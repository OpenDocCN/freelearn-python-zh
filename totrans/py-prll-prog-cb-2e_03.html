<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Process-Based Parallelism</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In</span><span><span class="koboSpan" id="kobo.3.1"> </span></span><span class="koboSpan" id="kobo.4.1">the previous chapter, we learned how to use threads to implement concurrent applications. </span><span class="koboSpan" id="kobo.4.2">This chapter will examine the process-based approach that we introduced in </span><a href="64fc65f9-fe29-4c34-9da7-13f272eaab9e.xhtml"><span class="koboSpan" id="kobo.5.1">Chapter 1</span></a><span class="koboSpan" id="kobo.6.1">, </span><em><span class="koboSpan" id="kobo.7.1">Getting Started with Parallel Computing and Python</span></em><span class="koboSpan" id="kobo.8.1">. </span><span><span class="koboSpan" id="kobo.9.1">In particular, the focus of the chapter is on the Python</span></span><span><span class="koboSpan" id="kobo.10.1"> </span></span><kbd><span class="koboSpan" id="kobo.11.1">multiprocessing</span></kbd><span><span class="koboSpan" id="kobo.12.1"> </span></span><span><span class="koboSpan" id="kobo.13.1">module.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">The Python </span><kbd><span class="koboSpan" id="kobo.15.1">multiprocessing</span></kbd><span class="koboSpan" id="kobo.16.1"> module, which is a part of the standard library of the language, implements the shared memory programming paradigm, that is, the programming of a system that consists of </span><em><span class="koboSpan" id="kobo.17.1">one or more processors</span></em><span class="koboSpan" id="kobo.18.1"> that have access to a shared memory.</span></p>
<p><span class="koboSpan" id="kobo.19.1">In this chapter, we will cover the following recipes:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.20.1">Understanding Python's </span><kbd><span class="koboSpan" id="kobo.21.1">multiprocessing</span></kbd><span class="koboSpan" id="kobo.22.1"> module</span></li>
<li><span class="koboSpan" id="kobo.23.1">Spawning a process</span></li>
<li><span class="koboSpan" id="kobo.24.1">Naming a process</span></li>
<li><span class="koboSpan" id="kobo.25.1">Running processes in the background</span></li>
<li><span class="koboSpan" id="kobo.26.1">Killing a process</span></li>
<li><span class="koboSpan" id="kobo.27.1">Defining a process in a subclass</span></li>
<li><span class="koboSpan" id="kobo.28.1">Using a queue to exchange objects</span></li>
<li><span class="koboSpan" id="kobo.29.1">Using pipes to exchange objects</span></li>
<li><span class="koboSpan" id="kobo.30.1">Synchronizing processes</span></li>
<li><span class="koboSpan" id="kobo.31.1">Managing a state between processes</span></li>
<li><span class="koboSpan" id="kobo.32.1">Using a process pool</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Understanding Python's multiprocessing module </span></h1>
                </header>
            
            <article>
                
<p><span><span class="koboSpan" id="kobo.2.1">The introduction of the Python </span><kbd><span class="koboSpan" id="kobo.3.1">multiprocessing</span></kbd></span><span><span class="koboSpan" id="kobo.4.1"> </span></span><span><span class="koboSpan" id="kobo.5.1">documentation (</span></span><a href="https://docs.python.org/2.7/library/multiprocessing.html#introduction"><span class="koboSpan" id="kobo.6.1">https://docs.python.org/2.7/library/multiprocessing.html#introduction</span></a><span><span class="koboSpan" id="kobo.7.1">) clearly mentions that all the functionality within this package requires the </span><kbd><span class="koboSpan" id="kobo.8.1">main</span></kbd><span class="koboSpan" id="kobo.9.1"> module to be importable to the children (</span></span><a href="https://docs.python.org/3.3/library/multiprocessing.html"><span class="koboSpan" id="kobo.10.1">https://docs.python.org/3.3/library/multiprocessing.html</span></a><span><span class="koboSpan" id="kobo.11.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">The </span><kbd><span class="koboSpan" id="kobo.13.1">__main__</span></kbd><span class="koboSpan" id="kobo.14.1"> module is not importable to the children in IDLE, even if you run the script as a file with IDLE. </span><span class="koboSpan" id="kobo.14.2">To get the correct result, we will run all the examples from Command Prompt:</span></p>
<pre><strong><span class="koboSpan" id="kobo.15.1">&gt; python multiprocessing_example.py</span></strong></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.16.1">Here, </span><kbd><span class="koboSpan" id="kobo.17.1">multiprocessing_example.py</span></kbd><span class="koboSpan" id="kobo.18.1"> is the script's name.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Spawning a process </span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Spawning a process is the creation of a </span><em><span class="koboSpan" id="kobo.3.1">child process</span></em><span class="koboSpan" id="kobo.4.1"> from a </span><em><span class="koboSpan" id="kobo.5.1">parent process.</span></em><span class="koboSpan" id="kobo.6.1"> The latter continues its execution asynchronously or waits until the child process ends.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The </span><kbd><span class="koboSpan" id="kobo.3.1">multiprocessing</span></kbd><span class="koboSpan" id="kobo.4.1"> library allows spawning processes by following these steps:</span></p>
<ol>
<li><em><span class="koboSpan" id="kobo.5.1">Define</span></em><span class="koboSpan" id="kobo.6.1"> the </span><kbd><span class="koboSpan" id="kobo.7.1">process</span></kbd><span class="koboSpan" id="kobo.8.1"> object.</span></li>
<li><em><span class="koboSpan" id="kobo.9.1">Call</span></em><span class="koboSpan" id="kobo.10.1"> the </span><kbd><span class="koboSpan" id="kobo.11.1">start()</span></kbd><span class="koboSpan" id="kobo.12.1"> method of the process to run it.</span></li>
<li><em><span class="koboSpan" id="kobo.13.1">Call</span></em><span class="koboSpan" id="kobo.14.1"> the </span><kbd><span class="koboSpan" id="kobo.15.1">join()</span></kbd><span class="koboSpan" id="kobo.16.1"> method of the process. </span><span class="koboSpan" id="kobo.16.2">It waits until the process has completed the job and then exits.</span></li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's have a look at the following steps:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.3.1">To create a process, we need to import the </span><kbd><span class="koboSpan" id="kobo.4.1">multiprocessing</span></kbd><span class="koboSpan" id="kobo.5.1"> module with the following command:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.6.1">import multiprocessing</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.7.1">Each process is associated with the </span><kbd><span class="koboSpan" id="kobo.8.1">myFunc(i)</span></kbd><span class="koboSpan" id="kobo.9.1"> </span><span><span class="koboSpan" id="kobo.10.1">function. </span><span class="koboSpan" id="kobo.10.2">T</span></span><span class="koboSpan" id="kobo.11.1">his function outputs the numbers from </span><kbd><span class="koboSpan" id="kobo.12.1">0</span></kbd><span class="koboSpan" id="kobo.13.1"> to </span><kbd><span class="koboSpan" id="kobo.14.1">i</span></kbd><span class="koboSpan" id="kobo.15.1">, where </span><kbd><span class="koboSpan" id="kobo.16.1">i</span></kbd><span class="koboSpan" id="kobo.17.1"> is the ID associated with the process number:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.18.1">def myFunc(i):</span><br/><span class="koboSpan" id="kobo.19.1">    print ('calling myFunc from process n°: %s' %i)</span><br/><span class="koboSpan" id="kobo.20.1">    for j in range (0,i):</span><br/><span class="koboSpan" id="kobo.21.1">        print('output from myFunc is :%s' %j)</span><br/>    </pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.22.1">Then, we define the </span><kbd><span class="koboSpan" id="kobo.23.1">process</span></kbd><span class="koboSpan" id="kobo.24.1"> object with </span><kbd><span class="koboSpan" id="kobo.25.1">myFunc</span></kbd><span class="koboSpan" id="kobo.26.1"> as the </span><kbd><span class="koboSpan" id="kobo.27.1">target</span></kbd><span class="koboSpan" id="kobo.28.1"> function:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.29.1">if __name__ == '__main__':</span><br/><span class="koboSpan" id="kobo.30.1">    for i in range(6):</span><br/><span class="koboSpan" id="kobo.31.1">        process = multiprocessing.Process(target=myFunc, args=(i,))</span></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.32.1">Finally, we call the </span><kbd><span class="koboSpan" id="kobo.33.1">start</span></kbd><span class="koboSpan" id="kobo.34.1"> and </span><kbd><span class="koboSpan" id="kobo.35.1">join</span></kbd><span class="koboSpan" id="kobo.36.1"> methods on the process created:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.37.1">     process.start()</span><br/><span class="koboSpan" id="kobo.38.1">     process.join()</span></pre>
<p><span class="koboSpan" id="kobo.39.1"> Without the </span><kbd><span class="koboSpan" id="kobo.40.1">join</span></kbd><span class="koboSpan" id="kobo.41.1"> method, child processes do not end and must be killed manually.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this section, we have therefore seen how it is possible to create processes by starting from a parent process. </span><span class="koboSpan" id="kobo.2.2">This feature is called </span><em><span class="koboSpan" id="kobo.3.1">spawning a process</span></em><span class="koboSpan" id="kobo.4.1">. </span></p>
<p><span class="koboSpan" id="kobo.5.1">Python's </span><kbd><span class="koboSpan" id="kobo.6.1">multiprocessing</span></kbd><span class="koboSpan" id="kobo.7.1"> library allows easy process management by following three simple steps. </span><span class="koboSpan" id="kobo.7.2">The first step is the process definition through the </span><kbd><span class="koboSpan" id="kobo.8.1">multiprocessing</span></kbd><span class="koboSpan" id="kobo.9.1"> class method, </span><kbd><span class="koboSpan" id="kobo.10.1">Process</span></kbd><span class="koboSpan" id="kobo.11.1">:</span></p>
<pre><span class="koboSpan" id="kobo.12.1">process = multiprocessing.Process(target=myFunc, args=(i,))</span></pre>
<p><span class="koboSpan" id="kobo.13.1">The </span><kbd><span class="koboSpan" id="kobo.14.1">Process</span></kbd><span class="koboSpan" id="kobo.15.1"> method has as an argument of the function to spawn,</span><span><span class="koboSpan" id="kobo.16.1"> </span></span><kbd><span class="koboSpan" id="kobo.17.1">myFunc</span></kbd><span class="koboSpan" id="kobo.18.1">, and any arguments of the function itself.</span></p>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.19.1">The following two steps are necessary to execute and exit the process:</span></p>
<pre><span class="koboSpan" id="kobo.20.1">     process.start()</span><br/><span class="koboSpan" id="kobo.21.1">     process.join()</span></pre>
<p><span class="koboSpan" id="kobo.22.1">To run the process and display the results, let's open Command Prompt, preferably in the same folder containing the example file (</span><kbd><span class="koboSpan" id="kobo.23.1">spawning_processes.py</span></kbd><span class="koboSpan" id="kobo.24.1">), and then type the following command:</span></p>
<pre><strong><span class="koboSpan" id="kobo.25.1">&gt; python spawning_processes.py</span></strong></pre>
<p><span class="koboSpan" id="kobo.26.1">For each process created (there are six in all), the output of the target function is shown. Remember that this is a simple counter from </span><kbd><span class="koboSpan" id="kobo.27.1">0</span></kbd><span class="koboSpan" id="kobo.28.1"> up to the index of the process ID:</span></p>
<pre><strong><span class="koboSpan" id="kobo.29.1">calling myFunc from process n°: 0</span></strong><br/><strong><span class="koboSpan" id="kobo.30.1">calling myFunc from process n°: 1</span></strong><br/><strong><span class="koboSpan" id="kobo.31.1">output from myFunc is :0</span></strong><br/><strong><span class="koboSpan" id="kobo.32.1">calling myFunc from process n°: 2</span></strong><br/><strong><span class="koboSpan" id="kobo.33.1">output from myFunc is :0</span></strong><br/><strong><span class="koboSpan" id="kobo.34.1">output from myFunc is :1</span></strong><br/><strong><span class="koboSpan" id="kobo.35.1">calling myFunc from process n°: 3</span></strong><br/><strong><span class="koboSpan" id="kobo.36.1">output from myFunc is :0</span></strong><br/><strong><span class="koboSpan" id="kobo.37.1">output from myFunc is :1</span></strong><br/><strong><span class="koboSpan" id="kobo.38.1">output from myFunc is :2</span></strong><br/><strong><span class="koboSpan" id="kobo.39.1">calling myFunc from process n°: 4</span></strong><br/><strong><span class="koboSpan" id="kobo.40.1">o</span></strong><strong><span class="koboSpan" id="kobo.41.1">utput from myFunc is :0</span></strong><br/><strong><span class="koboSpan" id="kobo.42.1">output from myFunc is :1</span></strong><br/><strong><span class="koboSpan" id="kobo.43.1">output from myFunc is :2</span></strong><br/><strong><span class="koboSpan" id="kobo.44.1">output from myFunc is :3</span></strong><br/><strong><span class="koboSpan" id="kobo.45.1">calling myFunc from process n°: 5</span></strong><br/><strong><span class="koboSpan" id="kobo.46.1">output from myFunc is :0</span></strong><br/><strong><span class="koboSpan" id="kobo.47.1">output from myFunc is :1</span></strong><br/><strong><span class="koboSpan" id="kobo.48.1">output from myFunc is :2</span></strong><br/><strong><span class="koboSpan" id="kobo.49.1">output from myFunc is :3</span></strong><br/><strong><span class="koboSpan" id="kobo.50.1">output from myFunc is :4</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">This reminds us once again of the importance of instantiating the </span><kbd><span class="koboSpan" id="kobo.3.1">Process</span></kbd><span class="koboSpan" id="kobo.4.1"> object within the main section: this is because the child process created imports the script file where the </span><kbd><span class="koboSpan" id="kobo.5.1">target</span></kbd><span class="koboSpan" id="kobo.6.1"> function is contained. </span><span class="koboSpan" id="kobo.6.2">Then, by instantiating the </span><kbd><span class="koboSpan" id="kobo.7.1">process</span></kbd><span class="koboSpan" id="kobo.8.1"> object within this block, we prevent an infinite recursive call of such instantiations.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.9.1">A valid workaround is used to define the </span><kbd><span class="koboSpan" id="kobo.10.1">target</span></kbd><span class="koboSpan" id="kobo.11.1"> function in a different script, namely </span><kbd><span class="koboSpan" id="kobo.12.1">myFunc.py</span></kbd><span class="koboSpan" id="kobo.13.1">:</span></p>
<pre><span class="koboSpan" id="kobo.14.1">def myFunc(i):</span><br/><span class="koboSpan" id="kobo.15.1">    print ('calling myFunc from process n°: %s' %i)</span><br/><span class="koboSpan" id="kobo.16.1">    for j in range (0,i):</span><br/><span class="koboSpan" id="kobo.17.1">        print('output from myFunc is :%s' %j)</span><br/><span class="koboSpan" id="kobo.18.1">    return</span></pre>
<p><span class="koboSpan" id="kobo.19.1">The </span><kbd><span class="koboSpan" id="kobo.20.1">main</span></kbd><span class="koboSpan" id="kobo.21.1"> program containing the process instance is defined in a second file (</span><kbd><span class="koboSpan" id="kobo.22.1">spawning_processes_namespace.py</span></kbd><span class="koboSpan" id="kobo.23.1">):</span></p>
<pre><span class="koboSpan" id="kobo.24.1">import multiprocessing</span><br/><span class="koboSpan" id="kobo.25.1">from myFunc import myFunc</span><br/><br/><span class="koboSpan" id="kobo.26.1">if __name__ == '__main__':</span><br/><span class="koboSpan" id="kobo.27.1">    for i in range(6):</span><br/><span class="koboSpan" id="kobo.28.1">        process = multiprocessing.Process(target=myFunc, args=(i,))</span><br/><span class="koboSpan" id="kobo.29.1">        process.start()</span><br/><span class="koboSpan" id="kobo.30.1">        process.join()</span></pre>
<p><span class="koboSpan" id="kobo.31.1">To run this example, type the following command:</span></p>
<pre><strong><span class="koboSpan" id="kobo.32.1">&gt; python spawning_processes_names.py</span></strong></pre>
<p><span class="koboSpan" id="kobo.33.1">The output is the same as the previous example.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">See also</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The official guide for the </span><kbd><span class="koboSpan" id="kobo.3.1">multiprocessing</span></kbd><span class="koboSpan" id="kobo.4.1"> library can be found at </span><a href="https://docs.python.org/3/"><span class="koboSpan" id="kobo.5.1">https://docs.python.org/3/</span></a><span class="koboSpan" id="kobo.6.1">.</span><a href="https://docs.python.org/3/"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Naming a process</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In the previous example, we identified the processes and how to pass a variable to the target function. </span><span class="koboSpan" id="kobo.2.2">However, it is very useful to associate a name to the processes as debugging an application requires the processes to be well marked and identifiable.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">At some point in your code, it may be crucial to know what process is </span><span><span class="koboSpan" id="kobo.3.1">currently </span></span><span class="koboSpan" id="kobo.4.1">being executed. </span><span class="koboSpan" id="kobo.4.2">For this purpose, the </span><kbd><span class="koboSpan" id="kobo.5.1">multiprocessing</span></kbd><span class="koboSpan" id="kobo.6.1"> library provides the </span><kbd><span class="koboSpan" id="kobo.7.1">current_process()</span></kbd><span class="koboSpan" id="kobo.8.1"> method, which uses the </span><kbd><span class="koboSpan" id="kobo.9.1">name</span></kbd><span class="koboSpan" id="kobo.10.1"> attribute to identify which process is</span><span><span class="koboSpan" id="kobo.11.1"> currently running</span></span><span class="koboSpan" id="kobo.12.1">. </span><span class="koboSpan" id="kobo.12.2">In the following section, we'll learn about this topic.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's perform the following steps:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.3.1">The </span><kbd><span class="koboSpan" id="kobo.4.1">target</span></kbd><span class="koboSpan" id="kobo.5.1"> function for both the processes is the </span><kbd><span class="koboSpan" id="kobo.6.1">myFunc</span></kbd><span class="koboSpan" id="kobo.7.1"> function. </span><span class="koboSpan" id="kobo.7.2">It outputs the process name by evaluating the </span><kbd><span class="koboSpan" id="kobo.8.1">multiprocessing.current_process().name</span></kbd> <span><span class="koboSpan" id="kobo.9.1">method:</span></span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.10.1">import multiprocessing</span><br/><span class="koboSpan" id="kobo.11.1">import time</span><br/><br/><span class="koboSpan" id="kobo.12.1">def myFunc():</span><br/><span class="koboSpan" id="kobo.13.1">    name = multiprocessing.current_process().name</span><br/><span class="koboSpan" id="kobo.14.1">    print ("Starting process name = %s \n" %name)</span><br/><span class="koboSpan" id="kobo.15.1">    time.sleep(3)</span><br/><span class="koboSpan" id="kobo.16.1">    print ("Exiting process name = %s \n" %name)</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.17.1">Then, we create </span><kbd><span class="koboSpan" id="kobo.18.1">process_with_name</span></kbd><span class="koboSpan" id="kobo.19.1"> simply by instantiating the </span><kbd><span class="koboSpan" id="kobo.20.1">name</span></kbd><span class="koboSpan" id="kobo.21.1"> parameter and </span><kbd><span class="koboSpan" id="kobo.22.1">process_with_default_name</span></kbd><span class="koboSpan" id="kobo.23.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.24.1">if __name__ == '__main__':</span><br/><span class="koboSpan" id="kobo.25.1">    process_with_name = multiprocessing.Process\</span><br/><span class="koboSpan" id="kobo.26.1">                        (name='myFunc process',\</span><br/><span class="koboSpan" id="kobo.27.1">                          target=myFunc)</span><br/><br/><span class="koboSpan" id="kobo.28.1">    process_with_default_name = multiprocessing.Process\</span><br/><span class="koboSpan" id="kobo.29.1">                                (target=myFunc)</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.30.1">Finally, the processes are started and then joined:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.31.1">    process_with_name.start()</span><br/><span class="koboSpan" id="kobo.32.1">    process_with_default_name.start()</span><br/><span class="koboSpan" id="kobo.33.1">    process_with_name.join()</span><br/><span class="koboSpan" id="kobo.34.1">    process_with_default_name.join()</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In the </span><kbd><span class="koboSpan" id="kobo.3.1">main</span></kbd><span class="koboSpan" id="kobo.4.1"> program, the processes are created using the same target function, </span><kbd><span class="koboSpan" id="kobo.5.1">myFunc</span></kbd><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">This function simply prints the process name.</span></p>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.7.1">To run the example, open Command Prompt and type the following command:</span></p>
<pre><strong><span class="koboSpan" id="kobo.8.1">&gt; python naming_processes.py</span></strong></pre>
<p><span class="koboSpan" id="kobo.9.1">The output looks like this:</span></p>
<pre><strong><span class="koboSpan" id="kobo.10.1">Starting process name = myFunc process</span></strong><br/><strong><span class="koboSpan" id="kobo.11.1">Starting process name = Process-2</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.12.1">Exiting process name = Process-2</span></strong><br/><strong><span class="koboSpan" id="kobo.13.1">Exiting process name = myFunc process</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The main Python process is </span><kbd><span class="koboSpan" id="kobo.3.1">multiprocessing.process._MainProcess</span></kbd><span class="koboSpan" id="kobo.4.1">, while child processes are </span><kbd><span class="koboSpan" id="kobo.5.1">multiprocessing.process.Process</span></kbd><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">It can be tested by </span><span><span class="koboSpan" id="kobo.7.1">simply </span></span><span class="koboSpan" id="kobo.8.1">typing the following:</span></p>
<pre><strong><span class="koboSpan" id="kobo.9.1">&gt;&gt;&gt; import multiprocessing</span></strong><br/><strong><span class="koboSpan" id="kobo.10.1">&gt;&gt;&gt; multiprocessing.current_process().name</span></strong><br/><strong><span class="koboSpan" id="kobo.11.1">'MainProcess'</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">See also</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">More on this topic can be found at </span><a href="https://doughellmann.com/blog/2012/04/30/determining-the-name-of-a-process-from-python/"><span class="koboSpan" id="kobo.3.1">https://doughellmann.com/blog/2012/04/30/determining-the-name-of-a-process-from-python/</span></a><span class="koboSpan" id="kobo.4.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Running processes in the background</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Running in the background is a mode of execution that is typical of some programs that do not require the presence or intervention of the user, and which may be concurrent to the execution of other programs (and therefore, it is only possible in multitasking systems), resulting in the user being unaware about it. Background programs typically perform</span><span><span class="koboSpan" id="kobo.3.1"> </span></span><span class="koboSpan" id="kobo.4.1">long</span><span><span class="koboSpan" id="kobo.5.1"> </span></span><span class="koboSpan" id="kobo.6.1">or time-consuming tasks such as peer-to-peer filesharing programs or defragmentation of filesystems. </span><span class="koboSpan" id="kobo.6.2">Many OS processes also run in the background.</span></p>
<p><span class="koboSpan" id="kobo.7.1">In Windows, programs in this mode (scanning antiviruses or OS updates) often place an icon in the system tray (the area of the desktop next to the system clock) in order to signal their activity and adopt behaviors that reduce the use of resources so as to not interfere with the user's interactive activities, such as slowing down or causing interruptions. </span><span class="koboSpan" id="kobo.7.2">In Unix and Unix-like systems, processes that run in the</span><span><span class="koboSpan" id="kobo.8.1"> </span></span><span class="koboSpan" id="kobo.9.1">background</span><span><span class="koboSpan" id="kobo.10.1"> </span></span><span class="koboSpan" id="kobo.11.1">are called</span><span><span class="koboSpan" id="kobo.12.1"> </span></span><strong><span class="koboSpan" id="kobo.13.1">daemons</span></strong><span class="koboSpan" id="kobo.14.1">. </span><span class="koboSpan" id="kobo.14.2">Using a task manager can highlight all running programs including those in the background.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The </span><kbd><span class="koboSpan" id="kobo.3.1">multiprocessing</span></kbd><span class="koboSpan" id="kobo.4.1"> module allows—through the daemonic option—to run background processes. </span><span class="koboSpan" id="kobo.4.2">In the following example, two processes are defined:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.5.1">background_process</span></kbd><span class="koboSpan" id="kobo.6.1"> with their </span><kbd><span class="koboSpan" id="kobo.7.1">daemon</span></kbd><span class="koboSpan" id="kobo.8.1"> parameter set to </span><kbd><span class="koboSpan" id="kobo.9.1">True</span></kbd></li>
<li><kbd><span class="koboSpan" id="kobo.10.1">NO_background_process</span></kbd><span class="koboSpan" id="kobo.11.1"> with their </span><kbd><span class="koboSpan" id="kobo.12.1">daemon</span></kbd><span class="koboSpan" id="kobo.13.1"> parameter set to </span><kbd><span class="koboSpan" id="kobo.14.1">False</span></kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In the following example, we implement a target function, namely </span><kbd><span class="koboSpan" id="kobo.3.1">foo</span></kbd><span class="koboSpan" id="kobo.4.1">, which displays the digits from </span><kbd><span class="koboSpan" id="kobo.5.1">0</span></kbd><span class="koboSpan" id="kobo.6.1"> to </span><kbd><span class="koboSpan" id="kobo.7.1">4</span></kbd> <strong><span class="koboSpan" id="kobo.8.1">if</span></strong><span class="koboSpan" id="kobo.9.1"> the child process is in the </span><strong><span class="koboSpan" id="kobo.10.1">background</span></strong><span class="koboSpan" id="kobo.11.1">; otherwise, it prints the digits from </span><kbd><span class="koboSpan" id="kobo.12.1">5</span></kbd><span class="koboSpan" id="kobo.13.1"> to </span><kbd><span class="koboSpan" id="kobo.14.1">9</span></kbd><span class="koboSpan" id="kobo.15.1">:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.16.1">Let's import the relevant libraries:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.17.1">import multiprocessing</span><br/><span class="koboSpan" id="kobo.18.1">import time</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.19.1">Then, we define the </span><kbd><span class="koboSpan" id="kobo.20.1">foo()</span></kbd><span class="koboSpan" id="kobo.21.1"> function. </span><span class="koboSpan" id="kobo.21.2">As previously specified, the printed digits depend on the value of the </span><kbd><span class="koboSpan" id="kobo.22.1">name</span></kbd><span class="koboSpan" id="kobo.23.1"> parameter:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.24.1">def foo():</span><br/><span class="koboSpan" id="kobo.25.1">    name = multiprocessing.current_process().name</span><br/><span class="koboSpan" id="kobo.26.1">    print ("Starting %s \n" %name)</span><br/><span class="koboSpan" id="kobo.27.1">    if name == 'background_process':</span><br/><span class="koboSpan" id="kobo.28.1">        for i in range(0,5):</span><br/><span class="koboSpan" id="kobo.29.1">            print('---&gt; %d \n' %i)</span><br/><span class="koboSpan" id="kobo.30.1">        time.sleep(1)</span><br/><span class="koboSpan" id="kobo.31.1">    else:</span><br/><span class="koboSpan" id="kobo.32.1">        for i in range(5,10):</span><br/><span class="koboSpan" id="kobo.33.1">            print('---&gt; %d \n' %i)</span><br/><span class="koboSpan" id="kobo.34.1">        time.sleep(1)</span><br/><span class="koboSpan" id="kobo.35.1">    print ("Exiting %s \n" %name)</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.36.1">Finally, we define the following processes: </span><kbd><span class="koboSpan" id="kobo.37.1">background_process</span></kbd><span class="koboSpan" id="kobo.38.1"> and </span><kbd><span class="koboSpan" id="kobo.39.1">NO_background_process</span></kbd><span class="koboSpan" id="kobo.40.1">. </span><span class="koboSpan" id="kobo.40.2">Notice that the </span><kbd><span class="koboSpan" id="kobo.41.1">daemon</span></kbd><span class="koboSpan" id="kobo.42.1"> </span><span><span class="koboSpan" id="kobo.43.1">parameter is </span></span><span class="koboSpan" id="kobo.44.1">set for the two processes:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.45.1">if __name__ == '__main__':</span><br/><span class="koboSpan" id="kobo.46.1">    background_process = multiprocessing.Process\</span><br/><span class="koboSpan" id="kobo.47.1">                         (name='background_process',\</span><br/><span class="koboSpan" id="kobo.48.1">                          target=foo)</span><br/><span class="koboSpan" id="kobo.49.1">    background_process.daemon = True</span><br/><br/><span class="koboSpan" id="kobo.50.1">    NO_background_process = multiprocessing.Process\</span><br/><span class="koboSpan" id="kobo.51.1">                            (name='NO_background_process',\</span><br/><span class="koboSpan" id="kobo.52.1">                             target=foo)</span><br/>    <br/><span class="koboSpan" id="kobo.53.1">    NO_background_process.daemon = False</span><br/>    <br/><span class="koboSpan" id="kobo.54.1">    background_process.start()</span><br/><span class="koboSpan" id="kobo.55.1">    NO_background_process.start()</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Note that only the </span><kbd><span class="koboSpan" id="kobo.3.1">daemon</span></kbd><span class="koboSpan" id="kobo.4.1"> parameter of the process defines whether the process should run in the background or not. </span><span class="koboSpan" id="kobo.4.2">To run this example, type the following command:</span></p>
<pre><strong><span class="koboSpan" id="kobo.5.1">&gt; python run_background_processes.py</span></strong></pre>
<p><span class="koboSpan" id="kobo.6.1">The output clearly reports only the </span><kbd><span class="koboSpan" id="kobo.7.1">NO_background_process</span></kbd><span class="koboSpan" id="kobo.8.1"> output:</span></p>
<pre><strong><span class="koboSpan" id="kobo.9.1">Starting NO_background_process</span></strong><br/><strong><span class="koboSpan" id="kobo.10.1">---&gt; 5</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.11.1">---&gt; 6</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.12.1">---&gt; 7</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.13.1">---&gt; 8</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.14.1">---&gt; 9</span></strong><br/><strong><span class="koboSpan" id="kobo.15.1">Exiting NO_background_process</span></strong></pre>
<p><span class="koboSpan" id="kobo.16.1">The output changes the setting of the </span><kbd><span class="koboSpan" id="kobo.17.1">daemon</span></kbd><span class="koboSpan" id="kobo.18.1"> parameter for </span><kbd><span class="koboSpan" id="kobo.19.1">background_process</span></kbd><span class="koboSpan" id="kobo.20.1"> to </span><kbd><span class="koboSpan" id="kobo.21.1">False</span></kbd><span class="koboSpan" id="kobo.22.1">:</span></p>
<pre><span class="koboSpan" id="kobo.23.1">background_process.daemon = False</span></pre>
<p><span class="koboSpan" id="kobo.24.1">To run this example, type the following:</span></p>
<pre><strong><span class="koboSpan" id="kobo.25.1">C:\&gt;python run_background_processes_no_daemons.py</span></strong></pre>
<p><span class="koboSpan" id="kobo.26.1">The output reports the execution of both the </span><kbd><span class="koboSpan" id="kobo.27.1">background_process</span></kbd><span class="koboSpan" id="kobo.28.1"> and </span><kbd><span class="koboSpan" id="kobo.29.1">NO_background_process</span></kbd><span class="koboSpan" id="kobo.30.1"> </span><span><span class="koboSpan" id="kobo.31.1">processes:</span></span></p>
<pre><strong><span class="koboSpan" id="kobo.32.1">Starting NO_background_process</span></strong><br/><strong><span class="koboSpan" id="kobo.33.1">Starting background_process</span></strong><br/><strong><span class="koboSpan" id="kobo.34.1">---&gt; 5</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.35.1">---&gt; 0</span></strong><br/><strong><span class="koboSpan" id="kobo.36.1">---&gt; 6</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.37.1">---&gt; 1</span></strong><br/><strong><span class="koboSpan" id="kobo.38.1">---&gt; 7</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.39.1">---&gt; 2</span></strong><br/><strong><span class="koboSpan" id="kobo.40.1">---&gt; 8</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.41.1">---&gt; 3</span></strong><br/><strong><span class="koboSpan" id="kobo.42.1">---&gt; 9</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.43.1">---&gt; 4</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.44.1">Exiting NO_background_process</span></strong><br/><strong><span class="koboSpan" id="kobo.45.1">Exiting background_process</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">See also</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A code snippet on how to run a Python script in the background in Linux can be found at </span><a href="https://janakiev.com/til/python-background/"><span class="koboSpan" id="kobo.3.1">https://janakiev.com/til/python-background/</span></a><span class="koboSpan" id="kobo.4.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Killing a process</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">There is no perfect software and even in the best applications, you can nest a bug that leads to blocking the application, which is why modern OSes have developed several methods to terminate the processes of applications in order to free the system resources and allow the user to use them for other operations as soon as possible. </span><span class="koboSpan" id="kobo.2.2">This section will show you how to kill a process in your multiprocessing application.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">It's possible to kill a process immediately by using the </span><kbd><span class="koboSpan" id="kobo.3.1">terminate</span></kbd><span class="koboSpan" id="kobo.4.1"> method. </span><span class="koboSpan" id="kobo.4.2">Also, we use the </span><kbd><span class="koboSpan" id="kobo.5.1">is_alive</span></kbd><span class="koboSpan" id="kobo.6.1"> method to keep track of whether the process is alive or not.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The following steps </span><span><span class="koboSpan" id="kobo.3.1">allow us to perform the recipe</span></span><span class="koboSpan" id="kobo.4.1">:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.5.1">Let's import the relevant libraries:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.6.1">import multiprocessing</span><br/><span class="koboSpan" id="kobo.7.1">import time</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.8.1">Then, a simple </span><kbd><span class="koboSpan" id="kobo.9.1">target</span></kbd><span class="koboSpan" id="kobo.10.1"> function is implemented. </span><span class="koboSpan" id="kobo.10.2">In this example, the </span><kbd><span class="koboSpan" id="kobo.11.1">target</span></kbd><span class="koboSpan" id="kobo.12.1"> function, </span><kbd><span class="koboSpan" id="kobo.13.1">foo()</span></kbd><span class="koboSpan" id="kobo.14.1">, prints the first </span><kbd><span class="koboSpan" id="kobo.15.1">10</span></kbd><span class="koboSpan" id="kobo.16.1"> digits:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.17.1">def foo():</span><br/><span class="koboSpan" id="kobo.18.1">    print ('Starting function')</span><br/><span class="koboSpan" id="kobo.19.1">    for i in range(0,10):</span><br/><span class="koboSpan" id="kobo.20.1">        print('--&gt;%d\n' %i)</span><br/><span class="koboSpan" id="kobo.21.1">        time.sleep(1)</span><br/><span class="koboSpan" id="kobo.22.1">    print ('Finished function')</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.23.1">In the </span><kbd><span class="koboSpan" id="kobo.24.1">main</span></kbd><span class="koboSpan" id="kobo.25.1"> program, we create a process monitoring its lifetime by the </span><kbd><span class="koboSpan" id="kobo.26.1">is_alive</span></kbd><span class="koboSpan" id="kobo.27.1"> method; then, we finish it with a call to </span><kbd><span class="koboSpan" id="kobo.28.1">terminate</span></kbd><span class="koboSpan" id="kobo.29.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.30.1">if __name__ == '__main__':</span><br/><span class="koboSpan" id="kobo.31.1">    p = multiprocessing.Process(target=foo)</span><br/><span class="koboSpan" id="kobo.32.1">    print ('Process before execution:', p, p.is_alive())</span><br/><span class="koboSpan" id="kobo.33.1">    p.start()</span><br/><span class="koboSpan" id="kobo.34.1">    print ('Process running:', p, p.is_alive())</span><br/><span class="koboSpan" id="kobo.35.1">    p.terminate()</span><br/><span class="koboSpan" id="kobo.36.1">    print ('Process terminated:', p, p.is_alive())</span><br/><span class="koboSpan" id="kobo.37.1">    p.join()</span><br/><span class="koboSpan" id="kobo.38.1">    print ('Process joined:', p, p.is_alive())</span></pre>
<ol start="4">
<li><span><span class="koboSpan" id="kobo.39.1">Then, we verify the status code when the process is finished and read the attribute of the</span></span> <kbd><span class="koboSpan" id="kobo.40.1">ExitCode</span></kbd> <span><span class="koboSpan" id="kobo.41.1">process:</span></span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.42.1">    print ('Process exit code:', p.exitcode)</span></pre>
<ol start="5">
<li><span class="koboSpan" id="kobo.43.1">The possible values of </span><kbd><span class="koboSpan" id="kobo.44.1">ExitCode</span></kbd><span class="koboSpan" id="kobo.45.1"> are as follows:</span></li>
</ol>
<ul>
<li style="padding-left: 30px"><kbd><span class="koboSpan" id="kobo.46.1">== 0</span></kbd><span class="koboSpan" id="kobo.47.1">: No error was produced.</span></li>
<li style="padding-left: 30px"><kbd><span class="koboSpan" id="kobo.48.1">&gt; 0</span></kbd><span class="koboSpan" id="kobo.49.1">: The process had an error and exited that code.</span></li>
<li style="padding-left: 30px"><kbd><span class="koboSpan" id="kobo.50.1">&lt; 0</span></kbd><span class="koboSpan" id="kobo.51.1">: The process was killed with a signal of </span><kbd><span class="koboSpan" id="kobo.52.1">-1 * ExitCode</span></kbd><span class="koboSpan" id="kobo.53.1">.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The sample code consists of a target function, </span><kbd><span class="koboSpan" id="kobo.3.1">foo()</span></kbd><span class="koboSpan" id="kobo.4.1">, whose task is to print out the first </span><kbd><span class="koboSpan" id="kobo.5.1">10</span></kbd><span class="koboSpan" id="kobo.6.1"> integer numbers on the screen. </span><span class="koboSpan" id="kobo.6.2">In the </span><kbd><span class="koboSpan" id="kobo.7.1">main</span></kbd><span class="koboSpan" id="kobo.8.1"> program, the process is executed and then killed by the </span><kbd><span class="koboSpan" id="kobo.9.1">terminate</span></kbd><span class="koboSpan" id="kobo.10.1"> instruction. </span><span class="koboSpan" id="kobo.10.2">The process is then joined and </span><kbd><span class="koboSpan" id="kobo.11.1">ExitCode</span></kbd><span class="koboSpan" id="kobo.12.1"> is determined.</span></p>
<p><span class="koboSpan" id="kobo.13.1">To run the code, type the following command:</span></p>
<pre><strong><span class="koboSpan" id="kobo.14.1">&gt; python killing_processes.py</span></strong></pre>
<p><span class="koboSpan" id="kobo.15.1">Then, </span><span><span class="koboSpan" id="kobo.16.1">we get</span></span> <span><span class="koboSpan" id="kobo.17.1">the </span></span><span class="koboSpan" id="kobo.18.1">following output:</span></p>
<pre><strong><span class="koboSpan" id="kobo.19.1">Process before execution: &lt;Process(Process-1, initial)&gt; False</span></strong><br/><strong><span class="koboSpan" id="kobo.20.1">Process running: &lt;Process(Process-1, started)&gt; True</span></strong><br/><strong><span class="koboSpan" id="kobo.21.1">Process terminated: &lt;Process(Process-1, started)&gt; True</span></strong><br/><strong><span class="koboSpan" id="kobo.22.1">Process joined: &lt;Process(Process-1, stopped[SIGTERM])&gt; False</span></strong><br/><strong><span class="koboSpan" id="kobo.23.1">Process exit code: -15</span></strong></pre>
<p><span class="koboSpan" id="kobo.24.1">Notice that the output value of the </span><kbd><span class="koboSpan" id="kobo.25.1">ExitCode</span></kbd><span class="koboSpan" id="kobo.26.1"> code is equal to </span><kbd><strong><span class="koboSpan" id="kobo.27.1">-</span></strong><span class="koboSpan" id="kobo.28.1">15</span></kbd><span class="koboSpan" id="kobo.29.1">. </span><span class="koboSpan" id="kobo.29.2">The negative value of </span><kbd><span class="koboSpan" id="kobo.30.1">-15</span></kbd><span class="koboSpan" id="kobo.31.1"> indicates that the child was terminated by an interrupt signal, which is identified by the number </span><kbd><span class="koboSpan" id="kobo.32.1">15</span></kbd><span class="koboSpan" id="kobo.33.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">See also</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">On a Linux machine, a Python process can be identified and then killed simply by following the tutorial at </span><a href="http://www.cagrimmett.com/til/2016/05/06/killing-rogue-python-processes.html"><span class="koboSpan" id="kobo.3.1">http://www.cagrimmett.com/til/2016/05/06/killing-rogue-python-processes.html</span></a><span class="koboSpan" id="kobo.4.1">.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Defining processes in a subclass</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The </span><kbd><span class="koboSpan" id="kobo.3.1">multiprocessing</span></kbd><span class="koboSpan" id="kobo.4.1"> module provides access to</span><span><span class="koboSpan" id="kobo.5.1"> </span></span><span class="koboSpan" id="kobo.6.1">process management functionalities. </span><span class="koboSpan" id="kobo.6.2">I</span><span><span class="koboSpan" id="kobo.7.1">n this section, we'll learn about how to define a process in a subclass of the</span></span> <kbd><span class="koboSpan" id="kobo.8.1">multiprocessing.Process</span></kbd> <span><span class="koboSpan" id="kobo.9.1">class.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">To implement a multiprocessing custom subclass, we need to do the following things:</span></p>
<ul>
<li><em><span class="koboSpan" id="kobo.3.1">Define</span></em><span class="koboSpan" id="kobo.4.1"> a subclass of the </span><kbd><span class="koboSpan" id="kobo.5.1">multiprocessing.Process</span></kbd><span class="koboSpan" id="kobo.6.1"> class, redefining the </span><kbd><span class="koboSpan" id="kobo.7.1">run()</span></kbd><span class="koboSpan" id="kobo.8.1"> method.</span></li>
<li><em><span class="koboSpan" id="kobo.9.1">Override</span></em><span class="koboSpan" id="kobo.10.1"> the </span><kbd><span class="koboSpan" id="kobo.11.1">_init__(self [,args])</span></kbd><span class="koboSpan" id="kobo.12.1"> method to add additional arguments, if needed.</span></li>
<li><em><span class="koboSpan" id="kobo.13.1">Override</span></em><span class="koboSpan" id="kobo.14.1"> the </span><kbd><span class="koboSpan" id="kobo.15.1">run(self [,args])</span></kbd><span class="koboSpan" id="kobo.16.1"> method to implement what </span><kbd><span class="koboSpan" id="kobo.17.1">Process</span></kbd><span class="koboSpan" id="kobo.18.1"> should do when it is started.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.19.1">Once you have created the new </span><kbd><span class="koboSpan" id="kobo.20.1">Process</span></kbd><span class="koboSpan" id="kobo.21.1"> subclass, you can create an instance of it and then start by invoking the </span><kbd><span class="koboSpan" id="kobo.22.1">start</span></kbd><span class="koboSpan" id="kobo.23.1"> method, which will, in turn, call the </span><kbd><span class="koboSpan" id="kobo.24.1">run</span></kbd><span class="koboSpan" id="kobo.25.1"> method.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Just consider a very simple example, as follows:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.3.1">Import the relevant library first:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.4.1">import multiprocessing</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.5.1">Then, define a subclass, </span><kbd><span class="koboSpan" id="kobo.6.1">MyProcess</span></kbd><span class="koboSpan" id="kobo.7.1">, overriding only the </span><kbd><span class="koboSpan" id="kobo.8.1">run</span></kbd><span class="koboSpan" id="kobo.9.1"> method, which returns the process' name:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.10.1">class MyProcess(multiprocessing.Process):</span><br/><br/><span class="koboSpan" id="kobo.11.1">    def run(self):</span><br/><span class="koboSpan" id="kobo.12.1">        print ('called run method by %s' %self.name)</span><br/><span class="koboSpan" id="kobo.13.1">        return</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="3">
<li><span class="koboSpan" id="kobo.14.1">In the </span><kbd><span class="koboSpan" id="kobo.15.1">main</span></kbd><span class="koboSpan" id="kobo.16.1"> program, we define a</span><span><span class="koboSpan" id="kobo.17.1"> subclass of</span></span><span class="koboSpan" id="kobo.18.1"> </span><kbd><span class="koboSpan" id="kobo.19.1">10</span></kbd><span class="koboSpan" id="kobo.20.1"> processes:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.21.1">if __name__ == '__main__':</span><br/><span class="koboSpan" id="kobo.22.1">    for i in range(10):</span><br/><span class="koboSpan" id="kobo.23.1">        process = MyProcess()</span><br/><span class="koboSpan" id="kobo.24.1">        process.start()</span><br/><span class="koboSpan" id="kobo.25.1">        process.join()</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Each process subclass is represented by a class that extends the </span><kbd><span class="koboSpan" id="kobo.3.1">Process</span></kbd><span class="koboSpan" id="kobo.4.1"> class and overrides the </span><kbd><span class="koboSpan" id="kobo.5.1">run()</span></kbd><span class="koboSpan" id="kobo.6.1"> method. </span><span class="koboSpan" id="kobo.6.2">This method is the starting point of </span><kbd><span class="koboSpan" id="kobo.7.1">Process</span></kbd><span class="koboSpan" id="kobo.8.1">:</span></p>
<pre><span class="koboSpan" id="kobo.9.1">class MyProcess (multiprocessing.Process):</span><br/><span class="koboSpan" id="kobo.10.1">    def run(self):</span><br/><span class="koboSpan" id="kobo.11.1">        print ('called run method in process: %s' %self.name)</span><br/><span class="koboSpan" id="kobo.12.1">        return</span></pre>
<p><span class="koboSpan" id="kobo.13.1">In the </span><kbd><span class="koboSpan" id="kobo.14.1">main</span></kbd><span class="koboSpan" id="kobo.15.1"> program, we create several objects of the </span><kbd><span class="koboSpan" id="kobo.16.1">MyProcess()</span></kbd><span class="koboSpan" id="kobo.17.1"> </span><span><span class="koboSpan" id="kobo.18.1">type.</span></span><span class="koboSpan" id="kobo.19.1"> The execution of the thread begins when the </span><kbd><span class="koboSpan" id="kobo.20.1">start()</span></kbd><span class="koboSpan" id="kobo.21.1"> method is called:</span></p>
<pre><span class="koboSpan" id="kobo.22.1">p = MyProcess()</span><br/><span class="koboSpan" id="kobo.23.1">p.start()</span></pre>
<p><span class="koboSpan" id="kobo.24.1">The </span><kbd><span class="koboSpan" id="kobo.25.1">join()</span></kbd><span class="koboSpan" id="kobo.26.1"> command just handles the termination of processes. </span><span class="koboSpan" id="kobo.26.2">To run the script from Command Prompt, type the following command:</span></p>
<pre><strong><span class="koboSpan" id="kobo.27.1">&gt; python process_in_subclass.py</span></strong></pre>
<p><span class="koboSpan" id="kobo.28.1">The output looks like this:</span></p>
<pre><strong><span class="koboSpan" id="kobo.29.1">called run method by MyProcess-1</span></strong><br/><strong><span class="koboSpan" id="kobo.30.1">called run method by MyProcess-2</span></strong><br/><strong><span class="koboSpan" id="kobo.31.1">called run method by MyProcess-3</span></strong><br/><strong><span class="koboSpan" id="kobo.32.1">called run method by MyProcess-4</span></strong><br/><strong><span class="koboSpan" id="kobo.33.1">called run method by MyProcess-5</span></strong><br/><strong><span class="koboSpan" id="kobo.34.1">called run method by MyProcess-6</span></strong><br/><strong><span class="koboSpan" id="kobo.35.1">called run method by MyProcess-7</span></strong><br/><strong><span class="koboSpan" id="kobo.36.1">called run method by MyProcess-8</span></strong><br/><strong><span class="koboSpan" id="kobo.37.1">called run method by MyProcess-9</span></strong><br/><strong><span class="koboSpan" id="kobo.38.1">called run method by MyProcess-10</span></strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In object-oriented programming, a subclass is a class that inherits all properties from a superclass, whether they are objects or methods. </span><span class="koboSpan" id="kobo.2.2">An alternative name to subclass is </span><em><span class="koboSpan" id="kobo.3.1">derived class</span></em><span class="koboSpan" id="kobo.4.1">. </span><em><span class="koboSpan" id="kobo.5.1">Inheritance</span></em><span class="koboSpan" id="kobo.6.1"> is the specific term that indicates this process by which the daughter or derived classes inherit the properties of parent classes or superclasses.</span></p>
<p><span class="koboSpan" id="kobo.7.1">You can think of a subclass as a particular genre of its superclass; in fact, it can use methods and/or attributes, as well as redefine them through </span><em><span class="koboSpan" id="kobo.8.1">overriding</span></em><span class="koboSpan" id="kobo.9.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">See also</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">More information on class definition techniques can be found at </span><a href="http://buildingskills.itmaybeahack.com/book/python-2.6/html/p03/p03c02_adv_class.html"><span class="koboSpan" id="kobo.3.1">http://buildingskills.itmaybeahack.com/book/python-2.6/html/p03/p03c02_adv_class.html</span></a><span class="koboSpan" id="kobo.4.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Using a queue to exchange data</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A </span><em><span class="koboSpan" id="kobo.3.1">queue</span></em><span class="koboSpan" id="kobo.4.1"> is a data structure of the </span><strong><span class="koboSpan" id="kobo.5.1">First-In, First-Out</span></strong><span class="koboSpan" id="kobo.6.1"> (</span><strong><span class="koboSpan" id="kobo.7.1">FIFO</span></strong><span class="koboSpan" id="kobo.8.1">) </span><span><span class="koboSpan" id="kobo.9.1">type </span></span><span class="koboSpan" id="kobo.10.1">(the first input is the first to exit). </span><span class="koboSpan" id="kobo.10.2">A practical example is the queues to get a service, how to pay at the supermarket, or get your hair cut at the hairdresser. </span><span class="koboSpan" id="kobo.10.3">Ideally, you are served in the same order as you were presented to. </span><span class="koboSpan" id="kobo.10.4">This is exactly how a FIFO queue works.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this section, we show you how to use a queue for a </span><em><span class="koboSpan" id="kobo.3.1">producer-consumer</span></em><span class="koboSpan" id="kobo.4.1"> problem, that</span><span><span class="koboSpan" id="kobo.5.1"> is a classic example of </span><em><span class="koboSpan" id="kobo.6.1">process synchronization</span></em><span class="koboSpan" id="kobo.7.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">The </span><strong><span class="koboSpan" id="kobo.9.1">producer-consumer</span></strong><span class="koboSpan" id="kobo.10.1"> problem describes two </span><em><span class="koboSpan" id="kobo.11.1">processes</span></em><span class="koboSpan" id="kobo.12.1">: one is the </span><em><span class="koboSpan" id="kobo.13.1">producer</span></em><span class="koboSpan" id="kobo.14.1"> and the other is a </span><em><span class="koboSpan" id="kobo.15.1">consumer</span></em><span class="koboSpan" id="kobo.16.1">, sharing a </span><strong><span class="koboSpan" id="kobo.17.1">common</span></strong> <strong><span class="koboSpan" id="kobo.18.1">buffer</span></strong><span class="koboSpan" id="kobo.19.1"> of a </span><strong><span class="koboSpan" id="kobo.20.1">fixed</span></strong> <strong><span class="koboSpan" id="kobo.21.1">size</span></strong><span class="koboSpan" id="kobo.22.1">.</span></p>
<p><span class="koboSpan" id="kobo.23.1">The task of the </span><em><span class="koboSpan" id="kobo.24.1">producer</span></em><span class="koboSpan" id="kobo.25.1"> is to generate data and to deposit it in the buffer continuously. </span><span class="koboSpan" id="kobo.25.2">At the same time, the </span><em><span class="koboSpan" id="kobo.26.1">consumer</span></em><span class="koboSpan" id="kobo.27.1"> will use the data produced, removing it</span><span><span class="koboSpan" id="kobo.28.1"> from the buffer</span></span><span class="koboSpan" id="kobo.29.1"> from time to time. </span><span class="koboSpan" id="kobo.29.2">The problem is to ensure that the producer does not process new data if the buffer is full and that the consumer does not look for data if the buffer is empty. </span><span class="koboSpan" id="kobo.29.3">The solution for the producer is to suspend its execution if the buffer is full.</span></p>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.30.1">As soon as the consumer has taken an item from the buffer, the producer wakes up and starts to fill the buffer again. Similarly, the consumer will suspend if the buffer is empty. </span><span class="koboSpan" id="kobo.30.2">As soon as the producer has downloaded the data into the buffer, the consumer wakes up.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">This solution can be implemented by means of communication strategies between processes, shared memory, or message passing. </span><span class="koboSpan" id="kobo.2.2">An incorrect solution could result in a deadlock, in which both processes wait to be awakened:</span></p>
<pre><span class="koboSpan" id="kobo.3.1">import multiprocessing</span><br/><span class="koboSpan" id="kobo.4.1">import random</span><br/><span class="koboSpan" id="kobo.5.1">import time</span></pre>
<p><span class="koboSpan" id="kobo.6.1">Let's perform the steps as follows:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.7.1">The </span><kbd><span class="koboSpan" id="kobo.8.1">producer</span></kbd><span class="koboSpan" id="kobo.9.1"> class is responsible for entering </span><kbd><span class="koboSpan" id="kobo.10.1">10</span></kbd><span class="koboSpan" id="kobo.11.1"> items in the queue by using the </span><kbd><span class="koboSpan" id="kobo.12.1">put</span></kbd><span class="koboSpan" id="kobo.13.1"> method:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.14.1">class producer(multiprocessing.Process):</span><br/><span class="koboSpan" id="kobo.15.1">    def __init__(self, queue):</span><br/><span class="koboSpan" id="kobo.16.1">        multiprocessing.Process.__init__(self)</span><br/><span class="koboSpan" id="kobo.17.1">        self.queue = queue</span><br/><br/><span class="koboSpan" id="kobo.18.1">    def run(self) :</span><br/><span class="koboSpan" id="kobo.19.1">        for i in range(10):</span><br/><span class="koboSpan" id="kobo.20.1">            item = random.randint(0, 256)</span><br/><span class="koboSpan" id="kobo.21.1">            self.queue.put(item) </span><br/><span class="koboSpan" id="kobo.22.1">            print ("Process Producer : item %d appended \</span><br/><span class="koboSpan" id="kobo.23.1">                   to queue %s"\</span><br/><span class="koboSpan" id="kobo.24.1">                   % (item,self.name))</span><br/><span class="koboSpan" id="kobo.25.1">            time.sleep(1)</span><br/><span class="koboSpan" id="kobo.26.1">            print ("The size of queue is %s"\</span><br/><span class="koboSpan" id="kobo.27.1">                   % self.queue.qsize())</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.28.1">The </span><kbd><span class="koboSpan" id="kobo.29.1">consumer</span></kbd><span class="koboSpan" id="kobo.30.1"> class has the task of removing the items from the queue (using the </span><kbd><span class="koboSpan" id="kobo.31.1">get</span></kbd><span class="koboSpan" id="kobo.32.1"> method) and verifying that the queue is not empty. </span><span class="koboSpan" id="kobo.32.2">If this happens, then the flow inside the </span><kbd><span class="koboSpan" id="kobo.33.1">while</span></kbd><span class="koboSpan" id="kobo.34.1"> loop ends with a </span><kbd><span class="koboSpan" id="kobo.35.1">break</span></kbd><span class="koboSpan" id="kobo.36.1"> statement:</span></li>
</ol>
<pre style="padding-left: 30px"><span class="koboSpan" id="kobo.37.1">class consumer(multiprocessing.Process):</span><br/><span class="koboSpan" id="kobo.38.1">    def __init__(self, queue):</span><br/><span class="koboSpan" id="kobo.39.1">        multiprocessing.Process.__init__(self)</span><br/><span class="koboSpan" id="kobo.40.1">        self.queue = queue</span><br/><br/><span class="koboSpan" id="kobo.41.1">    def run(self):</span><br/><span class="koboSpan" id="kobo.42.1">        while True:</span><br/><span class="koboSpan" id="kobo.43.1">            if (self.queue.empty()):</span><br/><span class="koboSpan" id="kobo.44.1">                print("the queue is empty")</span><br/><span class="koboSpan" id="kobo.45.1">                break</span><br/><span class="koboSpan" id="kobo.46.1">            else :</span><br/><span class="koboSpan" id="kobo.47.1">                time.sleep(2)</span><br/><span class="koboSpan" id="kobo.48.1">                item = self.queue.get()</span><br/><span class="koboSpan" id="kobo.49.1">                print ('Process Consumer : item %d popped \</span><br/><span class="koboSpan" id="kobo.50.1">                        from by %s \n'\</span><br/><span class="koboSpan" id="kobo.51.1">                       % (item, self.name))</span><br/><span class="koboSpan" id="kobo.52.1">                time.sleep(1)</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.53.1">The </span><kbd><span class="koboSpan" id="kobo.54.1">multiprocessing</span></kbd><span class="koboSpan" id="kobo.55.1"> class has its </span><kbd><span class="koboSpan" id="kobo.56.1">queue</span></kbd><span class="koboSpan" id="kobo.57.1"> object instantiated in the </span><kbd><span class="koboSpan" id="kobo.58.1">main</span></kbd><span class="koboSpan" id="kobo.59.1"> program:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.60.1">if __name__ == '__main__':</span><br/><span class="koboSpan" id="kobo.61.1">        queue = multiprocessing.Queue()</span><br/><span class="koboSpan" id="kobo.62.1">        process_producer = producer(queue)</span><br/><span class="koboSpan" id="kobo.63.1">        process_consumer = consumer(queue)</span><br/><span class="koboSpan" id="kobo.64.1">        process_producer.start()</span><br/><span class="koboSpan" id="kobo.65.1">        process_consumer.start()</span><br/><span class="koboSpan" id="kobo.66.1">        process_producer.join()</span><br/><span class="koboSpan" id="kobo.67.1">        process_consumer.join()</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Within the </span><kbd><span class="koboSpan" id="kobo.3.1">main</span></kbd><span class="koboSpan" id="kobo.4.1"> program, we define the queue using the </span><kbd><span class="koboSpan" id="kobo.5.1">multiprocessing.Queue</span></kbd><span class="koboSpan" id="kobo.6.1"> object. </span><span class="koboSpan" id="kobo.6.2">Then, it is passed as an argument to the </span><kbd><span class="koboSpan" id="kobo.7.1">producer </span></kbd><span class="koboSpan" id="kobo.8.1"> and </span><kbd><span class="koboSpan" id="kobo.9.1">consumer</span></kbd><span class="koboSpan" id="kobo.10.1"> </span><span><span class="koboSpan" id="kobo.11.1">processes:</span></span></p>
<pre><span class="koboSpan" id="kobo.12.1">        queue = multiprocessing.Queue()</span><br/><span class="koboSpan" id="kobo.13.1">        process_producer = producer(queue)</span><br/><span class="koboSpan" id="kobo.14.1">        process_consumer = consumer(queue)</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.15.1">In the </span><kbd><span class="koboSpan" id="kobo.16.1">producer</span></kbd><span class="koboSpan" id="kobo.17.1"> class, the </span><kbd><span class="koboSpan" id="kobo.18.1">queue.put</span></kbd><span class="koboSpan" id="kobo.19.1"> method is used to append new items to the queue:</span></p>
<pre><span class="koboSpan" id="kobo.20.1">self.queue.put(item) </span></pre>
<p><span class="koboSpan" id="kobo.21.1">While in the </span><kbd><span class="koboSpan" id="kobo.22.1">consumer</span></kbd><span class="koboSpan" id="kobo.23.1"> class, the </span><kbd><span class="koboSpan" id="kobo.24.1">queue.get</span></kbd><span class="koboSpan" id="kobo.25.1"> method is used to po</span><em><span class="koboSpan" id="kobo.26.1">p</span></em><span class="koboSpan" id="kobo.27.1"> out the items:</span></p>
<pre><span class="koboSpan" id="kobo.28.1">self.queue.get()</span></pre>
<p><span class="koboSpan" id="kobo.29.1">Execute the code by typing the following command:</span></p>
<pre><strong><span class="koboSpan" id="kobo.30.1">&gt; python communicating_with_queue.py</span></strong></pre>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.31.1">The following output reports the interaction between the producer and the consumer:</span></p>
<pre><strong><span class="koboSpan" id="kobo.32.1">Process Producer : item 79 appended to queue producer-1</span></strong><br/><strong><span class="koboSpan" id="kobo.33.1">The size of queue is 1</span></strong><br/><strong><span class="koboSpan" id="kobo.34.1">Process Producer : item 50 appended to queue producer-1</span></strong><br/><strong><span class="koboSpan" id="kobo.35.1">The size of queue is 2</span></strong><br/><strong><span class="koboSpan" id="kobo.36.1">Process Consumer : item 79 popped from by consumer-2</span></strong><br/><strong><span class="koboSpan" id="kobo.37.1">Process Producer : item 33 appended to queue producer-1</span></strong><br/><strong><span class="koboSpan" id="kobo.38.1">The size of queue is 2</span></strong><br/><strong><span class="koboSpan" id="kobo.39.1">Process Producer : item 57 appended to queue producer-1</span></strong><br/><strong><span class="koboSpan" id="kobo.40.1">The size of queue is 3</span></strong><br/><strong><span class="koboSpan" id="kobo.41.1">Process Producer : item 227 appended to queue producer-1</span></strong><br/><strong><span class="koboSpan" id="kobo.42.1">Process Consumer : item 50 popped from by consumer-2</span></strong><br/><strong><span class="koboSpan" id="kobo.43.1">The size of queue is 3</span></strong><br/><strong><span class="koboSpan" id="kobo.44.1">Process Producer : item 98 appended to queue producer-1</span></strong><br/><strong><span class="koboSpan" id="kobo.45.1">The size of queue is 4</span></strong><br/><strong><span class="koboSpan" id="kobo.46.1">Process Producer : item 64 appended to queue producer-1</span></strong><br/><strong><span class="koboSpan" id="kobo.47.1">The size of queue is 5</span></strong><br/><strong><span class="koboSpan" id="kobo.48.1">Process Producer : item 182 appended to queue producer-1</span></strong><br/><strong><span class="koboSpan" id="kobo.49.1">Process Consumer : item 33 popped from by consumer-2</span></strong><br/><strong><span class="koboSpan" id="kobo.50.1">The size of queue is 5</span></strong><br/><strong><span class="koboSpan" id="kobo.51.1">Process Producer : item 206 appended to queue producer-1</span></strong><br/><strong><span class="koboSpan" id="kobo.52.1">The size of queue is 6</span></strong><br/><strong><span class="koboSpan" id="kobo.53.1">Process Producer : item 214 appended to queue producer-1</span></strong><br/><strong><span class="koboSpan" id="kobo.54.1">The size of queue is 7</span></strong><br/><strong><span class="koboSpan" id="kobo.55.1">Process Consumer : item 57 popped from by consumer-2</span></strong><br/><strong><span class="koboSpan" id="kobo.56.1">Process Consumer : item 227 popped from by consumer-2</span></strong><br/><strong><span class="koboSpan" id="kobo.57.1">Process Consumer : item 98 popped from by consumer-2</span></strong><br/><strong><span class="koboSpan" id="kobo.58.1">Process Consumer : item 64 popped from by consumer-2</span></strong><br/><strong><span class="koboSpan" id="kobo.59.1">Process Consumer : item 182 popped from by consumer-2</span></strong><br/><strong><span class="koboSpan" id="kobo.60.1">Process Consumer : item 206 popped from by consumer-2</span></strong><br/><strong><span class="koboSpan" id="kobo.61.1">Process Consumer : item 214 popped from by consumer-2</span></strong><br/><strong><span class="koboSpan" id="kobo.62.1">the queue is empty</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A queue has the </span><kbd><span class="koboSpan" id="kobo.3.1">JoinableQueue</span></kbd><span class="koboSpan" id="kobo.4.1"> subclass. </span><span class="koboSpan" id="kobo.4.2">This provides the following methods:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.5.1">task_done()</span></kbd><span class="koboSpan" id="kobo.6.1">: This method indicates that a task is complete, for example, after using the </span><kbd><span class="koboSpan" id="kobo.7.1">get()</span></kbd><span class="koboSpan" id="kobo.8.1"> method to fetch items from the queue. </span><span class="koboSpan" id="kobo.8.2">So </span><kbd><span class="koboSpan" id="kobo.9.1">task_done()</span></kbd><span class="koboSpan" id="kobo.10.1"> must be used only by queue consumers.</span></li>
<li><kbd><span class="koboSpan" id="kobo.11.1">join()</span></kbd><span class="koboSpan" id="kobo.12.1">: This method blocks the processes until all the items in the queue have been completed and processed.</span></li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">See also</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A good tutorial on how to use a queue is available at </span><a href="https://www.pythoncentral.io/use-queue-beginners-guide/"><span class="koboSpan" id="kobo.3.1">https://www.pythoncentral.io/use-queue-beginners-guide/</span></a><span class="koboSpan" id="kobo.4.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Using pipes to exchange objects</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A </span><em><span class="koboSpan" id="kobo.3.1">pipe</span></em><span class="koboSpan" id="kobo.4.1"> does the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.5.1">It returns a pair of connection objects connected by a pipe.</span></li>
<li><span><span class="koboSpan" id="kobo.6.1">E</span></span><span class="koboSpan" id="kobo.7.1">very connection object has to send/receive methods to communicate between processes.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The </span><kbd><span class="koboSpan" id="kobo.3.1">multiprocessing</span></kbd><span class="koboSpan" id="kobo.4.1"> library allows you to implement a pipe data structure using the </span><kbd><span class="koboSpan" id="kobo.5.1">multiprocessing.Pipe (duplex)</span></kbd><span class="koboSpan" id="kobo.6.1"> </span><span><span class="koboSpan" id="kobo.7.1">function.</span></span><span class="koboSpan" id="kobo.8.1"> This returns a pair of objects, </span><kbd><span class="koboSpan" id="kobo.9.1">(conn1, conn2)</span></kbd><span class="koboSpan" id="kobo.10.1">, which represent the end of the pipe.</span></p>
<p><span class="koboSpan" id="kobo.11.1">The </span><kbd><span class="koboSpan" id="kobo.12.1">duplex</span></kbd><span class="koboSpan" id="kobo.13.1"> parameter determines whether the pipe for the last case is bidirectional (that is, </span><kbd><span class="koboSpan" id="kobo.14.1">duplex = True</span></kbd><span class="koboSpan" id="kobo.15.1">), or unidirectional (that is, </span><kbd><span class="koboSpan" id="kobo.16.1">duplex = False</span></kbd><span class="koboSpan" id="kobo.17.1">). </span><kbd><span class="koboSpan" id="kobo.18.1">conn1</span></kbd><span class="koboSpan" id="kobo.19.1"> can only be used for receiving messages, and </span><kbd><span class="koboSpan" id="kobo.20.1">conn2</span></kbd><span class="koboSpan" id="kobo.21.1"> can only be used for sending messages. </span></p>
<p><span><span class="koboSpan" id="kobo.22.1">Now, </span></span><span class="koboSpan" id="kobo.23.1">let's see how to exchange objects using pipes.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Here is a simple example of pipes. </span><span class="koboSpan" id="kobo.2.2">We have one process pipe that outputs numbers from </span><kbd><span class="koboSpan" id="kobo.3.1">0</span></kbd><span class="koboSpan" id="kobo.4.1"> to </span><kbd><span class="koboSpan" id="kobo.5.1">9</span></kbd><span class="koboSpan" id="kobo.6.1">, and a second process pipe that takes the numbers and squares them:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.7.1">Let's import the </span><kbd><span class="koboSpan" id="kobo.8.1">multiprocessing</span></kbd><span class="koboSpan" id="kobo.9.1"> library:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.10.1">import multiprocessing</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<ol start="2">
<li><span class="koboSpan" id="kobo.11.1">The </span><kbd><span class="koboSpan" id="kobo.12.1">pipe</span></kbd><span class="koboSpan" id="kobo.13.1"> function returns a pair of connection objects connected by a </span><em><span class="koboSpan" id="kobo.14.1">two-way</span></em><span class="koboSpan" id="kobo.15.1"> pipe. </span><span class="koboSpan" id="kobo.15.2">In the example, </span><kbd><span class="koboSpan" id="kobo.16.1">out_pipe</span></kbd><span class="koboSpan" id="kobo.17.1"> contains the numbers from </span><kbd><span class="koboSpan" id="kobo.18.1">0</span></kbd><span class="koboSpan" id="kobo.19.1"> to </span><kbd><span class="koboSpan" id="kobo.20.1">9</span></kbd><span class="koboSpan" id="kobo.21.1">, which were generated by the </span><kbd><span class="koboSpan" id="kobo.22.1">target</span></kbd><span class="koboSpan" id="kobo.23.1"> function of </span><kbd><span class="koboSpan" id="kobo.24.1">create_items</span></kbd><span class="koboSpan" id="kobo.25.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.26.1">def create_items(pipe):</span><br/><span class="koboSpan" id="kobo.27.1">    output_pipe, _ = pipe</span><br/><span class="koboSpan" id="kobo.28.1">    for item in range(10):</span><br/><span class="koboSpan" id="kobo.29.1">        output_pipe.send(item)</span><br/><span class="koboSpan" id="kobo.30.1">    output_pipe.close()</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.31.1">The </span><kbd><span class="koboSpan" id="kobo.32.1">multiply_items</span></kbd><span class="koboSpan" id="kobo.33.1"> function is based on two pipes, </span><kbd><span class="koboSpan" id="kobo.34.1">pipe_1</span></kbd><span class="koboSpan" id="kobo.35.1"> and </span><kbd><span class="koboSpan" id="kobo.36.1">pipe_2</span></kbd><span class="koboSpan" id="kobo.37.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.38.1"> def multiply_items(pipe_1, pipe_2):</span><br/><span class="koboSpan" id="kobo.39.1">    close, input_pipe = pipe_1</span><br/><span class="koboSpan" id="kobo.40.1">    close.close()</span><br/><span class="koboSpan" id="kobo.41.1">    output_pipe, _ = pipe_2</span><br/><span class="koboSpan" id="kobo.42.1">    try:</span><br/><span class="koboSpan" id="kobo.43.1">        while True:</span><br/><span class="koboSpan" id="kobo.44.1">            item = input_pipe.recv()</span></pre>
<ol start="4">
<li><span><span class="koboSpan" id="kobo.45.1">This function </span></span><span class="koboSpan" id="kobo.46.1">returns the product of the elements of each pipe:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.47.1">           output_pipe.send(item * item)</span><br/><span class="koboSpan" id="kobo.48.1"> except EOFError:</span><br/><span class="koboSpan" id="kobo.49.1">        output_pipe.close()</span></pre>
<ol start="5">
<li><span class="koboSpan" id="kobo.50.1">In the </span><kbd><span class="koboSpan" id="kobo.51.1">main</span></kbd><span class="koboSpan" id="kobo.52.1"> program,  </span><kbd><span class="koboSpan" id="kobo.53.1">pipe_1</span></kbd><span class="koboSpan" id="kobo.54.1">, and </span><kbd><span class="koboSpan" id="kobo.55.1">pipe_2</span></kbd><span class="koboSpan" id="kobo.56.1"> are defined:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.57.1">if __name__== '__main__':</span></pre>
<ol start="6">
<li><span class="koboSpan" id="kobo.58.1">First, process </span><kbd><span class="koboSpan" id="kobo.59.1">pipe_1</span></kbd><span class="koboSpan" id="kobo.60.1"> with numbers from </span><kbd><span class="koboSpan" id="kobo.61.1">0</span></kbd><span class="koboSpan" id="kobo.62.1"> to </span><kbd><span class="koboSpan" id="kobo.63.1">9</span></kbd><span class="koboSpan" id="kobo.64.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.65.1">    pipe_1 = multiprocessing.Pipe(True)</span><br/><span class="koboSpan" id="kobo.66.1">    process_pipe_1 = \</span><br/><span class="koboSpan" id="kobo.67.1">                   multiprocessing.Process\</span><br/><span class="koboSpan" id="kobo.68.1">                   (target=create_items, args=(pipe_1,))</span><br/><span class="koboSpan" id="kobo.69.1">    process_pipe_1.start()</span></pre>
<ol start="7">
<li><span class="koboSpan" id="kobo.70.1">Then, process </span><kbd><span class="koboSpan" id="kobo.71.1">pipe_2</span></kbd><span class="koboSpan" id="kobo.72.1">, which picks up the numbers from </span><kbd><span class="koboSpan" id="kobo.73.1">pipe_1</span></kbd><span class="koboSpan" id="kobo.74.1"> and squares them:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.75.1">    pipe_2 = multiprocessing.Pipe(True)</span><br/><span class="koboSpan" id="kobo.76.1">    process_pipe_2 = \</span><br/><span class="koboSpan" id="kobo.77.1">                   multiprocessing.Process\</span><br/><span class="koboSpan" id="kobo.78.1">                   (target=multiply_items, args=(pipe_1, pipe_2,))</span><br/><span class="koboSpan" id="kobo.79.1">    process_pipe_2.start()</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="8">
<li><span class="koboSpan" id="kobo.80.1">Close the processes:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.81.1">    pipe_1[0].close()</span><br/><span class="koboSpan" id="kobo.82.1">    pipe_2[0].close()</span></pre>
<ol start="9">
<li><span class="koboSpan" id="kobo.83.1">Print out the results:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.84.1">    try:</span><br/><span class="koboSpan" id="kobo.85.1">        while True:</span><br/><span class="koboSpan" id="kobo.86.1">            print (pipe_2[1].recv())</span><br/><span class="koboSpan" id="kobo.87.1">    except EOFError:</span><br/><span class="koboSpan" id="kobo.88.1">        print("End")</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Essentially, the two pipes, </span><kbd><span class="koboSpan" id="kobo.3.1">pipe_1</span></kbd><span class="koboSpan" id="kobo.4.1"> and </span><kbd><span class="koboSpan" id="kobo.5.1">pipe_2</span></kbd><span class="koboSpan" id="kobo.6.1">, are created by the </span><kbd><span class="koboSpan" id="kobo.7.1">multiprocessing.Pipe(True)</span></kbd> <span><span class="koboSpan" id="kobo.8.1">statement:</span></span></p>
<pre><span class="koboSpan" id="kobo.9.1">pipe_1 = multiprocessing.Pipe(True)</span><br/><span class="koboSpan" id="kobo.10.1">pipe_2 = multiprocessing.Pipe(True)</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.11.1">The first pipe, </span><kbd><span class="koboSpan" id="kobo.12.1">pipe_1</span></kbd><span class="koboSpan" id="kobo.13.1">, simply created a list of integers from </span><kbd><span class="koboSpan" id="kobo.14.1">0</span></kbd><span class="koboSpan" id="kobo.15.1"> to </span><kbd><span class="koboSpan" id="kobo.16.1">9</span></kbd><span class="koboSpan" id="kobo.17.1">, while the second pipe, </span><kbd><span class="koboSpan" id="kobo.18.1">pipe_2</span></kbd><span class="koboSpan" id="kobo.19.1">, processed each element of the list created by </span><kbd><span class="koboSpan" id="kobo.20.1">pipe_1</span></kbd><span class="koboSpan" id="kobo.21.1">, calculating the squared value of each element:</span></p>
<pre><span class="koboSpan" id="kobo.22.1">process_pipe_2 = \</span><br/><span class="koboSpan" id="kobo.23.1">                   multiprocessing.Process\</span><br/><span class="koboSpan" id="kobo.24.1">                   (target=multiply_items, args=(pipe_1, pipe_2,))</span></pre>
<p><span class="koboSpan" id="kobo.25.1">Therefore, both processes are closed:</span></p>
<pre><span class="koboSpan" id="kobo.26.1">pipe_1[0].close()</span><br/><span class="koboSpan" id="kobo.27.1">pipe_2[0].close()</span></pre>
<p><span><span class="koboSpan" id="kobo.28.1">And the final result is printed:</span></span></p>
<pre><span class="koboSpan" id="kobo.29.1">print (pipe_2[1].recv())</span></pre>
<p><span class="koboSpan" id="kobo.30.1">Execute the code by typing the following command:</span></p>
<pre><strong><span class="koboSpan" id="kobo.31.1">&gt; python communicating_with_pipe.py</span></strong></pre>
<p><span class="koboSpan" id="kobo.32.1">The following result shows the square of the first </span><kbd><span class="koboSpan" id="kobo.33.1">9</span></kbd><span class="koboSpan" id="kobo.34.1"> digits:</span></p>
<pre><strong><span class="koboSpan" id="kobo.35.1">0</span></strong><br/><strong><span class="koboSpan" id="kobo.36.1">1</span></strong><br/><strong><span class="koboSpan" id="kobo.37.1">4</span></strong><br/><strong><span class="koboSpan" id="kobo.38.1">9</span></strong><br/><strong><span class="koboSpan" id="kobo.39.1">16</span></strong><br/><strong><span class="koboSpan" id="kobo.40.1">25</span></strong><br/><strong><span class="koboSpan" id="kobo.41.1">36</span></strong><br/><strong><span class="koboSpan" id="kobo.42.1">49</span></strong><br/><strong><span class="koboSpan" id="kobo.43.1">64</span></strong><br/><strong><span class="koboSpan" id="kobo.44.1">81</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">If you need more than two points to communicate, then use a </span><kbd><span class="koboSpan" id="kobo.3.1">Queue()</span></kbd><span class="koboSpan" id="kobo.4.1"> method. </span><span class="koboSpan" id="kobo.4.2">However, if you need absolute performance, then a </span><kbd><span class="koboSpan" id="kobo.5.1">Pipe()</span></kbd><span class="koboSpan" id="kobo.6.1"> method is much faster because </span><kbd><span class="koboSpan" id="kobo.7.1">Queue()</span></kbd><span class="koboSpan" id="kobo.8.1"> is built on top of </span><kbd><span class="koboSpan" id="kobo.9.1">Pipe()</span></kbd><strong><span class="koboSpan" id="kobo.10.1">.</span></strong></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1"> See also</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">More information on Python and pipes can be found at </span><a href="https://www.python-course.eu/pipes.php%0d"><span class="koboSpan" id="kobo.3.1">https://www.python-course.eu/pipes.php</span></a><span class="koboSpan" id="kobo.4.1">.</span><a href="https://www.python-course.eu/pipes.php%0d"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Synchronizing processes</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Multiple processes can work together to perform a given task. </span><span class="koboSpan" id="kobo.2.2">Usually, they share data. </span><span class="koboSpan" id="kobo.2.3">It is important that access to shared data by various processes does not produce inconsistent data. </span><span class="koboSpan" id="kobo.2.4">Processes that cooperate by sharing data must, therefore, act in an orderly manner in order </span><span><span class="koboSpan" id="kobo.3.1">for that data to be accessible</span></span><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">Synchronization primitives are quite like those encountered for the library and threading.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Synchronization primitives are as follows:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.6.1">Lock</span></strong><span class="koboSpan" id="kobo.7.1">: This object can be in either the locked or unlocked state. </span><span class="koboSpan" id="kobo.7.2">A locked object has two methods, </span><kbd><span class="koboSpan" id="kobo.8.1">acquire()</span></kbd><span class="koboSpan" id="kobo.9.1"> and </span><kbd><span class="koboSpan" id="kobo.10.1">release()</span></kbd><span class="koboSpan" id="kobo.11.1">, to manage access to a shared resource.</span></li>
<li><strong><span class="koboSpan" id="kobo.12.1">Event</span></strong><span class="koboSpan" id="kobo.13.1">: This object realizes simple communication between processes; one process signals an event and the other processes wait for it. </span><span class="koboSpan" id="kobo.13.2">An event object has two methods, </span><kbd><span class="koboSpan" id="kobo.14.1">set()</span></kbd><span class="koboSpan" id="kobo.15.1"> and </span><kbd><span class="koboSpan" id="kobo.16.1">clear()</span></kbd><span class="koboSpan" id="kobo.17.1">, to manage its own internal flag.</span></li>
<li><strong><span class="koboSpan" id="kobo.18.1">Condition</span></strong><span class="koboSpan" id="kobo.19.1">: This object is used to synchronize parts of a workflow, in sequential or parallel processes. </span><span class="koboSpan" id="kobo.19.2">It has two basic methods: </span><kbd><span class="koboSpan" id="kobo.20.1">wait()</span></kbd><span class="koboSpan" id="kobo.21.1"> is used to wait for a condition and </span><kbd><span class="koboSpan" id="kobo.22.1">notify_all()</span></kbd><span class="koboSpan" id="kobo.23.1"> is used to communicate the condition that was applied.</span></li>
<li><strong><span class="koboSpan" id="kobo.24.1">Semaphore</span></strong><span class="koboSpan" id="kobo.25.1">: This is used to share a common resource, for example, to support a fixed number of simultaneous connections.</span></li>
<li><strong><span class="koboSpan" id="kobo.26.1">RLock</span></strong><span class="koboSpan" id="kobo.27.1">: This defines the </span><em><span class="koboSpan" id="kobo.28.1">recursive lock</span></em><span class="koboSpan" id="kobo.29.1"> object. </span><span class="koboSpan" id="kobo.29.2">The methods and functionality of RLock are the same as the </span><kbd><span class="koboSpan" id="kobo.30.1">threading</span></kbd><span class="koboSpan" id="kobo.31.1"> module.</span></li>
<li><strong><span class="koboSpan" id="kobo.32.1">Barrier</span></strong><span class="koboSpan" id="kobo.33.1">: This divides a program into phases as it requires all processes to reach the barrier before any of the proceeds. </span><span class="koboSpan" id="kobo.33.2">Code that is executed after a barrier cannot be concurrent with the code that was executed before the barrier.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><em><span class="koboSpan" id="kobo.2.1">Barrier</span></em><span class="koboSpan" id="kobo.3.1"> objects in Python are used to wait for the execution of a fixed number of threads to complete before a given thread can proceed with the execution of the program.</span></p>
<p><span><span class="koboSpan" id="kobo.4.1">The following example shows how to synchronize simultaneous tasks with a </span></span><kbd><span class="koboSpan" id="kobo.5.1">barrier()</span></kbd><span><span class="koboSpan" id="kobo.6.1"> object.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's consider four processes, wherein process </span><kbd><span class="koboSpan" id="kobo.3.1">p1</span></kbd><span class="koboSpan" id="kobo.4.1"> and process </span><kbd><span class="koboSpan" id="kobo.5.1">p2</span></kbd><span class="koboSpan" id="kobo.6.1"> are managed by a barrier statement</span><em><span class="koboSpan" id="kobo.7.1">,</span></em><span class="koboSpan" id="kobo.8.1"> while process </span><kbd><span class="koboSpan" id="kobo.9.1">p3</span></kbd><span class="koboSpan" id="kobo.10.1"> and process </span><kbd><span class="koboSpan" id="kobo.11.1">p4</span></kbd><span class="koboSpan" id="kobo.12.1"> have </span><em><span class="koboSpan" id="kobo.13.1">no synchronization</span></em><span class="koboSpan" id="kobo.14.1"> directives.</span></p>
<p><span class="koboSpan" id="kobo.15.1">To do this, perform the following steps:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.16.1">Import the relevant libraries:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.17.1">import multiprocessing</span><br/><span class="koboSpan" id="kobo.18.1">from multiprocessing import Barrier, Lock, Process</span><br/><span class="koboSpan" id="kobo.19.1">from time import time</span><br/><span class="koboSpan" id="kobo.20.1">from datetime import datetime</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.21.1">The </span><kbd><span class="koboSpan" id="kobo.22.1">test_with_barrier</span></kbd><span class="koboSpan" id="kobo.23.1"> function executes the barrier's </span><strong><kbd><span class="koboSpan" id="kobo.24.1">wait()</span></kbd></strong><span class="koboSpan" id="kobo.25.1"> method:</span></li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><span class="koboSpan" id="kobo.26.1">def test_with_barrier(synchronizer, serializer):</span><br/><span class="koboSpan" id="kobo.27.1">    name = multiprocessing.current_process().name</span><br/><span class="koboSpan" id="kobo.28.1">    synchronizer.wait()</span><br/><span class="koboSpan" id="kobo.29.1">    now = time()</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.30.1">When the two processes have called the </span><kbd><span class="koboSpan" id="kobo.31.1">wait()</span></kbd><span class="koboSpan" id="kobo.32.1"> method, they are released simultaneously:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.33.1">with serializer:</span><br/><span class="koboSpan" id="kobo.34.1">    print("process %s ----&gt; %s" \</span><br/><span class="koboSpan" id="kobo.35.1">        %(name,datetime.fromtimestamp(now)))</span><br/><br/><span class="koboSpan" id="kobo.36.1">def test_without_barrier():</span><br/><span class="koboSpan" id="kobo.37.1">    name = multiprocessing.current_process().name</span><br/><span class="koboSpan" id="kobo.38.1">    now = time()</span><br/><span class="koboSpan" id="kobo.39.1">    print("process %s ----&gt; %s" \</span><br/><span class="koboSpan" id="kobo.40.1">        %(name ,datetime.fromtimestamp(now)))</span></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.41.1">In the </span><kbd><span class="koboSpan" id="kobo.42.1">main</span></kbd><span class="koboSpan" id="kobo.43.1"> program, we created four processes. </span><span class="koboSpan" id="kobo.43.2">However, we also need a barrier and lock primitive. </span><span class="koboSpan" id="kobo.43.3">The </span><kbd><span class="koboSpan" id="kobo.44.1">2</span></kbd><span class="koboSpan" id="kobo.45.1"> parameter in the </span><kbd><span class="koboSpan" id="kobo.46.1">Barrier</span></kbd><span class="koboSpan" id="kobo.47.1"> statement stands for the total number of processes to manage:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.48.1">if __name__ == '__main__':</span><br/><span class="koboSpan" id="kobo.49.1">    synchronizer = Barrier(2)</span><br/><span class="koboSpan" id="kobo.50.1">    serializer = Lock()</span><br/><span class="koboSpan" id="kobo.51.1">    Process(name='p1 - test_with_barrier'\</span><br/><span class="koboSpan" id="kobo.52.1">            ,target=test_with_barrier,\</span><br/><span class="koboSpan" id="kobo.53.1">            args=(synchronizer,serializer)).start()</span><br/><span class="koboSpan" id="kobo.54.1">    Process(name='p2 - test_with_barrier'\</span><br/><span class="koboSpan" id="kobo.55.1">            ,target=test_with_barrier,\</span><br/><span class="koboSpan" id="kobo.56.1">            args=(synchronizer,serializer)).start()</span><br/><span class="koboSpan" id="kobo.57.1">    Process(name='p3 - test_without_barrier'\</span><br/><span class="koboSpan" id="kobo.58.1">            ,target=test_without_barrier).start()</span><br/><span class="koboSpan" id="kobo.59.1">    Process(name='p4 - test_without_barrier'\</span><br/><span class="koboSpan" id="kobo.60.1">            ,target=test_without_barrier).start()</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span><span class="koboSpan" id="kobo.2.1">The </span><kbd><span class="koboSpan" id="kobo.3.1">Barrier</span></kbd><span class="koboSpan" id="kobo.4.1"> object provides one of the Python synchronization techniques with which single or multiple threads wait until a point in a set of activities and make progress together. </span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In the </span><kbd><span class="koboSpan" id="kobo.6.1">main</span></kbd><span class="koboSpan" id="kobo.7.1"> program, the </span><kbd><span class="koboSpan" id="kobo.8.1">Barrier</span></kbd><span class="koboSpan" id="kobo.9.1"> object (that is, </span><kbd><span class="koboSpan" id="kobo.10.1">synchronizer</span></kbd><span class="koboSpan" id="kobo.11.1">) is defined through the following statement:</span></p>
<pre><span class="koboSpan" id="kobo.12.1">synchronizer = Barrier(2)</span></pre>
<p><span><span class="koboSpan" id="kobo.13.1">Note that </span></span><span><span class="koboSpan" id="kobo.14.1">the number </span><kbd><span class="koboSpan" id="kobo.15.1">2</span></kbd><span class="koboSpan" id="kobo.16.1"> within the parentheses represents the number of processes that the barrier should wait upon.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">Then, </span><span><span class="koboSpan" id="kobo.18.1">we implement a set of four processes, but only for the</span></span><span class="koboSpan" id="kobo.19.1"> </span><kbd><span class="koboSpan" id="kobo.20.1">p1</span></kbd> <span><span class="koboSpan" id="kobo.21.1">and </span><kbd><span class="koboSpan" id="kobo.22.1">p2</span></kbd><span class="koboSpan" id="kobo.23.1"> processes. </span><span class="koboSpan" id="kobo.23.2">Note that </span><kbd><span class="koboSpan" id="kobo.24.1">synchronizer</span></kbd><span class="koboSpan" id="kobo.25.1"> is passed as an argument:</span></span></p>
<pre><span class="koboSpan" id="kobo.26.1">Process(name='p1 - test_with_barrier'\</span><br/><span class="koboSpan" id="kobo.27.1">            ,target=test_with_barrier,\</span><br/><span class="koboSpan" id="kobo.28.1">            args=(synchronizer,serializer)).start()</span><br/><span class="koboSpan" id="kobo.29.1">Process(name='p2 - test_with_barrier'\</span><br/><span class="koboSpan" id="kobo.30.1">            ,target=test_with_barrier,\</span><br/><span class="koboSpan" id="kobo.31.1">            args=(synchronizer,serializer)).start()</span></pre>
<p><span class="koboSpan" id="kobo.32.1">Indeed, in the body of the </span><kbd><span class="koboSpan" id="kobo.33.1">test_with_barrier</span></kbd><span class="koboSpan" id="kobo.34.1"> </span><span><span class="koboSpan" id="kobo.35.1">function, </span></span><span class="koboSpan" id="kobo.36.1">the barrier's </span><kbd><span class="koboSpan" id="kobo.37.1">wait()</span></kbd><span class="koboSpan" id="kobo.38.1"> </span><span><span class="koboSpan" id="kobo.39.1">method </span></span><span class="koboSpan" id="kobo.40.1">is used in order to synchronize the processes:</span></p>
<pre class="mce-root"><span class="koboSpan" id="kobo.41.1">synchronizer.wait()</span></pre>
<p><span class="koboSpan" id="kobo.42.1">By running the script, we can see that the </span><kbd><span class="koboSpan" id="kobo.43.1">p1</span></kbd><span class="koboSpan" id="kobo.44.1"> and </span><kbd><span class="koboSpan" id="kobo.45.1">p2</span></kbd> <span><span class="koboSpan" id="kobo.46.1">processes </span></span><span class="koboSpan" id="kobo.47.1">print out the same timestamps as expected:</span></p>
<pre><strong><span class="koboSpan" id="kobo.48.1">&gt; python processes_barrier.py</span></strong><br/><strong><span class="koboSpan" id="kobo.49.1">process p4 - test_without_barrier ----&gt; 2019-03-03 08:58:06.159882</span></strong><br/><strong><span class="koboSpan" id="kobo.50.1">process p3 - test_without_barrier ----&gt; 2019-03-03 08:58:06.144257</span></strong><br/><strong><span class="koboSpan" id="kobo.51.1">process p1 - test_with_barrier ----&gt; 2019-03-03 08:58:06.175505</span></strong><br/><strong><span class="koboSpan" id="kobo.52.1">process p2 - test_with_barrier ----&gt; 2019-03-03 08:58:06.175505</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The following diagram shows you how a barrier works with the two processes:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.3.1"><img src="assets/f9077bdf-036b-4f0e-90ea-0ddfd80fc58f.png" style="width:29.17em;height:24.67em;"/></span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.4.1">Process management with a barrier</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">See also</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Please read </span><a href="https://pymotw.com/2/multiprocessing/communication.html"><span class="koboSpan" id="kobo.3.1">https://pymotw.com/2/multiprocessing/communication.html</span></a><span class="koboSpan" id="kobo.4.1"> for more examples of process synchronization.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Using a process pool</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The process pool mechanism allows the execution of a function across multiple input values to be parallelized, distributing </span><em><span class="koboSpan" id="kobo.3.1">the</span></em><span class="koboSpan" id="kobo.4.1"> input data between processes. The process pool, therefore, allows implementing the so-called </span><strong><span class="koboSpan" id="kobo.5.1">data parallelism</span></strong><span class="koboSpan" id="kobo.6.1"> that is based on the distribution of data through the different processes that operate on data in parallel.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The </span><kbd><span class="koboSpan" id="kobo.3.1">multiprocessing</span></kbd><span class="koboSpan" id="kobo.4.1"> library provides the </span><kbd><span class="koboSpan" id="kobo.5.1">Pool</span></kbd><span class="koboSpan" id="kobo.6.1"> class for simple parallel processing tasks.</span></p>
<p><span class="koboSpan" id="kobo.7.1">The </span><kbd><span class="koboSpan" id="kobo.8.1">Pool</span></kbd><span class="koboSpan" id="kobo.9.1"> class has the following methods:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.10.1">apply()</span></kbd><span class="koboSpan" id="kobo.11.1">: This blocks until the result is ready.</span></li>
<li><kbd><span class="koboSpan" id="kobo.12.1">apply_async()</span></kbd><span class="koboSpan" id="kobo.13.1">: This is a variant of the </span><kbd><span class="koboSpan" id="kobo.14.1">apply()</span></kbd><span class="koboSpan" id="kobo.15.1"> (</span><a href="https://docs.python.org/2/library/functions.html#apply"><span class="koboSpan" id="kobo.16.1">https://docs.python.org/2/library/functions.html#apply</span></a><span class="koboSpan" id="kobo.17.1">) method, which returns a result object. </span><span class="koboSpan" id="kobo.17.2">It is an asynchronous operation that will not lock the main thread until all the child classes are executed.</span></li>
<li><kbd><span class="koboSpan" id="kobo.18.1">map()</span></kbd><span class="koboSpan" id="kobo.19.1">: This is the parallel equivalent of the </span><span><span class="koboSpan" id="kobo.20.1">built-in</span></span> <kbd><span class="koboSpan" id="kobo.21.1">map()</span></kbd><span class="koboSpan" id="kobo.22.1"> (</span><a href="https://docs.python.org/2/library/functions.html#map"><span class="koboSpan" id="kobo.23.1">https://docs.python.org/2/library/functions.html#map</span></a><span class="koboSpan" id="kobo.24.1">) function. </span><span class="koboSpan" id="kobo.24.2">This blocks until the result is ready, and it chops the iterable data in a number of chunks that are submitted to the process pool as separate tasks.</span></li>
<li><kbd><span class="koboSpan" id="kobo.25.1">map_async()</span></kbd><span class="koboSpan" id="kobo.26.1">: This is a variant of the </span><kbd><span class="koboSpan" id="kobo.27.1">map()</span></kbd><span class="koboSpan" id="kobo.28.1"> (</span><a href="https://docs.python.org/2/library/multiprocessing.html?highlight=pool%20class#multiprocessing.pool.multiprocessing.Pool.map"><span class="koboSpan" id="kobo.29.1">https://docs.python.org/2/library/multiprocessing.html?highlight=pool%20class#multiprocessing.pool.multiprocessing.Pool.map</span></a><span class="koboSpan" id="kobo.30.1">) method, which returns a </span><kbd><span class="koboSpan" id="kobo.31.1">result</span></kbd><span class="koboSpan" id="kobo.32.1"> object. </span><span class="koboSpan" id="kobo.32.2">If a callback is specified, then it should be callable, which accepts a single argument. </span><span class="koboSpan" id="kobo.32.3">When the result becomes ready, a callback is applied to it (unless the call fails). </span><span class="koboSpan" id="kobo.32.4">A callback should be completed immediately; otherwise, the thread that handles the results will get blocked.</span></li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it…</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">This example shows you how to implement a process pool to perform a parallel application. </span><span class="koboSpan" id="kobo.2.2">We create a pool of four processes and then we use the pool's </span><kbd><span class="koboSpan" id="kobo.3.1">map</span></kbd><span class="koboSpan" id="kobo.4.1"> method to perform a simple function:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.5.1">Import the </span><kbd><span class="koboSpan" id="kobo.6.1">multiprocessing</span></kbd><span class="koboSpan" id="kobo.7.1"> library:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.8.1">import multiprocessing</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.9.1">The </span><kbd><span class="koboSpan" id="kobo.10.1">Pool</span></kbd><span class="koboSpan" id="kobo.11.1"> method applies </span><kbd><span class="koboSpan" id="kobo.12.1">function_square</span></kbd><span class="koboSpan" id="kobo.13.1"> to the input element to perform a simple calculation:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.14.1">def function_square(data):</span><br/><span class="koboSpan" id="kobo.15.1">    result = data*data</span><br/><span class="koboSpan" id="kobo.16.1">    return result</span><br/><br/><span class="koboSpan" id="kobo.17.1">if __name__ == '__main__':</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.18.1">The parameter inputs are a list of integers from </span><kbd><span class="koboSpan" id="kobo.19.1">0</span></kbd><span class="koboSpan" id="kobo.20.1"> to </span><kbd><span class="koboSpan" id="kobo.21.1">100</span></kbd><span class="koboSpan" id="kobo.22.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.23.1">    inputs = list(range(0,100))</span></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.24.1">The total number of parallel processes is </span><kbd><span class="koboSpan" id="kobo.25.1">4</span></kbd><span class="koboSpan" id="kobo.26.1">:</span></li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><span class="koboSpan" id="kobo.27.1">    pool = multiprocessing.Pool(processes=4)</span></pre>
<ol start="5">
<li><span class="koboSpan" id="kobo.28.1">The </span><kbd><span class="koboSpan" id="kobo.29.1">pool.map</span></kbd><span class="koboSpan" id="kobo.30.1"> method submits to the process pool as separate tasks:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.31.1">    pool_outputs = pool.map(function_square, inputs)</span><br/><span class="koboSpan" id="kobo.32.1">    pool.close() </span><br/><span class="koboSpan" id="kobo.33.1">    pool.join() </span></pre>
<ol start="6">
<li><span class="koboSpan" id="kobo.34.1">The result of the calculation is stored in </span><kbd><span class="koboSpan" id="kobo.35.1">pool_outputs</span></kbd><span class="koboSpan" id="kobo.36.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.37.1">    print ('Pool    :', pool_outputs)</span></pre>
<p><span class="koboSpan" id="kobo.38.1">It is important to note that the result of the </span><kbd><span class="koboSpan" id="kobo.39.1">pool.map()</span></kbd><span class="koboSpan" id="kobo.40.1"> method is equivalent to Python's built-in </span><kbd><span class="koboSpan" id="kobo.41.1">map()</span></kbd><span class="koboSpan" id="kobo.42.1"> </span><span><span class="koboSpan" id="kobo.43.1">function,</span></span><span class="koboSpan" id="kobo.44.1"> except that the processes run in parallel.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works…</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Here, we have created a pool of four processes using the following statement:</span></p>
<pre class="mce-root"><span class="koboSpan" id="kobo.3.1">  pool = multiprocessing.Pool(processes=4)</span></pre>
<p><span class="koboSpan" id="kobo.4.1">Each process has a list of integers as input. </span><span class="koboSpan" id="kobo.4.2">Here, </span><span><kbd><span class="koboSpan" id="kobo.5.1">pool.map</span></kbd><span class="koboSpan" id="kobo.6.1"> works in the same way as the map, but uses multiple processes, whose number, four, was previously defined during pool creation:</span></span></p>
<pre><span class="koboSpan" id="kobo.7.1">   pool_outputs = pool.map(function_square, inputs)</span></pre>
<p><span class="koboSpan" id="kobo.8.1">To terminate the computation of the pool, the usual </span><kbd><span class="koboSpan" id="kobo.9.1">close</span></kbd><span class="koboSpan" id="kobo.10.1"> and </span><kbd><span class="koboSpan" id="kobo.11.1">join</span></kbd> <span><span class="koboSpan" id="kobo.12.1">functions </span></span><span class="koboSpan" id="kobo.13.1">are used:</span></p>
<pre><span class="koboSpan" id="kobo.14.1">    pool.close() </span><br/><span class="koboSpan" id="kobo.15.1">    pool.join() </span></pre>
<p><span class="koboSpan" id="kobo.16.1">To execute this, type the following command:</span></p>
<pre><strong><span class="koboSpan" id="kobo.17.1">&gt; python process_pool.py</span></strong></pre>
<p><span class="koboSpan" id="kobo.18.1">This is the result that we get after completing the calculation:</span></p>
<pre><strong><span class="koboSpan" id="kobo.19.1">Pool : [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400, 441, 484, 529, 576, 625, 676, 729, 784, 841, 900, 961, 1024, 1089, 1156, 1225, 1296, 1369, 1444, 1521, 1600, 1681, 1764, 1849, 1936, 2025, 2116, 2209, 2304, 2401, 2500, 2601, 2704, 2809, 2916, 3025, 3136, 3249, 3364, 3481, 3600, 3721, 3844, 3969, 4096, 4225, 4356, 4489, 4624, 4761, 4900, 5041, 5184, 5329, 5476, 5625, 5776, 5929, 6084, 6241, 6400, 6561, 6724, 6889, 7056, 7225, 7396, 7569, 7744, 7921, 8100, 8281, 8464, 8649, 8836, 9025, 9216, 9409, 9604, 9801]</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In the previous example, we saw that </span><kbd><span class="koboSpan" id="kobo.3.1">Pool</span></kbd><span class="koboSpan" id="kobo.4.1"> </span><span><span class="koboSpan" id="kobo.5.1">also </span></span><span class="koboSpan" id="kobo.6.1">provides the </span><kbd><span class="koboSpan" id="kobo.7.1">map</span></kbd><span class="koboSpan" id="kobo.8.1"> method, which allows us to apply a function to a different set of data. </span><span class="koboSpan" id="kobo.8.2">In particular, the</span><span><span class="koboSpan" id="kobo.9.1"> scenario in which the</span></span><span class="koboSpan" id="kobo.10.1"> same operation is performed in parallel on the elements of the input is referred to as</span><strong><span class="koboSpan" id="kobo.11.1"> </span></strong><em><span class="koboSpan" id="kobo.12.1">data parallelism</span></em><span class="koboSpan" id="kobo.13.1">.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.14.1">In the following example, in which we use </span><kbd><span class="koboSpan" id="kobo.15.1">Pool</span></kbd><span class="koboSpan" id="kobo.16.1"> and </span><kbd><span class="koboSpan" id="kobo.17.1">map</span></kbd><span class="koboSpan" id="kobo.18.1">, w</span><span><span class="koboSpan" id="kobo.19.1">e create </span><kbd><span class="koboSpan" id="kobo.20.1">pool</span></kbd><span class="koboSpan" id="kobo.21.1"> with </span></span><kbd><span class="koboSpan" id="kobo.22.1">5</span></kbd><span><span class="koboSpan" id="kobo.23.1"> workers and, through the </span><kbd><span class="koboSpan" id="kobo.24.1">map</span></kbd><span class="koboSpan" id="kobo.25.1"> method,</span><em><span class="koboSpan" id="kobo.26.1"> </span></em><span class="koboSpan" id="kobo.27.1">a function of </span></span><kbd><span class="koboSpan" id="kobo.28.1">f</span></kbd><span><span class="koboSpan" id="kobo.29.1"> is applied to a list of </span></span><kbd><span class="koboSpan" id="kobo.30.1">10</span></kbd><span><span class="koboSpan" id="kobo.31.1"> elements:</span></span></p>
<pre><span class="koboSpan" id="kobo.32.1">from multiprocessing import Pool</span><br/><br/><span class="koboSpan" id="kobo.33.1">def f(x):</span><br/><span class="koboSpan" id="kobo.34.1">    return x+10</span><br/><br/><span class="koboSpan" id="kobo.35.1">if __name__ == '__main__':</span><br/><span class="koboSpan" id="kobo.36.1">     p=Pool(processes=5)</span><br/><span class="koboSpan" id="kobo.37.1">     print(p.map(f, [1, 2, 3,5,6,7,8,9,10]))</span></pre>
<p><span class="koboSpan" id="kobo.38.1">The output is as follows:</span></p>
<pre><strong><span class="koboSpan" id="kobo.39.1">11 12 13 14 15 16 17 18 19 20</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">See also</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">To learn more information about process </span><span><span class="koboSpan" id="kobo.3.1">pools, use</span></span><span class="koboSpan" id="kobo.4.1"> the following link: </span><a href="https://www.tutorialspoint.com/concurrency_in_python/concurrency_in_python_pool_of_processes.htm"><span class="koboSpan" id="kobo.5.1">https://www.tutorialspoint.com/concurrency_in_python/concurrency_in_python_pool_of_processes.htm</span></a><span class="koboSpan" id="kobo.6.1">.</span></p>


            </article>

            
        </section>
    </body></html>