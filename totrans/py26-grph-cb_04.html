<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 4. Animation Principles"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Animation Principles</h1></div></div></div><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Static shifting of a ball</li><li class="listitem" style="list-style-type: disc">Timed shifting of a ball</li><li class="listitem" style="list-style-type: disc">Animation timed draw-and-erase cycles</li><li class="listitem" style="list-style-type: disc">Two balls moving unimpeded</li><li class="listitem" style="list-style-type: disc">A ball that bounces</li><li class="listitem" style="list-style-type: disc">Bouncing in a gravitational field</li><li class="listitem" style="list-style-type: disc">Colliding balls with tracer trails</li><li class="listitem" style="list-style-type: disc">Elastic ball against ball collisions</li><li class="listitem" style="list-style-type: disc">Dynamic debugging</li><li class="listitem" style="list-style-type: disc">Trajectory tracing</li><li class="listitem" style="list-style-type: disc">Rotating a line and vital trigonometry</li><li class="listitem" style="list-style-type: disc">Rotating lines which rotate lines</li><li class="listitem" style="list-style-type: disc">A digital flower</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec01"/>Introduction</h1></div></div></div><p>Animation is about making graphic objects move smoothly around a screen. The method to create the sensation of smooth dynamic action is simple:<a id="id73" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">First present a picture to the viewer's eye.<a id="id74" class="indexterm"/></li><li class="listitem">Allow the image to stay in view for about one-twentieth of a second.</li><li class="listitem">With a minimum of delay, present another picture where objects have been shifted by a small amount and repeat the process.</li></ol></div><p>Besides the obvious applications of making animated figures move around on a screen for entertainment, animating the results of computer code gives you powerful insights into how code works at a detailed level. Animation offers an extra dimension to the programmers' debugging arsenal. It provides you with an all encompassing, holistic view of software execution in progress that nothing else can.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Static shifting of a ball"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec02"/>Static shifting of a ball</h1></div></div></div><p>We make an image of a small colored disk and draw it in a sequence of different positions.<a id="id75" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec01"/>How to do it...</h2></div></div></div><p>Execute the program shown in exactly the same way as all the examples in<a class="link" href="ch02.html" title="Chapter 2. Drawing Fundamental Shapes"> Chapter 2</a>,<span class="emphasis"><em> Drawing Fundamental Shapes</em></span> and you will see a neat row of colored disks laid on top of each other going from top left to bottom right. The idea is to demonstrate the method of systematic position shifting that we will use again and again throughout the book.</p><div class="informalexample"><pre class="programlisting"># moveball_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title("shifted sequence")
cw = 250 # canvas width
ch = 130 # canvas height
chart_1 = Canvas(root, width=cw, height=ch, background="white")
chart_1.grid(row=0, column=0)
# The parameters determining the dimensions of the ball and its # position.
# ==========================================
posn_x = 1 # x position of box containing the ball (bottom)
posn_y = 1 # y position of box containing the ball (left edge)
shift_x = 3 # amount of x-movement each cycle of the 'for' loop
shift_y = 2 # amount of y-movement each cycle of the 'for' loop
ball_width = 12 # size of ball - width (x-dimension)
ball_height = 12 # size of ball - height (y-dimension)
color = "violet" # color of the ball
for i in range(1,50): # end the program after 50 position shifts
posn_x += shift_x
posn_y += shift_y
chart_1.create_oval(posn_x, posn_y, posn_x + ball_width,\
posn_y + ball_height, fill=color)
root.mainloop()
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec02"/>How it works...</h2></div></div></div><p>A simple ball is drawn on a canvas in a sequence of steps, one on top of the other. For each step, the position of the ball is shifted by three pixels as specified by the size of<code class="literal"> shift_x</code>. Similarly, a downward shift of two pixels is applied by an amount to the value of<code class="literal"> shift_y. shift_x</code> and<code class="literal"> shift_y</code> only specify the amount of shift, but they do not make it happen. What makes it happen are the two commands<code class="literal"> posn_x += shift_x</code> and<code class="literal"> posn_y += shift_y. posn</code> is the abbreviation for position. An important word of explanation of this notation is needed here because we use it often throughout the book. It is neat and handy.<a id="id76" class="indexterm"/>
</p><p>
<code class="literal">posn_x += shift_x</code> means "take the variable<code class="literal"> posn_x</code> and add to it an amount<code class="literal"> shift_x."</code> It is the same as<code class="literal"> posn_x = posn_x + shift_x</code>.</p><p>Another minor point to note is the use of the line continuation character, the backslash "\". We use this when we want to continue the same Python command onto a following line to make reading easier. Strictly speaking for text inside brackets "(...)" this is not needed. In this particular case you can just insert a carriage return character. However, the backslash makes it clear to anyone reading your code what your intention is.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec03"/>There's more...</h2></div></div></div><p>The series of ball images in this recipe were drawn in a few microseconds. To create decent looking animation, we need to be able to slow the code execution down by just the right amount. We need to draw the equivalent of a movie frame onto the screen and keep it there for a measured time and then move on to the next, slightly shifted, image. This is done in the next recipe.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time-controlled shifting of a ball"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec03"/>Time-controlled shifting of a ball</h1></div></div></div><p>Here we introduce the time control function<code class="literal"> canvas.after(milliseconds)</code> and the<code class="literal"> canvas.update()</code> function that refreshes the image on the canvas. These are the cornerstones of animation in Python.<a id="id77" class="indexterm"/>
</p><p>Control of when code gets executed is made possible by the time module that comes with the standard Python library.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec04"/>How to do it...</h2></div></div></div><p>Execute the program as previously. What you will see is a diagonal row of disks being laid in a line with a short delay of one fifth of a second (200 milliseconds) between updates. The result is shown in the following screenshot showing the ball shifting in regular intervals.<a id="id78" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3845_04_01.jpg" width="98" alt="How to do it..."/></div><div class="informalexample"><pre class="programlisting"># timed_moveball_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title("Time delayed ball drawing")
cw = 300 # canvas width
ch = 130 # canvas height
chart_1 = Canvas(root, width=cw, height=ch, background="white")
chart_1.grid(row=0, column=0)
cycle_period = 200 # time between fresh positions of the ball
# (milliseconds).
# The parameters determining the dimensions of the ball and it's # position.
posn_x = 1 # x position of box containing the ball (bottom).
posn_y = 1 # y position of box containing the ball (left edge).
shift_x = 3 # amount of x-movement each cycle of the 'for' loop.
shift_y = 3 # amount of y-movement each cycle of the 'for' loop.
ball_width = 12 # size of ball - width (x-dimension).
ball_height = 12 # size of ball - height (y-dimension).
color = "purple" # color of the ball
for i in range(1,50): # end the program after 50 position shifts.
posn_x += shift_x
posn_y += shift_y
chart_1.create_oval(posn_x, posn_y, posn_x + ball_width,\
posn_y + ball_height, fill=color)
chart_1.update() # This refreshes the drawing on the canvas.
chart_1.after(cycle_period) # This makes execution pause for 200 # milliseconds.
root.mainloop()
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec05"/>How it works...</h2></div></div></div><p>This recipe is the same as the previous one except for the<code class="literal"> canvas.after(...)</code> and the<code class="literal"> canvas.update()</code> methods. These are two functions that come from the Python library. The first gives you some control over code execution time by allowing you to specify delays in execution. The second forces the canvas to be completely redrawn with all the objects that should be there. There are more complicated ways of refreshing only portions of the screen, but they create difficulties so they will not be dealt with here.<a id="id79" class="indexterm"/>
</p><p>The<code class="literal"> canvas.after(your-chosen-milliseconds)</code> method simply causes a timed-pause to the execution of the code. In all the preceding code, the pause is executed as fast as the computer can do it, then when the pause, invoked by the<code class="literal"> canvas.after()</code> method is encountered, execution simply gets suspended for the specified number of milliseconds. At the end of the pause, execution continues as if nothing ever happened.<a id="id80" class="indexterm"/>
</p><p>The<code class="literal"> canvas.update()</code> method forces everything on the canvas to be redrawn immediately rather than wait for some unspecified event to cause the canvas to be refreshed.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec06"/>There's more...</h2></div></div></div><p>The next step in effective animation is to erase the previous image of the object being animated shortly before a fresh, shifted clone is drawn on the canvas. This happens in the next example.</p><div class="section" title="The robustness of Tkinter"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec01"/>The robustness of Tkinter</h3></div></div></div><p>It is also worth noting that Tkinter is robust. When you give position coordinates that are off the canvas, Python does not crash or freeze. It simply carries on drawing the object 'off-the-page'. The Tkinter canvas can be seen as just a tiny window into an almost unlimited universe of visual space. We only see objects when they move into the view of the camera which is the Tkinter canvas.<a id="id81" class="indexterm"/>
</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Complete animation using draw-move-pause-erase cycles"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec04"/>Complete animation using draw-move-pause-erase cycles</h1></div></div></div><p>This recipe gives you the whole animation procedure. All the actions necessary for the human brain to interpret images on the retina as moving objects are present in this example. The whole craft of animation and the million dollar movies based thereon is demonstrated here in its simplest and purest form.<a id="id82" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec07"/>How to do it...</h2></div></div></div><p>Execute this program as we have done before. Note that this time we have reduced the timed pause to 50 milliseconds which is 20 times per second. This is close to the standard 24 frames per second used in movies. However, without a graphics card this time becomes less accurate as shorter pauses are specified. In addition, the distance moved between position shifts of the ball has been reduced to one pixel.</p><div class="informalexample"><pre class="programlisting"># move_erase_cycle_1.py
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title("move-and-erase")
cw = 230 # canvas width
ch = 130 # canvas height
chart_1 = Canvas(root, width=cw, height=ch, background="white")
chart_1.grid(row=0, column=0)
cycle_period = 50 # time between new positions of the ball
# (milliseconds).
# The parameters determining the dimensions of the ball and its
# position.
posn_x = 1 # x position of box containing the ball (bottom).
posn_y = 1 # y position of box containing the ball (left edge).
shift_x = 1 # amount of x-movement each cycle of the 'for' loop.
draw-move-pause-erase cyclesusing, in animationshift_y = 1 # amount of y-movement each cycle of the 'for' loop.
ball_width = 12 # size of ball - width (x-dimension).
ball_height = 12 # size of ball height (y-dimension).
color = "hot pink" # color of the ball
for i in range(1,500): # end the program after 500 position shifts.
posn_x += shift_x
posn_y += shift_y
chart_1.create_oval(posn_x, posn_y, posn_x + ball_width,\
posn_y + ball_height, fill=color)
chart_1.update() # This refreshes the drawing on the canvas.
chart_1.after(cycle_period) # This makes execution pause for 200 # milliseconds.
chart_1.delete(ALL) # This erases everything on the canvas.
root.mainloop()
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec08"/>How it works...</h2></div></div></div><p>The new element in this self-contained animation is the<code class="literal"> canvas.delete(ALL)</code> method that clears the entire canvas of everything that was drawn on it. It is possible to erase only specific objects on the screen through the use of identification tags. This is not needed now. Selective object deletion using tags will be used in the last three recipes of this chapter.<a id="id84" class="indexterm"/>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec09"/>There's more...</h2></div></div></div><p>How accurate is the timing of the<code class="literal"> pause()</code> method?.</p><p>With modern computers, pauses of five milliseconds are realistic but the animation becomes jerky as the pause times get shorter.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="More than one moving object"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec05"/>More than one moving object</h1></div></div></div><p>We want to be able to develop programs where more than one independent graphic object co-exists and interacts according to some rules. This is how most computer games work. Pilot training simulators and serious engineering design models are designed on the same principles. We start this process simply by working up to an application that ends up with two balls bouncing off the walls and each other under the influence of gravity and energy loss.<a id="id85" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec10"/>How to do it...</h2></div></div></div><p>The following code is very similar to that in the previous recipe, except that two similar objects are created. They are independent of each other and do not interact in any way.</p><div class="informalexample"><pre class="programlisting"># two_balls_moving_1.py
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title("Two balls")
cw = 200 # canvas width
ch = 130 # canvas height
chart_1 = Canvas(root, width=cw, height=ch, background="white")
chart_1.grid(row=0, column=0)
cycle_period = 100 # time between new positions of the ball
# (milliseconds).
# The parameters defining ball no 1.
posn_x_1 = 1 # x position of box containing the ball (bottom).
posn_y_1 = 1 # y position of box containing the ball (left edge).
shift_x_1 = 1 # amount of x-movement each cycle of the 'for' loop.
shift_y_1 = 1 # amount of y-movement each cycle of the 'for' loop.
ball_width_1 = 12 # size of ball - width (x-dimension).
ball_height_1 = 12 # size of ball - height (y-dimension).
color_1 = "blue" # color of ball #1
# The parameters defining ball no 2.
posn_x_2 = 180 # x position of box containing the ball (bottom).
multiple objectsmovingposn_y_2 = 180 # x position of box containing the ball (left # edge).
shift_x_2 = -2 # amount of x-movement each cycle of the 'for' # loop.
shift_y_2 = -2 # amount of y-movement each cycle of the 'for' # loop.
ball_width_2 = 8 # size of ball - width (x-dimension).
ball_height_2 = 8 # size of ball - height (y-dimension).
color_2 = "green" # color of ball #2.
for i in range(1,100): # end the program after 50 position shifts.
posn_x_1 += shift_x_1
posn_y_1 += shift_y_1
posn_x_2 += shift_x_2
posn_y_2 += shift_y_2
chart_1.create_oval(posn_x_1, posn_y_1, posn_x_1 + ball_width_1,\
posn_y_1 + ball_height_1, fill=color_1)
chart_1.create_oval(posn_x_2, posn_y_2, posn_x_2 + ball_width_2,\
posn_y_2 + ball_height_2, fill=color_2)
chart_1.update() # This refreshes the drawing on the canvas.
chart_1.after(cycle_period) # This makes execution pause for 100 # milliseconds.
chart_1.delete(ALL) # This erases everything on the canvas
root.mainloop()
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec11"/>How it works...</h2></div></div></div><p>The main point to note is that these programs, and many others in this book, are divided into five parts:<a id="id87" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Creating the environment where objects will exist.</li><li class="listitem">Defining the individual objects and their attributes.</li><li class="listitem">Defining the rules of engagement between objects.</li><li class="listitem">Creating the objects.</li><li class="listitem">Using a loop to simulate the march of time by changing properties such as position at rates that mimic real-time motion.</li><li class="listitem">Controlling the environment inside which the objects exist.</li></ol></div><p>The environment in most of our examples is the Tkinter canvas. The objects that are going to exist inside the canvas environment in this example are two colored balls. The rules of engagement are that they will not have any effect on each other at all and they will not be affected by the edges of the canvas. Another rule of engagement is how their positions will shift each time the<code class="literal"> for</code> loop is executed.</p><p>Finally the environment is controlled by the time regulated<code class="literal"> canvas.update()</code> and<code class="literal"> canvas.delete(ALL)</code> methods.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec12"/>There's more...</h2></div></div></div><p>The principle idea demonstrated in this recipe is that we can create more than one similar, but different objects exist and react independently. This gives rise to the idea of object-oriented programming.</p><p>Python offers more than one way to use the ideas of object-oriented programming. In this book, we use three ways of making objects: lists, dictionaries, and classes.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="A ball that bounces"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec06"/>A ball that bounces</h1></div></div></div><p>Now and in the next three examples, we add rules of engagement that are increasingly complex. The overall objective is to introduce behaviors and interactions into our artificial world to make it behave more like the real world. We use numbers, calculations, and graphical drawings to represent aspects of the real world as we know it.<a id="id88" class="indexterm"/>
</p><p>The first new behavior is that our colored disks will bounce elastically off the walls of the container that is the Tkinter canvas.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec13"/>How to do it...</h2></div></div></div><p>The code has purposely been kept as similar as possible to the previous four examples so that we feel we are still in familiar territory as the world we create gets increasingly more complicated. If we did not do this, we would get lost and bewildered. The whole secret in successfully constructing complex computer programs is to build it up gradually and systematically piece-by-piece. It is not a planned journey along a well-mapped road but rather a strenuous exploration through uncharted jungle.</p><div class="informalexample"><pre class="programlisting"># bounce_ball.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
import time
root = Tk()
root.title("The bouncer")
cw = 200 # canvas width
ch = 120 # canvas height
chart_1 = Canvas(root, width=cw, height=ch, background="white")
chart_1.grid(row=0, column=0)
cycle_period = 50 # time between new positions of the ball
# (milliseconds).
# The parameters determining the dimensions of the ball and its position.
posn_x = 1 # x position of box containing the ball (bottom).
posn_y = 1 # x position of box containing the ball (left edge).
shift_x = 1 # amount of x-movement each cycle of the 'for' loop.
shift_y = 1 # amount of y-movement each cycle of the 'for' loop.
ball_width = 12 # size of ball - width (x-dimension).
ball_height = 12 # size of ball - height (y-dimension).
color = "firebrick" # color of the ball
# Here is a function that detects collisions with the walls of the # container
# and then reverses the direction of movement if a collision is # detected.
def detect_wall_collision():
global posn_x, posn_y, shift_x, shift_y, cw, cy
if posn_x &gt; cw : # Collision with right-hand container wall.
shift_x = -shift_x # reverse direction.
if posn_x &lt; 0 : # Collision with left-hand wall.
shift_x = -shift_x
if posn_y &gt; ch : # Collision with floor.
ballbouncingshift_y = -shift_y
if posn_y &lt; 0 : # Collision with ceiling.
shift_y = -shift_y
for i in range(1,1000): # end the program after1000 position shifts.
posn_x += shift_x
posn_y += shift_y
chart_1.create_oval(posn_x, posn_y, posn_x + ball_width,\
posn_y + ball_height, fill=color)
detect_wall_collision() # Has the ball collided with # any container wall?
chart_1.update() # This refreshes the drawing on the canvas.
chart_1.after(cycle_period) # This makes execution pause # for 200 milliseconds.
chart_1.delete(ALL) # This erases everything on the canvas.
root.mainloop()
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec14"/>How it works...</h2></div></div></div><p>The new feature here is the function<code class="literal"> detect_Wall_Collision()</code>. Whenever it is called, it checks whether the position of the ball has moved outside the boundary of the canvas. If it has, the direction of the ball is reversed. This method is crude because it does not compensate for the size of the ball. Consequently the ball pops out of existence.<a id="id90" class="indexterm"/>
</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Bouncing in a gravity field"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec07"/>Bouncing in a gravity field</h1></div></div></div><p>In this recipe, the influence of a gravitational field is added to the previous rule of bouncing off the canvas wall.<a id="id91" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec15"/>How to do it...</h2></div></div></div><p>What makes this recipe different to all the previous ones is a new attribute of the ball named<code class="literal"> velocity_y</code>. With every cycle of the for i in<code class="literal"> range(0,300)</code> loop the velocity is modified just as it would be in the gravitational field of our real world.</p><div class="informalexample"><pre class="programlisting"># gravityball.py
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title("Gravity bounce")
cw = 220 # canvas width
ch = 200 # canvas height
GRAVITY = 4
chart_1 = Canvas(root, width=cw, height=ch, background="white")
chart_1.grid(row=0, column=0)
cycle_period = 30
# The parameters determining the dimensions of the ball and its # position.
posn_x = 15
posn_y = 180
shift_x = 1
velocity_y = 50
ball_width = 12
ball_height = 12
color = "blue"
# The function that detects collisions with the walls and reverses # direction
def detect_wall_collision():
global posn_x, posn_y, shift_x, velocity_y, cw, cy
if posn_x &gt; cw -ball_width: # Collision with right-hand # container wall.
shift_x = -shift_x # reverse direction.
if posn_x &lt; ball_width: # Collision with left-hand wall.
shift_x = -shift_x
ballbouncing, in gravity fieldif posn_y &lt; ball_height : # Collision with ceiling.
velocity_y = -velocity_y
if posn_y &gt; ch - ball_height : # Floor collision.
velocity_y = -velocity_y
for i in range(1,300):
posn_x += shift_x
velocity_y = velocity_y + GRAVITY # a crude equation # incorporating gravity.
posn_y += velocity_y
chart_1.create_oval(posn_x, posn_y, posn_x + ball_width, \
posn_y + ball_height, \ fill=color)
detect_wall_collision() # Has the ball collided with any # container wall?
chart_1.update() # This refreshes the drawing on the canvas.
chart_1.after(cycle_period) # This makes execution pause for 200 # milliseconds.
chart_1.delete(ALL) # This erases everything on the canvas.
root.mainloop()
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec16"/>How it works...</h2></div></div></div><p>The vertical<code class="literal"> velocity_y</code> property of our ball is increased by a constant quantity GRAVITY every time a new position is calculated. The net result is that the speed gets faster when the ball is falling downward and slower when it moves upward. Because the y-direction of a Tkinter canvas is positively increasing downward (contrary to our real world) this has the effect of slowing down the ball when moving upward and speeding it up when moving downward.<a id="id93" class="indexterm"/>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec17"/>There's more...</h2></div></div></div><p>There is a flaw with this simulation of a bouncing ball. The ball disappears off the canvas after about three bounces because the integer arithmetic used in calculating each new position of the ball and the criteria used to detect collisions with the wall are much too coarse. The result of this is that the ball finds itself outside of the conditions we have set up to reverse its direction when it hits the floor. The GRAVITY added to its velocity kick it beyond the interval if<code class="literal"> posn_y &gt; ch ball_height</code>, and the ball never gets placed back inside the canvas.</p><p>Positions on the canvas are defined as integers only but we need to deal with much greater precision than that when calculating the position of our ball. It turns out there is no problem here. In their wisdom the Python designers have allowed us to work with all our variables as floating point numbers that are very precise and still pass them to the<code class="literal"> canvas.create_oval(...)</code> method which draws the ball on the canvas. For the final drawing they obviously get converted into integers. Thank you wise Python guys.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec18"/>See also</h2></div></div></div><p>The next recipe,<code class="literal"> floating_point_collisions_1.py</code>, uses floating point position calculation to fix the flaws in this example.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Precise collisions using floating point numbers"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec08"/>Precise collisions using floating point numbers</h1></div></div></div><p>Here the simulation flaws caused by the coarseness of integer arithmetic are eliminated by using floating point numbers for all ball position calculations.<a id="id94" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec19"/>How to do it...</h2></div></div></div><p>All position, velocity, and gravity variables are made floating point by writing them with explicit decimal points. The result is shown in the following screenshot, showing the bouncing balls with trajectory tracing.</p><div class="mediaobject"><img src="images/3845_04_02.jpg" height="201" alt="How to do it..."/></div><div class="informalexample"><pre class="programlisting">from Tkinter import *
root = Tk()
root.title("Collisions with Floating point")
cw = 350 # canvas width
ch = 200 # canvas height
GRAVITY = 1.5
chart_1 = Canvas(root, width=cw, height=ch, background="black")
chart_1.grid(row=0, column=0)
cycle_period = 80 # Time between new positions of the ball # (milliseconds).
simulation flawseliminatingtime_scaling = 0.2 # This governs the size of the differential steps
# when calculating changes in position.
# The parameters determining the dimensions of the ball and it's # position.
ball_1 = {'posn_x':25.0, # x position of box containing the # ball (bottom).
'posn_y':180.0, # x position of box containing the # ball (left edge).
'velocity_x':30.0, # amount of x-movement each cycle of # the 'for' loop.
'velocity_y':100.0, # amount of y-movement each cycle of # the 'for' loop.
'ball_width':20.0, # size of ball - width (x-dimension).
'ball_height':20.0, # size of ball - height (y-dimension).
'color':"dark orange", # color of the ball
'coef_restitution':0.90} # proportion of elastic energy # recovered each bounce
ball_2 = {'posn_x':cw - 25.0,
'posn_y':300.0,
'velocity_x':-50.0,
'velocity_y':150.0,
'ball_width':30.0,
simulation flawseliminating'ball_height':30.0,
'color':"yellow3",
'coef_restitution':0.90}
def detectWallCollision(ball):
# Collision detection with the walls of the container
if ball['posn_x'] &gt; cw - ball['ball_width']: # Collision # with right-hand wall.
ball['velocity_x'] = -ball['velocity_x'] * ball['coef_ \ restitution'] # reverse direction.
ball['posn_x'] = cw - ball['ball_width']
if ball['posn_x'] &lt; 1: # Collision with left-hand wall.
ball['velocity_x'] = -ball['velocity_x'] * ball['coef_ \restitution']
ball['posn_x'] = 2 # anti-stick to the wall
if ball['posn_y'] &lt; ball['ball_height'] : # Collision # with ceiling.
ball['velocity_y'] = -ball['velocity_y'] * ball['coef_ \ restitution']
ball['posn_y'] = ball['ball_height']
if ball['posn_y'] &gt; ch - ball['ball_height']: # Floor # collision.
ball['velocity_y'] = - ball['velocity_y'] * ball['coef_ \restitution']
ball['posn_y'] = ch - ball['ball_height']
def diffEquation(ball):
# An approximate set of differential equations of motion # for the balls
ball['posn_x'] += ball['velocity_x'] * time_scaling
ball['velocity_y'] = ball['velocity_y'] + GRAVITY # a crude # equation incorporating gravity.
ball['posn_y'] += ball['velocity_y'] * time_scaling
chart_1.create_oval( ball['posn_x'], ball['posn_y'], ball['posn_x'] + ball['ball_width'],\
ball ['posn_y'] + ball['ball_height'], \ fill= ball['color'])
detectWallCollision(ball) # Has the ball collided with # any container wall?
for i in range(1,2000): # end the program after 1000 position shifts.
diffEquation(ball_1)
diffEquation(ball_2)
chart_1.update() # This refreshes the drawing on the canvas.
chart_1.after(cycle_period) # This makes execution pause for 200 # milliseconds.
chart_1.delete(ALL) # This erases everything on the
root.mainloop()
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec20"/>How it works...</h2></div></div></div><p>Use of precision arithmetic has allowed us to notice simulation behavior that was previously hidden by the sins of integer-only calculations. This is the UNIQUE VALUE OF GRAPHIC SIMULATION AS A DEBUGGING TOOL. If you can represent your ideas in a visual way rather than as lists of numbers you will easily pick up subtle quirks in your code. The human brain is designed to function best in graphical images. It is a direct consequence of being a hunter.<a id="id97" class="indexterm"/>
</p></div><div class="section" title="A graphic debugging tool..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec21"/>A graphic debugging tool...</h2></div></div></div><p>There is another very handy trick in the software debugger's arsenal and that is the visual trace. A trace is some kind of visual trail that shows the history of dynamic behavior. All of this is revealed in the next example.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Trajectory tracing and ball-to-ball collisions"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec09"/>Trajectory tracing and ball-to-ball collisions</h1></div></div></div><p>Now we introduce one of the more difficult behaviors in our simulation of ever increasing complexity the mid-air collision.<a id="id98" class="indexterm"/>
</p><p>The hardest thing when you are debugging a program is to try to hold in your short term memory some recently observed behavior and compare it meaningfully with present behavior. This kind of memory is an imperfect recorder. The way to overcome this is to create a graphic form of memory some sort of picture that shows accurately what has been happening in the past. In the same way that military cannon aimers use glowing tracer projectiles to adjust their aim, a graphic programmer can use trajectory traces to examine the history of execution.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec22"/>How to do it...</h2></div></div></div><p>In our new code there is a new function called<code class="literal"> detect_ball_collision (ball_1, ball_2)</code> whose job is to anticipate imminent collisions between the two balls no matter where they are. The collisions will come from any direction and therefore we need to be able to test all possible collision scenarios and examine the behavior of each one and see if it does not work as planned. This can be too difficult unless we create tools to test the outcome. In this recipe, the tool for testing outcomes is a graphic trajectory trace. It is a line that trails behind the path of the ball and shows exactly where it went right since the beginning of the simulation. The result is shown in the following screenshot, showing the bouncing with ball-to-ball collision rebounds.</p><div class="mediaobject"><img src="images/3845_04_03.jpg" width="175" alt="How to do it..."/></div><div class="informalexample"><pre class="programlisting"># kinetic_gravity_balls_1.py
animationmid-air collision# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
import math
root = Tk()
root.title("Balls bounce off each other")
cw = 300 # canvas width
ch = 200 # canvas height
GRAVITY = 1.5
chart_1 = Canvas(root, width=cw, height=ch, background="white")
chart_1.grid(row=0, column=0)
cycle_period = 80 # Time between new positions of the ball # (milliseconds).
time_scaling = 0.2 # The size of the differential steps
# The parameters determining the dimensions of the ball and its # position.
ball_1 = {'posn_x':25.0,
'posn_y':25.0,
'velocity_x':65.0,
'velocity_y':50.0,
'ball_width':20.0,
'ball_height':20.0,
'color':"SlateBlue1",
'coef_restitution':0.90}
ball_2 = {'posn_x':180.0,
'posn_y':ch- 25.0,
'velocity_x':-50.0,
'velocity_y':-70.0,
'ball_width':30.0,
'ball_height':30.0,
'color':"maroon1",
'coef_restitution':0.90}
def detect_wall_collision(ball):
animationmid-air collision# detect ball-to-wall collision
if ball['posn_x'] &gt; cw - ball['ball_width']: # Right-hand wall.
ball['velocity_x'] = -ball['velocity_x'] * ball['coef_ \restitution']
ball['posn_x'] = cw - ball['ball_width']
if ball['posn_x'] &lt; 1: # Left-hand wall.
ball['velocity_x'] = -ball['velocity_x'] * ball['coef_ \restitution']
ball['posn_x'] = 2
if ball['posn_y'] &lt; ball['ball_height'] : # Ceiling.
ball['velocity_y'] = -ball['velocity_y'] * ball['coef_ \restitution']
ball['posn_y'] = ball['ball_height']
if ball['posn_y'] &gt; ch - ball['ball_height'] : # Floor
ball['velocity_y'] = - ball['velocity_y'] * ball['coef_ \restitution']
ball['posn_y'] = ch - ball['ball_height']
def detect_ball_collision(ball_1, ball_2):
#detect ball-to-ball collision
# firstly: is there a close approach in the horizontal direction
if math.fabs(ball_1['posn_x'] - ball_2['posn_x']) &lt; 25:
# secondly: is there also a close approach in the vertical # direction.
if math.fabs(ball_1['posn_y'] - ball_2['posn_y']) &lt; 25:
ball_1['velocity_x'] = -ball_1['velocity_x'] # reverse # direction.
ball_1['velocity_y'] = -ball_1['velocity_y']
ball_2['velocity_x'] = -ball_2['velocity_x']
ball_2['velocity_y'] = -ball_2['velocity_y']
# to avoid internal rebounding inside balls
ball_1['posn_x'] += ball_1['velocity_x'] * time_scaling
ball_1['posn_y'] += ball_1['velocity_y'] * time_scaling
ball_2['posn_x'] += ball_2['velocity_x'] * time_scaling
ball_2['posn_y'] += ball_2['velocity_y'] * time_scaling
animationmid-air collisiondef diff_equation(ball):
x_old = ball['posn_x']
y_old = ball['posn_y']
ball['posn_x'] += ball['velocity_x'] * time_scaling
ball['velocity_y'] = ball['velocity_y'] + GRAVITY
ball['posn_y'] += ball['velocity_y'] * time_scaling
chart_1.create_oval( ball['posn_x'], ball['posn_y'],\
ball['posn_x'] + ball['ball_width'],\
ball['posn_y'] + ball['ball_height'],\
fill= ball['color'], tags="ball_tag")
chart_1.create_line( x_old, y_old, ball['posn_x'], \ ball ['posn_y'], fill= ball['color'])
detect_wall_collision(ball) # Has the ball # collided with any container wall?
for i in range(1,5000):
diff_equation(ball_1)
diff_equation(ball_2)
detect_ball_collision(ball_1, ball_2)
chart_1.update()
chart_1.after(cycle_period)
chart_1.delete("ball_tag") # Erase the balls but # leave the trajectories
root.mainloop()
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec23"/>How it works...</h2></div></div></div><p>Mid-air ball against ball collisions are done in two steps. In the first step, we test whether the two balls are close to each other inside a vertical strip defined by<code class="literal"> if math.fabs(ball_1['posn_x'] - ball_2['posn_x']) &lt; 25</code>. In plain English, this asks "Is the horizontal distance between the balls less than 25 pixels?" If the answer is yes, then the region of examination is narrowed down to a small vertical distance less than 25 pixels by the statement<code class="literal"> if math.fabs(ball_1['posn_y'] - ball_2['posn_y']) &lt; 25</code>. So every time the loop is executed, we sweep the entire canvas to see if the two balls are both inside an area where their bottom-left corners are closer than 25 pixels to each other. If they are that close then we simply cause a rebound off each other by reversing their direction of travel in both the horizontal and vertical directions.<a id="id102" class="indexterm"/>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec24"/>There's more...</h2></div></div></div><p>Simply reversing the direction is not the mathematically correct way to reverse the direction of colliding balls. Certainly billiard balls do not behave that way. The law of physics that governs colliding spheres demands that momentum be conserved. This requires more complicated mathematics not covered in this book.</p></div><div class="section" title="Why do we sometimes get tkinter.TckErrors?"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec25"/>Why do we sometimes get tkinter.TckErrors?</h2></div></div></div><p>If we click the close window button (the X in the top right) while Python is paused, when Python revives and then calls on<code class="literal"> Tcl</code> (Tkinter) to draw something on the canvas we will get an error message. What probably happens is that the application has already shut down, but<code class="literal"> Tcl</code> has unfinished business. If we allow the program to run to completion before trying to shut the window then termination is orderly.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Rotating line"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec10"/>Rotating line</h1></div></div></div><p>Now we will see how to handle rotating lines. In any kind of graphic computer work, the need to rotate objects arises eventually. By starting off as simply as possible and progressively adding behaviors we can handle some increasingly complicated situations. This recipe is that first simple step in the art of making things rotate.<a id="id103" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec26"/>Getting ready</h2></div></div></div><p>To understand the mathematics of rotation you need to be reasonably familiar with the trigonometry functions of sine, cosine, and tangent. The good news for those of us whose eyes glaze at the mention of trigonometry is that you can use these examples without understanding trigonometry. However, it is much more rewarding if you do try to figure out the math. It is like the difference between watching football or playing it. Only the players get fit.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec27"/>How to do it...</h2></div></div></div><p>You just need to write and run this code and observe the results as you did for all the other recipes. The insights come from repeated tinkering and hacking the code. Change the values of variables<code class="literal"> p1_x</code> to<code class="literal"> p2_y</code> one at a time and observe the results.<a id="id104" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"># rotate_line_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
import math
root = Tk()
root.title("Rotating line")
cw = 220 # canvas width
ch = 180 # canvas height
chart_1 = Canvas(root, width=cw, height=ch, background="white")
chart_1.grid(row=0, column=0)
cycle_period = 50 # pause duration (milliseconds).
p1_x = 90.0 # the pivot point
p1_y = 90.0 # the pivot point,
p2_x = 180.0 # the specific point to be rotated
p2_y = 160.0 # the specific point to be rotated.
a_radian = math.atan((p2_y - p1_y)/(p2_x - p1_x))
a_length = math.sqrt((p2_y - p1_y)*(p2_y - p1_y) +\
(p2_x - p1_x)*(p2_x - p1_x))
for i in range(1,300): # end the program after 300 position shifts
a_radian +=0.05 # incremental rotation of 0.05 radians
p1_x = p2_x - a_length * math.cos(a_radian)
p1_y = p2_y - a_length * math.sin(a_radian)
chart_1.create_line(p1_x, p1_y, p2_x, p2_y)
chart_1.update()
chart_1.after(cycle_period)
chart_1.delete(ALL)
root.mainloop()
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec28"/>How it works...</h2></div></div></div><p>In essence, all rotation comes down to the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Establish a center of rotation or pivot point</li><li class="listitem" style="list-style-type: disc">Pick a specific point on the object you want to rotate</li><li class="listitem" style="list-style-type: disc">Calculate the distance from the pivot point to the specific point of interest</li><li class="listitem" style="list-style-type: disc">Calculate the angle of the line joining the pivot and the specific point</li><li class="listitem" style="list-style-type: disc">Increase the angle of the line joining the points by a known amount, the rotation angle, and re-calculate the new x and y coordinates for that point.</li></ul></div><p>For math students what you do is relocate the origin of your rectangular coordinate system to the pivot point, express the coordinates of your specific point into polar coordinates, add an increment to the angular position, and convert the new polar coordinate position into a fresh pair of rectangular coordinates. The preceding recipe performs all these actions.<a id="id105" class="indexterm"/>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec29"/>There's more...</h2></div></div></div><p>The pivot point was purposely placed near the bottom corner of the canvas so that the point on the end of the line to be rotated would fall outside the canvas for much of the rotation process. The rotation continues without errors or bad behavior emphasizing a point made earlier in this chapter that Python is mathematically robust. However, we need to exercise care when using the<code class="literal"> arctangent</code> function<code class="literal"> math.atan()</code> because it flips from a value positive infinity to negative infinity as angles move through 90 and 270 degrees.<code class="literal"> Atan()</code> can give ambiguous results. Again the Python designers have taken care of business well by creating the math.<code class="literal"> atan2(y,x)</code> function that takes into account the signs of both y and x to give unambiguous results between 180 degrees and -180.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Trajectory tracing on multiple line rotations"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec11"/>Trajectory tracing on multiple line rotations</h1></div></div></div><p>This example draws a visually appealing kind of Art Noveau arrowhead but that is just an issue on the happy-side. The real point of this recipe is to see how you can have any number of pivot points all with different motions and that the essential arithmetic remains simple and clean looking in Python. The use of animation methods to slow the execution down makes it entertaining to watch. We also see how tag names given to different parts of the objects drawn onto the canvas allow them to be selectively erased when the<code class="literal"> canvas.delete(...)</code> method is invoked.<a id="id106" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec30"/>Getting ready</h2></div></div></div><p>Imagine a skilled drum major marching in a parade whirling a staff in circles. Holding onto the end of the staff is a small monkey also twirling a baton but at a different speed. At the tip of the monkey's staff is a miniature marmoset twirling a baton in the opposite direction...</p><p>Now run the program.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec31"/>How to do it...</h2></div></div></div><p>Run the Python code below as we have done before. The result is shown in following screenshot showing multiple line rotation traces.</p><div class="mediaobject"><img src="images/3845_04_04_new.jpg" width="271" alt="How to do it..."/></div><div class="informalexample"><pre class="programlisting"># multiple_line_rotations_1.py
multiple line rotationstrajectory tracing#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
import math
root = Tk()
root.title("multi-line rotations")
cw = 600 # canvas width
ch = 600 # canvas height
chart_1 = Canvas(root, width=cw, height=ch, background="white")
chart_1.grid(row=0, column=0)
cycle_period = 50 # time between new positions of the ball # (milliseconds).
p0_x = 300.0
p0_y = 300.0
p1_x = 200.0
p1_y = 200.0
p2_x = 150.0 # central pivot
p2_y = 150.0 # central pivot
p3_x = 100.0
p3_y = 100.0
p4_x = 50.0
p4_y = 50.0
alpha_0 = math.atan((p0_y - p1_y)/(p0_x - p1_x))
length_0_1 = math.sqrt((p0_y - p1_y)*(p0_y - p1_y) +\
(p0_x - p1_x)*(p0_x - p1_x))
alpha_1 = math.atan((p1_y - p2_y)/(p1_x - p2_x))
multiple line rotationstrajectory tracinglength_1_2 = math.sqrt((p2_y - p1_y)*(p2_y - p1_y) +\
(p2_x - p1_x)*(p2_x - p1_x))
alpha_2 = math.atan((p2_y - p3_y)/(p2_x - p3_x))
length_2_3 = math.sqrt((p3_y - p2_y)*(p3_y - p2_y) +\
(p3_x - p2_x)*(p3_x - p2_x))
alpha_3 = math.atan((p3_y - p4_y)/(p3_x - p4_x))
length_3_4 = math.sqrt((p4_y - p3_y)*(p4_y - p3_y) +\
(p4_x - p3_x)*(p4_x - p3_x))
for i in range(1,5000):
alpha_0 += 0.1
alpha_1 += 0.3
alpha_2 -= 0.4
p1_x = p0_x - length_0_1 * math.cos(alpha_0)
p1_y = p0_y - length_0_1 * math.sin(alpha_0)
tip_locus_2_x = p2_x
tip_locus_2_y = p2_y
p2_x = p1_x - length_1_2 * math.cos(alpha_1)
p2_y = p1_y - length_1_2 * math.sin(alpha_1)
tip_locus_3_x = p3_x
tip_locus_3_y = p3_y
p3_x = p2_x - length_2_3 * math.cos(alpha_2)
p3_y = p2_y - length_2_3 * math.sin(alpha_2)
tip_locus_4_x = p4_x
tip_locus_4_y = p4_y
p4_x = p3_x - length_3_4 * math.cos(alpha_3)
p4_y = p3_y - length_3_4 * math.sin(alpha_3)
chart_1.create_line(p1_x, p1_y, p0_x, p0_y, tag='line_1')
chart_1.create_line(p2_x, p2_y, p1_x, p1_y, tag='line_2')
chart_1.create_line(p3_x, p3_y, p2_x, p2_y, tag='line_3')
chart_1.create_line(p4_x, p4_y, p3_x, p3_y, fill="purple", \tag='line_4')
# Locus tip_locus_2 at tip of line 1-2
chart_1.create_line(tip_locus_2_x, tip_locus_2_y, p2_x, p2_y, \ fill='maroon')
# Locus tip_locus_2 at tip of line 2-3
chart_1.create_line(tip_locus_3_x, tip_locus_3_y, p3_x, p3_y, \ fill='orchid1')
# Locus tip_locus_2 at tip of line 2-3
chart_1.create_line(tip_locus_4_x, tip_locus_4_y, p4_x, p4_y, \ fill='DeepPink')
chart_1.update()
chart_1.after(cycle_period)
chart_1.delete('line_1', 'line_2', 'line_3')
root.mainloop()
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec32"/>How it works...</h2></div></div></div><p>As we did in the previous recipe we have lines defined by connecting two points, each being specified in the rectangular coordinates that Tkinter drawing methods use. There are three such lines connected pivot-to-tip. It may help to visualize each pivot as a drum major or a monkey. We convert each pivot-to-tip line into polar coordinates of length and angle. Then each pivot-to-tip line is rotated by its own individual increment angle. If you alter these angles alpha_1 etc. or the positions of the various pivot points you will get a limitless variety of interesting patterns.<a id="id109" class="indexterm"/>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec33"/>There's more...</h2></div></div></div><p>Once you are able to control and vary color you are able to make extraordinary and beautiful patterns never seen before. Color control is the subject of the next chapter.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="A rose for you"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec12"/>A rose for you</h1></div></div></div><p>This last example of the chapter is simply a gift for the reader. No illustration is provided. We will only see the result if we run the code. It is a surprise.<a id="id110" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">from Tkinter import *
root = Tk()
root.title("This is for you dear reader. A token of esteem and affection.")
import math
cw = 800 # canvas width
ch = 800 # canvas height
chart_1 = Canvas(root, width=cw, height=ch, background="black")
chart_1.grid(row=0, column=0)
p0_x = 400.0
p0_y = 400.0
p1_x = 330.0
p1_y = 330.0
p2_x = 250.0
p2_y = 250.0
p3_x = 260.0
p3_y = 260.0
p4_x = 250.0
p4_y = 250.0
p5_x = 180.0
p5_y = 180.0
alpha_0 = math.atan((p0_y - p1_y)/(p0_x - p1_x))
length_0_1 = math.sqrt((p0_y - p1_y)*(p0_y - p1_y) + (p0_x - p1_ \x)*(p0_x - p1_x))
alpha_1 = math.atan((p1_y - p2_y)/(p1_x - p2_x))
length_1_2 = math.sqrt((p2_y - p1_y)*(p2_y - p1_y) + (p2_x - p1_ \x)*(p2_x - p1_x))
alpha_2 = math.atan((p2_y - p3_y)/(p2_x - p3_x))
length_2_3 = math.sqrt((p3_y - p2_y)*(p3_y - p2_y) + (p3_x - p2_ \ x)*(p3_x - p2_x))
alpha_3 = math.atan((p3_y - p4_y)/(p3_x - p4_x))
length_3_4 = math.sqrt((p4_y - p3_y)*(p4_y - p3_y) + (p4_x - p3_ \ x)*(p4_x - p3_x))
alpha_4 = math.atan((p3_y - p5_y)/(p3_x - p5_x))
length_4_5 = math.sqrt((p5_y - p4_y)*(p5_y - p4_y) + (p5_x - p4_ \x)*(p5_x - p4_x))
for i in range(1,2300): # end the program after 500 position # shifts.
animationdigital flower examplealpha_0 += 0.003
alpha_1 += 0.018
alpha_2 -= 0.054
alpha_3 -= 0.108
alpha_4 += 0.018
p1_x = p0_x - length_0_1 * math.cos(alpha_0)
p1_y = p0_y - length_0_1 * math.sin(alpha_0)
tip_locus_2_x = p2_x
tip_locus_2_y = p2_y
p2_x = p1_x - length_1_2 * math.cos(alpha_1)
p2_y = p1_y - length_1_2 * math.sin(alpha_1)
tip_locus_3_x = p3_x
tip_locus_3_y = p3_y
p3_x = p2_x - length_2_3 * math.cos(alpha_2)
p3_y = p2_y - length_2_3 * math.sin(alpha_2)
tip_locus_4_x = p4_x
tip_locus_4_y = p4_y
p4_x = p3_x - length_3_4 * math.cos(alpha_3)
p4_y = p3_y - length_3_4 * math.sin(alpha_3)
tip_locus_5_x = p5_x
tip_locus_5_y = p5_y
p5_x = p4_x - length_4_5 * math.cos(alpha_4)
p5_y = p4_y - length_4_5 * math.sin(alpha_4)
chart_1.create_line(p1_x, p1_y, p0_x, p0_y, tag='line_1', \ fill='gray')
chart_1.create_line(p2_x, p2_y, p1_x, p1_y, tag='line_2', \ fill='gray')
chart_1.create_line(p3_x, p3_y, p2_x, p2_y, tag='line_3', \ fill='gray')
chart_1.create_line(p4_x, p4_y, p3_x, p3_y, tag='line_4', \ fill='gray')
animationdigital flower examplechart_1.create_line(p5_x, p5_y, p4_x, p4_y, tag='line_5', \ fill='#550000')
chart_1.create_line(tip_locus_2_x, tip_locus_2_y, p2_x, p2_y, \ fill='#ff00aa')
chart_1.create_line(tip_locus_3_x, tip_locus_3_y, p3_x, p3_y, \ fill='#aa00aa')
chart_1.create_line(tip_locus_4_x, tip_locus_4_y, p4_x, p4_y, \ fill='#dd00dd')
chart_1.create_line(tip_locus_5_x, tip_locus_5_y, p5_x, p5_y, \ fill='#880066')
chart_1.create_line(tip_locus_2_x, tip_locus_2_y, p5_x, p5_y, \ fill='#0000ff')
chart_1.create_line(tip_locus_3_x, tip_locus_3_y, p4_x, p4_y, \ fill='#6600ff')
chart_1.update() # This refreshes the drawing on the # canvas.
chart_1.delete('line_1', 'line_2', 'line_3', 'line_4') # Erase # selected tags.
root.mainloop()
</pre></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec34"/>How it works...</h2></div></div></div><p>The structure of this program is similar to the previous example but the rotation parameters have been adjusted to evoke the image of a rose. The colors used are chosen to remind us that control over color is extremely import in graphics.<a id="id113" class="indexterm"/>
</p></div></div></div>
</body></html>