<html><head></head><body>
  <div><h1 class="chapterNumber">4</h1>
    <h1 id="_idParaDest-76" class="chapterTitle">Linked Lists</h1>
    <p class="normal">Python’s list implementation is quite powerful and can encompass several different use cases. We have discussed the built-in data structures of <strong class="keyWord">lists</strong> in Python in <em class="chapterRef">Chapter 1</em>, <em class="italic">Python Data Types and Structures</em>. Most of the time, Python’s built-in implementation of a list data structure is used to store data using a linked list. In this chapter, we will understand how linked lists work along with their internals.</p>
    <p class="normal">A linked list is a data structure where the data elements are stored in a linear order. Linked lists provide efficient storage of data in linear order through pointer structures. Pointers are used to store the memory address of data items. They store the data and location, and the location stores the position of the next data item in the memory.</p>
    <p class="normal">The focus of this chapter will be the following:</p>
    <ul>
      <li class="bulletList">Arrays</li>
      <li class="bulletList">Introducing linked lists</li>
      <li class="bulletList">Singly linked lists</li>
      <li class="bulletList">Doubly linked lists</li>
      <li class="bulletList">Circular lists</li>
      <li class="bulletList">Practical applications of linked lists</li>
    </ul>
    <p class="normal">Before discussing linked lists, let us first discuss an array, which is one of the most elementary data structures.</p>
    <h1 id="_idParaDest-77" class="heading-1">Arrays</h1>
    <p class="normal">An array is a <a id="_idIndexMarker290"/>collection of data items of the same type, whereas a linked list is a collection of the same data type stored sequentially and connected through pointers. In the case of lists, the data elements are stored in different memory locations, whereas the array elements are stored in contiguous memory locations.</p>
    <p class="normal">An<a id="_idIndexMarker291"/> array stores the data of the same data type and each data element in the array is stored in contiguous memory locations. Storing multiple data values of the same type makes it <a id="_idIndexMarker292"/>easier and<a id="_idIndexMarker293"/> faster to compute the position of any element in the array using <strong class="keyWord">offset</strong> and <strong class="keyWord">base address</strong>. The term <em class="italic">base address</em> refers to the address of memory location where the first element is stored, and offset refers to an integer indicating the displacement between the first element and a given element.</p>
    <p class="normal"><em class="italic">Figure 4.1</em> demonstrates an array holding a sequence of seven integer values that are stored sequentially in contiguous memory locations. The first element (data value 3) is stored at index 0, the second element at index position 1, and so on.</p>
    <figure class="mediaobject"><img src="img/B17217_04_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.1: Representation of a one-dimensional array</p>
    <p class="normal">To store, traverse, and access array elements is very fast as compared to lists since elements can be<a id="_idIndexMarker294"/> accessed randomly using their index positions, whereas in the case of a linked list, the elements are accessed sequentially. Therefore, if the data to be stored in the array is large and the system has low memory, the array data structure will not be a good choice to store the data because it is difficult to allot a large block of memory locations. The array data structure has further limitations in that it has a static size that has to be declared at the time of creation.</p>
    <p class="normal">In addition, the insertion and deletion operations in array data structures are slow as compared to linked lists. This is because it is difficult to insert an element in an array at a given location since all data elements after that desired position must be shifted and then new elements inserted in between. Thus, array data structures are suitable when we want to do a lot of accessing of elements and fewer insertion and deletion operations, whereas linked lists are suitable in applications where the size of the list is not fixed, and a lot of insertion and deletion operations will be required.</p>
    <h1 id="_idParaDest-78" class="heading-1">Introducing linked lists</h1>
    <p class="normal">The linked list is <a id="_idIndexMarker295"/>an important and popular data structure with the following properties:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The data <a id="_idIndexMarker296"/>elements are stored in memory in different locations that are connected through pointers. A pointer is an object that can store the memory address of a variable, and each data element points to the next data element and so on until the last element, which points to <code class="inlineCode">None</code>.</li>
      <li class="numberedList">The length of the list can increase or decrease during the execution of the program.</li>
    </ol>
    <p class="normal">Contrary to arrays, linked lists store data items sequentially in different locations in memory, wherein each data item is stored separately and linked to other data items using pointers. Each of these data items is called a <a id="_idIndexMarker297"/>node. More specifically, a node stores the actual data and a pointer. In <em class="italic">Figure 4.2</em>, nodes A and B store the data independently, and node A is connected to node B.</p>
    <figure class="mediaobject"><img src="img/B17217_04_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.2: A linked list with two nodes</p>
    <p class="normal">Moreover, the nodes can have links to other nodes based differently on how we want to store the data, and on which basis we will learn various kinds of data structures, such as singular linked lists, doubly linked lists, circular link lists, and trees.</p>
    <h2 id="_idParaDest-79" class="heading-2">Nodes and pointers</h2>
    <p class="normal">A node is a <a id="_idIndexMarker298"/>key<a id="_idIndexMarker299"/> component of several<a id="_idIndexMarker300"/> data<a id="_idIndexMarker301"/> structures such as linked lists. A node is a container of data, together with one or more links to other nodes where a link is a pointer.</p>
    <p class="normal">To begin with, let us consider an example of creating a linked list of two nodes that contains data (for example, strings). For this, we first declare the variable that stores the data along with pointers that point to the next variable. Consider the example in the following <em class="italic">Figure 4.3</em>, in which there are two nodes. The first node has a pointer to the string (<strong class="keyWord">eggs</strong>), and another node pointing to the <strong class="keyWord">ham</strong> string. </p>
    <p class="normal">Furthermore, the first node that points to the <strong class="keyWord">eggs</strong> string has a link to another node. Pointers are used to store the address of a variable, and since the string is not actually stored in the node, rather, the address of the string is stored in the node.</p>
    <figure class="mediaobject"><img src="img/B17217_04_03.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 4.3: A sample linked list of two nodes</p>
    <p class="normal">Furthermore, we<a id="_idIndexMarker302"/> can<a id="_idIndexMarker303"/> also add a new third node to this existing<a id="_idIndexMarker304"/> linked list that<a id="_idIndexMarker305"/> stores spam as a data value, while a second node points to the third node, as shown in <em class="italic">Figure 4.4</em>. Hence, <em class="italic">Figure 4.3</em> demonstrates the structure of three nodes having data strings, in other words, <strong class="keyWord">eggs</strong>, <strong class="keyWord">ham</strong>, and <strong class="keyWord">spam</strong>, which are stored sequentially in a linked list.</p>
    <figure class="mediaobject"><img src="img/B17217_04_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.4: A sample linked list of three nodes</p>
    <p class="normal">So, we have created three nodes—one containing <strong class="keyWord">eggs</strong>, one <strong class="keyWord">ham</strong>, and another <strong class="keyWord">spam</strong>. The <strong class="keyWord">eggs</strong> node points to the <strong class="keyWord">ham</strong> node, which in turn points to the <strong class="keyWord">spam</strong> node. But what does the <strong class="keyWord">spam</strong> node point to? Since this is the last element in the list, we need to make sure its next member has a value that makes this clear. If we make the last element point to nothing, then we make this fact clear. In Python, we will use the special value <strong class="keyWord">None</strong> to denote nothing. Consider <em class="italic">Figure 4.5</em>. Node <strong class="keyWord">B</strong> is the last element in the list, and thus it is pointing to <strong class="keyWord">None</strong>.</p>
    <figure class="mediaobject"><img src="img/B17217_04_05.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 4.5: A linked list with two nodes</p>
    <p class="normal">Let us first <a id="_idIndexMarker306"/>learn<a id="_idIndexMarker307"/> about the implementation<a id="_idIndexMarker308"/> of <a id="_idIndexMarker309"/>the node, as shown in the following code snippet:</p>
    <pre class="programlisting code"><code class="hljs-code">class Node:
    def __init__ (self, data=None):
        self.data = data 
        self.next = None
</code></pre>
    <p class="normal">Here, the <strong class="keyWord">next</strong> pointer is initialized to <code class="inlineCode">None</code>, meaning that unless we change the value of <strong class="keyWord">next</strong>, the node is going to be an endpoint, meaning that initially, any node that is attached to the list will be independent.</p>
    <p class="normal">You can also add any other data items to the node class if required. If your node is going to contain customer data, then create a <code class="inlineCode">Customer</code> class and place all the data there.</p>
    <p class="normal">There are three kinds of list—a singly linked list, a doubly linked list, and a circular linked list. First of all, let’s discuss singly linked lists.</p>
    <p class="normal">We need to learn the following operations in order to use any linked lists in real-time applications.</p>
    <ul>
      <li class="bulletList">Traversing the list</li>
      <li class="bulletList">Inserting a data item in the list:<ul>
          <li class="bulletList">Inserting a new data item (node) at the beginning</li>
          <li class="bulletList">Inserting a new data item (node) at the end of the list</li>
          <li class="bulletList">Inserting a new data item (node) in the middle/or at any given position in the list</li>
        </ul>
      </li>
      <li class="bulletList">Deleting an item from the list:<ul>
          <li class="bulletList">Deleting the first node</li>
          <li class="bulletList">Deleting the last node</li>
          <li class="bulletList">Deleting a node in the middle/or at any given position in the list</li>
        </ul>
      </li>
    </ul>
    <p class="normal">We will be discussing<a id="_idIndexMarker310"/> these important operations on different types of linked lists in <a id="_idIndexMarker311"/>subsequent <a id="_idIndexMarker312"/>subsections, along with their implementations, using<a id="_idIndexMarker313"/> Python. Let us start with singly linked lists.</p>
    <h1 id="_idParaDest-80" class="heading-1">Singly linked lists</h1>
    <p class="normal">A linked list (also <a id="_idIndexMarker314"/>called a singly linked list) contains a number of nodes in which each node<a id="_idIndexMarker315"/> contains data and a pointer that links to the next node. The link of the last node in the list is <code class="inlineCode">None</code>, which indicates the end of the list. Refer to the following linked list in <em class="italic">Figure 4.6</em>, in which a sequence of integers is stored.</p>
    <figure class="mediaobject"><img src="img/B17217_04_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.6: An example of a singly linked list</p>
    <p class="normal">Next, we discuss how to create a singly linked list, and how to traverse it.</p>
    <h2 id="_idParaDest-81" class="heading-2">Creating and traversing</h2>
    <p class="normal">In order to <a id="_idIndexMarker316"/>implement<a id="_idIndexMarker317"/> the singly linked list, we can use the node class that we created in the previous section. For example, we create three nodes, <code class="inlineCode">n1</code>, <code class="inlineCode">n2</code>, and <code class="inlineCode">n3</code>, that store three strings:</p>
    <pre class="programlisting code"><code class="hljs-code">n1 = Node('eggs')
n2 = Node('ham') 
n3 = Node('spam')
</code></pre>
    <p class="normal">Next, we link the nodes sequentially to form the linked list. For example, in the following code, node <code class="inlineCode">n1</code> is pointing to node <code class="inlineCode">n2</code>, node <code class="inlineCode">n2</code> is pointing to node <code class="inlineCode">n3</code>, and node <code class="inlineCode">n3</code> is the last node, and is pointing to <strong class="keyWord">None</strong>:</p>
    <pre class="programlisting code"><code class="hljs-code">n1.next = n2
n2.next = n3
</code></pre>
    <p class="normal">Traversal of the linked lists means visiting all the nodes of the list, from the starting node to the last node. The process of traversing the singly linked list begins with the first node, displaying the data of the current node, following the pointers, and finally stopping when we reach the last node.</p>
    <p class="normal">To implement the traversal of the linked list, we start by setting the <code class="inlineCode">current</code> variable to the first item (starting node) in the list, and then we traverse the complete list through a loop, traversing<a id="_idIndexMarker318"/> each <a id="_idIndexMarker319"/>node as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">current = n1 
while current:
     print(current.data)
     current = current.next
</code></pre>
    <p class="normal">In the loop, we print out the current element after which we set <code class="inlineCode">current</code> to point to the next element in the list. We keep doing this until we reach the end of the list. The output of the preceding code for this example is:</p>
    <pre class="programlisting con"><code class="hljs-con">eggs
ham
spam
</code></pre>
    <p class="normal">There are, however, several problems with this simplistic list implementation:</p>
    <ul>
      <li class="bulletList">It requires too much manual work by the programmer</li>
      <li class="bulletList">Too much of the inner workings of the list is exposed to the programmer</li>
    </ul>
    <p class="normal">So, let us discuss a better and more efficient way of traversing the linked list.</p>
    <h3 id="_idParaDest-82" class="heading-3">Improving list creation and traversal</h3>
    <p class="normal">As you <a id="_idIndexMarker320"/>will <a id="_idIndexMarker321"/>notice in the earlier example of the list traversal, we are exposing the node class to the client/user. However, the client node should not interact with the node object. We need to use <code class="inlineCode">node.data</code> to get the contents of the node, and <code class="inlineCode">node.next</code> to get the next node. We can access the data by creating a method that returns a generator, which can be done using the <code class="inlineCode">yield</code> keyword in Python. The updated code snippet for list traversal is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">def iter(self):
    current = self.head 
    while current:
        val = current.data 
        current = current.next 
        yield val
</code></pre>
    <p class="normal">Here, the <code class="inlineCode">yield</code> keyword is used to return from a function while saving the states of its local variables to enable the function to resume from where it left off. Whenever the function is called again, the execution starts from the last yield statement. Any function that contains a yield<a id="_idIndexMarker322"/> keyword is termed a <strong class="keyWord">generator</strong>.</p>
    <p class="normal">Now, list traversal is much simpler. We can completely ignore the fact that there is anything called a node outside of the list:</p>
    <pre class="programlisting code"><code class="hljs-code">for word in words.iter():
    print(word)
</code></pre>
    <p class="normal">Notice that since the <code class="inlineCode">iter()</code> method yields the data member of the node, our client code doesn’t need to worry about that at all.</p>
    <p class="normal">A singly linked list can be created using a simple class to hold the list. We start with a constructor that holds a reference to the very first node in the list (that is <code class="inlineCode">head</code> in the following code). Since this list is initially empty, we will start by setting this reference to <code class="inlineCode">None</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">class SinglyLinkedList:
    def __init__ (self):
        self.head = None
</code></pre>
    <p class="normal">In the preceding code, we start with an empty list that points to <code class="inlineCode">None</code>. Now, new data elements can be appended/added to this list.</p>
    <h2 id="_idParaDest-83" class="heading-2">Appending items</h2>
    <p class="normal">The first operation <a id="_idIndexMarker323"/>that we need to perform is to <code class="inlineCode">append</code> items to the list. This operation is also called an <code class="inlineCode">insertion</code> operation. Here we get a chance to hide the <code class="inlineCode">Node</code> class away. The user of the list class should never have to interact with <code class="inlineCode">Node</code> objects.</p>
    <h3 id="_idParaDest-84" class="heading-3">Appending items to the end of a list</h3>
    <p class="normal">Let’s have a look at the Python code for creating a linked<a id="_idIndexMarker324"/> list where we append new elements to the list using the <code class="inlineCode">append()</code> method, as shown here: </p>
    <p class="normal">The first shot at an <code class="inlineCode">append()</code> method may look like this:</p>
    <pre class="programlisting code"><code class="hljs-code">class SinglyLinkedList:
    def __init__ (self):  
        self.head = None  
        self.size = 0
def append(self, data):
    # Encapsulate the data in a Node 
    node = Node(data)
    if self.head is None:
        self.head = node
    else:
        current = self.head
        while current.next:
            current = current.next
        current.next = node
</code></pre>
    <p class="normal">Here, in this code, we encapsulate data in a node so that it has the next pointer attribute. From here, we check if there are any existing nodes in the list (that is, whether <code class="inlineCode">self.head</code> points to a <code class="inlineCode">Node</code>). If there is <code class="inlineCode">None</code>, this means that initially, the list is empty and the new node will be the first node. So, we make the new node the first node of the list; otherwise, we find the insertion point by traversing the list to the last node and updating the next pointer of the last node to the new node. This working is depicted in <em class="italic">Figure 4.7</em>.</p>
    <figure class="mediaobject"><img src="img/B17217_04_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.7: Inserting a node at the end of the list in a singly linked list</p>
    <p class="normal">Consider the following example code to append three nodes:</p>
    <pre class="programlisting code"><code class="hljs-code">words = SinglyLinkedList()
words.append('egg')
words.append('ham')
words.append('spam')
</code></pre>
    <p class="normal">List traversal will work as we discussed before. You will get the first element of the list from the list <a id="_idIndexMarker325"/>itself, and then traverse the list through the <code class="inlineCode">next</code> pointer:</p>
    <pre class="programlisting code"><code class="hljs-code">current = words.head
while current:
   print(current.data)
   current = current.next
</code></pre>
    <p class="normal">Still, this implementation is not very efficient, and there is a drawback with the append method. In this, we have to traverse the entire list to find the insertion point. This may not be a problem when there are just a few items in the list, but it will be very inefficient when the list is long, as it will have to traverse the whole list to add an item every time. Let us discuss a better implementation of the <code class="inlineCode">append</code> method.</p>
    <p class="normal">For this, the idea is that we not only have a reference to the first node in the list but also have one more variable in the node that references the last node of the list. That way, we can quickly append a new node at the end of the list. The worst-case running time of the append operation can be reduced from <code class="inlineCode">O(n)</code> to <code class="inlineCode">O(1)</code> using this method. We must ensure that the previous last node points to the new node that is to be appended to the list.</p>
    <p class="normal">Here is our updated code:</p>
    <pre class="programlisting code"><code class="hljs-code">class SinglyLinkedList:
    def __init__ (self):
        self.tail = None
        self.head = None
        self.size = 0
    def append(self, data):
        node = Node(data)
        if self.tail:
            self.tail.next = node
            self.tail = node
        else:
            self.head = node 
            self.tail = node
</code></pre>
    <div><p class="normal">Take note of the convention being used. The point at which we append new nodes is through <code class="inlineCode">self.tail</code>. The <code class="inlineCode">self.head</code> variable points to the first node in the list.</p>
    </div>
    <p class="normal">In this code, a<a id="_idIndexMarker326"/> new node can be appended in the end through a <code class="inlineCode">tail</code> pointer by making a link from the last node to the new node. <em class="italic">Figure 4.8</em> shows the workings of the preceding code.</p>
    <figure class="mediaobject"><img src="img/B17217_04_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.8: Illustrating the insertion of a node at the end of a linked list</p>
    <p class="normal">In <em class="italic">Figure 4.8</em>, <em class="italic">step 1</em> shows the addition of the new node at the end, and <em class="italic">step 2</em> shows when the list is empty. In that case, <code class="inlineCode">head</code> is made the new node, with <code class="inlineCode">tail</code> pointing to that node.</p>
    <p class="normal">Furthermore, the following code snippet shows the workings of the code:</p>
    <pre class="programlisting code"><code class="hljs-code">words = SinglyLinkedList()
words.append('egg')
words.append('ham')
words.append('spam')
 
current = words.head
while current:
    print(current.data)
    current = current.next
</code></pre>
    <p class="normal">The output <a id="_idIndexMarker327"/>of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">eggs
ham
spam
</code></pre>
    <h3 id="_idParaDest-85" class="heading-3">Appending items at intermediate positions</h3>
    <p class="normal">To append or <a id="_idIndexMarker328"/>insert an element in an existing linked list at a given position, firstly, we have to traverse the list to reach the desired position where we want to insert an element. An element can be inserted in between two successive nodes using two pointers (<code class="inlineCode">prev</code> and <code class="inlineCode">current</code>).</p>
    <p class="normal">A new node can easily be inserted in between two existing nodes by updating these links, as shown in <em class="italic">Figure 4.9</em>.</p>
    <figure class="mediaobject"><img src="img/B17217_04_09.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.9: Insertion of a node between two successive nodes in a linked list</p>
    <p class="normal">When we want to insert a node in between two existing nodes, all we have to do is update two links. The previous node points to the new node, and the new node should point to the successor of the previous node.</p>
    <p class="normal">Let’s look at the <a id="_idIndexMarker329"/>complete code below to add a new element at a given index position:</p>
    <pre class="programlisting code"><code class="hljs-code">class SinglyLinkedList:
    def __init__ (self):
        self.tail = None
        self.head = None
        self.size = 0
    def append_at_a_location(self, data, index): 
        current = self.head 
        prev = self.head 
        node = Node(data)
        count = 1
        while current:
            if count == 1:        
                node.next = current
                self.head = node
                print(count)
                return
            elif index == index:
                node.next = current 
                prev.next = node
                return
            count += 1
            prev = current
            current = current.next
        if count &lt; index:
            print("The list has less number of elements")
</code></pre>
    <p class="normal">In the preceding <a id="_idIndexMarker330"/>code, we start from the first node and move the current pointer to reach the index position where we want to add a new element, and then we update the node pointers accordingly. In the <code class="inlineCode">if</code> condition, firstly, we check whether the index position is <code class="inlineCode">1</code>. In that case, we have to update the nodes as we are adding the new node at the start of the list. Therefore, we have to make the new node a <code class="inlineCode">head</code> node. Next, in the <code class="inlineCode">else</code> part, we check whether we have reached the required index position by comparing the value of <code class="inlineCode">count</code> and <code class="inlineCode">index</code>. If both values are equal, we add a new node in between nodes indicated by <code class="inlineCode">prev</code> and <code class="inlineCode">current</code> and update the pointers accordingly. Finally, we print an appropriate message if the required index position is greater than the length of the linked list.</p>
    <pre>2</code> in the existing linked list:</pre>
    <pre class="programlisting code"><code class="hljs-code">words = SinglyLinkedList()
words.append('egg')
words.append('ham')
words.append('spam')
current = words.head
while current:
    print(current.data)
    current = current.next
words.append_at_a_location('new', 2)
current = words.head
while current:
    print(current.data)
    current = current.next
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">egg
new
ham
spam
</code></pre>
    <p class="normal">It is important to note that the condition where we may want to insert a new element can change depending upon the requirement, so let’s say we want to insert a new element just before an element that has the same data value. In that case, the code to <code class="inlineCode">append_at_a_position</code> will be as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">def append_at_a_location(self, data): 
    current = self.head 
    prev = self.head
    node = Node(data)
    while current:
        if current.data == data:
            node.next = current 
            prev.next = node
        prev = current
        current = current.next
</code></pre>
    <p class="normal">We can now use the preceding code to insert a new node at an intermediate position:</p>
    <pre class="programlisting code"><code class="hljs-code">words.append_at_a_location('ham')
current = words.head
while current:
    print(current.data)
    current = current.next
</code></pre>
    <p class="normal">The output of <a id="_idIndexMarker331"/>the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">egg
ham
ham
spam
</code></pre>
    <p class="normal">The worst-case time complexity of the <code class="inlineCode">insert</code> operation is <code class="inlineCode">O(1)</code> when we have an additional pointer that points to the last node. Otherwise, when we do not have the link to the last node, the time complexity will be <code class="inlineCode">O(n)</code> since we have to traverse the list to reach the desired position and in the worst case, we may have to traverse all the <em class="italic">n</em> nodes in the list.</p>
    <h2 id="_idParaDest-86" class="heading-2">Querying a list</h2>
    <p class="normal">Once the list is<a id="_idIndexMarker332"/> created, we may require some quick information about the linked list, such as the size of the list, and occasionally to establish whether a given data item is present in the list.</p>
    <h3 id="_idParaDest-87" class="heading-3">Searching an element in a list</h3>
    <p class="normal">We may also <a id="_idIndexMarker333"/>need to check whether a list contains a given item. This can be implemented using the <code class="inlineCode">iter()</code> method, which we have already seen in the previous section while traversing the linked list. Using that, we write the search method as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">def search(self, data):
    for node in self.iter():
        if data == node:
            return True
    return False
</code></pre>
    <p class="normal">In the above code, each pass of the loop compares the data to be searched with each data item in the list one by one. If a match is found, <code class="inlineCode">True</code> is returned, otherwise <code class="inlineCode">False</code> is returned.</p>
    <p class="normal">If we run the following code for searching a given data item:</p>
    <pre class="programlisting code"><code class="hljs-code">print(words.search('sspam'))
print(words.search('spam'))
</code></pre>
    <p class="normal">The output<a id="_idIndexMarker334"/> of the preceding code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">False
True
</code></pre>
    <h3 id="_idParaDest-88" class="heading-3">Getting the size of the list</h3>
    <p class="normal">It is important<a id="_idIndexMarker335"/> to get the size of the list by counting the number of nodes. One way to do it is by traversing the entire list and increasing the counter as we go along:</p>
    <pre class="programlisting code"><code class="hljs-code">def size(self):
    count = 0
    current = self.head
    while current:
        count += 1
        current = current.next
    return count
</code></pre>
    <p class="normal">The above code is very similar to what we did while traversing the linked list. Similarly, in this code, we traverse the nodes of the list one by one and increase the <code class="inlineCode">count</code> variable. However, list traversal is potentially an expensive operation that we should avoid wherever we can. </p>
    <p class="normal">So instead, we can opt for another method in which we can add a size member to the <code class="inlineCode">SinglyLinkedList</code> class, initializing it to <code class="inlineCode">0</code> in the constructor, as shown in the following code snippet:</p>
    <pre class="programlisting code"><code class="hljs-code">class SinglyLinkedList:
    def __init__(self):
        self.head = data
        self.size = 0
</code></pre>
    <p class="normal">Because we are now only reading the size attribute of the node object, and not using a loop to count the <a id="_idIndexMarker336"/>number of nodes in the list, we reduce the worst-case running time from <code class="inlineCode">O(n)</code> to <code class="inlineCode">O(1)</code>.</p>
    <h2 id="_idParaDest-89" class="heading-2">Deleting items</h2>
    <p class="normal">Another common <a id="_idIndexMarker337"/>operation on a linked list is to delete nodes. There are three possibilities that we may encounter in order to delete a node from the singly linked list.</p>
    <h3 id="_idParaDest-90" class="heading-3">Deleting the node at the beginning of the singly linked list</h3>
    <p class="normal">Deleting a node <a id="_idIndexMarker338"/>from the beginning is quite easy. It involves updating the <code class="inlineCode">head</code> pointer to the second node in the list. This can be done in two steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">A temporary pointer (<code class="inlineCode">current</code> pointer) is created that points to the first node (<code class="inlineCode">head</code> node), as shown in <em class="italic">Figure 4.10</em>.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B17217_04_10.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.10: Illustration of the deletion of the first node from the linked list</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Next, the <code class="inlineCode">current</code> node pointer is moved to the next node and assigned to the <code class="inlineCode">head</code> node. Now, the second node becomes the <code class="inlineCode">head</code> node that is pointed to by the <code class="inlineCode">head</code> pointer, as shown in <em class="italic">Figure 4.11</em>.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B17217_04_11.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.11: After deleting the first node, the head pointer now points to the new starting element</p>
    <p class="normal">This can be implemented using the following Python code. In this code, initially, three data elements are added as we have done previously, and then the first node of the list is deleted:</p>
    <pre class="programlisting code"><code class="hljs-code">def delete_first_node (self):
       current = self.head  
        if self.head is None:
              print("No data element to delete")
        elif current == self.head:
              self.head = current.next  
</code></pre>
    <p class="normal">In the above code, we initially check if there is no item to delete from the list, and we print the appropriate message. Next, if there is some data item in the list, we assign the <code class="inlineCode">head</code> pointer to the temporary pointer current as per <em class="italic">step 1</em>, and then the <code class="inlineCode">head</code> pointer is now pointing to the next node, assuming that we already have a linked list of three data items – “eggs”, “ham”, and “spam”:</p>
    <pre class="programlisting code"><code class="hljs-code">words.delete_first_node()
current = words.head
while current:
    print(current.data)
    current = current.next
</code></pre>
    <p class="normal">The output <a id="_idIndexMarker339"/>of the preceding code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">ham
spam
</code></pre>
    <h3 id="_idParaDest-91" class="heading-3">Deleting the node at the end in the singly linked list</h3>
    <p class="normal">To delete the last<a id="_idIndexMarker340"/> node from the list, we have to first traverse the list to reach the last node. At that time, we also need an extra pointer that points to just one node before the last node, so that after deleting the last node, the second last node can be marked as the last node. It can be implemented in the following three steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Firstly, we have two pointers, in other words, a <code class="inlineCode">current</code> pointer that will point to the last node, and a <code class="inlineCode">prev</code> pointer that will point to the node previous to the last node (second last node). Initially, we will have three pointers (<code class="inlineCode">current</code>, <code class="inlineCode">prev</code>, and <code class="inlineCode">head</code>) pointing to the first node, as shown in <em class="italic">Figure 4.12</em>.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B17217_04_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.12: Illustration of the deletion of the end node from the linked list</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">To reach the last node, we move the <code class="inlineCode">current</code> and <code class="inlineCode">prev</code> pointers in such a way that the <code class="inlineCode">current</code> pointer should point to the last node and the <code class="inlineCode">prev</code> pointer <a id="_idIndexMarker341"/>should point to the second last node. So, we stop when the <code class="inlineCode">current</code> pointer reaches the last node. This is shown in <em class="italic">Figure 4.13</em>.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B17217_04_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.13: Traversal of the linked list to reach the end of the list</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Finally, we mark the <code class="inlineCode">prev</code> pointer to point to the second last node, which is rendered as the last node of the list by pointing this node to <code class="inlineCode">None</code>, as shown in <em class="italic">Figure 4.14</em>.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B17217_04_14.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.14: Deletion of the last node from the linked list</p>
    <p class="normal">The implementation in Python for deleting a node from the end of the list is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">    def delete_last_node (self):  
        current = self.head  
        prev = self.head  
        while current: 
            if current.next is None: 
                prev.next = current.next  
                self.size -= 1 
            prev = current 
            current = current.next
</code></pre>
    <p class="normal">In the preceding code, firstly, the <code class="inlineCode">current</code> and <code class="inlineCode">prev</code> pointers are assigned the <code class="inlineCode">head</code> pointer as per <em class="italic">step 1</em>. Then, in the <code class="inlineCode">while</code> loop, we check whether we reached the end of the list using the <code class="inlineCode">current.next is None</code> condition. Once we reach the end of the list, we make the second last node, which is indicated by the <code class="inlineCode">prev</code> pointer, the last node. We also decrement <a id="_idIndexMarker342"/>the size of the list. If we do not reach the end of the list, we increment the <code class="inlineCode">prev</code> and <code class="inlineCode">current</code> pointers in the <code class="inlineCode">while</code> loop in the last two lines of code. Next, let us discuss how to delete any intermediate node in a singly linked list.</p>
    <h3 id="_idParaDest-92" class="heading-3">Deleting any intermediate node in a singly linked list</h3>
    <p class="normal">We first have to <a id="_idIndexMarker343"/>decide how to select a node for deletion. Identifying the intermediate node to be deleted can be determined by the index number or by the data the node contains. Let us understand this concept by deleting a node depending on the data it contains.</p>
    <p class="normal">To delete any intermediary node, we need two pointers similar to the case when we learned to delete the last node; in other words, the <code class="inlineCode">current</code> pointer and the <code class="inlineCode">prev</code> pointer. Once we reach the node that is to be deleted, the desired node can be deleted by making the previous node point to the next node of the node that is to be deleted. The process is provided in the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1"><em class="italic">Figure 4.15</em> shows when an intermediate node is deleted from the given linked list. In this, we can see that the initial pointers point to the first node.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B17217_04_15.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.15: Illustration of the deletion of an intermediate node from the linked list</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Once the<a id="_idIndexMarker344"/> node is identified, the <code class="inlineCode">prev</code> pointer is updated to delete the node, as shown in <em class="italic">Figure 4.16</em>. The node to be deleted is shown along with the link to those to be updated in <em class="italic">Figure 4.16</em>.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B17217_04_16.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.16: Traversing to reach the intermediate node that is to be deleted in the linked list</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Finally, the list after deleting the node is shown in <em class="italic">Figure 4.17</em>.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B17217_04_17.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.17: Deletion of an intermediate node from the linked list</p>
    <p class="normal">Let’s say we want to delete a data element that has the given value. For this given condition, we can first search the node to be deleted and then delete the node as per the steps discussed.</p>
    <p class="normal">Here is what the<a id="_idIndexMarker345"/> implementation of the <code class="inlineCode">delete()</code> method may look like:</p>
    <pre class="programlisting code"><code class="hljs-code">def delete(self, data):
    current = self.head 
    prev = self.head 
    while current:
          if current.data == data:
              if current == self.head:
                  self.head = current.next 
              else:
                  prev.next = current.next 
              self.size -= 1
              return
          prev = current
          current = current.next
</code></pre>
    <p class="normal">Assuming that we already have a linked list of three items – “eggs”, “ham”, and “spam”, the following code is for executing the delete operation, that is, deleting a data element with the value “ham” from the given linked list:</p>
    <pre class="programlisting code"><code class="hljs-code">words.delete("ham")
current = words.head
while current:
    print(current.data)
    current = current.next
</code></pre>
    <p class="normal">The output of the preceding code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">egg
spam
</code></pre>
    <p class="normal">The worst-case time complexity of the <code class="inlineCode">delete</code> operation is <code class="inlineCode">O(n)</code> since we have to traverse the list to reach the desired position and, in the worst-case scenario, we may have to<a id="_idIndexMarker346"/> traverse all the <em class="italic">n</em> nodes in the list.</p>
    <h3 id="_idParaDest-93" class="heading-3">Clearing a list</h3>
    <p class="normal">We may need <a id="_idIndexMarker347"/>to clear a list quickly, and there is a very simple way to do this. We can clear a list by simply clearing the pointer head and tail by setting them to <code class="inlineCode">None</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">def clear(self):
    # clear the entire list.
    self.tail = None
    self.head = None
</code></pre>
    <p class="normal">In the above code, we can clear the list by assigning <code class="inlineCode">None</code> to the <code class="inlineCode">tail</code> and <code class="inlineCode">head</code> pointers.</p>
    <p class="normal">We have discussed different operations for a singly linked list, and now we will discuss the concept of doubly linked list and learn how different operations can be implemented in a doubly linked list in the next section.</p>
    <h1 id="_idParaDest-94" class="heading-1">Doubly linked lists</h1>
    <p class="normal">A doubly linked list is <a id="_idIndexMarker348"/>quite similar to the singly linked list in the sense that we use<a id="_idIndexMarker349"/> the same fundamental concept of nodes along with how we can store data and links together, as we did in a singly linked list. The only difference between a singly linked list and a doubly linked list is that in a singly linked list, there is only one link between each successive node, whereas, in a doubly linked list, we have two pointers—a pointer to the next node and a pointer to the previous node. See the following <em class="italic">Figure 4.18</em> of a node; there is a pointer to the next node and the previous node, which are set to <code class="inlineCode">None</code> as there is no node attached to this node.</p>
    <figure class="mediaobject"><img src="img/B17217_04_18.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.18: Represents a doubly linked list with a single node</p>
    <p class="normal">A node in a singly linked list can only determine the next node associated with it. However, there is no link to go back from this referenced node. The direction of flow is only one way. In a doubly linked list, we solve this issue and include the ability not only to <a id="_idIndexMarker350"/>reference the <a id="_idIndexMarker351"/>next node, but also to reference the previous node. Consider the following <em class="italic">Figure 4.19</em> to understand the nature of the linkages between two successive nodes. Here, node <strong class="keyWord">A</strong> is referencing node <strong class="keyWord">B</strong>; in addition, there is also a link back to node <strong class="keyWord">A</strong>.</p>
    <figure class="mediaobject"><img src="img/B17217_04_19.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.19: Doubly linked list with two nodes</p>
    <p class="normal">Doubly linked lists can be traversed in any direction. A node in a doubly linked list can be easily referred to by its previous node whenever required without having a variable to keep track of that node. </p>
    <p class="normal">However, in a singly linked list, it may be difficult to move back to the start or beginning of the list to make some changes at the start of the list, which is very easy now in the case of a doubly linked list.</p>
    <h2 id="_idParaDest-95" class="heading-2">Creating and traversing</h2>
    <p class="normal">The Python<a id="_idIndexMarker352"/> code to <a id="_idIndexMarker353"/>create a doubly linked list node includes its initializing methods, the <code class="inlineCode">prev</code> pointer, the <code class="inlineCode">next</code> pointer, and the <code class="inlineCode">data</code> instance variables. When a node is newly created, all these variables default to <code class="inlineCode">None</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">class Node:
    def __init__ (self, data=None, next=None, prev=None):
       self.data = data 
       self.next = next 
       self.prev = prev
</code></pre>
    <p class="normal">The <code class="inlineCode">prev</code> variable has a reference to the previous node, while the <code class="inlineCode">next</code> variable keeps the reference to the next node, and the <code class="inlineCode">data</code> variable stores the data.</p>
    <p class="normal">Next, let’s create a doubly linked list class.</p>
    <p class="normal">The doubly linked list class has two pointers, <code class="inlineCode">head</code> and <code class="inlineCode">tail</code>, that will point to the start and end of the doubly linked list, respectively. In addition, for the size of the list, we set the count instance variable to <code class="inlineCode">0</code>. It can be used to keep track of the number of items in the linked list. Consider the following Python code for creating a doubly linked list class:</p>
    <pre class="programlisting code"><code class="hljs-code">class DoublyLinkedList:
    def __init__ (self): 
        self.head = None
        self.tail = None
        self.count = 0
</code></pre>
    <div><p class="normal">Here, <code class="inlineCode">self.head</code> points to the beginner node of the list, and <code class="inlineCode">self.tail</code> points to the last node. However, there are no fixed rules as to the naming of the head and tail node pointers.</p>
    </div>
    <p class="normal">Doubly linked lists also require functionalities that return the size of the list, insert items into the list, and delete nodes from the list. Next, we discuss different operations that can be applied to the doubly linked list. Let’s start with the append operation.</p>
    <h2 id="_idParaDest-96" class="heading-2">Appending items</h2>
    <p class="normal">The <code class="inlineCode">append</code> operation <a id="_idIndexMarker354"/>is used to add an element at the end of a list. An element can be appended or inserted into a doubly linked list in the following instances.</p>
    <h3 id="_idParaDest-97" class="heading-3">Inserting a node at beginning of the list</h3>
    <p class="normal">Firstly, it is<a id="_idIndexMarker355"/> important to check whether the <code class="inlineCode">head</code> node of the list is <code class="inlineCode">None</code>. If it is <code class="inlineCode">None</code>, this means that the list is empty, otherwise the list has some nodes, and a new node can be appended to the list. If a new node is to be added to the empty list, it should have the <code class="inlineCode">head</code> pointer pointing to the newly created node, and the tail of the list should also point to this newly created node. </p>
    <p class="normal">The following <em class="italic">Figure 4.20</em> illustrates the <code class="inlineCode">head</code> and <code class="inlineCode">tail</code> pointers of the doubly linked list when a new node is added to an empty list.</p>
    <figure class="mediaobject"><img src="img/B17217_04_20.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.20: Illustration of inserting a node in an empty doubly linked list</p>
    <p class="normal">Alternatively, we can insert or append a new node at the beginning of an existing doubly linked list, as shown in <em class="italic">Figure 4.21</em>.</p>
    <figure class="mediaobject"><img src="img/B17217_04_21.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.21: Illustration of inserting an element in a doubly linked list</p>
    <p class="normal">The new node should be made as a new starting node of the list and that should now point to the previous <code class="inlineCode">head</code> node.</p>
    <p class="normal">It can be done by updating the three links, which are also shown with dotted lines in <em class="italic">Figure 4.22</em> and described as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Firstly, the <code class="inlineCode">next</code> pointer of a new node should point to the <code class="inlineCode">head</code> node of the existing list</li>
      <li class="numberedList">The <code class="inlineCode">prev</code> pointer of the <code class="inlineCode">head</code> node of the existing list should point to the new node</li>
      <li class="numberedList">Finally, mark<a id="_idIndexMarker356"/> the new node as the <code class="inlineCode">head</code> node in the list</li>
    </ol>
    <figure class="mediaobject"><img src="img/B17217_04_22.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.22: Inserting a node at the beginning of the doubly linked list</p>
    <p class="normal">The following code is used to append/insert an item at the beginning when the list is initially empty and with an existing doubly linked list:</p>
    <pre class="programlisting code"><code class="hljs-code">def append_at_start(self, data):
  #Append an item at beginning to the list.
  new_node = Node(data, None, None)
  if self.head is None:
      self.head = new_node
      self.tail = self.head
    else:
      new_node.next = self.head
      self.head.prev = new_node
      self.head = new_node
  self.count += 1
</code></pre>
    <p class="normal">In the above code, firstly, the <code class="inlineCode">self.head</code> condition is checked irrespective of whether the list is empty. If it is empty, then the head and tail pointers point to the newly created node. In this case, the new node becomes the <code class="inlineCode">head</code> node. Next, if the condition is not true, this means the list is not empty, and a new node has to be added at the beginning of the list. For this, three links are updated as shown in <em class="italic">Figure 4.22</em>, and also shown in the code in bold font. After updating these three links, finally, the size of the list is<a id="_idIndexMarker357"/> increased by <code class="inlineCode">1</code>. Furthermore, let us understand how to insert an element at the end of the doubly linked list.</p>
    <p class="normal">Further, the following code snippet shows how we can create a double link list and append a new node at the starting of the list: </p>
    <pre class="programlisting code"><code class="hljs-code">words = DoublyLinkedList()
words.append('egg')
words.append('ham')
words.append('spam')
print("Items in doubly linked list before append:")
current = words.head
while current:
    print(current.data)
    current = current.next
words.append_at_start('book')
print("Items in doubly linked list after append:")
current = words.head
while current:
    print(current.data)
    current = current.next
</code></pre>
    <p class="normal">The output of the above code is:</p>
    <pre class="programlisting con"><code class="hljs-con">Items in doubly linked list before append:
egg
ham
spam
Items in doubly linked list after append:
book
egg
ham
spam
</code></pre>
    <p class="normal">In the output, we can see that the new data item “<code class="inlineCode">book</code>" is added in the starting of the list.</p>
    <h3 id="_idParaDest-98" class="heading-3">Inserting a node at the end of the list</h3>
    <p class="normal">To append/insert<a id="_idIndexMarker358"/> a new element at the end of the doubly linked list, we will need to traverse through the list to reach the end of the list if we do not have a separate pointer pointing to the end of the list. Here, we have a <code class="inlineCode">tail</code> pointer that points to the end of the list.</p>
    <p class="normal">A visual representation of the append operation to an existing list is shown in the following <em class="italic">Figure 4.23</em>.</p>
    <figure class="mediaobject"><img src="img/B17217_04_23.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.23: Inserting a node at the end of the list in a doubly linked list</p>
    <p class="normal">To add a new node at the end, we update two links as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Make the <code class="inlineCode">prev</code> pointer of the new node point to the previous <code class="inlineCode">tail</code> node</li>
      <li class="numberedList">Make the previous <code class="inlineCode">tail</code> node point to the new node</li>
      <li class="numberedList">Finally, update the <code class="inlineCode">tail</code> pointer so that the <code class="inlineCode">tail</code> pointer now points to the new node</li>
    </ol>
    <p class="normal">The following code is used to append an item at the end of the doubly linked list:</p>
    <pre class="programlisting code"><code class="hljs-code">def append(self, data):
    #Append an item at the end of the list.
    new_node = Node(data, None, None)
    if self.head is None:
        self.head = new_node
        self.tail = self.head
    else:
        new_node.prev = self.tail
        self.tail.next = new_node
        self.tail = new_node
    self.count += 1
</code></pre>
    <p class="normal">In the above code, the <code class="inlineCode">if</code> part of the preceding program is for adding a node to the empty list; the <code class="inlineCode">else</code> part of the preceding program will be executed if the list is not empty. If the <a id="_idIndexMarker359"/>new node is to be added to a list, the new node’s previous variable is to be set to the tail of the list:</p>
    <pre class="programlisting code"><code class="hljs-code">new_node.prev = self.tail
</code></pre>
    <p class="normal">The tail’s next pointer (or variable) has to be set to the new node:</p>
    <pre class="programlisting code"><code class="hljs-code">self.tail.next = new_node
</code></pre>
    <p class="normal">Lastly, we update the tail pointer to point to the new node:</p>
    <pre class="programlisting code"><code class="hljs-code">self.tail = new_node
</code></pre>
    <p class="normal">Since an append operation increases the number of nodes by one, we increase the counter by one:</p>
    <pre class="programlisting code"><code class="hljs-code">self.count += 1
</code></pre>
    <p class="normal">The following code snippet can be used to append a node at the end of the list:</p>
    <pre class="programlisting code"><code class="hljs-code">print("Items in doubly linked list after append")
words = DoublyLinkedList()
words.append('egg')
words.append('ham')
words.append('spam')
words.append('book')
print("Items in doubly linked list after adding element at end.")
current = words.head
while current:
    print(current.data)
    current = current.next
</code></pre>
    <p class="normal">The output of the above code:</p>
    <pre class="programlisting con"><code class="hljs-con">Items in doubly linked list after adding element at end.
egg
ham
spam
book
</code></pre>
    <p class="normal">The worst-case time complexity of appending an element to the doubly linked list is <code class="inlineCode">O(1)</code> since we already have the tail pointer that points to the end of the list, and we can directly add a new element. Next, we will discuss how to insert a node at an intermediate position of the doubly linked list.</p>
    <h3 id="_idParaDest-99" class="heading-3">Inserting a node at an intermediate position in the list</h3>
    <p class="normal">Inserting a new <a id="_idIndexMarker360"/>node at any given position in a doubly linked list is similar to what we discussed in a singly linked list. Let us take an example in which we insert a new element just before the element that has the same data value as the given data.</p>
    <p class="normal">Firstly, we traverse to the position where we want to insert a new element in that situation. The <code class="inlineCode">current</code> pointer points to the target node, while the <code class="inlineCode">prev</code> pointer just points to the previous node of the target node, as shown in <em class="italic">Figure 4.24</em>.</p>
    <figure class="mediaobject"><img src="img/B17217_04_24.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.24: Illustration of pointers for inserting a node at an intermediate position in a doubly linked list</p>
    <p class="normal">After reaching the correct position, a few pointers have to be added in order to add a new node. The details of these links that need to be updated (also shown in <em class="italic">Figure 4.25</em>) are as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The <code class="inlineCode">next</code> pointer of the new node points to the current node</li>
      <li class="numberedList">The <code class="inlineCode">prev</code> pointer of the new node should point to the previous node</li>
      <li class="numberedList">The <code class="inlineCode">next</code> pointer of the previous node should point to the new node</li>
      <li class="numberedList">The <code class="inlineCode">prev</code> pointer of the current node should point to the new node</li>
    </ol>
    <figure class="mediaobject"><img src="img/B17217_04_25.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.25: Demonstration of links that need to be updated in order to add a new node at any intermediate position in the list</p>
    <p class="normal">Here is what the implementation of the <code class="inlineCode">append_at_a_location()</code> method may look like:</p>
    <pre class="programlisting code"><code class="hljs-code">def append_at_a_location(self, data):
   current = self.head
   prev = self.head
   new_node = Node(data, None, None)
   while current:
        if current.data == data:
            new_node.prev = prev
            new_node.next = current
            prev.next = new_node
            current.prev = new_node
            self.count += 1
        prev = current
        current = current.next
</code></pre>
    <p class="normal">In the preceding code, firstly, the <code class="inlineCode">current</code> and <code class="inlineCode">prev</code> pointers are initialized by pointing to the <code class="inlineCode">head</code> node. Then, in the <code class="inlineCode">while</code> loop, we first reach the desired position by checking the condition. In this example, we check the data value of the current node against the data value provided by the user. Once we reach the desired position, we update four links as discussed, which are also shown in <em class="italic">Figure 4.25</em>.</p>
    <pre>ham</code>" after the first occurrence of the word “<code class="inlineCode">ham</code>" in the doubly linked list:</pre>
    <pre class="programlisting code"><code class="hljs-code">words = DoublyLinkedList() 
words.append('egg') 
words.append('ham') 
words.append('spam') 
words.append_at_a_location('ham')
print("Doubly linked list after adding an element after word \"ham\" in the list.")
current = words.head
while current:
    print(current.data)
    current = current.next
</code></pre>
    <p class="normal">The output of the above code:</p>
    <pre class="programlisting con"><code class="hljs-con">Doubly linked list after adding an element after word "ham" in the list.
egg
ham
ham
spam
</code></pre>
    <p class="normal">Appending at the start and end positions in a doubly linked list will have a worst-case running time<a id="_idIndexMarker361"/> complexity of <code class="inlineCode">O(1)</code> since we can directly append the new node, and the worst-case time complexity for appending a new node at any intermediate position will be <code class="inlineCode">O(n)</code> since we may have to traverse the list of <em class="italic">n</em> items.</p>
    <p class="normal">Next, let us learn how to search a given item if that is present in the doubly linked list or not.</p>
    <h2 id="_idParaDest-100" class="heading-2">Querying a list</h2>
    <p class="normal">The search<a id="_idIndexMarker362"/> for an item in a doubly linked list is similar to the way we did it in the singly linked list. We use the <code class="inlineCode">iter()</code> method to check the data in all the nodes. As we run a loop through all the data in the list, each node is matched with the data passed in the <code class="inlineCode">contain</code> method. If we find the item in the list, <code class="inlineCode">True</code> is returned, denoting that the item is found, otherwise <code class="inlineCode">False</code> is returned, which means the item was not found in the list. The Python code for this is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">def iter(self):
        current = self.head 
        while current:
            val = current.data 
            current = current.next 
            yield val
            
    def contains(self, data): 
        for node_data in self.iter(): 
            if data == node_data: 
                print("Data item is present in the list.")
                return   
        print("Data item is not present in the list.")
        return  
</code></pre>
    <p class="normal">The following code can be used to search if a data item is present in the existing doubly linked list:</p>
    <pre class="programlisting code"><code class="hljs-code">words = DoublyLinkedList() 
 
words.append('egg') 
words.append('ham') 
words.append('spam')
words.contains("ham") 
words.contains("ham2")
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">Data item is present in the list.
Data item is not present in the list.
</code></pre>
    <p class="normal">The search operation in a doubly linked list has a running time complexity of <code class="inlineCode">O(n)</code> since we have to traverse the list in order to reach the desired element and, in the worst case, we may have <a id="_idIndexMarker363"/>to traverse the whole list of <em class="italic">n</em> items.</p>
    <h2 id="_idParaDest-101" class="heading-2">Deleting items</h2>
    <p class="normal">The deletion <a id="_idIndexMarker364"/>operation is easier in the doubly linked list compared to the singly linked list. Unlike in a singly linked list, where we need to traverse the linked list to reach the desired position, and we also need one more pointer to keep track of the previous node of the target node, in a doubly linked list, we don’t have to do that because we can traverse in both directions.</p>
    <p class="normal">The <code class="inlineCode">delete</code> operation in a doubly linked list can have four scenarios, which are discussed as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The item to be deleted is located at the start of the list</li>
      <li class="numberedList">The item to be deleted is found at the tail end of the list</li>
      <li class="numberedList">The item to be deleted is located anywhere at an intermediate position in the list</li>
      <li class="numberedList">The item to be deleted is not found in the list</li>
    </ol>
    <p class="normal">The node to be deleted is identified by matching the data instance variable with the data that is passed to the method. If the data matches the data variable of a node, that matching node will be deleted:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">For the first scenario, when we have found the item to be deleted at the first position, we will have to simply update the <code class="inlineCode">head</code> pointer to the next node. It is shown in <em class="italic">Figure 4.26</em>.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B17217_04_26.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.26: Illustration of the deletion of the first node in a doubly linked list</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">For the second scenario, when we found the item to be deleted at the last position in the list, we will have to simply update the <code class="inlineCode">tail</code> pointer to the second last<a id="_idIndexMarker365"/> node. It is shown in <em class="italic">Figure 4.27</em>.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B17217_04_27.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.27: Illustration of the deletion of the last node in a doubly linked list</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">For the third scenario, we found the data item to be deleted at any intermediate position. To better understand this, consider the example shown in <em class="italic">Figure 4.28</em>. In this, there are three nodes, <strong class="keyWord">A</strong>, <strong class="keyWord">B</strong>, and <strong class="keyWord">C</strong>. To delete node <strong class="keyWord">B</strong> in the middle of the list, we will essentially make <strong class="keyWord">A</strong> point to node <strong class="keyWord">C</strong> as its next node, while making <strong class="keyWord">C</strong> point to <strong class="keyWord">A</strong> as its previous node.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B17217_04_28.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.28: Illustration of the deletion of the intermediate node B from the doubly linked list</p>
    <p class="normal">The complete implementation to delete a node from the doubly linked list in Python is as follows. We’ll<a id="_idIndexMarker366"/> discuss each part of this code step by step:</p>
    <pre class="programlisting code"><code class="hljs-code">    def delete(self, data):
          # Delete a node from the list. 
          current = self.head 
          node_deleted = False 
          if current is None:       
          #List is empty 
               print("List is empty")
          elif current.data == data:   
          #Item to be deleted is found at starting of the list
               self.head.prev = None 
               node_deleted = True 
               self.head = current.next
           elif self.tail.data == data:   
        #Item to be deleted is found at the end of list
               self.tail = self.tail.prev  
               self.tail.next = None 
               node_deleted = True 
          else: 
               while current:          
               #search item to be deleted, and delete that node
                   if current.data == data: 
                       current.prev.next = current.next  
                       current.next.prev = current.prev 
                       node_deleted = True 
                   current = current.next 
               if node_deleted == False: 
               # Item to be deleted is not found in the list
                   print("Item not found")
          if node_deleted: 
               self.count -= 1
</code></pre>
    <p class="normal">Initially, we create a <code class="inlineCode">node_deleted</code> variable to denote the deleted node in the list and this is initialized to <code class="inlineCode">False</code>. The <code class="inlineCode">node_deleted</code> variable is set to <code class="inlineCode">True</code> if a matching node is found and subsequently removed.</p>
    <p class="normal">In the <code class="inlineCode">delete</code> method, the <code class="inlineCode">current</code> variable is initially set to the <code class="inlineCode">head</code> node of the list (that is, it points to the <code class="inlineCode">self.head</code> node of the list). This is shown in the following code fragment:</p>
    <pre class="programlisting code"><code class="hljs-code">def delete(self, data):
    current = self.head
    node_deleted = False
</code></pre>
    <p class="normal">Next, we use<a id="_idIndexMarker367"/> a set of <code class="inlineCode">if...else</code> statements to search various parts of the list to ascertain the node with the specified data that is to be deleted.</p>
    <p class="normal">First of all, we search for the data to be deleted at the <code class="inlineCode">head</code> node, and if the data is matched at the <code class="inlineCode">head</code> node, this node would be deleted. Since <code class="inlineCode">current</code> is pointing at <code class="inlineCode">head</code>, if <code class="inlineCode">current</code> is <code class="inlineCode">None</code>, this means that the list is empty and has no nodes to find the node to be deleted. The following is its code fragment:</p>
    <pre class="programlisting code"><code class="hljs-code">if current is None:
  node_deleted = False
</code></pre>
    <p class="normal">However, if <code class="inlineCode">current</code> (which now points to <code class="inlineCode">head</code>) contains the data being searched for, this means that we found the data to be deleted at the <code class="inlineCode">head</code> node, and <code class="inlineCode">self.head</code> is then marked to point to the <code class="inlineCode">current.next</code> node. Since there is now no node behind <code class="inlineCode">head</code>, <code class="inlineCode">self.head.prev</code> is set to <code class="inlineCode">None</code>. Consider the following code snippet for this:</p>
    <pre class="programlisting code"><code class="hljs-code">elif current.data == data:
    self.head.prev = None
    node_deleted = True
    self.head = current.next
</code></pre>
    <p class="normal">Similarly, if the node that is to be deleted is found at the <code class="inlineCode">tail</code> end of the list, we delete the last node by setting its previous node pointing to <code class="inlineCode">None</code>. <code class="inlineCode">self.tail</code> is set to point to <code class="inlineCode">self.tail.prev</code>, and <code class="inlineCode">self.tail.next</code> is set to <code class="inlineCode">None</code> as there is no node afterward. Consider the following code fragment for this:</p>
    <pre class="programlisting code"><code class="hljs-code">elif self.tail.data == data:
   self.tail = self.tail.prev
   self.tail.next = None
   node_deleted = True
</code></pre>
    <p class="normal">Lastly, we search for the node to be deleted by looping through the entire list of nodes. If the data that is to be deleted is matched with a node, that node will be deleted. </p>
    <p class="normal">To delete a node, we make the previous node of the <code class="inlineCode">current</code> node point to the next node using the <code class="inlineCode">current.prev.next = current.next</code> code. After that step, we make the current’s next node point to the previous node of the <code class="inlineCode">current</code> node using <code class="inlineCode">current.next.prev = current.prev</code>. Furthermore, if we traverse the complete list, and the desired<a id="_idIndexMarker368"/> item is not found, we print the appropriate message. Consider the following code snippet for this:</p>
    <pre class="programlisting code"><code class="hljs-code">else:
    while current:
       if current.data == data:
             current.prev.next = current.next
             current.next.prev = current.prev
             node_deleted = True
       current = current.next
   if node_deleted == False:
# Item to be deleted is not found in the list
       print("Item not found")
</code></pre>
    <p class="normal">Finally, the <code class="inlineCode">node_delete</code> variable is then checked to ascertain whether a node is actually deleted. If any node is deleted, then we decrease the count variable by <code class="inlineCode">1</code>, and this keeps track of the total number of nodes in the list. See the following code fragment:</p>
    <pre class="programlisting code"><code class="hljs-code">if node_deleted:
  self.count -= 1
</code></pre>
    <p class="normal">This decrements the count variable by <code class="inlineCode">1</code> in case any node is deleted.</p>
    <p class="normal">Let’s take an example to see how the delete operation works with the same example of adding three strings – “egg”, “ham”, and “spam”, and then a node with the value “ham” is deleted from the list. The code is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">#Code to create for a doubly linked list
words = DoublyLinkedList()
words.append('egg')
words.append('ham')
words.append('spam')
words.delete('ham') 
current = words.head
while current:
    print(current.data)
    current = current.next
</code></pre>
    <p class="normal">The output of the preceding code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">egg
spam
</code></pre>
    <p class="normal">The worst-case running time complexity of the delete operation is <code class="inlineCode">O(n)</code> since we may have to <a id="_idIndexMarker369"/>traverse the list of <em class="italic">n</em> items to search for the item to be deleted.</p>
    <p class="normal">In the next section, we will learn different operations on a circular linked list.</p>
    <h1 id="_idParaDest-102" class="heading-1">Circular lists</h1>
    <p class="normal">A circular linked list <a id="_idIndexMarker370"/>is a special case of a linked list. In a circular linked list, the <a id="_idIndexMarker371"/>endpoints are connected, which means that the last node in the list points back to the first node. In other words, we can say that in circular linked lists, all the nodes point to the next node (and the previous node in the case of a doubly linked list) and there is no end node, meaning no node will point to <code class="inlineCode">None</code>.</p>
    <p class="normal">The circular linked lists can be based on both singly and doubly linked lists. Consider <em class="italic">Figure 4.29</em> for the circular linked list based on a singly linked list where the last node, <strong class="keyWord">C</strong>, is again connected to the first node <strong class="keyWord">A</strong>, thus making a circular list.</p>
    <figure class="mediaobject"><img src="img/B17217_04_29.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.29: Example of a circular list based on a singly linked list</p>
    <p class="normal">In the case of a doubly linked circular list, the first node points to the last node, and the last node points back to the first node. <em class="italic">Figure 4.30</em> shows the concept of the circular linked list based on a<a id="_idIndexMarker372"/> doubly linked list where the last node <strong class="keyWord">C</strong> is again connected to the first node <strong class="keyWord">A</strong> through the <code class="inlineCode">next</code> pointer. Node <strong class="keyWord">A</strong> is also connected to node <strong class="keyWord">C</strong> through the <code class="inlineCode">previous</code> pointer, thus<a id="_idIndexMarker373"/> making a circular list.</p>
    <figure class="mediaobject"><img src="img/B17217_04_30.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.30: Example of a circular list based on a doubly linked list</p>
    <p class="normal">Now, we are going to look at an implementation of a singly linked circular list. It is very straightforward to implement a doubly linked circular list once we understand the basic concepts of singly and doubly linked lists. </p>
    <p class="normal">Almost everything is similar except that we should be careful in managing the link of the last node to the first node.</p>
    <p class="normal">We can reuse the node class that we created in the singly linked lists subsection. We can reuse most parts of the <code class="inlineCode">SinglyLinkedList</code> class as well. So, we are going to focus on where the circular list implementation differs from the normal singly linked list.</p>
    <h2 id="_idParaDest-103" class="heading-2">Creating and traversing</h2>
    <p class="normal">The <a id="_idIndexMarker374"/>circular <a id="_idIndexMarker375"/>linked list class can be created using the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">class CircularList:
    def __init__ (self):
        self.tail = None
        self.head = None
        self.size = 0
</code></pre>
    <p class="normal">In the above code, initially in the circular linked list class, we have two pointers; <code class="inlineCode">self.tail</code> is used to point to the last node, and <code class="inlineCode">self.head</code> is used to point to the first node of the list.</p>
    <h2 id="_idParaDest-104" class="heading-2">Appending items</h2>
    <p class="normal">Here, we want to<a id="_idIndexMarker376"/> add a node at the end of a circular linked list, as shown in <em class="italic">Figure 4.31</em>, in which we have four nodes, wherein the head is pointing to the starting node and the tail is pointing to the last node.</p>
    <figure class="mediaobject"><img src="img/B17217_04_31.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.31: Example of a circular linked list for adding a node at the end</p>
    <p class="normal"><em class="italic">Figure 4.32</em> shows how a node is added to a circular linked list.</p>
    <figure class="mediaobject"><img src="img/B17217_04_32.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.32: Inserting a node at the end of the singly circular list </p>
    <p class="normal">To add a node at the end, we will update three links:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The <code class="inlineCode">next</code> pointer of the last node to point to a new node</li>
      <li class="numberedList">The <code class="inlineCode">next</code> pointer of a new node to point to the <code class="inlineCode">head</code> node</li>
      <li class="numberedList">Update the <code class="inlineCode">tail</code> pointer to point to the new node</li>
    </ol>
    <p class="normal">The implementation of the circular linked list to append an element at the end of the circular list <a id="_idIndexMarker377"/>based on a singly linked list is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">    def append(self, data):
        node = Node(data) 
        if self.tail: 
            self.tail.next = node
            self.tail = node
<code style="font-weight: bold;" class="codeHighlighted">            node.next = self.head</code>
        else: 
            self.head = node 
            self.tail = node 
<code style="font-weight: bold;" class="codeHighlighted">            self.tail.next = self.tail</code>
        self.size += 1
</code></pre>
    <p class="normal">In the above code, firstly, we check whether the list is empty. If the list is empty, we go to the <code class="inlineCode">else</code> part of the above code. In this case, the new node will be the first node of the list, and both the <code class="inlineCode">head</code> and <code class="inlineCode">tail</code> pointers will point to the new node, while the <code class="inlineCode">next</code> pointer of the new node will again point to the new node. </p>
    <p class="normal">Otherwise, if the list is not empty, we go to the <code class="inlineCode">if</code> part of the preceding code. In this case, we update the three pointers as shown in <em class="italic">Figure 4.32</em>. This is similar to what we did in the case of the single linked list. Only one link is additionally added in this case, which is shown in bold font in the preceding code.</p>
    <p class="normal">Further, we can use <code class="inlineCode">iter()</code> method traverse all the elements of the list, The <code class="inlineCode">iter()</code> method described below should be defined in <code class="inlineCode">CircularList</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">def iter(self):
     current = self.head
     while current:
          val = current.data
          current = current.next
          yield val
</code></pre>
    <p class="normal">The below code can be used to create a singly circular linked list, and then print all the data elements of the list, and then we stop when the counter becomes 3 which is the length of the list.</p>
    <pre class="programlisting code"><code class="hljs-code">words = CircularList()
words.append('eggs')
words.append('ham')
words.append('spam')
</code></pre>
    <p class="normal"> </p>
    <pre class="programlisting code"><code class="hljs-code">counter = 0
for word in words.iter():
    print(word)
    counter += 1
    if counter &gt; 2:
        break
</code></pre>
    <p class="normal">The output of the preceding code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">eggs
ham
spam
</code></pre>
    <p class="normal">Appending<a id="_idIndexMarker378"/> any element at an intermediate position in a circular list is exactly to its implementation in a singly linked list.</p>
    <h2 id="_idParaDest-105" class="heading-2">Querying a list</h2>
    <p class="normal">Traversing a <a id="_idIndexMarker379"/>circular linked list is very convenient as we don’t need to look for the starting point. We can start anywhere, and we just need to carefully stop traversing when we reach the same node again. We can use the same <code class="inlineCode">iter()</code> method, which we discussed at the start of this chapter. This will also be the case for the circular list; the only difference is that we have to mention an exit condition when we are iterating through the circular list, otherwise the program will get stuck in a loop, and it will run indefinitely. We can make any exit condition dependent upon our requirements; for example, we can use a counter variable. Consider the following example code:</p>
    <pre class="programlisting code"><code class="hljs-code">words = CircularList()
words.append('eggs')
words.append('ham')
words.append('spam')
counter = 0
for word in words.iter():
    print(word)
    counter += 1
    if counter &gt; 100:
        break
</code></pre>
    <p class="normal">In the above code, we add three strings of data to the circular linked list, and then we print the <a id="_idIndexMarker380"/>data values iterating through the list 100 times.</p>
    <p class="normal">In the next section, let us understand how the <code class="inlineCode">delete</code> operation works in a circular linked list.</p>
    <h2 id="_idParaDest-106" class="heading-2">Deleting an element in a circular list</h2>
    <p class="normal">To delete a node in a<a id="_idIndexMarker381"/> circular list, it looks like we can do it similarly to how we did in the case of the append operation—simply make sure that the last node through the <code class="inlineCode">tail</code> pointer points back to the starting node of the list through the <code class="inlineCode">head</code> pointer. We have the following three scenarios:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">When the item to be deleted is the <code class="inlineCode">head</code> node: <p class="normal">In this scenario, we have to ensure that we make the second node of the list the new <code class="inlineCode">head</code> node (shown as <em class="italic">step 1</em> in <em class="italic">Figure 4.33</em>), and the last node should be pointing back to the new head (shown as <em class="italic">step 2</em> in <em class="italic">Figure 4.33</em>).</p>
        <figure class="mediaobject"><img src="img/B17217_04_33.png" alt=""/></figure>
        <p class="packt_figref">Figure 4.33: Deletion of a starting node in a singly circular list</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">When the item to be deleted is the <code class="inlineCode">last</code> node: <p class="normal">In this scenario, we have to ensure that we make the second last node the new tail node (shown as <em class="italic">step 1 </em>in <em class="italic">Figure 4.34</em>), while the new tail node should be pointing back to the new head (shown as <em class="italic">step 2</em> in <em class="italic">Figure 4.34</em>).</p>
        <figure class="mediaobject"><img src="img/B17217_04_34.png" alt=""/></figure>
        <p class="packt_figref">Figure 4.34: Deletion of the last node in a singly circular list</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">When<a id="_idIndexMarker382"/> the item to be deleted is an intermediate node: <p class="normal">This is very similar to what we did in the singly linked list. We have to make a link from the previous node of the target node to the next node of the target node, as shown in <em class="italic">Figure 4.35</em>.</p>
        <figure class="mediaobject"><img src="img/B17217_04_35.png" alt=""/></figure>
        <p class="packt_figref">Figure 4.35: Deletion of any intermediate node in a singly circular list</p>
      </li>
    </ol>
    <p class="normal">The implementation of the <code class="inlineCode">delete</code> operation is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">    def delete(self, data):
        current = self.head
        prev = self.head
<code style="font-weight: bold;" class="codeHighlighted">        while prev == current or prev != self.tail:</code>
            if current.data == data:
                if current == self.head:   
                    #item to be deleted is head node
                    self.head = current.next
                    self.tail.next = self.head
                elif current == self.tail:  
                    #item to be deleted is tail node
                    self.tail = prev
                    prev.next = self.head
                else:
                    #item to be deleted is an intermediate node
                    prev.next = current.next
                self.size -= 1
                return
            prev = current
            current = current.next
            if flag is False:
                print("Item not present in the list")
</code></pre>
    <p class="normal">In the preceding code, firstly, iterate over all the elements to search the desired element to be<a id="_idIndexMarker383"/> deleted. Here, it is important to note the stopping condition. If we simply check the <code class="inlineCode">current</code> pointer to be equal to <code class="inlineCode">None</code> (which we did in the singly linked list), the program will go into an indefinite loop since the current node will never point to <code class="inlineCode">None</code> in the case of circular linked lists. </p>
    <p class="normal">For this, we cannot check whether <code class="inlineCode">current</code> has reached <code class="inlineCode">tail</code> because then it will never check the last node. So, the stopping criterion in the circular list is the fact that the <code class="inlineCode">prev</code> and <code class="inlineCode">current</code> pointers point to the same node. It will work fine except on one occasion when the first loop iteration, at that time, <code class="inlineCode">current</code> and <code class="inlineCode">prev</code>, will point to the same node, in other words, the <code class="inlineCode">head</code> node.</p>
    <p class="normal">Once, we enter the loop, we check the data value of the current pointer with the given data value to get the node to be deleted. We check whether the node to be deleted is the <code class="inlineCode">head</code> node, tail node, or intermediate node, and then update the appropriate links shown in <em class="italic">Figures 4.33</em>, <em class="italic">4.34</em>, and <em class="italic">4.35</em>.</p>
    <p class="normal">So, we have discussed the different scenarios while deleting any node in singly circular linked list, similarly, the doubly linked list based circular linked list can be implemented. </p>
    <p class="normal">The following code can be used to create a circular linked list, and apply different delete operations:</p>
    <pre class="programlisting code"><code class="hljs-code">words = CircularList()
words.append('eggs')
words.append('ham')
words.append('spam')
words.append('foo')
words.append('bar')
 
print("Let us try to delete something that isn't in the list.")
words.delete('socks')
counter = 0
for item in words.iter():
    print(item)
    counter += 1
    if counter &gt; 4:
        break
        
print("Let us delete something that is there.")
words.delete('foo')
counter = 0
for item in words.iter():
    print(item)
    counter += 1
    if counter &gt; 3:
        break
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">Let us try to delete something that isn't in the list.
Item not present in the list
eggs
ham
spam
foo
bar
Let us delete something that is there.
eggs
ham
spam
bar
</code></pre>
    <p class="normal">The worst-case time complexity of inserting an element at a given location in the circular linked list is <code class="inlineCode">O(n)</code> since we have to traverse the list to the desired location. The complexity of insertion at the first and last locations of the circular list will be <code class="inlineCode">O(1)</code>. Similarly, the worst-case time complexity to delete an element at a given location is <code class="inlineCode">O(n)</code>.</p>
    <p class="normal">So far, we have discussed the different scenarios while deleting any node in a singly circular linked list. Similarly, the doubly linked list can be implemented based on a circular linked list.</p>
    <p class="normal">In a singly linked list, the traversal of nodes can be done in one direction, whereas, in a doubly linked list, it is possible to traverse in both directions (forward and backward). In both cases, the complexity of the insertion and deletion operations at a given location is <code class="inlineCode">O(n)</code> whenever we have to traverse the list in order to reach the desired location where we want to insert or delete any element. Similarly, the worst-case time complexity of the insertion or deletion of a node for a given desired location is <code class="inlineCode">O(n)</code>. Whenever we need to save memory space, we should use a singly linked list since it only needs one pointer, whereas a doubly linked list takes more memory space to store double pointers. When a search operation is important, we should use a doubly linked list since it is possible to<a id="_idIndexMarker384"/> search in both directions. Furthermore, the circular linked list should be used when we have an application when we need to iterate over the nodes in the list. Let us now see more real-world applications of linked lists.</p>
    <h1 id="_idParaDest-107" class="heading-1">Practical applications of linked lists</h1>
    <p class="normal">As of now, we have<a id="_idIndexMarker385"/> discussed singly linked lists, circular linked lists, and doubly linked lists. Depending upon what kind of operations (insertion, deletion, updating, and so on) will be required in different applications, these data structures are used accordingly. Let’s see a few real-time applications where these data structures are being used.</p>
    <p class="normal">Singly linked lists can be used to represent any sparse matrix. Another important application is to represent and manipulate polynomials by accumulating constants in the node of linked lists. </p>
    <p class="normal">It can also be used in implementing a dynamic memory management scheme that allows the user to allocate and deallocate the memory as per requirements during the execution of programs.</p>
    <p class="normal">On the other hand, doubly linked lists are used by the thread schedular in the operating system to maintain the list of processes running at that time. These lists are also used in the implementation of <strong class="screenText">MRU</strong> (most recently used) and <strong class="screenText">LRU</strong> (least recently used) cache in the operating system. </p>
    <p class="normal">Doubly linked lists can also be used by various applications to implement <strong class="screenText">Undo</strong> and <strong class="screenText">Redo</strong> functionality. The browsers can use these lists to implement backward and forward navigation of the web pages visited.</p>
    <p class="normal">A circular linked list can be used by operating systems to implement a round-robin scheduling mechanism. Another application of circular linked lists is to implement <strong class="screenText">Undo</strong> functionality in Photoshop or Word software and use it in implementing a browser cache that allows you to hit the <strong class="screenText">BACK</strong> button. Besides that, it is also used to implement advanced data structures such as the Fibonacci heap. Multiplayer games also use a circular linked<a id="_idIndexMarker386"/> list to swap between players in a loop.</p>
    <h1 id="_idParaDest-108" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we studied the concepts that underlie lists, such as nodes and pointers to other nodes. We have discussed singly linked lists, doubly linked lists, and circular linked lists. We have seen various operations that can be applied to these data structures and their implementations using Python.</p>
    <p class="normal">These types of data structures have certain advantages over arrays. In the case of arrays, insertion and deletion are quite time-consuming as these operations require the shifting of elements downward and upward, respectively, due to contiguous memory allocations. On the other hand, in the case of linked lists, these operations require only changes in pointers. Another advantage of linked lists over arrays is the allowance of a dynamic memory management scheme that allocates memory during the runtime as and when needed, while the array is based on a static memory allocation scheme.</p>
    <p class="normal">The singly linked list can traverse in a forward direction only, while traversal in doubly linked lists is bidirectional, hence the reason why the deletion of a node in a doubly linked list is easy compared to a singly linked list. Similarly, circular linked lists save time while accessing the first node from the last node as compared to the singly linked list. Thus, each list has its advantages and disadvantages. We should use them as per the requirements of the application.</p>
    <p class="normal">In the next chapter, we are going to look at two other data structures that are usually implemented using lists—stacks and queues.</p>
    <h1 id="_idParaDest-109" class="heading-1">Exercise</h1>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">What will be the time complexity when inserting a data element after an element that is being pointed to by a pointer in a linked list?</li>
      <li class="numberedList">What will be the time complexity when ascertaining the length of the given linked list?</li>
      <li class="numberedList">What will be the worst-case time complexity for searching a given element in a singly linked list of length n?</li>
      <li class="numberedList">For a given linked list, assuming it has only one <code class="inlineCode">head</code> pointer that points to the starting point of the list, what will be the time complexity for the following operations?<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">Insertion at the front of the linked list</li>
          <li class="alphabeticList">Insertion at the end of the linked list</li>
          <li class="alphabeticList">Deletion of the front node of the linked list</li>
          <li class="alphabeticList">Deletion of the last node of the linked list</li>
        </ol>
      </li>
      <li class="numberedList">Find the n<sup class="superscript">th</sup> node from the end of a linked list.</li>
      <li class="numberedList">How can you establish whether there is a loop (or circle) in a given linked list?</li>
      <li class="numberedList">How can you ascertain the middle element of the linked list?</li>
    </ol>
    <h1 class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://packt.link/MEvK4">https://packt.link/MEvK4</a></p>
    <p class="normal"><img src="img/QR_Code1421249772551223062.png" alt=""/></p>
  </div>
</body></html>