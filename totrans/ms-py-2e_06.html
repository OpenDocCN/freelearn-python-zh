<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer121" class="Basic-Text-Frame">&#13;
    <h1 class="chapterNumber">6</h1>&#13;
    <h1 id="_idParaDest-152" class="chapterTitle">Decorators – Enabling Code Reuse by Decorating</h1>&#13;
    <p class="normal">In this chapter, you are going to learn about Python decorators. The previous chapters have already shown the usage of a few decorators, but you will now find out more about them. Decorators are essentially function/class wrappers that can be used to modify the input, output, or even the function/class itself before executing it. This type of wrapping can just as easily be achieved by having a separate function that calls the inner function, or via inheriting small feature classes commonly called <strong class="keyWord">mixins</strong>. As is the case with many Python constructs, decorators are not the only way to reach the goal but are definitely convenient in many cases.</p>&#13;
    <p class="normal">While you can get along fine without knowing too much about decorators, they give you a lot of “reuse power” and are therefore used heavily in framework libraries such as web frameworks. Python actually comes bundled with some useful decorators, most notably the <code class="inlineCode">@property</code>, <code class="inlineCode">@classmethod</code>, and <code class="inlineCode">@staticmethod</code> decorators.</p>&#13;
    <p class="normal">There are, however, some particularities to take note of: wrapping a function creates a new function and makes it harder to reach the inner function and its properties. One example of this is the <code class="inlineCode">help(function)</code> functionality of Python; by default, you, your editor, and your documentation generator can lose function properties such as the help text and the module the function exists in.</p>&#13;
    <p class="normal">This chapter will cover the usage of both function and class decorators, as well as the intricate details you need to know when decorating functions within classes.</p>&#13;
    <p class="normal">The following are the topics covered:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Decorating functions</li>&#13;
      <li class="bulletList">Decorating class functions</li>&#13;
      <li class="bulletList">Decorating classes</li>&#13;
      <li class="bulletList">Useful decorators in the Python Standard Library</li>&#13;
    </ul>&#13;
    <h1 id="_idParaDest-153" class="heading-1">Decorating functions</h1>&#13;
    <p class="normal">Decorators are<a id="_idIndexMarker407"/> functions or classes that wrap other functions and/or classes. In its most basic form, you <a id="_idIndexMarker408"/>can view a regular function call as <code class="inlineCode">add(1, 2)</code>, which transforms into <code class="inlineCode">decorator(add(1, 2))</code> when applying a decorator. There’s slightly more to it, but we will come to that later. Let’s implement that <code class="inlineCode">decorator()</code> function:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">decorator</span><span class="hljs-con-function">(</span><span class="hljs-con-params">function</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> function</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">add</span><span class="hljs-con-function">(</span><span class="hljs-con-params">a, b</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> a + b</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">add = decorator(add)</span>&#13;
</code></pre>&#13;
    <p class="normal">To make the syntax easier to use, Python has a special syntax for this case. So, instead of adding a line such as the preceding one below the function, you can decorate a function using the <code class="inlineCode">@</code> operator as a shortcut:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@decorator</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">add</span><span class="hljs-con-function">(</span><span class="hljs-con-params">a, b</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> a + b</span>&#13;
</code></pre>&#13;
    <p class="normal">This example shows the simplest and most useless decorator you can get: simply returning the input function and doing nothing else.</p>&#13;
    <p class="normal">From this, you might wonder what the use of a decorator is and what is so special about them. Some possibilities of decorators<a id="_idIndexMarker409"/> are:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Registering a function/class</li>&#13;
      <li class="bulletList">Modifying function/class input</li>&#13;
      <li class="bulletList">Modifying function/class output</li>&#13;
      <li class="bulletList">Logging function calls/class instantiations</li>&#13;
    </ul>&#13;
    <p class="normal">All of these will be covered later in this chapter, but let’s start simple for now.</p>&#13;
    <p class="normal">Our first <a id="_idIndexMarker410"/>decorator will show how we can modify both the input and the output of a function call. Additionally, it adds some <code class="inlineCode">logging</code> calls so we can see what is happening:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> functools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">decorator</span><span class="hljs-con-function">(</span><span class="hljs-con-params">function</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">   </span><span class="hljs-con-comment"># This decorator makes sure we mimic the wrapped function</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">   @functools.wraps(</span><span class="hljs-con-params">function</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">   </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">_decorator</span><span class="hljs-con-function">(</span><span class="hljs-con-params">a, b</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">       </span><span class="hljs-con-comment"># Pass the modified arguments to the function</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">       result = function(a, b + </span><span class="hljs-con-number">5</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">       </span><span class="hljs-con-comment"># Log the function call</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">       name = function.__name__</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">       print(</span><span class="hljs-con-string">f'</span><span class="hljs-con-subst">{name}</span><span class="hljs-con-string">(a=</span><span class="hljs-con-subst">{a}</span><span class="hljs-con-string">, b=</span><span class="hljs-con-subst">{b}</span><span class="hljs-con-string">): </span><span class="hljs-con-subst">{result}</span><span class="hljs-con-string">'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">       </span><span class="hljs-con-comment"># Return a modified result</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">       </span><span class="hljs-con-keyword">return</span><span class="python"> result + </span><span class="hljs-con-number">4</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">   </span><span class="hljs-con-keyword">return</span><span class="python"> _decorator</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@decorator</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">func</span><span class="hljs-con-function">(</span><span class="hljs-con-params">a, b</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> a + b</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">func(</span><span class="hljs-con-number">1</span><span class="python">, </span><span class="hljs-con-number">2</span><span class="python">)</span>&#13;
func(a=1, b=2): 8&#13;
12&#13;
</code></pre>&#13;
    <p class="normal">This should show you how powerful<a id="_idIndexMarker411"/> decorators can be. We can modify, add, and/or remove arguments. We can modify the return value or even call a completely different function if we want to. And we can easily log all behavior if needed, which can be very useful when debugging. Instead of <code class="inlineCode">return function(...)</code>, we can return something completely different if we wish.</p>&#13;
    <p class="normal">More extensive examples of how to log using decorators are covered in <em class="chapterRef">Chapter 12, </em><em class="italic">Debugging – Solving the Bugs</em>.</p>&#13;
    <h2 id="_idParaDest-154" class="heading-2">Generic function decorators</h2>&#13;
    <p class="normal">The decorator <a id="_idIndexMarker412"/>we wrote earlier explicitly used the <code class="inlineCode">a</code> and <code class="inlineCode">b</code> arguments so it only works with functions that have a signature very similar to taking <code class="inlineCode">a</code> and <code class="inlineCode">b</code> arguments. If we want to make the generator more generic, we can replace <code class="inlineCode">a, b</code> with <code class="inlineCode">*args</code> and <code class="inlineCode">**kwargs</code> to get the arguments and keyword arguments, respectively. That introduces a new problem, however. We either need to make sure to only use regular arguments or keyword arguments, or the checking will become increasingly difficult:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> functools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">decorator</span><span class="hljs-con-function">(</span><span class="hljs-con-params">function</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">   @functools.wraps(</span><span class="hljs-con-params">function</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">   </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">_decorator</span><span class="hljs-con-function">(</span><span class="hljs-con-params">*args, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">       a, b = args</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">       </span><span class="hljs-con-keyword">return</span><span class="python"> function(a, b + </span><span class="hljs-con-number">5</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">   </span><span class="hljs-con-keyword">return</span><span class="python"> _decorator</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@decorator</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">func</span><span class="hljs-con-function">(</span><span class="hljs-con-params">a, b</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> a + b</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">func(</span><span class="hljs-con-number">1</span><span class="python">, </span><span class="hljs-con-number">2</span><span class="python">)</span>&#13;
8&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">func(a=</span><span class="hljs-con-number">1</span><span class="python">, b=</span><span class="hljs-con-number">2</span><span class="python">)</span>&#13;
Traceback (most recent call last):&#13;
<span class="hljs-con-meta">...</span>&#13;
ValueError: not enough values to unpack (expected 2, got 0)&#13;
</code></pre>&#13;
    <p class="normal">As can be seen, in this <a id="_idIndexMarker413"/>case, keyword arguments are broken. To work around this issue, we have a few different methods. We can change the arguments to positional-only or keyword-only arguments:</p>&#13;
    <div class="note">&#13;
      <p class="normal">This code uses positional-only arguments (the <code class="inlineCode">/</code> as the last function argument), which have been supported since Python 3.8. For older versions, you can emulate this behavior using <code class="inlineCode">*args</code> instead of explicit arguments.</p>&#13;
    </div>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">add</span><span class="hljs-con-function">(</span><span class="hljs-con-params">a, b, /</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> a + b</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">add(a=</span><span class="hljs-con-number">1</span><span class="python">, b=</span><span class="hljs-con-number">2</span><span class="python">)</span>&#13;
Traceback (most recent call last):&#13;
<span class="hljs-con-meta">...</span>&#13;
TypeError: add() got some positional-only arguments passed ...&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">add</span><span class="hljs-con-function">(</span><span class="hljs-con-params">*, a, b</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> a + b</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">add(</span><span class="hljs-con-number">1</span><span class="python">, </span><span class="hljs-con-number">2</span><span class="python">)</span>&#13;
Traceback (most recent call last):&#13;
<span class="hljs-con-meta">...</span>&#13;
TypeError: add() takes 0 positional arguments but 2 were given&#13;
</code></pre>&#13;
    <p class="normal">Or we can make <a id="_idIndexMarker414"/>Python automatically take care of this by fetching the signature and binding it to the given arguments:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> inspect</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> functools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">decorator</span><span class="hljs-con-function">(</span><span class="hljs-con-params">function</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">   </span><span class="hljs-con-comment"># Use the inspect module to get function signature. More</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">   </span><span class="hljs-con-comment"># about this in the logging chapter</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">   signature = inspect.signature(function)</span>&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">   @functools.wraps(</span><span class="hljs-con-params">function</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">   </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">_decorator</span><span class="hljs-con-function">(</span><span class="hljs-con-params">*args, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">       </span><span class="hljs-con-comment"># Bind the arguments to the given *args and **kwargs.</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">       </span><span class="hljs-con-comment"># If you want to make arguments optional, use</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">       </span><span class="hljs-con-comment"># signature.bind_partial instead.</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">       bound = signature.bind(*args, **kwargs)</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">       </span><span class="hljs-con-comment"># Apply the defaults so b is always filled</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">       bound.apply_defaults()</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">       </span><span class="hljs-con-comment"># Extract the filled arguments. If the number of</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">       </span><span class="hljs-con-comment"># arguments is still expected to be fixed, you can use</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">       </span><span class="hljs-con-comment"># tuple unpacking: 'a, b = bound.arguments.values()'</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">       a = bound.arguments[</span><span class="hljs-con-string">'a'</span><span class="python">]</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">       b = bound.arguments[</span><span class="hljs-con-string">'b'</span><span class="python">]</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">       </span><span class="hljs-con-keyword">return</span><span class="python"> function(a, b + </span><span class="hljs-con-number">5</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">   </span><span class="hljs-con-keyword">return</span><span class="python"> _decorator</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@decorator</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">func</span><span class="hljs-con-function">(</span><span class="hljs-con-params">a, b=</span><span class="hljs-con-number">3</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> a + b</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">func(</span><span class="hljs-con-number">1</span><span class="python">, </span><span class="hljs-con-number">2</span><span class="python">)</span>&#13;
8&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">func(a=</span><span class="hljs-con-number">1</span><span class="python">, b=</span><span class="hljs-con-number">2</span><span class="python">)</span>&#13;
8&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">func(a=</span><span class="hljs-con-number">1</span><span class="python">)</span>&#13;
9&#13;
</code></pre>&#13;
    <p class="normal">By using this<a id="_idIndexMarker415"/> method, the function has become a lot more versatile. We could easily add arguments to the <code class="inlineCode">add</code> function and still be sure that the decorator functions.</p>&#13;
    <h2 id="_idParaDest-155" class="heading-2">The importance of functools.wraps</h2>&#13;
    <p class="normal">Whenever you are writing a<a id="_idIndexMarker416"/> decorator, always be sure to add <code class="inlineCode">functools.wraps</code> to wrap the inner function. Without wrapping it, you will lose all properties from the original function, which can lead to confusion and unexpected behavior. Take a look at the following code without <code class="inlineCode">functools.wraps</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">decorator</span><span class="hljs-con-function">(</span><span class="hljs-con-params">function</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">   </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">_decorator</span><span class="hljs-con-function">(</span><span class="hljs-con-params">*args, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">       </span><span class="hljs-con-keyword">return</span><span class="python"> function(*args, **kwargs)</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">   </span><span class="hljs-con-keyword">return</span><span class="python"> _decorator</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@decorator</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">add</span><span class="hljs-con-function">(</span><span class="hljs-con-params">a, b</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-string">'''Add a and b'''</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> a + b</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">help</span><span class="python">(add)</span>&#13;
Help on function _decorator in module ...:&#13;
&lt;BLANKLINE&gt;&#13;
_decorator(*args, **kwargs)&#13;
&lt;BLANKLINE&gt;&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">add.__name__</span>&#13;
'_decorator'&#13;
</code></pre>&#13;
    <p class="normal">Now, our <code class="inlineCode">add</code> method has no documentation anymore and the name is gone. It has been renamed <code class="inlineCode">_decorator</code>. Since we are indeed calling <code class="inlineCode">_decorator</code>, this is understandable, but it’s very inconvenient for code that relies on this information. Now we will try the same code with a minor difference; we will use <code class="inlineCode">functools.wraps</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> functools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">decorator</span><span class="hljs-con-function">(</span><span class="hljs-con-params">function</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @functools.wraps(</span><span class="hljs-con-params">function</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">_decorator</span><span class="hljs-con-function">(</span><span class="hljs-con-params">*args, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> function(*args, **kwargs)</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> _decorator</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@decorator</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">add</span><span class="hljs-con-function">(</span><span class="hljs-con-params">a, b</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-string">'''Add a and b'''</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> a + b</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">help</span><span class="python">(add)</span>&#13;
Help on function add in module ...:&#13;
&lt;BLANKLINE&gt;&#13;
add(a, b)&#13;
    Add a and b&#13;
&lt;BLANKLINE&gt;&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">add.__name__</span>&#13;
'add'&#13;
</code></pre>&#13;
    <p class="normal">Without any<a id="_idIndexMarker417"/> further changes, we now have documentation and the expected function name. The working of <code class="inlineCode">functools.wraps</code> is nothing magical; it copies and updates several attributes. Specifically, the following attributes are copied:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">__doc__</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">__name__</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">__module__</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">__annotations__</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">__qualname__</code></li>&#13;
    </ul>&#13;
    <p class="normal">Also, <code class="inlineCode">__dict__</code> is updated using <code class="inlineCode">_decorator.__dict__.update(add.__dict__)</code>, and a new property called <code class="inlineCode">__wrapped__</code> is added, which contains the original function (<code class="inlineCode">add,</code> in this case). The actual <code class="inlineCode">wraps</code> function is available in the <code class="inlineCode">functools.py</code> file of your Python distribution.</p>&#13;
    <h2 id="_idParaDest-156" class="heading-2">Chaining or nesting decorators</h2>&#13;
    <p class="normal">Since we’re <a id="_idIndexMarker418"/>wrapping functions, there is nothing stopping us from adding<a id="_idIndexMarker419"/> multiple wrappers. The order is important to keep in mind, though, because the decorators are initialized starting from the inside, but are called starting from the outside. Additionally, the teardown starts from the inside again:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> functools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">track</span><span class="hljs-con-function">(</span><span class="hljs-con-params">function=</span><span class="hljs-con-literal">None</span><span class="hljs-con-params">, label=</span><span class="hljs-con-literal">None</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-comment"># Trick to add an optional argument to our decorator</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">if</span><span class="python"> label </span><span class="hljs-con-keyword">and</span><span class="python"> </span><span class="hljs-con-keyword">not</span><span class="python"> function:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> functools.partial(track, label=label)</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">f'initializing </span><span class="hljs-con-subst">{label}</span><span class="hljs-con-string">'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @functools.wraps(</span><span class="hljs-con-params">function</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">_track</span><span class="hljs-con-function">(</span><span class="hljs-con-params">*args, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        print(</span><span class="hljs-con-string">f'calling </span><span class="hljs-con-subst">{label}</span><span class="hljs-con-string">'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        function(*args, **kwargs)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        print(</span><span class="hljs-con-string">f'called </span><span class="hljs-con-subst">{label}</span><span class="hljs-con-string">'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> _track</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@track(</span><span class="hljs-con-params">label=</span><span class="hljs-con-string">'outer'</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">@track(</span><span class="hljs-con-params">label=</span><span class="hljs-con-string">'inner'</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">func</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">'func'</span><span class="python">)</span>&#13;
initializing inner&#13;
initializing outer&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">func()</span>&#13;
calling outer&#13;
calling inner&#13;
func&#13;
called inner&#13;
called outer&#13;
</code></pre>&#13;
    <p class="normal">As you can see in the output, the decorators are called from outer to inner before running the function and running from inner to outer when processing the results.</p>&#13;
    <h2 id="_idParaDest-157" class="heading-2">Registering functions using decorators</h2>&#13;
    <p class="normal">We have seen how <a id="_idIndexMarker420"/>calls can be tracked, arguments can be<a id="_idIndexMarker421"/> modified, and return values can be changed. Now it is time to see how we can use decorators to register a function that can be useful for registering plugins, callbacks, and so on.</p>&#13;
    <p class="normal">One situation where this is very useful is a user interface. Let us assume we have a GUI that has a button that can be clicked. By creating a system that can register callbacks, we can make the button fire a “clicked” signal and connect functions to that event.</p>&#13;
    <p class="normal">To create an event manager like that, we will now create a class that keeps track of all of the registered functions and allows the firing of events:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> collections</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">EventRegistry</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.registry = collections.defaultdict(</span><span class="hljs-con-built_in">list</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">on</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, *events</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">_on</span><span class="hljs-con-function">(</span><span class="hljs-con-params">function</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-keyword">for</span><span class="python"> event </span><span class="hljs-con-keyword">in</span><span class="python"> events:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">                self.registry[event].append(function)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-keyword">return</span><span class="python"> function</span>&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> _on</span>&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">fire</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, event, *args, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">for</span><span class="python"> function </span><span class="hljs-con-keyword">in</span><span class="python"> self.registry[event]:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            function(*args, **kwargs)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">events = EventRegistry()</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@events.on(</span><span class="hljs-con-string">'success'</span><span class="hljs-con-params">, </span><span class="hljs-con-string">'error'</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">teardown</span><span class="hljs-con-function">(</span><span class="hljs-con-params">value</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">f'Tearing down got: </span><span class="hljs-con-subst">{value}</span><span class="hljs-con-string">'</span><span class="python">)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@events.on(</span><span class="hljs-con-string">'</span><span class="hljs-con-string">success'</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">success</span><span class="hljs-con-function">(</span><span class="hljs-con-params">value</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">f'Successfully executed: </span><span class="hljs-con-subst">{value}</span><span class="hljs-con-string">'</span><span class="python">)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">events.fire(</span><span class="hljs-con-string">'non-existing'</span><span class="python">, </span><span class="hljs-con-string">'nothing to see here'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">events.fire(</span><span class="hljs-con-string">'error'</span><span class="python">, </span><span class="hljs-con-string">'Oops, some error here'</span><span class="python">)</span>&#13;
Tearing down got: Oops, some error here&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">events.fire(</span><span class="hljs-con-string">'success'</span><span class="python">, </span><span class="hljs-con-string">'Everything is fine'</span><span class="python">)</span>&#13;
Tearing down got: Everything is fine&#13;
Successfully executed: Everything is fine&#13;
</code></pre>&#13;
    <p class="normal">Firstly, we create the <code class="inlineCode">EventRegistry</code> class to handle all of the events and store all the callbacks. After that, we register a few functions with the registry. Lastly, we fire a few events to see if it works as expected.</p>&#13;
    <p class="normal">While this <a id="_idIndexMarker422"/>example is rather basic, this pattern can be <a id="_idIndexMarker423"/>applied to many scenarios: handling events for a web server, letting plugins register themselves for events, letting plugins register themselves in an application, and so on.</p>&#13;
    <h2 id="_idParaDest-158" class="heading-2">Memoization using decorators</h2>&#13;
    <p class="normal">Memoization<a id="_idIndexMarker424"/> is a simple trick for remembering results to make code run a lot faster in specific scenarios. The basic trick here is to store a mapping of the input and expected output so that you have to calculate a value only once. One of the most common examples of this technique is the naïve (recursive) Fibonacci function.</p>&#13;
    <div class="note">&#13;
      <p class="normal">The Fibonacci sequence starts from 0 or 1 (depending how you look at it) and each consecutive number consists of the sum of the previous two numbers. To illustrate the pattern starting from the additions of the initial <code class="inlineCode">0</code> and <code class="inlineCode">1</code>:</p>&#13;
      <pre class="programlisting gen"><code class="hljs"><code class="inlineCode">1 = 0 + 1</code>&#13;
<code class="inlineCode">2 = 1 + 1</code>&#13;
<code class="inlineCode">3 = 1 + 2</code>&#13;
<code class="inlineCode">5 = 2 + 3</code>&#13;
<code class="inlineCode">8 = 3 + 5</code>&#13;
</code></pre>&#13;
    </div>&#13;
    <p class="normal">I will now show how<a id="_idIndexMarker425"/> you can build a very basic memoization function<a id="_idIndexMarker426"/> decorator, and how it can be used:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> functools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">memoize</span><span class="hljs-con-function">(</span><span class="hljs-con-params">function</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-comment"># Store the cache as attribute of the function so we can</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-comment"># apply the decorator to multiple functions without</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-comment"># sharing the cache.</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    function.cache = </span><span class="hljs-con-built_in">dict</span><span class="python">()</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @functools.wraps(</span><span class="hljs-con-params">function</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">_memoize</span><span class="hljs-con-function">(</span><span class="hljs-con-params">*args</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-comment"># If the cache is not available, call the function</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-comment"># Note that all args need to be hashable</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">if</span><span class="python"> args </span><span class="hljs-con-keyword">not</span><span class="python"> </span><span class="hljs-con-keyword">in</span><span class="python"> function.cache:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            function.cache[args] = function(*args)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> function.cache[args]</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> _memoize</span>&#13;
</code></pre>&#13;
    <p class="normal">The memoize decorator has to be used without arguments and the cache can be introspected as well:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@memoize</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">fibonacci</span><span class="hljs-con-function">(</span><span class="hljs-con-params">n</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">if</span><span class="python"> n &lt; </span><span class="hljs-con-number">2</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> n</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">else</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> fibonacci(n - </span><span class="hljs-con-number">1</span><span class="python">) + fibonacci(n - </span><span class="hljs-con-number">2</span><span class="python">)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span><span class="python"> i </span><span class="hljs-con-keyword">in</span><span class="python"> </span><span class="hljs-con-built_in">range</span><span class="python">(</span><span class="hljs-con-number">1</span><span class="python">, </span><span class="hljs-con-number">7</span><span class="python">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">f'fibonacci </span><span class="hljs-con-subst">{i}</span><span class="hljs-con-string">: </span><span class="hljs-con-subst">{fibonacci(i)}</span><span class="hljs-con-string">'</span><span class="python">)</span>&#13;
fibonacci 1: 1&#13;
fibonacci 2: 1&#13;
fibonacci 3: 2&#13;
fibonacci 4: 3&#13;
fibonacci 5: 5&#13;
fibonacci 6: 8&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">fibonacci.__wrapped__.cache</span>&#13;
{(1,): 1, (0,): 0, (2,): 1, (3,): 2, (4,): 3, (5,): 5, (6,): 8}&#13;
</code></pre>&#13;
    <p class="normal">When<a id="_idIndexMarker427"/> arguments are given, it breaks because the decorator<a id="_idIndexMarker428"/> is not built to support them:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># It breaks keyword arguments:</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">fibonacci(n=</span><span class="hljs-con-number">2</span><span class="python">)</span>&#13;
Traceback (most recent call last):&#13;
<span class="hljs-con-meta">...</span>&#13;
TypeError: _memoize() got an unexpected keyword argument 'n'&#13;
</code></pre>&#13;
    <p class="normal">Additionally, the arguments need to be hashable to work with this implementation:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># Unhashable types don't work as dict keys:</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">fibonacci([</span><span class="hljs-con-number">123</span><span class="python">])</span>&#13;
Traceback (most recent call last):&#13;
<span class="hljs-con-meta">...</span>&#13;
TypeError: unhashable type: 'list'&#13;
</code></pre>&#13;
    <p class="normal">While examples with a small <code class="inlineCode">n</code> will work easily without memoization, for larger numbers it will run for an extremely long time. For <code class="inlineCode">n=2</code>, the function would execute <code class="inlineCode">fibonacci(n - 1)</code> and <code class="inlineCode">fibonacci(n - 2)</code> recursively, resulting in exponential time complexity. For <code class="inlineCode">n=30</code>, the Fibonacci function would already be called 2,692,537 times; at <code class="inlineCode">n=50</code>, it will stall or even crash your system.</p>&#13;
    <p class="normal">Without <a id="_idIndexMarker429"/>memoization, the call stack becomes a tree that very<a id="_idIndexMarker430"/> quickly grows. To illustrate, let’s assume we want to calculate <code class="inlineCode">fibonacci(4)</code>.</p>&#13;
    <p class="normal">First, <code class="inlineCode">fibonacci(4)</code> calls <code class="inlineCode">fibonacci(3)</code> and <code class="inlineCode">fibonacci(2)</code>. There’s nothing special here.</p>&#13;
    <p class="normal">Now, <code class="inlineCode">fibonacci(3)</code> calls <code class="inlineCode">fibonacci(2)</code> and <code class="inlineCode">fibonacci(1)</code>. You will notice that we got <code class="inlineCode">fibonacci(2)</code> for the second time now. <code class="inlineCode">fibonacci(4)</code> also executed it.</p>&#13;
    <p class="normal">That split with each call is exactly the problem. Each function call starts two new function calls, which means it doubles for every call. And those double again and again until we have reached the end of the calculation.</p>&#13;
    <p class="normal">Because the memoized version caches the results and only needs to calculate every number once, it doesn’t even break a sweat and only needs to execute <code class="inlineCode">31</code> times for <code class="inlineCode">n=30</code>.</p>&#13;
    <p class="normal">This decorator also shows how a context can be attached to a function itself. In this case, the cache property becomes an attribute of the internal (wrapped <code class="inlineCode">fibonacci</code>) function so that an extra <code class="inlineCode">memoize</code> decorator for a different object won’t clash with any of the other decorated functions.</p>&#13;
    <p class="normal">Note, however, that implementing the memoization function yourself is generally not that useful anymore since Python introduced <code class="inlineCode">lru_cache</code> (<strong class="keyWord">least recently used cache</strong>) in Python 3.2. The <code class="inlineCode">lru_cache</code> is similar to the preceding memoize decorator function but a bit more advanced. It maintains a fixed cache size (<code class="inlineCode">128</code> by default) to save memory, and stores statistics so you can check whether the cache size should be increased.</p>&#13;
    <p class="normal">If you are only looking for statistics and have no need for caching, you can also set the <code class="inlineCode">maxsize</code> to <code class="inlineCode">0</code>. Or if you want to forego the LRU algorithm and save everything, you can pass <code class="inlineCode">None</code> as <code class="inlineCode">maxsize</code>. With a fixed size, the <code class="inlineCode">lru_cache</code> will keep only the most recently accessed items and discard the oldest once it is full.</p>&#13;
    <p class="normal">In most cases, I would suggest using <code class="inlineCode">lru_cache</code> over your own decorator, but if you always need to store all items or if you need to process the keys before storing them, you can always roll your own. At the very least, it is useful to know how to write a decorator like this.</p>&#13;
    <p class="normal">To demonstrate<a id="_idIndexMarker431"/> how <code class="inlineCode">lru_cache</code> works internally, we will<a id="_idIndexMarker432"/> calculate <code class="inlineCode">fibonacci(100)</code>, which would keep our computer busy until the end of the universe without any caching. Moreover, to make sure that we can actually see how many times the <code class="inlineCode">fibonacci</code> function is being called, we’ll add an extra decorator that keeps track of the count, as follows:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> functools</span>&#13;
&#13;
<span class="hljs-con-comment"># Create a simple call counting decorator</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">counter</span><span class="hljs-con-function">(</span><span class="hljs-con-params">function</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    function.calls = </span><span class="hljs-con-number">0</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @functools.wraps(</span><span class="hljs-con-params">function</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">_counter</span><span class="hljs-con-function">(</span><span class="hljs-con-params">*args, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        function.calls += </span><span class="hljs-con-number">1</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> function(*args, **kwargs)</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> _counter</span>&#13;
&#13;
<span class="hljs-con-comment"># Create a LRU cache with size 3</span> &#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@functools.lru_cache(</span><span class="hljs-con-params">maxsize=</span><span class="hljs-con-number">3</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">@counter</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">fibonacci</span><span class="hljs-con-function">(</span><span class="hljs-con-params">n</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">if</span><span class="python"> n &lt; </span><span class="hljs-con-number">2</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> n</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">else</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> fibonacci(n - </span><span class="hljs-con-number">1</span><span class="python">) + fibonacci(n - </span><span class="hljs-con-number">2</span><span class="python">)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">fibonacci(</span><span class="hljs-con-number">100</span><span class="python">)</span>&#13;
354224848179261915075&#13;
&#13;
<span class="hljs-con-comment"># The LRU cache offers some useful statistics</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">fibonacci.cache_info()</span>&#13;
CacheInfo(hits=98, misses=101, maxsize=3, currsize=3)&#13;
&#13;
<span class="hljs-con-comment"># The result from our counter function which is now wrapped both by</span>&#13;
<span class="hljs-con-comment"># our counter and the cache</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">fibonacci.__wrapped__.__wrapped__.calls</span>&#13;
101&#13;
</code></pre>&#13;
    <p class="normal">You might wonder <a id="_idIndexMarker433"/>why we need only 101 calls with a cache size <a id="_idIndexMarker434"/>of <code class="inlineCode">3</code>. That’s because we recursively require only <code class="inlineCode">n - 1</code> and <code class="inlineCode">n - 2</code>, so we have no need for a larger cache in this case. If your cache is not performing as expected, the cache size might be the culprit.</p>&#13;
    <p class="normal">Additionally, this example shows the usage of two decorators for a single function. You can see these as the layers of an onion. When calling <code class="inlineCode">fibonacci</code>, the execution order is as follows:</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;">&#13;
      <li class="numberedList" value="1"><code class="inlineCode">functools.lru_cache</code></li>&#13;
      <li class="numberedList"><code class="inlineCode">counter</code></li>&#13;
      <li class="numberedList"><code class="inlineCode">fibonacci</code></li>&#13;
    </ol>&#13;
    <p class="normal">Returning the values works in the reverse order, of course; <code class="inlineCode">fibonacci</code> returns its value to <code class="inlineCode">counter</code>, which passes the value along to <code class="inlineCode">lru_cache</code>.</p>&#13;
    <h2 id="_idParaDest-159" class="heading-2">Decorators with (optional) arguments</h2>&#13;
    <p class="normal">The previous<a id="_idIndexMarker435"/> examples mostly used simple decorators without any arguments. As you have already seen with <code class="inlineCode">lru_cache</code>, decorators can accept arguments as well since they are just regular functions, but this adds an extra layer to a decorator. This means that we need to check the decorator arguments to see if they are the decorated method or a regular argument. The only caveat is that the optional argument should not be callable. If the argument has to be callable, you will need to pass it as a keyword argument instead.</p>&#13;
    <p class="normal">The upcoming code shows a decorator that has an optional (keyword) argument to the decorator:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> functools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">add</span><span class="hljs-con-function">(</span><span class="hljs-con-params">function=</span><span class="hljs-con-literal">None</span><span class="hljs-con-params">, add_n=</span><span class="hljs-con-number">0</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-comment"># function is not callable so it's probably 'add_n'</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">if</span><span class="python"> </span><span class="hljs-con-keyword">not</span><span class="python"> </span><span class="hljs-con-built_in">callable</span><span class="python">(function):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-comment"># Test to make sure we don't pass 'None' as 'add_n'</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">if</span><span class="python"> function </span><span class="hljs-con-keyword">is</span><span class="python"> </span><span class="hljs-con-keyword">not</span><span class="python"> </span><span class="hljs-con-literal">None</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            add_n = function</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> functools.partial(add, add_n=add_n)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @functools.wraps(</span><span class="hljs-con-params">function</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">_add</span><span class="hljs-con-function">(</span><span class="hljs-con-params">n</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> function(n) + add_n</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> _add</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@add</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">add_zero</span><span class="hljs-con-function">(</span><span class="hljs-con-params">n</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> n</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@add(</span><span class="hljs-con-number">1</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">add_one</span><span class="hljs-con-function">(</span><span class="hljs-con-params">n</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> n</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@add(</span><span class="hljs-con-params">add_n=</span><span class="hljs-con-number">2</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">add_two</span><span class="hljs-con-function">(</span><span class="hljs-con-params">n</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> n</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">add_zero(</span><span class="hljs-con-number">5</span><span class="python">)</span>&#13;
5&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">add_one(</span><span class="hljs-con-number">5</span><span class="python">)</span>&#13;
6&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">add_two(</span><span class="hljs-con-number">5</span><span class="python">)</span>&#13;
7&#13;
</code></pre>&#13;
    <p class="normal">This decorator <a id="_idIndexMarker436"/>uses the <code class="inlineCode">callable()</code> test to see whether the argument is a callable such as a function. This method works in many cases, but if for some reason your argument to the <code class="inlineCode">add()</code> decorator is callable, this will break because it will be called instead of the function.</p>&#13;
    <p class="normal">Whenever you have the choice available, I recommend that you either have a decorator with arguments or without them. Having optional arguments makes the flow of the function less obvious and slightly harder to debug when issues arise.</p>&#13;
    <h2 id="_idParaDest-160" class="heading-2">Creating decorators using classes</h2>&#13;
    <p class="normal">Similar to <a id="_idIndexMarker437"/>how we create regular function decorators, it is <a id="_idIndexMarker438"/>also possible to create decorators using classes instead. As is always the case with classes, this makes storing data, inheriting, and reuse more convenient than with functions. After all, a function is just a callable object and a class can implement the callable interface as well. The following decorator works similarly to the <code class="inlineCode">debug</code> decorator we used earlier, but uses a class instead of a regular function:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> functools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Debug</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">object</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, function</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.function = function</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-comment"># functools.wraps for classes</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        functools.update_wrapper(self, function)</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__call__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, *args, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        output = self.function(*args, **kwargs)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        name = self.function.__name__</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        print(</span><span class="hljs-con-string">f'</span><span class="hljs-con-subst">{name}</span><span class="hljs-con-string">(</span><span class="hljs-con-subst">{args!r}</span><span class="hljs-con-string">, </span><span class="hljs-con-subst">{kwargs!r}</span><span class="hljs-con-string">): </span><span class="hljs-con-subst">{output!r}</span><span class="hljs-con-string">'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> output</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@Debug</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">add</span><span class="hljs-con-function">(</span><span class="hljs-con-params">a, b=</span><span class="hljs-con-number">0</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> a + b</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">output = add(</span><span class="hljs-con-number">3</span><span class="python">)</span>&#13;
add((3,), {}): 3&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">output = add(a=</span><span class="hljs-con-number">4</span><span class="python">, b=</span><span class="hljs-con-number">2</span><span class="python">)</span>&#13;
add((), {'a': 4, 'b': 2}): 6&#13;
</code></pre>&#13;
    <p class="normal">The only notable difference between functions and classes is that <code class="inlineCode">functools.wraps</code> is now replaced with <code class="inlineCode">functools.update_wrapper</code> in the <code class="inlineCode">__init__</code> method.</p>&#13;
    <p class="normal">Since class methods have a <code class="inlineCode">self</code> argument in addition to the regular arguments, you might wonder whether decorators will function in that scenario. The next section will cover decorator usage within classes.</p>&#13;
    <h1 id="_idParaDest-161" class="heading-1">Decorating class functions</h1>&#13;
    <p class="normal">Decorating <a id="_idIndexMarker439"/>class functions is very similar to regular functions, but you need to be aware of the required first argument, <code class="inlineCode">self</code>—the class instance. You have most likely already used a few class function decorators. The <code class="inlineCode">classmethod</code>, <code class="inlineCode">staticmethod</code>, and <code class="inlineCode">property</code> decorators, for example, are used in many different projects. To explain how all this works, we will build our own versions of the <code class="inlineCode">classmethod</code>, <code class="inlineCode">staticmethod</code>, and <code class="inlineCode">property</code> decorators. First, let’s look at a simple decorator for class functions to demonstrate the difference from regular decorators:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> functools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">plus_one</span><span class="hljs-con-function">(</span><span class="hljs-con-params">function</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @functools.wraps(</span><span class="hljs-con-params">function</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">_plus_one</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, n, *args</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> function(self, n + </span><span class="hljs-con-number">1</span><span class="python">, *args)</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> _plus_one</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Adder</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">object</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @plus_one</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">add</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, a, b=</span><span class="hljs-con-number">0</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> a + b</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">adder = Adder()</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">adder.add(</span><span class="hljs-con-number">0</span><span class="python">)</span>&#13;
1&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">adder.add(</span><span class="hljs-con-number">3</span><span class="python">, </span><span class="hljs-con-number">4</span><span class="python">)</span>&#13;
8&#13;
</code></pre>&#13;
    <p class="normal">As is the case with regular functions, the class function decorator now gets passed along <code class="inlineCode">self</code> as the instance. Nothing unexpected!</p>&#13;
    <h2 id="_idParaDest-162" class="heading-2">Skipping the instance – classmethod and staticmethod</h2>&#13;
    <p class="normal">The difference<a id="_idIndexMarker440"/> between a <code class="inlineCode">classmethod</code> and a <code class="inlineCode">staticmethod</code> is fairly simple. The <code class="inlineCode">classmethod</code> passes a class object<a id="_idIndexMarker441"/> instead of a class instance (<code class="inlineCode">self</code>), and <code class="inlineCode">staticmethod</code> skips both the class and the instance entirely. This effectively makes <code class="inlineCode">staticmethod</code> very similar to a regular function outside of a class.</p>&#13;
    <div class="note">&#13;
      <p class="normal">In the following examples, we will use <code class="inlineCode">pprint.pprint(... width=60)</code> to account for the width of the book. Additionally, <code class="inlineCode">locals()</code> is a Python built-in that shows all local variables. Similarly, a <code class="inlineCode">globals()</code> function is also available.</p>&#13;
    </div>&#13;
    <p class="normal">Before we recreate <code class="inlineCode">classmethod</code> and <code class="inlineCode">staticmethod</code>, we need to take a look at the expected behavior of these methods:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> pprint</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Spam</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">object</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">some_instancemethod</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, *args, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        pprint.pprint(</span><span class="hljs-con-built_in">locals</span><span class="python">(), width=</span><span class="hljs-con-number">60</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @classmethod</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">some_classmethod</span><span class="hljs-con-function">(</span><span class="hljs-con-params">cls, *args, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        pprint.pprint(</span><span class="hljs-con-built_in">locals</span><span class="python">(), width=</span><span class="hljs-con-number">60</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @staticmethod</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">some_staticmethod</span><span class="hljs-con-function">(</span><span class="hljs-con-params">*args, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        pprint.pprint(</span><span class="hljs-con-built_in">locals</span><span class="python">(), width=</span><span class="hljs-con-number">60</span><span class="python">)</span>&#13;
&#13;
<span class="hljs-con-comment"># Create an instance so we can compare the difference between</span>&#13;
<span class="hljs-con-comment"># executions with and without instances easily</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">spam = Spam()</span>&#13;
</code></pre>&#13;
    <p class="normal">The following <a id="_idIndexMarker442"/>examples will use the example above to illustrate the difference between a <a id="_idIndexMarker443"/>regular (class instance) method, a <code class="inlineCode">classmethod</code>, and a <code class="inlineCode">staticmethod</code>. Be wary of the difference between <code class="inlineCode">spam</code> (lowercase) the instance and <code class="inlineCode">Spam</code> (capitalized) the class:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># With an instance (note the lowercase spam)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">spam.some_instancemethod(</span><span class="hljs-con-number">1</span><span class="python">, </span><span class="hljs-con-number">2</span><span class="python">, a=</span><span class="hljs-con-number">3</span><span class="python">, b=</span><span class="hljs-con-number">4</span><span class="python">)</span>&#13;
{'args': (1, 2),&#13;
 'kwargs': {'a': 3, 'b': 4},&#13;
 'self': &lt;__main__.Spam object at ...&gt;}&#13;
&#13;
<span class="hljs-con-comment"># Without an instance (note the capitalized Spam)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">Spam.some_instancemethod()</span>&#13;
Traceback (most recent call last):&#13;
    ...&#13;
TypeError: some_instancemethod() missing ... argument: 'self'&#13;
&#13;
<span class="hljs-con-comment"># But what if we add parameters? Be very careful with these!</span>&#13;
<span class="hljs-con-comment"># Our first argument is now used as an argument, this can give</span>&#13;
<span class="hljs-con-comment"># very strange and unexpected errors</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">Spam.some_instancemethod(</span><span class="hljs-con-number">1</span><span class="python">, </span><span class="hljs-con-number">2</span><span class="python">, a=</span><span class="hljs-con-number">3</span><span class="python">, b=</span><span class="hljs-con-number">4</span><span class="python">)</span>&#13;
{'args': (2,), 'kwargs': {'a': 3, 'b': 4}, 'self': 1}&#13;
</code></pre>&#13;
    <p class="normal">In particular, the last example is rather tricky. Because we passed some arguments to the function, these<a id="_idIndexMarker444"/> have automatically been passed as the <code class="inlineCode">self</code> argument. Similarly, the <a id="_idIndexMarker445"/>last example shows how you can use this argument handling to call a method using a given instance. <code class="inlineCode">Spam.some_instancemethod(spam)</code> is identical to <code class="inlineCode">spam.some_instancemethod()</code>.</p>&#13;
    <p class="normal">Now let’s look at the <code class="inlineCode">classmethod</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># Classmethods are expectedly identical</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">spam.some_classmethod(</span><span class="hljs-con-number">1</span><span class="python">, </span><span class="hljs-con-number">2</span><span class="python">, a=</span><span class="hljs-con-number">3</span><span class="python">, b=</span><span class="hljs-con-number">4</span><span class="python">)</span>&#13;
{'args': (1, 2),&#13;
 'cls': &lt;class '__main__.Spam'&gt;,&#13;
 'kwargs': {'a': 3, 'b': 4}}&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">Spam.some_classmethod()</span>&#13;
{'args': (), 'cls': &lt;class '__main__.Spam'&gt;, 'kwargs': {}}&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">Spam.some_classmethod(</span><span class="hljs-con-number">1</span><span class="python">, </span><span class="hljs-con-number">2</span><span class="python">, a=</span><span class="hljs-con-number">3</span><span class="python">, b=</span><span class="hljs-con-number">4</span><span class="python">)</span>&#13;
{'args': (1, 2),&#13;
 'cls': &lt;class '__main__.Spam'&gt;,&#13;
 'kwargs': {'a': 3, 'b': 4}}&#13;
</code></pre>&#13;
    <p class="normal">The main difference here is that instead of <code class="inlineCode">self</code> we now have <code class="inlineCode">cls</code>, which contains the class (<code class="inlineCode">Spam</code>) instead of the instance (<code class="inlineCode">spam</code>).</p>&#13;
    <div class="note">&#13;
      <p class="normal">The names <code class="inlineCode">self</code> and <code class="inlineCode">cls</code> are conventions and are not enforced in any way. You could easily call them <code class="inlineCode">s</code> and <code class="inlineCode">c</code> or something completely different instead.</p>&#13;
    </div>&#13;
    <p class="normal">Next up is the <code class="inlineCode">staticmethod</code>. The <code class="inlineCode">staticmethod</code> behaves identically to a regular function outside of a class.</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># Staticmethods are also identical</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">spam.some_staticmethod(</span><span class="hljs-con-number">1</span><span class="python">, </span><span class="hljs-con-number">2</span><span class="python">, a=</span><span class="hljs-con-number">3</span><span class="python">, b=</span><span class="hljs-con-number">4</span><span class="python">)</span>&#13;
{'args': (1, 2), 'kwargs': {'a': 3, 'b': 4}}&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">Spam.some_staticmethod()</span>&#13;
{'args': (), 'kwargs': {}}&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">Spam.some_staticmethod(</span><span class="hljs-con-number">1</span><span class="python">, </span><span class="hljs-con-number">2</span><span class="python">, a=</span><span class="hljs-con-number">3</span><span class="python">, b=</span><span class="hljs-con-number">4</span><span class="python">)</span>&#13;
{'args': (1, 2), 'kwargs': {'a': 3, 'b': 4}}&#13;
</code></pre>&#13;
    <p class="normal">Before we can continue with decorators, you need to be aware of how Python descriptors function. Descriptors can <a id="_idIndexMarker446"/>be used to modify the binding behavior of object attributes. This means that if a descriptor is used as the value of an attribute, you can modify which value is being set, got, and deleted when these operations are called on the attribute. Here is a basic example of this behavior:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Spam</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, spam=</span><span class="hljs-con-number">1</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.spam = spam</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__get__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, instance, cls</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> self.spam + instance.eggs</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__set__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, instance, value</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        instance.eggs = value - self.spam</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Sandwich</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    spam = Spam(</span><span class="hljs-con-number">5</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, eggs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.eggs = eggs</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sandwich = Sandwich(</span><span class="hljs-con-number">1</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sandwich.eggs</span>&#13;
1&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sandwich.spam</span>&#13;
6&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sandwich.eggs = </span><span class="hljs-con-number">10</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sandwich.spam</span>&#13;
15&#13;
</code></pre>&#13;
    <p class="normal">As you can see, whenever we set or get values from <code class="inlineCode">sandwich.spam</code>, it actually calls <code class="inlineCode">__get__</code> or <code class="inlineCode">__set__</code> on <code class="inlineCode">Spam</code>, which has access not only to its own variables, but also the calling class. A very useful feature for automatic conversions and type checking, the <code class="inlineCode">property</code> decorator we will see in the next section is just a more convenient implementation of this technique.</p>&#13;
    <p class="normal">Now that you know how <a id="_idIndexMarker447"/>descriptors work, we can <a id="_idIndexMarker448"/>continue with <a id="_idIndexMarker449"/>creating the <code class="inlineCode">classmethod</code> and <code class="inlineCode">staticmethod</code> decorators. For these two, we simply need to modify <code class="inlineCode">__get__</code> instead of <code class="inlineCode">__call__</code> so that we can control which type of instance (or none at all) is passed along:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> functools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">ClassMethod</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">object</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, method</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.method = method</span>&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__get__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, instance, cls</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">        @functools.wraps(</span><span class="hljs-con-params">self.method</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">method</span><span class="hljs-con-function">(</span><span class="hljs-con-params">*args, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-keyword">return</span><span class="python"> self.method(cls, *args, **kwargs)</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> method</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">StaticMethod</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">object</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, method</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.method = method</span>&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__get__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, instance, cls</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> self.method</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Sandwich</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    spam = </span><span class="hljs-con-string">'class'</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, spam</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.spam = spam</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @ClassMethod</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">some_classmethod</span><span class="hljs-con-function">(</span><span class="hljs-con-params">cls, arg</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> cls.spam, arg</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @StaticMethod</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">some_staticmethod</span><span class="hljs-con-function">(</span><span class="hljs-con-params">arg</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> Sandwich.spam, arg</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sandwich = Sandwich(</span><span class="hljs-con-string">'instance'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sandwich.spam</span>&#13;
'instance'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sandwich.some_classmethod(</span><span class="hljs-con-string">'argument'</span><span class="python">)</span>&#13;
('class', 'argument')&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sandwich.some_staticmethod(</span><span class="hljs-con-string">'argument'</span><span class="python">)</span>&#13;
('class', 'argument')&#13;
</code></pre>&#13;
    <p class="normal">The <code class="inlineCode">ClassMethod</code> decorator still <a id="_idIndexMarker450"/>features a sub-function to actually produce a working <a id="_idIndexMarker451"/>decorator. Looking at the function, you can most likely guess how it functions. Instead of passing <code class="inlineCode">instance</code> as the first argument to <code class="inlineCode">self.method</code>, it passes <code class="inlineCode">cls</code>.</p>&#13;
    <p class="normal"><code class="inlineCode">StaticMethod</code> is even simpler, because it completely ignores both the <code class="inlineCode">instance</code> and the <code class="inlineCode">cls</code>. It can just return the original method unmodified. Because it returns the original method without any modifications, we have no need for the <code class="inlineCode">functools.wraps</code> call either.</p>&#13;
    <h2 id="_idParaDest-163" class="heading-2">Properties – Smart descriptor usage</h2>&#13;
    <p class="normal">The <code class="inlineCode">property</code> decorator<a id="_idIndexMarker452"/> is probably the most used decorator in Python land. It allows you to add getters/setters to existing instance properties so that you can add validators and modify your values before setting them to your instance properties. </p>&#13;
    <p class="normal">The <code class="inlineCode">property</code> decorator can be used both as an assignment and as a decorator. The following example shows both syntaxes so that you know what to expect from the <code class="inlineCode">property</code> decorator.</p>&#13;
    <p class="normal">Python 3.8 added <code class="inlineCode">functools.cached_property</code>, which<a id="_idIndexMarker453"/> functions the same as <code class="inlineCode">property</code> but executes only once per instance.</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> functools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Sandwich</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">object</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">get_eggs</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        print(</span><span class="hljs-con-string">'getting eggs'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> self._eggs</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">set_eggs</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, eggs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        print(</span><span class="hljs-con-string">'setting eggs to %s'</span><span class="python"> % eggs)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self._eggs = eggs</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">delete_eggs</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        print(</span><span class="hljs-con-string">'deleting eggs'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">del</span><span class="python"> self._eggs</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    eggs = </span><span class="hljs-con-built_in">property</span><span class="python">(get_eggs, set_eggs, delete_eggs)</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @property</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">spam</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        print(</span><span class="hljs-con-string">'getting spam'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> self._spam</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @spam.setter</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">spam</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, spam</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        print(</span><span class="hljs-con-string">'setting spam to %s'</span><span class="python"> % spam)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self._spam = spam</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @spam.deleter</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">spam</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        print(</span><span class="hljs-con-string">'deleting spam'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">del</span><span class="python"> self._spam</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @functools.cached_property</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">bacon</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        print(</span><span class="hljs-con-string">'getting bacon'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> </span><span class="hljs-con-string">'bacon!'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sandwich = Sandwich()</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sandwich.eggs = </span><span class="hljs-con-number">123</span>&#13;
setting eggs to 123&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sandwich.eggs</span>&#13;
getting eggs&#13;
123&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">del</span><span class="python"> sandwich.eggs</span>&#13;
deleting eggs&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sandwich.bacon</span>&#13;
getting bacon&#13;
'bacon!' &#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sandwich.bacon</span>&#13;
'bacon!'&#13;
</code></pre>&#13;
    <p class="normal">Similar to how we<a id="_idIndexMarker454"/> implemented the <code class="inlineCode">classmethod</code> and <code class="inlineCode">staticmethod</code> decorators, we need the Python descriptors again. This time, we require the full power of the descriptors, not just <code class="inlineCode">__get__</code> but <code class="inlineCode">__set__</code> and <code class="inlineCode">__delete__</code> as well. For brevity, however, we will skip handling the documentation and some error handling:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Property</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">object</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, fget=</span><span class="hljs-con-literal">None</span><span class="hljs-con-params">, fset=</span><span class="hljs-con-literal">None</span><span class="hljs-con-params">, fdel=</span><span class="hljs-con-literal">None</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.fget = fget</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.fset = fset</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.fdel = fdel</span>&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__get__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, instance, cls</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">if</span><span class="python"> instance </span><span class="hljs-con-keyword">is</span><span class="python"> </span><span class="hljs-con-literal">None</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-comment"># Redirect class (not instance) properties to self</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-keyword">return</span><span class="python"> self</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">elif</span><span class="python"> self.fget:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-keyword">return</span><span class="python"> self.fget(instance)</span>&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__set__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, instance, value</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.fset(instance, value)</span>&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__delete__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, instance</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.fdel(instance)</span>&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">getter</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, fget</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> Property(fget, self.fset, self.fdel)</span>&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">setter</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, fset</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> Property(self.fget, fset, self.fdel)</span>&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">deleter</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, fdel</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> Property(self.fget, self.fset, fdel)</span>&#13;
</code></pre>&#13;
    <p class="normal">That doesn’t <a id="_idIndexMarker455"/>look all that complicated, does it? The descriptors make up most of the code, which is fairly straight to the point. Only the <code class="inlineCode">getter</code>/<code class="inlineCode">setter</code>/<code class="inlineCode">deleter</code> functions might look a bit strange, but they’re actually fairly straightforward as well. </p>&#13;
    <p class="normal">To make sure the <code class="inlineCode">property</code> still works as expected, the class returns a new <code class="inlineCode">Property</code> instance while copying the other methods. The only small caveat to make this work here is the <code class="inlineCode">return self</code> in the <code class="inlineCode">__get__</code> method.</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Sandwich</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @Property</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">eggs</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> self._eggs</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @eggs.setter</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">eggs</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, value</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self._eggs = value</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @eggs.deleter</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">eggs</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">del</span><span class="python"> self._eggs</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sandwich = Sandwich()</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sandwich.eggs = </span><span class="hljs-con-number">5</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sandwich.eggs</span>&#13;
5&#13;
</code></pre>&#13;
    <p class="normal">As expected, our <code class="inlineCode">Property</code> decorator works as it should. But note that this is a more limited version of the built-in <code class="inlineCode">property</code> decorator; our version has no checking for edge cases.</p>&#13;
    <p class="normal">Naturally, being <a id="_idIndexMarker456"/>Python, there are more methods of achieving the effect of properties. In the previous examples, you saw the bare descriptor implementation, and in our previous example, you saw the <code class="inlineCode">property</code> decorator. Now we will look at a generic solution by implementing <code class="inlineCode">__getattr__</code> or <code class="inlineCode">__getattribute__</code>. Here’s a simple demonstration:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Sandwich</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">object</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.registry = {}</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__getattr__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, key</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        print(</span><span class="hljs-con-string">'Getting %r'</span><span class="python"> % key)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> self.registry.get(key, </span><span class="hljs-con-string">'Undefined'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__setattr__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, key, value</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">if</span><span class="python"> key == </span><span class="hljs-con-string">'registry'</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-built_in">object</span><span class="python">.__setattr__(self, key, value)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">else</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            print(</span><span class="hljs-con-string">'Setting %r to %r'</span><span class="python"> % (key, value))</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            self.registry[key] = value</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__delattr__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, key</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        print(</span><span class="hljs-con-string">'Deleting %r'</span><span class="python"> % key)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">del</span><span class="python"> self.registry[key]</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sandwich = Sandwich()</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sandwich.a</span>&#13;
Getting 'a'&#13;
'Undefined'&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sandwich.a = </span><span class="hljs-con-number">1</span>&#13;
Setting 'a' to 1&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sandwich.a</span>&#13;
Getting 'a'&#13;
1&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">del</span><span class="python"> sandwich.a</span>&#13;
Deleting 'a'&#13;
</code></pre>&#13;
    <p class="normal">The <code class="inlineCode">__getattr__</code> method looks for existing attributes, for example, it checks whether the key exists in <code class="inlineCode">instance.__dict__</code>, and is called only if it does not exist. That’s why we never see a <code class="inlineCode">__getattr__</code> for the registry attribute. The <code class="inlineCode">__getattribute__</code> method is called in all cases, which makes it a bit more dangerous to use. With the <code class="inlineCode">__getattribute__</code> method, you will need a specific exclusion for <code class="inlineCode">registry</code> since it will be executed infinitely through recursion if you try to access <code class="inlineCode">self.registry</code>.</p>&#13;
    <p class="normal">There is rarely a <a id="_idIndexMarker457"/>need to look at descriptors, but they are used by several internal Python processes, such as the <code class="inlineCode">super()</code> method when inheriting classes.</p>&#13;
    <p class="normal">Now that you know how to create decorators for regular functions and class methods, let’s continue by decorating entire classes.</p>&#13;
    <h1 id="_idParaDest-164" class="heading-1">Decorating classes</h1>&#13;
    <p class="normal">Python 2.6 introduced the class decorator syntax. As is the case with the function decorator syntax, this is not really a new technique either. Even without the syntax, a class can be decorated simply by executing <code class="inlineCode">DecoratedClass = decorator(RegularClass)</code>. After the previous sections, you should be familiar with writing decorators. Class decorators <a id="_idIndexMarker458"/>are no different from regular ones, except for the fact that they take a class instead of a function. As is the case with functions, this happens at declaration time and <em class="italic">not</em> at instantiating/calling time.</p>&#13;
    <p class="normal">Because there are quite a few alternative ways to modify how classes work, such as standard inheritance, mixins, and metaclasses (read more in <em class="chapterRef">Chapter 8</em>, <em class="italic">Metaclasses – Making Classes (Not Instances) Smarter</em>), class decorators are never strictly needed. This does not reduce their usefulness, but it does offer an explanation of why you will most likely not see too many examples of class decorating in the wild.</p>&#13;
    <h2 id="_idParaDest-165" class="heading-2">Singletons – Classes with a single instance</h2>&#13;
    <p class="normal">Singletons are <a id="_idIndexMarker459"/>classes that always allow only a single instance to exist. So, instead of getting an instance specifically for your call, you always get the same one. This can be very useful for things such as a database connection pool, where you don’t want to keep opening connections all of the time but want to reuse the original ones:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> functools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">singleton</span><span class="hljs-con-function">(</span><span class="hljs-con-params">cls</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    instances = </span><span class="hljs-con-built_in">dict</span><span class="python">()</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @functools.wraps(</span><span class="hljs-con-params">cls</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">_singleton</span><span class="hljs-con-function">(</span><span class="hljs-con-params">*args, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">if</span><span class="python"> cls </span><span class="hljs-con-keyword">not</span><span class="python"> </span><span class="hljs-con-keyword">in</span><span class="python"> instances:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            instances[cls] = cls(*args, **kwargs)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> instances[cls]</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> _singleton</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@singleton</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">SomeSingleton</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">object</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        print(</span><span class="hljs-con-string">'Executing init'</span><span class="python">)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">a = SomeSingleton()</span>&#13;
Executing init&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">b = SomeSingleton()</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">a </span><span class="hljs-con-keyword">is</span><span class="python"> b</span>&#13;
&#13;
True&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">a.x = </span><span class="hljs-con-number">123</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">b.x</span>&#13;
123&#13;
</code></pre>&#13;
    <p class="normal">As you can see in the <code class="inlineCode">a is b</code> comparison, both objects have the same identity, so we can conclude that they are indeed the same object. As is the case with regular decorators, due to the <code class="inlineCode">functools.wraps</code> functionality, we can still access the original class through <code class="inlineCode">Spam.__wrapped__</code> if needed.</p>&#13;
    <div class="note">&#13;
      <p class="normal">The <code class="inlineCode">is</code> operator compares objects by identity, which is implemented as the memory address in CPython. If <code class="inlineCode">a is b</code> returns <code class="inlineCode">True</code>, we can conclude that both <code class="inlineCode">a</code> and <code class="inlineCode">b</code> are the same instance.</p>&#13;
    </div>&#13;
    <h2 id="_idParaDest-166" class="heading-2">Total ordering – Making classes sortable</h2>&#13;
    <p class="normal">At some point or the other, you have probably needed to sort data structures. While this is easily achievable using the key parameter of the <code class="inlineCode">sorted</code> function, there is a more convenient way if you need to do this often—by implementing the <code class="inlineCode">__gt__</code>, <code class="inlineCode">__ge__</code>, <code class="inlineCode">__lt__</code>, <code class="inlineCode">__le__</code>, and <code class="inlineCode">__eq__</code> functions. That seems a bit verbose, doesn’t it? If you want the best performance, it’s still a good idea, but if you can take a tiny performance hit and some slightly more complicated stack traces, then <code class="inlineCode">total_ordering</code> might be a nice alternative. </p>&#13;
    <p class="normal">The <code class="inlineCode">total_ordering</code> class decorator<a id="_idIndexMarker460"/> can implement all required sort functions based on a class that possesses an <code class="inlineCode">__eq__</code> function and one of the comparison functions (<code class="inlineCode">__lt__</code>, <code class="inlineCode">__le__</code>, <code class="inlineCode">__gt__</code>, or <code class="inlineCode">__ge__</code>). This means you can seriously shorten your function definitions. Let’s compare the regular function definition and the function definition using the <code class="inlineCode">total_ordering</code> decorator:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> functools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Value</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">object</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, value</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.value = value</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">                                                              </span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__repr__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> </span><span class="hljs-con-string">f'&lt;</span><span class="hljs-con-subst">{self.__class__.__name__}</span><span class="hljs-con-string"> </span><span class="hljs-con-subst">{self.value}</span><span class="hljs-con-string">&gt;'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Spam</span><span class="hljs-con-class">(</span><span class="hljs-con-params">Value</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__gt__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, other</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> self.value &gt; other.value</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">                                                               </span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__ge__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, other</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> self.value &gt;= other.value</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">                                                               </span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__lt__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, other</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> self.value &lt; other.value</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">                                                               </span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__le__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, other</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> self.value &lt;= other.value</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">                                                               </span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__eq__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, other</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> self.value == other.value</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@functools.total_ordering</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Egg</span><span class="hljs-con-class">(</span><span class="hljs-con-params">Value</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__lt__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, other</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> self.value &lt; other.value</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">                                                                 </span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__eq__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, other</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> self.value == other.value</span>&#13;
</code></pre>&#13;
    <p class="normal">As you can see, without <code class="inlineCode">functools.total_ordering</code>, it’s quite a bit of work to create a fully sortable class. Now we <a id="_idIndexMarker461"/>will test whether they actually sort in a similar way:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">numbers = [</span><span class="hljs-con-number">4</span><span class="python">, </span><span class="hljs-con-number">2</span><span class="python">, </span><span class="hljs-con-number">3</span><span class="python">, </span><span class="hljs-con-number">4</span><span class="python">]</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">spams = [Spam(n) </span><span class="hljs-con-keyword">for</span><span class="python"> n </span><span class="hljs-con-keyword">in</span><span class="python"> numbers]</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">eggs = [Egg(n) </span><span class="hljs-con-keyword">for</span><span class="python"> n </span><span class="hljs-con-keyword">in</span><span class="python"> numbers]</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">spams</span>&#13;
[&lt;Spam 4&gt;, &lt;Spam 2&gt;, &lt;Spam 3&gt;, &lt;Spam 4&gt;]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">eggs</span>&#13;
[&lt;Egg 4&gt;, &lt;Egg 2&gt;, &lt;Egg 3&gt;, &lt;Egg 4&gt;]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">sorted</span><span class="python">(spams)</span>&#13;
[&lt;Spam 2&gt;, &lt;Spam 3&gt;, &lt;Spam 4&gt;, &lt;Spam 4&gt;]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">sorted</span><span class="python">(eggs)</span>&#13;
[&lt;Egg 2&gt;, &lt;Egg 3&gt;, &lt;Egg 4&gt;, &lt;Egg 4&gt;]&#13;
&#13;
<span class="hljs-con-comment"># Sorting using key is of course still possible and in this case</span>&#13;
<span class="hljs-con-comment"># perhaps just as easy:</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">values = [Value(n) </span><span class="hljs-con-keyword">for</span><span class="python"> n </span><span class="hljs-con-keyword">in</span><span class="python"> numbers]</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">values</span>&#13;
[&lt;Value 4&gt;, &lt;Value 2&gt;, &lt;Value 3&gt;, &lt;Value 4&gt;]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">sorted</span><span class="python">(values, key=</span><span class="hljs-con-keyword">lambda</span><span class="python"> v: v.value)</span>&#13;
[&lt;Value 2&gt;, &lt;Value 3&gt;, &lt;Value 4&gt;, &lt;Value 4&gt;]&#13;
</code></pre>&#13;
    <p class="normal">Now, you might be wondering, “Why isn’t there a class decorator to make a class sortable using a specified key property?” Well, that might indeed be a good idea for the <code class="inlineCode">functools</code> library<a id="_idIndexMarker462"/>, but it isn’t there yet. So, let’s see how we would implement something like it while still using <code class="inlineCode">functools.total_ordering</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">sort_by_attribute</span><span class="hljs-con-function">(</span><span class="hljs-con-params">attr, keyfunc=</span><span class="hljs-con-built_in">getattr</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">_sort_by_attribute</span><span class="hljs-con-function">(</span><span class="hljs-con-params">cls</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__lt__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, other</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-keyword">return</span><span class="python"> </span><span class="hljs-con-built_in">getattr</span><span class="python">(self, attr) &lt; </span><span class="hljs-con-built_in">getattr</span><span class="python">(other, attr)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">                                          </span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__eq__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, other</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-keyword">return</span><span class="python"> </span><span class="hljs-con-built_in">getattr</span><span class="python">(self, attr) &lt;= </span><span class="hljs-con-built_in">getattr</span><span class="python">(other, attr)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">                                          </span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        cls.__lt__ = __lt__               </span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        cls.__eq__ = __eq__               </span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">                                </span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> functools.total_ordering(cls)</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> _sort_by_attribute</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Value</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">object</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, value</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.value = value</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__repr__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> </span><span class="hljs-con-string">f'&lt;</span><span class="hljs-con-subst">{self.__class__.__name__}</span><span class="hljs-con-string"> </span><span class="hljs-con-subst">{self.value}</span><span class="hljs-con-string">&gt;'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@sort_by_attribute(</span><span class="hljs-con-string">'value'</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Spam</span><span class="hljs-con-class">(</span><span class="hljs-con-params">Value</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">pass</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">numbers = [</span><span class="hljs-con-number">4</span><span class="python">, </span><span class="hljs-con-number">2</span><span class="python">, </span><span class="hljs-con-number">3</span><span class="python">, </span><span class="hljs-con-number">4</span><span class="python">]</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">spams = [Spam(n) </span><span class="hljs-con-keyword">for</span><span class="python"> n </span><span class="hljs-con-keyword">in</span><span class="python"> numbers]</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">sorted</span><span class="python">(spams)</span>&#13;
[&lt;Spam 2&gt;, &lt;Spam 3&gt;, &lt;Spam 4&gt;, &lt;Spam 4&gt;]&#13;
</code></pre>&#13;
    <p class="normal">Certainly, this greatly simplifies the making of a sortable class. And if you would rather have your own key function instead of <code class="inlineCode">getattr</code>, it’s even easier. Simply replace the <code class="inlineCode">getattr(self, attr)</code> call with <code class="inlineCode">key_function(self)</code>, do that for <code class="inlineCode">other</code> as well, and change the argument for the decorator to your function. You can even use that as the base function and implement <code class="inlineCode">sort_by_attribute</code> by simply passing a wrapped <code class="inlineCode">getattr</code> function.</p>&#13;
    <p class="normal">Now that you know how to create all types of decorators, let’s look at a few useful decorator examples bundled with Python.</p>&#13;
    <h1 id="_idParaDest-167" class="heading-1">Useful decorators</h1>&#13;
    <p class="normal">In addition to the ones already mentioned in this chapter, Python comes bundled with a few other useful decorators. There are some that aren’t in the standard library (yet?).</p>&#13;
    <h2 id="_idParaDest-168" class="heading-2">Single dispatch – Polymorphism in Python</h2>&#13;
    <p class="normal">If you’ve used<a id="_idIndexMarker463"/> C++ or Java before, you’re probably used to having ad hoc polymorphism available—different functions being called depending on the argument types. Python being a dynamically typed language, most people would not expect the possibility of a single dispatch pattern. Python, however, is a language that is not only dynamically typed but also strongly typed, which means we can rely on the type we receive.</p>&#13;
    <div class="note">&#13;
      <p class="normal">A dynamically typed language does not require strict type definitions. While a language such as C would require the following to declare an integer:</p>&#13;
      <pre class="programlisting code"><code class="hljs-code"><code class="inlineCode">int some_integer = 123;</code>&#13;
</code></pre>&#13;
      <p class="normal">Python simply accepts that our value has a type:</p>&#13;
      <pre class="programlisting code"><code class="hljs-code"><code class="inlineCode">some_integer = 123</code>&#13;
</code></pre>&#13;
      <p class="normal">Although with type hinting we could also do:</p>&#13;
      <pre class="programlisting code"><code class="hljs-code"><code class="inlineCode">some_integer: int = 123</code>&#13;
</code></pre>&#13;
      <p class="normal">As opposed to languages such as JavaScript and PHP, however, Python does very little implicit type conversion. In Python, the following will return an error, whereas JavaScript would execute it without any problems:</p>&#13;
      <pre class="programlisting code"><code class="hljs-code"><code class="inlineCode">'spam' + 5</code>&#13;
</code></pre>&#13;
      <p class="normal">In Python, the result is a <code class="inlineCode">TypeError</code>. In JavaScript, it’s <code class="inlineCode">'spam5'</code>.</p>&#13;
    </div>&#13;
    <p class="normal">The idea of single dispatch<a id="_idIndexMarker464"/> is that depending on the type you pass, the correct function is called. Since <code class="inlineCode">str + int</code> results in an error in Python, this can be very convenient to automatically convert your arguments before passing them to your function. This can be useful for separating the actual workings of your function from the type conversions.</p>&#13;
    <p class="normal">Since Python 3.4, there is a decorator that makes it easily possible to implement the single dispatch pattern in Python. This decorator is useful if you need to execute different functions depending on the <code class="inlineCode">type()</code> of your input variable. Here is a basic example:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> functools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@functools.singledispatch</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">show_type</span><span class="hljs-con-function">(</span><span class="hljs-con-params">argument</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">f'argument: </span><span class="hljs-con-subst">{argument}</span><span class="hljs-con-string">'</span><span class="python">)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@show_type.register(</span><span class="hljs-con-built_in">int</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">show_int</span><span class="hljs-con-function">(</span><span class="hljs-con-params">argument</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">f'int argument: </span><span class="hljs-con-subst">{argument}</span><span class="hljs-con-string">'</span><span class="python">)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@show_type.register</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">show_float</span><span class="hljs-con-function">(</span><span class="hljs-con-params">argument: </span><span class="hljs-con-built_in">float</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">f'float argument: </span><span class="hljs-con-subst">{argument}</span><span class="hljs-con-string">'</span><span class="python">)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">show_type(</span><span class="hljs-con-string">'abc'</span><span class="python">)</span>&#13;
argument: abc&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">show_type(</span><span class="hljs-con-number">123</span><span class="python">)</span>&#13;
int argument: 123&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">show_type(</span><span class="hljs-con-number">1.23</span><span class="python">)</span>&#13;
float argument: 1.23&#13;
</code></pre>&#13;
    <p class="normal">The <code class="inlineCode">singledispatch</code> decorator automatically<a id="_idIndexMarker465"/> calls the correct function for the type passed as the first argument. As you can see in the example, this works both when using type annotations and if explicit types are passed to the <code class="inlineCode">register</code> function.</p>&#13;
    <p class="normal">Let’s see how we could make a simplified version of this method ourselves:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> functools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">registry = </span><span class="hljs-con-built_in">dict</span><span class="python">()</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">register</span><span class="hljs-con-function">(</span><span class="hljs-con-params">function</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-comment"># Fetch the first type from the type annotation but be</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-comment"># careful not to overwrite the 'type' function</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    type_ = </span><span class="hljs-con-built_in">next</span><span class="python">(</span><span class="hljs-con-built_in">iter</span><span class="python">(function.__annotations__.values()))</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    registry[type_] = function</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @functools.wraps(</span><span class="hljs-con-params">function</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">_register</span><span class="hljs-con-function">(</span><span class="hljs-con-params">argument</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-comment"># Fetch the function using the type of argument, and</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-comment"># fall back to the main function</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        new_function = registry.get(</span><span class="hljs-con-built_in">type</span><span class="python">(argument), function)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> new_function(argument)</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> _register</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@register</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">show_type</span><span class="hljs-con-function">(</span><span class="hljs-con-params">argument: </span><span class="hljs-con-built_in">any</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">f'argument: </span><span class="hljs-con-subst">{argument}</span><span class="hljs-con-string">'</span><span class="python">)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@register</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">show_int</span><span class="hljs-con-function">(</span><span class="hljs-con-params">argument: </span><span class="hljs-con-built_in">int</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">f'int argument: </span><span class="hljs-con-subst">{argument}</span><span class="hljs-con-string">'</span><span class="python">)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">show_type(</span><span class="hljs-con-string">'abc'</span><span class="python">)</span>&#13;
argument: abc&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">show_type(</span><span class="hljs-con-number">123</span><span class="python">)</span>&#13;
int argument: 123&#13;
</code></pre>&#13;
    <p class="normal">Naturally, this method is a bit<a id="_idIndexMarker466"/> basic and it uses a single global registry, which limits its application. But this exact pattern can be used for registering plugins or callbacks.</p>&#13;
    <div class="note">&#13;
      <p class="normal">When naming the functions, make sure that you do not overwrite the original <code class="inlineCode">singledispatch</code> function. If you named <code class="inlineCode">show_int</code> as just <code class="inlineCode">show_type</code>, it would overwrite the initial <code class="inlineCode">show_type</code> function. This would make it impossible to access the original <code class="inlineCode">show_type</code> function and make all <code class="inlineCode">register</code> operations after that fail as well.</p>&#13;
    </div>&#13;
    <p class="normal">Now, a slightly more useful example—differentiating between a filename and a file handler:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> json</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> functools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@functools.singledispatch</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">write_as_json</span><span class="hljs-con-function">(</span><span class="hljs-con-params">file, data</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    json.dump(data, file)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@write_as_json.register(</span><span class="hljs-con-built_in">str</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">@write_as_json.register(</span><span class="hljs-con-built_in">bytes</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">write_as_json_filename</span><span class="hljs-con-function">(</span><span class="hljs-con-params">file, data</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">with</span><span class="python"> </span><span class="hljs-con-built_in">open</span><span class="python">(file, </span><span class="hljs-con-string">'w'</span><span class="python">) </span><span class="hljs-con-keyword">as</span><span class="python"> fh:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        write_as_json(fh, data)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">data = </span><span class="hljs-con-built_in">dict</span><span class="python">(a=</span><span class="hljs-con-number">1</span><span class="python">, b=</span><span class="hljs-con-number">2</span><span class="python">, c=</span><span class="hljs-con-number">3</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">write_as_json(</span><span class="hljs-con-string">'test1.json'</span><span class="python">, data)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">write_as_json(</span><span class="hljs-con-string">b'test2.json'</span><span class="python">, </span><span class="hljs-con-string">'w'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">with</span><span class="python"> </span><span class="hljs-con-built_in">open</span><span class="python">(</span><span class="hljs-con-string">'test3.json'</span><span class="python">, </span><span class="hljs-con-string">'w'</span><span class="python">) </span><span class="hljs-con-keyword">as</span><span class="python"> fh:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    write_as_json(fh, data)</span>&#13;
</code></pre>&#13;
    <p class="normal">So now we have a single <code class="inlineCode">write_as_json</code> function; it calls the right code depending on the type. If it’s a <code class="inlineCode">str</code> or <code class="inlineCode">bytes</code> object, it will automatically open the file and call the regular version of <code class="inlineCode">write_as_json</code>, which accepts file objects.</p>&#13;
    <p class="normal">Writing a decorator that does this is not that hard to do, of course, but it’s still quite convenient to have the <code class="inlineCode">singledispatch</code> decorator in the base library. It most certainly beats manually checking the given argument types with a list of <code class="inlineCode">isinstance()</code> <code class="inlineCode">if</code>/<code class="inlineCode">elif</code>/<code class="inlineCode">elif</code>/<code class="inlineCode">else</code> statements. </p>&#13;
    <p class="normal">To see which function will be <a id="_idIndexMarker467"/>called, you can use the <code class="inlineCode">write_as_json.dispatch</code> function with a specific type. When passing along a <code class="inlineCode">str</code>, you will get the <code class="inlineCode">write_as_json_filename</code> function. It should be noted that the names of the dispatched functions are completely arbitrary. They are accessible as regular functions, of course, but you can name them anything you like.</p>&#13;
    <p class="normal">To check the registered types, you can access the registry, which is a dictionary, through <code class="inlineCode">write_as_json.registry</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">write_as_json.registry.keys()</span>&#13;
dict_keys([&lt;class 'bytes'&gt;, &lt;class 'object'&gt;, &lt;class 'str'&gt;])&#13;
</code></pre>&#13;
    <h2 id="_idParaDest-169" class="heading-2">contextmanager — with statements made easy</h2>&#13;
    <p class="normal">Using the <code class="inlineCode">contextmanager</code> class, we can <a id="_idIndexMarker468"/>make the creation of a context wrapper very easy. Context wrappers are used whenever you use a <code class="inlineCode">with</code> statement. One example is the <code class="inlineCode">open</code> function, which works as a context wrapper as well, allowing you to use the following code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> fh:&#13;
    <span class="hljs-keyword">pass</span>&#13;
</code></pre>&#13;
    <p class="normal">Let’s just assume for now that the <code class="inlineCode">open</code> function is not usable as a context manager and that we need to build our own function to do this. The standard method of creating a context manager is by creating a class that implements the <code class="inlineCode">__enter__</code> and <code class="inlineCode">__exit__</code> methods:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Open</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, filename, mode</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.filename = filename</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.mode = mode</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__enter__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.handle = </span><span class="hljs-con-built_in">open</span><span class="python">(self.filename, self.mode)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> self.handle</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__exit__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, exc_type, exc_val, exc_tb</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.handle.close()</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">with</span><span class="python"> Open(</span><span class="hljs-con-string">'test.txt'</span><span class="python">, </span><span class="hljs-con-string">'w'</span><span class="python">) </span><span class="hljs-con-keyword">as</span><span class="python"> fh:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">'Our test is complete!'</span><span class="python">, file=fh)</span>&#13;
</code></pre>&#13;
    <p class="normal">While that works perfectly, it’s a tad verbose. With <code class="inlineCode">contextlib.contextmanager</code>, we can have the same behavior in just a few lines:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> contextlib</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@contextlib.contextmanager</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">open_context_manager</span><span class="hljs-con-function">(</span><span class="hljs-con-params">filename, mode=</span><span class="hljs-con-string">'r'</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    fh = </span><span class="hljs-con-built_in">open</span><span class="python">(filename, mode)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">yield</span><span class="python"> fh</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    fh.close()</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">with</span><span class="python"> open_context_manager(</span><span class="hljs-con-string">'test.txt'</span><span class="python">, </span><span class="hljs-con-string">'w'</span><span class="python">) </span><span class="hljs-con-keyword">as</span><span class="python"> fh:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">'Our test is complete!'</span><span class="python">, file=fh)</span>&#13;
</code></pre>&#13;
    <p class="normal">Simple, right? However, I <a id="_idIndexMarker469"/>should mention that for this specific case—the closing of objects—there is a dedicated function in <code class="inlineCode">contextlib</code>, and it is even easier to use.</p>&#13;
    <div class="note">&#13;
      <p class="normal">With <code class="inlineCode">file</code> objects, database connections, and connections, it is important to always have a <code class="inlineCode">close()</code> call to clean up resources. In the case of a <code class="inlineCode">file</code>, it tells the operating system to write the data to disk (as opposed to temporary buffers), and in the case of network connections and database connections, it releases the network connection and related resources on both ends. With database connections, it will also notify the server that the connection is no longer needed so that part is also handled gracefully.</p>&#13;
      <p class="normal">Without these calls, you can quickly run into “too many open files” or “too many connections” errors.</p>&#13;
    </div>&#13;
    <p class="normal">Let’s demonstrate it with the most basic example of when <code class="inlineCode">closing()</code> would be useful:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> contextlib</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">with</span><span class="python"> contextlib.closing(</span><span class="hljs-con-built_in">open</span><span class="python">(</span><span class="hljs-con-string">'test.txt'</span><span class="python">, </span><span class="hljs-con-string">'a'</span><span class="python">)) </span><span class="hljs-con-keyword">as</span><span class="python"> fh:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">'Yet another test'</span><span class="python">, file=fh)</span>&#13;
</code></pre>&#13;
    <p class="normal">For a <code class="inlineCode">file</code> object, you <a id="_idIndexMarker470"/>can usually also use <code class="inlineCode">with open(...)</code> because it is a context manager by itself, but if some other part of the code handles the opening, you don’t always have that luxury, and in those cases, you will need to close it yourself. Additionally, some objects such as requests made by <code class="inlineCode">urllib</code> don’t support automatic closing in that manner and benefit from this function.</p>&#13;
    <p class="normal">But wait; there’s more! In addition to being usable in a <code class="inlineCode">with</code> statement, the results of a <code class="inlineCode">contextmanager</code> are actually usable as decorators since Python 3.2. In older Python versions, the <code class="inlineCode">contextmanager</code> was simply a small wrapper, but since Python 3.2 it’s based on the <code class="inlineCode">ContextDecorator</code> class, which makes it a decorator. </p>&#13;
    <p class="normal">The <code class="inlineCode">open_context_manager</code> context manager isn’t really suitable as a decorator since it has a <code class="inlineCode">yield &lt;value&gt;</code> as opposed to an empty <code class="inlineCode">yield</code> (more about that in <em class="chapterRef">Chapter 7</em>, <em class="italic">Generators and Coroutines – Infinity, One Step at a Time</em>), but we can think of other functions:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@contextlib.contextmanager</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">debug</span><span class="hljs-con-function">(</span><span class="hljs-con-params">name</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">f'Debugging </span><span class="hljs-con-subst">{name}</span><span class="hljs-con-string">:'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">yield</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">f'Finished debugging </span><span class="hljs-con-subst">{name}</span><span class="hljs-con-string">'</span><span class="python">)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@debug(</span><span class="hljs-con-string">'spam'</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">spam</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">'This is the inside of our spam function'</span><span class="python">)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">spam()</span>&#13;
Debugging spam:&#13;
This is the inside of our spam function&#13;
Finished debugging spam&#13;
</code></pre>&#13;
    <p class="normal">There are quite a few nice use cases for this, but at the very least, it’s just a convenient way to wrap a function in a context without all the (nested) <code class="inlineCode">with</code> statements.</p>&#13;
    <h2 id="_idParaDest-170" class="heading-2">Validation, type checks, and conversions</h2>&#13;
    <p class="normal">While checking for<a id="_idIndexMarker471"/> types is usually not the best way to go in Python, at times it can be useful if you know that you will need a specific type (or something that can be cast to that type). To facilitate this, Python 3.5 introduced a type hinting system<a id="_idIndexMarker472"/> so that you can do the following:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">sandwich</span><span class="hljs-con-function">(</span><span class="hljs-con-params">bacon: </span><span class="hljs-con-built_in">float</span><span class="hljs-con-params">, eggs: </span><span class="hljs-con-built_in">int</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">pass</span>&#13;
</code></pre>&#13;
    <p class="normal">In some cases, it can be useful to <a id="_idIndexMarker473"/>change these hints into requirements. Instead of using an <code class="inlineCode">isinstance()</code>, we will simply try to enforce the types by casting, which is more along the lines of duck-typing.</p>&#13;
    <p class="normal">The essence of duck-typing is: if it looks like a duck, walks like a duck, and quacks like a duck, it might be a duck. Essentially, this means that we don’t care if the value is a <code class="inlineCode">duck</code> or something else, only if it supports the <code class="inlineCode">quack()</code> method that we need.</p>&#13;
    <p class="normal">To enforce the type hints, we can create a decorator:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> inspect</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> functools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">enforce_type_hints</span><span class="hljs-con-function">(</span><span class="hljs-con-params">function</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-comment"># Construct the signature from the function which contains</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-comment"># the type annotations</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    signature = inspect.signature(function)</span>&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @functools.wraps(</span><span class="hljs-con-params">function</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">_enforce_type_hints</span><span class="hljs-con-function">(</span><span class="hljs-con-params">*args, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-comment"># Bind the arguments and apply the default values</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        bound = signature.bind(*args, **kwargs)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        bound.apply_defaults()</span>&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">for</span><span class="python"> key, value </span><span class="hljs-con-keyword">in</span><span class="python"> bound.arguments.items():</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            param = signature.parameters[key]</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-comment"># The annotation should be a callable</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-comment"># type/function so we can cast as validation</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-keyword">if</span><span class="python"> param.annotation:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">                bound.arguments[key] = param.annotation(value)</span>&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> function(*bound.args, **bound.kwargs)</span>&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> _enforce_type_hints</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@enforce_type_hints</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">sandwich</span><span class="hljs-con-function">(</span><span class="hljs-con-params">bacon: </span><span class="hljs-con-built_in">float</span><span class="hljs-con-params">, eggs: </span><span class="hljs-con-built_in">int</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">f'bacon: </span><span class="hljs-con-subst">{bacon!r}</span><span class="hljs-con-string">, eggs: </span><span class="hljs-con-subst">{eggs!r}</span><span class="hljs-con-string">'</span><span class="python">)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sandwich(</span><span class="hljs-con-number">1</span><span class="python">, </span><span class="hljs-con-number">2</span><span class="python">)</span>&#13;
bacon: 1.0, eggs: 2&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sandwich(</span><span class="hljs-con-number">3</span><span class="python">, </span><span class="hljs-con-string">'abc'</span><span class="python">)</span>&#13;
Traceback (most recent call last):&#13;
<span class="hljs-con-meta">...</span>&#13;
ValueError: invalid literal for int() with base 10: 'abc'&#13;
</code></pre>&#13;
    <p class="normal">This is a fairly simple yet very versatile type enforcer that should work with most type annotations.</p>&#13;
    <h2 id="_idParaDest-171" class="heading-2">Useless warnings – How to ignore them safely</h2>&#13;
    <p class="normal">When writing in Python, warnings<a id="_idIndexMarker474"/> are often very useful when you’re actually writing the code. When executing it, however, it is not useful to get that same message every time you run your script/application. So, let’s create some code that allows easy hiding of the expected warnings, but not all of them so that we can easily catch new ones:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> warnings</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> functools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">ignore_warning</span><span class="hljs-con-function">(</span><span class="hljs-con-params">warning, count=</span><span class="hljs-con-literal">None</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">_ignore_warning</span><span class="hljs-con-function">(</span><span class="hljs-con-params">function</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">        @functools.wraps(</span><span class="hljs-con-params">function</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__ignore_warning</span><span class="hljs-con-function">(</span><span class="hljs-con-params">*args, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-comment"># Execute the code while catching all warnings</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-keyword">with</span><span class="python"> warnings.catch_warnings(record=</span><span class="hljs-con-literal">True</span><span class="python">) </span><span class="hljs-con-keyword">as</span><span class="python"> ws:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">                </span><span class="hljs-con-comment"># Catch all warnings of the given type</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">                warnings.simplefilter(</span><span class="hljs-con-string">'always'</span><span class="python">, warning)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">                </span><span class="hljs-con-comment"># Execute the function</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">                result = function(*args, **kwargs)</span>&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-comment"># Re-warn all warnings beyond the expected count</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-keyword">if</span><span class="python"> count </span><span class="hljs-con-keyword">is</span><span class="python"> </span><span class="hljs-con-keyword">not</span><span class="python"> </span><span class="hljs-con-literal">None</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">                </span><span class="hljs-con-keyword">for</span><span class="python"> w </span><span class="hljs-con-keyword">in</span><span class="python"> ws[count:]:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">                    warnings.warn(w.message)</span>&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-keyword">return</span><span class="python"> result</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> __ignore_warning</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> _ignore_warning</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@ignore_warning(</span><span class="hljs-con-params">DeprecationWarning, count=</span><span class="hljs-con-number">1</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">spam</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    warnings.warn(</span><span class="hljs-con-string">'deprecation 1'</span><span class="python">, DeprecationWarning)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    warnings.warn(</span><span class="hljs-con-string">'deprecation 2'</span><span class="python">, DeprecationWarning)</span>&#13;
&#13;
<span class="hljs-con-comment"># Note, we use catch_warnings here because doctests normally</span>&#13;
<span class="hljs-con-comment"># capture the warnings quietly</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">with</span><span class="python"> warnings.catch_warnings(record=</span><span class="hljs-con-literal">True</span><span class="python">) </span><span class="hljs-con-keyword">as</span><span class="python"> ws:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    spam()</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">for</span><span class="python"> i, w </span><span class="hljs-con-keyword">in</span><span class="python"> </span><span class="hljs-con-built_in">enumerate</span><span class="python">(ws):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        print(w.message)</span>&#13;
deprecation 2&#13;
</code></pre>&#13;
    <p class="normal">Using this method, we can catch the first (expected) warning and still see the second (unexpected) warning.</p>&#13;
    <p class="normal">Now that you have seen some examples of useful decorators, it is time to continue with a few exercises and see how much you can write yourself.</p>&#13;
    <h1 id="_idParaDest-172" class="heading-1">Exercises</h1>&#13;
    <p class="normal">Decorators have a huge range of uses, so you can probably think of some yourself after reading this chapter, but you can easily elaborate on some of the decorators we wrote earlier:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Extend the <code class="inlineCode">track</code> function to monitor execution time.</li>&#13;
      <li class="bulletList">Extend the <code class="inlineCode">track</code> function with min/max/average execution time and call count.</li>&#13;
      <li class="bulletList">Modify the memoization function to function with unhashable types.</li>&#13;
      <li class="bulletList">Modify the memoization function to have a cache per function instead of a global one.</li>&#13;
      <li class="bulletList">Create a version of <code class="inlineCode">functools.cached_property</code> that can be recalculated as needed.</li>&#13;
      <li class="bulletList">Create a single-dispatch decorator that considers all or a configurable number of arguments instead of only the first one.</li>&#13;
      <li class="bulletList">Enhance the <code class="inlineCode">type_check</code> decorator to include additional checks such as requiring a number to be greater than or less than a given value.</li>&#13;
    </ul>&#13;
    <div class="note">&#13;
      <p class="normal">Example answers for these exercises can be found on GitHub: <a href="Chapter_6.xhtml"><span class="url">https://github.com/mastering-python/exercises</span></a>. You are encouraged to submit your own solutions and learn about alternative solutions from others.</p>&#13;
    </div>&#13;
    <h1 id="_idParaDest-173" class="heading-1">Summary</h1>&#13;
    <p class="normal">This chapter showed you some of the places where decorators can be used to make our code simpler and add some fairly complex behavior to very simple functions. Truthfully, most decorators are more complex than the regular function would have been by simply adding the functionality directly, but the added advantage of applying the same pattern to many functions and classes is generally well worth it.</p>&#13;
    <p class="normal">Decorators have so many uses to make your functions and classes smarter and more convenient to use:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Debugging</li>&#13;
      <li class="bulletList">Validation</li>&#13;
      <li class="bulletList">Argument convenience (pre-filling or converting arguments)</li>&#13;
      <li class="bulletList">Output convenience (converting the output to a specific type)</li>&#13;
    </ul>&#13;
    <p class="normal">The most important takeaway of this chapter should be to never forget <code class="inlineCode">functools.wraps</code> when wrapping a function. Debugging decorated functions can be rather difficult because of (unexpected) behavior modification, but losing attributes as well can make that problem much worse.</p>&#13;
    <p class="normal">The next chapter will show you how and when to use <code class="inlineCode">generators</code> and <code class="inlineCode">coroutines</code>. This chapter has already shown you the usage of the <code class="inlineCode">with</code> statement briefly, but <code class="inlineCode">generators</code> and <code class="inlineCode">coroutines</code> go much further with this. We will still be using decorators often, both in this book and when using Python in general, so make sure you have a good understanding of how they work.</p>&#13;
    <h1 class="heading-1">Join our community on Discord</h1>&#13;
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://discord.gg/QMzJenHuJf"><span class="url">https://discord.gg/QMzJenHuJf</span></a></p>&#13;
    <p class="normal"><img src="Images/QR_Code156081100001293319171.png" alt="" width="177" height="177"/></p>&#13;
  </div>&#13;
</div></body></html>