- en: '*Chapter 5:* Sequence – The Basic Building Block of a Computer Program'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to programming, the most fundamental concept is the sequence.
    It indicates what we do and when we do it, one after another. However, when we
    take a closer look, we find that there is more to this, and, in this chapter,
    we will learn what it is.
  prefs: []
  type: TYPE_NORMAL
- en: We will also use the concept of a sequence to decide what steps a program will
    need to perform to accomplish its overall task. Since it can be tough to have
    both an overview of everything that needs to be done and, at the same time, look
    at all the details, we will require a concept that can assist us. Thinking of
    the sequence in which the program needs to do things in, for instance, could be
    such a tool.
  prefs: []
  type: TYPE_NORMAL
- en: When learning how to program, one problem many people face is how to transform
    an idea to go. Where should you start? In this chapter, we will learn that we
    can use the concept of sequential thinking to break down an idea into smaller
    tasks that we then can deal with. We will also see that we can apply the same
    concept to the code that we write to ensure that we do things in the right order.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the importance of sequences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What a statement is and how it is defined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How different statements are separated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to format the code to make it more readable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different kinds of comments and ways to document our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One day, when you come home, you start craving a pie, so you decide to make
    one. The reason you will bake a pie is not that you wish to cook, but to satisfy
    your desire for pie. However, to be able to get the pie, you need to perform several
    steps. First, you need a recipe, and then you need to get all of the ingredients.
    When you acquire them, you will follow each step in the recipe. Then, finally,
    after the pie has been in the oven and cooled down a bit, you can enjoy your well-deserved
    treat.
  prefs: []
  type: TYPE_NORMAL
- en: You just performed a few tasks in sequence. Some of them need to be completed
    in the right order, while others can be done in any order (or, at least, in a
    more relaxed order). You must turn on the oven before you can bake the pie, but
    it is not essential that you bring out the flour before the butter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Programming is like baking a pie. We will have goals, such as we want pie,
    and to be able to achieve that goal, we will need to do several things: in some
    instances, the order is essential, while others are less dependent on the order.'
  prefs: []
  type: TYPE_NORMAL
- en: Programming is all about problem-solving and the art of breaking things down
    into smaller steps. This will be done in iterations where you first have an overall
    solution and then break this solution down into smaller and smaller steps until
    you are on a level where you understand each step that needs to be taken.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the more difficult skills to master when you begin to learn programming.
    As with all new skills, it takes lots of practice before you will feel comfortable
    doing this. Some tricks can make it easier for you to acquire this skill. The
    essential ability you require is an overview of the full problem that you are
    trying to solve and, at the same time, a focus on details of one or more subproblems
    that need to be resolved. This means that you will need to zoom in and out on
    the details while keeping an overall view of the whole problem. You can practice
    this without doing any programming. Playing logical puzzle games such as Sudoku
    will train your brain to keep an eye on the overall game and, at the same time,
    focus on individual parts of the game such as what numbers can go into a certain
    cell.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at how we can go from a problem to a solution on a sequential
    level. First, we need to define the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You often arrive home after dark, and you always forget to turn on the outdoor
    lighting before you leave home. It is so dark that you are afraid of stumbling
    on your way to the door, and finding the keyhole is always a gamble.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, you don't want the light to be on all day. You don't like
    the idea of those automatic lights that react to motion either, as it will be
    activated when the neighbor's cat passes by. There must be a better solution.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to the problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One solution would be if you could use your smartphone's GPS. If you had a program
    running on it that continually monitors your position, then when you come into
    a given radius from your home, it could somehow activate the lights. You soon
    realize that your solution will need to be a two-part application. One part runs
    on your phone, and the other part runs on a computer in your home. The program
    running on a computer in your house would get a signal from your mobile app that
    you now are close to home. It could then check with an online service to see what
    time the sun sets at your home's location during this time of year. If it is past
    sunset, the program can activate the lights.
  prefs: []
  type: TYPE_NORMAL
- en: What we have done so far is to start to define a solution. Now we must break
    down this solution further.
  prefs: []
  type: TYPE_NORMAL
- en: Solution breakdown
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now have an overview of what we want, and, at the same time, we have zoomed
    in on a couple of details. We have decided that we would like to use the phone's
    GPS. We don't know how this can be done yet, but that is not important at this
    stage. We know that other applications can use GPS. This means that we know it
    is possible to do it and even if we, at the moment, have no idea how this is done,
    we can learn it later on in the process. We have also decided that this will be
    a two-part application. The part on the phone will, aside from monitoring the
    GPS, also need a way to contact the other part of our solution, which is the application
    running on a computer in your home. Again, we don't know how this will be done,
    but we know it can be done, and that is good enough for now. We also understand
    that we need a way to detect that we are coming from outside the defined range
    and then entering it. It is only then that the lights should be turned on. If
    we don't do this, the lights would always be on when the phone is within a stipulated
    range and we don't want that.
  prefs: []
  type: TYPE_NORMAL
- en: The home application will need to wait for a signal from the mobile app and
    then contact a service that can tell us about the time the sun will set. On our
    to-do list, we add that we need to find such a service. Again, we don't need to
    bother about how this can be done. We will also find a way for our home application
    to control the lights. We will most likely require some hardware for this step,
    but that will be a problem that we can deal with later.
  prefs: []
  type: TYPE_NORMAL
- en: What we now have is a sequential list of steps that we need to take. That list
    looks something like this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of steps for the mobile application:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the phone within the predefined range?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If yes, was it previously outside the range, that is, have we just entered
    this range? Let us check:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.1: The phone enters the predefined region](img/B15554_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: The phone enters the predefined region'
  prefs: []
  type: TYPE_NORMAL
- en: 'If yes, send a signal to the home application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.2: The phone application contacts the application running on the
    home computer](img/B15554_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: The phone application contacts the application running on the home
    computer'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of steps for the home application:'
  prefs: []
  type: TYPE_NORMAL
- en: Wait for a signal from the mobile app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When a signal is received, check the current time:![Figure 5.3: The application
    that is running on the home computer checks the local time](img/B15554_05_03.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 5.3: The application that is running on the home computer checks the
    local time'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Check the online service for the local sunset time:![Figure 5.4: The application
    that is running on the home computer contacts'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: an online service to get the local sunset time](img/B15554_05_04.jpg)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.4: The application that is running on the home computer contacts an
    online service to get the local sunset time'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the time is after sunset, turn on lights:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.5: If the time is after sunset, the home application turns on the
    light](img/B15554_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: If the time is after sunset, the home application turns on the
    light'
  prefs: []
  type: TYPE_NORMAL
- en: This is still a slightly rough breakdown of the sequential steps that we need
    to take. But now that we have them, we can zoom in on each of them and think about
    the things we need to do for each of the preceding steps.
  prefs: []
  type: TYPE_NORMAL
- en: A detailed breakdown for the phone application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's take each of the steps, one by one, and closely examine what we need to
    do for each of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how can we know whether the phone is within the predefined range? To understand
    this, we must first do some research. The first thing we need to understand is
    how the phone GPS knows where it is. Searching online will soon reveal that a
    GPS works with two coordinates: longitude and latitude. These two coordinates
    will pinpoint any location on the earth. This means that when we request the current
    location from the GPS, we will be given these coordinates.'
  prefs: []
  type: TYPE_NORMAL
- en: When we have these coordinates, we need to check how far away we are from home.
    To do this, we will need to know where home is, so the application on the phone
    needs to store this location somehow, and it will also be in the form of a longitude
    and a latitude.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the distance between two geocoordinates is not a trivial task, but
    we don't need to worry as this is something that has been done many times before.
    In addition to this, no matter what language we are using, a simple Google search
    will give us many solutions for how this can be done. We might even be able to
    use the language package manager (refer to the *Package managers* section in [*Chapter
    4*](B15554_04_Final_NM_ePub.xhtml#_idTextAnchor067), *Software Projects and How
    We Organize Our Code*, to learn what a packet manager is and how it works) to
    find a package that can do this calculation.
  prefs: []
  type: TYPE_NORMAL
- en: No matter what solution we use, we can assume that we will use the two coordinate
    pairs that we have, the phone's location, and our home location, and what we get
    back is a distance between them. We also need to decide how close to home we need
    to be for the lights to activate. This can be any distance.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have to check whether we have come from outside the predefined range.
    We need a way to tell whether we have entered the predefined range or whether
    we already were within the range. We could do this by keeping track of what the
    distance to home was before we check the current position. If we were outside
    the range and are now inside it, then we know that we are close enough to home
    to send the signal to turn on the lights.
  prefs: []
  type: TYPE_NORMAL
- en: So, now we need to send a signal to the home application. When we have entered
    the range, we need a way for the phone application to contact the home computer.
    This can be done in several ways, and there is no need for us to decide what technique
    to use at this point.
  prefs: []
  type: TYPE_NORMAL
- en: We can now summarize the sequence for the phone application.
  prefs: []
  type: TYPE_NORMAL
- en: Phone application sequence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we have the logic for the phone application in place. We also know what
    the sequence will need to look like. It will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the current position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the distance from home.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is the distance within the range that defines when we are close enough to turn
    on the lights?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Was our previous distance, that is, the distance of the last time we checked
    our position, outside the given range?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the answer to the questions in *step 3* and *step 4* are both yes, tell the
    home computer to turn on the light. If it is no, we can go back to *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the distance from home as our old distance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start over from *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These steps are illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6: Sequence for the phone application](img/B15554_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: Sequence for the phone application'
  prefs: []
  type: TYPE_NORMAL
- en: These seven steps will be repeated over and over. We will need to consider what
    will happen when we perform the first iteration as we will not have a value for
    the old distance. We can give this an initial default value that is well outside
    the range, for example, a negative number.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a well-defined sequence of steps, and we have not written a line
    of code yet. This is good because it will help us when we start to write the code
    as we can zoom in and focus on each of these steps without losing track of the
    overview.
  prefs: []
  type: TYPE_NORMAL
- en: We can now turn our attention to the home application.
  prefs: []
  type: TYPE_NORMAL
- en: A detailed breakdown of the home application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At first, the home application will have absolutely nothing to do as it will
    just sit and wait for a signal from the phone app. However, when it gets that
    signal, it will wake up and start to do its work.
  prefs: []
  type: TYPE_NORMAL
- en: When the home application gets the message from the phone, the first thing it
    needs to do is one of two things. Either it can check the local time, or it can
    contact the sunset service to get the current sunset time. The order of these
    two operations is not essential as we need both, so we can compare them.
  prefs: []
  type: TYPE_NORMAL
- en: When we have the local time and the sunset time, we need to compare them to
    see whether it is after dark. If it is, all the conditions for turning on the
    light are met, and we get a signal that the phone is within range and that it
    is dark outside.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to turn on the outside light. We still need to figure out how this
    can be done. One way to do this is to use LED lamps that can be controlled wirelessly.
    These can often be interacted with from an application such as the one we are
    about to create. We should do some research before buying the lights since we
    need to select a brand that can be controlled by our application.
  prefs: []
  type: TYPE_NORMAL
- en: Home application sequence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The sequence for the home application is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Wait for a signal from the phone app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the signal is received, get the local time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Contact the sunset service to get the local sunset time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compare the current time with the sunset time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is after sunset, turn on the light.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Step 2 and step 3 can be performed in any order. If the current time is before
    the sunset time, the application will skip turning on the light and go back to
    step 1\. The sequence is depicted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7: Sequence for the home application](img/B15554_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: Sequence for the home application'
  prefs: []
  type: TYPE_NORMAL
- en: We now have an excellent starting point regarding how to build this application.
    Even if several things are still unclear to us, such as how the phone application
    shall contact the home application, what service the home application will use
    to check the sunset time and how it will get in touch with it, and how the home
    application will turn on the light, the sequence that the different things must
    be performed in, is now clear to us.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have a good idea of what our application needs to do, but
    we still have a number of things we need to do. First of all, we need to learn
    the necessary things to create this application. How can we get the position from
    the phone GPS? When learning things like this, it is usually a good idea to create
    a *toy project* where you can just try to get the coordinates and print them to
    the screen. When you have figured that out, you can then take this solution into
    your real project. Doing it in a separate project is smart because you can focus
    on learning one particular thing at a time. Another example is that we need to
    implement a way to calculate the distance between two geocoordinates. Apply the
    same principle of doing it in a separate application when testing different solutions.
    When you get a result, you should find an online service that does this calculation
    so that you can verify your results. In programming, you never stop learning new
    things and technologies. There are always things you have never done before. But
    don't let that stop you.
  prefs: []
  type: TYPE_NORMAL
- en: This is one aspect of sequencing in a computer program. Another point is what
    happens on a smaller level. In the code that we write, every step we perform needs
    to be broken down into something known as a *statement*, and those statements
    will be performed in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many programming languages, the sequence of code that we write is made up
    of what are called statements. A statement expresses some action to be carried
    out and is made up of several internal components. These are called expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Statements are made up of expressions, and expressions are made up of even
    smaller parts. Let''s refer to an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is an expression made up of three parts. Here, we are operating using the
    addition operator, `+`. On both sides of the operator, we have the operands in
    the form of two constant values, `5` and `4`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A statement can be made up of more than one expression. Take a look at the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have the same expression as we had earlier, `5 + 4`, but now with
    a new expression to the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8: A statement with two expressions, one addition and one assignment](img/B15554_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.8: A statement with two expressions, one addition and one assignment'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we have two operands, the result of the addition, `9`, to the right,
    and to the left, we have something called a *variable*, named `result`. A variable
    is a way for us to store data in memory using a name we define:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9: When the result of the addition is calculated the assignment
    expression can be performed](img/B15554_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.9: When the result of the addition is calculated the assignment expression
    can be performed'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will talk more about variables in [*Chapter 6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091),
    *Working with Data – Variables*. We also introduced a second operator, `=`. This
    operator is called the assignment operator. It takes what is on the right and
    stores it in what is on the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10: The variable called result can be visualized as a box;'
  prefs: []
  type: TYPE_NORMAL
- en: the assignment stores a value in that box](img/B15554_05_11.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.10: The variable called result can be visualized as a box; the assignment
    stores a value in that box'
  prefs: []
  type: TYPE_NORMAL
- en: To be able to complete this statement, the expressions must be dealt with in
    the correct order. This is called the order of operations.
  prefs: []
  type: TYPE_NORMAL
- en: Order of operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To store the result of the addition in the variable called `result`, we must
    first perform the expression to the right; that is the addition, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When the expression to the right is completed, we can imagine that our statement
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, this final expression can be executed. The value of `9` is assigned (it
    is stored) in the `result` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'A statement can be made up of more expressions. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we must understand here is the order of operations, that is,
    in which order the addition and the multiplication is performed. If we do the
    addition first, we will do `5` `+` `4`, which is 9, and then 9 times `2`, which
    is 18\.
  prefs: []
  type: TYPE_NORMAL
- en: If we instead do the multiplication first, we would get `4` times `2`, which
    is 8, and then `5 +` 8, which is 13\. So, the order is important. Every programming
    language has a well-defined order of operations, which is in what different order
    the operations must be performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the order will be the same as in mathematics; multiplication
    will be performed before addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to override the built-in order of operations, we can use parentheses
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now the addition is performed first because it is within parentheses, so the
    variable result will now store the value of 18 (9 times 2).
  prefs: []
  type: TYPE_NORMAL
- en: Some statements are made up of more than one single line. These are often called
    compound statements. Let's explore what those are next.
  prefs: []
  type: TYPE_NORMAL
- en: Compound statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A compound statement is a statement that spans several lines. These compound
    statements are made up of one or more *normal* one-line statements. They can also
    consist of other compound statements, as we will learn later on. For example,
    in our application that turns on the light, we have some conditions that must
    be met before we do something. One condition is that we only turn on the light
    if the current time is after sunset. The logic can be visualized in a flowchart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11\. Flowchart for the home application](img/B15554_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11\. Flowchart for the home application
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the part where we turn on the light is only executed if it is
    after sunset. So, for that statement to be performed, we have a condition that
    must be met. That condition is a statement, but that statement includes the statement
    that turns on the light.
  prefs: []
  type: TYPE_NORMAL
- en: 'In code, it can look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first line of the preceding code contains one single statement. It is a
    function call. We will discuss functions in more detail in [*Chapter 8*](B15554_08_Final_NM_ePub.xhtml#_idTextAnchor116),
    *Understanding Functions*. We can see that it is a function because it ends with
    parentheses. For now, we can regard these parentheses as an indication that something
    is a function. Calling a function means that, somewhere, there are several lines
    of code that have been given a name. Calling the function means that we will jump
    to that location and execute those lines. In this example, the content of the
    function is not visible. This function will halt the program until a signal comes
    in from the phone.
  prefs: []
  type: TYPE_NORMAL
- en: The statement on the second line is made up of one operation, with one operator
    and two operands. We recognize the equals sign as the assignment operator. That
    means that whatever is to the right will be assigned (remember that we can see
    an assignment because the thing to the right will be stored in the item to the
    left) to what's on the left-hand side. To the left, we have a variable that can
    contain a value. It has the name `current_time`. What we have to the right is
    another function call. This function will grab the current time and return it.
    When this statement has been executed, the present time will be stored in the
    `current_time` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Line 3 is like line 2\. This statement is also made up of one operator and two
    operands. The operand on the right is again a function call. This is the function
    that will contact the sunset service online and return the sunset time for our
    location. To the left, we have a `sunset_time` variable and we assign the time
    we get back from the function to this variable. When this statement has been executed,
    we have the sunset time stored in the `sunset_time` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 4 starts with an `if`. This is a special kind of statement, spanning over
    several lines. This one covers lines 4 to 6\. It contains another statement, the
    one on line 5\. Line 4 is a condition. It checks whether the value in the `current_time`
    variable is greater than the value in the `sunset_time` variable. This can either
    be true or false. If it is greater, that is, the statement is true, then the code
    inside this compound statement is executed. If it is false, the value in `current_time`
    is not greater than the value in `sunset_time`; the code inside the statement
    will not be executed. In this case, the end of the compound statement is the last
    line: `end_if`. It indicates that everything between the line starting with `if`
    and the `end_if` line is a part of that statement. It should be noted that there
    is a flaw in the logic as this condition will not work if the current time is
    after midnight, but let''s ignore that for now.'
  prefs: []
  type: TYPE_NORMAL
- en: The statement on line 5 that turns on the light is yet again a call to a function.
    Also, note that this line starts with some spaces. This is called an indentation
    and is something we will discuss in more detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We now know that statements are made up of expressions or other statements.
    To be able to figure out where a statement ends and another begins, a language
    will define how they are separated. How this is done will be a part of the language
    syntax. Let's explore how we can do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Separating statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A programming language will separate statements by defining where a statement
    ends. If the language can figure out where one statement ends, it also knows that
    what comes after it must be the beginning of another statement.
  prefs: []
  type: TYPE_NORMAL
- en: Languages have different ways to define this. If we compare how different languages
    terminate statements, we will see that we have three main ways for it to be done.
    Many languages will terminate a statement by inserting a new line. This means
    that, in general, every line is a single statement if it is not a compound statement,
    as it will need to be handled uniquely.
  prefs: []
  type: TYPE_NORMAL
- en: Another popular way to terminate statements is by using a semicolon, `;`. For
    languages that use this technique, we can have several statements on a single
    line. The language knows that a statement ends as soon as it sees a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: A third variant is to use a period, `.`, instead of a semicolon. Apart from
    that, it works the same way as when a semicolon is used so that we can have more
    than one statement on a single line.
  prefs: []
  type: TYPE_NORMAL
- en: A few languages will use other techniques, such as using a colon instead of
    a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some languages that terminate statements with a new line include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: BASIC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fortran
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Basic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some languages that end statements with a semicolon include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go (even if the compiler automatically inserts them)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pascal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some languages that use other symbols to terminate statements include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: ABAP (period)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: COBOL (whitespace, such as a space, tab, or newline; sometimes, a period)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Erlang (period, comma, and semicolon)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lua (whitespace such as a space, tab, or newline)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prolog (comma, semicolon, and period)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For compound statements, we will need a way to define where they begin and where
    they end. As a compound statement is made up of one or more statements, many languages
    will use another method to terminate them.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will find three main techniques that languages use. One is to use curly
    brackets, `{}`, to indicate where a compound statement begins and ends. Everything
    that is placed between the brackets is considered to be part of the compound statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In such a language, the compound `if` statement that we saw in the preceding
    code should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is an open bracket at the end of the first line and a
    closing bracket on the last line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of languages that use this technique include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another way to do this is to use end statements. Different languages will have
    slight variations on this.
  prefs: []
  type: TYPE_NORMAL
- en: Here are some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Ada programming language, an `if` statement looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The same statement in Modula-2 is just slightly different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Ruby has another variant that is along the same lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The last variant is the language that will use indentation to accomplish the
    same thing. Remember that indentation is when we use a space to push in the code.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at all of the preceding examples, the line containing `turn_on_light`
    is always indented. In those languages, it is only because it makes the code easier
    to read for us as humans. However, some languages will use this to define where
    a compound statement begins and ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'One such language is Python. The code example for Python should look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, everything that is indented is part of the compound statement. To indicate
    that something that comes afterward is not part of the statement, it would be
    written on the same level as the `if` statement, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, the last line is not part of the compound statement as it is written without
    any indentation.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, an indentation can be used to make the code easier to read, while
    some languages will use it for compound statement termination. Let's go on to
    discuss why the readability of code is important and how we can use indentation
    and blank lines to improve it.
  prefs: []
  type: TYPE_NORMAL
- en: Making the code readable by indenting and using empty lines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ever since we moved away from machine code, the motivation has been that we
    want code that is easier to read and write for humans. We shall keep this in mind
    when we are writing code, as code does not just consist of instructions to the
    computer, but also something that needs to be maintained by either us or others.
  prefs: []
  type: TYPE_NORMAL
- en: As we have learned, one tool that we can use to make the intentions of the code
    clearer to whoever reads it is indentation.
  prefs: []
  type: TYPE_NORMAL
- en: The indentation technique
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Indentation is a technique that we use to show that certain code lines belong
    together in a block. This is typically done for compound statements. Since a compound
    statement can be constructed of other statements or other compound statements,
    indentation becomes essential to be able to see what code block a statement belongs
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12: Indented code will be a visual aid that indicates how compound
    statements are constructed](img/B15554_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.12: Indented code will be a visual aid that indicates how compound
    statements are constructed'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if the lines in the preceding diagram are just lines, we could make out
    the individual components they represent. If we color them, as in *figure 5.13*,
    we can see that this page is made up of four statements. The first line is a single
    statement, but then we have the green lines: these are compound statements, starting
    at line 2\. Again, the purple lines are compound statements and, in the end, we
    have a single line that makes up a one-line statement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The dashed lines represent compound statements and are made up of single-line
    statements and a compound statement, as indicated by the indentation. It is the
    same thing with the dotted lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13: The dashed lines are a compound statement containing another
    compound statement; the same is true for the dotted lines](img/B15554_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.13: The dashed lines are a compound statement containing another compound
    statement; the same is true for the dotted lines'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the indentation will carry lots of information to the reader
    if we know how to interpret it. It is, therefore, crucial that we are careful
    to get the indentation right when writing our code. In most languages, this information
    is only interesting to human readers. The compiler or interpreter will ignore
    the indentation. But some languages, such as Python, use indentation as their
    tool to define compound statements, making the indentation mandatory and a part
    of the language's syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly, the text editor that a programmer uses to write the code will help
    with code indentation, either by automatically indenting code within a compound
    statement or by providing built-in commands that, when executed, will adequately
    format the code.
  prefs: []
  type: TYPE_NORMAL
- en: There is another formatting trick that we can use to make our code more readable
    to humans. One such trick is the use of blank lines.
  prefs: []
  type: TYPE_NORMAL
- en: Blank lines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Blank lines separate the paragraphs in this book. The reason is apparent. Without
    them, the text would be hard to read. These empty lines are not inserted at random.
    The text within a paragraph is logically connected. We can indicate that the text
    changes focus by creating a new paragraph, which is by inserting a blank line
    in the text.
  prefs: []
  type: TYPE_NORMAL
- en: The same thing applies to code. Blank lines are inserted for human readers.
    It is used to show the intent the programmer has. If three statements are somehow
    connected logically, we can indicate this by adding a blank line after the last
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is some Python code. It is not important to know what this code
    does, but look at the use of indentation and blank lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that all the code is within one single compound statement as
    all lines, except the first, are indented. Further down, we can see other compound
    statements. Every time the indentation level increases, a new compound statement
    begins, and when it decreases, one ends.
  prefs: []
  type: TYPE_NORMAL
- en: There are also some blank lines. This indicates that there is a logical connection
    between the lines preceding the empty line.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at lines 2 and 3 and how they are connected. In line 2, we
    are preparing some data so that it will be in the right form for what we want
    to do on line 3\. Here, we can see the importance of the sequence. Line 3 will
    require a number in a particular format. So, line 2 prepares the number so that
    it can be used on line 3\.
  prefs: []
  type: TYPE_NORMAL
- en: When these two lines are completed, the program changes its focus slightly.
    Even if we don't understand anything about what the code does, the information
    carried by the indentation and the blank lines will give us clues that will make
    it easier to read the code.
  prefs: []
  type: TYPE_NORMAL
- en: Blanks lines are also something that compilers and interpreters will ignore,
    so they are there for us humans. Just as it is vital to use paragraphs in a line
    of text correctly, we must use blank lines in a way that makes sense and assist
    the reader of our code.
  prefs: []
  type: TYPE_NORMAL
- en: There is another tool that we also can use to make things easier to understand
    for a human reading our code, and that is comments.
  prefs: []
  type: TYPE_NORMAL
- en: Making the code understandable using comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Indentation and blank lines are not always enough to make the intent of the
    code clear. In such cases, we can use comments. A comment is a line of normal
    text, inserted in the code, which is only for humans. We use them to explain lines
    of code that are not obviously understood at first glance.
  prefs: []
  type: TYPE_NORMAL
- en: As the compiler or interpreter ignores comments, we need a way to indicate that
    something is a comment. We have two variants of comments; one that runs to the
    end of the line, called a *line comment*, and one that spans multiple lines, often
    referred to as a *block comment*. Let's understand each in turn, in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Line comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A line comment has some symbols indicating the beginning of the comment, and
    it continues for the rest of that line. These can be inserted on a separate line
    or at the end of a line with code that will execute.
  prefs: []
  type: TYPE_NORMAL
- en: As a part of the language syntax, the symbol used to indicate the beginning
    of these comments is defined. Some are common, even if some languages will use
    more obscure variants.
  prefs: []
  type: TYPE_NORMAL
- en: The most common symbol used by many languages is a double slash, `//`, which
    is two slashes without any space between them. Even if this symbol is made up
    of two characters, it is treated as a single symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The languages that use this method for line comments include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another common symbol used by a number of languages is the hash symbol, `#`.
    Despite being a different symbol, it is handled in the same way as the double
    slash.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hash symbol is used for line comments by languages such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Perl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some languages have other ways to indicate a comment. In BASIC, the abbreviation
    `'`.
  prefs: []
  type: TYPE_NORMAL
- en: The `⍝`.
  prefs: []
  type: TYPE_NORMAL
- en: Ada and Lua are two languages that use double hyphens, `--`, to indicate a line
    comment.
  prefs: []
  type: TYPE_NORMAL
- en: Haskell also uses this. Haskell also has another unique way to handle comments,
    called `>`. All other lines are considered to be comments.
  prefs: []
  type: TYPE_NORMAL
- en: Pascal, and languages closely related to Pascal, such as Modula-2, use `(*`
    to indicate the beginning of a comment and `*)` to mark the end.
  prefs: []
  type: TYPE_NORMAL
- en: Languages that are related to Lisp, such as Common Lisp and Clojure, use a semicolon,
    `;`, to indicate line comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using line comments can look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first part is the normal code that will be executed, but as soon as the
    compiler or interpreter sees the comment symbol, `//`, it will ignore the rest
    of this line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same code in a language that uses the hash symbol for comments will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'These comments can also be on a separate line like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, the comments can also appear like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This separation will depend on the language.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we want a comment to span multiple lines. Instead of having a line
    comment symbol at the start of every line in the comment, we can use block comments.
  prefs: []
  type: TYPE_NORMAL
- en: Block comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Block comments have one symbol that indicates the beginning of the comment and
    another symbol that marks the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Languages that use the double slash symbol for line comments will often use
    `/*` to indicate the beginning of a block comment and `*/` to indicate the end.
    Languages that use these symbols include the following, among others:'
  prefs: []
  type: TYPE_NORMAL
- en: C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perl uses `=begin` to indicate the start of a block comment and `=cut` to mark
    the end.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby has a similar concept, with `=begin` and `=end` marking the beginning and
    end, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Python does not have a block comment but, instead, something called a `'''`
    or `"""`. They end with the same three characters that were used at the beginning.
    So, use three single quotes to end the comment if you used single quotes at the
    beginning; otherwise, use three double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In code, a block comment can look something like this if we use `/*` and `*/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A programmer can also use several commonly used tags within comments to indicate
    certain things.
  prefs: []
  type: TYPE_NORMAL
- en: Tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, a programmer wants to mark a section in the code using a tag so
    that it is easy to find this location. These tags are informal, but some are commonly
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BUG`: A known bug in the code that should be corrected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FIXME`: Either a known bug or something else that must be corrected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HACK`: Marking a section of code that is not structured or written optimally
    and should be rewritten.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TODO`: This marks a location where something will be inserted later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These tags are written in comments and are mainly used so that they can be found
    with tools such as the Unix grep tool (a tool for searching in text files). Some
    programming editors will even highlight some of these tags.
  prefs: []
  type: TYPE_NORMAL
- en: Comments can also be used to remove code.
  prefs: []
  type: TYPE_NORMAL
- en: Commenting out code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, a programmer needs to remove a couple of lines of code to try something
    out or to isolate a bug. Instead of deleting these lines, they can be commented
    out with either a line comment or block comments. It is then easy to remove the
    comment symbol to make the code active again.
  prefs: []
  type: TYPE_NORMAL
- en: This technique can also be used if we are rewriting a code section. In that
    case, it is a good idea to have the old code as a reference when we are constructing
    the new code, so we don't forget something we need to do. We can place the old
    code in a comment; however, when we are done, we should remove the old commented
    out code as it will distract us when reading the code.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler or interpreter will ignore most comments, but not all. Some might
    have a special directive meaning.
  prefs: []
  type: TYPE_NORMAL
- en: Directive comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are some examples where a comment can have a meaning for the language
    compiler or interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Some languages, such as Python, can if we use it on a Unix system and use a
    symbol that looks like a comment on the first line in a code file. This symbol
    is called a *shebang* and is made up of the hash symbol followed by an exclamation
    mark, `#!`.
  prefs: []
  type: TYPE_NORMAL
- en: This is used as an instruction, not to other humans, but to the Python interpreter
    so that it knows what version of Python should be used to interpret this program.
  prefs: []
  type: TYPE_NORMAL
- en: Python also has something called a *magic comment*, which identifies the character
    encoding that the source code file is using. It begins with `# -*- coding:` and
    ends with `-*-`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Python program using both directives can start with two lines that look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As Python uses `#` as the symbol for line comments, it might look like these
    are two normal comments. This can be a bit confusing when reading the code, and
    we should be aware that these are instructions to the interpreter and not to humans.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, comments can be used in several different ways. Let's take a
    look at some typical uses in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Making use of comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How to use comments in the best way is subject to dispute, and, often, you will
    get conflicting advice. Let's examine some typical uses before we discuss some
    of the opinions people have regarding comments.
  prefs: []
  type: TYPE_NORMAL
- en: Planning and reviewing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Comments can be used to plan the structure of the code before it is written.
    When writing an intricate part of an application, some people prefer to map out
    the logic with comments before focusing on the real code.
  prefs: []
  type: TYPE_NORMAL
- en: Code description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One everyday use of comments is to summarize what a section of code is doing
    and explain the programmer's intent. You should not use comments to rewrite what
    the code does in English. If you feel that you need to do that, the code is most
    likely too complicated and should be revised.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithmic description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes, we implement complex algorithms that need an explanation with maybe
    both text and diagrams. This is usually the prerequisite knowledge required to
    be able to understand the code. This can, sometimes, be rather extensive explanations.
    Look at the following diagram as an example. This comment is taken from a part
    of the Python language itself. If we count the number of lines that are comments
    in that module, we will see that they are over 77%:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14: Example of comment describing the process.py module in the'
  prefs: []
  type: TYPE_NORMAL
- en: Python programming language](img/B15554_05_15.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.14: Example of comment describing the process.py module in the Python
    programming language'
  prefs: []
  type: TYPE_NORMAL
- en: The Python language is open source, so anyone can look at or download the code
    for it. If you want to see what the code for a programming language looks like,
    you can view it at [https://github.com/python/cpython](https://github.com/python/cpython).
  prefs: []
  type: TYPE_NORMAL
- en: '**Comments controversy**'
  prefs: []
  type: TYPE_NORMAL
- en: There is a never-ending debate regarding how and when comments should be used.
    Some people argue that code should be written using few comments, arguing that
    the source code should be written in a way so that it is self-explanatory or self-documenting.
    The motivation for this standpoint is that if you know a language, you should
    be able to understand the intent by just reading the code. If you can't, the code
    needs to be rewritten.
  prefs: []
  type: TYPE_NORMAL
- en: Others will argue that code should be extensively commented, as per the example
    in the preceding diagram.
  prefs: []
  type: TYPE_NORMAL
- en: In between these standpoints, you will find some that argue that comments, by
    themselves, are not beneficial nor harmful and should be used with care where
    they provide added value.
  prefs: []
  type: TYPE_NORMAL
- en: So, to sum it up, in this section, we learned that comments are a tool to explain
    the code. But they are also used for documentation. Additionally, tags can be
    used to make notes of things that need to be dealt with in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed the most fundamental concept that we have in
    programming: a sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: Sequential thinking can help us structure our ideas so that we can break them
    down into smaller pieces. As we have mentioned in this chapter, grasping everything
    a program needs to do can be hard, so we need a way to be able to focus on the
    details without losing the overview of what the program needs to do.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of doing things in sequence is also at the very heart of any program,
    since the instructions we write are executed one after the other. This is important
    because we need to make sure that these instructions come in the right order.
  prefs: []
  type: TYPE_NORMAL
- en: The instructions we write are made up of statements, and we learned that some
    statements are short and simple, while others can span several lines and be made
    up of other statements. Some are smaller building blocks, called expressions.
    We are now on an abstraction level where we can deal with details such as adding
    two numbers together.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down the code into smaller and smaller chunks allows us to think about
    how to structure our solution. Sometimes, we will need to document our line of
    thought to help us or other readers of our code see what made us choose this solution.
    We learned that comments can be used for this.
  prefs: []
  type: TYPE_NORMAL
- en: Comments can also be used as a documentation of the code so that it is clear
    what it does and how it can be used. Additionally, we saw that comments can be
    directed to the language compiler or interpreter to give instructions to it.
  prefs: []
  type: TYPE_NORMAL
- en: As we know from previous chapters, a computer program takes data as its input,
    stores it in memory, processes this data, and produces new data as its output.
    Data is a key concept, so, in the next chapter, we will learn how to interact
    with it and why this type of data has such importance.
  prefs: []
  type: TYPE_NORMAL
