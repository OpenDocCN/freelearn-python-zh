- en: '*Chapter 5:* Sequence – The Basic Building Block of a Computer Program'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章：序列 - 计算机程序的基本构建块*'
- en: When it comes to programming, the most fundamental concept is the sequence.
    It indicates what we do and when we do it, one after another. However, when we
    take a closer look, we find that there is more to this, and, in this chapter,
    we will learn what it is.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到编程时，最基本的概念是序列。它表示我们做什么以及我们何时依次进行。然而，当我们仔细观察时，我们发现这不仅仅是这样，在本章中，我们将学习它是什么。
- en: We will also use the concept of a sequence to decide what steps a program will
    need to perform to accomplish its overall task. Since it can be tough to have
    both an overview of everything that needs to be done and, at the same time, look
    at all the details, we will require a concept that can assist us. Thinking of
    the sequence in which the program needs to do things in, for instance, could be
    such a tool.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还将使用序列的概念来决定程序需要执行哪些步骤才能完成其总体任务。由于同时拥有对需要完成的所有事情的概述和查看所有细节可能很困难，我们需要一个概念来帮助我们。例如，考虑程序需要按什么顺序做事，这可能是一个工具。 '
- en: When learning how to program, one problem many people face is how to transform
    an idea to go. Where should you start? In this chapter, we will learn that we
    can use the concept of sequential thinking to break down an idea into smaller
    tasks that we then can deal with. We will also see that we can apply the same
    concept to the code that we write to ensure that we do things in the right order.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当学习如何编程时，许多人面临的一个问题是如何将一个想法转化为行动。你应该从哪里开始？在本章中，我们将学习我们可以使用顺序思维的概念将一个想法分解成更小的任务，然后我们可以处理这些任务。我们还将看到我们可以将同样的概念应用到我们编写的代码中，以确保我们按正确的顺序做事。
- en: 'In this chapter, you will look at the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解以下主题：
- en: Understanding the importance of sequences
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解序列的重要性
- en: What a statement is and how it is defined
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语句是什么以及它是如何定义的
- en: How different statements are separated
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的语句是如何分隔的
- en: How to format the code to make it more readable
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何格式化代码以使其更易于阅读
- en: Different kinds of comments and ways to document our code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的注释类型和记录代码的方法
- en: The importance of sequences
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列的重要性
- en: One day, when you come home, you start craving a pie, so you decide to make
    one. The reason you will bake a pie is not that you wish to cook, but to satisfy
    your desire for pie. However, to be able to get the pie, you need to perform several
    steps. First, you need a recipe, and then you need to get all of the ingredients.
    When you acquire them, you will follow each step in the recipe. Then, finally,
    after the pie has been in the oven and cooled down a bit, you can enjoy your well-deserved
    treat.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有一天，当你回到家，你开始渴望一块派，于是你决定自己做一块。你烘焙派的原因并不是因为你喜欢烹饪，而是为了满足你对派的渴望。然而，为了能够得到派，你需要执行几个步骤。首先，你需要一个食谱，然后你需要收集所有的原料。当你收集到它们后，你将按照食谱中的每个步骤进行。最后，当派在烤箱里烤了一段时间并稍微冷却后，你就可以享受你应得的美食了。
- en: You just performed a few tasks in sequence. Some of them need to be completed
    in the right order, while others can be done in any order (or, at least, in a
    more relaxed order). You must turn on the oven before you can bake the pie, but
    it is not essential that you bring out the flour before the butter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚按顺序完成了一些任务。其中一些任务需要按正确的顺序完成，而其他任务则可以按任何顺序（或者至少可以更轻松地按顺序）完成。你必须先打开烤箱，然后才能烤派，但你在拿出面粉之前拿出黄油并不是必要的。
- en: 'Programming is like baking a pie. We will have goals, such as we want pie,
    and to be able to achieve that goal, we will need to do several things: in some
    instances, the order is essential, while others are less dependent on the order.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 编程就像烘焙派。我们将有目标，比如我们想要派，为了能够实现这个目标，我们需要做几件事情：在某些情况下，顺序是重要的，而在其他情况下，顺序则不那么重要。
- en: Programming is all about problem-solving and the art of breaking things down
    into smaller steps. This will be done in iterations where you first have an overall
    solution and then break this solution down into smaller and smaller steps until
    you are on a level where you understand each step that needs to be taken.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 编程全部关于问题解决和将事物分解成更小步骤的艺术。这将在迭代中进行，你首先有一个总体解决方案，然后将这个解决方案分解成越来越小的步骤，直到你达到一个理解每个需要采取的步骤的水平。
- en: This is one of the more difficult skills to master when you begin to learn programming.
    As with all new skills, it takes lots of practice before you will feel comfortable
    doing this. Some tricks can make it easier for you to acquire this skill. The
    essential ability you require is an overview of the full problem that you are
    trying to solve and, at the same time, a focus on details of one or more subproblems
    that need to be resolved. This means that you will need to zoom in and out on
    the details while keeping an overall view of the whole problem. You can practice
    this without doing any programming. Playing logical puzzle games such as Sudoku
    will train your brain to keep an eye on the overall game and, at the same time,
    focus on individual parts of the game such as what numbers can go into a certain
    cell.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在你开始学习编程时需要掌握的更困难技能之一。与所有新技能一样，在感到舒适地做这件事之前，你需要大量的练习。一些技巧可以使你更容易获得这项技能。你需要的基本能力是对你试图解决的整个问题的概述，同时关注一个或多个需要解决的子问题的细节。这意味着你需要在保持整个问题整体观的前提下，对细节进行放大和缩小。你可以通过不进行任何编程来练习这一点。玩逻辑谜题游戏，如数独，可以训练你的大脑在关注整体游戏的同时，专注于游戏的各个部分，例如哪些数字可以放入某个单元格。
- en: Let's take a look at how we can go from a problem to a solution on a sequential
    level. First, we need to define the problem.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何可以从问题到解决方案在顺序层面上进行。首先，我们需要定义问题。
- en: Defining the problem
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义问题
- en: You often arrive home after dark, and you always forget to turn on the outdoor
    lighting before you leave home. It is so dark that you are afraid of stumbling
    on your way to the door, and finding the keyhole is always a gamble.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常在黄昏后回到家，而且你总是忘记在离开家之前打开户外照明。外面太黑了，你害怕在去门的路途中绊倒，而且找到钥匙孔总像是一场赌博。
- en: On the other hand, you don't want the light to be on all day. You don't like
    the idea of those automatic lights that react to motion either, as it will be
    activated when the neighbor's cat passes by. There must be a better solution.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你不想整日开着灯。你也不喜欢那些对动作做出反应的自动灯，因为当邻居的猫经过时，它们会被激活。肯定有更好的解决方案。
- en: The solution to the problem
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决问题的方案
- en: One solution would be if you could use your smartphone's GPS. If you had a program
    running on it that continually monitors your position, then when you come into
    a given radius from your home, it could somehow activate the lights. You soon
    realize that your solution will need to be a two-part application. One part runs
    on your phone, and the other part runs on a computer in your home. The program
    running on a computer in your house would get a signal from your mobile app that
    you now are close to home. It could then check with an online service to see what
    time the sun sets at your home's location during this time of year. If it is past
    sunset, the program can activate the lights.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个解决方案是，如果你能使用你的智能手机的GPS。如果你在上面有一个持续监控你位置的程序，那么当你从家进入一个给定半径时，它就能以某种方式激活灯光。你很快就会意识到你的解决方案将需要是一个两部分的程序。一部分运行在你的手机上，另一部分运行在你家中的电脑上。运行在你家电脑上的程序会从你的移动应用中接收到信号，表明你现在离家很近。然后它可以与在线服务核对，看看在这一年中，太阳在此时此刻在你的家所在位置是否已经落山。如果是日落之后，程序就可以激活灯光。
- en: What we have done so far is to start to define a solution. Now we must break
    down this solution further.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所做的是开始定义一个解决方案。现在我们必须进一步分解这个解决方案。
- en: Solution breakdown
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案分解
- en: We now have an overview of what we want, and, at the same time, we have zoomed
    in on a couple of details. We have decided that we would like to use the phone's
    GPS. We don't know how this can be done yet, but that is not important at this
    stage. We know that other applications can use GPS. This means that we know it
    is possible to do it and even if we, at the moment, have no idea how this is done,
    we can learn it later on in the process. We have also decided that this will be
    a two-part application. The part on the phone will, aside from monitoring the
    GPS, also need a way to contact the other part of our solution, which is the application
    running on a computer in your home. Again, we don't know how this will be done,
    but we know it can be done, and that is good enough for now. We also understand
    that we need a way to detect that we are coming from outside the defined range
    and then entering it. It is only then that the lights should be turned on. If
    we don't do this, the lights would always be on when the phone is within a stipulated
    range and we don't want that.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对想要实现的目标有了总体了解，同时我们也关注了一些细节。我们决定想要使用手机的GPS。我们目前还不知道如何实现这一点，但在这个阶段这并不重要。我们知道其他应用程序可以使用GPS。这意味着我们知道这是可行的，即使我们现在还没有头绪，我们可以在后续过程中学习。我们还决定这将是一个两部分的程序。手机部分除了监控GPS外，还需要一种方式来联系我们解决方案的另一部分，即在你家电脑上运行的应用程序。同样，我们不知道如何实现这一点，但我们知道这是可行的，这对现在来说已经足够好了。我们还理解我们需要一种方式来检测我们是否从定义的范围外进入。只有在这种情况下，灯才应该打开。如果我们不这样做，当手机在规定的范围内时，灯将始终是开着的，而我们不希望这样。
- en: The home application will need to wait for a signal from the mobile app and
    then contact a service that can tell us about the time the sun will set. On our
    to-do list, we add that we need to find such a service. Again, we don't need to
    bother about how this can be done. We will also find a way for our home application
    to control the lights. We will most likely require some hardware for this step,
    but that will be a problem that we can deal with later.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 家庭应用程序将需要等待来自移动应用程序的信号，然后联系一个可以告诉我们太阳何时落下的服务。在我们的待办事项列表中，我们添加了我们需要找到这样的服务。同样，我们不需要担心如何实现这一点。我们还将找到一种方式让我们的家庭应用程序控制灯光。我们很可能需要一些硬件来完成这一步骤，但那将是我们可以稍后解决的问题。
- en: What we now have is a sequential list of steps that we need to take. That list
    looks something like this.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个需要采取的步骤的顺序列表。这个列表看起来像这样。
- en: 'Here is a list of steps for the mobile application:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是移动应用程序的步骤列表：
- en: Is the phone within the predefined range?
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手机是否在预定义的范围内？
- en: 'If yes, was it previously outside the range, that is, have we just entered
    this range? Let us check:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是，它之前是否在范围外，也就是说，我们刚刚进入这个范围？让我们检查：
- en: '![Figure 5.1: The phone enters the predefined region](img/B15554_05_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1：手机进入预定义的区域](img/B15554_05_01.jpg)'
- en: 'Figure 5.1: The phone enters the predefined region'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：手机进入预定义的区域
- en: 'If yes, send a signal to the home application:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是，向家庭应用程序发送信号：
- en: '![Figure 5.2: The phone application contacts the application running on the
    home computer](img/B15554_05_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2：手机应用与家庭电脑上运行的应用程序进行联系](img/B15554_05_02.jpg)'
- en: 'Figure 5.2: The phone application contacts the application running on the home
    computer'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：手机应用与家庭电脑上运行的应用程序进行联系
- en: 'Here is a list of steps for the home application:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是家庭应用程序的步骤列表：
- en: Wait for a signal from the mobile app.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待来自移动应用程序的信号。
- en: 'When a signal is received, check the current time:![Figure 5.3: The application
    that is running on the home computer checks the local time](img/B15554_05_03.jpg)'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当接收到信号时，检查当前时间：![图5.3：运行在家庭电脑上的应用程序检查当地时间](img/B15554_05_03.jpg)
- en: 'Figure 5.3: The application that is running on the home computer checks the
    local time'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.3：运行在家庭电脑上的应用程序检查当地时间
- en: 'Check the online service for the local sunset time:![Figure 5.4: The application
    that is running on the home computer contacts'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查在线服务以获取当地日落时间：![图5.4：运行在家庭电脑上的应用程序联系
- en: an online service to get the local sunset time](img/B15554_05_04.jpg)
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 获取当地日落时间的在线服务](img/B15554_05_04.jpg)
- en: 'Figure 5.4: The application that is running on the home computer contacts an
    online service to get the local sunset time'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.4：运行在家庭电脑上的应用程序联系在线服务以获取当地日落时间
- en: 'If the time is after sunset, turn on lights:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果时间是在日落之后，打开灯光：
- en: '![Figure 5.5: If the time is after sunset, the home application turns on the
    light](img/B15554_05_05.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5：如果时间在日落之后，家庭应用程序会打开灯光](img/B15554_05_05.jpg)'
- en: 'Figure 5.5: If the time is after sunset, the home application turns on the
    light'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：如果时间在日落之后，家庭应用程序会打开灯光
- en: This is still a slightly rough breakdown of the sequential steps that we need
    to take. But now that we have them, we can zoom in on each of them and think about
    the things we need to do for each of the preceding steps.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然是对我们需要采取的顺序步骤的一个稍微粗糙的分解。但现在我们已经有了它们，我们可以深入到每个步骤中，并思考我们需要为每个前面的步骤做些什么。
- en: A detailed breakdown for the phone application
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手机应用程序的详细分解
- en: Let's take each of the steps, one by one, and closely examine what we need to
    do for each of them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个步骤地来看，并仔细检查我们需要为每个步骤做些什么。
- en: 'So, how can we know whether the phone is within the predefined range? To understand
    this, we must first do some research. The first thing we need to understand is
    how the phone GPS knows where it is. Searching online will soon reveal that a
    GPS works with two coordinates: longitude and latitude. These two coordinates
    will pinpoint any location on the earth. This means that when we request the current
    location from the GPS, we will be given these coordinates.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何知道手机是否在预定义的范围内呢？为了理解这一点，我们首先必须做一些研究。我们需要首先理解的是手机GPS是如何知道它所在的位置的。在网上搜索很快就会揭示GPS是使用两个坐标：经度和纬度。这两个坐标可以精确地定位地球上的任何位置。这意味着当我们从GPS请求当前位置时，我们会得到这些坐标。
- en: When we have these coordinates, we need to check how far away we are from home.
    To do this, we will need to know where home is, so the application on the phone
    needs to store this location somehow, and it will also be in the form of a longitude
    and a latitude.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有了这些坐标后，我们需要检查我们离家的距离有多远。为此，我们需要知道家的位置，因此手机上的应用程序需要以某种方式存储这个位置，并且它将以经度和纬度的形式存在。
- en: Calculating the distance between two geocoordinates is not a trivial task, but
    we don't need to worry as this is something that has been done many times before.
    In addition to this, no matter what language we are using, a simple Google search
    will give us many solutions for how this can be done. We might even be able to
    use the language package manager (refer to the *Package managers* section in [*Chapter
    4*](B15554_04_Final_NM_ePub.xhtml#_idTextAnchor067), *Software Projects and How
    We Organize Our Code*, to learn what a packet manager is and how it works) to
    find a package that can do this calculation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 计算两个地理坐标之间的距离不是一项简单的工作，但我们不需要担心，因为这是以前已经多次做过的事情。此外，无论我们使用什么语言，简单的谷歌搜索都会给我们提供许多如何做到这一点的解决方案。我们甚至可能能够使用语言包管理器（参考[*第4章*](B15554_04_Final_NM_ePub.xhtml#_idTextAnchor067)，*软件项目和我们的代码组织方式*，了解什么是包管理器以及它是如何工作的）来找到一个可以进行这种计算的包。
- en: No matter what solution we use, we can assume that we will use the two coordinate
    pairs that we have, the phone's location, and our home location, and what we get
    back is a distance between them. We also need to decide how close to home we need
    to be for the lights to activate. This can be any distance.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们使用什么解决方案，我们都可以假设我们将使用我们拥有的两个坐标对，即手机的位置和我们的家位置，我们得到的是它们之间的距离。我们还需要决定我们需要离家多近才能激活灯光。这可以是任何距离。
- en: Next, we have to check whether we have come from outside the predefined range.
    We need a way to tell whether we have entered the predefined range or whether
    we already were within the range. We could do this by keeping track of what the
    distance to home was before we check the current position. If we were outside
    the range and are now inside it, then we know that we are close enough to home
    to send the signal to turn on the lights.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须检查我们是否是从预定义的范围外进来的。我们需要一种方法来判断我们是进入了预定义的范围，还是我们已经在范围内。我们可以通过跟踪在检查当前位置之前家的距离来做这件事。如果我们之前在范围外而现在在范围内，那么我们知道我们已经足够接近家，可以发送信号打开灯光。
- en: So, now we need to send a signal to the home application. When we have entered
    the range, we need a way for the phone application to contact the home computer.
    This can be done in several ways, and there is no need for us to decide what technique
    to use at this point.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们需要向家庭应用程序发送一个信号。当我们进入范围时，我们需要一种方法让手机应用程序联系家庭电脑。这可以通过几种方式完成，我们目前不需要决定使用哪种技术。
- en: We can now summarize the sequence for the phone application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以总结出手机应用程序的顺序。
- en: Phone application sequence
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手机应用程序顺序
- en: 'Now we have the logic for the phone application in place. We also know what
    the sequence will need to look like. It will look something like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为手机应用建立了逻辑。我们还知道序列将需要看起来像什么。它看起来可能像这样：
- en: Get the current position.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取当前位置。
- en: Calculate the distance from home.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算从家的距离。
- en: Is the distance within the range that defines when we are close enough to turn
    on the lights?
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个距离是否在我们定义的足够近以打开灯的范围之内？
- en: Was our previous distance, that is, the distance of the last time we checked
    our position, outside the given range?
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们之前测量的距离，即我们上次检查位置的距离，是否在给定的范围之外？
- en: If the answer to the questions in *step 3* and *step 4* are both yes, tell the
    home computer to turn on the light. If it is no, we can go back to *step 1*.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*步骤 3*和*步骤 4*的答案都是是，告诉家用电脑打开灯。如果答案是 否，我们可以回到*步骤 1*。
- en: Store the distance from home as our old distance.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将从家的距离存储为我们旧的距离。
- en: Start over from *step 1*.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*步骤 1*重新开始。
- en: 'These steps are illustrated here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤在这里进行了说明：
- en: '![Figure 5.6: Sequence for the phone application](img/B15554_05_06.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6：电话应用的序列](img/B15554_05_06.jpg)'
- en: 'Figure 5.6: Sequence for the phone application'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：电话应用的序列
- en: These seven steps will be repeated over and over. We will need to consider what
    will happen when we perform the first iteration as we will not have a value for
    the old distance. We can give this an initial default value that is well outside
    the range, for example, a negative number.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这七个步骤将反复进行。当我们执行第一次迭代时，我们需要考虑会发生什么，因为我们不会有旧距离的值。我们可以给它一个初始默认值，这个值远远超出范围，例如，一个负数。
- en: We now have a well-defined sequence of steps, and we have not written a line
    of code yet. This is good because it will help us when we start to write the code
    as we can zoom in and focus on each of these steps without losing track of the
    overview.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个明确的步骤序列，我们还没有写一行代码。这是好的，因为它将帮助我们开始编写代码，我们可以放大并专注于这些步骤中的每一个，而不会失去对概览的把握。
- en: We can now turn our attention to the home application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将注意力转向家用应用。
- en: A detailed breakdown of the home application
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 家用应用的详细分解
- en: At first, the home application will have absolutely nothing to do as it will
    just sit and wait for a signal from the phone app. However, when it gets that
    signal, it will wake up and start to do its work.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，家用应用将没有任何事情可做，因为它将只是坐着等待来自手机应用的信号。然而，当它收到那个信号时，它会醒来并开始工作。
- en: When the home application gets the message from the phone, the first thing it
    needs to do is one of two things. Either it can check the local time, or it can
    contact the sunset service to get the current sunset time. The order of these
    two operations is not essential as we need both, so we can compare them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当家用应用收到来自手机的消息时，它需要做的第一件事是两件事之一。要么它可以检查当地时间，要么它可以联系日落服务以获取当前的日落时间。这两个操作的顺序不是必要的，因为我们都需要它们，所以我们可以比较它们。
- en: When we have the local time and the sunset time, we need to compare them to
    see whether it is after dark. If it is, all the conditions for turning on the
    light are met, and we get a signal that the phone is within range and that it
    is dark outside.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有了当地时间以及日落时间，我们需要比较它们以确定是否是晚上。如果是，打开灯的所有条件都满足，我们会收到一个信号，表明手机在范围内，外面是黑暗的。
- en: Now we need to turn on the outside light. We still need to figure out how this
    can be done. One way to do this is to use LED lamps that can be controlled wirelessly.
    These can often be interacted with from an application such as the one we are
    about to create. We should do some research before buying the lights since we
    need to select a brand that can be controlled by our application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要打开外面的灯。我们仍然需要弄清楚如何做到这一点。一种方法是可以使用无线控制的LED灯。这些灯通常可以通过我们即将创建的应用程序等应用程序进行交互。在购买灯之前，我们应该做一些研究，因为我们需要选择一个可以被我们的应用程序控制的品牌。
- en: Home application sequence
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 家用应用序列
- en: 'The sequence for the home application is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 家用应用的序列如下：
- en: Wait for a signal from the phone app.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待来自手机应用的信号。
- en: When the signal is received, get the local time.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当收到信号时，获取当地时间。
- en: Contact the sunset service to get the local sunset time.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 联系日落服务以获取当地时间。
- en: Compare the current time with the sunset time.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前时间与日落时间进行比较。
- en: If it is after sunset, turn on the light.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是日落之后，打开灯。
- en: Go back to step 1.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到步骤 1。
- en: 'Step 2 and step 3 can be performed in any order. If the current time is before
    the sunset time, the application will skip turning on the light and go back to
    step 1\. The sequence is depicted here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第2步和第3步可以按任何顺序执行。如果当前时间早于日落时间，应用程序将跳过打开灯光并返回第1步。这个顺序在这里表示：
- en: '![Figure 5.7: Sequence for the home application](img/B15554_05_07.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7：家庭应用程序的顺序](img/B15554_05_07.jpg)'
- en: 'Figure 5.7: Sequence for the home application'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7：家庭应用程序的顺序
- en: We now have an excellent starting point regarding how to build this application.
    Even if several things are still unclear to us, such as how the phone application
    shall contact the home application, what service the home application will use
    to check the sunset time and how it will get in touch with it, and how the home
    application will turn on the light, the sequence that the different things must
    be performed in, is now clear to us.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个很好的起点，关于如何构建这个应用程序。即使我们仍然对一些事情不太清楚，比如手机应用程序应该如何联系家庭应用程序，家庭应用程序将使用什么服务来检查日落时间以及它将如何与之联系，以及家庭应用程序将如何打开灯光，但不同事情必须执行的顺序现在对我们来说已经很清晰了。
- en: At this point, we have a good idea of what our application needs to do, but
    we still have a number of things we need to do. First of all, we need to learn
    the necessary things to create this application. How can we get the position from
    the phone GPS? When learning things like this, it is usually a good idea to create
    a *toy project* where you can just try to get the coordinates and print them to
    the screen. When you have figured that out, you can then take this solution into
    your real project. Doing it in a separate project is smart because you can focus
    on learning one particular thing at a time. Another example is that we need to
    implement a way to calculate the distance between two geocoordinates. Apply the
    same principle of doing it in a separate application when testing different solutions.
    When you get a result, you should find an online service that does this calculation
    so that you can verify your results. In programming, you never stop learning new
    things and technologies. There are always things you have never done before. But
    don't let that stop you.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经对我们的应用程序需要做什么有了很好的了解，但我们仍然有许多事情要做。首先，我们需要学习创建此应用程序所需的知识。我们如何从手机GPS获取位置？在学习这类事情时，通常一个好的想法是创建一个*玩具项目*，你只需尝试获取坐标并将它们打印到屏幕上。当你弄清楚这一点后，你就可以将这个解决方案应用到你的实际项目中。在单独的项目中这样做是聪明的，因为你可以一次专注于学习一件特别的事情。另一个例子是我们需要实现一种计算两个地理坐标之间距离的方法。在测试不同的解决方案时，应用同样的原则在单独的应用程序中执行。当你得到结果时，你应该找到一个提供这种计算服务的在线服务，以便你可以验证你的结果。在编程中，你永远不会停止学习新事物和技术。总有你从未做过的事情。但不要让这阻止你。
- en: This is one aspect of sequencing in a computer program. Another point is what
    happens on a smaller level. In the code that we write, every step we perform needs
    to be broken down into something known as a *statement*, and those statements
    will be performed in sequence.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是计算机程序中序列的一个方面。另一个点是更小层面上发生的事情。在我们编写的代码中，我们执行的每个步骤都需要分解成称为*语句*的东西，而这些语句将按顺序执行。
- en: Understanding statements
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解语句
- en: In many programming languages, the sequence of code that we write is made up
    of what are called statements. A statement expresses some action to be carried
    out and is made up of several internal components. These are called expressions.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多编程语言中，我们编写的代码序列由被称为语句的东西组成。语句表达了一些要执行的操作，并由几个内部组件组成。这些被称为表达式。
- en: Expressions
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达式
- en: 'Statements are made up of expressions, and expressions are made up of even
    smaller parts. Let''s refer to an example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 语句由表达式组成，而表达式由更小的部分组成。让我们参考一个例子：
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is an expression made up of three parts. Here, we are operating using the
    addition operator, `+`. On both sides of the operator, we have the operands in
    the form of two constant values, `5` and `4`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个由三个部分组成的表达式。在这里，我们使用加法运算符`+`进行操作。在运算符的两侧，我们有形式为两个常量值的操作数，`5`和`4`。
- en: 'A statement can be made up of more than one expression. Take a look at the
    following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一个语句可以由多个表达式组成。看看下面的代码：
- en: '[PRE1]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we have the same expression as we had earlier, `5 + 4`, but now with
    a new expression to the left:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个与之前相同的表达式，`5 + 4`，但现在左侧有一个新的表达式：
- en: '![Figure 5.8: A statement with two expressions, one addition and one assignment](img/B15554_05_08.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图5.8：包含两个表达式的语句，一个是加法，另一个是赋值](img/B15554_05_08.jpg)'
- en: 'Figure 5.8: A statement with two expressions, one addition and one assignment'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8：包含两个表达式（一个加法和一个赋值）的语句
- en: 'Again, we have two operands, the result of the addition, `9`, to the right,
    and to the left, we have something called a *variable*, named `result`. A variable
    is a way for us to store data in memory using a name we define:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们有两个操作数，右侧的加法结果`9`，左侧有一个称为*变量*的东西，名为`result`。变量是我们使用我们定义的名称在内存中存储数据的一种方式：
- en: '![Figure 5.9: When the result of the addition is calculated the assignment
    expression can be performed](img/B15554_05_10.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图5.9：当计算加法的结果时，可以执行赋值表达式](img/B15554_05_10.jpg)'
- en: 'Figure 5.9: When the result of the addition is calculated the assignment expression
    can be performed'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9：当计算加法的结果时，可以执行赋值表达式
- en: 'We will talk more about variables in [*Chapter 6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091),
    *Working with Data – Variables*. We also introduced a second operator, `=`. This
    operator is called the assignment operator. It takes what is on the right and
    stores it in what is on the left:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第6章*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091)中更多地讨论变量，*使用数据 –
    变量*。我们还介绍了一个第二个运算符，`=`。这个运算符被称为赋值运算符。它将右侧的内容存储在左侧：
- en: '![Figure 5.10: The variable called result can be visualized as a box;'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.10：名为`result`的变量可以表示为一个框；'
- en: the assignment stores a value in that box](img/B15554_05_11.jpg)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值将一个值存储在那个框中](img/B15554_05_11.jpg)
- en: 'Figure 5.10: The variable called result can be visualized as a box; the assignment
    stores a value in that box'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10：名为`result`的变量可以表示为一个框；赋值将一个值存储在那个框中
- en: To be able to complete this statement, the expressions must be dealt with in
    the correct order. This is called the order of operations.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个陈述，必须按照正确的顺序处理表达式。这被称为运算顺序。
- en: Order of operations
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运算顺序
- en: 'To store the result of the addition in the variable called `result`, we must
    first perform the expression to the right; that is the addition, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要将加法的结果存储在名为`result`的变量中，我们必须首先执行右侧的表达式；即加法，如下所示：
- en: '[PRE2]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When the expression to the right is completed, we can imagine that our statement
    will look like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当右侧的表达式完成时，我们可以想象我们的语句将看起来像这样：
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, this final expression can be executed. The value of `9` is assigned (it
    is stored) in the `result` variable.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个最终表达式可以执行。`9`的值被分配（存储）在`result`变量中。
- en: 'A statement can be made up of more expressions. Consider the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个陈述可以由多个表达式组成。考虑以下内容：
- en: '[PRE4]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first thing we must understand here is the order of operations, that is,
    in which order the addition and the multiplication is performed. If we do the
    addition first, we will do `5` `+` `4`, which is 9, and then 9 times `2`, which
    is 18\.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先必须理解的是运算顺序，即加法和乘法执行的顺序。如果我们先做加法，我们会做`5` `+` `4`，结果是9，然后9乘以`2`，结果是18。
- en: If we instead do the multiplication first, we would get `4` times `2`, which
    is 8, and then `5 +` 8, which is 13\. So, the order is important. Every programming
    language has a well-defined order of operations, which is in what different order
    the operations must be performed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们首先执行乘法，我们会得到`4`乘以`2`，结果是8，然后`5 +` 8，结果是13。所以，顺序很重要。每种编程语言都有一个明确的运算顺序，即操作必须执行的不同顺序。
- en: 'In this example, the order will be the same as in mathematics; multiplication
    will be performed before addition:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，顺序将与数学中的顺序相同；乘法将在加法之前执行：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we want to override the built-in order of operations, we can use parentheses
    like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要覆盖内置的运算顺序，我们可以使用括号，如下所示：
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now the addition is performed first because it is within parentheses, so the
    variable result will now store the value of 18 (9 times 2).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在先执行加法，因为它是括号内的，所以变量`result`现在将存储18的值（9乘以2）。
- en: Some statements are made up of more than one single line. These are often called
    compound statements. Let's explore what those are next.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有些陈述由多于一行组成。这些通常被称为复合语句。接下来让我们探索一下这些是什么。
- en: Compound statements
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复合语句
- en: 'A compound statement is a statement that spans several lines. These compound
    statements are made up of one or more *normal* one-line statements. They can also
    consist of other compound statements, as we will learn later on. For example,
    in our application that turns on the light, we have some conditions that must
    be met before we do something. One condition is that we only turn on the light
    if the current time is after sunset. The logic can be visualized in a flowchart:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 复合语句是跨越多行的语句。这些复合语句由一个或多个*普通*的单行语句组成。它们也可以由其他复合语句组成，正如我们稍后将要学习的。例如，在我们的打开灯的应用程序中，我们在做某事之前必须满足一些条件。一个条件是，只有当当前时间在日落之后，我们才打开灯。这种逻辑可以用流程图来表示：
- en: '![Figure 5.11\. Flowchart for the home application](img/B15554_05_12.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图5.11.家庭应用程序的流程图](img/B15554_05_12.jpg)'
- en: Figure 5.11\. Flowchart for the home application
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11.家庭应用程序的流程图
- en: As you can see, the part where we turn on the light is only executed if it is
    after sunset. So, for that statement to be performed, we have a condition that
    must be met. That condition is a statement, but that statement includes the statement
    that turns on the light.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们打开灯的部分只有在日落之后才会执行。因此，为了执行这个语句，我们必须满足一个条件。这个条件是一个语句，但这个语句包括打开灯的语句。
- en: 'In code, it can look something like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，它可能看起来像这样：
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first line of the preceding code contains one single statement. It is a
    function call. We will discuss functions in more detail in [*Chapter 8*](B15554_08_Final_NM_ePub.xhtml#_idTextAnchor116),
    *Understanding Functions*. We can see that it is a function because it ends with
    parentheses. For now, we can regard these parentheses as an indication that something
    is a function. Calling a function means that, somewhere, there are several lines
    of code that have been given a name. Calling the function means that we will jump
    to that location and execute those lines. In this example, the content of the
    function is not visible. This function will halt the program until a signal comes
    in from the phone.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的第一行包含一个单独的语句。它是一个函数调用。我们将在[*第8章*](B15554_08_Final_NM_ePub.xhtml#_idTextAnchor116)中更详细地讨论函数，*理解函数*。我们可以看到它是一个函数，因为它以括号结束。现在，我们可以将这些括号视为表示某物是一个函数的指示。调用函数意味着，在某个地方，有若干行代码被赋予了一个名字。调用函数意味着我们将跳转到那个位置并执行那些行。在这个例子中，函数的内容是不可见的。这个函数将使程序停止，直到手机接收到信号。
- en: The statement on the second line is made up of one operation, with one operator
    and two operands. We recognize the equals sign as the assignment operator. That
    means that whatever is to the right will be assigned (remember that we can see
    an assignment because the thing to the right will be stored in the item to the
    left) to what's on the left-hand side. To the left, we have a variable that can
    contain a value. It has the name `current_time`. What we have to the right is
    another function call. This function will grab the current time and return it.
    When this statement has been executed, the present time will be stored in the
    `current_time` variable.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行的语句由一个操作组成，包含一个操作符和两个操作数。我们认出等号是赋值操作符。这意味着右边的任何内容都将被分配（记住，我们可以看到赋值，因为右边的将存储在左边的项中）到左边。在左边，我们有一个可以包含值的变量。它有一个名为`current_time`的名字。右边的是另一个函数调用。这个函数将获取当前时间并返回它。当这个语句执行后，当前时间将被存储在`current_time`变量中。
- en: Line 3 is like line 2\. This statement is also made up of one operator and two
    operands. The operand on the right is again a function call. This is the function
    that will contact the sunset service online and return the sunset time for our
    location. To the left, we have a `sunset_time` variable and we assign the time
    we get back from the function to this variable. When this statement has been executed,
    we have the sunset time stored in the `sunset_time` variable.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行类似于第二行。这个陈述也是由一个操作符和两个操作数组成的。右边的操作数再次是一个函数调用。这是将联系在线日落服务的函数，并为我们所在位置返回日落时间的函数。在左边，我们有一个名为`sunset_time`的变量，我们将从函数返回的时间赋值给这个变量。当这个语句执行后，我们将日落时间存储在`sunset_time`变量中。
- en: 'Line 4 starts with an `if`. This is a special kind of statement, spanning over
    several lines. This one covers lines 4 to 6\. It contains another statement, the
    one on line 5\. Line 4 is a condition. It checks whether the value in the `current_time`
    variable is greater than the value in the `sunset_time` variable. This can either
    be true or false. If it is greater, that is, the statement is true, then the code
    inside this compound statement is executed. If it is false, the value in `current_time`
    is not greater than the value in `sunset_time`; the code inside the statement
    will not be executed. In this case, the end of the compound statement is the last
    line: `end_if`. It indicates that everything between the line starting with `if`
    and the `end_if` line is a part of that statement. It should be noted that there
    is a flaw in the logic as this condition will not work if the current time is
    after midnight, but let''s ignore that for now.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第4行以`if`开始。这是一种特殊的语句，跨越多行。这个例子涵盖了第4到6行。它包含另一个语句，即第5行的语句。第4行是一个条件。它检查`current_time`变量中的值是否大于`sunset_time`变量中的值。这可能为真或为假。如果是大于，即语句为真，那么这个复合语句内部的代码将被执行。如果是假的，`current_time`中的值不大于`sunset_time`中的值；该语句内部的代码将不会执行。在这种情况下，复合语句的结束是最后一行：`end_if`。它表示从以`if`开头的行到`end_if`行之间的所有内容都是该语句的一部分。需要注意的是，逻辑上存在一个缺陷，因为这个条件在当前时间是午夜之后将不会工作，但现在我们先忽略这个问题。
- en: The statement on line 5 that turns on the light is yet again a call to a function.
    Also, note that this line starts with some spaces. This is called an indentation
    and is something we will discuss in more detail later in this chapter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第5行开启灯的语句再次是一个函数调用。此外，请注意，这一行以一些空格开头。这被称为缩进，我们将在本章后面更详细地讨论它。
- en: We now know that statements are made up of expressions or other statements.
    To be able to figure out where a statement ends and another begins, a language
    will define how they are separated. How this is done will be a part of the language
    syntax. Let's explore how we can do that next.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道，语句由表达式或其他语句组成。为了能够确定一个语句的结束和另一个语句的开始，一种语言将定义它们是如何分隔的。如何实现这将是语言语法的一部分。让我们接下来探索我们如何做到这一点。
- en: Separating statements
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分隔语句
- en: A programming language will separate statements by defining where a statement
    ends. If the language can figure out where one statement ends, it also knows that
    what comes after it must be the beginning of another statement.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一种编程语言将通过定义语句结束的位置来分隔语句。如果语言能够确定一个语句的结束位置，它也知道紧随其后的是什么必须是从另一个语句的开始。
- en: Languages have different ways to define this. If we compare how different languages
    terminate statements, we will see that we have three main ways for it to be done.
    Many languages will terminate a statement by inserting a new line. This means
    that, in general, every line is a single statement if it is not a compound statement,
    as it will need to be handled uniquely.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 语言有不同的方式来定义这一点。如果我们比较不同语言如何终止语句，我们会看到我们有三种主要的方式来实现它。许多语言将通过插入新行来终止语句。这意味着，一般来说，如果不是复合语句，每一行都是一个单独的语句，因为它需要被独特地处理。
- en: Another popular way to terminate statements is by using a semicolon, `;`. For
    languages that use this technique, we can have several statements on a single
    line. The language knows that a statement ends as soon as it sees a semicolon.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种流行的终止语句的方式是使用分号`；`。对于使用这种技术的语言，我们可以在单行上有多个语句。语言知道一个语句的结束是在它看到分号的那一刻。
- en: A third variant is to use a period, `.`, instead of a semicolon. Apart from
    that, it works the same way as when a semicolon is used so that we can have more
    than one statement on a single line.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个变体是使用句点`.`而不是分号。除此之外，它的工作方式与使用分号时相同，这样我们就可以在单行上有多个语句。
- en: A few languages will use other techniques, such as using a colon instead of
    a semicolon.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: A few languages will use other techniques, such as using a colon instead of
    a semicolon.
- en: 'Some languages that terminate statements with a new line include the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一些以新行终止语句的语言包括以下：
- en: BASIC
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BASIC
- en: Fortran
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fortran
- en: Python
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python
- en: Ruby
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby
- en: Visual Basic
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Basic
- en: 'Some languages that end statements with a semicolon include the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一些以分号结束语句的语言包括以下：
- en: C
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C
- en: C++
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++
- en: C#
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#
- en: Go (even if the compiler automatically inserts them)
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go（即使编译器会自动插入它们）
- en: Java
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java
- en: JavaScript
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript
- en: Kotlin
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin
- en: Pascal
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pascal
- en: PHP
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP
- en: Rust
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust
- en: 'Some languages that use other symbols to terminate statements include the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一些使用其他符号来终止语句的语言包括以下：
- en: ABAP (period)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ABAP（句点）
- en: COBOL (whitespace, such as a space, tab, or newline; sometimes, a period)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: COBOL（空白字符，如空格、制表符或换行符；有时，句号）
- en: Erlang (period, comma, and semicolon)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Erlang（句号、逗号和分号）
- en: Lua (whitespace such as a space, tab, or newline)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lua（空白字符，如空格、制表符或换行符）
- en: Prolog (comma, semicolon, and period)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prolog（逗号、分号和句号）
- en: For compound statements, we will need a way to define where they begin and where
    they end. As a compound statement is made up of one or more statements, many languages
    will use another method to terminate them.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复合语句，我们需要一种方法来定义它们的开始和结束位置。由于复合语句由一个或多个语句组成，许多语言将使用另一种方法来终止它们。
- en: Here, we will find three main techniques that languages use. One is to use curly
    brackets, `{}`, to indicate where a compound statement begins and ends. Everything
    that is placed between the brackets is considered to be part of the compound statement.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将找到语言使用的主要三种技术。一种是使用花括号 `{}` 来指示复合语句的开始和结束位置。括号之间放置的所有内容都被认为是复合语句的一部分。
- en: 'In such a language, the compound `if` statement that we saw in the preceding
    code should look like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的语言中，我们之前代码中看到的复合 `if` 语句应该看起来像这样：
- en: '[PRE8]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, there is an open bracket at the end of the first line and a
    closing bracket on the last line.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，第一行的末尾有一个开括号，最后一行有一个闭括号。
- en: 'Examples of languages that use this technique include the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术的语言示例包括以下：
- en: C
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C
- en: C++
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++
- en: C#
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#
- en: Go
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go
- en: Java
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java
- en: JavaScript
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript
- en: PHP
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP
- en: Another way to do this is to use end statements. Different languages will have
    slight variations on this.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现方式是使用结束语句。不同的语言对此会有细微的差别。
- en: Here are some examples.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些例子。
- en: 'In the Ada programming language, an `if` statement looks like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ada 编程语言中，一个 `if` 语句看起来是这样的：
- en: '[PRE9]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The same statement in Modula-2 is just slightly different:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Modula-2 中，同样的语句只是略有不同：
- en: '[PRE10]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Ruby has another variant that is along the same lines:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 有另一种与此类似的变体：
- en: '[PRE11]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The last variant is the language that will use indentation to accomplish the
    same thing. Remember that indentation is when we use a space to push in the code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种变体是使用缩进来完成同样功能的语言。记住，缩进是我们使用空格来推入代码的时候。
- en: If you look at all of the preceding examples, the line containing `turn_on_light`
    is always indented. In those languages, it is only because it makes the code easier
    to read for us as humans. However, some languages will use this to define where
    a compound statement begins and ends.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看所有前面的例子，包含 `turn_on_light` 的行总是缩进的。在这些语言中，这仅仅是因为它使代码对我们人类来说更容易阅读。然而，一些语言会使用这种方法来定义复合语句的开始和结束位置。
- en: 'One such language is Python. The code example for Python should look something
    like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种语言是 Python。Python 的代码示例应该看起来像这样：
- en: '[PRE12]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, everything that is indented is part of the compound statement. To indicate
    that something that comes afterward is not part of the statement, it would be
    written on the same level as the `if` statement, like so:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，所有缩进的都包含在复合语句中。为了表明随后出现的内容不是语句的一部分，它应该与 `if` 语句在同一级别上书写，如下所示：
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, the last line is not part of the compound statement as it is written without
    any indentation.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，最后一行不是复合语句的一部分，因为它没有缩进。
- en: As mentioned, an indentation can be used to make the code easier to read, while
    some languages will use it for compound statement termination. Let's go on to
    discuss why the readability of code is important and how we can use indentation
    and blank lines to improve it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，缩进可以用来使代码更容易阅读，而一些语言会使用它来终止复合语句。让我们继续讨论代码可读性的重要性以及我们如何使用缩进和空行来提高它。
- en: Making the code readable by indenting and using empty lines
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过缩进和使用空行使代码可读
- en: Ever since we moved away from machine code, the motivation has been that we
    want code that is easier to read and write for humans. We shall keep this in mind
    when we are writing code, as code does not just consist of instructions to the
    computer, but also something that needs to be maintained by either us or others.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我们远离机器代码以来，我们的动机就是希望代码对人类来说更容易阅读和编写。我们在编写代码时应该记住这一点，因为代码不仅仅是对计算机的指令，还需要我们或其他人维护。
- en: As we have learned, one tool that we can use to make the intentions of the code
    clearer to whoever reads it is indentation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，我们可以使用缩进来使代码的意图对阅读者更加清晰的一个工具是缩进。
- en: The indentation technique
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缩进技术
- en: 'Indentation is a technique that we use to show that certain code lines belong
    together in a block. This is typically done for compound statements. Since a compound
    statement can be constructed of other statements or other compound statements,
    indentation becomes essential to be able to see what code block a statement belongs
    to:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进是我们用来显示某些代码行在代码块中属于一起的技术。这通常用于复合语句。由于复合语句可以由其他语句或其他复合语句构成，因此缩进对于能够看到语句属于哪个代码块变得至关重要：
- en: '![Figure 5.12: Indented code will be a visual aid that indicates how compound
    statements are constructed](img/B15554_05_13.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图5.12：缩进代码将是一个视觉辅助工具，表明复合语句是如何构建的](img/B15554_05_13.jpg)'
- en: 'Figure 5.12: Indented code will be a visual aid that indicates how compound
    statements are constructed'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12：缩进代码将是一个视觉辅助工具，表明复合语句是如何构建的
- en: 'Even if the lines in the preceding diagram are just lines, we could make out
    the individual components they represent. If we color them, as in *figure 5.13*,
    we can see that this page is made up of four statements. The first line is a single
    statement, but then we have the green lines: these are compound statements, starting
    at line 2\. Again, the purple lines are compound statements and, in the end, we
    have a single line that makes up a one-line statement.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 即使前面的图中的线条只是线条，我们也能辨认出它们所代表的单个组件。如果我们像图5.13中那样给它们上色，我们可以看到这一页由四个语句组成。第一行是一个单行语句，然后我们有绿色线条：这些是复合语句，从第2行开始。再次，紫色线条是复合语句，最后我们有一个单行语句组成的一行。
- en: 'The dashed lines represent compound statements and are made up of single-line
    statements and a compound statement, as indicated by the indentation. It is the
    same thing with the dotted lines:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 虚线表示复合语句，由单行语句和复合语句组成，如缩进所示。点线也是同样的情况：
- en: '![Figure 5.13: The dashed lines are a compound statement containing another
    compound statement; the same is true for the dotted lines](img/B15554_05_14.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图5.13：虚线表示包含另一个复合语句的复合语句；同样适用于点线](img/B15554_05_14.jpg)'
- en: 'Figure 5.13: The dashed lines are a compound statement containing another compound
    statement; the same is true for the dotted lines'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13：虚线表示包含另一个复合语句的复合语句；同样适用于点线
- en: As you can see, the indentation will carry lots of information to the reader
    if we know how to interpret it. It is, therefore, crucial that we are careful
    to get the indentation right when writing our code. In most languages, this information
    is only interesting to human readers. The compiler or interpreter will ignore
    the indentation. But some languages, such as Python, use indentation as their
    tool to define compound statements, making the indentation mandatory and a part
    of the language's syntax.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，如果我们知道如何解释它，缩进将向读者传达大量信息。因此，在编写代码时，我们务必小心地正确处理缩进。在大多数语言中，这种信息只对人类读者有趣。编译器或解释器会忽略缩进。但有些语言，例如Python，使用缩进来定义复合语句，这使得缩进成为强制性的，并且是语言语法的一部分。
- en: Commonly, the text editor that a programmer uses to write the code will help
    with code indentation, either by automatically indenting code within a compound
    statement or by providing built-in commands that, when executed, will adequately
    format the code.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，程序员用来编写代码的文本编辑器会帮助进行代码缩进，要么通过自动缩进复合语句内的代码，要么通过提供内置命令，当执行时，将适当地格式化代码。
- en: There is another formatting trick that we can use to make our code more readable
    to humans. One such trick is the use of blank lines.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用另一种格式化技巧来使我们的代码对人类读者更易读。其中一个技巧就是使用空行。
- en: Blank lines
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空行
- en: Blank lines separate the paragraphs in this book. The reason is apparent. Without
    them, the text would be hard to read. These empty lines are not inserted at random.
    The text within a paragraph is logically connected. We can indicate that the text
    changes focus by creating a new paragraph, which is by inserting a blank line
    in the text.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 空行分隔本书中的段落。原因很明显。没有它们，文本将难以阅读。这些空行不是随机插入的。段落内的文本在逻辑上是相连的。我们可以通过创建一个新的段落来表示文本的焦点变化，即在文本中插入一个空行。
- en: The same thing applies to code. Blank lines are inserted for human readers.
    It is used to show the intent the programmer has. If three statements are somehow
    connected logically, we can indicate this by adding a blank line after the last
    statement.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的情况也适用于代码。空行是为了人类读者插入的。它用于显示程序员的目的。如果三个语句在逻辑上以某种方式相连，我们可以在最后一个语句后添加一个空行来表示这一点。
- en: 'The following is some Python code. It is not important to know what this code
    does, but look at the use of indentation and blank lines:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些Python代码。了解这段代码的功能并不重要，但请观察缩进和空行的使用：
- en: '[PRE14]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we can see that all the code is within one single compound statement as
    all lines, except the first, are indented. Further down, we can see other compound
    statements. Every time the indentation level increases, a new compound statement
    begins, and when it decreases, one ends.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到所有代码都在一个单独的复合语句中，除了第一行之外的所有行都进行了缩进。向下看，我们可以看到其他复合语句。每当缩进级别增加时，一个新的复合语句开始，当它减少时，一个结束。
- en: There are also some blank lines. This indicates that there is a logical connection
    between the lines preceding the empty line.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 同时也有一些空行。这表明空行前后的行之间存在逻辑联系。
- en: Let's take a look at lines 2 and 3 and how they are connected. In line 2, we
    are preparing some data so that it will be in the right form for what we want
    to do on line 3\. Here, we can see the importance of the sequence. Line 3 will
    require a number in a particular format. So, line 2 prepares the number so that
    it can be used on line 3\.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第2行和第3行以及它们是如何连接起来的。在第2行，我们准备了一些数据，以便它以正确的形式用于第3行的操作。在这里，我们可以看到序列的重要性。第3行需要一个特定格式的数字。因此，第2行准备了数字，以便在第3行使用。
- en: When these two lines are completed, the program changes its focus slightly.
    Even if we don't understand anything about what the code does, the information
    carried by the indentation and the blank lines will give us clues that will make
    it easier to read the code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当这两行完成时，程序会稍微改变其焦点。即使我们不了解代码的功能，缩进和空行所携带的信息将给我们提供线索，使代码更容易阅读。
- en: Blanks lines are also something that compilers and interpreters will ignore,
    so they are there for us humans. Just as it is vital to use paragraphs in a line
    of text correctly, we must use blank lines in a way that makes sense and assist
    the reader of our code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 空行也是编译器和解释器会忽略的内容，因此它们是为了我们人类而存在的。正如正确使用文本中的段落至关重要一样，我们必须以有意义的方式使用空行，以帮助我们的代码读者。
- en: There is another tool that we also can use to make things easier to understand
    for a human reading our code, and that is comments.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一个工具我们可以用来使我们的代码更容易被人阅读理解，那就是注释。
- en: Making the code understandable using comments
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用注释使代码可理解
- en: Indentation and blank lines are not always enough to make the intent of the
    code clear. In such cases, we can use comments. A comment is a line of normal
    text, inserted in the code, which is only for humans. We use them to explain lines
    of code that are not obviously understood at first glance.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进和空行并不总是足以使代码的意图清晰。在这种情况下，我们可以使用注释。注释是一行普通文本，插入到代码中，仅供人类阅读。我们使用它们来解释那些一眼看去并不明显易懂的代码行。
- en: As the compiler or interpreter ignores comments, we need a way to indicate that
    something is a comment. We have two variants of comments; one that runs to the
    end of the line, called a *line comment*, and one that spans multiple lines, often
    referred to as a *block comment*. Let's understand each in turn, in the following
    sections.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编译器或解释器会忽略注释，我们需要一种方式来指示某物是一个注释。我们有两种注释的变体；一种是从行尾开始，称为*行注释*，另一种是跨越多行，通常称为*块注释*。让我们依次了解以下内容。
- en: Line comments
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行注释
- en: A line comment has some symbols indicating the beginning of the comment, and
    it continues for the rest of that line. These can be inserted on a separate line
    or at the end of a line with code that will execute.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 行注释有一些符号表示注释的开始，并继续到该行的其余部分。这些可以插入到单独的一行或代码的末尾，该代码将执行。
- en: As a part of the language syntax, the symbol used to indicate the beginning
    of these comments is defined. Some are common, even if some languages will use
    more obscure variants.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 作为语言语法的一部分，用于指示这些注释开始的符号是定义好的。有些是通用的，尽管某些语言可能会使用更不常见的变体。
- en: The most common symbol used by many languages is a double slash, `//`, which
    is two slashes without any space between them. Even if this symbol is made up
    of two characters, it is treated as a single symbol.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言中最常用的符号是双斜杠`//`，它由两个没有空格的斜杠组成。即使这个符号由两个字符组成，它也被视为一个单独的符号。
- en: 'The languages that use this method for line comments include the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法进行行注释的语言包括以下内容：
- en: C
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C
- en: C++
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++
- en: C#
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#
- en: Go
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go
- en: Java
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java
- en: JavaScript
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript
- en: Kotlin
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin
- en: PHP
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP
- en: Another common symbol used by a number of languages is the hash symbol, `#`.
    Despite being a different symbol, it is handled in the same way as the double
    slash.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言使用的另一个常见符号是哈希符号 `#`。尽管这是一个不同的符号，但它的处理方式与双斜杠相同。
- en: 'The hash symbol is used for line comments by languages such as the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希符号被以下语言等用于行注释：
- en: Perl
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Perl
- en: Python
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python
- en: Ruby
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby
- en: Some languages have other ways to indicate a comment. In BASIC, the abbreviation
    `'`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言有其他表示注释的方法。在 BASIC 中，缩写为 `'`。
- en: The `⍝`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`⍝`。'
- en: Ada and Lua are two languages that use double hyphens, `--`, to indicate a line
    comment.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Ada 和 Lua 是两种使用双破折号 `--` 来表示行注释的语言。
- en: Haskell also uses this. Haskell also has another unique way to handle comments,
    called `>`. All other lines are considered to be comments.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 也使用这种方法。Haskell 还有另一种处理注释的独特方式，称为 `>`。所有其他行都被视为注释。
- en: Pascal, and languages closely related to Pascal, such as Modula-2, use `(*`
    to indicate the beginning of a comment and `*)` to mark the end.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Pascal 以及与 Pascal 密切相关的语言，如 Modula-2，使用 `(*` 来表示注释的开始，并用 `*)` 来标记结束。
- en: Languages that are related to Lisp, such as Common Lisp and Clojure, use a semicolon,
    `;`, to indicate line comments.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Lisp 相关的语言，如 Common Lisp 和 Clojure，使用分号 `;` 来表示行注释。
- en: 'Using line comments can look like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用行注释可能看起来像这样：
- en: '[PRE15]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first part is the normal code that will be executed, but as soon as the
    compiler or interpreter sees the comment symbol, `//`, it will ignore the rest
    of this line.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是正常执行的代码，但一旦编译器或解释器看到注释符号 `//`，它就会忽略这一行的其余部分。
- en: 'The same code in a language that uses the hash symbol for comments will look
    like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用哈希符号作为注释的语言中的相同代码将看起来像这样：
- en: '[PRE16]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'These comments can also be on a separate line like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这些注释也可以单独一行，如下所示：
- en: '[PRE17]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Alternatively, the comments can also appear like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，注释也可以这样出现：
- en: '[PRE18]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This separation will depend on the language.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分隔将取决于语言。
- en: Sometimes, we want a comment to span multiple lines. Instead of having a line
    comment symbol at the start of every line in the comment, we can use block comments.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望注释跨越多行。而不是在注释的每一行开始处都有行注释符号，我们可以使用块注释。
- en: Block comments
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 块注释
- en: Block comments have one symbol that indicates the beginning of the comment and
    another symbol that marks the end.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 块注释有一个符号表示注释的开始，另一个符号表示注释的结束。
- en: 'Languages that use the double slash symbol for line comments will often use
    `/*` to indicate the beginning of a block comment and `*/` to indicate the end.
    Languages that use these symbols include the following, among others:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 使用双斜杠符号作为行注释的语言通常会使用 `/*` 来表示块注释的开始，并用 `*/` 来表示结束。包括以下语言在内的这些符号包括：
- en: C
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C
- en: C++
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++
- en: C#
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#
- en: Go
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go
- en: Java
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java
- en: JavaScript
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript
- en: PHP
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP
- en: Perl uses `=begin` to indicate the start of a block comment and `=cut` to mark
    the end.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Perl 使用 `=begin` 来表示块注释的开始，并用 `=cut` 来标记结束。
- en: Ruby has a similar concept, with `=begin` and `=end` marking the beginning and
    end, respectively.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 有一个类似的概念，使用 `=begin` 和 `=end` 分别标记开始和结束。
- en: Python does not have a block comment but, instead, something called a `'''`
    or `"""`. They end with the same three characters that were used at the beginning.
    So, use three single quotes to end the comment if you used single quotes at the
    beginning; otherwise, use three double quotes.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Python 没有块注释，而是使用 `'''` 或 `"""` 这样的东西。它们以开始时使用的相同三个字符结束。所以，如果你在开始时使用了单引号，就使用三个单引号来结束注释；否则，使用三个双引号。
- en: 'In code, a block comment can look something like this if we use `/*` and `*/`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `/*` 和 `*/`，代码中的块注释可能看起来像这样：
- en: '[PRE19]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A programmer can also use several commonly used tags within comments to indicate
    certain things.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员也可以在注释中使用几个常用的标签来表示某些内容。
- en: Tags
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标签
- en: 'Sometimes, a programmer wants to mark a section in the code using a tag so
    that it is easy to find this location. These tags are informal, but some are commonly
    used:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，程序员想要使用标签标记代码中的某个部分，以便容易找到这个位置。这些标签是非正式的，但其中一些是常用的：
- en: '`BUG`: A known bug in the code that should be corrected.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUG`：代码中已知需要修正的错误。'
- en: '`FIXME`: Either a known bug or something else that must be corrected.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FIXME`：已知需要修正的错误或其他必须修正的内容。'
- en: '`HACK`: Marking a section of code that is not structured or written optimally
    and should be rewritten.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HACK`：标记一个结构不良或编写不优的代码部分，应该重写。'
- en: '`TODO`: This marks a location where something will be inserted later.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TODO`：标记一个稍后将要插入的位置。'
- en: These tags are written in comments and are mainly used so that they can be found
    with tools such as the Unix grep tool (a tool for searching in text files). Some
    programming editors will even highlight some of these tags.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标签写在注释中，主要用于使它们可以通过像Unix grep工具（一种在文本文件中进行搜索的工具）这样的工具找到。一些编程编辑器甚至会突出显示这些标签中的一些。
- en: Comments can also be used to remove code.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 注释也可以用来移除代码。
- en: Commenting out code
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释代码
- en: Sometimes, a programmer needs to remove a couple of lines of code to try something
    out or to isolate a bug. Instead of deleting these lines, they can be commented
    out with either a line comment or block comments. It is then easy to remove the
    comment symbol to make the code active again.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，程序员需要删除几行代码来尝试某事或隔离一个错误。而不是删除这些行，他们可以用行注释或块注释来注释掉这些行。这样，在需要再次使代码生效时，很容易移除注释符号。
- en: This technique can also be used if we are rewriting a code section. In that
    case, it is a good idea to have the old code as a reference when we are constructing
    the new code, so we don't forget something we need to do. We can place the old
    code in a comment; however, when we are done, we should remove the old commented
    out code as it will distract us when reading the code.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在重写代码部分，这个技术也可以使用。在这种情况下，当我们在构建新代码时，保留旧代码作为参考是一个好主意，这样我们就不会忘记需要做的事情。我们可以将旧代码放在注释中；然而，当我们完成时，我们应该移除旧的注释代码，因为它会在阅读代码时分散我们的注意力。
- en: The compiler or interpreter will ignore most comments, but not all. Some might
    have a special directive meaning.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器或解释器将忽略大多数注释，但并非全部。一些注释可能具有特殊的指令意义。
- en: Directive comments
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指令注释
- en: There are some examples where a comment can have a meaning for the language
    compiler or interpreter.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些例子表明，注释可以为语言编译器或解释器提供意义。
- en: Some languages, such as Python, can if we use it on a Unix system and use a
    symbol that looks like a comment on the first line in a code file. This symbol
    is called a *shebang* and is made up of the hash symbol followed by an exclamation
    mark, `#!`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言，如Python，如果我们在一个Unix系统上使用它，并在代码文件的第一行使用一个看起来像注释的符号，就可以这样做。这个符号被称为*shebang*，由一个井号符号后跟一个感叹号组成，即`#!`。
- en: This is used as an instruction, not to other humans, but to the Python interpreter
    so that it knows what version of Python should be used to interpret this program.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这被用作指令，不是给其他人类，而是给Python解释器，以便它知道应该使用哪个版本的Python来解释这个程序。
- en: Python also has something called a *magic comment*, which identifies the character
    encoding that the source code file is using. It begins with `# -*- coding:` and
    ends with `-*-`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Python还有一个叫做*魔法注释*的东西，它标识了源代码文件所使用的字符编码。它以`# -*- coding:`开始，以`-*-`结束。
- en: 'A Python program using both directives can start with two lines that look something
    like this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一个同时使用指令的Python程序可以以两行看起来像这样的代码开始：
- en: '[PRE20]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As Python uses `#` as the symbol for line comments, it might look like these
    are two normal comments. This can be a bit confusing when reading the code, and
    we should be aware that these are instructions to the interpreter and not to humans.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python使用`#`作为行注释的符号，它们可能看起来像是两个普通的注释。在阅读代码时，这可能会有些令人困惑，我们应该意识到这些是给解释器的指令，而不是给人类的。
- en: As you can see, comments can be used in several different ways. Let's take a
    look at some typical uses in more detail.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，注释可以用几种不同的方式使用。让我们更详细地看看一些典型的用法。
- en: Making use of comments
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用注释
- en: How to use comments in the best way is subject to dispute, and, often, you will
    get conflicting advice. Let's examine some typical uses before we discuss some
    of the opinions people have regarding comments.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如何最佳地使用注释是一个有争议的话题，通常你会得到相互矛盾的建议。在我们讨论人们对注释的一些看法之前，让我们先考察一些典型的用法。
- en: Planning and reviewing
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 规划和审查
- en: Comments can be used to plan the structure of the code before it is written.
    When writing an intricate part of an application, some people prefer to map out
    the logic with comments before focusing on the real code.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 注释可以在编写代码之前用来规划代码的结构。当编写应用程序的复杂部分时，有些人喜欢在专注于真实代码之前，用注释来绘制逻辑图。
- en: Code description
  id: totrans-299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码描述
- en: One everyday use of comments is to summarize what a section of code is doing
    and explain the programmer's intent. You should not use comments to rewrite what
    the code does in English. If you feel that you need to do that, the code is most
    likely too complicated and should be revised.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 注释的一个日常用途是总结代码部分的功能并解释程序员的意图。你不应该使用注释来用英语重写代码的功能。如果你觉得你需要这样做，那么代码可能过于复杂，应该进行修改。
- en: Algorithmic description
  id: totrans-301
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 算法描述
- en: 'Sometimes, we implement complex algorithms that need an explanation with maybe
    both text and diagrams. This is usually the prerequisite knowledge required to
    be able to understand the code. This can, sometimes, be rather extensive explanations.
    Look at the following diagram as an example. This comment is taken from a part
    of the Python language itself. If we count the number of lines that are comments
    in that module, we will see that they are over 77%:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们会实现需要用文本和图表进行解释的复杂算法。这通常是理解代码所需的基本知识。这些解释有时可能相当广泛。以下是一个示例。这个注释是从Python语言本身的一部分取出的。如果我们计算那个模块中注释的行数，我们会看到它们超过了77%：
- en: '![Figure 5.14: Example of comment describing the process.py module in the'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.14：描述Python编程语言中process.py模块的注释示例]'
- en: Python programming language](img/B15554_05_15.jpg)
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '[Python编程语言](img/B15554_05_15.jpg)'
- en: 'Figure 5.14: Example of comment describing the process.py module in the Python
    programming language'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14：描述Python编程语言中process.py模块的注释示例
- en: The Python language is open source, so anyone can look at or download the code
    for it. If you want to see what the code for a programming language looks like,
    you can view it at [https://github.com/python/cpython](https://github.com/python/cpython).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Python语言是开源的，所以任何人都可以查看或下载它的代码。如果你想看看编程语言的代码是什么样的，你可以在[https://github.com/python/cpython](https://github.com/python/cpython)查看。
- en: '**Comments controversy**'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**注释争议**'
- en: There is a never-ending debate regarding how and when comments should be used.
    Some people argue that code should be written using few comments, arguing that
    the source code should be written in a way so that it is self-explanatory or self-documenting.
    The motivation for this standpoint is that if you know a language, you should
    be able to understand the intent by just reading the code. If you can't, the code
    needs to be rewritten.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何以及何时使用注释的争论永无止境。有些人认为代码应该使用很少的注释，认为源代码应该以自解释或自文档化的方式编写。这种观点的动机是，如果你了解一种语言，你应该能够通过阅读代码来理解意图。如果你做不到，代码就需要重写。
- en: Others will argue that code should be extensively commented, as per the example
    in the preceding diagram.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 另一些人可能会争论，代码应该像前图所示那样进行广泛注释。
- en: In between these standpoints, you will find some that argue that comments, by
    themselves, are not beneficial nor harmful and should be used with care where
    they provide added value.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些观点之间，你会发现一些人认为注释本身既不有益也不有害，应该在使用时谨慎，只有在它们提供额外价值时才使用。
- en: So, to sum it up, in this section, we learned that comments are a tool to explain
    the code. But they are also used for documentation. Additionally, tags can be
    used to make notes of things that need to be dealt with in the future.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，在本节中，我们了解到注释是解释代码的工具。但它们也用于文档。此外，标签可以用来记录未来需要处理的事情。
- en: Summary
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, we discussed the most fundamental concept that we have in
    programming: a sequence.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了编程中最基本的概念：序列。
- en: Sequential thinking can help us structure our ideas so that we can break them
    down into smaller pieces. As we have mentioned in this chapter, grasping everything
    a program needs to do can be hard, so we need a way to be able to focus on the
    details without losing the overview of what the program needs to do.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序思维可以帮助我们组织思想，以便我们可以将它们分解成更小的部分。正如我们在本章中提到的，掌握程序需要做的一切可能很困难，因此我们需要一种方法来专注于细节，同时不失对程序需要做什么的整体了解。
- en: The concept of doing things in sequence is also at the very heart of any program,
    since the instructions we write are executed one after the other. This is important
    because we need to make sure that these instructions come in the right order.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序做事的概念也是任何程序的核心，因为我们写的指令是依次执行的。这很重要，因为我们需要确保这些指令的顺序是正确的。
- en: The instructions we write are made up of statements, and we learned that some
    statements are short and simple, while others can span several lines and be made
    up of other statements. Some are smaller building blocks, called expressions.
    We are now on an abstraction level where we can deal with details such as adding
    two numbers together.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的指令由语句组成，我们了解到有些语句简短且简单，而有些则可以跨越多行，由其他语句组成。有些是更小的构建块，被称为表达式。我们现在处于一个抽象级别，可以处理诸如将两个数字相加这样的细节。
- en: Breaking down the code into smaller and smaller chunks allows us to think about
    how to structure our solution. Sometimes, we will need to document our line of
    thought to help us or other readers of our code see what made us choose this solution.
    We learned that comments can be used for this.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码分解成越来越小的块，使我们能够思考如何构建我们的解决方案。有时，我们需要记录我们的思考过程，以帮助我们或其他读者了解我们选择这种解决方案的原因。我们了解到注释可以用于此目的。
- en: Comments can also be used as a documentation of the code so that it is clear
    what it does and how it can be used. Additionally, we saw that comments can be
    directed to the language compiler or interpreter to give instructions to it.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 注释也可以用作代码的文档，以便清楚地了解其功能和使用方法。此外，我们还看到注释可以指向语言编译器或解释器，以向其提供指令。
- en: As we know from previous chapters, a computer program takes data as its input,
    stores it in memory, processes this data, and produces new data as its output.
    Data is a key concept, so, in the next chapter, we will learn how to interact
    with it and why this type of data has such importance.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从前面的章节所知，计算机程序将数据作为其输入，将其存储在内存中，处理这些数据，并以新的数据作为其输出。数据是一个关键概念，因此，在下一章中，我们将学习如何与之交互以及为什么这种类型的数据如此重要。
