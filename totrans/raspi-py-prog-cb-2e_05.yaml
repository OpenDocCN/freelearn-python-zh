- en: Chapter 5. Creating 3D Graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with 3D coordinates and vertices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and importing 3D models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a 3D world to roam in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building 3D maps and mazes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chip at the heart of the original Raspberry Pi (a **Broadcom BCM2835** processor)
    was originally designed to be a **Graphical Processing Unit** (**GPU**) for mobile
    and embedded applications. The ARM core that drives most of the Raspberry Pi's
    functionality was added because some extra space was available on the chip; this
    enabled this powerful GPU to be used as a **System-On-Chip** (**SoC**) solution.
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine, if that original ARM core (**ARM1176JZF-S**, which is the
    **ARMv6** architecture) consisted of only a small part of the chip on the Raspberry
    Pi, you would be right in thinking that the GPU must perform rather well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The processor at the heart of the Raspberry Pi 3 has been upgraded (to a **Broadcom
    BCM2837** processor); it now contains four ARM cores (**Cortex A53 ARMv8A**),
    each of which are more powerful than the original **ARMv6**. Coupled with the
    same GPU from the previous generation, the Raspberry Pi 3 is far better equipped
    to perform the calculations required to build 3D environments. However, although
    the Raspberry Pi 3 will load the examples faster, once the 3D models are generated,
    both versions of the chip perform just as well.
  prefs: []
  type: TYPE_NORMAL
- en: The **VideoCore IV GPU** consists of 48 purpose-built processors, with some
    providing support for 1080p high-definition encoding and decoding of video, while
    others support **OpenGL ES 2.0**, which provides fast calculations for 3D graphics.
    It has been said that its graphics processing power is equivalent to that of an
    Apple iPhone 4s and also the original Microsoft Xbox. This is even more apparent
    if you run **Quake 3** or **OpenArena** on the Raspberry Pi (go to [http://www.raspberrypi.org/openarena-for-raspberry-pi](http://www.raspberrypi.org/openarena-for-raspberry-pi)
    for details).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I hope to show you that while you can achieve a lot by performing
    operations using the ARM side of the Raspberry Pi, if you venture into the side
    where the GPU is hidden, you may see that there is even more to this little computer
    than first appears.
  prefs: []
  type: TYPE_NORMAL
- en: The Pi3D library created by the Pi3D team (Patrick Gaunt, Tom Swirly, Tim Skillman,
    and others) provides a way to put the GPU to work by creating 3D graphics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Pi3D wiki and documentation pages can be found at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://pi3d.github.io/html/index.html](http://pi3d.github.io/html/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The support/development group can be found at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://groups.google.com/forum/#!forum/pi3d](https://groups.google.com/forum/#!forum/pi3d)'
  prefs: []
  type: TYPE_NORMAL
- en: The library contains many features, so it will not be possible to cover everything
    that is available in the following examples. It is recommended that you also take
    some time to try out the Pi3D demos. To discover more options for the creation
    and handling of the 3D graphics, you can have a look through some of the Python
    modules, which make up the library itself (described in the documentation or the
    code on GitHub at [https://github.com/pi3d/pi3d.github.com](https://github.com/pi3d/pi3d.github.com)).
    It is hoped that this chapter will introduce you to enough concepts to illustrate
    some of the raw potential available to you.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with 3D coordinates and vertices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The world around us is three-dimensional, so in order to simulate parts of the
    world, we can create a 3D representation and display it on our 2D screen.
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi enables us to simulate a 3D space, place 3D objects within
    it, and observe them from a selected viewpoint. We will use the GPU to produce
    a representation of the 3D view as a 2D image to display it on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The following example will show how we can use **Pi3D** (an OpenGL ES library
    for the Raspberry Pi) to place a single 3D object and display it within the 3D
    space. We will then allow the mouse to rotate the view around the object.
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting with 3D coordinates and vertices](img/6623_05_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Raspberry Pi must be directly connected to a display, either via the HDMI
    or an analog video output. The 3D graphics rendered by the GPU will only be displayed
    on a local display, even if you are connecting to the Raspberry Pi remotely over
    a network. You will also need to use a locally connected mouse for control (however,
    keyboard control does work via a SSH connection).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first time we use Pi3D, we will need to download and install it with the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The Pi3D library uses Pillow, a version of the Python Imaging Library that is
    compatible with Python 3, to import graphics used in models (such as textures
    and backgrounds).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The installation of Pillow has been covered in the *Getting ready* section of
    [Chapter 3](ch03.html "Chapter 3. Using Python for Automation and Productivity"),
    *Using Python for Automation and Productivity*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The commands for the installation are shown in the following code (if you''ve
    installed them before, it will skip them and continue):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now use PIP to install Pi3D using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The Pi3D team is continuously developing and improving the library; if you are
    experiencing problems, it may mean that a new release is not compatible with the
    previous ones.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also check in the [Appendix](apa.html "Appendix A. Hardware and Software
    List"), *Hardware and Software List*, to confirm which version of Pi3D you have
    and, if required, install the same version listed. Alternatively, contact the
    Pi3D team on the Google group; they will be happy to help!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Obtain Pi3D demos from the GitHub site, as shown in the following command lines.
    You will need around 90 MB of free space to download and extract the files:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will find that the demos have been unpacked to `pi3d_demos-master`. By
    default, the demos are expected to be located at `home/pi/pi3d`; therefore, we
    will rename this directory `pi3d`, as shown in the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, check the Raspberry Pi memory split. Run **raspi-config** (`sudo raspi-config`)
    and ensure that your memory split is set to 128\. (You should only need to do
    this if you have changed it in the past, as 128 MB is the default.) This ensures
    that you have plenty of RAM allocated for the GPU, so it will be able to handle
    lots of 3D objects if required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Test if everything is working properly. You should now be able to run any of
    the scripts in the `pi3d_demos-master` directory. See the Pi3D wiki pages for
    details of how they function ([http://pi3d.github.io/html/ReadMe.html](http://pi3d.github.io/html/ReadMe.html)).
    To get the best performance, it is recommended that the scripts are run from the
    command prompt (without loading the desktop):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Many of the demos require mouse and keyboard control.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Although it would be perfectly reasonable to use the methods from [Chapter 4](ch04.html
    "Chapter 4. Creating Games and Graphics"), *Creating Games and Graphics*, for
    mouse and keyboard input using **Tkinter**, many of the demos in the Pi3D library
    use **pi3d.Keyboard** and **pi3d.Mouse** objects to provide additional support
    for joysticks and gamepads. The **pi3d.Keyboard** object also supports keyboard
    control via SSH (see the *Connecting remotely to the Raspberry Pi over the network
    using SSH (and X11 Forwarding)* section of [Chapter 1](ch01.html "Chapter 1. Getting
    Started with a Raspberry Pi Computer"), *Getting Started with a Raspberry Pi Computer*).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Configure the setup for your own scripts. Since we will use some of the textures
    and models from the demos, it is recommended that you create your scripts within
    the `pi3d` directory. If you have a username that''s different from the default
    Pi account, you will need to adjust `/pi3d/demo.py`. Replace the `USERNAME` part
    with your own username by editing the file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you want to relocate your files somewhere else, ensure that you add a copy
    of `demo.py` in the folder with the correct path to any resource files you require.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create the following `3dObject.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To run the script, use `python3 3dObject.py`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We import the math modules (for angle calculations—used to control the view
    based on mouse movements). We also import the demo module, which just provides
    the path to the **shaders** and **textures** in this example.
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining some key elements that will be used by Pi3D to generate
    and display our object. The space in which we shall place our object is the `pi3d.Display`
    object; this defines the size of the space and initializes the screen to generate
    and display OpenGL ES graphics.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define a `pi3d.Camera` object, which will allow us to define how we
    view the object within our space. To render our object, we define a texture to
    be applied to the surface and a shader that will apply the texture to the object.
    The shader is used to apply all the effects and lighting to the object, and it
    is coded to use the GPU's OpenGL ES core instead of the ARM processor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the `keyboard` and `mouse` object using `pi3d.keyboard()` and `pi3d.mouse()`
    so that we can respond to the keyboard and mouse input. The `restrict` flag of
    the `mouse` object allows the absolute mouse position to continue past the screen
    limits (so we can continuously rotate our 3D object). The main loop, when running,
    will check if the *Esc* key is pressed and then close everything down (including
    calling `DISPLAY.destroy()` to release the screen). We use the `try: finally:`
    method to ensure that the display is closed correctly even if there is an exception
    within `main()`.'
  prefs: []
  type: TYPE_NORMAL
- en: The mouse movement is collected in the main display loop using `mymouse.position()`,
    which returns the *x* and *y* coordinates. The difference in the *x* and *y* movement
    is used to rotate around the object.
  prefs: []
  type: TYPE_NORMAL
- en: The mouse movements determine the position and angle of the camera. Any adjustment
    to the forward/backward position of the mouse is used to move it over or under
    the object and change the angle of the camera (using `tilt`) so it remains pointing
    at the object. Similarly, any sideways movement will move the camera around the
    object using the `CAMERA.reset()` function. This ensures that the display updates
    the camera view with the new position, `CAMERA.rotate()`, to change the angle
    and uses `CAMERA.position()` to move the camera to a position around the object,
    `camRad` units away from its center.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will draw a three-dimensional object called a **tetrahedron**, a shape made
    up of four triangles to form a pyramid with a triangular base. The four corners
    of the shape (three around the base and one at the top) will be defined by the
    three-dimensional coordinates A, B, C, and D, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/6623_05_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The tetrahedron placed within the X, Y, and Z axes
  prefs: []
  type: TYPE_NORMAL
- en: The `pi3d.Tetrahedron` object is defined by specifying coordinates to position
    it in the space and then specify the corners that will be joined to form the four
    triangles that make up the shape.
  prefs: []
  type: TYPE_NORMAL
- en: Using `set_draw_details(flatsh,[text])`, we apply the shader(s) we wish to use
    and the texture(s) for the object. In our example, we are just using a single
    texture, but some shaders can use several textures for complex effects.
  prefs: []
  type: TYPE_NORMAL
- en: To help highlight where the coordinates are, we will add some `pi3d.String`
    objects by setting the string text to specify the ID and coordinates next to them
    and placing it at the required location. We will create two string objects for
    each location, one facing forward and another facing backwards (`ry=180` rotates
    the object by 180 degrees on the y axis). The `pi3d.String` objects are single-sided,
    so if we only had one side facing forward, it wouldn't be visible from behind
    when the view was rotated and would just disappear (plus, if it was visible, the
    text would be backwards anyway). Again, we use the `flatsh` shader to render it
    using the `set_shader()` string object.
  prefs: []
  type: TYPE_NORMAL
- en: All that is left to do now is to draw our tetrahedron and the string objects
    while checking for any keyboard events. Each time the `while` loop completes,
    `DISPLAY.loop_running()` is called, which will update the display with any adjustments
    to the camera as required.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to introducing how to draw a basic object within the 3D space, the
    preceding example makes use of the following four key elements used in 3D graphics
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Camera
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The camera represents our view in the 3D space; one way to explore and see
    more of the space is by moving the camera. The `Camera` class is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The camera is defined by providing two locations, one to look at (usually the
    object we wish to see—defined by `at`) and another to look from (the object's
    position—defined by `eye`). Other features of the camera, such as its field of
    view (`lens`) and so on, can be adjusted or used with the default settings.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we didn't define a camera in our display, a default one will be created that
    points at the origin (the center of the display, that is, `0,0,0`), positioned
    slightly in front of it (`0,0,-0.1`).
  prefs: []
  type: TYPE_NORMAL
- en: See the Pi3D documentation regarding the camera module for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Shaders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Shaders are very useful as they allow a lot of the complex work required to
    apply textures and lighting to an object by offloading the task to the more powerful
    GPU in the Raspberry Pi. The Shader class is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This allows you to specify a shader file (`shfile`) and specific vertex and
    fragment shaders (if required) within the file.
  prefs: []
  type: TYPE_NORMAL
- en: There are several shaders included in the Pi3D library, some of which allow
    multiple textures to be used for reflections, close-up details, and transparency
    effects. The implementation of the shader will determine how the lights and textures
    are applied to the object (and in some cases, such as `uv_flat`, the shader will
    ignore any lighting effects).
  prefs: []
  type: TYPE_NORMAL
- en: The shader files are listed in the `pi3d\shaders` directory. Try experimenting
    with different shaders, such as `mat_reflect`, which will ignore the textures/fonts
    but still apply the lighting effects; or `uv_toon`, which will apply a cartoon
    effect to the texture.
  prefs: []
  type: TYPE_NORMAL
- en: Each shader consists of two files, `vs` (vertex shader) and `fs` (fragment shader),
    written in C-like code. They work together to apply the effects to the object
    as desired. The vertex shader is responsible for mapping the 3D location of the
    vertices to the 2D display. The fragment shader (or sometimes called the pixel
    shader) is responsible for applying lighting and texture effects to the pixels
    themselves. The construction and operation of these shaders is well beyond the
    scope of this chapter, but there are several example shaders that you can compare,
    change, and experiment with within the `pi3d\shaders` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Lights
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lighting is very important in a 3D world; it could range from simple general
    lighting (as used in our example) to multiple lights angled from different directions
    providing different strengths and colors. How lights interact with objects and
    the effects they produce will be determined by the textures and shaders used to
    render them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lights are defined by their direction, their color and brightness, and also
    by an ambient light to define the background (non-directional) light. The `Light`
    class is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, the display will define a light that has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lightpos=(10, -10, 20)`: This is a light that shines from the front of the
    space (near the top-left side) down towards the back of the space (towards the
    right).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lightcol=(1.0, 1.0, 1.0)`: This is a bright, white, directional light (the
    direction is defined in the preceding dimension, and it is the color defined by
    the RGB values `1.0, 1.0, 1.0`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lightamb=(0.1, 0.1, 0.2)`: This is overall a dull, slightly bluish light.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Textures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Textures are able to add realism to an object by allowing fine detail to be
    applied to the object's surface; this could be an image of bricks for a wall or
    a person's face to be displayed on the character. When a texture is used by the
    shader, it can often be re-scaled and reflection can be added to it; some shaders
    even allow you to apply surface detail.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can apply multiple textures to an object to combine them and produce different
    effects; it will be up to the shader to determine how they are applied.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and importing 3D models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating complex shapes directly from code can often be cumbersome and time
    consuming. Fortunately, it is possible to import prebuilt models into your 3D
    space.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is even possible to use graphical 3D modeling programs to generate models
    and then export them as a suitable format for you to use. This example produces
    a Newell Teapot in the Raspberry Pi theme, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and importing 3D models](img/6623_05_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Newell Raspberry Pi teapot
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We shall use 3D models of a teapot (both `teapot.obj` and `teapot.mdl`) located
    in `pi3d\models`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modeling a teapot is the traditional 3D equivalent of displaying *Hello World*.
    Computer graphics researcher Martin Newell first created the Newell Teapot in
    1975 as a basic test model for his work. The Newell Teapot soon became the standard
    model to quickly check if a 3D rendering system is working correctly (it even
    appeared in Toy Story and a 3D episode of The Simpsons).
  prefs: []
  type: TYPE_NORMAL
- en: Other models are available in the `pi3d\models` directory (`monkey.obj/mdl`,
    which has been used later on, is available in the book's resource files).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create and run the following `3dModel.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like the `3dObject.py` example, we define the `DISPLAY` shader (this time using
    `uv_reflect`) and some additional textures—`bumptex` (`floor_nm.jpg`) and `shinetex`
    (`stars.jpg`)—to use later. We define a model that we want to import, placing
    it at `z=10` (if no coordinates are given, it will be placed at `(0,0,0)`. Since
    we do not specify a camera position, the default will place it within the view
    (see the section regarding the camera for more details).
  prefs: []
  type: TYPE_NORMAL
- en: We apply the shader using the `set_shader()` function. Next, we add some textures
    and effects using `bumptex` as a surface texture (scaled by `4`). We apply an
    extra shiny effect using `shinetex` and apply a reflection strength of `0.5` (the
    strength ranges from 0.0, the weakest, to 1.0, the strongest) using the `set_normal_shine()`
    function. If you look closely at the surface of the model, the `bumptex` texture
    provides additional surface detail and the `shinetex` texture can be seen as the
    reflection on the surface.
  prefs: []
  type: TYPE_NORMAL
- en: To display our model within something more interesting than a default blue space,
    we create an `EnvironmentCube` object. This defines a large space that has a special
    texture applied to the inside space (in this instance, it will load the `sbox_front/back/bottom/left`
    and `sbox_right` images from the `textures\ecubes` directory), so it effectively
    encloses the objects within. The result is that you get a pleasant backdrop for
    your object.
  prefs: []
  type: TYPE_NORMAL
- en: Again, we define a default `CAMERA` object with `rot` and `tilt` variables to
    control the view. Within the `DISPLAY.loop_running()` section, we can control
    the view of the `CAMERA` object using the mouse and rotate the model on its axis
    at different rates to let it spin and show all its sides (using the `RotateIncX/Y/Z()`
    function to specify the rate of rotation). Finally, we ensure that the `DISPLAY`
    is updated by drawing the model and the environment cube.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can create a wide range of objects to place within our simulated environment.
    Pi3D provides methods to import our own models and apply multiple textures to
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating or loading your own objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you wish to use your own models in this example, you shall need to create
    one in the correct format; Pi3D supports **obj** (wavefront object files) and
    **egg** (Panda3D).
  prefs: []
  type: TYPE_NORMAL
- en: An excellent, free, 3D modeling program is called **Blender** (available at
    [http://www.blender.org](http://www.blender.org)). There are lots of examples
    and tutorials on their website to get you started with basic modeling ([http://www.blender.org/education-help/tutorials](http://www.blender.org/education-help/tutorials)).
  prefs: []
  type: TYPE_NORMAL
- en: Pi3D model support is limited and will not support all the features that Blender
    can embed in an exported model, for example, deformable meshes. Therefore, only
    basic multipart models are supported. There are a few steps required to simplify
    the model so it can be loaded by Pi3D.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert an `.obj` model to use with Pi3D, proceed with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create or load a model in Blender—try starting with a simple object before attempting
    more complex models.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select each **Object** and switch to **Edit** mode (press *Tab*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select all vertices (press *A*) and uv-map them (press *U* and then select **Unwrap**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to **Object** mode (press *Tab*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Export it as **obj**—from the **File** menu at the top, select **Export** and
    then **Wavefront (.obj)**. Ensure that **Include Normals** is also checked in
    the list of options in the bottom-left list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on **Save** and place the `.obj` and `.mtl` files in the `pi3d\models`
    directory, and ensure that you update the script with the model''s filename, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you run your updated script, you will see your model displayed in the
    3D space. For example, the `monkey.obj` model is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating or loading your own objects](img/6623_05_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A monkey head model created in Blender and displayed by Pi3D
  prefs: []
  type: TYPE_NORMAL
- en: Changing the object's textures and .mtl files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The texture that is applied to the surface of the model is contained within
    the `.mtl` file of the model. This file defines the textures and how they are
    applied as set by the modeling software. Complex models may contain multiple textures
    for various parts of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'If no material is defined, the first texture in the shader is used (in our
    example, this is the `bumptex` texture). To add a new texture to the object, add
    (or edit) the following line in the `.mtl` file (that is, to use `water.jpg`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'More information about `.mtl` files and `.obj` files can be found at the following
    Wikipedia link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Wavefront_.obj_file](https://en.wikipedia.org/wiki/Wavefront_.obj_file)'
  prefs: []
  type: TYPE_NORMAL
- en: Taking screenshots
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Pi3D library includes a useful screenshot function to capture the screen
    in a `.jpg` or `.png` file. We can add a new key event to trigger it and call
    `pi3d.screenshot("filename.jpg")` to save an image (or use a counter to take multiple
    screenshots), as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Creating a 3D world to roam in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are able to create models and objects within our 3D space, as well
    as generate backgrounds, we may want to create a more interesting environment
    within which to place them.
  prefs: []
  type: TYPE_NORMAL
- en: '3D terrain maps provide an elegant way to define very complex landscapes. The
    terrain is defined using a grayscale image to set the elevation of the land. The
    following example shows how we can define our own landscape and simulate flying
    over it, or even walk on its surface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a 3D world to roam in](img/6623_05_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A 3D landscape generated from a terrain map
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to place the `Map.png` file (available in the book resource files)
    in the `pi3d/textures` directory of the Pi3D library. Alternatively, you can use
    one of the elevation maps already present—replace the reference to `Map.png` with
    another one of the elevation maps, such as `testislands.jpg`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create the following `3dWorld.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have defined the display, camera, textures, and shaders that we are
    going to use, we can define the `ElevationMap` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'It works by assigning a height to the terrain image based on the pixel value
    of selected points of the image. For example, a single line of an image will provide
    a slice of the `ElevationMap` object and a row of elevation points on the 3D surface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/6623_05_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mapping the map.png pixel shade to the terrain height
  prefs: []
  type: TYPE_NORMAL
- en: 'We create an `ElevationMap` object by providing the filename of the image we
    will use for the gradient information (`textures/Map.png`), and we also create
    the dimensions of the map (`width`, `depth`, and `height`—which is how high the
    white spaces will be compared to the black spaces):'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/6623_05_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The light parts of the map will create high points and the dark ones will create
    low points
  prefs: []
  type: TYPE_NORMAL
- en: The `Map.png` texture provides an example terrain map, which is converted into
    a three-dimensional surface.
  prefs: []
  type: TYPE_NORMAL
- en: We also specify `divx` and `divy`, which determine how much detail of the terrain
    map is used (how many points from the terrain map are used to create the elevation
    surface). Finally, `ntiles` specifies that the texture used will be scaled to
    fit `20 times` across the surface.
  prefs: []
  type: TYPE_NORMAL
- en: Within the main `DISPLAY.loop_running()` section, we will control the camera,
    draw `ElevationMap`, respond to inputs, and limit movements in our space.
  prefs: []
  type: TYPE_NORMAL
- en: As before, we use a `Keyboard` object to capture mouse movements and translate
    them to control the camera. We will also use `mykeys.read()` to determine if *W*,
    *S*, *R*, and *T* have been pressed, which allow us to move forward and backwards,
    as well as rise up and down.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To allow easy conversion between the values returned from the `Keyboard` object
    and their equivalent meaning, we will use a Python dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '`KEY = {''R'':114,''S'':115,''T'':116,''W'':119,''ESC'':27,''NONE'':-1}`'
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary provides an easy way to translate between a given value and the
    resulting string. To access a key's value, we use `KEY['W']`. We also used a dictionary
    in [Chapter 3](ch03.html "Chapter 3. Using Python for Automation and Productivity"),
    *Displaying Photo Information in an Application*, to translate between the image
    Exif TAG names and IDs.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that we do not fall through the surface of the `ElevationMap` object
    when we move over it, we can use `mymap.calcHeight()` to provide us with the height
    of the terrain at a specific location (`x,y,z`). We can either follow the ground
    by ensuring the camera is set to equal this, or fly through the air by just ensuring
    that we never go below it. When we detect that we are on the ground, we ensure
    that we remain on the ground until we press *R* to rise again.
  prefs: []
  type: TYPE_NORMAL
- en: Building 3D maps and mazes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen that the Pi3D library can be used to create lots of interesting objects
    and environments. Using some of the more complex classes (or by constructing our
    own), whole custom spaces can be designed for the user to explore.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we use a special module called **Building**, which
    has been designed to allow you to construct a whole building using a single image
    file to provide the layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building 3D maps and mazes](img/6623_05_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Explore the maze and find the sphere that marks the exit
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need to ensure that you have the following files in the `pi3d/textures`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`squareblocksred.png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`floor.png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inside_map0.png, inside_map1.png, inside_map2.png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These files are available as part of the book's resources placed in `Chapter05\resource\source_files\textures`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s run the following `3dMaze.py` script by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we set up the keyboard, mouse, display, and settings for the model using
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then create functions to allow us to reload the levels and display messages
    to the player using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the main function, we set up the 3D environment and draw all the objects
    using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we monitor for key presses, handle any collisions with objects, and
    move within the maze as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We define many of the elements we used in the preceding examples, such as the
    display, textures, shaders, font, and lighting. We also define the objects, such
    as the building itself, the `ElevationMap` object, as well as the start and end
    points of the maze. We also use **SolidObjects** to help detect movement within
    the space. See the *Using SolidObjects to detect collisions* subsection in the
    *There's more…* section of this recipe for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we create the actual `Building` object based on the selected map image
    (using the `loadLevel()` function) and locate the camera (which represents our
    first-person viewpoint) at the start. See the *The Building module* subsection
    in the *There's more…* section of this recipe for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `main` loop, we draw all the objects in our space and apply the lighting
    effects. We will also monitor for movement in the mouse (to control the tilt and
    rotation of the camera) or the keyboard to move the player (or exit/provide help).
  prefs: []
  type: TYPE_NORMAL
- en: 'The controls are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mouse movement**: This changes the camera tilt and rotation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**'' or / key**: This changes the camera to tilt either downwards or upwards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A or D**: This changes the camera to rotate from left to right or vice versa.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**W or S**: This moves the player forwards or backwards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**H**: This helps the player by rotating them to face the end of the maze.
    The useful `CAMERA.point_at()` function is used to quickly rotate and tilt the
    camera''s viewpoint towards the provided coordinates (the end position).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever the player moves, we check if the new position (`NewPos`) collides
    with another `SolidObject` using `CollisionList(NewPos)`. The function will return
    a list of any other SolidObjects that overlap the coordinates provided.
  prefs: []
  type: TYPE_NORMAL
- en: If there are no SolidObjects in the way, we make the player move; otherwise,
    we check to see if one of the SolidObject's names is the `end` object, in which
    case we have reached the end of the maze.
  prefs: []
  type: TYPE_NORMAL
- en: When the player reaches the end, we remove the walls from the old `Building`
    object and display a loading message. If we don't remove the walls, all the SolidObjects
    belonging to the previous `Building` will still remain, creating invisible obstacles
    in the next level.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `showMessage()` function to inform the user that the next level will
    be loaded soon (since it can take a while for the building object to be constructed).
    We need to ensure that we call `DISPLAY.loop_running()` after we draw the message.
    This ensures it is displayed on screen before we start loading the level (after
    which the person will be unable to move while loading takes place). We need to
    ensure that the message is always facing the player regardless of which of their
    sides collides with the `end` object by using the camera rotation (`rot`) for
    its angle.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/6623_05_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the exit ball is found, the next level is loaded
  prefs: []
  type: TYPE_NORMAL
- en: When the next level in the list has been loaded (or the first level has been
    loaded again when all the levels have been completed), we replace the message
    with a blank one to remove it and reset the person's position back to the start.
  prefs: []
  type: TYPE_NORMAL
- en: You can design and add your own levels by creating additional map files (20
    x 20 PNG files with walls marked out with black pixels and walkways in white)
    and listing them in `levelList`. The player will start at the top-left corner
    of the map, and the exit is placed at the center.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that loading the levels can take quite a long time; this is
    the relatively slow ARM processor in the Raspberry Pi performing all the calculations
    required to construct the maze and locate all the components. As soon as the maze
    has been built, the more powerful GPU takes over, which results in fast and smooth
    graphics as the player explores the space.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe demonstrates the difference between the original Raspberry Pi processor
    and the Raspberry Pi 2\. The Raspberry Pi 2 takes around 1 minute 20 seconds to
    load the first level, while the original Raspberry Pi can take up to 4 minutes
    20 seconds. The Raspberry Pi 3 takes a stunning 4 seconds to load the same level.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding example creates a building for the player to explore and interact
    with. In order to achieve this, we use the `Building` module of Pi3D to create
    a building and use `SolidObject` to detect collisions.
  prefs: []
  type: TYPE_NORMAL
- en: The Building module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `pi3d.Building` module allows you to define a whole level or floor of a
    building using map files. Like the terrain maps used in the preceding example,
    the color of the pixels will be converted into different parts of the level. In
    our case, black is for the walls and white is for the passages and halls, complete
    with ceilings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Building module](img/6623_05_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The building layout is defined by the pixels in the image
  prefs: []
  type: TYPE_NORMAL
- en: 'The sections built by the `Building` object are defined by the **Scheme** used.
    The `Scheme` is defined by two sections, by the number of models, and then by
    the definitions for various aspects of the model, as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first **tuple** defines the type of cell/square that the selected model
    should be applied to. Since there are two pixel colors in the map, the squares
    will either be black (`0`) or white (`1`). By determining the position and type
    of a particular cell/square, we can define which models (wall, ceiling, or roof)
    we want to apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define three main types of cell/square location:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A whole square `(1,None)`: This is a white cell representing open space in
    the building.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One cell bordering another, on the edge `(0,1,"edge")`: This is a black cell
    next to a white one on the map edge. This also includes `(1,0,"edge")`. This will
    represent the outer wall of the building.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Any black cell that is next to a white cell `(0,1)`: This will represent all
    the internal walls of the building.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we allocate a type of object(s) to be applied for that type (`W` or `C`):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wall** (`W`): This is a vertical wall that is placed between the specified
    cells (such as between black and white cells).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ceiling** (`C`): This is a horizontal section of the ceiling to cover the
    current cell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Roof** (`R`): This is an additional horizontal section that is placed slightly
    above the ceiling to provide a roofing effect. It is typically used for buildings
    that may need to be viewed from the outside (this is not used in our example).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ceiling Edge** (`CE`): This is used to join the ceiling sections to the roof
    around the edges of the building (it is not used in our example since ours is
    an indoor model).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we specify the model that will be used for each object. We are using
    three models in this example (normal walls, walls on an edge, and the ceiling),
    so we can define the model used by specifying `0`, `1`, or `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the models are defined in the `details` array, which allows us to set
    the required textures and shaders for each one (this contains the same information
    that would normally be set by the `.set_draw_details()` function), as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, the inside walls are allocated to the `wallimg` texture (`textures/squareblocksred.png`)
    and the ceilings are allocated to the `ceilingimg` texture (`textures/squareblocks4.png`).
    You may be able to note from the following screenshot that we can apply different
    texture models (in our case, a slightly different scaling) to the different types
    of blocks. The walls that border the outside of the maze (with the edge identifier)
    will use the `wallimg` model texture scaled by 4x8 (`details[1]`) while the same
    model texture will be scaled 4x16 for the internal walls (`details[0]`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Building module](img/6623_05_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The outward facing wall on the left has a different scaling applied compared
    to the other walls
  prefs: []
  type: TYPE_NORMAL
- en: 'Both `scheme` and `draw_details` are set when the `pi3d.Building` object is
    created, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the map file (`levelList[next_level`]), the scheme (`mazeScheme`), and
    draw details (`details`), the entire building is created within the environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Building module](img/6623_05_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An overhead view of the 3D maze we created
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although we use just black and white in this example, other colored pixels can
    also be used to define additional block types (and therefore different textures,
    if required). If another color (such as gray) is added, the indexing of the color
    mapping is shifted so that black blocks are referenced as `0`, the new colored
    blocks as `1`, and the white blocks as `2`. See the **Silo** example in the Pi3D
    demos for details.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to define an `ElevationMap` object—`mymap`. The `pi3d.Building`
    module makes use of the `ElevationMap` object's `calcHeight()` function to correctly
    place the walls on top of the `ElevationMap` object's surface. In this example,
    we will apply a basic `ElevationMap` object using `textures/floor.png`, which
    will generate a flat surface that the `Building` object will be placed on.
  prefs: []
  type: TYPE_NORMAL
- en: Using SolidObjects to detect collisions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to the `Building` object, we will define an object for the player
    and also define two objects to mark the start and end points of the maze. Although
    the player's view is the first-person viewpoint (that is, we don't actually see
    them since the view is effectively through their eyes), we need to define a **SolidObject**
    to represent them.
  prefs: []
  type: TYPE_NORMAL
- en: A SolidObject is a special type of invisible object that can be checked to determine
    if the space that would be occupied by one SolidObject has overlapped another.
    This will allow us to use `person.CollisionList(NewPos)` to get a list of any
    other SolidObjects that the `person` object will be in contact with at the `NewPos`
    position. Since the `Building` class defines SolidObjects for all the parts of
    the `Building` object, we will be able to detect when the player tries to move
    through a wall (or, for some reason, the roof/ceiling) and stop them from moving
    through it.
  prefs: []
  type: TYPE_NORMAL
- en: We also use SolidObjects for the start and end locations in the maze. The place
    where the player starts is set as the top-left corner of the map (the white-space
    pixel from the top left of the map) and is marked by the `startpos` object (a
    small `pi3d.Sphere` with the `rock1.jpg` texture) placed above the person's head.
    The end of the maze is marked with another `pi3d.Sphere` object (with the `water.jpg`
    texture) located at the center of the map. We also define another SolidObject
    at the end so that we can detect when the player reaches it and collides with
    it (and load the next level!).
  prefs: []
  type: TYPE_NORMAL
