- en: <st c="0">5</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">5</st>
- en: <st c="2">Building Asynchronous Transactions</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">构建异步事务</st>
- en: <st c="36">After rigorous discussion on the core components and advanced features
    of the Flask 3.0 framework, this chapter will explore Flask’s capability to manage
    requests and responses asynchronously and its ability to execute asynchronous
    services and</st> <st c="282">repository transactions.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36">在详细讨论了Flask 3.0框架的核心组件和高级特性之后，本章将探讨Flask管理请求和响应的异步能力以及其执行异步服务和</st>
    <st c="282">存储库事务的能力。</st>
- en: <st c="306">Flask was originally a standard Python framework that ran on the</st>
    `<st c="589">asyncio</st>` <st c="596">utilities and build asynchronous repository
    transactions with</st> <st c="659">SQLAlchemy 2.x.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="306">Flask最初是一个在</st> `<st c="589">asyncio</st>` <st c="596">工具上运行的</st>
    `<st c="659">SQLAlchemy 2.x</st>` <st c="596">构建异步存储库事务的标准Python框架。</st>
- en: <st c="674">This chapter will also explore other avenues that help provide Flask
    applications with the fastest performance using asynchronous mechanisms, such
    as Celery tasks, task queues, WebSocket, and server push.</st> <st c="880">The
    chapter will also introduce</st> **<st c="912">Quart</st>**<st c="917">, the asynchronous
    Flask-based platform that can build and run all components asynchronously compared
    to the original</st> <st c="1035">Flask framework.</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="674">本章还将探讨其他途径，帮助Flask应用程序通过异步机制获得最快的性能，例如Celery任务、任务队列、WebSocket和服务器推送。</st>
    <st c="880">本章还将介绍</st> **<st c="912">Quart</st>**<st c="917">，这是一个基于异步的Flask平台，可以与原始的</st>
    `<st c="1035">Flask框架</st>` <st c="917">相比，构建和运行所有组件都是异步的。</st>
- en: <st c="1051">Here are the topics that this chapter</st> <st c="1090">will highlight:</st>
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1051">本章将重点介绍以下主题：</st> <st c="1090">
- en: <st c="1105">Creating asynchronous</st> <st c="1128">Flask components</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1105">创建异步</st> <st c="1128">Flask组件</st>
- en: <st c="1144">Building an asynchronous SQLAlchemy</st> <st c="1181">repository
    layer</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1144">构建异步SQLAlchemy</st> <st c="1181">存储层</st>
- en: <st c="1197">Implementing async transactions</st> <st c="1230">with</st> `<st
    c="1235">asyncio</st>`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1197">使用</st> <st c="1230">`asyncio`</st> <st c="1235">实现异步事务</st>
- en: <st c="1242">Utilizing asynchronous</st> <st c="1266">signal notifications</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1242">利用异步</st> <st c="1266">信号通知</st>
- en: <st c="1286">Constructing background tasks with Celery</st> <st c="1329">and
    Redis</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1286">使用Celery和Redis构建后台任务</st> <st c="1329">
- en: <st c="1338">Building WebSockets with</st> <st c="1364">asynchronous transactions</st>
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1338">使用异步事务构建WebSocket</st> <st c="1364">
- en: <st c="1389">Implementing asynchronous</st> **<st c="1416">Server-Sent</st>**
    **<st c="1428">Events</st>** <st c="1434">(</st>**<st c="1436">SSE</st>**<st c="1439">)</st>
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1389">实现异步</st> **<st c="1416">服务器端发送</st>** **<st c="1428">事件</st>**
    <st c="1434">(**<st c="1436">SSE</st>**<st c="1439">)</st>
- en: <st c="1441">Applying reactive programming</st> <st c="1471">with RxPy</st>
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1441">使用RxPy应用响应式编程</st> <st c="1471">
- en: <st c="1480">Choosing Quart over</st> <st c="1501">Flask 2.x</st>
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1480">选择Quart而非</st> <st c="1501">Flask 2.x</st>
- en: <st c="1510">Technical requirements</st>
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1510">技术要求</st>
- en: <st c="1533">This chapter will highlight an</st> *<st c="1565">Online Voting
    System</st>* <st c="1585">prototype with some asynchronous tasks and background
    processes to manage the high bandwidth of candidates’ applications and election-related
    submissions from different areas and to cater to the simultaneous retrieval of
    vote tallies from various parties.</st> <st c="1842">The system is composed of
    three separate projects, namely</st> `<st c="1900">ch05-api</st>`<st c="1908">,
    which has the API endpoints,</st> `<st c="1939">ch05-web</st>`<st c="1947">, which
    implements the SSE, WebSocket, and template-based results, and</st> `<st c="2018">ch05-quart</st>`<st
    c="2028">, which provides another platform for the app using the Quart framework.</st>
    <st c="2101">All these projects use the</st> **<st c="2128">application factory
    design</st>** <st c="2154">pattern and are available</st> <st c="2181">at</st>
    [<st c="2184">https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch05</st>](https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch05)<st
    c="2265">.</st>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将突出介绍一个具有一些异步任务和后台进程的**《在线投票系统》**原型，这些进程用于管理来自不同地区的候选人申请和与选举相关的提交的高带宽，以及满足从各个政党同时检索投票计数的需要。该系统由三个独立的项目组成，分别是
    `<st c="1900">ch05-api</st>`<st c="1908">，它包含 API 端点，</st> `<st c="1939">ch05-web</st>`<st
    c="1947">，它实现了 SSE、WebSocket 和基于模板的结果，以及</st> `<st c="2018">ch05-quart</st>`<st
    c="2028">，它为应用程序提供了使用 Quart 框架的另一个平台。</st> `<st c="2101">所有这些项目都使用了</st>` **《应用工厂设计模式》**
    `<st c="2128">，并且可在</st> [<st c="2184">https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch05</st>](https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch05)<st
    c="2265">找到。</st>`
- en: <st c="2266">Creating asynchronous Flask components</st>
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建异步 Flask 组件
- en: <st c="2305">Flask 2.3 and up</st> <st c="2322">to the current version support
    running asynchronous API endpoint and web-based view functions over its WSGI-based
    platform.</st> <st c="2447">However, to fully use this feature, install the</st>
    `<st c="2495">flask[async]</st>` <st c="2507">module using the following</st>
    `<st c="2535">pip</st>` <st c="2538">command:</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="2305">Flask 2.3 及以上版本</st>` `<st c="2322">到当前版本支持在其基于 WSGI 的平台上运行异步
    API 端点和基于 Web 的视图函数。</st>` `<st c="2447">然而，要完全使用此功能，请使用以下</st>` `<st c="2535">pip</st>`
    `<st c="2538">命令安装</st>` `<st c="2495">flask[async]</st>` `<st c="2507">模块：</st>`'
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="2572">After installing the</st> `<st c="2594">flask[async]</st>` <st
    c="2606">module, implementing synchronous views using the</st> `<st c="2656">async</st>`<st
    c="2661">/</st>`<st c="2663">await</st>` <st c="2668">design pattern can now</st>
    <st c="2692">be feasible.</st>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了 `<st c="2572">flask[async]</st>` `<st c="2606">模块后，现在可以使用</st>` `<st c="2656">async</st>`<st
    c="2661">/</st>`<st c="2663">await</st>` `<st c="2668">设计模式来实现同步视图。</st> `<st
    c="2692">现在这变得可行了。</st>`
- en: <st c="2704">Implementing asynchronous views and endpoints</st>
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现异步视图和端点
- en: <st c="2750">Like</st> <st c="2755">Django or FastAPI, creating asynchronous
    views and endpoints in the Flask framework involves applying the</st> `<st c="2862">async</st>`<st
    c="2867">/</st>`<st c="2869">await</st>` <st c="2874">keywords.</st> <st c="2885">The
    following web view from</st> `<st c="2913">ch05-web</st>` <st c="2921">renders
    a welcome greeting message to the users with the description of our</st> *<st
    c="2998">Online</st>* *<st c="3005">Voting</st>* <st c="3011">application:</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `<st c="2750">Django 或 FastAPI</st>` 类似，在 Flask 框架中创建异步视图和端点涉及应用 `<st c="2862">async</st>`<st
    c="2867">/</st>`<st c="2869">await</st>` `<st c="2874">关键字。</st> `<st c="2885">以下来自</st>`
    `<st c="2913">ch05-web</st>` `<st c="2921">的网页视图向用户显示欢迎问候信息，并描述了我们的</st>` **《在线》**
    **《投票》** `<st c="3011">应用程序：</st>`
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="3125">Another asynchronous view function from the other application,</st>
    `<st c="3189">ch05-api</st>`<st c="3197">, is showcased in the following</st>
    <st c="3229">API endpoint that adds new login credentials to the</st> **<st c="3281">database</st>**
    <st c="3289">(</st>**<st c="3291">DB</st>**<st c="3293">):</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="3125">来自另一个应用程序的另一个异步视图函数</st>` `<st c="3189">ch05-api</st>`<st c="3197">，在以下</st>`
    `<st c="3229">API 端点中展示，该端点向</st> **《数据库》** `<st c="3281">（</st>**《DB》**<st c="3291">）**<st
    c="3293">）**中添加新的登录凭证：</st>`'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="3660">Both the given view and API functions use</st> `<st c="3703">async</st>`
    <st c="3708">routes to manage their respective request and response objects.</st>
    <st c="3773">Defining these routes with</st> `<st c="3800">async</st>` <st c="3805">creates
    coroutines that Flask 2.x can surprisingly run using the</st> `<st c="3871">run()</st>`
    <st c="3876">utility of the</st> `<st c="3892">asyncio</st>` <st c="3899">module.</st>
    <st c="3908">But how does the Flask framework manage the coroutine executions
    despite the pitfalls of its</st> <st c="4001">WSGI platform?</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的视图和 API 函数都使用 `<st c="3703">async</st>` `<st c="3708">路由</st>` 来管理它们各自的请求和响应对象。<st
    c="3773">使用</st>` `<st c="3800">async</st>` `<st c="3805">定义这些路由</st>` 创建协程，Flask
    2.x 可以使用 `<st c="3871">run()</st>` `<st c="3876">工具</st>` 的 `<st c="3892">asyncio</st>`
    `<st c="3899">模块</st>` 意外地运行。<st c="3908">但是，Flask 框架如何在 WSGI 平台的缺陷中管理协程执行呢？</st>
- en: <st c="4015">Flask spawns a</st> `<st c="4084">async</st>`<st c="4089">, the
    framework creates a</st> *<st c="4115">sub-thread</st>* <st c="4125">from the
    worker thread to create an</st> `<st c="4215">asyncio</st>` <st c="4222">utilities.</st>
    <st c="4234">Despite the asynchronous processes, there are still limitations on
    how far</st> `<st c="4309">async</st>` <st c="4314">can push through since the
    environment is still within the WSGI, a synchronous platform.</st> <st c="4404">However,
    for not-so-complex non-blocking transactions, the</st> `<st c="4463">flask[async]</st>`
    <st c="4475">framework is enough to improve software quality</st> <st c="4524">and
    performance.</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 创建一个 `<st c="4084">async</st>`，框架从工作线程创建一个 *<st c="4115">子线程</st>* 以创建
    `<st c="4215">asyncio</st>` `<st c="4222">工具。</st>` 尽管存在异步过程，但由于环境仍然在 WSGI，一个同步平台中，因此
    `<st c="4309">async</st>` `<st c="4314">可以推进的极限仍然有限。</st>` 然而，对于不太复杂的非阻塞事务，`<st
    c="4463">flask[async]</st>` `<st c="4475">框架足以提高软件质量和性能。</st>`
- en: <st c="4540">However, async components</st> <st c="4566">are not limited to
    view and API functions and also have Flask</st> <st c="4629">event handlers.</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="4540">异步组件</st>` `<st c="4566">不仅限于视图和 API 函数，还有 Flask `<st c="4629">事件处理器</st>`。'
- en: <st c="4644">Implementing the async before_request and after_request handlers</st>
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现异步的 `before_request` 和 `after_request` 处理器
- en: <st c="4709">Aside from</st> <st c="4721">views and endpoints, the Flask 3.0
    framework allows the</st> <st c="4776">implementation of asynchronous</st> `<st
    c="4808">before_request</st>` <st c="4822">and</st> `<st c="4827">after_request</st>`
    <st c="4840">handlers, just like the following</st> `<st c="4875">ch05-api</st>`
    <st c="4883">handlers that log every API</st> <st c="4912">request transaction:</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了视图和端点之外，Flask 3.0 框架允许实现异步的 `<st c="4808">before_request</st>` 和 `<st c="4827">after_request</st>`
    处理器，就像以下 `<st c="4875">ch05-api</st>` `<st c="4883">处理器</st>` 那样记录每个 API `<st
    c="4912">请求事务</st>`：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="5171">These event handlers still use the</st> `<st c="5207">app</st>`
    <st c="5210">instance created in</st> `<st c="5231">main.py</st>` <st c="5238">to
    create the log files using the built-in</st> `<st c="5282">logging</st>` <st c="5289">module.</st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件处理器仍然使用在 `<st c="5231">main.py</st>` `<st c="5238">中创建的 `<st c="5207">app</st>`
    `<st c="5210">实例</st>`，使用内置的 `<st c="5282">logging</st>` `<st c="5289">模块</st>`
    创建日志文件。
- en: <st c="5297">On the other hand, the</st> `<st c="5321">flask[async]</st>` <st
    c="5333">module can allow the creation of asynchronous</st> <st c="5380">error
    handlers.</st>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`<st c="5321">flask[async]</st>` `<st c="5333">模块可以允许创建异步的错误处理器。</st>`
- en: <st c="5395">Creating asynchronous error handlers</st>
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建异步错误处理器
- en: <st c="5432">Flask 2.x can</st> <st c="5447">decorate coroutines with</st> `<st
    c="5472">@errorhandler</st>` <st c="5485">to manage raised exceptions and HTTP
    status codes.</st> <st c="5537">The following are the asynchronous error handlers
    of the</st> `<st c="5594">ch05-api</st>` <st c="5602">project placed</st> <st
    c="5618">in</st> `<st c="5621">main.py</st>`<st c="5628">:</st>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 2.x 可以使用 `<st c="5472">@errorhandler</st>` `<st c="5485">装饰器</st>` 装饰协程，以管理引发的异常和
    HTTP 状态码。<st c="5594">ch05-api</st>` `<st c="5602">项目的以下异步错误处理器放置在</st>` `<st
    c="5621">main.py</st>` `<st c="5628">:</st>`
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="6018">Now, all these</st> <st c="6034">asynchronous Flask components
    can also await other asynchronous operations such as the repository layer of the
    application.</st> <st c="6158">Indeed, the asynchronous Flask environment is open
    to integration with asynchronous third-party extension modules such as the async</st>
    <st c="6290">SQLAlchemy 2.x.</st>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6018">现在，所有这些</st> <st c="6034">异步 Flask 组件也可以等待其他异步操作，例如应用程序的存储层。</st>
    <st c="6158">实际上，异步 Flask 环境对集成异步第三方扩展模块，如 async</st> <st c="6290">SQLAlchemy
    2.x</st>，持开放态度。
- en: <st c="6305">Building an asynchronous SQLAlchemy repository layer</st>
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="6305">构建异步 SQLAlchemy 存储层</st>
- en: <st c="6358">The</st> <st c="6362">updated</st> `<st c="6371">flask-sqlalchemy</st>`
    <st c="6387">extension module supports SQLAlchemy 2.x that provides API utilities,
    which use the</st> `<st c="6472">asyncio</st>` <st c="6479">environment with</st>
    `<st c="6497">greenlet</st>` <st c="6505">as the main library, allowing propagation
    of the</st> `<st c="6555">await</st>` <st c="6560">keyword in the APIs’ internal
    processes.</st> <st c="6602">Our</st> `<st c="6606">ch05-web</st>` <st c="6614">and</st>
    `<st c="6619">ch05-api</st>` <st c="6627">projects have the async transactions
    that call these awaited</st> <st c="6688">SQLAlchemy</st> `<st c="6791">/models/config.py</st>`
    <st c="6808">file that utilizes an</st> `<st c="6831">asyncpg</st>` <st c="6838">driver
    to build a session for non-blocking</st> <st c="6882">repository transactions.</st>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6358">更新的</st> <st c="6362">flask-sqlalchemy</st> <st c="6387">扩展模块支持
    SQLAlchemy 2.x，它提供了 API 工具，这些工具使用</st> `<st c="6472">asyncio</st>` <st c="6479">环境，以</st>
    `<st c="6497">greenlet</st>` <st c="6505">作为主要库，允许在 API 的内部过程中传播</st> `<st c="6555">await</st>`
    <st c="6560">关键字。</st> <st c="6602">我们的</st> `<st c="6606">ch05-web</st>` <st
    c="6614">和</st> `<st c="6619">ch05-api</st>` <st c="6627">项目具有异步事务，这些事务调用这些等待的</st>
    <st c="6688">SQLAlchemy</st> `<st c="6791">/models/config.py</st>` <st c="6808">文件，该文件利用一个</st>
    `<st c="6831">asyncpg</st>` <st c="6838">驱动程序来构建一个用于非阻塞</st> <st c="6882">存储层事务的会话。</st>
- en: <st c="6906">Setting up the DB connectivity</st>
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="6906">设置数据库连接</st>
- en: <st c="6937">To start</st> <st c="6946">with the configuration, install the</st>
    `<st c="6983">asyncpg</st>` <st c="6990">DB driver or dialect that the</st> `<st
    c="7021">asyncio</st>`<st c="7028">-driven SQLAlchemy module requires using the</st>
    `<st c="7074">pip</st>` <st c="7077">command:</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6937">要开始</st> <st c="6946">配置，请安装</st> `<st c="6983">asyncpg</st>` <st
    c="6990">数据库驱动程序或方言，该驱动程序或方言是</st> `<st c="7021">asyncio</st>`<st c="7028">-驱动的
    SQLAlchemy 模块所必需的，使用</st> `<st c="7074">pip</st>` <st c="7077">命令：</st>
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="7106">Also, include the greenlet library in the installation if it is
    not yet part of the</st> <st c="7191">virtual environment:</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7106">此外，如果绿色库尚未成为虚拟环境的一部分，请将其包含在安装中：</st>
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="7232">The setup also requires</st> <st c="7257">a</st> `<st c="7339">asyncpg</st>`
    <st c="7346">protocol, user credentials, the DB server host address, port, and
    the schema name.</st> <st c="7430">Our projects use the connection string,</st>
    `<st c="7470">postgresql+asyncpg://postgres:admin2255@localhost:5433/ovs</st>`<st
    c="7528">, to generate the</st> `<st c="7546">AsyncEngine</st>` <st c="7557">instance
    of the connection using</st> `<st c="7591">create_async_engine()</st>` <st c="7612">of
    the SQLAlchemy framework, the asynchronous version of its</st> `<st c="7674">create_engine()</st>`
    <st c="7689">utility.</st> <st c="7699">Aside from the DB URL, the method requires
    its</st> `<st c="7746">future</st>` <st c="7752">parameter to be set to</st> `<st
    c="7776">True</st>`<st c="7780">,</st> `<st c="7782">pool_pre_pring</st>` <st
    c="7796">to be set to</st> `<st c="7810">True</st>`<st c="7814">, and</st> `<st
    c="7820">poolclass</st>` <st c="7829">to be set to a connection pooling strategy
    such as</st> `<st c="7881">NullPool</st>`<st c="7889">.</st> `<st c="7891">poolclass</st>`
    <st c="7900">manages the threads the SQLAlchemy will utilize during its CRUD operations,
    and setting it to</st> `<st c="7995">NullPool</st>` <st c="8003">will restrict
    one Python thread to run only one event loop for one CRUD operation.</st> `<st
    c="8087">pool_pre_ping</st>`<st c="8100">, on the other hand, helps connection
    pooling for the pessimistic approach of handling disconnection.</st> <st c="8202">If
    it determines the DB connection as non-usable or invalid, that connection and
    its previous ones will be immediately recycled before executing a new operation.</st>
    <st c="8364">Most importantly, the</st> `<st c="8386">future</st>` <st c="8392">parameter
    must be set to</st> `<st c="8418">True</st>` <st c="8422">to enable asynchronous
    features of SQLAlchemy 2.x, or else the asynchronous SQLAlchemy setup will</st>
    <st c="8521">not work.</st>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7232">设置还需要</st> <st c="7257">一个</st> `<st c="7339">asyncpg</st>` <st
    c="7346">协议</st>，用户凭据，数据库服务器的主机地址，端口号以及模式名称。</st> <st c="7430">我们的项目使用连接字符串</st>
    `<st c="7470">postgresql+asyncpg://postgres:admin2255@localhost:5433/ovs</st>`<st
    c="7528">，来生成</st> `<st c="7546">AsyncEngine</st>` <st c="7557">实例，该实例使用SQLAlchemy框架的</st>
    `<st c="7591">create_async_engine()</st>` <st c="7612">函数，这是其</st> `<st c="7674">create_engine()</st>`
    <st c="7689">实用工具的异步版本。</st> <st c="7699">除了数据库URL之外，该方法还需要将它的</st> `<st c="7746">future</st>`
    <st c="7752">参数设置为</st> `<st c="7776">True</st>`<st c="7780">，将</st> `<st c="7782">pool_pre_pring</st>`
    <st c="7796">设置为</st> `<st c="7810">True</st>`<st c="7814">，并将</st> `<st c="7820">poolclass</st>`
    <st c="7829">设置为连接池策略，例如</st> `<st c="7881">NullPool</st>`<st c="7889">。</st>
    `<st c="7891">poolclass</st>` <st c="7900">管理SQLAlchemy在CRUD操作期间使用的线程，将其设置为</st>
    `<st c="7995">NullPool</st>` <st c="8003">将限制一个Python线程仅运行一个事件循环以执行一个CRUD操作。</st>
    `<st c="8087">pool_pre_ping</st>`<st c="8100">，另一方面，有助于处理断开连接的悲观方法的连接池。</st> <st
    c="8202">如果它确定数据库连接不可用或无效，那么在执行新操作之前，该连接及其之前的连接将立即回收。</st> <st c="8364">最重要的是，必须将</st>
    `<st c="8386">future</st>` <st c="8392">参数设置为</st> `<st c="8418">True</st>` <st
    c="8422">以启用SQLAlchemy 2.x的异步功能，否则异步SQLAlchemy设置将</st> <st c="8521">无法工作。</st>
- en: <st c="8530">After its successful creation, the</st> `<st c="8566">sessionmaker</st>`
    <st c="8578">callable will need the</st> `<st c="8602">AsyncEngine</st>` <st c="8613">instance
    to instantiate the session that every CRUD operation requires.</st> <st c="8686">However,
    this time, the session will be of the</st> `<st c="8733">AsyncSession</st>` <st
    c="8745">type, and the</st> `<st c="8760">async_scoped_session</st>` <st c="8780">callable
    will help derive the object with its provided</st> `<st c="8836">scopefunc</st>`
    <st c="8845">parameter to manage lightweight thread-local session-based operations
    in the repository layer.</st> <st c="8941">Every repository class will require
    this</st> `<st c="8982">AsyncSession</st>` <st c="8994">instance to implement
    every necessary DB transaction of the asynchronous</st> <st c="9068">Flask platform.</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8530">在成功创建之后，</st> `<st c="8566">sessionmaker</st>` <st c="8578">可调用对象将需要</st>
    `<st c="8602">AsyncEngine</st>` <st c="8613">实例来实例化每个CRUD操作所需的会话。</st> <st c="8686">然而，这次，会话将是</st>
    `<st c="8733">AsyncSession</st>` <st c="8745">类型，并且</st> `<st c="8760">async_scoped_session</st>`
    <st c="8780">可调用对象将帮助通过其提供的</st> `<st c="8836">scopefunc</st>` <st c="8845">参数来管理仓库层中的轻量级线程局部会话操作。</st>
    <st c="8941">每个仓库类都需要这个</st> `<st c="8982">AsyncSession</st>` <st c="8994">实例来实现异步</st>
    <st c="9068">Flask平台</st>的每个必要的数据库事务。</st>
- en: <st c="9083">Now, there is nothing new with the</st> `<st c="9119">declarative_base()</st>`
    <st c="9137">method, for it will still provide the needed helper classes to generate
    the model classes for the repository layer, like in the standard SQLAlchemy setup.</st>
    <st c="9293">The following is the complete module script of the</st> <st c="9344">specified</st>
    <st c="9354">SQLAlchemy setup:</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9083">Now, there is nothing new with the</st> `<st c="9119">declarative_base()</st>`
    <st c="9137">method, for it will still provide the needed helper classes to generate
    the model classes for the repository layer, like in the standard SQLAlchemy setup.</st>
    <st c="9293">The following is the complete module script of the</st> <st c="9344">specified</st>
    <st c="9354">SQLAlchemy setup:</st>
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="9955">The</st> `<st c="9960">echo</st>` <st c="9964">parameter of the
    given</st> `<st c="9988">create_async_engine</st>` <st c="10007">enables logging
    for the</st> `<st c="10032">AsyncEngine</st>`<st c="10043">-related transactions.</st>
    <st c="10067">Now, the</st> `<st c="10076">init_db()</st>` <st c="10085">method
    from the preceding configuration exposes the model classes to the different areas
    of the application.</st> <st c="10195">These model classes, built using the</st>
    `<st c="10232">Base</st>` <st c="10236">instance, help auto-generate the table
    schemas of our DB through the</st> *<st c="10306">Flask-Migrate</st>* <st c="10319">extension
    module, which still works with</st> `<st c="10361">flask[async]</st>` <st c="10373">and</st>
    `<st c="10378">flask-sqlalchemy</st>` <st c="10394">integration.</st>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9955">The</st> `<st c="9960">echo</st>` <st c="9964">parameter of the
    given</st> `<st c="9988">create_async_engine</st>` <st c="10007">enables logging
    for the</st> `<st c="10032">AsyncEngine</st>`<st c="10043">-related transactions.</st>
    <st c="10067">Now, the</st> `<st c="10076">init_db()</st>` <st c="10085">method
    from the preceding configuration exposes the model classes to the different areas
    of the application.</st> <st c="10195">These model classes, built using the</st>
    `<st c="10232">Base</st>` <st c="10236">instance, help auto-generate the table
    schemas of our DB through the</st> *<st c="10306">Flask-Migrate</st>* <st c="10319">extension
    module, which still works with</st> `<st c="10361">flask[async]</st>` <st c="10373">and</st>
    `<st c="10378">flask-sqlalchemy</st>` <st c="10394">integration.</st>
- en: <st c="10407">Let us now use the derived</st> `<st c="10435">async_scoped_session()</st>`
    <st c="10457">to build</st> <st c="10467">repository classes.</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10407">Let us now use the derived</st> `<st c="10435">async_scoped_session()</st>`
    <st c="10457">to build</st> <st c="10467">repository classes.</st>
- en: <st c="10486">Building the asynchronous repository layer</st>
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="10486">Building the asynchronous repository layer</st>
- en: <st c="10529">The</st> <st c="10533">asynchronous repository layer of the application
    requires the</st> `<st c="10596">AsyncSession</st>` <st c="10608">and the model
    classes to be created in the setup.</st> <st c="10659">The following is a</st>
    `<st c="10678">VoterRepository</st>` <st c="10693">class implementation that provides
    CRUD transactions for managing the</st> `<st c="10764">Voter</st>` <st c="10769">records:</st>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10529">The</st> <st c="10533">asynchronous repository layer of the application
    requires the</st> `<st c="10596">AsyncSession</st>` <st c="10608">and the model
    classes to be created in the setup.</st> <st c="10659">The following is a</st>
    `<st c="10678">VoterRepository</st>` <st c="10693">class implementation that provides
    CRUD transactions for managing the</st> `<st c="10764">Voter</st>` <st c="10769">records:</st>
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<st c="11864">async</st> def insert_voter(self, voter: Voter) -> bool:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="11864">async</st> def insert_voter(self, voter: Voter) -> bool:'
- en: 'try: <st c="11922">sql = insert(Voter).values(mid=voter.mid,</st> <st c="11963">precinct=voter.precinct,</st>
    <st c="11988">voter_id=voter.voter_id,</st> <st c="12013">last_vote_date=datetime.strptime(</st><st
    c="12047">voter.last_vote_date, ''%Y-%m-%d'').date())</st><st c="12089">await</st>
    self.sess.execute(sql) <st c="12119">await</st> self.sess.commit() <st c="12144">await</st>
    self.sess.close()'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try: <st c="11922">sql = insert(Voter).values(mid=voter.mid,</st> <st c="11963">precinct=voter.precinct,</st>
    <st c="11988">voter_id=voter.voter_id,</st> <st c="12013">last_vote_date=datetime.strptime(</st><st
    c="12047">voter.last_vote_date, ''%Y-%m-%d'').date())</st><st c="12089">await</st>
    self.sess.execute(sql) <st c="12119">await</st> self.sess.commit() <st c="12144">await</st>
    self.sess.close()'
- en: return True
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return True
- en: 'except Exception as e:'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'except Exception as e:'
- en: print(e)
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(e)
- en: return False
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return False
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<st c="12567">async</st> def update_voter(self, id:int, details:Dict[str, Any])
    -> bool:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="12567">async</st> def update_voter(self, id:int, details:Dict[str, Any])
    -> bool:'
- en: 'try: <st c="12643">sql = update(Voter).where(Voter.id ==</st> <st c="12680">id).values(**details)</st><st
    c="12702">await</st> self.sess.execute(sql) <st c="12732">await</st> self.sess.commit()
    <st c="12757">await</st> self.sess.close()'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try: <st c="12643">sql = update(Voter).where(Voter.id ==</st> <st c="12680">id).values(**details)</st><st
    c="12702">await</st> self.sess.execute(sql) <st c="12732">await</st> self.sess.commit()
    <st c="12757">await</st> self.sess.close()'
- en: return True
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return True
- en: 'except Exception as e:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'except Exception as e:'
- en: print(e)
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(e)
- en: return False
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return False
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<st c="13053">async</st> def delete_voter(self, id:int) -> bool:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="13053">async</st> def delete_voter(self, id:int) -> bool:'
- en: 'try: <st c="13105">sql = delete(Voter).where(Voter.id == id)</st><st c="13146">await</st>
    self.sess.execute(sql) <st c="13176">await</st> self.sess.commit() <st c="13201">await</st>
    self.sess.close()'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try: <st c="13105">sql = delete(Voter).where(Voter.id == id)</st><st c="13146">等待</st>
    self.sess.execute(sql) <st c="13176">等待</st> self.sess.commit() <st c="13201">等待</st>
    self.sess.close()'
- en: return True
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return True
- en: 'except Exception as e:'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'except Exception as e:'
- en: print(e)
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(e)
- en: return False
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return False
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<st c="13393">async</st> def select_all_voter(self): <st c="13428">sql = select(Voter)</st>
    q = <st c="13452">await</st> self.sess.execute(sql)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="13393">异步</st> def select_all_voter(self): <st c="13428">sql = select(Voter)</st>
    q = <st c="13452">等待</st> self.sess.execute(sql)'
- en: records = q.scalars().all() <st c="13509">await</st> self.sess.close()
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: records = q.scalars().all() <st c="13509">等待</st> self.sess.close()
- en: return records
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return records
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<st c="13918">async</st> def select_voter(self, id:int): <st c="13957">sql
    = select(Voter).where(Voter.id == id)</st> q = <st c="14003">await</st> self.sess.execute(sql)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="13918">异步</st> def select_voter(self, id:int): <st c="13957">sql = select(Voter).where(Voter.id
    == id)</st> q = <st c="14003">等待</st> self.sess.execute(sql)'
- en: record = q.scalars().all() <st c="14059">await</st> self.sess.close()
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: record = q.scalars().all() <st c="14059">等待</st> self.sess.close()
- en: return record
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return record
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<st c="14613">async</st> def update_precinct(self, old_prec:str,   new_prec:str)
    -> bool:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="14613">异步</st> def update_precinct(self, old_prec:str,   new_prec:str)
    -> bool:'
- en: 'try:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try:'
- en: sql = update(Voter).<st c="14708">where(Voter.precinct == old_prec).values(precint=new_prec)</st><st
    c="14767">sql.execution_options(synchronize_session=</st> <st c="14810">"fetch")</st>
    await self.sess.execute(sql)
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: sql = update(Voter).<st c="14708">where(Voter.precinct == old_prec).values(precint=new_prec)</st><st
    c="14767">sql.execution_options(synchronize_session=</st> <st c="14810">"fetch")</st>
    await self.sess.execute(sql)
- en: await self.sess.commit()
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: await self.sess.commit()
- en: await self.sess.close()
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: await self.sess.close()
- en: return True
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return True
- en: 'except Exception as e:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'except Exception as e:'
- en: print(e)
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(e)
- en: return False
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return False
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<st c="15369">async</st> def delete_voter_by_precinct(self, precint:str) ->
    bool:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="15369">异步</st> def delete_voter_by_precinct(self, precinct:str) -> bool:'
- en: 'try:'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try:'
- en: sql = delete(Voter).<st c="15458">where(Voter.precinct == precint)</st><st c="15491">sql.execution_options(synchronize_session=</st>
    <st c="15534">"fetch")</st> await self.sess.execute(sql)
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: sql = delete(Voter).<st c="15458">where(Voter.precinct == precinct)</st><st
    c="15491">sql.execution_options(synchronize_session=</st> <st c="15534">"fetch")</st>
    await self.sess.execute(sql)
- en: await self.sess.commit()
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: await self.sess.commit()
- en: await self.sess.close()
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: await self.sess.close()
- en: return True
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return True
- en: 'except Exception as e:'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'except Exception as e:'
- en: print(e)
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(e)
- en: return False
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return False
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: from app.model.db import Login
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: from app.model.db import Login
- en: 'from app.repository.login import LoginRepository <st c="16865">from app.model.config
    import db_session</st> @current_app.post(''/ch05/login/add'') <st c="16942">async</st>
    def add_login(): <st c="16965">async with db_session() as sess:</st><st c="16997">async
    with sess.begin():</st><st c="17022">repo = LoginRepository(sess)</st> login_json
    = request.get_json()'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 'from app.repository.login import LoginRepository <st c="16865">from app.model.config
    import db_session</st> @current_app.post(''/ch05/login/add'') <st c="16942">异步</st>
    def add_login(): <st c="16965">异步 with db_session() as sess:</st><st c="16997">异步
    with sess.begin():</st><st c="17022">repo = LoginRepository(sess)</st> login_json
    = request.get_json()'
- en: 'login = Login(**login_json) <st c="17112">result = await repo.insert_login(login)</st>
    if result:'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'login = Login(**login_json) <st c="17112">结果 = 等待(repo.insert_login(login))</st>
    if 结果:'
- en: content = jsonify(login_json)
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: content = jsonify(login_json)
- en: return make_response(content, 201)
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return make_response(content, 201)
- en: 'else:'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'else:'
- en: abort(500)
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: abort(500)
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: from app.model.db import Member
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: from app.model.db import Member
- en: from app.repository.member import MemberRepository
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: from app.repository.member import MemberRepository
- en: 'from app.model.config import db_session <st c="18512">from asyncio import create_task,
    ensure_future,</st> <st c="18559">InvalidStateError</st> from app.exceptions.db
    import DuplicateRecordException <st c="18633">@current_app.post("/ch05/member/add")</st>
    async def add_member():'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 'from app.model.config import db_session <st c="18512">from asyncio import create_task,
    ensure_future,</st> <st c="18559">InvalidStateError</st> from app.exceptions.db
    import DuplicateRecordException <st c="18633">@current_app.post("/ch05/member/add")</st>
    async def add_member():'
- en: 'async with db_session() as sess:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'async with db_session() as sess:'
- en: 'async with sess.begin():'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'async with sess.begin():'
- en: repo = MemberRepository(sess)
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: repo = MemberRepository(sess)
- en: member_json = request.get_json()
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: member_json = request.get_json()
- en: member = Member(**member_json)
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: member = Member(**member_json)
- en: 'try: <st c="18852">insert_task =</st> <st c="18865">create_task(repo.insert(member))</st><st
    c="18898">await insert_task</st><st c="18916">result = insert_task.result()</st>
    if result:'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try: <st c="18852">插入任务 =</st> <st c="18865">创建任务(repo.insert(member))</st><st
    c="18898">等待插入任务</st><st c="18916">结果 = 插入任务的结果</st> if 结果:'
- en: content = jsonify(member_json)
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: content = jsonify(member_json)
- en: return make_response(content, 201)
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return make_response(content, 201)
- en: 'else:'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'else:'
- en: raise DuplicateRecordException("insert member record failed")
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: raise DuplicateRecordException("插入成员记录失败")
- en: 'except InvalidStateError:'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'except InvalidStateError:'
- en: abort(500)
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: abort(500)
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <st c="20235">@current_app.get("/ch05/member/list/all")</st>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20235">@current_app.get("/ch05/member/list/all")</st>
- en: '<st c="20277">async</st> def list_all_member():'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="20277">async</st> def list_all_member():'
- en: 'async with db_session() as sess:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'async with db_session() as sess:'
- en: 'async with sess.begin():'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'async with sess.begin():'
- en: repo = MemberRepository(sess) <st c="20395">list_member_task =</st> <st c="20413">ensure_future(repo.select_all_member())</st><st
    c="20453">await list_member_task</st><st c="20476">records = list_member_task.result()</st>
    member_rec = [rec.to_json() for rec in records]
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: repo = MemberRepository(sess) <st c="20395">list_member_task =</st> <st c="20413">ensure_future(repo.select_all_member())</st><st
    c="20453">await list_member_task</st><st c="20476">records = list_member_task.result()</st>
    member_rec = [rec.to_json() for rec in records]
- en: return make_response(member_rec, 201)
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return make_response(member_rec, 201)
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <st c="21338">@current_app.post('/ch05/candidates/party')</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21338">@current_app.post('/ch05/candidates/party')</st>
- en: '<st c="21382">async</st> def add_list_candidates():'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="21382">async</st> def add_list_candidates():'
- en: candidates = request.get_json()
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: candidates = request.get_json()
- en: 'count_rec_added = 0 <st c="21468">results = await gather( *[insert_candidate_task(data)</st>
    <st c="21521">for data in candidates])</st> for success in results:'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'count_rec_added = 0 <st c="21468">results = await gather( *[insert_candidate_task(data)</st>
    <st c="21521">for data in candidates])</st> for success in results:'
- en: 'if success:'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果成功：
- en: count_rec_added = count_rec_added  + 1
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: count_rec_added = count_rec_added + 1
- en: return jsonify(message=f'there are {count_rec_added} newly added candidates'),
    201
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return jsonify(message=f'there are {count_rec_added} newly added candidates'),
    201
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<st c="22085">from asyncio import create_task</st> … … … … … … <st c="22129">async</st>
    def insert_candidate_task(data): <st c="22168">async with db_session() as sess:</st><st
    c="22200">async with sess.begin():</st> repo = CandidateRepository(sess) <st c="22259">insert_task
    =</st> <st c="22272">create_task(repo.insert_candidate(</st><st c="22307">Candidate(**data)))</st><st
    c="22327">await insert_task</st><st c="22345">result = insert_task.result()</st>
    return result'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="22085">from asyncio import create_task</st> … … … … … … <st c="22129">async</st>
    def insert_candidate_task(data): <st c="22168">async with db_session() as sess:</st><st
    c="22200">async with sess.begin():</st> repo = CandidateRepository(sess) <st c="22259">insert_task
    =</st> <st c="22272">create_task(repo.insert_candidate(</st><st c="22307">Candidate(**data)))</st><st
    c="22327">await insert_task</st><st c="22345">result = insert_task.result()</st>
    return result'
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <st c="24975">from flask.signals import Namespace</st>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24975">from flask.signals import Namespace</st>
- en: '<st c="25011">election_ns = Namespace()</st> check_election = election_ns.<st
    c="25067">signal(''check_election'')</st> list_elections = election_ns.<st c="25281">check_election_event</st>,
    for instance, has the following asynchronous method that uses <st c="25365">ElectionRepository</st>
    to verify an election date:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25011">election_ns = Namespace()</st> check_election = election_ns.<st
    c="25067">signal('check_election')</st> list_elections = election_ns.<st c="25281">check_election_event</st>，例如，它具有以下使用<st
    c="25365">ElectionRepository</st>验证选举日期的异步方法：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <st c="25798">Meanwhile, our</st> `<st c="25814">list_all_election()</st>` <st
    c="25833">API endpoint has the following</st> `<st c="25865">list_elections_event()</st>`
    <st c="25887">that returns a list of records in</st> <st c="25922">JSON format:</st>
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同时，我们的<st c="25798">`list_all_election()`</st> <st c="25814">API端点具有以下</st>
    <st c="25833">`list_elections_event()`</st> <st c="25865">，它返回JSON格式的记录列表：</st>
    <st c="25922">：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <st c="26198">Event or</st> <st c="26207">signal functions must accept a</st>
    *<st c="26239">sender</st>* <st c="26245">or</st> *<st c="26249">listener</st>*
    <st c="26257">as the first local parameter argument, followed by the other custom</st>
    `<st c="26326">args</st>` <st c="26330">objects essential to the event transaction.</st>
    <st c="26375">If the event mechanism is part of the class scope, the value of
    the function must be</st> `<st c="26460">self</st>` <st c="26464">or the class
    instance itself.</st> <st c="26495">Otherwise, if the signal is for a global event
    handling, its first argument must be the Flask</st> `<st c="26589">app</st>` <st
    c="26592">instance.</st>
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="26198">事件或</st> <st c="26207">信号函数必须接受一个</st> *<st c="26239">发送者</st>
    <st c="26245">或</st> *<st c="26249">监听器</st> <st c="26257">作为第一个局部参数，后面跟着其他对事件事务至关重要的自定义</st>
    `<st c="26326">args</st>` <st c="26330">对象。</st> <st c="26375">如果事件机制是类作用域的一部分，函数的值必须是</st>
    `<st c="26460">self</st>` <st c="26464">或类实例本身。</st> <st c="26495">否则，如果信号用于全局事件处理，其第一个参数必须是Flask</st>
    `<st c="26589">app</st>` <st c="26592">实例。</st>
- en: <st c="26602">A signal has a</st> `<st c="26618">connect()</st>` <st c="26627">function
    or decorator that registers an event or function as its implementation.</st> <st
    c="26709">These events will execute once a caller emits the signals.</st> <st
    c="26768">Flask components can emit signals by invoking the signal’s</st> `<st
    c="26827">send()</st>` <st c="26833">or</st> `<st c="26837">send_async()</st>`
    <st c="26849">utility with the event function arguments.</st> <st c="26893">The
    following</st> `<st c="26907">verify_election()</st>` <st c="26924">endpoint checks
    from the DB through the</st> `<st c="26965">check_election</st>` <st c="26979">signal
    if an election happens on a</st> <st c="27015">particular date:</st>
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信号有一个 `<st c="26618">connect()</st>` 函数或装饰器，用于注册事件或函数作为其实现。这些事件将在调用者发出信号时执行一次。Flask组件可以通过调用信号的
    `<st c="26827">send()</st>` 或 `<st c="26833">send_async()</st>` 工具函数，并传递事件函数参数来发出信号。以下
    `<st c="26907">verify_election()</st>` 端点通过 `<st c="26965">check_election</st>`
    信号从数据库检查特定日期是否发生了选举：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <st c="27473">If the event function is a standard Python function, send the
    notification for its execution through the signal’s</st> `<st c="27588">send()</st>`
    <st c="27594">method.</st> <st c="27603">However, if it is an asynchronous method,
    like in our case, use</st> `<st c="27667">send_async()</st>` <st c="27679">to
    create and run the task for the coroutine with</st> `<st c="27730">await</st>`
    <st c="27735">to extract its</st> `<st c="27751">Future</st>` <st c="27757">value.</st>
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果事件函数是一个标准的Python函数，则通过信号 `<st c="27588">send()</st>` 方法发送其执行的通知。然而，如果它是一个异步方法，就像我们的情况一样，使用
    `<st c="27667">send_async()</st>` 创建并运行协程的任务，并使用 `<st c="27730">await</st>` 提取其
    `<st c="27751">Future</st>` 值。
- en: <st c="27764">Generally, signals can employ the de-coupling of components in
    a scalable application to reduce dependencies and improve modularity and maintainability.</st>
    <st c="27918">This can also help build applications to have a distributed architecture
    design.</st> <st c="27999">However, as the requirements become complicated and
    the subscribers of the signals become numerous, the notifications can slow down
    the performance of the whole application.</st> <st c="28173">So, it is a good
    design if the caller and the event function can lessen the dependencies on each
    other’s parameters, returned values, and conditions.</st> <st c="28323">The subscribers
    must have an independent scope as to the event functions.</st> <st c="28397">Also,
    it is a good programming approach to create an event function that is flexible
    and not too narrow in its objectives so that many</st> <st c="28532">components
    can subscribe</st> <st c="28557">to it.</st>
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，信号可以采用可扩展应用程序中组件的解耦，以减少依赖关系并提高模块化和可维护性。这也有助于构建具有分布式架构设计的应用程序。然而，随着需求的复杂化和信号订阅者的数量增加，通知可能会降低整个应用程序的性能。因此，如果调用者和事件函数可以减少对彼此参数、返回值和条件的依赖，那么这是一个良好的设计。订阅者必须对事件函数有独立的范围。此外，创建一个灵活且目标不太狭窄的事件函数是一种良好的编程方法，这样许多
    `<st c="28532">组件</st>` 可以订阅它。
- en: <st c="28563">After exploring how Flask supports event handling using its signals,
    let us now learn how to create background processes using</st> <st c="28691">its
    platform.</st>
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在探索了Flask如何使用其信号支持事件处理之后，现在让我们学习如何使用其平台创建后台进程。
- en: <st c="28704">Constructing background tasks with Celery and Redis</st>
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用Celery和Redis构建后台任务
- en: <st c="28756">It is</st> <st c="28763">impossible to create background processes</st>
    <st c="28804">or</st> <st c="28807">transactions in</st> <st c="28823">Flask using
    its</st> `<st c="28840">flask[async]</st>` <st c="28852">platform.</st> <st c="28863">The
    event loop that runs tasks for the asynchronous view or endpoint will not allow
    the spawning of another event loop that will cater to background tasks because
    it cannot wait for the background processes to finish once the view or endpoint
    finishes its processing.</st> <st c="29131">However, with some third-party components,
    such as task queues, background processing is feasible for the</st> <st c="29237">Flask
    platform.</st>
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="28756">在 Flask 中使用其</st> <st c="28763">flask[async]</st> <st c="28804">平台</st>
    <st c="28807">创建后台进程</st> <st c="28823">或</st> <st c="28840">事务</st> <st c="28852">是不可能的。</st>
    <st c="28863">运行异步视图或端点的任务的事件循环不允许启动另一个事件循环来处理后台任务，因为它不能等待视图或端点完成其处理后再结束后台进程。</st>
    <st c="29131">然而，通过一些第三方组件，如任务队列，对于 Flask 平台来说，后台处理是可行的。</st>
- en: <st c="29252">One of the solutions is to use Celery, which is an asynchronous
    task queue that can run processes outside the context of the application.</st>
    <st c="29391">So, while the event loop is running the view or endpoint coroutines,
    they can entrust to Celery the management of the</st> <st c="29509">background
    transactions.</st>
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="29252">其中一个解决方案是使用 Celery，它是一个异步任务队列，可以在应用程序上下文之外运行进程。</st> <st c="29391">因此，当事件循环正在运行视图或端点的协程时，它们可以将后台事务的管理委托给
    Celery。</st>
- en: <st c="29533">Setting up the Celery task queue</st>
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="29533">设置 Celery 任务队列</st>
- en: <st c="29566">There are a few</st> <st c="29583">considerations when writing
    the background processes with Celery, and the first is to install the</st> `<st
    c="29681">celery</st>` <st c="29687">extension module using the</st> `<st c="29715">pip</st>`
    <st c="29718">command:</st>
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="29566">在用 Celery 编写后台进程时，有一些</st> <st c="29583">考虑因素，首先是使用</st> <st c="29681">celery</st>
    <st c="29687">扩展模块通过</st> <st c="29715">pip</st> <st c="29718">命令进行安装：</st>
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: <st c="29746">Then, we designate some local workers in the WSGI server to run
    tasks with the background jobs in the Celery queue, but in our application, our
    Flask server will only use a single worker to run all</st> <st c="29945">the processes.</st>
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="29746">然后，我们在 WSGI 服务器中指定一些本地工作者来运行 Celery 队列中的后台任务，但在我们的应用程序中，我们的 Flask
    服务器将只使用一个工作者来运行所有</st> <st c="29945">进程。</st>
- en: <st c="29959">Let us now install the Redis server, which will serve as the message
    broker to</st> <st c="30039">the Celery.</st>
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="29959">现在让我们安装 Redis 服务器，它将作为消息代理为 Celery 服务。</st>
- en: <st c="30050">Installing the Redis DB</st>
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="30050">安装 Redis 数据库</st>
- en: <st c="30074">After designating</st> <st c="30092">the worker, Celery requires
    a message broker for its workers to communicate with the client application about
    running the background jobs.</st> <st c="30232">Our applications use the Redis
    DB as the broker.</st> <st c="30281">So, install Redis in Windows using</st> <st
    c="30315">the</st> **<st c="30320">Windows Subsystem for Linux</st>** <st c="30347">(</st>**<st
    c="30349">WSL2</st>**<st c="30353">) shell or by downloading the Windows installer</st>
    <st c="30402">at</st> [<st c="30405">https://github.com/microsoftarchive/redis/releases</st>](https://github.com/microsoftarchive/redis/releases)<st
    c="30455">.</st>
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="30074">指定工作者后，Celery 需要一个消息代理来让工作者与客户端应用程序通信，以便运行后台任务。</st> <st c="30232">我们的应用程序使用
    Redis 数据库作为代理。</st> <st c="30281">因此，在 Windows 上使用</st> <st c="30315">**<st c="30320">Windows
    Subsystem for Linux</st>** <st c="30347">(</st>**<st c="30349">WSL2</st>**<st
    c="30353">) shell</st> <st c="30347">或通过在</st> [<st c="30405">https://github.com/microsoftarchive/redis/releases</st>](https://github.com/microsoftarchive/redis/releases)<st
    c="30455">下载 Windows 安装程序</st> <st c="30402">来安装 Redis。</st>
- en: <st c="30456">The next step is to add the necessary Celery configuration variables,
    including</st> `<st c="30537">CELERY_BROKER_URL</st>`<st c="30554">, to the</st>
    `<st c="30563">app</st>` <st c="30566">instance.</st>
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="30456">下一步是向</st> <st c="30563">app</st> <st c="30566">实例</st> <st c="30563">添加必要的
    Celery 配置变量，包括</st> `<st c="30537">CELERY_BROKER_URL</st>`<st c="30554">。</st>
- en: <st c="30576">Setting up the Celery client configuration</st>
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="30576">设置 Celery 客户端配置</st>
- en: <st c="30619">Since our projects use</st> <st c="30642">TOML files for setting
    the configuration environment variables, Celery will fetch all its configuration
    details from these files as TOML variables.</st> <st c="30791">The following is
    a snapshot of the</st> `<st c="30826">config_dev.toml</st>` <st c="30841">file
    that contains Celery</st> <st c="30868">setup variables:</st>
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="30619">由于我们的项目使用</st>` `<st c="30642">TOML</st>` `<st c="30645">文件来设置配置环境变量，Celery
    将从这些文件中作为 TOML 变量获取所有配置详细信息。</st> `<st c="30791">以下是对</st>` `<st c="30826">config_dev.toml</st>`
    `<st c="30841">文件的快照，该文件包含 Celery</st>` `<st c="30868">设置变量：</st>`'
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: <st c="31465">The two most</st> <st c="31478">important variables needed by
    the Celery client module are</st> `<st c="31538">CELERY_BROKER_URL</st>` <st c="31555">and</st>
    `<st c="31560">CELERY_RESULT_BACKEND</st>`<st c="31581">, which provide the address,
    port, and DB name of the Redis broker and backend server, respectively.</st> <st
    c="31682">Redis has DBs</st> `<st c="31696">0</st>` <st c="31697">to</st> `<st
    c="31701">15</st>`<st c="31703">, but our application utilizes only DB</st> `<st
    c="31742">0</st>` <st c="31743">for default purposes.</st> <st c="31766">Since
    the</st> `<st c="31776">CELERY_RESULT_BACKEND</st>` <st c="31797">is not that
    important in this setup, setting</st> `<st c="31843">CELERY_RESULT_BACKEND</st>`
    <st c="31864">as the defined broker URL or removing it from the configuration</st>
    <st c="31929">is acceptable.</st>
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Celery 客户端模块需要的两个最重要的变量是 `<st c="31465">CELERY_BROKER_URL</st>` `<st c="31478">和</st>
    `<st c="31483">CELERY_RESULT_BACKEND</st>` `<st c="31505">，它们分别提供 Redis 代理和后端服务器的地址、端口和
    DB 名称。</st> `<st c="31682">Redis 有 DB</st>` `<st c="31696">0</st>` `<st c="31697">到</st>`
    `<st c="31701">15</st>` `<st c="31703">，但我们的应用程序仅使用 DB</st>` `<st c="31742">0</st>`
    `<st c="31743">作为默认用途。</st> `<st c="31766">由于</st>` `<st c="31776">CELERY_RESULT_BACKEND</st>`
    `<st c="31797">在此配置中不是那么重要，因此将</st>` `<st c="31843">CELERY_RESULT_BACKEND</st>`
    `<st c="31864">设置为定义的代理 URL 或从配置中删除它是可接受的。</st>`
- en: <st c="31943">Then, create the</st> `<st c="31961">CELERY</st>` <st c="31967">TOML
    dictionary to contain the details needed by the Celery instance in managing the
    background task executions.</st> <st c="32081">First,</st> `<st c="32088">celery_store_errors_even_if_ignored</st>`
    <st c="32123">and</st> `<st c="32128">task_store_errors_even_if_ignored</st>`
    <st c="32161">must be</st> `<st c="32170">True</st>` <st c="32174">to enable audit
    trail features for logging errors during Celery execution.</st> `<st c="32250">broker_connection_retry_on_startup</st>`
    <st c="32284">should be</st> `<st c="32295">True</st>` <st c="32299">in case Redis
    is still in shutdown mode.</st> <st c="32341">On the other hand,</st> `<st c="32360">task_ignore_result</st>`
    <st c="32378">must be</st> `<st c="32387">False</st>` <st c="32392">since some
    of our coroutine jobs will be returning some values to the caller.</st> <st c="32471">Moreover,</st>
    `<st c="32481">task_create_missing_queues</st>` <st c="32507">is set to</st> `<st
    c="32518">True</st>` <st c="32522">in case there are undefined task queues that
    the application can utilize during traffic.</st> <st c="32612">By the way, the
    default task queue’s name</st> <st c="32654">is</st> `<st c="32657">celery</st>`<st
    c="32663">.</st>
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，创建包含 Celery 实例在管理后台任务执行所需详细信息的 `<st c="31943">CELERY</st>` `<st c="31961">TOML</st>`
    字典。<st c="32081">首先，</st> `<st c="32088">celery_store_errors_even_if_ignored</st>`
    `<st c="32123">和</st> `<st c="32128">task_store_errors_even_if_ignored</st>` `<st
    c="32161">必须</st> `<st c="32170">设置为</st>` `<st c="32174">True</st>` `<st c="32178">以启用
    Celery 执行期间的错误审计跟踪功能。</st> `<st c="32250">broker_connection_retry_on_startup</st>`
    `<st c="32284">应该</st> `<st c="32295">设置为</st>` `<st c="32299">True</st>` `<st
    c="32303">以防 Redis 仍在关闭模式。</st> `<st c="32341">另一方面，</st>` `<st c="32360">task_ignore_result</st>`
    `<st c="32378">必须</st> `<st c="32387">设置为</st>` `<st c="32392">False</st>` `<st
    c="32396">因为我们的一些协程作业将返回一些值给调用者。</st> `<st c="32471">此外，</st>` `<st c="32481">task_create_missing_queues</st>`
    `<st c="32507">设置为</st>` `<st c="32518">True</st>` `<st c="32522">以防在流量期间有未定义的任务队列供应用程序使用。</st>
    `<st c="32612">顺便说一下，默认任务队列的名称</st>` `<st c="32654">是</st>` `<st c="32657">celery</st>`
    `<st c="32663">。</st>`
- en: <st c="32664">Other details are about the mime-type of resources that tasks
    can accept for their coroutines (</st>`<st c="32760">celery_accept_content</st>`<st
    c="32782">) and the returned values that these background processes can return
    to the invoker (</st>`<st c="32868">celery_result_accept_content</st>`<st c="32897">).</st>
    <st c="32901">The task serializers are also part of the details because they are
    the mechanisms that convert the task’s incoming arguments and returning</st> <st
    c="33039">values to be in their acceptable state and valid</st> <st c="33089">mime-type
    types.</st>
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="32664">其他细节包括任务可以接受用于其协程的资源 mime-type（</st>`<st c="32760">celery_accept_content</st>`<st
    c="32782">）以及这些后台进程可以向调用者返回的返回值（</st>`<st c="32868">celery_result_accept_content</st>`<st
    c="32897">）。</st> <st c="32901">任务序列化器也是细节的一部分，因为它们是将任务的传入参数和返回</st> <st c="33039">值转换为可接受状态和有效</st>
    <st c="33089">mime-type 类型</st>的机制。
- en: <st c="33105">Now, let us focus on building the Celery client modules of our
    projects, starting with the instantiation of the</st> <st c="33218">Celery instance.</st>
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="33105">现在，让我们专注于构建我们项目的 Celery 客户端模块，从创建</st> <st c="33218">Celery 实例</st>开始。
- en: <st c="33234">Creating the Client instance</st>
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="33234">创建客户端实例</st>
- en: <st c="33263">Since all</st> <st c="33274">projects in this chapter use the
    application factory approach, the setup recognizing the application as a Celery
    client happens in</st> `<st c="33405">app/__init__.py</st>`<st c="33420">. However,
    the exact</st> `<st c="33441">Celery</st>` <st c="33447">class instantiation occurs
    in another module,</st> `<st c="33494">celery_config.py</st>`<st c="33510">, to
    avoid circular import errors.</st> <st c="33545">The following snippet shows the
    instantiation of the</st> `<st c="33598">Celery</st>` <st c="33604">class</st>
    <st c="33611">in</st> `<st c="33614">celery_config.py</st>`<st c="33630">:</st>
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="33263">由于本章中的所有</st> <st c="33274">项目都使用应用程序工厂方法，识别应用程序作为 Celery 客户端的设置发生在</st>
    `<st c="33405">app/__init__.py</st>`<st c="33420">中。</st> 然而，确切的</st> `<st c="33441">Celery</st>`
    <st c="33447">类实例化发生在另一个模块中，</st> `<st c="33494">celery_config.py</st>`<st c="33510">，以避免循环导入错误。</st>
    <st c="33545">以下代码片段显示了在</st> `<st c="33614">celery_config.py</st>`<st c="33630">中创建</st>
    `<st c="33598">Celery</st>` <st c="33604">类的实例：</st>
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: <st c="34104">From the preceding snippet, the instantiation of the</st> `<st
    c="34158">Celery</st>` <st c="34164">class strictly requires the Celery application
    name,</st> `<st c="34218">CELERY_BROKER_URL</st>`<st c="34235">, and the worker
    task.</st> <st c="34258">The first parameter, the Celery application name, can
    have any prescribed name or just the Flask app’s name since the Celery client
    module will run background jobs (</st>`<st c="34423">FlaskTask</st>`<st c="34433">)
    in the</st> <st c="34443">app’s thread.</st>
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="34104">从前面的代码片段中，创建</st> `<st c="34158">Celery</st>` <st c="34164">类的实例严格需要
    Celery 应用程序名称，</st> `<st c="34218">CELERY_BROKER_URL</st>`<st c="34235">，以及工作任务。</st>
    <st c="34258">第一个参数，Celery 应用程序名称，可以有任何指定的名称，或者直接使用 Flask 应用程序的名称，因为 Celery 客户端模块将在应用程序的线程中运行后台作业（</st>`<st
    c="34423">FlaskTask</st>`<st c="34433">）。</st>
- en: <st c="34456">After</st> <st c="34462">instantiating the Celery, the Celery
    instance,</st> `<st c="34510">celery_app</st>`<st c="34520">, needs to load the</st>
    `<st c="34540">CELERY</st>` <st c="34546">TOML dictionary from the Flask</st>
    `<st c="34578">app</st>` <st c="34581">to configure the task queue and its message
    broker.</st> <st c="34634">Lastly,</st> `<st c="34642">celery_app</st>` <st c="34652">must
    invoke</st> `<st c="34665">set_default()</st>` <st c="34678">to seal the configuration.</st>
    <st c="34706">Now,</st> `<st c="34711">app/__init__.py</st>` <st c="34726">will
    import the</st> `<st c="34743">celery_init_app()</st>` <st c="34760">factory to
    eventually pursue the creation of the Celery client out of the</st> <st c="34835">Flask
    application.</st>
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="34456">在</st> <st c="34462">实例化 Celery 之后，Celery 实例，</st> `<st c="34510">celery_app</st>`<st
    c="34520">，需要从 Flask</st> `<st c="34578">app</st>` <st c="34581">加载</st> `<st
    c="34540">CELERY</st>` <st c="34546">TOML 字典来配置任务队列及其消息代理。</st> <st c="34634">最后，</st>
    `<st c="34642">celery_app</st>` <st c="34652">必须调用</st> `<st c="34665">set_default()</st>`
    <st c="34678">来封闭配置。</st> <st c="34706">现在，</st> `<st c="34711">app/__init__.py</st>`
    <st c="34726">将导入</st> `<st c="34743">celery_init_app()</st>` <st c="34760">工厂，以最终从
    Flask 应用程序中创建 Celery 客户端。</st>
- en: <st c="34853">Let us now build the Celery client module with</st> <st c="34901">custom
    tasks.</st>
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="34853">现在，让我们使用自定义任务来构建 Celery 客户端模块。</st>
- en: <st c="34914">Implementing the Celery tasks</st>
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="34914">实现 Celery 任务</st>
- en: <st c="34944">To avoid circular</st> <st c="34963">import problems, it is not
    advisable to import</st> `<st c="35010">celery_app</st>` <st c="35020">and use
    it to decorate functions with the</st> `<st c="35063">task()</st>` <st c="35069">decorator.</st>
    <st c="35081">The</st> `<st c="35085">shared_task()</st>` <st c="35098">decorator
    from the</st> `<st c="35118">celery</st>` <st c="35124">module is enough proxy
    to define functions as Celery tasks.</st> <st c="35185">Here is a Celery task
    that adds a new vote to</st> <st c="35231">a candidate:</st>
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="34944">To avoid circular</st> <st c="34963">import problems, it is not
    advisable to import</st> `<st c="35010">celery_app</st>` <st c="35020">and use
    it to decorate functions with the</st> `<st c="35063">task()</st>` <st c="35069">decorator.</st>
    <st c="35081">The</st> `<st c="35085">shared_task()</st>` <st c="35098">decorator
    from the</st> `<st c="35118">celery</st>` <st c="35124">module is enough proxy
    to define functions as Celery tasks.</st> <st c="35185">Here is a Celery task
    that adds a new vote to</st> <st c="35231">a candidate:</st>
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '<st c="37658">@shared_task</st> def list_all_votes_task_wrapper():'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="37658">@shared_task</st> def list_all_votes_task_wrapper():'
- en: 'async def list_all_votes_task():'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'async def list_all_votes_task():'
- en: 'async with db_session() as sess:'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'async with db_session() as sess:'
- en: 'async with sess.begin():'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'async with sess.begin():'
- en: repo = VoteRepository(sess)
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: repo = VoteRepository(sess)
- en: records = await repo.select_all_vote()
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: records = await repo.select_all_vote()
- en: vote_rec = [rec.to_json() for rec in records]
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: vote_rec = [rec.to_json() for rec in records]
- en: return <st c="37917">dumps(vote_rec,</st> <st c="37932">default=json_date_serializer)</st>
    return <st c="37970">run(list_all_votes_task())</st>
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return <st c="37917">dumps(vote_rec,</st> <st c="37932">default=json_date_serializer)</st>
    return <st c="37970">run(list_all_votes_task())</st>
- en: '<st c="37996">def json_date_serializer(obj):</st> if isinstance(obj, time):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="37996">def json_date_serializer(obj):</st> if isinstance(obj, time):'
- en: return obj.isoformat()
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return obj.isoformat()
- en: raise TypeError ("Type %s not …" % type(obj))
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: raise TypeError ("Type %s not …" % type(obj))
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: celery -A main.celery_app worker --loglevel=info -P solo
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: celery -A main.celery_app worker --loglevel=info -P solo
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: pip install eventlet
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: pip install eventlet
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: <st c="41469">@current_app.post('/ch05/vote/add')</st>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41469">@current_app.post('/ch05/vote/add')</st>
- en: '<st c="41505">async</st> def add_vote():'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="41505">async</st> def add_vote():'
- en: vote_json = request.get_json() <st c="41559">vote_str = dumps(vote_json)</st><st
    c="41586">task =</st> <st c="41593">add_vote_task_wrapper.apply_async(args=[vote_str])</st><st
    c="41644">result = task.get()</st> return jsonify(message=result), 201
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: vote_json = request.get_json() <st c="41559">vote_str = dumps(vote_json)</st><st
    c="41586">task =</st> <st c="41593">add_vote_task_wrapper.apply_async(args=[vote_str])</st><st
    c="41644">result = task.get()</st> return jsonify(message=result), 201
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: <script> <st c="43660">const add_log = (message) => {</st> document.getElementById('add_log').innerHTML
    += `<span>${message}</span><br>`;
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: <script> <st c="43660">const add_log = (message) => {</st> document.getElementById('add_log').innerHTML
    += `<span>${message}</span><br>`;
- en: '}; <st c="43773">const socket = new WebSocket(''ws://'' + location.host</st>
    <st c="43825">+ ''/ch05/vote/save/ws'');</st><st c="43850">socket.addEventListener(''message'',
    msg => {</st><st c="43894">add_log(''server: '' + msg.data);</st><st c="43926">});</st>
    document.getElementById(''vote_form'').onsubmit = data => {'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}; <st c="43773">const socket = new WebSocket(''ws://'' + location.host</st>
    <st c="43825">+ ''/ch05/vote/save/ws'');</st><st c="43850">socket.addEventListener(''message'',
    msg => {</st><st c="43894">add_log(''server: '' + msg.data);</st><st c="43926">});</st>
    document.getElementById(''vote_form'').onsubmit = data => {'
- en: data.preventDefault();
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: data.preventDefault();
- en: const election_id = document.getElementById('election_id');
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: const election_id = document.getElementById('election_id');
- en: const precinct = document.getElementById('precinct');
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: const precinct = document.getElementById('precinct');
- en: const final_tally = document.getElementById('final_tally');
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: const final_tally = document.getElementById('final_tally');
- en: const approved_date = document.getElementById('approved_date');
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: const approved_date = document.getElementById('approved_date');
- en: var vote_count = new Object();
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: var vote_count = new Object();
- en: vote_count.election_id = election_id.value;
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: vote_count.election_id = election_id.value;
- en: vote_count.precinct  = precinct.value;
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: vote_count.precinct  = precinct.value;
- en: vote_count.final_tally = final_tally.value;
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: vote_count.final_tally = final_tally.value;
- en: vote_count.approved_date = approved_date.value;
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: vote_count.approved_date = approved_date.value;
- en: var vote_count_json = JSON.stringify(vote_count);
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: var vote_count_json = JSON.stringify(vote_count);
- en: 'add_log(''client: '' + vote_count_json); <st c="44544">socket.send(vote_count_json);</st>
    election_id.value = '''';'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'add_log(''client: '' + vote_count_json); <st c="44544">socket.send(vote_count_json);</st>
    election_id.value = '''';'
- en: precinct.value = '';
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: precinct.value = '';
- en: final_tally.value = '';
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: final_tally.value = '';
- en: approved_date.value = '';
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: approved_date.value = '';
- en: '};'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '};'
- en: </script>
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </script>
- en: '[PRE32]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: pip install flask-sock
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: pip install flask-sock
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: <st c="46173">from flask_sock import Sock</st>
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46173">from flask_sock import Sock</st>
- en: '<st c="46201">sock = Sock()</st> def create_app(config_file):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="46201">sock = Sock()</st> def create_app(config_file):'
- en: app = Flask(__name__, template_folder='../app/pages', static_folder="../app/resources")
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: app = Flask(__name__, template_folder='../app/pages', static_folder="../app/resources")
- en: app.config.from_file(config_file, toml.load)
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: app.config.from_file(config_file, toml.load)
- en: 'init_db() <st c="46451">sock</st> instance in <st c="46468">/api/ votecount_websocket.py
    module</st> to define the WebSocket routes. <st c="46536">ws://localhost:5001/ch05/vote/save/ws</st>,
    which was invoked by the preceding JS code, has the following route implementation:'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在<st c="46468">/api/ votecount_websocket.py模块</st>中初始化<st c="46451">sock</st>实例以定义WebSocket路由。
    <st c="46536">ws://localhost:5001/ch05/vote/save/ws</st>，这是由前面的JS代码调用的，具有以下路由实现：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: <st c="47092">The</st> `<st c="47097">Sock</st>` <st c="47101">instance has
    a</st> `<st c="47117">route()</st>` <st c="47124">decorator that defines WebSocket
    implementation.</st> <st c="47174">WebSocket route function or handler is always
    non-asynchronous with a required parameter that accepts an injected WebSocket
    object from</st> `<st c="47310">Sock</st>`<st c="47314">. This</st> `<st c="47321">ws</st>`
    <st c="47323">object has a</st> `<st c="47337">send()</st>` <st c="47343">method
    that emits data to the client application, a</st> `<st c="47396">receive()</st>`
    <st c="47405">utility that accepts messages from the client, and</st> `<st c="47457">close()</st>`
    <st c="47464">to employ forced disconnection of the two-way communication when
    runtime exceptions or server-related</st> <st c="47567">problems occur.</st>
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="47092">Sock</st> <st c="47101">实例有一个</st> `<st c="47117">route()</st>`
    <st c="47124">装饰器，用于定义WebSocket实现。</st> <st c="47174">WebSocket路由函数或处理程序始终是非异步的，并需要一个接受从</st>
    `<st c="47310">Sock</st>`<st c="47314">注入的WebSocket对象的必需参数。</st> 这个<st c="47321">ws</st>
    <st c="47323">对象有一个<st c="47337">send()</st> <st c="47343">方法，用于向客户端应用程序发送数据，一个<st
    c="47396">receive()</st> <st c="47405">实用工具，用于接受来自客户端的消息，以及</st> `<st c="47457">close()</st>`
    <st c="47464">用于在运行时异常或与服务器相关的问题发生时强制断开双向通信。</st>
- en: <st c="47582">The</st> <st c="47587">WebSocket handler usually holds an</st>
    *<st c="47622">open loop process</st>* <st c="47639">where it can receive a message
    first through</st> `<st c="47685">receive()</st>` <st c="47694">and then emit
    its message using</st> `<st c="47727">send()</st>` <st c="47733">continuously,
    depending on the purpose of</st> <st c="47776">the messaging.</st>
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="47582">WebSocket处理程序通常保持一个</st> *<st c="47622">开环过程</st> <st c="47639">，其中它可以首先通过</st>
    `<st c="47685">receive()</st>` <st c="47694">接收消息，然后使用</st> `<st c="47727">send()</st>`
    <st c="47733">连续地发出其消息，具体取决于消息的目的。</st>
- en: <st c="47790">In the case of</st> `<st c="47806">add_vote_count_server()</st>`<st
    c="47829">, which needs to await asynchronous</st> `<st c="47865">VoteCountRepository</st>`<st
    c="47884">’s INSERT transaction, an</st> `<st c="47911">async</st>` <st c="47916">local
    method similar to the Celery task must be present inside the WebSocket route function.</st>
    <st c="48010">This local method will encase the asynchronous operations, and the</st>
    `<st c="48077">asyncio</st>`<st c="48084">’s</st> `<st c="48088">run()</st>` <st
    c="48093">will execute it inside the</st> <st c="48121">route function.</st>
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="47790">在<st c="47806">add_vote_count_server()</st> <st c="47829">的情况下，它需要等待异步的</st>
    `<st c="47865">VoteCountRepository</st>` <st c="47884">的INSERT事务，WebSocket路由函数内部必须存在一个类似于Celery任务的</st>
    `<st c="47911">async</st>` <st c="47916">本地方法。</st> <st c="48010">这个本地方法将封装异步操作，并且</st>
    `<st c="48077">asyncio</st>` <st c="48084">的</st> `<st c="48088">run()</st>` <st
    c="48093">将在路由函数内部执行它。</st>
- en: <st c="48136">Now, to witness the exchange of messages,</st> *<st c="48179">Figure
    5</st>**<st c="48187">.3</st>* <st c="48189">shows a snapshot of the communication
    between our JS client and the</st> `<st c="48258">add_vote_count_server()</st>`
    <st c="48281">handler</st> <st c="48290">at runtime:</st>
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="48136">现在，为了见证消息交换，</st> *<st c="48179">图5</st>**<st c="48187">.3</st>*
    <st c="48189">显示了我们的JS客户端与运行时的</st> `<st c="48258">add_vote_count_server()</st>`
    <st c="48281">处理程序</st> `<st c="48290">之间的通信快照：</st>
- en: '![Figure 5.3 – A message exchange between a JS client and flask-sock WebSocket](img/B19383_05_003.jpg)'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图5.3 – 一个JS客户端与flask-sock WebSocket之间的消息交换](img/B19383_05_003.jpg)'
- en: <st c="48668">Figure 5.3 – A message exchange between a JS client and flask-sock
    WebSocket</st>
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="48668">图5.3 – 一个JS客户端与flask-sock WebSocket之间的消息交换</st>
- en: <st c="48744">Aside from web-based clients, WebSocket can also propagate or
    send data to</st> <st c="48820">API clients.</st>
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="48744">除了基于Web的客户端之外，WebSocket还可以将数据传播或发送到</st> <st c="48820">API客户端。</st>
- en: <st c="48832">Creating a Flask API client application</st>
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="48832">创建Flask API客户端应用程序</st>
- en: <st c="48872">Another way to</st> <st c="48888">connect through WebSocket emitters
    is through Flask components, not JS codes.</st> <st c="48966">Sometimes, the client
    applications are not web components composed of HTML, CSS, and frontend JS frameworks
    that support WebSocket communication.</st> <st c="49112">For instance, in our</st>
    `<st c="49133">ch05-api</st>` <st c="49141">project, a POST API function,</st>
    `<st c="49172">bulk_check_vote_count()</st>`<st c="49195">, asks for a list of
    candidates to count the votes they have during the election.</st> <st c="49277">The
    input to the API is a JSON string, such as the following</st> <st c="49338">sample
    data:</st>
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="48872">另一种通过WebSocket发射器连接的方式是通过Flask组件，而不是JS代码。</st> <st c="48888">有时，客户端应用程序不是由HTML、CSS和前端JS框架组成的支持WebSocket通信的Web组件。</st>
    <st c="49112">例如，在我们的</st> `<st c="49133">ch05-api</st>` <st c="49141">项目中，一个POST
    API函数</st> `<st c="49172">bulk_check_vote_count()</st>`<st c="49195">，要求列出候选人以计算他们在选举期间获得的选票。</st>
    <st c="49277">API的输入是一个JSON字符串，如下所示</st> <st c="49338">样本数据：</st>
- en: '[PRE35]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: <st c="49485">Then, the API function converts this JSON input to a list of dictionaries
    containing the candidate and election IDs.</st> <st c="49603">Here is the implementation
    of this API function that serves as a client to</st> <st c="49678">a WebSocket:</st>
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="49485">然后，API函数将此JSON输入转换为包含候选人和选举ID的字典列表。</st> <st c="49603">以下是实现此API函数的代码，该函数作为WebSocket的客户端：</st>
    <st c="49678">客户端：</st>
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: <st c="50217">Since the most compatible WebSocket client extension for</st>
    `<st c="50275">flask-sock</st>` <st c="50285">is</st> `<st c="50289">simple-websocket</st>`<st
    c="50305">, install this module using the</st> `<st c="50337">pip</st>` <st c="50340">command:</st>
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="50217">对于与</st> `<st c="50275">flask-sock</st>` <st c="50285">最兼容的WebSocket客户端扩展是</st>
    `<st c="50289">simple-websocket</st>`<st c="50305">，请使用以下</st> `<st c="50337">pip</st>`
    <st c="50340">命令安装此模块：</st>
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: <st c="50378">Instantiate the</st> `<st c="50395">Client</st>` <st c="50401">class</st>
    <st c="50407">from the</st> `<st c="50417">simple-websocket</st>` <st c="50433">module
    to connect to the</st> `<st c="50459">flask-sock</st>` <st c="50469">WebSocket
    emitter with</st> `<st c="50493">Access-Control-Allow-Origin</st>` <st c="50520">to
    allow cross-origin access.</st> <st c="50551">Then, the API will send the dictionary-converted-to-string
    details to the emitter using the</st> `<st c="50643">Client</st>`<st c="50649">’s</st>
    `<st c="50653">send()</st>` <st c="50659">method.</st>
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="50378">从</st> `<st c="50417">simple-websocket</st>` <st c="50433">模块实例化</st>
    `<st c="50495">Client</st>` <st c="50401">类</st> <st c="50407">以连接到具有</st> `<st
    c="50459">flask-sock</st>` <st c="50469">WebSocket发射器，并使用</st> `<st c="50493">Access-Control-Allow-Origin</st>`
    <st c="50520">允许跨域访问。</st> <st c="50551">然后，API将通过</st> `<st c="50643">Client</st>`<st
    c="50649">的</st> `<st c="50653">send()</st>` <st c="50659">方法将转换为字符串的字典详情发送到发射器。</st>
- en: <st c="50667">On the other hand, the WebSocket route that will receive the election
    details from the</st> `<st c="50755">bulk_check_vote_count()</st>` <st c="50778">client
    API has the</st> <st c="50798">following implementation:</st>
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="50667">另一方面，将接收来自</st> `<st c="50755">bulk_check_vote_count()</st>` <st
    c="50778">客户端API的选举详情的WebSocket路由具有以下实现：</st>
- en: '[PRE38]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: pip install redis
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: pip install redis
- en: '[PRE39]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: from app import create_app <st c="53471">from redis import Redis</st> app =
    create_app('../config_dev.toml') <st c="53534">redis_conn = Redis(</st><st c="53553">db
    = 0,</st><st c="53561">host='127.0.0.1',</st><st c="53579">port=6379,</st><st
    c="53590">decode_responses=True</st> )
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: from app import create_app <st c="53471">from redis import Redis</st> app =
    create_app('../config_dev.toml') <st c="53534">redis_conn = Redis(</st><st c="53553">db
    = 0,</st><st c="53561">host='127.0.0.1',</st><st c="53579">port=6379,</st><st
    c="53590">decode_responses=True</st> )
- en: '[PRE40]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: <st c="54293">from main import redis_conn</st> from  json import dumps <st c="54345">@current_app.route('/ch05/election/complaint/form',
    methods = ['GET','POST'])</st>
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54293">from main import redis_conn</st> from  json import dumps <st c="54345">@current_app.route('/ch05/election/complaint/form',
    methods = ['GET','POST'])</st>
- en: '<st c="54422">async</st> def create_complaint():'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="54422">async</st> def create_complaint():'
- en: 'if request.method == "GET":'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if request.method == "GET":'
- en: return render_template('complaint_form.html')
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return render_template('complaint_form.html')
- en: 'else:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'else:'
- en: voter_id = request.form['voter_id']
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: voter_id = request.form['voter_id']
- en: complaint = request.form['complaint']
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: complaint = request.form['complaint']
- en: 'record = {''voter_id'': voter_id, ''complaint'': complaint} <st c="54663">redis_conn.publish("complaint_channel",</st>
    <st c="54702">dumps(record))</st> return render_template(''complaint_form.html'')'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'record = {''voter_id'': voter_id, ''complaint'': complaint} <st c="54663">redis_conn.publish("complaint_channel",</st>
    <st c="54702">dumps(record))</st> return render_template(''complaint_form.html'')'
- en: '[PRE41]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: <st c="55344">@current_app.route('/ch05/elec/comaplaint/stream')</st>
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55344">@current_app.route('/ch05/elec/comaplaint/stream')</st>
- en: '<st c="55395">async</st> def elec_complaint_sse():'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="55395">async</st> def elec_complaint_sse():'
- en: 'def process_complaint_event(): <st c="55459">connection = redis_conn.pubsub()</st><st
    c="55491">connection.subscribe(''complaint_channel'')</st> for message in <st
    c="55549">connection.listen()</st>:'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def process_complaint_event(): <st c="55459">connection = redis_conn.pubsub()</st><st
    c="55491">connection.subscribe(''complaint_channel'')</st> for message in <st
    c="55549">connection.listen()</st>:'
- en: time.sleep(1)
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: time.sleep(1)
- en: 'if message is not None and message[''type''] == ''message'': <st c="55642">data
    = message[''data'']</st><st c="55664">yield ''data: %s\n\n'' % data</st> return
    <st c="55765">process_complaint_event()</st> in the given SSE route is the *<st
    c="55822">generator function</st>* that creates the subscriber object (<st c="55877">connection</st>),
    connects to Redis by invoking the <st c="55926">subscribe()</st> method, and builds
    an open loop transaction that will listen continuously from the broker for currently
    published messages. The message it retrieves from the <st c="56096">listen()</st>
    utility of the subscriber object is a JSON entity containing details about the
    message type, channel, and the <st c="56215">data</st> published by the form view
    publisher. <st c="56258">elec_complaint_sse()</st> only needs to yield the <st
    c="56303">data</st> portion of the message. Now, running the <st c="56349">process_complaint_event()</st>
    generator requires the SSE route to return Flask’s <st c="56426">Response</st>,
    which will execute and render it as a <st c="56474">text/event-stream</st> type
    object. *<st c="56505">Figure 5</st>**<st c="56513">.4</st>* shows the form view
    catering to the voters for their complaints:'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if message is not None and message[''type''] == ''message'': <st c="55642">data
    = message[''data'']</st><st c="55664">yield ''data: %s\n\n'' % data</st> return
    <st c="55765">process_complaint_event()</st> 在给定的 SSE 路由中是 *<st c="55822">生成器函数</st>*，它创建订阅者对象
    (<st c="55877">connection</st>)，通过调用 <st c="55926">subscribe()</st> 方法连接到 Redis，并构建一个开放循环事务，该事务将连续从代理监听当前发布的消息。它从订阅者对象的
    <st c="56096">listen()</st> 实用程序检索到的消息是一个包含有关消息类型、通道和表单视图发布者发布的 <st c="56215">数据</st>
    的 JSON 实体。<st c="56258">elec_complaint_sse()</st> 只需要产生消息的 <st c="56303">数据</st>
    部分。现在，运行 <st c="56349">process_complaint_event()</st> 生成器需要 SSE 路由返回 Flask 的 <st
    c="56426">Response</st>，这将执行并渲染它为一个 <st c="56474">text/event-stream</st> 类型的对象。*<st
    c="56505">图 5</st>**<st c="56513">.4</st>* 展示了为投票者提供投诉的表单视图：'
- en: '![Figure 5.4 – A complaint form view of the published data to Redis](img/B19383_05_004.jpg)'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 5.4 – 从 Redis 发布的数据的投诉表单视图](img/B19383_05_004.jpg)'
- en: <st c="56748">Figure 5.4 – A complaint form view of the published data to Redis</st>
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="56748">图 5.4 – 发布到 Redis 的数据投诉表单视图</st>
- en: '*<st c="56813">Figure 5</st>**<st c="56822">.5</st>* <st c="56824">provides
    a snapshot of the SSE client page with the pushed messages from the</st> <st c="56902">Redis
    broker.</st>'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*<st c="56813">图 5</st>**<st c="56822">.5</st>* 提供了包含从 Redis 代理推送的消息的 SSE 客户端页面的快照。'
- en: '![Figure 5.5 – An SSE client page rendering pushed data from Redis](img/B19383_05_005.jpg)'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 5.5 – 从 Redis 推送数据渲染的 SSE 客户端页面](img/B19383_05_005.jpg)'
- en: <st c="57234">Figure 5.5 – An SSE client page rendering pushed data from Redis</st>
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="57234">图 5.5 – 从 Redis 推送数据渲染的 SSE 客户端页面</st>
- en: <st c="57298">Aside from broker messaging, Flask supports other libraries that
    use publisher-subscriber design patterns in creating its components.</st> <st
    c="57433">The next subject will showcase one of them, the</st> `<st c="57481">reactivex</st>`
    <st c="57490">module.</st>
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="57298">除了代理消息之外，Flask 还支持其他库，这些库在创建其组件时使用发布者-订阅者设计模式。<st c="57433">下一个主题将展示其中之一，即</st>
    `<st c="57481">reactivex</st> <st c="57490">模块。</st>`
- en: <st c="57498">Applying reactive programming with RxPy</st>
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="57498">使用 RxPy 进行响应式编程</st>
- en: '**<st c="57538">Reactive programming</st>** <st c="57559">is</st> <st c="57563">one
    of the emerging popular programming paradigms nowadays that focuses on asynchronous
    data streams and operations that can manage executions, events, repositories,
    and exception propagations.</st> <st c="57757">It utilizes the publisher-subscriber
    programming approach, which builds asynchronous interactions between software
    components</st> <st c="57883">and transactions.</st>'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**<st c="57538">响应式编程</st>** <st c="57559">是当今兴起的一种流行编程范式之一，它侧重于异步数据流和可以管理执行、事件、存储库和异常传播的操作。<st
    c="57757">它利用发布者-订阅者编程方法，该方法在软件组件和事务之间建立异步交互。</st> <st c="57883">它支持 Flask 的其他库，这些库在创建其组件时使用发布者-订阅者设计模式。</st>'
- en: <st c="57900">The</st> <st c="57904">library used to apply reactive streams
    to build services transactions and API functions in this chapter is</st> `<st
    c="58012">reactivex</st>`<st c="58021">, so install the module using the</st>
    `<st c="58055">pip</st>` <st c="58058">command:</st>
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: <st c="58089">The</st> `<st c="58094">reactivex</st>` <st c="58103">module has
    an</st> `<st c="58118">Observable</st>` <st c="58128">class that generates data
    sources for the subscribers to consume.</st> `<st c="58195">Observer</st>` <st
    c="58203">is another API class that pertains to the subscriber entities.</st>
    `<st c="58267">reactivex</st>` <st c="58276">will not be a complete reactive programming
    library without its</st> *<st c="58341">operators</st>*<st c="58350">. The following
    is a vote-counting service implementation that uses the</st> `<st c="58422">reactivex</st>`
    <st c="58431">utilities:</st>
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: from app.services.vote_count import create_observable
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'from asyncio import get_event_loop, Future <st c="61067">@current_app.get("/ch05/votecount/tally")</st>
    async def list_votecount_tally():'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'finished = Future() <st c="61163">loop = get_event_loop()</st> def on_completed():'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: finished.set_result(0)
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'tally = [] <st c="61241">disposable</st> = <st c="61254">create_observable(loop).subscribe(</st><st
    c="61288">on_next = lambda i: tally.append(i),</st><st c="61325">on_error = lambda
    e: print("Error</st> <st c="61359">Occurred: {0}".format(e)),</st><st c="61386">on_completed
    = on_completed)</st><st c="61415">await finished</st><st c="61430">disposable.dispose()</st>
    return jsonify(tally=tally), 201'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: <st c="63374">from quart import Quart</st> import toml
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: from app.model.config import init_db
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: from app.api.home import home, welcome
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: from app.api.login import add_login, list_all_login
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_app(config_file): <st c="63568">app = Quart(__name__, template_folder=''../app/pages'',</st>
    <st c="63621">static_folder="../app/resources")</st><st c="63655">app.config.from_file(config_file,
    toml.load)</st> init_db()'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: app.<st c="63715">add_url_rule</st>('/ch05/home', view_func=home, endpoint='home')
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app.<st c="63781">add_url_rule</st>('/ch05/welcome', view_func=welcome, endpoint='welcome')
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app.<st c="63856">add_url_rule</st>('/ch05/login/add', view_func=add_login,
    endpoint='add_login')
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app.<st c="63937">add_url_rule</st>('/ch05/login/list/all', view_func=list_all_login,
    endpoint='list_all_login')
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return app
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: <st c="65402">from quart import jsonify, render_template, request,</st> <st
    c="65455">make_response</st>
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="65469">async def add_login():</st> async with db_session() as sess:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: repo = LoginRepository(sess)
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: login_json = request.get_json()
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: login = Login(**login_json)
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: result = await repo.insert(login)
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if result: <st c="65660">content = jsonify(login_json)</st><st c="65689">return
    await make_response(content, 201)</st> else:'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: content = jsonify(message="insert complaint details record encountered a problem")
    <st c="65820">return await make_response(content, 500)</st>
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '<st c="65860">async</st> def welcome(): <st c="65949">render_template()</st>
    and <st c="65971">make_response()</st> here in Quart need the <st c="66010">await</st>
    keyword. Another difference is Quart’s use of <st c="66062">hypercorn</st> to
    run its applications instead of the Werkzeug server. So, install <st c="66140">hypercorn</st>
    using the <st c="66160">pip</st> command:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: <st c="66194">Then, run the application with the</st> `<st c="66230">hypercorn</st>`
    `<st c="66240">main:app</st>` <st c="66248">command.</st>
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="66257">So far, in</st> <st c="66269">general, Quart has been a promising
    asynchronous framework.</st> <st c="66329">Let’s hope that collaborations with
    the creator, support groups, and enthusiasts can help upgrade and expand this
    framework in the</st> <st c="66460">near future.</st>
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="66472">Summary</st>
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="66480">Flask 2.2 is now at par with the other frameworks that support
    and utilize asynchronous solutions to improve the application’s runtime performance.</st>
    <st c="66629">Its view and API functions can now be</st> `<st c="66667">async</st>`
    <st c="66672">and runnable on an event loop created by Flask.</st> <st c="66721">Asynchronous
    services and transactions can now be executed and awaited on the Flask platform
    as tasks created by</st> `<st c="66834">create_task()</st>` <st c="66847">and</st>
    `<st c="66852">ensure_future()</st>`<st c="66867">.</st>
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="66868">The latest</st> *<st c="66880">SQLAlchemy[async]</st>* <st c="66897">can
    easily integrate with the Flask application to provide asynchronous CRUD transactions.</st>
    <st c="66989">Also, creating asynchronous tasks to break down the sequence of
    blocking transactions in Celery background processes, WebSocket messaging, and
    Observable operations are now possible with</st> <st c="67176">Flask 2.2.</st>
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="67186">Moreover, designing loosely coupled components, application-scoped
    cross-cut concern solutions, and some distributed setups is now feasible with
    Flask 2.2 through the built-in</st> <st c="67363">asynchronous signals.</st>
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="67384">There is even a 100% asynchronous Flask framework called Quart
    that can build fast-performing</st> <st c="67479">request-response transactions.</st>
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="67509">Although the purpose of asynchronous support in Flask is for performance,
    there is still a boundary on when it can be part of our applications.</st> <st
    c="67654">Some components or utilities will degrade in their running time when
    used with</st> `<st c="67733">asyncio</st>`<st c="67740">. Others, such as CRUD
    operations, will slow down DB access due to DB specifications that do not comply
    with the asynchronous setup.</st> <st c="67873">So, the effect of asynchronous
    programming still depends on the requirements of the projects and the resources
    the</st> <st c="67988">application uses.</st>
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="68005">The next chapter will bring us to the computational world of Flask,
    which deals with</st> `<st c="68091">numpy</st>`<st c="68096">,</st> `<st c="68098">pandas</st>`<st
    c="68104">, graphs, charts, statistics, file serializations, and other scientific
    solutions that Flask</st> <st c="68197">can provide.</st>
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="68005">下一章将带我们进入Flask的计算世界，它涉及</st> `<st c="68091">numpy</st>`<st c="68096">,</st>
    `<st c="68098">pandas</st>`<st c="68104">, 图表，统计，文件序列化以及其他Flask</st> <st c="68197">可以提供的科学解决方案。</st>
- en: '[PRE47]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
