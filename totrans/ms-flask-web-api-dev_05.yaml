- en: <st c="0">5</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2">Building Asynchronous Transactions</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="36">After rigorous discussion on the core components and advanced features
    of the Flask 3.0 framework, this chapter will explore Flask’s capability to manage
    requests and responses asynchronously and its ability to execute asynchronous
    services and</st> <st c="282">repository transactions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="306">Flask was originally a standard Python framework that ran on the</st>
    `<st c="589">asyncio</st>` <st c="596">utilities and build asynchronous repository
    transactions with</st> <st c="659">SQLAlchemy 2.x.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="674">This chapter will also explore other avenues that help provide Flask
    applications with the fastest performance using asynchronous mechanisms, such
    as Celery tasks, task queues, WebSocket, and server push.</st> <st c="880">The
    chapter will also introduce</st> **<st c="912">Quart</st>**<st c="917">, the asynchronous
    Flask-based platform that can build and run all components asynchronously compared
    to the original</st> <st c="1035">Flask framework.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1051">Here are the topics that this chapter</st> <st c="1090">will highlight:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1105">Creating asynchronous</st> <st c="1128">Flask components</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1144">Building an asynchronous SQLAlchemy</st> <st c="1181">repository
    layer</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1197">Implementing async transactions</st> <st c="1230">with</st> `<st
    c="1235">asyncio</st>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1242">Utilizing asynchronous</st> <st c="1266">signal notifications</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1286">Constructing background tasks with Celery</st> <st c="1329">and
    Redis</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1338">Building WebSockets with</st> <st c="1364">asynchronous transactions</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1389">Implementing asynchronous</st> **<st c="1416">Server-Sent</st>**
    **<st c="1428">Events</st>** <st c="1434">(</st>**<st c="1436">SSE</st>**<st c="1439">)</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1441">Applying reactive programming</st> <st c="1471">with RxPy</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1480">Choosing Quart over</st> <st c="1501">Flask 2.x</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1510">Technical requirements</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1533">This chapter will highlight an</st> *<st c="1565">Online Voting
    System</st>* <st c="1585">prototype with some asynchronous tasks and background
    processes to manage the high bandwidth of candidates’ applications and election-related
    submissions from different areas and to cater to the simultaneous retrieval of
    vote tallies from various parties.</st> <st c="1842">The system is composed of
    three separate projects, namely</st> `<st c="1900">ch05-api</st>`<st c="1908">,
    which has the API endpoints,</st> `<st c="1939">ch05-web</st>`<st c="1947">, which
    implements the SSE, WebSocket, and template-based results, and</st> `<st c="2018">ch05-quart</st>`<st
    c="2028">, which provides another platform for the app using the Quart framework.</st>
    <st c="2101">All these projects use the</st> **<st c="2128">application factory
    design</st>** <st c="2154">pattern and are available</st> <st c="2181">at</st>
    [<st c="2184">https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch05</st>](https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch05)<st
    c="2265">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2266">Creating asynchronous Flask components</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2305">Flask 2.3 and up</st> <st c="2322">to the current version support
    running asynchronous API endpoint and web-based view functions over its WSGI-based
    platform.</st> <st c="2447">However, to fully use this feature, install the</st>
    `<st c="2495">flask[async]</st>` <st c="2507">module using the following</st>
    `<st c="2535">pip</st>` <st c="2538">command:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <st c="2572">After installing the</st> `<st c="2594">flask[async]</st>` <st
    c="2606">module, implementing synchronous views using the</st> `<st c="2656">async</st>`<st
    c="2661">/</st>`<st c="2663">await</st>` <st c="2668">design pattern can now</st>
    <st c="2692">be feasible.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2704">Implementing asynchronous views and endpoints</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="2750">Like</st> <st c="2755">Django or FastAPI, creating asynchronous
    views and endpoints in the Flask framework involves applying the</st> `<st c="2862">async</st>`<st
    c="2867">/</st>`<st c="2869">await</st>` <st c="2874">keywords.</st> <st c="2885">The
    following web view from</st> `<st c="2913">ch05-web</st>` <st c="2921">renders
    a welcome greeting message to the users with the description of our</st> *<st
    c="2998">Online</st>* *<st c="3005">Voting</st>* <st c="3011">application:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: <st c="3125">Another asynchronous view function from the other application,</st>
    `<st c="3189">ch05-api</st>`<st c="3197">, is showcased in the following</st>
    <st c="3229">API endpoint that adds new login credentials to the</st> **<st c="3281">database</st>**
    <st c="3289">(</st>**<st c="3291">DB</st>**<st c="3293">):</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: <st c="3660">Both the given view and API functions use</st> `<st c="3703">async</st>`
    <st c="3708">routes to manage their respective request and response objects.</st>
    <st c="3773">Defining these routes with</st> `<st c="3800">async</st>` <st c="3805">creates
    coroutines that Flask 2.x can surprisingly run using the</st> `<st c="3871">run()</st>`
    <st c="3876">utility of the</st> `<st c="3892">asyncio</st>` <st c="3899">module.</st>
    <st c="3908">But how does the Flask framework manage the coroutine executions
    despite the pitfalls of its</st> <st c="4001">WSGI platform?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4015">Flask spawns a</st> `<st c="4084">async</st>`<st c="4089">, the
    framework creates a</st> *<st c="4115">sub-thread</st>* <st c="4125">from the
    worker thread to create an</st> `<st c="4215">asyncio</st>` <st c="4222">utilities.</st>
    <st c="4234">Despite the asynchronous processes, there are still limitations on
    how far</st> `<st c="4309">async</st>` <st c="4314">can push through since the
    environment is still within the WSGI, a synchronous platform.</st> <st c="4404">However,
    for not-so-complex non-blocking transactions, the</st> `<st c="4463">flask[async]</st>`
    <st c="4475">framework is enough to improve software quality</st> <st c="4524">and
    performance.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4540">However, async components</st> <st c="4566">are not limited to
    view and API functions and also have Flask</st> <st c="4629">event handlers.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4644">Implementing the async before_request and after_request handlers</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="4709">Aside from</st> <st c="4721">views and endpoints, the Flask 3.0
    framework allows the</st> <st c="4776">implementation of asynchronous</st> `<st
    c="4808">before_request</st>` <st c="4822">and</st> `<st c="4827">after_request</st>`
    <st c="4840">handlers, just like the following</st> `<st c="4875">ch05-api</st>`
    <st c="4883">handlers that log every API</st> <st c="4912">request transaction:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: <st c="5171">These event handlers still use the</st> `<st c="5207">app</st>`
    <st c="5210">instance created in</st> `<st c="5231">main.py</st>` <st c="5238">to
    create the log files using the built-in</st> `<st c="5282">logging</st>` <st c="5289">module.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5297">On the other hand, the</st> `<st c="5321">flask[async]</st>` <st
    c="5333">module can allow the creation of asynchronous</st> <st c="5380">error
    handlers.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5395">Creating asynchronous error handlers</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="5432">Flask 2.x can</st> <st c="5447">decorate coroutines with</st> `<st
    c="5472">@errorhandler</st>` <st c="5485">to manage raised exceptions and HTTP
    status codes.</st> <st c="5537">The following are the asynchronous error handlers
    of the</st> `<st c="5594">ch05-api</st>` <st c="5602">project placed</st> <st
    c="5618">in</st> `<st c="5621">main.py</st>`<st c="5628">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: <st c="6018">Now, all these</st> <st c="6034">asynchronous Flask components
    can also await other asynchronous operations such as the repository layer of the
    application.</st> <st c="6158">Indeed, the asynchronous Flask environment is open
    to integration with asynchronous third-party extension modules such as the async</st>
    <st c="6290">SQLAlchemy 2.x.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6305">Building an asynchronous SQLAlchemy repository layer</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="6358">The</st> <st c="6362">updated</st> `<st c="6371">flask-sqlalchemy</st>`
    <st c="6387">extension module supports SQLAlchemy 2.x that provides API utilities,
    which use the</st> `<st c="6472">asyncio</st>` <st c="6479">environment with</st>
    `<st c="6497">greenlet</st>` <st c="6505">as the main library, allowing propagation
    of the</st> `<st c="6555">await</st>` <st c="6560">keyword in the APIs’ internal
    processes.</st> <st c="6602">Our</st> `<st c="6606">ch05-web</st>` <st c="6614">and</st>
    `<st c="6619">ch05-api</st>` <st c="6627">projects have the async transactions
    that call these awaited</st> <st c="6688">SQLAlchemy</st> `<st c="6791">/models/config.py</st>`
    <st c="6808">file that utilizes an</st> `<st c="6831">asyncpg</st>` <st c="6838">driver
    to build a session for non-blocking</st> <st c="6882">repository transactions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6906">Setting up the DB connectivity</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="6937">To start</st> <st c="6946">with the configuration, install the</st>
    `<st c="6983">asyncpg</st>` <st c="6990">DB driver or dialect that the</st> `<st
    c="7021">asyncio</st>`<st c="7028">-driven SQLAlchemy module requires using the</st>
    `<st c="7074">pip</st>` <st c="7077">command:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: <st c="7106">Also, include the greenlet library in the installation if it is
    not yet part of the</st> <st c="7191">virtual environment:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: <st c="7232">The setup also requires</st> <st c="7257">a</st> `<st c="7339">asyncpg</st>`
    <st c="7346">protocol, user credentials, the DB server host address, port, and
    the schema name.</st> <st c="7430">Our projects use the connection string,</st>
    `<st c="7470">postgresql+asyncpg://postgres:admin2255@localhost:5433/ovs</st>`<st
    c="7528">, to generate the</st> `<st c="7546">AsyncEngine</st>` <st c="7557">instance
    of the connection using</st> `<st c="7591">create_async_engine()</st>` <st c="7612">of
    the SQLAlchemy framework, the asynchronous version of its</st> `<st c="7674">create_engine()</st>`
    <st c="7689">utility.</st> <st c="7699">Aside from the DB URL, the method requires
    its</st> `<st c="7746">future</st>` <st c="7752">parameter to be set to</st> `<st
    c="7776">True</st>`<st c="7780">,</st> `<st c="7782">pool_pre_pring</st>` <st
    c="7796">to be set to</st> `<st c="7810">True</st>`<st c="7814">, and</st> `<st
    c="7820">poolclass</st>` <st c="7829">to be set to a connection pooling strategy
    such as</st> `<st c="7881">NullPool</st>`<st c="7889">.</st> `<st c="7891">poolclass</st>`
    <st c="7900">manages the threads the SQLAlchemy will utilize during its CRUD operations,
    and setting it to</st> `<st c="7995">NullPool</st>` <st c="8003">will restrict
    one Python thread to run only one event loop for one CRUD operation.</st> `<st
    c="8087">pool_pre_ping</st>`<st c="8100">, on the other hand, helps connection
    pooling for the pessimistic approach of handling disconnection.</st> <st c="8202">If
    it determines the DB connection as non-usable or invalid, that connection and
    its previous ones will be immediately recycled before executing a new operation.</st>
    <st c="8364">Most importantly, the</st> `<st c="8386">future</st>` <st c="8392">parameter
    must be set to</st> `<st c="8418">True</st>` <st c="8422">to enable asynchronous
    features of SQLAlchemy 2.x, or else the asynchronous SQLAlchemy setup will</st>
    <st c="8521">not work.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8530">After its successful creation, the</st> `<st c="8566">sessionmaker</st>`
    <st c="8578">callable will need the</st> `<st c="8602">AsyncEngine</st>` <st c="8613">instance
    to instantiate the session that every CRUD operation requires.</st> <st c="8686">However,
    this time, the session will be of the</st> `<st c="8733">AsyncSession</st>` <st
    c="8745">type, and the</st> `<st c="8760">async_scoped_session</st>` <st c="8780">callable
    will help derive the object with its provided</st> `<st c="8836">scopefunc</st>`
    <st c="8845">parameter to manage lightweight thread-local session-based operations
    in the repository layer.</st> <st c="8941">Every repository class will require
    this</st> `<st c="8982">AsyncSession</st>` <st c="8994">instance to implement
    every necessary DB transaction of the asynchronous</st> <st c="9068">Flask platform.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9083">Now, there is nothing new with the</st> `<st c="9119">declarative_base()</st>`
    <st c="9137">method, for it will still provide the needed helper classes to generate
    the model classes for the repository layer, like in the standard SQLAlchemy setup.</st>
    <st c="9293">The following is the complete module script of the</st> <st c="9344">specified</st>
    <st c="9354">SQLAlchemy setup:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: <st c="9955">The</st> `<st c="9960">echo</st>` <st c="9964">parameter of the
    given</st> `<st c="9988">create_async_engine</st>` <st c="10007">enables logging
    for the</st> `<st c="10032">AsyncEngine</st>`<st c="10043">-related transactions.</st>
    <st c="10067">Now, the</st> `<st c="10076">init_db()</st>` <st c="10085">method
    from the preceding configuration exposes the model classes to the different areas
    of the application.</st> <st c="10195">These model classes, built using the</st>
    `<st c="10232">Base</st>` <st c="10236">instance, help auto-generate the table
    schemas of our DB through the</st> *<st c="10306">Flask-Migrate</st>* <st c="10319">extension
    module, which still works with</st> `<st c="10361">flask[async]</st>` <st c="10373">and</st>
    `<st c="10378">flask-sqlalchemy</st>` <st c="10394">integration.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10407">Let us now use the derived</st> `<st c="10435">async_scoped_session()</st>`
    <st c="10457">to build</st> <st c="10467">repository classes.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10486">Building the asynchronous repository layer</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="10529">The</st> <st c="10533">asynchronous repository layer of the application
    requires the</st> `<st c="10596">AsyncSession</st>` <st c="10608">and the model
    classes to be created in the setup.</st> <st c="10659">The following is a</st>
    `<st c="10678">VoterRepository</st>` <st c="10693">class implementation that provides
    CRUD transactions for managing the</st> `<st c="10764">Voter</st>` <st c="10769">records:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="11864">async</st> def insert_voter(self, voter: Voter) -> bool:'
  prefs: []
  type: TYPE_NORMAL
- en: 'try: <st c="11922">sql = insert(Voter).values(mid=voter.mid,</st> <st c="11963">precinct=voter.precinct,</st>
    <st c="11988">voter_id=voter.voter_id,</st> <st c="12013">last_vote_date=datetime.strptime(</st><st
    c="12047">voter.last_vote_date, ''%Y-%m-%d'').date())</st><st c="12089">await</st>
    self.sess.execute(sql) <st c="12119">await</st> self.sess.commit() <st c="12144">await</st>
    self.sess.close()'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return True
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'except Exception as e:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: print(e)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return False
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="12567">async</st> def update_voter(self, id:int, details:Dict[str, Any])
    -> bool:'
  prefs: []
  type: TYPE_NORMAL
- en: 'try: <st c="12643">sql = update(Voter).where(Voter.id ==</st> <st c="12680">id).values(**details)</st><st
    c="12702">await</st> self.sess.execute(sql) <st c="12732">await</st> self.sess.commit()
    <st c="12757">await</st> self.sess.close()'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return True
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'except Exception as e:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print(e)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return False
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="13053">async</st> def delete_voter(self, id:int) -> bool:'
  prefs: []
  type: TYPE_NORMAL
- en: 'try: <st c="13105">sql = delete(Voter).where(Voter.id == id)</st><st c="13146">await</st>
    self.sess.execute(sql) <st c="13176">await</st> self.sess.commit() <st c="13201">await</st>
    self.sess.close()'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return True
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'except Exception as e:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: print(e)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return False
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="13393">async</st> def select_all_voter(self): <st c="13428">sql = select(Voter)</st>
    q = <st c="13452">await</st> self.sess.execute(sql)'
  prefs: []
  type: TYPE_NORMAL
- en: records = q.scalars().all() <st c="13509">await</st> self.sess.close()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return records
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="13918">async</st> def select_voter(self, id:int): <st c="13957">sql
    = select(Voter).where(Voter.id == id)</st> q = <st c="14003">await</st> self.sess.execute(sql)'
  prefs: []
  type: TYPE_NORMAL
- en: record = q.scalars().all() <st c="14059">await</st> self.sess.close()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return record
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="14613">async</st> def update_precinct(self, old_prec:str,   new_prec:str)
    -> bool:'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql = update(Voter).<st c="14708">where(Voter.precinct == old_prec).values(precint=new_prec)</st><st
    c="14767">sql.execution_options(synchronize_session=</st> <st c="14810">"fetch")</st>
    await self.sess.execute(sql)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: await self.sess.commit()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: await self.sess.close()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return True
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'except Exception as e:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print(e)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return False
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="15369">async</st> def delete_voter_by_precinct(self, precint:str) ->
    bool:'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: sql = delete(Voter).<st c="15458">where(Voter.precinct == precint)</st><st c="15491">sql.execution_options(synchronize_session=</st>
    <st c="15534">"fetch")</st> await self.sess.execute(sql)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: await self.sess.commit()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: await self.sess.close()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return True
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'except Exception as e:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: print(e)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return False
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: from app.model.db import Login
  prefs: []
  type: TYPE_NORMAL
- en: 'from app.repository.login import LoginRepository <st c="16865">from app.model.config
    import db_session</st> @current_app.post(''/ch05/login/add'') <st c="16942">async</st>
    def add_login(): <st c="16965">async with db_session() as sess:</st><st c="16997">async
    with sess.begin():</st><st c="17022">repo = LoginRepository(sess)</st> login_json
    = request.get_json()'
  prefs: []
  type: TYPE_NORMAL
- en: 'login = Login(**login_json) <st c="17112">result = await repo.insert_login(login)</st>
    if result:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: content = jsonify(login_json)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return make_response(content, 201)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: abort(500)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: from app.model.db import Member
  prefs: []
  type: TYPE_NORMAL
- en: from app.repository.member import MemberRepository
  prefs: []
  type: TYPE_NORMAL
- en: 'from app.model.config import db_session <st c="18512">from asyncio import create_task,
    ensure_future,</st> <st c="18559">InvalidStateError</st> from app.exceptions.db
    import DuplicateRecordException <st c="18633">@current_app.post("/ch05/member/add")</st>
    async def add_member():'
  prefs: []
  type: TYPE_NORMAL
- en: 'async with db_session() as sess:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'async with sess.begin():'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: repo = MemberRepository(sess)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: member_json = request.get_json()
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: member = Member(**member_json)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'try: <st c="18852">insert_task =</st> <st c="18865">create_task(repo.insert(member))</st><st
    c="18898">await insert_task</st><st c="18916">result = insert_task.result()</st>
    if result:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: content = jsonify(member_json)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return make_response(content, 201)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: raise DuplicateRecordException("insert member record failed")
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'except InvalidStateError:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: abort(500)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: <st c="20235">@current_app.get("/ch05/member/list/all")</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="20277">async</st> def list_all_member():'
  prefs: []
  type: TYPE_NORMAL
- en: 'async with db_session() as sess:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'async with sess.begin():'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: repo = MemberRepository(sess) <st c="20395">list_member_task =</st> <st c="20413">ensure_future(repo.select_all_member())</st><st
    c="20453">await list_member_task</st><st c="20476">records = list_member_task.result()</st>
    member_rec = [rec.to_json() for rec in records]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return make_response(member_rec, 201)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: <st c="21338">@current_app.post('/ch05/candidates/party')</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="21382">async</st> def add_list_candidates():'
  prefs: []
  type: TYPE_NORMAL
- en: candidates = request.get_json()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'count_rec_added = 0 <st c="21468">results = await gather( *[insert_candidate_task(data)</st>
    <st c="21521">for data in candidates])</st> for success in results:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if success:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: count_rec_added = count_rec_added  + 1
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return jsonify(message=f'there are {count_rec_added} newly added candidates'),
    201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="22085">from asyncio import create_task</st> … … … … … … <st c="22129">async</st>
    def insert_candidate_task(data): <st c="22168">async with db_session() as sess:</st><st
    c="22200">async with sess.begin():</st> repo = CandidateRepository(sess) <st c="22259">insert_task
    =</st> <st c="22272">create_task(repo.insert_candidate(</st><st c="22307">Candidate(**data)))</st><st
    c="22327">await insert_task</st><st c="22345">result = insert_task.result()</st>
    return result'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: <st c="24975">from flask.signals import Namespace</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="25011">election_ns = Namespace()</st> check_election = election_ns.<st
    c="25067">signal(''check_election'')</st> list_elections = election_ns.<st c="25281">check_election_event</st>,
    for instance, has the following asynchronous method that uses <st c="25365">ElectionRepository</st>
    to verify an election date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: <st c="25798">Meanwhile, our</st> `<st c="25814">list_all_election()</st>` <st
    c="25833">API endpoint has the following</st> `<st c="25865">list_elections_event()</st>`
    <st c="25887">that returns a list of records in</st> <st c="25922">JSON format:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: <st c="26198">Event or</st> <st c="26207">signal functions must accept a</st>
    *<st c="26239">sender</st>* <st c="26245">or</st> *<st c="26249">listener</st>*
    <st c="26257">as the first local parameter argument, followed by the other custom</st>
    `<st c="26326">args</st>` <st c="26330">objects essential to the event transaction.</st>
    <st c="26375">If the event mechanism is part of the class scope, the value of
    the function must be</st> `<st c="26460">self</st>` <st c="26464">or the class
    instance itself.</st> <st c="26495">Otherwise, if the signal is for a global event
    handling, its first argument must be the Flask</st> `<st c="26589">app</st>` <st
    c="26592">instance.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="26602">A signal has a</st> `<st c="26618">connect()</st>` <st c="26627">function
    or decorator that registers an event or function as its implementation.</st> <st
    c="26709">These events will execute once a caller emits the signals.</st> <st
    c="26768">Flask components can emit signals by invoking the signal’s</st> `<st
    c="26827">send()</st>` <st c="26833">or</st> `<st c="26837">send_async()</st>`
    <st c="26849">utility with the event function arguments.</st> <st c="26893">The
    following</st> `<st c="26907">verify_election()</st>` <st c="26924">endpoint checks
    from the DB through the</st> `<st c="26965">check_election</st>` <st c="26979">signal
    if an election happens on a</st> <st c="27015">particular date:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: <st c="27473">If the event function is a standard Python function, send the
    notification for its execution through the signal’s</st> `<st c="27588">send()</st>`
    <st c="27594">method.</st> <st c="27603">However, if it is an asynchronous method,
    like in our case, use</st> `<st c="27667">send_async()</st>` <st c="27679">to
    create and run the task for the coroutine with</st> `<st c="27730">await</st>`
    <st c="27735">to extract its</st> `<st c="27751">Future</st>` <st c="27757">value.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="27764">Generally, signals can employ the de-coupling of components in
    a scalable application to reduce dependencies and improve modularity and maintainability.</st>
    <st c="27918">This can also help build applications to have a distributed architecture
    design.</st> <st c="27999">However, as the requirements become complicated and
    the subscribers of the signals become numerous, the notifications can slow down
    the performance of the whole application.</st> <st c="28173">So, it is a good
    design if the caller and the event function can lessen the dependencies on each
    other’s parameters, returned values, and conditions.</st> <st c="28323">The subscribers
    must have an independent scope as to the event functions.</st> <st c="28397">Also,
    it is a good programming approach to create an event function that is flexible
    and not too narrow in its objectives so that many</st> <st c="28532">components
    can subscribe</st> <st c="28557">to it.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="28563">After exploring how Flask supports event handling using its signals,
    let us now learn how to create background processes using</st> <st c="28691">its
    platform.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="28704">Constructing background tasks with Celery and Redis</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="28756">It is</st> <st c="28763">impossible to create background processes</st>
    <st c="28804">or</st> <st c="28807">transactions in</st> <st c="28823">Flask using
    its</st> `<st c="28840">flask[async]</st>` <st c="28852">platform.</st> <st c="28863">The
    event loop that runs tasks for the asynchronous view or endpoint will not allow
    the spawning of another event loop that will cater to background tasks because
    it cannot wait for the background processes to finish once the view or endpoint
    finishes its processing.</st> <st c="29131">However, with some third-party components,
    such as task queues, background processing is feasible for the</st> <st c="29237">Flask
    platform.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="29252">One of the solutions is to use Celery, which is an asynchronous
    task queue that can run processes outside the context of the application.</st>
    <st c="29391">So, while the event loop is running the view or endpoint coroutines,
    they can entrust to Celery the management of the</st> <st c="29509">background
    transactions.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="29533">Setting up the Celery task queue</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="29566">There are a few</st> <st c="29583">considerations when writing
    the background processes with Celery, and the first is to install the</st> `<st
    c="29681">celery</st>` <st c="29687">extension module using the</st> `<st c="29715">pip</st>`
    <st c="29718">command:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: <st c="29746">Then, we designate some local workers in the WSGI server to run
    tasks with the background jobs in the Celery queue, but in our application, our
    Flask server will only use a single worker to run all</st> <st c="29945">the processes.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="29959">Let us now install the Redis server, which will serve as the message
    broker to</st> <st c="30039">the Celery.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="30050">Installing the Redis DB</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="30074">After designating</st> <st c="30092">the worker, Celery requires
    a message broker for its workers to communicate with the client application about
    running the background jobs.</st> <st c="30232">Our applications use the Redis
    DB as the broker.</st> <st c="30281">So, install Redis in Windows using</st> <st
    c="30315">the</st> **<st c="30320">Windows Subsystem for Linux</st>** <st c="30347">(</st>**<st
    c="30349">WSL2</st>**<st c="30353">) shell or by downloading the Windows installer</st>
    <st c="30402">at</st> [<st c="30405">https://github.com/microsoftarchive/redis/releases</st>](https://github.com/microsoftarchive/redis/releases)<st
    c="30455">.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="30456">The next step is to add the necessary Celery configuration variables,
    including</st> `<st c="30537">CELERY_BROKER_URL</st>`<st c="30554">, to the</st>
    `<st c="30563">app</st>` <st c="30566">instance.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="30576">Setting up the Celery client configuration</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="30619">Since our projects use</st> <st c="30642">TOML files for setting
    the configuration environment variables, Celery will fetch all its configuration
    details from these files as TOML variables.</st> <st c="30791">The following is
    a snapshot of the</st> `<st c="30826">config_dev.toml</st>` <st c="30841">file
    that contains Celery</st> <st c="30868">setup variables:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: <st c="31465">The two most</st> <st c="31478">important variables needed by
    the Celery client module are</st> `<st c="31538">CELERY_BROKER_URL</st>` <st c="31555">and</st>
    `<st c="31560">CELERY_RESULT_BACKEND</st>`<st c="31581">, which provide the address,
    port, and DB name of the Redis broker and backend server, respectively.</st> <st
    c="31682">Redis has DBs</st> `<st c="31696">0</st>` <st c="31697">to</st> `<st
    c="31701">15</st>`<st c="31703">, but our application utilizes only DB</st> `<st
    c="31742">0</st>` <st c="31743">for default purposes.</st> <st c="31766">Since
    the</st> `<st c="31776">CELERY_RESULT_BACKEND</st>` <st c="31797">is not that
    important in this setup, setting</st> `<st c="31843">CELERY_RESULT_BACKEND</st>`
    <st c="31864">as the defined broker URL or removing it from the configuration</st>
    <st c="31929">is acceptable.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="31943">Then, create the</st> `<st c="31961">CELERY</st>` <st c="31967">TOML
    dictionary to contain the details needed by the Celery instance in managing the
    background task executions.</st> <st c="32081">First,</st> `<st c="32088">celery_store_errors_even_if_ignored</st>`
    <st c="32123">and</st> `<st c="32128">task_store_errors_even_if_ignored</st>`
    <st c="32161">must be</st> `<st c="32170">True</st>` <st c="32174">to enable audit
    trail features for logging errors during Celery execution.</st> `<st c="32250">broker_connection_retry_on_startup</st>`
    <st c="32284">should be</st> `<st c="32295">True</st>` <st c="32299">in case Redis
    is still in shutdown mode.</st> <st c="32341">On the other hand,</st> `<st c="32360">task_ignore_result</st>`
    <st c="32378">must be</st> `<st c="32387">False</st>` <st c="32392">since some
    of our coroutine jobs will be returning some values to the caller.</st> <st c="32471">Moreover,</st>
    `<st c="32481">task_create_missing_queues</st>` <st c="32507">is set to</st> `<st
    c="32518">True</st>` <st c="32522">in case there are undefined task queues that
    the application can utilize during traffic.</st> <st c="32612">By the way, the
    default task queue’s name</st> <st c="32654">is</st> `<st c="32657">celery</st>`<st
    c="32663">.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="32664">Other details are about the mime-type of resources that tasks
    can accept for their coroutines (</st>`<st c="32760">celery_accept_content</st>`<st
    c="32782">) and the returned values that these background processes can return
    to the invoker (</st>`<st c="32868">celery_result_accept_content</st>`<st c="32897">).</st>
    <st c="32901">The task serializers are also part of the details because they are
    the mechanisms that convert the task’s incoming arguments and returning</st> <st
    c="33039">values to be in their acceptable state and valid</st> <st c="33089">mime-type
    types.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="33105">Now, let us focus on building the Celery client modules of our
    projects, starting with the instantiation of the</st> <st c="33218">Celery instance.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="33234">Creating the Client instance</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="33263">Since all</st> <st c="33274">projects in this chapter use the
    application factory approach, the setup recognizing the application as a Celery
    client happens in</st> `<st c="33405">app/__init__.py</st>`<st c="33420">. However,
    the exact</st> `<st c="33441">Celery</st>` <st c="33447">class instantiation occurs
    in another module,</st> `<st c="33494">celery_config.py</st>`<st c="33510">, to
    avoid circular import errors.</st> <st c="33545">The following snippet shows the
    instantiation of the</st> `<st c="33598">Celery</st>` <st c="33604">class</st>
    <st c="33611">in</st> `<st c="33614">celery_config.py</st>`<st c="33630">:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: <st c="34104">From the preceding snippet, the instantiation of the</st> `<st
    c="34158">Celery</st>` <st c="34164">class strictly requires the Celery application
    name,</st> `<st c="34218">CELERY_BROKER_URL</st>`<st c="34235">, and the worker
    task.</st> <st c="34258">The first parameter, the Celery application name, can
    have any prescribed name or just the Flask app’s name since the Celery client
    module will run background jobs (</st>`<st c="34423">FlaskTask</st>`<st c="34433">)
    in the</st> <st c="34443">app’s thread.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="34456">After</st> <st c="34462">instantiating the Celery, the Celery
    instance,</st> `<st c="34510">celery_app</st>`<st c="34520">, needs to load the</st>
    `<st c="34540">CELERY</st>` <st c="34546">TOML dictionary from the Flask</st>
    `<st c="34578">app</st>` <st c="34581">to configure the task queue and its message
    broker.</st> <st c="34634">Lastly,</st> `<st c="34642">celery_app</st>` <st c="34652">must
    invoke</st> `<st c="34665">set_default()</st>` <st c="34678">to seal the configuration.</st>
    <st c="34706">Now,</st> `<st c="34711">app/__init__.py</st>` <st c="34726">will
    import the</st> `<st c="34743">celery_init_app()</st>` <st c="34760">factory to
    eventually pursue the creation of the Celery client out of the</st> <st c="34835">Flask
    application.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="34853">Let us now build the Celery client module with</st> <st c="34901">custom
    tasks.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="34914">Implementing the Celery tasks</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="34944">To avoid circular</st> <st c="34963">import problems, it is not
    advisable to import</st> `<st c="35010">celery_app</st>` <st c="35020">and use
    it to decorate functions with the</st> `<st c="35063">task()</st>` <st c="35069">decorator.</st>
    <st c="35081">The</st> `<st c="35085">shared_task()</st>` <st c="35098">decorator
    from the</st> `<st c="35118">celery</st>` <st c="35124">module is enough proxy
    to define functions as Celery tasks.</st> <st c="35185">Here is a Celery task
    that adds a new vote to</st> <st c="35231">a candidate:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="37658">@shared_task</st> def list_all_votes_task_wrapper():'
  prefs: []
  type: TYPE_NORMAL
- en: 'async def list_all_votes_task():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'async with db_session() as sess:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'async with sess.begin():'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: repo = VoteRepository(sess)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: records = await repo.select_all_vote()
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: vote_rec = [rec.to_json() for rec in records]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return <st c="37917">dumps(vote_rec,</st> <st c="37932">default=json_date_serializer)</st>
    return <st c="37970">run(list_all_votes_task())</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '<st c="37996">def json_date_serializer(obj):</st> if isinstance(obj, time):'
  prefs: []
  type: TYPE_NORMAL
- en: return obj.isoformat()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: raise TypeError ("Type %s not …" % type(obj))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: celery -A main.celery_app worker --loglevel=info -P solo
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: pip install eventlet
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: <st c="41469">@current_app.post('/ch05/vote/add')</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="41505">async</st> def add_vote():'
  prefs: []
  type: TYPE_NORMAL
- en: vote_json = request.get_json() <st c="41559">vote_str = dumps(vote_json)</st><st
    c="41586">task =</st> <st c="41593">add_vote_task_wrapper.apply_async(args=[vote_str])</st><st
    c="41644">result = task.get()</st> return jsonify(message=result), 201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: <script> <st c="43660">const add_log = (message) => {</st> document.getElementById('add_log').innerHTML
    += `<span>${message}</span><br>`;
  prefs: []
  type: TYPE_NORMAL
- en: '}; <st c="43773">const socket = new WebSocket(''ws://'' + location.host</st>
    <st c="43825">+ ''/ch05/vote/save/ws'');</st><st c="43850">socket.addEventListener(''message'',
    msg => {</st><st c="43894">add_log(''server: '' + msg.data);</st><st c="43926">});</st>
    document.getElementById(''vote_form'').onsubmit = data => {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: data.preventDefault();
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: const election_id = document.getElementById('election_id');
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: const precinct = document.getElementById('precinct');
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: const final_tally = document.getElementById('final_tally');
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: const approved_date = document.getElementById('approved_date');
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: var vote_count = new Object();
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: vote_count.election_id = election_id.value;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: vote_count.precinct  = precinct.value;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: vote_count.final_tally = final_tally.value;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: vote_count.approved_date = approved_date.value;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: var vote_count_json = JSON.stringify(vote_count);
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'add_log(''client: '' + vote_count_json); <st c="44544">socket.send(vote_count_json);</st>
    election_id.value = '''';'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: precinct.value = '';
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: final_tally.value = '';
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: approved_date.value = '';
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </script>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: pip install flask-sock
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: <st c="46173">from flask_sock import Sock</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="46201">sock = Sock()</st> def create_app(config_file):'
  prefs: []
  type: TYPE_NORMAL
- en: app = Flask(__name__, template_folder='../app/pages', static_folder="../app/resources")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app.config.from_file(config_file, toml.load)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'init_db() <st c="46451">sock</st> instance in <st c="46468">/api/ votecount_websocket.py
    module</st> to define the WebSocket routes. <st c="46536">ws://localhost:5001/ch05/vote/save/ws</st>,
    which was invoked by the preceding JS code, has the following route implementation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: <st c="47092">The</st> `<st c="47097">Sock</st>` <st c="47101">instance has
    a</st> `<st c="47117">route()</st>` <st c="47124">decorator that defines WebSocket
    implementation.</st> <st c="47174">WebSocket route function or handler is always
    non-asynchronous with a required parameter that accepts an injected WebSocket
    object from</st> `<st c="47310">Sock</st>`<st c="47314">. This</st> `<st c="47321">ws</st>`
    <st c="47323">object has a</st> `<st c="47337">send()</st>` <st c="47343">method
    that emits data to the client application, a</st> `<st c="47396">receive()</st>`
    <st c="47405">utility that accepts messages from the client, and</st> `<st c="47457">close()</st>`
    <st c="47464">to employ forced disconnection of the two-way communication when
    runtime exceptions or server-related</st> <st c="47567">problems occur.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="47582">The</st> <st c="47587">WebSocket handler usually holds an</st>
    *<st c="47622">open loop process</st>* <st c="47639">where it can receive a message
    first through</st> `<st c="47685">receive()</st>` <st c="47694">and then emit
    its message using</st> `<st c="47727">send()</st>` <st c="47733">continuously,
    depending on the purpose of</st> <st c="47776">the messaging.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="47790">In the case of</st> `<st c="47806">add_vote_count_server()</st>`<st
    c="47829">, which needs to await asynchronous</st> `<st c="47865">VoteCountRepository</st>`<st
    c="47884">’s INSERT transaction, an</st> `<st c="47911">async</st>` <st c="47916">local
    method similar to the Celery task must be present inside the WebSocket route function.</st>
    <st c="48010">This local method will encase the asynchronous operations, and the</st>
    `<st c="48077">asyncio</st>`<st c="48084">’s</st> `<st c="48088">run()</st>` <st
    c="48093">will execute it inside the</st> <st c="48121">route function.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="48136">Now, to witness the exchange of messages,</st> *<st c="48179">Figure
    5</st>**<st c="48187">.3</st>* <st c="48189">shows a snapshot of the communication
    between our JS client and the</st> `<st c="48258">add_vote_count_server()</st>`
    <st c="48281">handler</st> <st c="48290">at runtime:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.3 – A message exchange between a JS client and flask-sock WebSocket](img/B19383_05_003.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: <st c="48668">Figure 5.3 – A message exchange between a JS client and flask-sock
    WebSocket</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="48744">Aside from web-based clients, WebSocket can also propagate or
    send data to</st> <st c="48820">API clients.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="48832">Creating a Flask API client application</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="48872">Another way to</st> <st c="48888">connect through WebSocket emitters
    is through Flask components, not JS codes.</st> <st c="48966">Sometimes, the client
    applications are not web components composed of HTML, CSS, and frontend JS frameworks
    that support WebSocket communication.</st> <st c="49112">For instance, in our</st>
    `<st c="49133">ch05-api</st>` <st c="49141">project, a POST API function,</st>
    `<st c="49172">bulk_check_vote_count()</st>`<st c="49195">, asks for a list of
    candidates to count the votes they have during the election.</st> <st c="49277">The
    input to the API is a JSON string, such as the following</st> <st c="49338">sample
    data:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: <st c="49485">Then, the API function converts this JSON input to a list of dictionaries
    containing the candidate and election IDs.</st> <st c="49603">Here is the implementation
    of this API function that serves as a client to</st> <st c="49678">a WebSocket:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: <st c="50217">Since the most compatible WebSocket client extension for</st>
    `<st c="50275">flask-sock</st>` <st c="50285">is</st> `<st c="50289">simple-websocket</st>`<st
    c="50305">, install this module using the</st> `<st c="50337">pip</st>` <st c="50340">command:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: <st c="50378">Instantiate the</st> `<st c="50395">Client</st>` <st c="50401">class</st>
    <st c="50407">from the</st> `<st c="50417">simple-websocket</st>` <st c="50433">module
    to connect to the</st> `<st c="50459">flask-sock</st>` <st c="50469">WebSocket
    emitter with</st> `<st c="50493">Access-Control-Allow-Origin</st>` <st c="50520">to
    allow cross-origin access.</st> <st c="50551">Then, the API will send the dictionary-converted-to-string
    details to the emitter using the</st> `<st c="50643">Client</st>`<st c="50649">’s</st>
    `<st c="50653">send()</st>` <st c="50659">method.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="50667">On the other hand, the WebSocket route that will receive the election
    details from the</st> `<st c="50755">bulk_check_vote_count()</st>` <st c="50778">client
    API has the</st> <st c="50798">following implementation:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: pip install redis
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: from app import create_app <st c="53471">from redis import Redis</st> app =
    create_app('../config_dev.toml') <st c="53534">redis_conn = Redis(</st><st c="53553">db
    = 0,</st><st c="53561">host='127.0.0.1',</st><st c="53579">port=6379,</st><st
    c="53590">decode_responses=True</st> )
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: <st c="54293">from main import redis_conn</st> from  json import dumps <st c="54345">@current_app.route('/ch05/election/complaint/form',
    methods = ['GET','POST'])</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="54422">async</st> def create_complaint():'
  prefs: []
  type: TYPE_NORMAL
- en: 'if request.method == "GET":'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return render_template('complaint_form.html')
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: voter_id = request.form['voter_id']
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: complaint = request.form['complaint']
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'record = {''voter_id'': voter_id, ''complaint'': complaint} <st c="54663">redis_conn.publish("complaint_channel",</st>
    <st c="54702">dumps(record))</st> return render_template(''complaint_form.html'')'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: <st c="55344">@current_app.route('/ch05/elec/comaplaint/stream')</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="55395">async</st> def elec_complaint_sse():'
  prefs: []
  type: TYPE_NORMAL
- en: 'def process_complaint_event(): <st c="55459">connection = redis_conn.pubsub()</st><st
    c="55491">connection.subscribe(''complaint_channel'')</st> for message in <st
    c="55549">connection.listen()</st>:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: time.sleep(1)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if message is not None and message[''type''] == ''message'': <st c="55642">data
    = message[''data'']</st><st c="55664">yield ''data: %s\n\n'' % data</st> return
    <st c="55765">process_complaint_event()</st> in the given SSE route is the *<st
    c="55822">generator function</st>* that creates the subscriber object (<st c="55877">connection</st>),
    connects to Redis by invoking the <st c="55926">subscribe()</st> method, and builds
    an open loop transaction that will listen continuously from the broker for currently
    published messages. The message it retrieves from the <st c="56096">listen()</st>
    utility of the subscriber object is a JSON entity containing details about the
    message type, channel, and the <st c="56215">data</st> published by the form view
    publisher. <st c="56258">elec_complaint_sse()</st> only needs to yield the <st
    c="56303">data</st> portion of the message. Now, running the <st c="56349">process_complaint_event()</st>
    generator requires the SSE route to return Flask’s <st c="56426">Response</st>,
    which will execute and render it as a <st c="56474">text/event-stream</st> type
    object. *<st c="56505">Figure 5</st>**<st c="56513">.4</st>* shows the form view
    catering to the voters for their complaints:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.4 – A complaint form view of the published data to Redis](img/B19383_05_004.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: <st c="56748">Figure 5.4 – A complaint form view of the published data to Redis</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '*<st c="56813">Figure 5</st>**<st c="56822">.5</st>* <st c="56824">provides
    a snapshot of the SSE client page with the pushed messages from the</st> <st c="56902">Redis
    broker.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.5 – An SSE client page rendering pushed data from Redis](img/B19383_05_005.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: <st c="57234">Figure 5.5 – An SSE client page rendering pushed data from Redis</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="57298">Aside from broker messaging, Flask supports other libraries that
    use publisher-subscriber design patterns in creating its components.</st> <st
    c="57433">The next subject will showcase one of them, the</st> `<st c="57481">reactivex</st>`
    <st c="57490">module.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="57498">Applying reactive programming with RxPy</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="57538">Reactive programming</st>** <st c="57559">is</st> <st c="57563">one
    of the emerging popular programming paradigms nowadays that focuses on asynchronous
    data streams and operations that can manage executions, events, repositories,
    and exception propagations.</st> <st c="57757">It utilizes the publisher-subscriber
    programming approach, which builds asynchronous interactions between software
    components</st> <st c="57883">and transactions.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="57900">The</st> <st c="57904">library used to apply reactive streams
    to build services transactions and API functions in this chapter is</st> `<st
    c="58012">reactivex</st>`<st c="58021">, so install the module using the</st>
    `<st c="58055">pip</st>` <st c="58058">command:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: <st c="58089">The</st> `<st c="58094">reactivex</st>` <st c="58103">module has
    an</st> `<st c="58118">Observable</st>` <st c="58128">class that generates data
    sources for the subscribers to consume.</st> `<st c="58195">Observer</st>` <st
    c="58203">is another API class that pertains to the subscriber entities.</st>
    `<st c="58267">reactivex</st>` <st c="58276">will not be a complete reactive programming
    library without its</st> *<st c="58341">operators</st>*<st c="58350">. The following
    is a vote-counting service implementation that uses the</st> `<st c="58422">reactivex</st>`
    <st c="58431">utilities:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: from app.services.vote_count import create_observable
  prefs: []
  type: TYPE_NORMAL
- en: 'from asyncio import get_event_loop, Future <st c="61067">@current_app.get("/ch05/votecount/tally")</st>
    async def list_votecount_tally():'
  prefs: []
  type: TYPE_NORMAL
- en: 'finished = Future() <st c="61163">loop = get_event_loop()</st> def on_completed():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: finished.set_result(0)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'tally = [] <st c="61241">disposable</st> = <st c="61254">create_observable(loop).subscribe(</st><st
    c="61288">on_next = lambda i: tally.append(i),</st><st c="61325">on_error = lambda
    e: print("Error</st> <st c="61359">Occurred: {0}".format(e)),</st><st c="61386">on_completed
    = on_completed)</st><st c="61415">await finished</st><st c="61430">disposable.dispose()</st>
    return jsonify(tally=tally), 201'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: <st c="63374">from quart import Quart</st> import toml
  prefs: []
  type: TYPE_NORMAL
- en: from app.model.config import init_db
  prefs: []
  type: TYPE_NORMAL
- en: from app.api.home import home, welcome
  prefs: []
  type: TYPE_NORMAL
- en: from app.api.login import add_login, list_all_login
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_app(config_file): <st c="63568">app = Quart(__name__, template_folder=''../app/pages'',</st>
    <st c="63621">static_folder="../app/resources")</st><st c="63655">app.config.from_file(config_file,
    toml.load)</st> init_db()'
  prefs: []
  type: TYPE_NORMAL
- en: app.<st c="63715">add_url_rule</st>('/ch05/home', view_func=home, endpoint='home')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app.<st c="63781">add_url_rule</st>('/ch05/welcome', view_func=welcome, endpoint='welcome')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app.<st c="63856">add_url_rule</st>('/ch05/login/add', view_func=add_login,
    endpoint='add_login')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app.<st c="63937">add_url_rule</st>('/ch05/login/list/all', view_func=list_all_login,
    endpoint='list_all_login')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return app
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: <st c="65402">from quart import jsonify, render_template, request,</st> <st
    c="65455">make_response</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="65469">async def add_login():</st> async with db_session() as sess:'
  prefs: []
  type: TYPE_NORMAL
- en: repo = LoginRepository(sess)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: login_json = request.get_json()
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: login = Login(**login_json)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: result = await repo.insert(login)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if result: <st c="65660">content = jsonify(login_json)</st><st c="65689">return
    await make_response(content, 201)</st> else:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: content = jsonify(message="insert complaint details record encountered a problem")
    <st c="65820">return await make_response(content, 500)</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '<st c="65860">async</st> def welcome(): <st c="65949">render_template()</st>
    and <st c="65971">make_response()</st> here in Quart need the <st c="66010">await</st>
    keyword. Another difference is Quart’s use of <st c="66062">hypercorn</st> to
    run its applications instead of the Werkzeug server. So, install <st c="66140">hypercorn</st>
    using the <st c="66160">pip</st> command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: <st c="66194">Then, run the application with the</st> `<st c="66230">hypercorn</st>`
    `<st c="66240">main:app</st>` <st c="66248">command.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="66257">So far, in</st> <st c="66269">general, Quart has been a promising
    asynchronous framework.</st> <st c="66329">Let’s hope that collaborations with
    the creator, support groups, and enthusiasts can help upgrade and expand this
    framework in the</st> <st c="66460">near future.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="66472">Summary</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="66480">Flask 2.2 is now at par with the other frameworks that support
    and utilize asynchronous solutions to improve the application’s runtime performance.</st>
    <st c="66629">Its view and API functions can now be</st> `<st c="66667">async</st>`
    <st c="66672">and runnable on an event loop created by Flask.</st> <st c="66721">Asynchronous
    services and transactions can now be executed and awaited on the Flask platform
    as tasks created by</st> `<st c="66834">create_task()</st>` <st c="66847">and</st>
    `<st c="66852">ensure_future()</st>`<st c="66867">.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="66868">The latest</st> *<st c="66880">SQLAlchemy[async]</st>* <st c="66897">can
    easily integrate with the Flask application to provide asynchronous CRUD transactions.</st>
    <st c="66989">Also, creating asynchronous tasks to break down the sequence of
    blocking transactions in Celery background processes, WebSocket messaging, and
    Observable operations are now possible with</st> <st c="67176">Flask 2.2.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="67186">Moreover, designing loosely coupled components, application-scoped
    cross-cut concern solutions, and some distributed setups is now feasible with
    Flask 2.2 through the built-in</st> <st c="67363">asynchronous signals.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="67384">There is even a 100% asynchronous Flask framework called Quart
    that can build fast-performing</st> <st c="67479">request-response transactions.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="67509">Although the purpose of asynchronous support in Flask is for performance,
    there is still a boundary on when it can be part of our applications.</st> <st
    c="67654">Some components or utilities will degrade in their running time when
    used with</st> `<st c="67733">asyncio</st>`<st c="67740">. Others, such as CRUD
    operations, will slow down DB access due to DB specifications that do not comply
    with the asynchronous setup.</st> <st c="67873">So, the effect of asynchronous
    programming still depends on the requirements of the projects and the resources
    the</st> <st c="67988">application uses.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="68005">The next chapter will bring us to the computational world of Flask,
    which deals with</st> `<st c="68091">numpy</st>`<st c="68096">,</st> `<st c="68098">pandas</st>`<st
    c="68104">, graphs, charts, statistics, file serializations, and other scientific
    solutions that Flask</st> <st c="68197">can provide.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
