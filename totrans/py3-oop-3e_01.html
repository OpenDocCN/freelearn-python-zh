<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Object-Oriented Design</h1>
                </header>
            
            <article>
                
<p>In software development, design is often considered as the step done <em>before</em> programming. This isn't true; in reality, analysis, programming, and design tend to overlap, combine, and interweave. In this chapter, we will cover the following topics:</p>
<ul>
<li>What object-oriented means</li>
<li>The difference between object-oriented design and object-oriented programming</li>
<li>The basic principles of object-oriented design</li>
<li>Basic <strong>Unified Modeling Language</strong> (<strong>UML</strong>) and when it isn't evil</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing object-oriented</h1>
                </header>
            
            <article>
                
<p>Everyone knows what an object is: a tangible thing that we can sense, feel, and manipulate. The earliest objects we interact with are typically baby toys. Wooden blocks, plastic shapes, and over-sized puzzle pieces are common first objects. Babies learn quickly that certain objects do certain things: bells ring, buttons are pressed, and levers are pulled.</p>
<p>The definition of an object in software development is not terribly different. Software objects may not be tangible things that you can pick up, sense, or feel, but they are models of something that can do certain things and have certain things done to them. Formally, an object is a collection of <strong>data</strong> and associated <strong>behaviors</strong>.</p>
<p>So, knowing what an object is, what does it mean to be object-oriented? In the dictionary, <em>oriented</em> means <em>directed toward</em>. So object-oriented means functionally directed toward modeling objects. This is one of many techniques used for modeling complex systems. It is defined by describing a collection of interacting objects via their data and behavior.</p>
<p>If you've read any hype, you've probably come across the terms <em>object-oriented analysis</em>, <em>object-oriented design</em>, <em>object-oriented analysis and design</em>, and <em>object-oriented programming</em>. These are all highly related concepts under the general <em>object-oriented</em> umbrella.</p>
<p>In fact, analysis, design, and programming are all stages of software development. Calling them object-oriented simply specifies what level of software development is being pursued.</p>
<p><strong>Object-oriented analysis</strong> (<strong>OOA</strong>) is the process of looking at a problem, system, or task (that somebody wants to turn into an application) and identifying the objects and interactions between those objects. The analysis stage is all about <em>what</em> needs to be done.</p>
<p>The output of the analysis stage is a set of requirements. If we were to complete the analysis stage in one step, we would have turned a task, such as <em>I need a website</em>, into a set of requirements.  As an example, here or some requirements as to what a website visitor might need to do (<em>italic</em> represents actions, <strong>bold</strong> represents objects):</p>
<ul>
<li><em>Review</em> our <strong>history</strong></li>
<li><em>Apply</em> for <strong>jobs</strong></li>
<li><em>Browse</em>, <em>compare</em>, and <em>order</em> <strong>products</strong></li>
</ul>
<p>In some ways, <em>analysis</em> is a misnomer. The baby we discussed earlier doesn't analyze the blocks and puzzle pieces. Instead, she explores her environment, manipulates shapes, and sees where they might fit. A better turn of phrase might be <em>object-oriented exploration</em>. In software development, the initial stages of analysis include interviewing customers, studying their processes, and eliminating possibilities.</p>
<p><strong>Object-oriented design</strong> (<strong>OOD</strong>) is the process of converting such requirements into an implementation specification. The designer must name the objects, define the behaviors, and formally specify which objects can activate specific behaviors on other objects. The design stage is all about <em>how</em> things should be done.</p>
<p>The output of the design stage is an implementation specification. If we were to complete the design stage in a single step, we would have turned the requirements defined during object-oriented analysis into a set of classes and interfaces that could be implemented in (ideally) any object-oriented programming language.</p>
<p><strong>Object-oriented programming</strong> (<strong>OOP</strong>) is the process of converting this perfectly-defined design into a working program that does exactly what the CEO originally requested.</p>
<p>Yeah, right! It would be lovely if the world met this ideal and we could follow these stages one by one, in perfect order, like all the old textbooks told us to. As usual, the real world is much murkier. No matter how hard we try to separate these stages, we'll always find things that need further analysis while we're designing. When we're programming, we find features that need clarification in the design.</p>
<p>Most twenty-first century development happens in an iterative development model. In iterative development, a small part of the task is modeled, designed, and programmed, and then the program is reviewed and expanded to improve each feature and include new features in a series of short development cycles.</p>
<p>The rest of this book is about object-oriented programming, but in this chapter, we will cover the basic object-oriented principles in the context of design. This allows us to understand these (rather simple) concepts without having to argue with software syntax or Python tracebacks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Objects and classes</h1>
                </header>
            
            <article>
                
<p>So, an object is a collection of data with associated behaviors. How do we differentiate between types of objects? Apples and oranges are both objects, but it is a common adage that they cannot be compared. Apples and oranges aren't modeled very often in computer programming, but let's pretend we're doing an inventory application for a fruit farm. To facilitate the example, we can assume that apples go in barrels and oranges go in baskets.</p>
<p>Now, we have four kinds of objects: apples, oranges, baskets, and barrels. In object-oriented modeling, the term used for a <em>kind of object</em> is <strong>class</strong>. So, in technical terms, we now have four classes of objects.</p>
<p>It's important to understand the difference between an object and a class. Classes describe objects. They are like blueprints for creating an object. You might have three oranges sitting on the table in front of you. Each orange is a distinct object, but all three have the attributes and behaviors associated with one class: the general class of oranges.</p>
<p>The relationship between the four classes of objects in our inventory system can be described using a <strong>Unified Modeling Language</strong> (invariably referred to as <strong>UML</strong>, because three-letter acronyms never go out of style) class diagram. Here is our first class diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/da5a618a-1873-45d4-9cc1-9f6a3be48278.png" style="width:11.92em;height:7.17em;"/></div>
<p>This diagram shows that an <strong>Orange</strong> is somehow associated with a <strong>Basket</strong> and that an <strong>Apple</strong> is also somehow associated with a <strong>Barrel</strong>. <em>Association</em> is the most basic way for two classes to be related.</p>
<p>UML is very popular among managers, and occasionally disparaged by programmers. The syntax of a UML diagram is generally pretty obvious; you don't have to read a tutorial to (mostly) understand what is going on when you see one. UML is also fairly easy to draw, and quite intuitive. After all, many people, when describing classes and their relationships, will naturally draw boxes with lines between them. Having a standard based on these intuitive diagrams makes it easy for programmers to communicate with designers, managers, and each other.</p>
<p>However, some programmers think UML is a waste of time. Citing iterative development, they will argue that formal specifications done up in fancy UML diagrams are going to be redundant before they're implemented, and that maintaining these formal diagrams will only waste time and not benefit anyone.</p>
<p>Depending on the corporate structure involved, this may or may not be true. However, every programming team consisting of more than one person will occasionally have to sit down and hash out the details of the subsystem it is currently working on. UML is extremely useful in these brainstorming sessions for quick and easy communication. Even those organizations that scoff at formal class diagrams tend to use some informal version of UML in their design meetings or team discussions.</p>
<p>Furthermore, the most important person you will ever have to communicate with is yourself. We all think we can remember the design decisions we've made, but there will always be the <em>Why did I do that?</em> moments hiding in our future. If we keep the scraps of papers we did our initial diagramming on when we started a design, we'll eventually find them a useful reference.</p>
<p>This chapter, however, is not meant to be a tutorial on UML. There are many of those available on the internet, as well as numerous books on the topic. UML covers far more than class and object diagrams; it also has a syntax for use cases, deployment, state changes, and activities. We'll be dealing with some common class diagram syntax in this discussion of object-oriented design. You can pick up the structure by example, and you'll subconsciously choose the UML-inspired syntax in your own team or personal design sessions.</p>
<p>Our initial diagram, while correct, does not remind us that apples go in barrels or how many barrels a single apple can go in. It only tells us that apples are somehow associated with barrels. The association between classes is often obvious and needs no further explanation, but we have the option to add further clarification as needed.</p>
<p>The beauty of UML is that most things are optional. We only need to specify as much information in a diagram as makes sense for the current situation. In a quick whiteboard session, we might just quickly draw lines between boxes. In a formal document, we might go into more detail. In the case of apples and barrels, we can be fairly confident that the association is <strong>many apples go in one barrel</strong>, but just to make sure nobody confuses it with <strong>one apple spoils one barrel</strong>, we can enhance the diagram as shown:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/2dd6f137-fafa-4b84-9619-afc7c64c3102.png" style="width:13.83em;height:10.67em;"/></div>
<p>This diagram tells us that oranges <strong>go in</strong> baskets, with a little arrow showing what goes in what. It also tells us the number of that object that can be used in the association on both sides of the relationship. One <strong>Basket</strong> can hold many (represented by a <strong>*</strong>) <strong>Orange</strong> objects. Any one <strong>Orange</strong> can go in exactly one <strong>Basket</strong>. This number is referred to as the <em>multiplicity</em> of the object. You may also hear it described as the <em>cardinality</em>. These are actually slightly distinct terms. Cardinality refers to the actual number of items in the set, whereas multiplicity specifies how small or how large the set could be.</p>
<p>I sometimes forget which end of the relationship line is supposed to have which multiplicity number. The multiplicity nearest to a class is the number of objects of that class that can be associated with any one object at the other end of the association. For the apple goes in barrel association, reading from left to right, many instances of the <strong>Apple</strong> class (that is many <strong>Apple</strong> objects) can go in any one <strong>Barrel</strong>. Reading from right to left, exactly one <strong>Barrel</strong> can be associated with any one <strong>Apple</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Specifying attributes and behaviors</h1>
                </header>
            
            <article>
                
<p>We now have a grasp of some basic object-oriented terminology. Objects are instances of classes that can be associated with each other. An object instance is a specific object with its own set of data and behaviors; a specific orange on the table in front of us is said to be an instance of the general class of oranges. That's simple enough, but let's dive into the meaning of those two words, <em>data</em> and <em>behaviors</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data describes objects</h1>
                </header>
            
            <article>
                
<p>Let's start with data. Data represents the individual characteristics of a certain object. A class can define specific sets of characteristics that are shared by all objects from that class. Any specific object can have different data values for the given characteristics. For example, the three oranges on our table (if we haven't eaten any) could each weigh a different amount. The orange class could have a weight attribute to represent that datum. All instances of the orange class have a weight attribute, but each orange has a different value for this attribute. Attributes don't have to be unique, though; any two oranges may weigh the same amount. As a more realistic example, two objects representing different customers might have the same value for a first name attribute.</p>
<p>Attributes are frequently referred to as <strong>members</strong> or <strong>properties</strong>. Some authors suggest that the terms have different meanings, usually that attributes are settable, while properties are read-only. In Python, the concept of <em>read-only</em> is rather pointless, so throughout this book, we'll see the two terms used interchangeably. In addition, as we'll discuss in <a href="42cd7e16-073b-485c-8073-554ac64d992f.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>When to Use Object-Oriented Programming</em>, the <kbd>property</kbd> keyword has a special meaning in Python for a particular kind of attribute.</p>
<p>In our fruit inventory application, the fruit farmer may want to know what orchard the orange came from, when it was picked, and how much it weighs. They might also want to keep track of where each <strong>Basket</strong> is stored. Apples might have a color attribute, and barrels might come in different sizes. Some of these properties may also belong to multiple classes (we may want to know when apples are picked, too), but for this first example, let's just add a few different attributes to our class diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/0f81faab-3b48-4d5a-bb40-00f63bf6caf8.png" style="width:17.17em;height:16.33em;"/></div>
<p>Depending on how detailed our design needs to be, we can also specify the type for each attribute. Attribute types are often primitives that are standard to most programming languages, such as integer, floating-point number, string, byte, or Boolean. However, they can also represent data structures such as lists, trees, or graphs, or most notably, other classes. This is one area where the design stage can overlap with the programming stage. The various primitives or objects available in one programming language may be different from what is available in another:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/40213909-0fda-4ae3-8422-94ced58e8911.png" style="width:22.00em;height:16.00em;"/></div>
<p>Usually, we don't need to be overly concerned with data types at the design stage, as implementation-specific details are chosen during the programming stage. Generic names are normally sufficient for design. If our design calls for a list container type, Java programmers can choose to use a <kbd>LinkedList</kbd> or an <kbd>ArrayList</kbd> when implementing it, while Python programmers (that's us!) might choose between the <kbd>list</kbd> built-in and a <kbd>tuple</kbd>.</p>
<p>In our fruit-farming example so far, our attributes are all basic primitives. However, there are some implicit attributes that we can make explicit—the associations. For a given orange, we might have an attribute referring to the basket that holds that orange.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Behaviors are actions</h1>
                </header>
            
            <article>
                
<p>Now that we know what data is, the last undefined term is <em>behaviors</em>. Behaviors are actions that can occur on an object. The behaviors that can be performed on a specific class of object are called <strong>methods</strong>. At the programming level, methods are like functions in structured programming, but they <em>magically</em> have access to all the data associated with this object. Like functions, methods can also accept <strong>parameters</strong> and return <strong>values</strong>.</p>
<p>A method's parameters are provided to it as a list of objects that need to be <strong>passed</strong> into that method. The actual object instances that are passed into a method during a specific invocation are usually referred to as <strong>arguments</strong>. These objects are used by the method to perform whatever behavior or task it is meant to do. Returned values are the results of that task.</p>
<p>We've stretched our <em>comparing apples and oranges</em> example into a basic (if far-fetched) inventory application. Let's stretch it a little further and see whether it breaks. One action that can be associated with oranges is the <strong>pick</strong> action. If you think about implementation, <strong>pick</strong> would need to do two things:</p>
<ul>
<li>Place the orange in a basket by updating the <strong>Basket</strong> attribute of the orange</li>
<li>Add the orange to the <strong>Orange</strong> list on the given <strong>Basket</strong>.</li>
</ul>
<p>So, <strong>pick</strong> needs to know what basket it is dealing with. We do this by giving the <strong>pick</strong> method a <strong>Basket</strong> parameter. Since our fruit farmer also sells juice, we can add a <strong>squeeze</strong> method to the <strong>Orange</strong> class. When called, the <strong>squeeze</strong> method might return the amount of juice retrieved, while also removing the <strong>Orange</strong> from the <strong>Basket</strong> it was in.</p>
<p>The class <strong>Basket</strong> can have a <strong>sell</strong> action. When a basket is sold, our inventory system might update some data on as-yet unspecified objects for accounting and profit calculations. Alternatively, our basket of oranges might go bad before we can sell them, so we add a <strong>discard</strong> method. Let's add these methods to our diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0d650e06-f671-4acd-9490-f657598e0c46.png" style="width:35.42em;height:12.17em;"/></p>
<p>Adding attributes and methods to individual objects allows us to create a <strong>system</strong> of interacting objects. Each object in the system is a member of a certain class. These classes specify what types of data the object can hold and what methods can be invoked on it. The data in each object can be in a different state from other instances of the same class; each object may react to method calls differently because of the differences in state.</p>
<p>Object-oriented analysis and design is all about figuring out what those objects are and how they should interact. The next section describes principles that can be used to make those interactions as simple and intuitive as possible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hiding details and creating the public interface</h1>
                </header>
            
            <article>
                
<p>The key purpose of modeling an object in object-oriented design is to determine what the public <strong>interface</strong> of that object will be. The interface is the collection of attributes and methods that other objects can access to interact with that object. They do not need, and are often not allowed, to access the internal workings of the object.</p>
<p>A common real-world example is the television. Our interface to the television is the remote control. Each button on the remote control represents a method that can be called on the television object. When we, as the calling object, access these methods, we do not know or care if the television is getting its signal from a cable connection, a satellite dish, or an internet-enabled device. We don't care what electronic signals are being sent to adjust the volume, or whether the sound is destined for speakers or headphones. If we open the television to access the internal workings, for example, to split the output signal to both external speakers and a set of headphones, we will void the warranty.</p>
<p>This process of hiding the implementation of an object is suitably called <strong>information hiding</strong>. It is also sometimes referred to as <strong>encapsulation</strong>, but encapsulation is actually a more all-encompassing term. Encapsulated data is not necessarily hidden. Encapsulation is, literally, creating a capsule (think of creating a time capsule). If you put a bunch of information into a time capsule, and lock and bury it, it is both encapsulated and the information is hidden. On the other hand, if the time capsule, has not been buried and is unlocked or made of clear plastic, the items inside it are still encapsulated, but there is no information hiding.</p>
<p>The distinction between encapsulation and information hiding is largely irrelevant, especially at the design level. Many practical references use these terms interchangeably. As Python programmers, we don't actually have or need true information hiding (we'll discuss the reasons for this in <a href="0786c893-abb9-4f35-9320-3f2f54de95eb.xhtml"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Objects in Python</em>), so the more encompassing definition for encapsulation is suitable.</p>
<p>The public interface, however, is very important. It needs to be carefully designed as it is difficult to change it in the future. Changing the interface will break any client objects that are accessing it. We can change the internals all we like, for example, to make it more efficient, or to access data over the network as well as locally, and the client objects will still be able to talk to it, unmodified, using the public interface. On the other hand, if we alter the interface by changing publicly accessed attribute names or the order or types of arguments that a method can accept, all client classes will also have to be modified. When designing public interfaces, keep it simple. Always design the interface of an object based on how easy it is to use, not how hard it is to code (this advice applies to user interfaces as well).</p>
<p>Remember, program objects may represent real objects, but that does not make them real objects. They are models. One of the greatest gifts of modeling is the ability to ignore irrelevant details. The model car I built as a child looked like a real 1956 Thunderbird on the outside, but it obviously doesn't run. When I was too young to drive, these details were overly complex and irrelevant. The model is an <strong>abstraction</strong> of a real concept.</p>
<p><strong>Abstraction</strong> is another object-oriented term related to encapsulation and information hiding.  Abstraction means dealing with the level of detail that is most appropriate to a given task. It is the process of extracting a public interface from the inner details. A car's driver needs to interact with the steering, accelerator, and brakes. The workings of the motor, drive train, and brake subsystem don't matter to the driver. A mechanic, on the other hand, works at a different level of abstraction, tuning the engine and bleeding the brakes. Here's an example of two abstraction levels for a car:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/f449bcf2-2293-4fc2-8b9d-c9b85968ba0f.png" style="width:26.42em;height:21.08em;"/></div>
<p>Now, we have several new terms that refer to similar concepts. Let's summarize all this jargon in a couple of sentences: abstraction is the process of encapsulating information with separate public and private interfaces. The private interfaces can be subject to information hiding.</p>
<p>The important lesson to take from all these definitions is to make our models understandable to other objects that have to interact with them. This means paying careful attention to small details. Ensure methods and properties have sensible names. When analyzing a system, objects typically represent nouns in the original problem, while methods are normally verbs. Attributes may show up as adjectives or more nouns. Name your classes, attributes, and methods accordingly.</p>
<p>When designing the interface, imagine you are the object and that you have a very strong preference for privacy. Don't let other objects have access to data about you unless you feel it is in your best interest for them to have it. Don't give them an interface to force you to perform a specific task unless you are certain you want them to be able to do that to you.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Composition</h1>
                </header>
            
            <article>
                
<p>So far, we have learned to design systems as a group of interacting objects, where each interaction involves viewing objects at an appropriate level of abstraction. But we don't know yet how to create these levels of abstraction. There are a variety of ways to do this; we'll discuss some advanced design patterns in <a href="9a6335a2-1c69-4fa8-a685-02bbeeba23be.xhtml"><span class="ChapterrefPACKT">Chapter 8</span></a>, <em>Strings and Serialization,</em> and <a href="0abbcae0-eb3f-4237-adda-32765e1cce32.xhtml"><span class="ChapterrefPACKT">Chapter 9</span></a>, <em>The Iterator Pattern</em>. But even most design patterns rely on two basic object-oriented principles known as <strong>composition</strong> and <strong>inheritance</strong>. Composition is simpler, so let's start with it.</p>
<p>Composition is the act of collecting several objects together to create a new one. Composition is usually a good choice when one object is part of another object. We've already seen a first hint of composition in the mechanic example. A fossil-fueled car is composed of an engine, transmission, starter, headlights, and windshield, among numerous other parts. The engine, in turn, is composed of pistons, a crank shaft, and valves. In this example, composition is a good way to provide levels of abstraction. The <strong>Car</strong> object can provide the interface required by a driver, while also giving access to its component parts, which offers the deeper level of abstraction suitable for a mechanic. Those component parts can, of course, be further broken down if the mechanic needs more information to diagnose a problem or tune the engine.</p>
<p>A car is a common introductory example of composition, but it's not overly useful when it comes to designing computer systems. Physical objects are easy to break into component objects. People have been doing this at least since the ancient Greeks originally postulated that atoms were the smallest units of matter (they, of course, didn't have access to particle accelerators). Computer systems are generally less complicated than physical objects, yet identifying the component objects in such systems does not happen as naturally.</p>
<p>The objects in an object-oriented system occasionally represent physical objects such as people, books, or telephones. More often, however, they represent abstract ideas. People have names, books have titles, and telephones are used to make calls. Calls, titles, accounts, names, appointments, and payments are not usually considered objects in the physical world, but they are all frequently-modeled components in computer systems.</p>
<p>Let's try modeling a more computer-oriented example to see composition in action. We'll be looking at the design of a computerized chess game. This was a very popular pastime among academics in the 80s and 90s. People were predicting that computers would one day be able to defeat a human chess master. When this happened in 1997 (IBM's Deep Blue defeated world chess champion, Gary Kasparov), interest in the problem waned. Nowadays, the computer always wins.</p>
<p>As a basic, high-level analysis, a <em>game</em> of chess is <strong>played</strong> between two <em>players</em>, using a chess set featuring a <em>board</em> containing sixty-four <em>positions</em> in an 8x8 grid. The board can have two sets of sixteen <em>pieces</em> that can be <strong>moved</strong>, in alternating <em>turns</em> by the two players in different ways. Each piece can <strong>take</strong> other pieces. The board will be required to <strong>draw</strong> itself on the computer <em>screen</em> after each turn.</p>
<p>I've identified some of the possible objects in the description using <em>italics</em>, and a few key methods using <strong>bold</strong>. This is a common first step in turning an object-oriented analysis into a design. At this point, to emphasize composition, we'll focus on the board, without worrying too much about the players or the different types of pieces.</p>
<p>Let's start at the highest level of abstraction possible. We have two players interacting with a <strong>Chess Set</strong> by taking turns making moves:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/cce8f943-f61d-4166-85dd-c658cf898b48.png" style="width:27.58em;height:10.67em;"/></div>
<p>This doesn't quite look like our earlier class diagrams, which is a good thing since it isn't one! This is an <strong>object diagram</strong>, also called an <strong>instance diagram</strong>. It describes the system at a specific state in time, and is describing specific instances of objects, not the interaction between classes. Remember, both players are members of the same class, so the class diagram looks a little different:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/c2720c3b-6c13-4357-9e08-17834c0b7429.png" style="width:17.25em;height:5.33em;"/></div>
<p>The diagram shows that exactly two players can interact with one chess set. This also indicates that any one player can be playing with only one <strong>Chess Set</strong> at a time.</p>
<p>However, we're discussing composition, not UML, so let's think about what the <strong>Chess Set</strong> is composed of. We don't care what the player is composed of at this time. We can assume that the player has a heart and brain, among other organs, but these are irrelevant to our model. Indeed, there is nothing stopping said player from being Deep Blue itself, which has neither a heart nor a brain.</p>
<p>The chess set, then, is composed of a board and 32 pieces. The board further comprises 64 positions. You could argue that pieces are not part of the chess set because you could replace the pieces in a chess set with a different set of pieces. While this is unlikely or impossible in a computerized version of chess, it introduces us to <strong>aggregation</strong>.</p>
<p>Aggregation is almost exactly like composition. The difference is that aggregate objects can exist independently. It would be impossible for a position to be associated with a different chess board, so we say the board is composed of positions. But the pieces, which might exist independently of the chess set, are said to be in an aggregate relationship with that set.</p>
<p>Another way to differentiate between aggregation and composition is to think about the lifespan of the object. If the composite (outside) object controls when the related (inside) objects are created and destroyed, composition is most suitable. If the related object is created independently of the composite object, or can outlast that object, an aggregate relationship makes more sense. Also, keep in mind that composition is aggregation; aggregation is simply a more general form of composition. Any composite relationship is also an aggregate relationship, but not vice versa.</p>
<p>Let's describe our current <strong>Chess Set</strong> composition and add some attributes to the objects to hold the composite relationships:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/929aff43-9cc8-4419-8616-0f36d1a1f2ff.png" style="width:40.17em;height:13.58em;"/></p>
<p>The composition relationship is represented in UML as a solid diamond. The hollow diamond represents the aggregate relationship. You'll notice that the board and pieces are stored as part of the <strong>Chess Set</strong> in exactly the same way a reference to them is stored as an attribute on the chess set. This shows that, once again, in practice, the distinction between aggregation and composition is often irrelevant once you get past the design stage. When implemented, they behave in much the same way. However, it can help to differentiate between the two when your team is discussing how the different objects interact. Often, you can treat them as the same thing, but when you need to distinguish between them (usually when talking about how long related objects exist), it's great to know the difference.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inheritance</h1>
                </header>
            
            <article>
                
<p>We discussed three types of relationships between objects: association, composition, and aggregation. However, we have not fully specified our chess set, and these tools don't seem to give us all the power we need. We discussed the possibility that a player might be a human or it might be a piece of software featuring artificial intelligence. It doesn't seem right to say that a player is <em>associated</em> with a human, or that the artificial intelligence implementation is <em>part of</em> the player object. What we really need is the ability to say that <em>Deep Blue is a player,</em> or that <em>Gary Kasparov is a player</em>.</p>
<p>The <em>is a</em> relationship is formed by <strong>inheritance</strong>. Inheritance is the most famous, well-known, and over-used relationship in object-oriented programming. Inheritance is sort of like a family tree. My grandfather's last name was Phillips and my father inherited that name. I inherited it from him. In object-oriented programming, instead of inheriting features and behaviors from a person, one class can inherit attributes and methods from another class.</p>
<p>For example, there are 32 chess pieces in our chess set, but there are only six different types of pieces (pawns, rooks, bishops, knights, king, and queen), each of which behaves differently when it is moved. All of these classes of piece have properties, such as color and the chess set they are part of, but they also have unique shapes when drawn on the chess board, and make different moves. Let's see how the six types of pieces can inherit from a <strong>Piece</strong> class:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cb334e90-08f3-4736-940b-ea3a653a4cce.png" style="width:44.08em;height:19.75em;"/></p>
<p>The hollow arrows indicate that the individual classes of pieces inherit from the <strong>Piece</strong> class. All the child classes automatically have a <strong>chess_set</strong> and <strong>color</strong> attribute inherited from the base class. Each piece provides a different shape property (to be drawn on the screen when rendering the board), and a different <strong>move</strong> method to move the piece to a new position on the board at each turn.</p>
<p>We actually know that all subclasses of the <strong>Piece</strong> class need to have a <strong>move</strong> method; otherwise, when the board tries to move the piece, it will get confused. It is possible that we would want to create a new version of the game of chess that has one additional piece (the wizard). Our current design will allow us to design this piece without giving it a <strong>move</strong> method. The board would then choke when it asked the piece to move itself.</p>
<p>We can fix this by creating a dummy move method on the <strong>Piece</strong> class. The subclasses can then <strong>override</strong> this method with a more specific implementation. The default implementation might, for example, pop up an error message that says <strong>That piece cannot be moved</strong>.</p>
<p>Overriding methods in subclasses allows very powerful object-oriented systems to be developed. For example, if we wanted to implement a <strong>Player</strong> class with artificial intelligence, we might provide a <kbd>calculate_move</kbd> method that takes a <strong>Board</strong> object and decides which piece to move where. A very basic class might randomly choose a piece and direction and move it accordingly. We could then override this method in a subclass with the Deep Blue implementation. The first class would be suitable for play against a raw beginner; the latter would challenge a grand master. The important thing is that other methods in the class, such as the ones that inform the board as to which move was chosen, need not be changed; this implementation can be shared between the two classes.</p>
<p>In the case of chess pieces, it doesn't really make sense to provide a default implementation of the move method. All we need to do is specify that the move method is required in any subclasses. This can be done by making <strong>Piece</strong> an <strong>abstract class</strong> with the move method declared <strong>abstract</strong>. Abstract methods basically say this:</p>
<div class="packt_quote">We demand this method exist in any non-abstract subclass, but we are declining to specify an implementation in this class.</div>
<p>Indeed, it is possible to make a class that does not implement any methods at all. Such a class would simply tell us what the class should do, but provides absolutely no advice on how to do it. In object-oriented parlance, such classes are called <strong>interfaces</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inheritance provides abstraction</h1>
                </header>
            
            <article>
                
<p>Let's explore the longest word in object-oriented argot. <strong>Polymorphism</strong> is the ability to treat a class differently, depending on which subclass is implemented. We've already seen it in action with the pieces system we've described. If we took the design a bit further, we'd probably see that the <strong>Board</strong> object can accept a move from the player and call the <strong>move</strong> function on the piece. The board need not ever know what type of piece it is dealing with. All it has to do is call the <strong>move</strong> method, and the proper subclass will take care of moving it as a <strong>Knight</strong> or a <strong>Pawn</strong>.</p>
<p>Polymorphism is pretty cool, but it is a word that is rarely used in Python programming. Python goes an extra step past allowing a subclass of an object to be treated like a parent class. A board implemented in Python could take any object that has a <strong>move</strong> method, whether it is a bishop piece, a car, or a duck. When <strong>move</strong> is called, the <strong>Bishop</strong> will move diagonally on the board, the car will drive someplace, and the duck will swim or fly, depending on its mood.</p>
<p>This sort of polymorphism in Python is typically referred to as <strong>duck typing</strong>: <em>if it walks like a duck or swims like a duck, it's a duck</em>. We don't care if it really <em>is a</em> duck (<em>is a</em> being a cornerstone of inheritance), only that it swims or walks. Geese and swans might easily be able to provide the duck-like behavior we are looking for. This allows future designers to create new types of birds without actually specifying an inheritance hierarchy for aquatic birds. It also allows them to create completely different drop-in behaviors that the original designers never planned for. For example, future designers might be able to make a walking, swimming penguin that works with the same interface without ever suggesting that penguins are ducks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Multiple inheritance</h1>
                </header>
            
            <article>
                
<p>When we think of inheritance in our own family tree, we can see that we inherit features from more than just one parent. When strangers tell a proud mother that her son has <em>his father's eyes</em>, she will typically respond along the lines of, <em>yes, but he got my nose</em>.</p>
<p>Object-oriented design can also feature such <strong>multiple inheritance</strong>, which allows a subclass to inherit functionality from multiple parent classes. In practice, multiple inheritance can be a tricky business, and some programming languages (most famously, Java) strictly prohibit it. However, multiple inheritance can have its uses. Most often, it can be used to create objects that have two distinct sets of behaviors. For example, an object designed to connect to a scanner and send a fax of the scanned document might be created by inheriting from two separate <kbd>scanner</kbd> and <kbd>faxer</kbd> objects.</p>
<p>As long as two classes have distinct interfaces, it is not normally harmful for a subclass to inherit from both of them. However, it gets messy if we inherit from two classes that provide overlapping interfaces. For example, if we have a motorcycle class that has a <kbd>move</kbd> method, and a boat class also featuring a <kbd>move</kbd> method, and we want to merge them into the ultimate amphibious vehicle, how does the resulting class know what to do when we call <kbd>move</kbd>? At the design level, this needs to be explained, and, at the implementation level, each programming language has different ways of deciding which parent class's method is called, or in what order.</p>
<p>Often, the best way to deal with it is to avoid it. If you have a design showing up like this, you're <em>probably</em> doing it wrong. Take a step back, analyze the system again, and see if you can remove the multiple inheritance relationship in favor of some other association or composite design.</p>
<p>Inheritance is a very powerful tool for extending behavior. It is also one of the most marketable advancements of object-oriented design over earlier paradigms. Therefore, it is often the first tool that object-oriented programmers reach for. However, it is important to recognize that owning a hammer does not turn screws into nails. Inheritance is the perfect solution for obvious <em>is a</em> relationships, but it can be abused. Programmers often use inheritance to share code between two kinds of objects that are only distantly related, with no <em>is a</em> relationship in sight. While this is not necessarily a bad design, it is a terrific opportunity to ask just why they decided to design it that way, and whether a different relationship or design pattern would have been more suitable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case study</h1>
                </header>
            
            <article>
                
<p>Let's tie all our new object-oriented knowledge together by going through a few iterations of object-oriented design on a somewhat real-world example. The system we'll be modeling is a library catalog. Libraries have been tracking their inventory for centuries, originally using card catalogs, and more recently, electronic inventories. Modern libraries have web-based catalogs that we can query from our homes.</p>
<p>Let's start with an analysis. The local librarian has asked us to write a new card catalog program because their ancient Windows XP-based program is ugly and out of date. That doesn't give us much detail, but before we start asking for more information, let's consider what we already know about library catalogs.</p>
<p>Catalogs contain lists of books. People search them to find books on certain subjects, with specific titles, or by a particular author. Books can be uniquely identified by an <strong>International Standard Book Number</strong> (<strong>ISBN</strong>). Each book has a <strong>Dewey Decimal System</strong> (<strong>DDS</strong>) number assigned to help find it on a particular shelf.</p>
<p>This simple analysis tells us some of the obvious objects in the system. We quickly identify <strong>Book</strong> as the most important object, with several attributes already mentioned, such as author, title, subject, ISBN, and DDS number, and catalog as a sort of manager for books.</p>
<p>We also notice a few other objects that may or may not need to be modeled in the system. For cataloging purposes, all we need to search a book by author is an <kbd>author_name</kbd> attribute on the book. However, authors are also objects, and we might want to store some other data about the author. As we ponder this, we might remember that some books have multiple authors. Suddenly, the idea of having a single <kbd>author_name</kbd> attribute on objects seems a bit silly. A list of authors associated with each book is clearly a better idea.</p>
<p>The relationship between author and book is clearly association, since you would never say <em>a book is an author</em> (it's not inheritance), and saying <em>a book has an author</em>, though grammatically correct, does not imply that authors are part of books (it's not aggregation). Indeed, any one author may be associated with multiple books.</p>
<p>We should also pay attention to the noun (nouns are always good candidates for objects) <em>shelf</em>. Is a shelf an object that needs to be modeled in a cataloging system? How do we identify an individual shelf? What happens if a book is stored at the end of one shelf, and later moved to the beginning of the next shelf because a new book was inserted in the previous shelf?</p>
<p>DDS was designed to help locate physical books in a library. As such, storing a DDS attribute with the book should be enough to locate it, regardless of which shelf it is stored on. So we can, at least for the moment, remove shelf from our list of contending objects.</p>
<p>Another questionable object in the system is the user. Do we need to know anything about a specific user, such as their name, address, or list of overdue books? So far, the librarian has told us only that they want a catalog; they said nothing about tracking subscriptions or overdue notices. In the back of our minds, we also note that authors and users are both specific kinds of people; there might be a useful inheritance relationship here in the future.</p>
<p>For cataloging purposes, we decide we don't need to identify the user for now. We can assume that a user will be searching the catalog, but we don't have to actively model them in the system, beyond providing an interface that allows them to search.</p>
<p>We have identified a few attributes on the book, but what properties does a catalog have? Does any one library have more than one catalog? Do we need to uniquely identify them? Obviously, the catalog has to have a collection of the books it contains, somehow, but this list is probably not part of the public interface.</p>
<p>What about behaviors? The catalog clearly needs a search method, possibly separate ones for authors, titles, and subjects. Are there any behaviors on books? Would it need a preview method? Or could preview be identified by a first page attribute instead of a method?</p>
<p>The questions in the preceding discussion are all part of the object-oriented analysis phase. But intermixed with the questions, we have already identified a few key objects that are part of the design. Indeed, what you have just seen are several microiterations between analysis and design.</p>
<p>Likely, these iterations would all occur in an initial meeting with the librarian. Before this meeting, however, we can already sketch out a most basic design for the objects we have concretely identified, as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/9b3385dd-f401-4fad-a791-8275a1ef2374.png" style="width:19.92em;height:16.33em;"/></div>
<p>Armed with this basic diagram and a pencil to interactively improve it, we meet up with the librarian. They tell us that this is a good start, but libraries don't serve only books; they also have DVDs, magazines, and CDs, none of which have an ISBN or DDS number. All of these types of items can be uniquely identified by a UPC number, though. We remind the librarian that they have to find the items on the shelf, and these items probably aren't organized by UPC. The librarian explains that each type is organized in a different way. The CDs are mostly audio books, and they only have two dozen in stock, so they are organized by the author's last name. DVDs are divided into genre and further organized by title. Magazines are organized by title and then refined by the volume and issue number. Books are, as we had guessed, organized by the DDS number.</p>
<p>With no previous object-oriented design experience, we might consider adding separate lists of DVDs, CDs, magazines, and books to our catalog, and search each one in turn. The trouble is, except for certain extended attributes, and identifying the physical location of the item, these items all behave much the same. This is a job for inheritance! We quickly update our UML diagram as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/d524ed1b-5d32-40c0-9920-215c3f12b564.png" style="width:37.17em;height:20.42em;"/></div>
<p>The librarian understands the gist of our sketched diagram, but is a bit confused by the <strong>locate</strong> functionality. We explain using a specific use case where the user is searching for the word <em>bunnies</em>. The user first sends a search request to the catalog. The catalog queries its internal list of items and finds a book and a DVD with <em>bunnies</em> in the title. At this point, the catalog doesn't care whether it is holding a DVD, book, CD, or magazine; all items are the same, as far as the catalog is concerned. However, the user wants to know how to find the physical items, so the catalog would be remiss if it simply returned a list of titles. So, it calls the <strong>locate</strong> method on the two items it has uncovered. The book's <strong>locate</strong> method returns a DDS number that can be used to find the shelf holding the book. The DVD is located by returning the genre and title of the DVD. The user can then visit the DVD section, find the section containing that genre, and find the specific DVD as sorted by the titles.</p>
<p>As we explain, we sketch a UML <strong>sequence diagram</strong>, explaining how the various objects are communicating:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/2ce3970b-112a-4f5a-bf58-b6fc76f21b8f.png" style="width:27.83em;height:29.17em;"/></div>
<p>While class diagrams describe the relationships between classes, sequence diagrams describe specific sequences of messages passed between objects. The dashed line hanging from each object is a <strong>lifeline</strong> describing the lifetime of the object. The wider boxes on each lifeline represent active processing in that object (where there's no box, the object is basically sitting idle, waiting for something to happen). The horizontal arrows between the lifelines indicate specific messages. The solid arrows represent methods being called, while the dashed arrows with solid heads represent the method return values.</p>
<p>The half arrowheads indicate asynchronous messages sent to or from an object. An asynchronous message typically means the first object calls a method on the second object, which returns immediately. After some processing, the second object calls a method on the first object to give it a value. This is in contrast to normal method calls, which do the processing in the method, and return a value immediately.</p>
<p>Sequence diagrams, like all UML diagrams, are best used only when they are needed. There is no point in drawing a UML diagram for the sake of drawing a diagram. However, when you need to communicate a series of interactions between two objects, the sequence diagram is a very useful tool.</p>
<p>Unfortunately, our class diagram so far is still a messy design. We notice that actors on DVDs and artists on CDs are all types of people, but are being treated differently from the book authors. The librarian also reminds us that most of their CDs are audio books, which have authors instead of artists.</p>
<p>How can we deal with different kinds of people that contribute to a title? One obvious implementation is to create a <kbd>Person</kbd> class with the person's name and other relevant details, and then create subclasses of this for the artists, authors, and actors. However, is inheritance really necessary here? For searching and cataloging purposes, we don't really care that acting and writing are two very different activities. If we were doing an economic simulation, it would make sense to give separate actor and author classes, and different <kbd>calculate_income</kbd> and <kbd>perform_job</kbd> methods, but for cataloging purposes, it is enough to know how the person contributed to the item. Having thought this through, we recognize that all items have one or more <kbd>Contributor</kbd> objects, so we move the author relationship from the book to its parent class:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/96a84929-92b2-4fa6-b610-07fb11c70605.png" style="width:34.50em;height:20.58em;"/></div>
<p>The multiplicity of the <strong>Contributor</strong>/<strong>LibraryItem</strong> relationship is <strong>many-to-many</strong>, as indicated by the <strong>*</strong> character at both ends of one relationship. Any one library item might have more than one contributor (for example, several actors and a director on a DVD). And many authors write many books, so they be attached to multiple library items.</p>
<p>This little change, while it looks a bit cleaner and simpler, has lost some vital information. We can still tell who contributed to a specific library item, but we don't know how they contributed. Were they the director or an actor? Did they write the audio book, or were they the voice that narrated the book?</p>
<p>It would be nice if we could just add a <kbd>contributor_type</kbd> attribute on the <strong>Contributor</strong> class, but this will fall apart when dealing with multi-talented people who have both authored books and directed movies.</p>
<p>One option is to add attributes to each of our <strong>LibraryItem</strong> subclasses to hold the information we need, such as <strong>Author</strong> on <strong>Book</strong>, or <strong>Artist</strong> on <strong>CD</strong>, and then make the relationship to those properties all point to the <strong>Contributor</strong> class. The problem with this is that we lose a lot of polymorphic elegance. If we want to list the contributors to an item, we have to look for specific attributes on that item, such as <strong>Authors</strong> or <strong>Actors</strong>. We can solve this by adding a <strong>GetContributors</strong> method on the <strong>LibraryItem</strong> class that subclasses can override. Then the catalog never has to know what attributes the objects are querying; we've abstracted the public interface:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/2b802a09-3415-425c-8579-7c05b120a6ac.png" style="width:35.75em;height:29.25em;"/></div>
<p>Just looking at this class diagram, it feels like we are doing something wrong. It is bulky and fragile. It may do everything we need, but it feels like it will be hard to maintain or extend. There are too many relationships, and too many classes would be affected by modifications to any one class. It looks like spaghetti and meatballs.</p>
<p>Now that we've explored inheritance as an option, and found it wanting, we might look back at our previous composition-based diagram, where <strong>Contributor</strong> was attached directly to <strong>LibraryItem</strong>. With some thought, we can see that we actually only need to add one more relationship to a brand-new class to identify the type of contributor. This is an important step in object-oriented design. We are now adding a class to the design that is intended to <em>support</em> the other objects, rather than modeling any part of the initial requirements. We are <strong>refactoring</strong> the design to facilitate the objects in the system, rather than objects in real life. Refactoring is an essential process in the maintenance of a program or design. The goal of refactoring is to improve the design by moving code around, removing duplicate code or complex relationships in favor of simpler, more elegant designs.</p>
<p>This new class is composed of a <strong>Contributor</strong> and an extra attribute identifying the type of contribution the person has made to the given <strong>LibraryItem</strong>. There can be many such contributions to a particular <strong>LibraryItem</strong>, and one contributor can contribute in the same way to different items. The following diagram communicates this design very well:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/98765a8a-a5aa-4952-90e6-36830c80c653.png" style="width:37.83em;height:18.50em;"/></div>
<p>At first, this composition relationship looks less natural than the inheritance-based relationships. However, it has the advantage of allowing us to add new types of contributions without adding a new class to the design. Inheritance is most useful when the subclasses have some kind of <strong>specialization</strong>. Specialization is creating or changing attributes or behaviors on the subclass to make it somehow different from the parent class. It seems silly to create a bunch of empty classes solely for identifying different types of objects (this attitude is less prevalent among Java and other <em>everything is an object</em> programmers, but it is common among more pragmatic Python designers). If we look at the inheritance version of the diagram, we can see a bunch of subclasses that don't actually do anything:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/7decfd4c-2c35-442e-93c5-6189dec87260.png" style="width:30.83em;height:14.00em;"/></div>
<p>Sometimes, it is important to recognize when not to use object-oriented principles. This example of when not to use inheritance is a good reminder that objects are just tools, and not rules.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exercises</h1>
                </header>
            
            <article>
                
<p>This is a practical book, not a textbook. As such, I'm not assigning a bunch of fake object-oriented analysis problems to create designs for you to analyze and design. Instead, I want to give you some ideas that you can apply to your own projects. If you have previous object-oriented experience, you won't need to put much effort into this chapter. However, they are useful mental exercises if you've been using Python for a while, but have never really cared about all that class stuff.</p>
<p>First, think about a recent programming project you've completed. Identify the most prominent object in the design. Try to think of as many attributes for this object as possible. Did it have the following: Color? Weight? Size? Profit? Cost? Name? ID number? Price? Style?</p>
<p>Think about the attribute types. Were they primitives or classes? Were some of those attributes actually behaviors in disguise? Sometimes, what looks like data is actually calculated from other data on the object, and you can use a method to do those calculations. What other methods or behaviors did the object have? Which objects called those methods? What kinds of relationships did they have with this object?</p>
<p>Now, think about an upcoming project. It doesn't matter what the project is; it might be a fun free-time project or a multi-million-dollar contract. It doesn't have to be a complete application; it could just be one subsystem. Perform a basic object-oriented analysis. Identify the requirements and the interacting objects. Sketch out a class diagram featuring the highest level of abstraction on that system. Identify the major interacting objects. Identify minor supporting objects. Go into detail for the attributes and methods of some of the most interesting ones. Take different objects to different levels of abstraction. Look for places where you can use inheritance or composition. Look for places where you should avoid inheritance.</p>
<p>The goal is not to design a system (although you're certainly welcome to do so if inclination meets both ambition and available time). The goal is to think about object-oriented design. Focusing on projects that you have worked on, or are expecting to work on in the future, simply makes it real.</p>
<p>Lastly, visit your favorite search engine and look up some tutorials on UML. There are dozens, so find one that suits your preferred method of study. Sketch some class diagrams or a sequence diagram for the objects you identified earlier. Don't get too hung up on memorizing the syntax (after all, if it is important, you can always look it up again); just get a feel for the language. Something will stay lodged in your brain, and it can make communicating a bit easier if you can quickly sketch a diagram for your next OOP discussion.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we took a whirlwind tour through the terminology of the object-oriented paradigm, focusing on object-oriented design. We can separate different objects into a taxonomy of different classes and describe the attributes and behaviors of those objects via the class interface. Abstraction, encapsulation, and information hiding are highly-related concepts. There are many different kinds of relationships between objects, including association, composition, and inheritance. UML syntax can be useful for fun and communication.</p>
<p>In the next chapter, we'll explore how to implement classes and methods in Python.</p>


            </article>

            
        </section>
    </body></html>