- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Data Modeling
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据建模
- en: The core of any application is its data. At the very root of any computer application,
    it's a system designed to deal with information, receiving it, transforming it,
    and returning either the same information or insightful elements extracted from
    it. The stored data is a crucial part of this cycle, as it allows you to use information
    that has been communicated before.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序的核心是其数据。在计算机应用程序的最底层，它是一个设计来处理信息、接收它、转换它并返回相同信息或从中提取的见解的系统。存储的数据是这个周期中的关键部分，因为它允许你使用之前已经传达的信息。
- en: In this chapter, we will talk about how we can model the stored data from our
    application and what the different options are to store and structure the data
    to be persisted.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何对应用程序中存储的数据进行建模，以及存储和结构化要持久化的数据的不同选项。
- en: We will start by describing the different database options that are available,
    which are critical to understanding their different applications, but we will
    mostly focus, during the chapter, on relational databases, as they are the most
    common type. We will describe the concept of a transaction to ensure that different
    changes are applied in one go.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先描述可用的不同数据库选项，这对于理解它们的不同应用至关重要，但在本章中，我们将主要关注关系数据库，因为它们是最常见的类型。我们将描述事务的概念，以确保不同的更改能够一次性应用。
- en: We will describe different ways that we can increase the scope of a relational
    database by using multiple servers, and what the use cases for each option are.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将描述使用多个服务器来扩展关系数据库的不同方法，以及每个选项的使用案例。
- en: After that, we will describe different alternatives when designing a schema
    to ensure that our data is structured in the best possible way. We will discuss
    how to enable fast access to data through the usage of indices.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将描述在设计模式时不同的替代方案，以确保我们的数据以最佳方式结构化。我们将讨论如何通过使用索引来启用对数据的快速访问。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Types of databases
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库类型
- en: Database transactions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库事务
- en: Distributed relational databases
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式关系数据库
- en: Schema design
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式设计
- en: Data indexing
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据索引
- en: Let's start with an introduction to the different databases out there.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从介绍现有的不同数据库开始。
- en: Types of databases
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库类型
- en: All the persistent data from an application should live in a database. As we've
    discussed, data is the most critical aspect of any application, and proper handling
    of it is critical to ensure the viability of the project.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的所有持久数据都应该存储在数据库中。正如我们讨论的那样，数据是任何应用程序最关键的部分，正确处理它对于确保项目的可行性至关重要。
- en: Technically, databases are collections of data themselves and are handled by
    the **database management system** (**DBMS**), the software that allows the input
    and output of data. Normally, the word "database" is used for both the collection
    and the management system, depending on the context. Most DBMSes will allow access
    to multiple databases of the same kind, without being able to cross data between
    them, to allow logical separation of the data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来看，数据库本身就是数据的集合，并由数据库管理系统（**DBMS**）处理，该软件允许数据的输入和输出。通常，根据上下文，“数据库”一词用于集合和管理系统。大多数DBMS将允许访问同一类型的多个数据库，而无法在它们之间交叉数据，以允许数据的逻辑分离。
- en: Databases have been a critical tool for most of the time software systems have
    been available. They create an abstraction layer that allows accessing data without
    having to worry too much about how the data is structured by the hardware. Most
    databases allow the structure of the data to be defined without having to worry
    about how that's implemented behind the curtains.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库在软件系统存在的大部分时间里都是一个关键工具。它们创建了一个抽象层，允许访问数据而无需过多担心硬件如何结构化数据。大多数数据库允许定义数据的结构，而无需担心幕后如何实现。
- en: As we saw in *Chapter 2*, *API Design*, this abstraction is not perfect and
    sometimes we will have to understand the internals of databases to improve the
    performance or do things in "the proper way."
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第二章*，*API设计*中看到的，这种抽象并不完美，有时我们不得不了解数据库的内部结构，以提高性能或以“正确的方式”做事。
- en: 'DBMSes are among the most invested and mature projects in software. Each DBMS
    has its own quirks, to the point where there''s a specific job role for a "database
    expert": the **Database Administrator** (**DBA**).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: DBMS是软件中最受投资和成熟的工程项目之一。每个DBMS都有其独特的特点，以至于有一个专门的职位是“数据库专家”：**数据库管理员**（**DBA**）。
- en: The DBA role was quite popular for a long time and required highly specialized
    engineers, to the point of DBAs specializing in a single specific DBMS. The DBA
    will act as the expert in the database, both in knowing how to access it and ensuring
    that any changes done to it work adequately. They normally are the only ones allowed
    to perform changes or maintenance tasks in the database.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库管理员（DBA）角色在很长时间内非常受欢迎，需要高度专业化的工程师，以至于DBA专门从事单个特定的DBMS。DBA将作为数据库的专家，既了解如何访问它，又确保对其所做的任何更改都能适当地工作。他们通常是唯一被允许在数据库中执行更改或维护任务的。
- en: Performance improvements in hardware and software and external tools to handle
    database complexity have made this role less common, though it's still in use
    by some organizations. To a certain degree, the architect role overtakes parts
    of this role, though with more of a supervising role and less of a gatekeeping
    one.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件和软件的性能改进以及处理数据库复杂性的外部工具使得这个角色不那么常见，尽管一些组织仍在使用它。在某种程度上，架构师角色接管了这一角色的部分，尽管更多的是监督角色而不是把关角色。
- en: 'There are multiple DBMSes available on the market, with a good selection of
    open source software that covers most use cases. Roughly speaking, we can divide
    the existing DBMS alternatives into this non-exhaustive classification:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有多款数据库管理系统（DBMS）可供选择，其中包括丰富的开源软件，可以覆盖大多数用例。粗略地说，我们可以将现有的DBMS替代品分为以下非详尽分类：
- en: '**Relational databases**: The default standard in databases. Use SQL query
    language and have a defined schema. Examples are open source projects like MySQL
    or PostgreSQL, or commercial ones like Oracle or MS SQL Server.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关系型数据库**：数据库中的默认标准。使用SQL查询语言并具有定义的架构。例如，像MySQL或PostgreSQL这样的开源项目，或者像Oracle或MS
    SQL Server这样的商业产品。'
- en: '**Non-relational databases**: New alternatives to the traditional databases.
    This is a diverse group with multiple alternatives, and includes very different
    options like MongoDB, Riak, or Cassandra.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非关系型数据库**：传统数据库的新替代品。这是一个多样化的群体，有多种替代品，包括MongoDB、Riak或Cassandra等非常不同的选项。'
- en: '**Small databases**: These databases are aimed to be embedded into the system.
    The most famous example is SQLite.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小型数据库**：这些数据库旨在嵌入到系统中。最著名的例子是SQLite。'
- en: Let's take a more in-depth look at them.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解一下它们。
- en: Relational databases
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系型数据库
- en: These are the most common databases and the first idea that comes to mind when
    talking about databases. The relational model for databases was developed in the
    1970s, and it's based on creating a series of tables that can be related to each
    other. Since the 1980s, they have become incredibly popular.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是最常见的数据库，当谈到数据库时，人们首先想到的想法。数据库的关系模型是在20世纪70年代开发的，它基于创建一系列可以相互关联的表。自20世纪80年代以来，它们变得极其流行。
- en: Each defined table has a number of fields or columns that are fixed and data
    is described as records or rows. Tables are theoretically infinite, so more and
    more rows can be added. One of the columns is defined as the *primary key* and
    uniquely describes the row. Therefore, it needs to be unique.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个定义的表都有一定数量的固定字段或列，数据被描述为记录或行。理论上，表是无限的，因此可以添加越来越多的行。其中一列被定义为*主键*，并唯一描述了该行。因此，它需要是唯一的。
- en: If there is a value that's unique and descriptive enough, it can be used for
    the primary key; this is called a *natural key*. Natural keys can also be a combination
    of fields, though that limits their convenience. When a natural key is not available,
    an increasing counter can be handled directly by the database to ensure it is
    unique per row. This is called a *surrogate key*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个值既独特又足够描述性，它可以用作主键；这被称为*自然键*。自然键也可以是字段的组合，但这限制了它们的便利性。当没有自然键可用时，数据库可以直接处理递增计数器以确保每行都是唯一的。这被称为*代理键*。
- en: The primary key is used to reference that record, when necessary, in other tables.
    This creates the relation aspect of the database. When a column in a table makes
    reference to another table, this is called a *foreign* *key*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要时，主键用于在其他表中引用该记录。这创建了数据库的关系方面。当表中的一列引用另一个表时，这被称为*外键*。
- en: These references can produce one-to-one relationships; one-to-many, when a single
    row can be referenced in multiple rows in another table; or even many-to-many,
    which requires an intermediary table to cross over the data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些引用可以产生一对一的关系；一对一，当单行可以在另一个表中的多行中引用时；甚至多对多，这需要一个中间表来跨越数据。
- en: All this information needs to be described in the schema. The schema describes
    each table, what the fields and types of each are, as well as the relations between
    them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些信息都需要在模式中描述。模式描述了每个表，以及每个字段的类型，以及它们之间的关系。
- en: Relations in relational databases are really constraints. That means that a
    value can't be deleted if it's still referenced somewhere. Relational databases
    come from a strict mathematical background, though that background's implemented
    in different degrees of strictness.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库中的关系实际上是约束。这意味着如果一个值在某处被引用，则不能删除它。关系型数据库来自严格的数学背景，尽管这种背景在不同程度上得到了实施。
- en: It's important to note that defining the schema requires thinking ahead and
    being aware of the changes that can be made. Defining types before having data
    also requires keeping in mind possible improvements. While the schema can be changed,
    it's always a serious operation that, if not taken with proper care, can lead
    to the database not being available for some time, or, in the worst-case scenario,
    data can be changed or processed inconsistently.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，定义模式需要提前思考和意识到可以做出的更改。在拥有数据之前定义类型，也需要考虑到可能的改进。虽然模式可以更改，但这始终是一项严肃的操作，如果不妥善处理，可能会导致数据库在一段时间内不可用，或者在最坏的情况下，数据可能会被不一致地更改或处理。
- en: A query can also be executed that searches for data fulfilling certain conditions.
    For that, tables can be joined based on their relationships.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以执行查询来搜索满足特定条件的数据。为此，可以根据它们之间的关系将表连接起来。
- en: Virtually all relational databases are interacted with using Structured Query
    Language, or SQL. This language has become the standard to work with relational
    databases and follow the same concepts that we've described here. It describes
    both how to query the database and how to add or change data contained there.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有关系型数据库都是通过结构化查询语言（SQL）进行交互的。这种语言已经成为与关系型数据库一起工作并遵循我们在这里描述的相同概念的标准。它描述了如何查询数据库以及如何添加或更改其中包含的数据。
- en: The most relevant characteristic of SQL is that it is a declarative language.
    This means that the statements describe the result instead of the procedure to
    obtain it, as is typical with imperative languages. This abstracts the internal
    details away from the *how* to focus on the *what*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 最相关的特性是它是一种声明式语言。这意味着语句描述的是结果，而不是获取该结果的过程，这与命令式语言中的典型做法不同。这抽象了内部细节，从而关注于“什么”。
- en: Imperative languages describe the control flow and are the most common languages.
    Examples of imperative languages are Python, JavaScript, C, and Java. Declarative
    languages are normally restricted to specific domains (Domain-Specific Languages,
    or DSLs) that allow you to describe the result in simpler terms, while imperative
    languages are more flexible.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式语言描述控制流，是最常见的语言。命令式语言的例子包括 Python、JavaScript、C 和 Java。声明式语言通常限于特定的领域（领域特定语言，或
    DSL），允许你用更简单的术语描述结果，而命令式语言则更加灵活。
- en: This characteristic makes SQL portable between systems, as the internals of
    the *how* can be different in different databases. Using a specific relational
    database and adapting to another is relatively easy.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这一特性使得 SQL 在不同系统之间具有可移植性，因为不同数据库的内部“如何”可能不同。使用特定的关系型数据库并适应另一个数据库相对容易。
- en: This is used sometimes to set up a local database for running tests that's different
    from the final database that will be in place once the system is in production.
    This is possible in some web frameworks, but it requires some caveats, as complex
    systems sometimes have to use specific characteristics for a particular database,
    making it impossible to perform an easy replacement of this kind.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这有时用于设置一个用于运行测试的本地数据库，该数据库与系统投入生产后将存在的最终数据库不同。这在某些 Web 框架中是可能的，但需要注意一些注意事项，因为复杂系统有时必须为特定数据库使用特定特性，这使得进行此类简单替换变得不可能。
- en: While relational databases are very mature and flexible and are used in very
    different scenarios, there are two main problems that are difficult to deal with.
    One is requiring a predefined schema, as we said above. The other, and more serious
    after a certain size, is dealing with scale. Relational databases are thought
    to be a central access point that's accessed, and there need to be some techniques
    to scale once the limit of vertical scaling has been reached.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然关系型数据库非常成熟且灵活，并且被用于非常不同的场景，但存在两个主要问题难以处理。一个是需要预定义的模式，正如我们上面所说的。另一个，在达到一定规模后更为严重，是处理扩展性问题。关系型数据库被认为是一个中心访问点，一旦达到垂直扩展的极限，就需要一些技术来扩展。
- en: We will talk about specific techniques to deal with this issue and increase
    the scalability of relational databases later in this chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论处理此问题并提高关系型数据库可扩展性的具体技术。
- en: Non-relational databases
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非关系型数据库
- en: Non-relational databases are a diverse group of DBMSes that do not fit into
    the relational paradigm.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 非关系型数据库是一组多样化的数据库管理系统，它们不符合关系型范式。
- en: Non-relational databases are also called NoSQL, emphasizing the relational nature
    of the SQL language, standing for either "not SQL" or "Not Only SQL," to be more
    reflective of adding possibilities and not removing them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 非关系型数据库也被称为NoSQL，强调SQL语言的关联性质，代表“非SQL”或“不仅SQL”，以更准确地反映增加可能性而不是移除它们。
- en: While there have been non-relational databases even before the introduction
    of relational databases and alongside them, since the 2000s, there has been an
    introduction or recovery of methods and designs that look to alternative options.
    Most of them aim to address the two main weak spots in relational databases, their strictness
    and scalability issues.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系型数据库引入之前甚至与之并行，自2000年代以来，已经引入或恢复了旨在寻找替代方案的方法和设计。大多数它们旨在解决关系型数据库的两个主要弱点，即严格性和可扩展性问题。
- en: 'They are very varied and have very different structures, but the most common
    kinds of non-relational systems are the following groups:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 它们非常多样，结构也各不相同，但最常见的非关系型系统类型如下几组：
- en: Key-value stores
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键值存储
- en: Document stores
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档存储
- en: Wide-column databases
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宽列数据库
- en: Graph databases
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图数据库
- en: Let's describe each of them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述每一个。
- en: Key-value stores
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 键值存储
- en: Key-value stores are arguably the simplest of all databases in terms of functionality.
    They define a single key that stores a value. The value is totally opaque to the
    system, not being able to be queried in any way. There's even, in some implementations,
    no way of querying keys in the system; instead, they need to be an input to any
    operation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 键值存储在功能上可以说是所有数据库中最简单的。它们定义了一个存储值的单一键。值对系统来说是完全透明的，无法以任何方式查询。在某些实现中，甚至没有查询系统中的键的方法；相反，它们需要成为任何操作的输入。
- en: This is very similar to a hash table or dictionary but on a bigger scale. Cache
    systems are normally based on this kind of data store.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这与哈希表或字典非常相似，但规模更大。缓存系统通常基于这种类型的数据存储。
- en: While the technology is similar, there's an important differentiation between
    a cache and a database. A cache is a system that stores data already calculated
    to speed up its retrieval, while a database stores raw data. If the data is not
    in the cache, it can be retrieved from a different system, but if it's not in
    the database, either the data is not stored or there has been a big problem.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然该技术与数据库相似，但缓存和数据库之间存在一个重要的区别。缓存是一个存储已计算数据以加快检索速度的系统，而数据库存储原始数据。如果数据不在缓存中，可以从不同的系统检索，但如果数据不在数据库中，要么数据未存储，要么出现了大问题。
- en: That's why cache systems tend to store information only in memory and are more
    resilient to restarts or problems, making them easier to deal with. If a cache
    is missing, the system works, just slower.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么缓存系统倾向于仅在内存中存储信息，并且对重启或问题更具弹性，这使得它们更容易处理。如果缓存缺失，系统仍然可以工作，只是速度较慢。
- en: It's very important that information is not ultimately stored in cache systems
    that are not backed up by proper storage. It's a mistake that sometimes happens
    inadvertently, for example, with temporal data, but the risk is to get a problem
    at the wrong time and lose the data, so be aware of it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 信息最终不应存储在缺乏适当存储支持的缓存系统中，这是有时无意中犯下的错误，例如在处理时间数据时，但风险是在错误的时间遇到问题并丢失数据，因此要对此保持警觉。
- en: The main advantage of this system is, on the one hand, the simplicity of it,
    allowing the quick storage and retrieval of data. It also allows you to horizontally
    scale to a great extent. As each key is independent of the rest, they can even
    be stored in different servers. Redundancy can also be introduced in the system,
    making multiple copies for each key and value, though this makes the retrieval
    of information slower, as the multiple copies need to be compared to detect data
    corruption.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统的主要优势在于其简单性，一方面允许快速存储和检索数据。它还允许你水平扩展到很大程度。由于每个键与其他键独立，它们甚至可以存储在不同的服务器上。系统还可以引入冗余，为每个键和值创建多个副本，尽管这会使信息检索变慢，因为需要比较多个副本以检测数据损坏。
- en: Some examples of key-value databases are **Riak** and **Redis** (if used with
    durability enabled).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一些键值数据库的例子是 **Riak** 和 **Redis**（如果启用了持久性）。
- en: Document stores
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档存储
- en: Document stores revolve around the concept of a "document," which is similar
    to a "record" in relational databases. Documents, though, are more flexible, as
    they don't need to follow a predefined format. They also typically allow embedding
    more data in subfields, something that relational databases normally don't do,
    relying instead on creating a relationship and storing that data in a different
    table.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 文档存储围绕“文档”这一概念展开，这与关系数据库中的“记录”类似。然而，文档更加灵活，因为它们不需要遵循预定义的格式。它们通常还允许在子字段中嵌入更多数据，这是关系数据库通常不做的，而是通过创建关系并将数据存储在不同的表中。
- en: 'For example, a document can look like this, here represented as JSON:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个文档可以看起来像这样，这里以 JSON 格式表示：
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Documents are normally grouped in collections, which are similar to "tables."
    Normally documents are retrieved by a unique ID that acts as the primary key,
    but queries can also be constructed to search fields created in the document.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 文档通常按集合分组，类似于“表”。通常通过一个唯一的 ID 来检索文档，该 ID 作为主键，但也可以构建查询以搜索文档中创建的字段。
- en: So, in our case, we could retrieve the key (ID) `ABCDEFG`, like in a key-value
    store; or make richer queries like "get me all entries in the `detectives` collection
    whose `address.country` equals `UK`," for example.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的情况下，我们可以检索键（ID）`ABCDEFG`，就像在键值存储中一样；或者进行更丰富的查询，例如“获取所有在`detectives`集合中且`address.country`等于`UK`的条目”，例如。
- en: Keep in mind that, while it is technically possible to create a collection with
    documents totally independent and with different formats, in practice, all documents
    in a collection will follow a somewhat *similar* format, with optional fields
    or embedded data.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，虽然从技术上讲，可以创建一个包含完全独立且格式不同的文档的集合，但在实践中，一个集合中的所有文档都将遵循某种*相似*的格式，包括可选字段或嵌入数据。
- en: Documents in one collection can be related to documents in another collection
    by their ID, creating a reference, but normally these databases don't allow you
    to create join queries. Instead, the application layer should allow you to retrieve
    this linked information.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一个集合中的文档可以通过其 ID 与另一个集合中的文档相关联，创建一个引用，但通常这些数据库不允许你创建连接查询。相反，应用层应该允许你检索这些链接信息。
- en: In general, documents favor embedding information over creating references.
    This could lead to denormalizing information, repeating the information in several
    places. We will talk more about denormalization later in the chapter.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，文档倾向于嵌入信息而不是创建引用。这可能导致信息去规范化，在多个地方重复信息。我们将在本章后面更多地讨论去规范化。
- en: Some examples of document stores are **MongoDB** ([https://www.mongodb.com/](https://www.mongodb.com/))
    and **Elasticsearch** ([https://www.elastic.co/elasticsearch/](https://www.elastic.co/elasticsearch/)).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一些文档存储的例子是 **MongoDB** ([https://www.mongodb.com/](https://www.mongodb.com/))
    和 **Elasticsearch** ([https://www.elastic.co/elasticsearch/](https://www.elastic.co/elasticsearch/))。
- en: Wide-column databases
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 宽列数据库
- en: Wide-column databases are structured with their data separated by columns. They
    create tables with certain columns, but they are optional. They also can't natively
    relate a record in one table with another.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 宽列数据库通过列来组织数据。它们创建具有特定列的表，但这些列是可选的。它们也无法原生地将一个表中的记录与另一个表中的记录相关联。
- en: They are a bit more capable of being queried than pure key-value stores but
    require more upfront design work on what kinds of queries are possible in the
    system. This is more restrictive than in document-oriented stores where there
    is more flexibility in doing that after the design is done.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 它们比纯键值存储更易于查询，但需要对系统中的可能查询类型进行更多前期设计工作。这比在文档存储中更为限制性，在文档设计完成后，文档存储在这方面有更大的灵活性。
- en: Normally, columns are related and can only be queried in a particular order,
    meaning that if columns A, B, and C exist, a row can query based on either A,
    A and B, or A, B, and C, but not just C or B and C, for example.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，列是相关的，并且只能按特定顺序查询，这意味着如果存在列A、B和C，则一行可以基于A、A和B或A、B和C进行查询，但不能仅基于C或B和C，例如。
- en: They are aimed at very big database deployments with high availability and replicated
    data. Some examples of wide-column databases are **Apache Cassandra** ([https://cassandra.apache.org/](https://cassandra.apache.org/))
    and Google's **Bigtable** ([https://cloud.google.com/bigtable](https://cloud.google.com/bigtable)).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 它们旨在针对具有高可用性和复制数据的非常大的数据库部署。一些宽列数据库的例子包括**Apache Cassandra** ([https://cassandra.apache.org/](https://cassandra.apache.org/))和谷歌的**Bigtable**
    ([https://cloud.google.com/bigtable](https://cloud.google.com/bigtable))。
- en: Graph databases
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图数据库
- en: While the previous non-relational databases are based on giving up the ability
    to create relationships between elements to gain other features (like scalability
    or flexibility), graph databases go in the opposite direction. They greatly enhance
    the relationship aspect of the elements to create complex graphs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然之前的非关系型数据库是基于放弃元素之间创建关系的能力以获得其他功能（如可扩展性或灵活性），但图数据库则走向了相反的方向。它们极大地增强了元素的关系方面，以创建复杂的图。
- en: They store objects that are nodes and edges, or relationships between the nodes.
    Both edges and nodes may have properties to better describe them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 它们存储节点和边或节点之间的关系对象。边和节点都可以有属性来更好地描述它们。
- en: The query capabilities of graph databases are aimed at retrieving information
    based on relationships. For example, given a list of companies and providers,
    is there any provider in a supply chain of a specific company that is in a specific
    country? Up to how many levels? These questions may be easy to answer for the
    first level in a relational database (obtain the suppliers of the company and
    their countries), but quite complex and consuming for the third-level relations.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图数据库的查询能力旨在根据关系检索信息。例如，给定一家公司及其供应商的列表，是否存在任何特定国家的特定公司的供应链中的供应商？达到多少层级？这些问题对于关系数据库的第一层级可能很容易回答（获取公司的供应商及其国家），但对于第三层级的关系来说则相当复杂且耗时。
- en: '![Diagram'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图示'
- en: Description automatically generated](img/B17580_03_01.png)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_03_01.png)
- en: 'Figure 3.1: Example of data that is typical of graph databases'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：图数据库中典型数据的示例
- en: They are typically used for social graphs, where there are connections between
    people or organizations. Some examples are **Neo4j** ([https://neo4j.com/](https://neo4j.com/))
    or **ArangoDB** ([https://www.arangodb.com/](https://www.arangodb.com/)).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 它们通常用于社交图，其中存在人与人或组织之间的连接。一些例子包括**Neo4j** ([https://neo4j.com/](https://neo4j.com/))或**ArangoDB**
    ([https://www.arangodb.com/](https://www.arangodb.com/))。
- en: Small databases
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小型数据库
- en: This group is a bit special compared with the rest. It's composed of database
    systems that are not differentiated as an independent process, working as an independent
    client-server structure. Instead, they are embedded into the code of the application,
    reading directly from the hard drive. They are normally used in simple applications
    that run as a single process and want to keep the information in a structured
    way.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他数据库相比，这一组有点特别。它由不作为独立进程区分的数据库系统组成，作为独立的客户端-服务器结构运行。相反，它们嵌入到应用程序的代码中，直接从硬盘读取。它们通常用于作为单个进程运行且希望以结构化方式保存信息的简单应用程序。
- en: A crude, yet effective, way of representing this method is to save information
    as a JSON object into a file and recover it when required, for example, client
    settings for a smartphone app. The settings file is loaded when the application
    starts from memory, then saved if there's any change.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 表示此方法的一种粗略但有效的方式是将信息作为JSON对象保存到文件中，并在需要时恢复，例如智能手机应用程序的客户设置。设置文件在应用程序启动时从内存中加载，如果有任何更改则保存。
- en: 'For example, in Python code, this could be represented like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Python代码中，这可以表示如下：
- en: '[PRE1]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For small amounts of data, this structure may work, but it has the limitation
    that it's difficult to query. The most complete alternative is SQLite, which is
    a full-fledged SQL database, but it's embedded into the system, without requiring
    external calls. The database is stored in a binary file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于少量数据，这种结构可能适用，但它有一个限制，那就是查询起来比较困难。最完整的替代方案是SQLite，它是一个完整的SQL数据库，但它被嵌入到系统中，无需外部调用。数据库存储在一个二进制文件中。
- en: SQLite is so popular that it's even supported in a lot of standard libraries,
    without requiring an external module, for example, in the Python standard library.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite非常流行，以至于它甚至被许多标准库支持，无需外部模块，例如，在Python标准库中。
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This module follows the DB-API 2.0 standard, which is the Python standard to
    connect to databases. It aims to standardize access to different database backends.
    This makes it easy to create a higher-level module that can access multiple SQL
    databases and swap them with minimal changes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块遵循DB-API 2.0标准，这是连接到数据库的Python标准。它的目标是标准化对不同数据库后端的访问。这使得创建一个可以访问多个SQL数据库并可以最小化更改进行交换的高级模块变得容易。
- en: 'You can check the full DB-API 2.0 specification in PEP-249: [https://www.python.org/dev/peps/pep-0249/](https://www.python.org/dev/peps/pep-0249/).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在PEP-249中查看完整的DB-API 2.0规范：[https://www.python.org/dev/peps/pep-0249/](https://www.python.org/dev/peps/pep-0249/)。
- en: SQLite implements most of the SQL standard.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite实现了大部分SQL标准。
- en: Database transactions
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库事务
- en: Storing data can be a complex operation internally for a database. In some cases,
    it can include changing the data in a single place, but there are operations that
    can affect millions of records in a single operation, for example, "update all
    records created before this timestamp."
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据库来说，存储数据可能是一个复杂的内部操作。在某些情况下，它可能包括在单个位置更改数据，但有一些操作可以在单个操作中影响数百万条记录，例如，“更新在此时间戳之前创建的所有记录”。
- en: How broad and possible these operations are highly depends on the database,
    but they are very similar to relational databases. In that case, normally there's
    the concept of a *transaction*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作的范围和可能性在很大程度上取决于数据库，但它们与关系数据库非常相似。在这种情况下，通常有*事务*的概念。
- en: A transaction is an operation that happens in one go. It either happens or it
    doesn't, but the database is not left in an inconsistent state in the middle.
    For example, if the operation described before of "update all records created
    before this timestamp" can produce an effect where, through an error, only half
    of the records are changed, then it's not a transaction, but multiple independent
    operations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 事务是一次性发生的操作。要么发生，要么不发生，但数据库不会处于中间的不一致状态。例如，如果之前描述的“更新在此时间戳之前创建的所有记录”的操作可能会产生一个效果，即通过错误，只有一半的记录被更改，那么它不是一个事务，而是多个独立的操作。
- en: It can happen that there's an error in the middle of a transaction. In that
    case, it will go back all the way to the start of it, so no record will change.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在事务中间可能会出现错误。在这种情况下，它将回滚到开始处，因此没有任何记录会更改。
- en: This characteristic can become a strong requirement for the database in some
    applications, and it's called *atomicity*. That means the transaction is atomic
    when it's applied. This characteristic is the main one of the so-called ACID properties.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些应用中，这种特性可能成为对数据库的强烈要求，这被称为*原子性*。这意味着当它被应用时，事务是原子的。这种特性是所谓的ACID属性的主要特性。
- en: 'The other properties are consistency, isolation, and durability. The four properties
    are, then:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 其他属性是一致性、隔离性和持久性。这四个属性是：
- en: '*Atomicity*, which means that the transaction is applied as one unit. It is
    either applied completely or not.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*原子性*，意味着事务作为一个单元应用。要么完全应用，要么不应用。'
- en: '*Consistency*, which means that the transaction is applied taking into account
    all restrictions that are defined in the database. For example, foreign key constraints
    are respected, or any stored triggers that modify the data applied.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一致性*，意味着事务在应用时考虑到数据库中定义的所有限制。例如，外键约束得到尊重，或者任何修改数据的存储触发器。'
- en: '*Isolation*, which means that parallel transactions work in the same way that
    they were run one after the other, ensuring that one transaction is not affecting
    another. Obviously, the exception is the order in which they are run, which may
    have an impact.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*隔离性*，意味着并行事务以相同的方式运行，就像它们一个接一个地运行一样，确保一个事务不会影响另一个。显然，它们的运行顺序可能会有影响。'
- en: '*Durability*, which means that, after a transaction is reported as completed,
    it won''t be lost even in the event of a catastrophic failure, like the database
    process crashing.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*持久性*，这意味着在事务报告为完成后，即使在灾难性故障（如数据库进程崩溃）的情况下也不会丢失。'
- en: These properties are the gold standard to take care of data. It means that the
    data is safe and consistent.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性是处理数据的黄金标准。这意味着数据是安全和一致的。
- en: Most relational databases have the concept of starting a transaction, performing
    several operations, and then finally committing the transaction so all the changes
    are applied in one go. If there's a problem, the transaction will fail, reverting
    to the previous state. A transaction can also be aborted if, during the performance
    of operations, any problem, like a constraint issue, is detected.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数关系型数据库都有开始事务、执行多个操作，然后最终提交事务的概念，这样所有更改都可以一次性应用。如果出现问题，事务将失败，回滚到之前的状态。如果在执行操作期间检测到任何问题，如约束问题，事务也可以被中止。
- en: This way of operating allows creating extra verification steps, as inside the
    transaction, data can still be queried and be validated before finally committing
    it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操作方式允许创建额外的验证步骤，因为在事务内部，数据仍然可以被查询并在最终提交之前进行验证。
- en: ACID transactions have a cost in terms of performance, and especially in terms
    of scalability. The need for durability means that data needs to be stored on
    disk or other permanent support before being returned from the transaction. The
    requirement for isolation means that each open transaction requires operating
    in a way that it can't see new updates, which may require temporary data to be
    stored until the transaction is completed. Consistency also requires checks to
    ensure that all constraints are fulfilled, which may require complex checks.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ACID事务在性能方面有成本，尤其是在可扩展性方面。持久性的需求意味着数据需要在事务返回之前存储在磁盘或其他永久性支持上。隔离性的需求意味着每个打开的事务都需要以某种方式操作，使其无法看到新的更新，这可能需要存储临时数据直到事务完成。一致性还要求检查以确保所有约束都得到满足，这可能需要复杂的检查。
- en: Virtually all relational databases are fully ACID compliant, and that has become
    a defining characteristic of them. In the non-relational world, things are more
    flexible.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有关系型数据库都是完全ACID兼容的，这已经成为它们的定义特征。在非关系型世界中，事情更加灵活。
- en: Scaling the database with multiple servers or nodes with these properties proves
    difficult, though. This system creates distributed transactions, running on multiple
    servers at the same time. Maintaining full ACID transactions in databases with
    more than one server is extremely difficult, and has a heavy penalty in terms
    of performance, because of the extra delay caused by understanding what the other
    nodes have done and rolling back the transaction if there's a failure in any of
    them. The problems also increase in a non-linear way, sort of working against
    the advantages of having multiple servers.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用具有这些特性的多个服务器或节点扩展数据库很困难。这个系统创建了分布式事务，同时在多个服务器上运行。在具有多个服务器的数据库中维护完整的ACID事务非常困难，并且在性能方面有沉重的代价，因为理解其他节点所做的工作以及在它们中的任何一个出现故障时回滚事务的额外延迟。问题也会以非线性方式增加，某种程度上抵消了拥有多个服务器的优势。
- en: While this is possible, a lot of applications can work around these limitations.
    We will see some useful patterns.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是可能的，但许多应用程序可以绕过这些限制。我们将看到一些有用的模式。
- en: Distributed relational databases
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式关系型数据库
- en: As we've discussed before, relational databases weren't designed with scalability
    in mind. They are great for enforcing strong data assurances, including ACID transactions,
    but their preferred way of operating is through a single server.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，关系型数据库并不是为了可扩展性而设计的。它们在强制执行强大的数据保证方面很出色，包括ACID事务，但它们首选的操作方式是通过单个服务器。
- en: This can impose limitations in terms of how big an application can be using
    relational databases.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会对使用关系型数据库的应用程序的大小施加限制。
- en: It is worth noting that a database server can grow vertically, which means using
    better hardware. Increasing the capacity of a server or replacing it with a bigger
    one is an easier solution for high demand than applying some of these techniques,
    but there's a limit. In any case, please double-check that the expected size is
    big enough. These days, there are servers in cloud providers that reach 1 terabyte
    of RAM or more. That's enough to cover a huge number of cases.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，数据库服务器可以垂直扩展，这意味着使用更好的硬件。增加服务器容量或用更大的服务器替换它，对于高需求来说，比应用这些技术要容易，但有一个限制。无论如何，请确保预期的尺寸足够大。如今，云服务提供商的某些服务器内存达到1TB或更多。这足以覆盖大量情况。
- en: Note that these techniques are useful to grow a system after it is up and running,
    and can be added to most usages of relational databases.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些技术在系统运行后扩展系统时很有用，并且可以添加到大多数关系型数据库的使用中。
- en: The disadvantage of the ACID properties is *eventual consistency*. Instead of
    an atomic operation that gets processed in a single go, the system gradually translates
    to the desired system. Not every part of the system has the same state at the
    same time. Instead, there are certain delays while this change is propagating
    in the system. The other big advantage is that we can increase the availability,
    as it won't depend on a single node to make the change, and any non-available
    elements will catch up after recovering. Because of the distributed nature of
    the cluster, this may involve consulting different sources and trying to reach
    a quorum between them.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ACID属性的不利之处在于*最终一致性*。不是一次性处理的原子操作，系统逐渐转换为所需的系统。系统不是所有部分同时处于相同状态。相反，在系统传播这个变化的过程中会有一定的延迟。另一个大优点是我们可以提高可用性，因为它不会依赖于单个节点来做出更改，任何不可用的元素在恢复后会赶上。由于集群的分布式特性，这可能涉及咨询不同的来源并试图在它们之间达到共识。
- en: It depends greatly on the application you have in mind when considering if loosening
    some of the ACID properties is worth doing. Critical data, where a delay or data
    corruption has a higher impact and may not be acceptable, may not be a good fit
    for a distributed database.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑是否放宽一些ACID属性是否值得做时，很大程度上取决于你心中的应用程序。对于延迟或数据损坏影响较大且可能不可接受的关键数据，可能不适合分布式数据库。
- en: In order to increase the capacity, the first thing is to understand what the
    data access of the application is.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加容量，首先要了解应用程序的数据访问方式。
- en: Primary/replica
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主/副本
- en: A very common case is that the number of reads is much higher than writes. Or,
    talking in SQL terms, the number of `SELECT` statements is much higher than the
    `UPDATE` or `DELETE` ones. This is very typical of applications where there's
    way more access to information than updates to information, for example, a newspaper,
    where there's a lot of access to read a news article, but not so many new articles
    comparatively.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的例子是读取次数远高于写入次数。或者用SQL术语来说，`SELECT`语句的数量远高于`UPDATE`或`DELETE`语句的数量。这在信息访问远多于信息更新的应用程序中非常典型，例如，报纸，阅读新闻文章的访问量很大，但相比之下新文章不多。
- en: 'A common pattern for this situation is to create a cluster adding one or more
    read-only copies of the database, and then spread the reads across them, a situation
    similar to this one:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，一个常见的模式是创建一个集群，添加一个或多个数据库只读副本，然后在这些副本之间分配读取，这种情况类似于以下：
- en: '![Diagram'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图示'
- en: Description automatically generated](img/B17580_03_02.png)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_03_02.png)
- en: 'Figure 3.2: Dealing with multiple Read queries'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：处理多个读取查询
- en: All the writes go to the primary node, and then that gets disseminated to the
    replica nodes automatically. Because the replicas contain the whole database,
    and the only write activity comes from the primary, this increases the number
    of queries that can run at the same time in the system.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所有写入都发送到主节点，然后自动传播到副本节点。因为副本包含整个数据库，唯一的写入活动来自主节点，这增加了系统中可以同时运行的查询数量。
- en: This system is natively supported by most relational databases, especially the
    most common ones, MySQL and PostgreSQL. The write nodes are configured as primary,
    and the replicas are pointed at the primary to start copying the data. After some
    time, they'll be up to date and in sync with the primary.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统由大多数关系型数据库原生支持，尤其是最常见的MySQL和PostgreSQL。写入节点配置为主节点，副本节点指向主节点以开始复制数据。经过一段时间，它们将更新并同步到主节点。
- en: Every new change in the primary will be replicated automatically. This, though,
    has a delay, called a replication lag. This means that the data just written won't
    be available to read for some time, typically less than a second.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 主服务器上的每个新更改都会自动复制。然而，这有一个延迟，称为复制延迟。这意味着刚刚写入的数据在一段时间内不可读，通常不到一秒。
- en: Replication lag is a good indicator of the wellbeing of the database. If the
    lag increases over time, it's an indication that the cluster is not capable of
    handling the level of traffic and requires adjustments. This time will be greatly
    influenced by the network and general performance of each of the nodes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 复制延迟是数据库健康状态的良好指标。如果延迟随时间增加，这表明集群无法处理当前流量水平，需要调整。这个时间将受到每个节点网络和总体性能的极大影响。
- en: An operation to avoid, then, is to write and immediately read the same or related
    data in an external operation, as this can cause inconsistent results. This can
    be solved either by keeping the data temporarily, avoiding the need for the query,
    or by making it possible to address a specific read to the primary node, to ensure
    that the data is consistent.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要避免的操作是在外部操作中立即写入和读取相同或相关数据，因为这可能导致不一致的结果。这可以通过暂时保留数据以避免查询需求，或者通过使特定读取指向主节点以确保数据一致性来解决。
- en: These direct reads should be used only when necessary, as they go against the
    idea of reducing the number of queries to the primary server. That was the reason
    to set up multiple servers!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些直接读取仅在必要时使用，因为它们违反了减少主服务器查询数量的理念。这正是设置多个服务器的原因！
- en: '![Diagram, schematic'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图，示意图'
- en: Description automatically generated](img/B17580_03_03.png)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_03_03.png)
- en: 'Figure 3.3: A specific Read query on the primary node'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：对主节点上的特定读取查询
- en: This system also allows there to be redundancy of data, as it's always being
    copied to the replicas. If there's a problem, a replica can be promoted to be
    the new primary.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此系统还允许数据冗余，因为数据始终被复制到副本中。如果出现问题，可以将副本提升为新的主服务器。
- en: A replica server doesn't fulfill exactly the same role as a backup, though it
    can be used with a similar intent. A replica is intended to perform a quick action
    and maintain the availability of the system. Backups are easier and cheaper to
    run and allow you to keep a historical record of the data. Backups can also be
    located in a very different location than the replica, while a replica requires
    a good network connection with the primary.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 副本服务器并不完全履行与备份相同的角色，尽管它可以用于类似的目的。副本旨在执行快速操作并保持系统的可用性。备份更容易且成本更低，允许您保留数据的历史记录。备份也可以位于与副本非常不同的位置，而副本需要与主服务器有良好的网络连接。
- en: Do not skip doing backups, even if there are replicas available. Backups will
    add a security layer in case of catastrophic failure.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有副本可用，也不要跳过备份。备份可以在灾难性故障的情况下增加一层安全防护。
- en: Note that this way of structuring the database may require adapting the application
    level to be aware of all the changes and access to different database servers.
    There are existing tools such as Pgpool (for PostgreSQL) or ProxySQL (for MySQL)
    that stay in the middle of the path and redirect the queries. The application
    addresses the queries to the proxies, and then the proxy redirects them based
    on the configuration. There are cases, like the write and read pattern that we've
    seen above, that are not covered easily and may require specific changes in the
    application code. Be sure to understand how these kinds of tools work and run
    some tests before running them in your application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种数据库结构方式可能需要调整应用层以了解所有更改并访问不同的数据库服务器。存在一些现有工具，如Pgpool（用于PostgreSQL）或ProxySQL（用于MySQL），它们位于路径中间并重定向查询。应用将查询发送到代理，然后代理根据配置重定向它们。有些情况，如我们上面看到的读写模式，不容易覆盖，可能需要在应用代码中进行特定更改。在使用这些工具之前，请确保理解它们的工作原理并对其进行一些测试。
- en: A simpler case of this structure is to create offline replicas. These can be
    created from a backup and not updated from the live system. These replicas can
    be useful to create queries that don't require up-to-date information, in cases
    where perhaps a daily snapshot is good enough. They are common in applications
    like statistical analysis or data warehousing.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构的简单案例是创建离线副本。这些副本可以从备份中创建，并且不更新来自实时系统。这些副本可以用于创建不需要最新信息的查询，在可能的情况下，每日快照就足够了。它们在统计分析或数据仓库等应用中很常见。
- en: Sharding
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分片
- en: If the application has a higher number of writes, the primary-replica structure
    may not be good enough. Too many writes are directed to the same server, which
    creates a bottleneck. Or if the system traffic grows enough, there's a limit to
    the number of writes that a single server can accept.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序的写入次数较多，主从结构可能不够好。太多的写入都指向同一个服务器，这会形成瓶颈。或者如果系统流量增长足够大，单个服务器可以接受的写入次数将有限。
- en: A possible solution is to horizontally partition the data. This means dividing
    the data into different databases according to a specific key, so all related
    data can go to the same server. Each of the different partitions is called a shard.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是将数据水平分区。这意味着根据特定的键将数据分割到不同的数据库中，这样所有相关数据都可以发送到同一个服务器。每个不同的分区被称为分片。
- en: Note that "partitioning" and "sharding" can be considered synonyms, though in
    reality sharding is only if the partition is horizontal, separating a single table
    into different servers. Partitioning can be more general, like dividing a table
    into two, or splitting into different columns, which is not typically called sharding.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，“分区”和“分片”可以被认为是同义词，尽管在现实中，分片只有在分区是水平的时候才存在，即把单个表分割到不同的服务器上。分区可以更通用，比如把一个表分成两个，或者分割到不同的列，这通常不被称为分片。
- en: The partition key is called the shard key, and based on its value, each row
    will be allocated a specific shard.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 分区键被称为分片键，根据其值，每一行都会被分配到特定的分片。
- en: '![Diagram'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图'
- en: Description automatically generated](img/B17580_03_04.png)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_03_04.png)
- en: 'Figure 3.4: Shard keys'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：分片键
- en: The name *shard* comes from the videogame Ultima Online, which, in the late
    90s, used this strategy to create a "multiverse" where different players could
    play the same game on different servers. They called them "shards," as they were
    aspects of the same reality, but contained different players in them. The name
    stuck and it's still used to describe the architecture.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: “分片”这个名字来源于电子游戏《Ultima Online》，在20世纪90年代末，该游戏使用这种策略创建了一个“多元宇宙”，不同的玩家可以在不同的服务器上玩同样的游戏。他们称之为“分片”，因为它们是同一现实的不同方面，但其中包含了不同的玩家。这个名字一直沿用至今，现在仍用来描述这种架构。
- en: Any query needs to be able to determine what the proper shard is to be applied
    to. Any query that affects two or more shards may be impossible to do or can only
    be performed in succession. Of course, this excludes the possibility of performing
    these queries in a single transaction. In any case, these operations will be very
    expensive, and should be avoided as much as possible. Sharding is a fantastic
    idea when the data is naturally partitioned, and very bad when queries affecting
    multiple shards are performed.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 任何查询都需要能够确定要应用的正确分片。任何影响两个或更多分片的查询可能无法执行，或者只能依次执行。当然，这排除了在单个事务中执行这些查询的可能性。在任何情况下，这些操作都将非常昂贵，应尽可能避免。当数据自然分区时，分片是一个极好的想法，而当执行影响多个分片的查询时，分片就非常糟糕。
- en: Some NoSQL databases allow native sharding that will take care of all these
    options automatically. A common example is MongoDB, which is even capable of running
    queries in multiple shards in a transparent manner. These queries will be slow,
    in any case.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一些NoSQL数据库允许原生分片，这将自动处理所有这些选项。一个常见的例子是MongoDB，它甚至能够在多个分片中透明地运行查询。无论如何，这些查询都会很慢。
- en: The choosing of the sharding key is also crucial. A good key should follow natural
    partitions between data, so performing cross-shard queries is not required. For
    example, if the data of a user is independent of the rest, which may happen with
    a photo-sharing application, the user identifier could be a good shard key.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 选择分片键也非常关键。一个好的键应该遵循数据之间的自然分区，这样就不需要执行跨分片查询。例如，如果某个用户的数据与其他数据独立，这在照片分享应用中可能发生，那么用户标识符可以是一个好的分片键。
- en: Another important quality is that the shard to address the query needs to be
    determined based on the shard key. That means that every query needs to have the
    shard key available. This means that the shard key should be an input of every
    operation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的特性是，需要根据分片键确定要解决查询的分片。这意味着每个查询都需要有分片键可用。这意味着分片键应该是每个操作的输入。
- en: Another property of the shard key is that the data should be ideally portioned
    in a way that shards have the same size, or at least they are similar enough.
    If one shard is much bigger than the rest, that could lead to problems of imbalanced
    data, not enough distributing of the queries, and having one shard being the bottleneck.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 分片键的另一个特性是，数据应该理想地分割成分片大小相同，或者至少相似到足够程度。如果一个分片比其他分片大得多，可能会导致数据不平衡的问题、查询分布不足，以及一个分片成为瓶颈。
- en: Pure sharding
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纯分片
- en: On pure shards, the data is all partitioned in shards and the shard key is an
    input of every operation. The shard is determined based on the shard key.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯分片中，数据全部分区在分片中，分片键是每个操作的输入。分片是根据分片键确定的。
- en: To ensure that the shards are balanced, each key is hashed in a way that is
    equally distributed between the number of shards. A typical case is to use a modulo
    operation, for example. If we have 8 shards, we determine which shard the data
    is partitioned into based on a number that's equally distributed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保分片平衡，每个键都通过一种方式散列，使得它们在分片数量之间均匀分布。一个典型的例子是使用取模操作，例如。如果我们有8个分片，我们根据一个均匀分布的数字来确定数据分区的分片。
- en: '| User ID | Operation | Shard |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 用户ID | 操作 | 分片 |'
- en: '| 1234 | 1234 mod 8 | 2 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 1234 | 1234 mod 8 | 2 |'
- en: '| 2347 | 2347 mod 8 | 3 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 2347 | 2347 mod 8 | 3 |'
- en: '| 7645 | 7645 mod 8 | 5 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 7645 | 7645 mod 8 | 5 |'
- en: '| 1235 | 1235 mod 8 | 3 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 1235 | 1235 mod 8 | 3 |'
- en: '| 4356 | 4356 mod 8 | 4 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 4356 | 4356 mod 8 | 4 |'
- en: '| 2345 | 2345 mod 8 | 1 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 2345 | 2345 mod 8 | 1 |'
- en: '| 2344 | 2344 mod 8 | 0 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 2344 | 2344 mod 8 | 0 |'
- en: 'If the shard key is not a number, or if it''s not evenly distributed, a hash
    function can be applied. For example, in Python:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分片键不是一个数字，或者它分布不均匀，可以应用一个哈希函数。例如，在Python中：
- en: '[PRE3]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This strategy is only possible if the shard key is **always** available as input
    for every operation. When this is not an option, we need to look at other options.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略仅在分片键**始终**作为每个操作的输入可用时才可行。当这不是一个选项时，我们需要考虑其他选项。
- en: Changing the number of shards is not an easy task, as the destination for each
    key is decided by a fixed formula. It is possible, though, to grow or reduce the
    number of shards with some preparation in advance.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 改变分片数量不是一个容易的任务，因为每个键的目的是由一个固定的公式决定的。然而，通过提前做一些准备，是有可能增加或减少分片数量的。
- en: 'We can create "virtual shards" that point to the same server. For example,
    to create 100 shards, and use two servers, initially the virtual shard distribution
    will be like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建指向同一服务器的“虚拟分片”。例如，为了创建100个分片，并使用两个服务器，最初虚拟分片分布将如下所示：
- en: '| Virtual Shard | Server |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 虚拟分片 | 服务器 |'
- en: '| 0-49 | Server A |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 0-49 | 服务器A |'
- en: '| 50-99 | Server B |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 50-99 | 服务器B |'
- en: If the number of servers needs to be increased, the virtual shard structure
    will change in this way.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要增加服务器数量，虚拟分片结构将按这种方式改变。
- en: '| Virtual Shard | Server |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 虚拟分片 | 服务器 |'
- en: '| 0-24 | Server A |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 0-24 | 服务器A |'
- en: '| 25-49 | Server C |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 25-49 | 服务器C |'
- en: '| 50-74 | Server B |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 50-74 | 服务器B |'
- en: '| 75-99 | Server D |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 75-99 | 服务器D |'
- en: This change to the specific server that corresponds to each shard may require
    some code change, but it's easier to handle as the shard key calculation won't
    change. The same operation can be applied in reverse, though it may create imbalance,
    so it needs to be done with care.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这种更改对应于每个分片的具体服务器可能需要一些代码更改，但因为它不会改变分片键的计算，所以更容易处理。同样的操作可以反向应用，尽管它可能会造成不平衡，所以需要谨慎操作。
- en: '| Virtual Shard | Server |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 虚拟分片 | 服务器 |'
- en: '| 0-24 | Server A |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 0-24 | 服务器A |'
- en: '| 25-49 | Server C |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 25-49 | 服务器C |'
- en: '| 50-99 | Server B |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 50-99 | 服务器B |'
- en: Each of the operations requires changing the location of data based on the shard
    key. This is a costly operation, especially if a lot of data needs to be exchanged.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作都需要根据分片键更改数据的位置。这是一个昂贵的操作，尤其是当需要交换大量数据时。
- en: Mixed sharding
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混合分片
- en: Sometimes it is not possible to create pure shards and a translation from the
    input is required to determine the shard key. This is the case, for example, when
    a user is logging in if the shard key is the user ID. The user will log in using
    their email, but that needs to be translated to the user ID to be able to determine
    the shard to search the information.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有时无法创建纯分片，需要从输入进行转换以确定分片键。例如，当用户登录且分片键是用户ID时，就是这种情况。用户将使用他们的电子邮件登录，但需要将其转换为用户ID，以便能够确定要搜索信息的分片。
- en: In that case, an external table can be used purely to translate the input of
    a particular query to the shard key.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，可以使用外部表纯粹地翻译特定查询的输入到分片键。
- en: '![Diagram'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![图'
- en: Description automatically generated](img/B17580_03_05.png)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_03_05.png)
- en: 'Figure 3.5: External tables to translate the input of shard keys'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：外部表用于翻译分片键的输入
- en: This creates a situation where a single shard is responsible for this translation
    layer. This shard can be used exclusively for this, or also act as any other shard.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这会形成一个情况，即单个分片负责这个翻译层。这个分片可以专门用于此，也可以作为任何其他分片。
- en: Keep in mind that this requires a translation layer for each possible input
    parameter that's not directly the shard key, and that it requires keeping all
    the information of all shards in a single database. This needs to be kept under
    control and store as little information as possible, to avoid issues.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这需要对每个可能的输入参数都添加一个翻译层，这些参数不是直接的分片键，并且需要在一个数据库中保留所有分片的信息。这需要受到控制，并尽可能存储最少的信息，以避免问题。
- en: This strategy can be used as well to store, directly, what shard key goes to
    what shard, and perform a query instead of a direct operation, as we saw above.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略也可以用来直接存储哪个分片键对应哪个分片，并执行查询而不是直接操作，就像我们上面看到的。
- en: '![Diagram'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图'
- en: Description automatically generated](img/B17580_03_06.png)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_03_06.png)
- en: 'Figure 3.6: Storing shard keys to shards'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：将分片键存储到分片中
- en: This has the inconvenience that determining the shard based on the key requires
    a query in a database, especially with a big database. But it also allows changing
    the shard of the data in a consistent way, which can be used to adapt the number
    of shards, like growing or reducing the number. And it can be done without requiring
    downtime.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这的不便之处在于，根据键确定分片需要在一个数据库中进行查询，尤其是对于大型数据库。但它也允许以一致的方式更改数据分片，这可以用来调整分片数量，如增长或减少。而且可以在不要求停机的情况下完成。
- en: 'If the specific shard, not only the shard key, is stored in this translation
    table, the assignment of the shard to the key can be changed one by one, and in
    a continuous manner. The process will be approximately like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在翻译表中存储了特定的分片（而不仅仅是分片键），则可以逐个、连续地更改分片到键的分配。这个过程将大致如下：
- en: Shard key X is assigned to server A in the reference table. This is the start
    state.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分片键X在参考表中分配给服务器A。这是初始状态。
- en: Data from server A for shard key X is copied to server B. Note that no query
    involving shard key X is directed to server B yet.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器A为分片键X的数据已复制到服务器B。请注意，尚未将涉及分片键X的任何查询指向服务器B。
- en: Once all the data is copied, the entry for the reference table for shard key
    X is changed to server B.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有数据都已复制，分片键X的参考表条目将更改为服务器B。
- en: All queries for shard key X are directed to server B.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有针对分片键X的查询都指向服务器B。
- en: Data from shard key X in server A can be cleaned.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器A中分片键X的数据可以进行清理。
- en: '*Step 3* is the critical step, and needs to happen only after all the data
    is copied, and before any new write is performed. A way of ensuring this is to
    create a flag in the reference table that can stop or delay the writing of data
    while the operation is in place. This flag will be set up right before *step 2*
    and removed after *step 3* is completed.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*第3步*是关键步骤，必须在所有数据复制后、任何新写入操作之前发生。确保这一点的办法是在参考表中创建一个标志，在操作进行时可以停止或延迟数据的写入。这个标志将在*第2步*之前设置，并在*第3步*完成后移除。'
- en: This process will produce a smooth migration over time, but it requires enough
    space to work, and can take a significant amount of time.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程将在一段时间内产生平滑迁移，但它需要足够的空间来工作，并且可能需要相当长的时间。
- en: Downscale operations are more complicated than upscale, as the increase in space
    allows for ample room. Fortunately, it is rare that a database cluster needs to
    downscale, as most applications will grow over time.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 扩容操作比缩容操作更复杂，因为空间增加提供了充足的空间。幸运的是，数据库集群需要缩容的情况很少，因为大多数应用程序会随着时间的推移而增长。
- en: Please allow ample time to complete the migration. Depending on the size and
    complexity of the dataset, it can take a lot of time to migrate, up to hours or
    even days for extreme cases.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请留出足够的时间来完成迁移。根据数据集的大小和复杂性，迁移可能需要很长时间，极端情况下甚至可能需要数小时或数天。
- en: Table sharding
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表分片
- en: An alternative to sharding by shard key, for smaller clusters, is to separate
    tables or collections by server. This means that any query in table X is directed
    to a specific server, and the rest of the queries are directed to another. This
    strategy only works for unrelated tables, as it's not possible to perform joins
    between tables in different servers.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较小的集群，可以通过服务器来分离表或集合，作为按分片键分片的一种替代方案。这意味着对表X的任何查询都会被导向特定的服务器，而其他查询则导向另一个服务器。这种策略仅适用于无关的表，因为不同服务器上的表之间无法执行连接操作。
- en: Note that this can be considered, being pedantic, as not properly sharding,
    though the structure is similar.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这可以被认为是一种过于拘泥于细节的做法，因为它并不真正地实现了分片，尽管结构相似。
- en: This works as a less complicated alternative, but it's way less flexible. It's
    only recommended for relatively small clusters where there's a big imbalance in
    size between one or two tables and the rest, for example, if one table stores
    logs that are much bigger than the rest of the database and are sparingly accessed.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种较为简单的替代方案，但它的灵活性要低得多。它仅适用于相对较小的集群，其中一张或两张表与其他表的大小存在很大不均衡，例如，如果一张表存储的日志数据比数据库中的其他部分大得多，并且访问频率较低。
- en: Advantages and disadvantages of sharding
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分片的优势和劣势
- en: 'In summary, the main advantages of sharding are:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，分片的主要优势包括：
- en: Allows spreading writes over multiple servers, increasing the write throughput
    of the system
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许将写入分散到多个服务器上，从而提高系统的写入吞吐量。
- en: The data gets stored in multiple servers, so massive amounts of data can be
    stored, without limiting the data that can be stored in a single server
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储在多个服务器上，因此可以存储大量数据，而不会限制单个服务器上可以存储的数据量。
- en: 'In essence, sharding allows the creation of big, scalable systems. But it also
    has disadvantages:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，分片允许创建大型、可扩展的系统。但这也存在一些劣势：
- en: Sharded systems are more complicated to run and have some overhead in terms
    of configuring different servers, and so forth. While any big deployment will
    have its problems, sharding requires more work than a primary-replica setup, as
    the maintenance and operation need to be planned with more care and operations
    will take longer.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分片系统运行起来更复杂，并且在配置不同服务器等方面有一些开销。虽然任何大型部署都会遇到问题，但与主从设置相比，分片需要更多的工作，因为维护和操作需要更加细致的计划，操作也会更加耗时。
- en: Native support for sharding is available only in a small number of databases,
    like MongoDB, but relational databases don't have the feature implemented natively.
    This means that the complexity needs to be handled with ad hoc code, which will
    require an investment in developing it.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生支持分片仅在少数数据库中可用，例如MongoDB，但关系型数据库并没有原生实现这一功能。这意味着需要用专门的代码来处理复杂性，这将需要投入开发成本。
- en: Some queries will be impossible or almost impossible to do once the data is
    sharded. Aggregation and joins, depending on how the data is partitioned, won't
    be possible. The shard key needs to be selected carefully, as it will have a big
    implication on what queries are possible or not. We also lose the ACID properties,
    as some operations may need to involve more than one shard. A sharded database
    is less flexible.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦数据被分片，某些查询将变得不可能或几乎不可能执行。聚合和连接操作，取决于数据的分区方式，将无法执行。分片键需要仔细选择，因为它将对可能的查询产生重大影响。我们还会失去ACID属性，因为某些操作可能需要涉及多个分片。分片数据库的灵活性较低。
- en: As we've seen, designing, operating, and maintaining a sharded database only
    makes sense for very big systems, when the number of actions in the database requires
    such a complex system.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，设计、运营和维护分片数据库只适用于非常大的系统，当数据库中的操作数量需要如此复杂的系统时才有意义。
- en: Schema design
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式设计
- en: For databases that need to define a schema, the specific design to use is something
    that needs to be considered.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要定义模式的数据库，需要考虑使用特定的设计。
- en: This section will talk specifically about relational databases, as they are
    the ones that enforce a stricter schema. Other databases are more flexible in
    their changes, but they also benefit from spending some time thinking about their
    structure.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将具体讨论关系数据库，因为它们强制执行更严格的模式。其他数据库在更改方面更加灵活，但它们也受益于花时间思考其结构。
- en: Changing the schema is an important action that will require planning and, certainly,
    a long-term view needs to be applied to the design.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 更改模式是一个重要的操作，需要规划，并且当然，需要对设计采取长期视角。
- en: We will talk later in the chapter about how to change the schema of a database.
    We only need to remark here that mutating the database schema is an unavoidable
    part of the process of building a system. Nonetheless, it's a process that needs
    to be taken with respect and understanding what the possible problems are. It's
    definitely a good idea to spend time thinking about and ensuring an adequate design
    for the schema.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论如何更改数据库的模式。在此我们只需指出，更改数据库模式是构建系统过程中不可避免的一部分。尽管如此，这是一个需要尊重并理解可能问题的过程。确保模式设计足够合理，花时间思考和确保这一点绝对是个好主意。
- en: The best way to start the design of a schema is to draw the different tables,
    fields, and their relationships, if there are foreign keys pointing to other tables.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式的最好方式是绘制不同的表、字段及其关系，如果有外键指向其他表。
- en: '![Diagram'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图'
- en: Description automatically generated](img/B17580_03_07.png)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_03_07.png)
- en: 'Figure 3.7: Drawing a schema'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7：绘制模式
- en: The presentation of this data should allow you to detect possible blind spots
    or the repetition of elements. If the number of tables is too big, it may be necessary
    to divide it into several groups.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据的展示应允许你发现可能的盲点或元素的重复。如果表的数量太多，可能需要将其分成几个组。
- en: Though there are tools that can help with this work, personally, it helps me
    to hand-draw these relationships, as it helps me think of the different relationships
    and construct a mental image of the design.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有工具可以帮助完成这项工作，但就我个人而言，手动绘制这些关系有助于我思考不同的关系，并在脑海中构建设计图。
- en: 'Each of the tables can have foreign key relationships with others of different
    kinds:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 每个表都可以与其他不同类型的表有外键关系：
- en: '**One-to-many**, where a single reference is added for multiple elements of
    another table. For example, a single author is referenced in all their books.
    A simple foreign key relationship works in this case, as the Books table will
    have a foreign key to the entry in Authors. Multiple book rows can have a reference
    to the same author.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对多**，其中为另一个表中的多个元素添加单个引用。例如，一位作者在其所有书籍中都有引用。在这种情况下，简单的外键关系就足够了，因为《书籍》表将有一个指向《作者》表中条目的外键。多个书籍行可以引用同一作者。'
- en: '![Diagram'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![图'
- en: Description automatically generated](img/B17580_03_08.png)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_03_08.png)
- en: 'Figure 3.8: The key in the first table references multiple rows in the second'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8：第一张表中的键引用了第二张表中的多行
- en: '**One-to-zero or -one** are specific cases where a row can be related to only
    another. For example, let''s assume an editor can be working on a book (and only
    one book at a time). The reference for the editor in the Books table is a foreign
    key that can be set to `null` if there''s no editing process. Another back reference
    from the editor to the book will ensure that the relationship is unique. Both
    references need to be changed in a transaction.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对一或零一**是特定情况，其中一行只能与另一行相关联。例如，假设编辑可以处理一本书（并且一次只能处理一本书）。在《书籍》表中编辑的引用是一个外键，如果没有编辑过程，则可以将其设置为`null`。从编辑到书籍的另一个反向引用将确保关系的唯一性。这两个引用都需要在事务中更改。'
- en: Strict one-to-one relationships, like a book and a title, where both are always
    related, are typically better modeled as adding all the information into a single
    table.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 严格的一对一关系，例如一本书和它的标题，两者总是相关联，通常最好将所有信息添加到单个表中。
- en: '![](img/B17580_03_09.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17580_03_09.png)'
- en: 'Figure 3.9: The relationship only makes it possible to match two rows'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9：关系仅使匹配两行成为可能
- en: '**Many-to-many**,where there can be multiple assignments in both directions.
    For example, a book may be categorized under different genres. A single genre
    will be assigned to multiple books, and a single book can be assigned to more
    than one genre. Under a relational data structure, there''s a need for an intermediary
    extra table that makes that relationship, which will point to both the book and
    the genre.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多对多**，在两个方向上都可以有多个分配。例如，一本书可能被归类在不同的类型下。一个类型将被分配给多本书，一本书也可以被分配给多个类型。在关系型数据结构中，需要一个中间的额外表来建立这种关系，该表将指向书籍和类型。'
- en: This extra table may include more information, for example, how accurate the
    genre is for the book. That way, it could describe books that are 50% horror and
    90% adventure.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个额外表可能包含更多信息，例如，类型对书籍的准确性。这样，它可以描述50%恐怖和90%冒险的书籍。
- en: Outside of the relational data world, sometimes there's not such a pressing
    need for creating many-to-many relationships, and instead they can be directly
    added as a collection of tags. Some relational databases now allow more flexibility
    in allowing fields that are lists or JSON objects, which can be used in this way,
    simplifying the design.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系型数据世界之外，有时不需要迫切创建多对多关系，而可以直接将其作为标签集合添加。一些关系型数据库现在允许在允许字段为列表或JSON对象方面有更多的灵活性，这可以用来简化设计。
- en: '![Diagram'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图解'
- en: Description automatically generated](img/B17580_03_10.png)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![自动生成的描述](img/B17580_03_10.png)'
- en: 'Figure 3.10: Note the intermediary table allows multiple combinations. The
    first table can reference multiple rows of the second, and the second multiple
    rows of the first'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10：注意中间表允许多种组合。第一个表可以引用第二个表的多个行，第二个表也可以引用第一个表的多个行
- en: 'In most cases, the types of fields to store for each of the tables are straightforward,
    though certain details should be considered:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，每个表要存储的字段类型是直接的，尽管应该考虑某些细节：
- en: '**Allowing enough space to grow in the future**. Some fields, like strings,
    require defining a maximum size to store. For example, storing a string representing
    an email address will require a maximum of 254 characters. But sometimes the size
    is not obvious, like storing the name of a customer. In these cases, it''s better
    to err on the safe size and increase the limit.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为未来的增长留出足够的空间**。一些字段，如字符串，需要定义一个最大存储大小。例如，存储表示电子邮件地址的字符串将需要最多254个字符。但有时大小并不明显，例如存储客户的名称。在这些情况下，最好选择安全的大小并增加限制。'
- en: The limits should be enforced not only for the database, but also above this
    level, to always allow any API or UI that deals with the field to handle it gracefully.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制不仅应该应用于数据库，还应该在此级别以上强制执行，以确保任何处理该字段的API或UI都能优雅地处理。
- en: When dealing with numbers, in most cases regular integers will be enough to
    represent most used numbers. Though some databases accept categories like `smallint`
    for 2 bytes or `tinyint` for 1-byte values, it's not recommended to make use of
    them. The difference in space used will be minimal.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在处理数字时，在大多数情况下，常规整数足以表示大多数使用的数字。尽管一些数据库接受像`smallint`（2字节）或`tinyint`（1字节）这样的类别，但并不建议使用它们。使用的空间差异将非常小。
- en: '**The internal database representation doesn''t need to be the same as what''s
    externally available**. For example, the time stored in the database should always
    be in UTC, and then translated to the user''s time zone.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部数据库表示不需要与外部可用的内容相同**。例如，数据库中存储的时间应始终为协调世界时（UTC），然后转换为用户的时区。'
- en: Storing the time always in UTC format allows using a consistent time in the
    server, in particular if there are users in different time zones. Storing the
    time by applying the time zone for the user produces non-comparable times in the
    database and using the default time zone of the server can produce different results
    based on the position of the server, or even worse, inconsistent data if more
    than one server in different time zones is involved. Ensure that all times are
    stored in the database in UTC.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 总是在UTC格式中存储时间，允许在服务器上使用一致的时间，特别是如果有不同时区的用户。通过应用用户的时区来存储时间会在数据库中产生不可比较的时间，而使用服务器默认的时区可能会根据服务器的位置产生不同的结果，或者更糟糕的是，如果涉及不同时区的多个服务器，可能会产生不一致的数据。确保所有时间都在数据库中以UTC格式存储。
- en: Another example is if prices are stored, it's better to store them in cents,
    to avoid float numbers, and then present them as dollars and cents.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是如果存储价格，最好以分存储，以避免浮点数，然后以美元和分的形式展示。
- en: For example, this means that a price of $99.95 will be stored as the integer
    `9995`. Dealing with float arithmetic can create problems for prices, and prices
    can be translated into cents for easy handling.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这意味着$99.95的价格将被存储为整数`9995`。处理浮点算术可能会为价格带来问题，而价格可以转换为分以便于处理。
- en: The internal representation doesn't need to follow the same conventions if storing
    them in a different format is better for some reason.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某种原因以不同的格式存储它们更好，内部表示不需要遵循相同的约定。
- en: '**At the same time, it''s better to represent the data naturally**. A typical
    example of that is the overabundance of using numeric IDs to represent rows that
    have natural keys or using `Enums` (small integers assigned to represent a list
    of options) instead of using short strings instead. While these choices made sense
    some time ago, when space and processing power were more restrictive, now the
    performance improvement is negligible, and storing data in an understandable way
    helps greatly while developing.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同时，最好以自然的方式表示数据**。一个典型的例子是过度使用数字ID来表示具有自然键的行，或者使用`Enums`（分配给表示选项列表的小整数）而不是使用短字符串。虽然这些选择在过去某个时候是有意义的，当时空间和处理能力更加受限，但现在性能提升微乎其微，以可理解的方式存储数据在开发过程中有很大帮助。'
- en: For example, instead of using an integer field to store colors, where `1` means
    `RED`, `2` means `BLUE`, and `3` means `YELLOW`, use a short string field using
    the strings `RED`, `BLUE`, and `YELLOW`. The storing difference is negligible
    even if there are millions of records, and it's way easier to navigate the database.
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，与其使用整数字段来存储颜色，其中`1`代表`RED`，`2`代表`BLUE`，`3`代表`YELLOW`，不如使用短字符串字段，使用字符串`RED`、`BLUE`和`YELLOW`。即使有数百万条记录，存储差异也是微不足道的，而且导航数据库要容易得多。
- en: We will see a bit later about normalization and denormalization, which are related
    to this concept.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会看到关于规范化（Normalization）和反规范化（Denormalization）的内容，它们与这个概念相关。
- en: '**No design will be perfect or complete**. In a system under development, the
    schema will always require changes. This is totally normal and expected and should
    be accepted as such. Perfect is the enemy of good. The design should try to be
    as simple as possible to adjust for the current needs of the system. Overdesign,
    trying to advance every possible future need and complicating the design, is a
    real problem that can waste efforts in laying the ground for needs that never
    materialize. Keep your design simple and flexible.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有任何设计会是完美或完整的**。在一个正在开发中的系统中，模式总是会需要改变。这是完全正常和预期的，应该被接受为这样的。完美是好的敌人。设计应该尽可能地简单，以适应系统的当前需求。过度设计，试图推进每一个可能未来的需求，并使设计复杂化，这是一个真正的问题，可能会浪费为那些永远不会实现的需求奠定基础的努力。保持你的设计简单和灵活。'
- en: Schema normalization
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式规范化
- en: As we've seen, in relational databases, a key concept is the foreign key one.
    Data can be stored in a table and linked to another. This split in data means
    that a set of limited data can, instead of being stored in a single table, be
    split in two.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，在关系型数据库中，一个关键概念是外键。数据可以存储在一张表中，并与另一张表相链接。这种数据分割意味着一组有限的数据，而不是存储在单个表中，可以被分割成两部分。
- en: 'For example, let''s take a look at this table, initially with the field `House`
    as a string:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看这个表，最初字段`House`是一个字符串：
- en: '**Characters**'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**角色**'
- en: '| id | Name | House |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| id | 名称 | 家族 |'
- en: '| 1 | Eddard Stark | Stark |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 艾德·史塔克 | 史塔克 |'
- en: '| 2 | Jon Snow | Stark |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 约恩·史塔克 | 史塔克 |'
- en: '| 3 | Daenerys Targaryen | Targaryen |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 丹妮莉丝·坦格利安 | 坦格利安 |'
- en: '| 4 | Jaime Lannister | Lannister |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 詹姆·兰尼斯特 | 兰尼斯特 |'
- en: To ensure that the data is consistent and there are no errors, the field `House`
    can be normalized. This means that it's stored in a different table, and a `FOREIGN
    KEY` constraint is enforced, in this way.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保数据的一致性并且没有错误，字段`House`可以被规范化。这意味着它存储在不同的表中，并且通过这种方式强制执行`FOREIGN KEY`约束。
- en: '**Characters** **Houses**'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**角色** **家族**'
- en: '| id | Name | HouseId (FK) |  | id | Name | Words |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| id | 名称 | 家族Id (FK) |  | id | 名称 | 词语 |'
- en: '| 1 | Eddard Stark | 1 |  | 1 | Stark | Winter is coming |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 艾德·史塔克 | 1 |  | 1 | 史塔克 | 冬风将至 |'
- en: '| 2 | Jon Snow | 1 |  | 2 | Lannister | Hear me roar |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 约恩·史塔克 | 1 |  | 2 | 兰尼斯特 | 听我咆哮 |'
- en: '| 3 | Daenerys Targaryen | 3 |  | 3 | Targaryen | Fire and blood |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 丹妮莉丝·坦格利安 | 3 |  | 3 | 坦格利安 | 火与血 |'
- en: '| 4 | Jaime Lannister | 2 |  |  |  |  |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 詹姆·兰尼斯特 | 2 |  |  |  |  |'
- en: This way of operating *normalizes* the data. No new entry with a new `House`
    can be added unless it is first introduced in the `Houses` table. In the same
    way, an entry in `Houses` cannot be deleted while a single entry in `Characters`
    contains a reference. This ensures that the data is very consistent and there
    are no problems, like introducing a typo like `House` *Lanister* (single n) for
    a new entry, which may complicate later queries.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操作方式*标准化*了数据。除非首先在“家族”表中引入，否则不能添加带有新“家族”的新条目。同样，如果“角色”表中有一个条目引用了它，则不能删除“家族”表中的条目。这确保了数据非常一致，没有问题，例如，为新的条目引入一个像“家族”*兰尼斯特*（单n）这样的打字错误，这可能会使后续查询复杂化。
- en: It also has the advantage of being able to add extra information for each of
    the entries in `Houses`. In this case, we can add the `Words` of the `House`.
    The data is also more compact, as repeated information is stored in a single pace.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 它还有这样的优点：可以为“家族”表中的每个条目添加额外信息。在这种情况下，我们可以添加“家族”的“词语”。数据也更紧凑，因为重复信息存储在单个位置。
- en: 'On the other hand, this has a couple of issues. First of all, any reference
    to a `Character` that needs to know the information of the `House` needs to perform
    a `JOIN` query. In the first `Characters` table, we could generate our query in
    this way:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这有几个问题。首先，任何需要知道“家族”信息的“角色”引用都需要执行一个`JOIN`查询。在第一个“角色”表中，我们可以这样生成查询：
- en: '[PRE4]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'While in the second schema, we will require this one:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 而在第二个架构中，我们将需要这个：
- en: '[PRE5]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This query will take longer to execute, as information needs to be compounded
    from two tables. For big tables, this time can be extensive. This can also require
    a `JOIN` from different tables if we add, for example, a `PreferredWeapon` field
    and a `Weapons` normalized table for each `Character`. Or we can add even more
    tables as the `Characters` table grows in fields.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询将需要更长的时间来执行，因为需要从两个表中组合信息。对于大型表，这个时间可能会非常长。如果我们添加例如“首选武器”字段和每个“角色”的标准化“武器”表，这也可能需要从不同的表中执行`JOIN`。或者，随着“角色”表字段的增长，我们还可以添加更多的表。
- en: It will also take longer to insert and delete data, as more checks need to be
    performed. In general, operations will take longer.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 插入和删除数据也会花费更长的时间，因为需要执行更多的检查。一般来说，操作会花费更长的时间。
- en: Normalized data is also difficult to shard. The concept of normalization of
    keeping every element described in its own table and reference from there is inherently
    difficult to shard, as it makes partitioning very difficult.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 标准化数据也难以分片。将每个元素描述保存在其自己的表中并从那里引用的概念本身就很难以分片，因为它使得分区变得非常困难。
- en: Another problem is that the database is more difficult to read and operate.
    Deletes need to happen in an ordered fashion, which gets more difficult to follow
    as more fields are being added. Also, complex `JOIN` queries need to be performed
    for simple operations. The queries are longer and more complicated to generate.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题在于数据库更难以阅读和操作。删除需要按顺序进行，随着更多字段的添加，这变得更加难以跟踪。此外，对于简单的操作，需要执行复杂的`JOIN`查询。查询更长，更复杂。
- en: While this normalization structure, creating foreign keys through numerical
    identifiers, is pretty typical, it's not the only option.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种通过数值标识符创建外键的标准化结构相当典型，但并非唯一的选择。
- en: To improve the clarity of the database, natural keys can be used to simplify
    them, describing the data in this way. Instead of using an integer as the primary
    key, we use the `Name` field on the `Houses` table.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高数据库的清晰度，可以使用自然键来简化它们，以这种方式描述数据。而不是使用整数作为主键，我们在“家族”表上使用“名称”字段。
- en: '**Characters** **Houses**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**角色** **家族**'
- en: '| Id | Name | House (FK) |  | Name (PK) | Words |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| Id | 名称 | 家族（外键） |  | 名称（主键） | 词语 |'
- en: '| 1 | Eddard Stark | Stark |  | Stark | Winter is coming |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 艾德·史塔克 | 史塔克家族 |  | 史塔克家族 | 冬风将至 |'
- en: '| 2 | Jon Snow | Stark |  | Lannister | Hear me roar |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 约恩·雪诺 | 史塔克家族 |  | 兰尼斯特家族 | 听我咆哮 |'
- en: '| 3 | Daenerys Targaryen | Targaryen |  | Targaryen | Fire and blood |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 丹妮莉丝·坦格利安 | 坦格利安家族 |  | 坦格利安家族 | 火与血 |'
- en: '| 4 | Jaime Lannister | Lannister |  |  |  |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 詹姆·兰尼斯特 | 兰尼斯特家族 |  |  |  |'
- en: This not only removes the usage of an extra field, but it also allows you to
    make the reference with a descriptive value. We recover our original query, even
    if the data is normalized.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅消除了使用额外字段的需求，还允许你使用描述性值进行引用。即使数据是标准化的，我们也能恢复原始查询。
- en: As we described before, the extra space of storing a string instead of a single
    integer is negligible. Some developers are very much against natural keys and
    prefer to use integer values, but nowadays there's not really a solid technical
    reason for limiting yourself.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所描述的，存储字符串而不是单个整数的额外空间是可以忽略不计的。一些开发者非常反对自然键，并更喜欢使用整数值，但如今并没有真正的技术理由来限制自己。
- en: 'Only when we want to obtain the information in the `Words` field will we need
    to perform a `JOIN` query:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当我们想要获取`Words`字段中的信息时，我们才需要进行`JOIN`查询：
- en: '[PRE6]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This trick, anyway, may not avoid the usage of `JOIN` queries in normal operation.
    Perhaps there are a lot of references and the system is having problems with the
    amount of time that it's taking to perform queries. In that case, it may be necessary
    to reduce the need to `JOIN` tables.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，这个技巧可能无法避免在正常操作中使用`JOIN`查询。也许有很多引用，系统在执行查询所需的时间上遇到了问题。在这种情况下，可能需要减少对`JOIN`表的需求。
- en: Denormalization
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反规范化
- en: Denormalization is the opposing action to normalization. Where normalizing data
    splits it into different tables to ensure that all the data is consistent, denormalizing
    regroups information into a single table to avoid the necessity to `JOIN` tables.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 反规范化是规范化的对立面。规范化数据时，将其拆分到不同的表中以确保所有数据的一致性，而反规范化则将信息重新组合到一个表中，以避免必须`JOIN`表。
- en: 'Following our example above, we want to replace a `JOIN` query like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们上面的例子，我们想要替换如下`JOIN`查询：
- en: '[PRE7]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Which follows this schema:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 它遵循以下模式：
- en: '**Characters** **Houses**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**角色** **家族**'
- en: '| Id | Name | House (FK) |  | Name (PK) | Words |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| Id | 姓名 | 家族（外键） |  | 姓名（主键） | 话语 |'
- en: '| 1 | Eddard Stark | Stark |  | Stark | Winter is coming |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 艾德·史塔克 | 斯塔克 |  | 斯塔克 | 冬风将至 |'
- en: '| 2 | Jon Snow | Stark |  | Lannister | Hear me roar |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 约恩·雪诺 | 斯塔克 |  | 兰尼斯特 | 听我咆哮 |'
- en: '| 3 | Daenerys Targaryen | Targaryen |  | Targaryen | Fire and blood |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 丹妮莉丝·坦格利安 | 坦格利安 |  | 坦格利安 | 火与血 |'
- en: '| 4 | Jaime Lannister | Lannister |  |  |  |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 詹姆·兰尼斯特 | 兰尼斯特 |  |  |  |'
- en: 'For a query similar to this, querying a single table, use something like this:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类似这样的查询，查询单个表，可以使用如下方法：
- en: '[PRE8]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To do so, the data needs to be structured in a single table.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，数据需要在一个表中结构化。
- en: '**Characters**'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**角色**'
- en: '| id | Name | House | Words |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| id | 姓名 | 家族 | 话语 |'
- en: '| 1 | Eddard Stark | Stark | Winter is coming |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 艾德·史塔克 | 斯塔克 | 冬风将至 |'
- en: '| 2 | Jon Snow | Stark | Winter is coming |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 约恩·雪诺 | 斯塔克 | 冬风将至 |'
- en: '| 3 | Daenerys Targaryen | Targaryen | Fire and blood |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 丹妮莉丝·坦格利安 | 坦格利安 | 火与血 |'
- en: '| 4 | Jaime Lannister | Lannister | Hear me roar |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 詹姆·兰尼斯特 | 兰尼斯特 | 听我咆哮 |'
- en: Note that information is duplicated. Every `Character` has a copy of the `Words`
    of the `House`, something that was not required before. This means denormalization
    uses more space; in a big table with many rows, way more space.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，信息是重复的。每个`Character`都有一个`House`的`Words`的副本，这在之前是不必要的。这意味着反规范化使用更多的空间；在一个行数众多的表中，空间会更多。
- en: Denormalization also increases the risk of inconsistent data, as there's nothing
    ensuring that there's not a new value that's a typo of an old value, or that,
    by mistake, incorrect `Words` are added to a different `House`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 反规范化也增加了数据不一致的风险，因为没有东西可以确保没有新的值是旧值的打字错误，或者错误地添加了不同的`House`中的`Words`。
- en: But, on the other hand, we are now free of having to `JOIN` tables. For big
    tables this can speed up processing, both read and writes, quite a lot. It also
    removes the concerns for sharding, as now the table can be partitioned on whatever
    shard key that's convenient and will contain all the information.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，另一方面，我们现在可以摆脱`JOIN`表的需求。对于大型表，这可以大大加快读写处理速度。它还消除了分片的问题，因为现在表可以根据方便的任何分片键进行分区，并将包含所有信息。
- en: Denormalization is an extremely common option for the use cases that typically
    fall under NoSQL databases, which remove the capability to perform `JOIN` queries.
    For example, document databases embed data as subfields into a bigger entity.
    While it certainly has its cons, it's a trade-off that makes sense in some operations.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 反规范化是NoSQL数据库中常见的选择，这些数据库移除了执行`JOIN`查询的能力。例如，文档数据库将数据作为子字段嵌入到更大的实体中。虽然它确实有其缺点，但在某些操作中，这种权衡是有意义的。
- en: Data indexing
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据索引
- en: As data grows, the access to data starts getting slower. Retrieving exactly
    the proper data from a big table full of information requires performing more
    internal operations to locate it.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数据的增长，数据的访问开始变慢。从充满信息的大表中检索确切的数据需要执行更多内部操作来定位它。
- en: While we will describe data indexing in relation to relational databases, most
    of the fundamentals are applicable to other databases.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们将描述与关系数据库相关的数据索引，但大多数基本原理也适用于其他数据库。
- en: This process can be greatly speeded up by organizing the data smartly in a way
    that is easy to search. This leads to creating indexes that allow you to locate
    data very quickly by searching through them. The basics of an index is to create
    an external sorted data structure that points to one or more fields of each of
    the records of the database. This index structure is always kept sorted as data
    in the table changes.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以易于搜索的方式智能地组织数据，可以大大加快这个过程。这导致创建索引，通过搜索它们可以非常快速地定位数据。索引的基本原理是创建一个指向数据库中每条记录的一个或多个字段的外部排序数据结构。这个索引结构始终保持排序状态，因为表中的数据发生变化。
- en: For example, a short table may contain this information
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个简短的表可能包含以下信息
- en: '| id | Name | Height (cm) |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| id | Name | Height (cm) |'
- en: '| 1 | Eddard | 178 |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Eddard | 178 |'
- en: '| 2 | John | 173 |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| 2 | John | 173 |'
- en: '| 3 | Daenerys | 157 |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Daenerys | 157 |'
- en: '| 4 | Jaime | 188 |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| 4 | Jaime | 188 |'
- en: In the absence of an index, to query what entry has the highest height, the
    database will need to individually check each of the rows and sort them. This
    is called a **full table scan**. A full table scan can be very costly if the table
    has millions of rows.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有索引的情况下，要查询具有最高身高的条目，数据库需要逐行检查并排序。这被称为**全表扫描**。如果表有数百万行，全表扫描可能会非常昂贵。
- en: By creating an index for the `Height` field, a data structure that is always
    sorted is kept in sync with the data.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为`Height`字段创建索引，一个始终排序的数据结构会与数据保持同步。
- en: '| id | Name | Height (cm) |  | Height (cm) | id |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| id | Name | Height (cm) |  | Height (cm) | id |'
- en: '| 1 | Eddard | 178 |  | 188 | 4 |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Eddard | 178 |  | 188 | 4 |'
- en: '| 2 | John | 173 |  | 178 | 1 |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| 2 | John | 173 |  | 178 | 1 |'
- en: '| 3 | Daenerys | 157 |  | 173 | 5 |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Daenerys | 157 |  | 173 | 5 |'
- en: '| 4 | Jaime | 188 |  | 157 | 3 |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| 4 | Jaime | 188 |  | 157 | 3 |'
- en: Because it is always sorted, making any query related to the height is easy
    to fulfill. For example, obtaining what the top 3 heights are doesn't require
    any checking, just retrieving the first three records from the index, and determining
    heights between 180 and 170 is also easy, using search methods in sorted lists,
    like a binary search. Once again, if this index doesn't exist, the only way to
    find these queries is by checking each record in the table.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它总是排序的，所以任何与身高相关的查询都很容易完成。例如，获取最高的三个身高不需要任何检查，只需从索引中检索前三条记录，并且使用排序列表中的搜索方法，如二分搜索，来确定在180到170厘米之间的身高也很容易。再次强调，如果这个索引不存在，唯一找到这些查询的方法就是检查表中的每一条记录。
- en: Note that the index doesn't cover all the fields. The `Name` field is not indexed,
    for example. Another index may be required to cover other fields. The same table
    accepts multiple indices.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，索引并不涵盖所有字段。例如，`Name`字段没有索引。可能还需要其他索引来涵盖其他字段。相同的表可以接受多个索引。
- en: The primary key of a table is always indexed, as it needs to be a unique value.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 表的主键总是索引的，因为它需要是一个唯一值。
- en: Indexes can be combined, creating an index for two or more fields. These composite
    indices sort the data based on the ordered combination of both fields, for example,
    a composite index that is `(Name, Height)` will quickly return the height for
    `Names` starting with `J`. A composite index of `(Height, Name)` will do the opposite,
    priming the height and then sorting the `Name` field.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 索引可以组合，为两个或更多字段创建索引。这些组合索引根据两个字段的有序组合对数据进行排序，例如，一个`(Name, Height)`的组合索引将快速返回以`J`开头的`Names`的身高。一个`(Height,
    Name)`的组合索引将做相反的操作，首先对身高进行排序，然后对`Name`字段进行排序。
- en: Querying in composite indices for only the first part of the index is possible.
    In our example, an index of `(Height, Name)` will always work for querying `Height`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在组合索引中查询索引的第一部分是可能的。在我们的例子中，`(Height, Name)`的索引将始终用于查询`Height`。
- en: The usage or not of indexes to retrieve the information is done automatically
    by the database; the SQL query doesn't change at all. Internally, the database
    will run the query analyzer before running a query. This part of the database
    software will determine how to retrieve the data, and what indexes to use, if
    any.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 使用或不使用索引来检索信息是由数据库自动完成的；SQL查询本身没有任何变化。内部，数据库在运行查询之前会运行查询分析器。这部分数据库软件将确定如何检索数据，以及是否使用索引。
- en: The query analyzer needs to run quickly, as determining what the best possible
    way to search for information is can take more time than running a naïve approach
    and returning the data. This means that, sometimes, it will make mistakes and
    not use the optimal combination. The SQL command `EXPLAIN`, used before another
    SQL statement, will display how the query will be interpreted and run, which allows
    you to understand and tweak it to improve its execution time.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 查询分析器需要快速运行，因为确定最佳搜索信息的方法可能比运行简单方法并返回数据花费的时间更长。这意味着有时它可能会出错，不会使用最佳组合。在另一个SQL语句之前使用的SQL命令`EXPLAIN`将显示查询将被如何解释和运行，这允许你理解和调整它以改善其执行时间。
- en: Keep in mind that using different independent indices in the same query may
    not be possible. Sometimes the database won't be able to perform a faster query
    by combining two indices as the data needs to be correlated between them, and
    that may be a costly operation.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在同一个查询中使用不同的独立索引可能不可行。有时数据库无法通过结合两个索引来执行更快的查询，因为数据需要在它们之间进行关联，这可能会是一项昂贵的操作。
- en: 'Indexes greatly speed up the queries that use them, especially for big tables
    with thousands or millions of rows. They are also used automatically, so they
    don''t add extra complexity to the generation of queries. So, if they are so great,
    why not index absolutely everything? Well, indices also have some issues:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 索引可以极大地加快使用它们的查询速度，特别是对于有数千或数百万行的大表。它们也是自动使用的，因此不会给查询生成增加额外的复杂性。所以，如果它们如此之好，为什么不索引一切呢？嗯，索引也有一些问题：
- en: Each index requires extra space. While this is optimized, adding a lot of indexes
    in a single table will use more space, both in the hard drive and in RAM.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个索引都需要额外的空间。虽然这是优化的，但在单个表中添加大量索引将占用更多的空间，包括硬盘和RAM。
- en: Each time the table changes, all indices in the table need to be adjusted to
    be sure that the index is properly sorted. This is more noticeable in new data
    being written, like records being added or indexed fields being updated. Indices
    are a trade-off between spending more time on writing to speed up the reading.
    For tables that are write heavy, this trade-off may not be adequate, and maintaining
    one or more indices can be counterproductive.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次表发生变化时，都需要调整表中的所有索引，以确保索引被正确排序。这在写入新数据时更为明显，例如添加记录或更新索引字段。索引是花费更多时间在写入上以加快读取速度的权衡。对于写入密集型的表，这种权衡可能不足，维护一个或多个索引可能适得其反。
- en: Small tables don't really benefit from being indexed. The difference between
    a full table scan and an indexed search is small if the number of rows is below
    the thousands.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小表实际上并不真正受益于索引。如果行数低于千行，全表扫描和索引搜索之间的差异很小。
- en: As a rule of thumb, it's better to try to create indices *after* the need is
    detected. Once a slow query is discovered, analyze if an index will improve the
    situation, and only then create it.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 按照经验法则，最好在检测到需求后尝试创建索引。一旦发现查询缓慢，分析索引是否可以改善情况，然后再创建它。
- en: Cardinality
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基数
- en: An important characteristic of the usefulness of each index is its **cardinality**.This
    is the number of different values that an index contains.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 每个索引的有用性的一个重要特征是其**基数**。这是索引包含的不同值的数量。
- en: For example, the `Height` index in this table has a cardinality of 4\. There
    are four different values.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，此表中的`Height`索引具有4个基数。有四个不同的值。
- en: '| id | Height (cm) |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| id | 身高 (cm) |'
- en: '| 1 | 178 |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 178 |'
- en: '| 2 | 165 |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 165 |'
- en: '| 3 | 167 |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 167 |'
- en: '| 4 | 192 |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 192 |'
- en: A table like this has only a cardinality of 2.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的表只有一个2的基数。
- en: '| id | Height (cm) |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| id | 身高 (cm) |'
- en: '| 1 | 178 |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 178 |'
- en: '| 2 | 165 |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 165 |'
- en: '| 3 | 178 |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 178 |'
- en: '| 4 | 165 |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 165 |'
- en: An index with low cardinality has low quality, as it's not able to speed up
    the search as much as expected. An index can be understood as a filter that allows
    you to reduce the number of rows to search. If, after applying the filter, the
    table has not been greatly reduced, the index won't be useful. Let's use an extreme
    example to describe it.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 卡尔达数低的索引质量较低，因为它无法像预期的那样加快搜索速度。可以将索引理解为一种过滤器，允许您减少要搜索的行数。如果在应用过滤器后，表中的行数没有显著减少，那么索引将没有用。让我们用一个极端的例子来描述它。
- en: Imagine a table with a million rows indexed by a field that's the same in all
    of them. Now imagine that we make a query to find a single row in a different
    field that's not indexed. If we use the index, we won't be able to speed up the
    process, as the index will return every single row in the database.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个有百万行记录的表，这些记录通过一个字段索引，而这个字段在所有记录中都是相同的。现在想象一下，如果我们对一个未索引的不同字段进行查询以找到单个行，如果我们使用索引，我们将无法加快这个过程，因为索引将返回数据库中的每一行。
- en: '![A picture containing text, shoji, crossword puzzle'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '![包含文本、障子、填字游戏的图片'
- en: Description automatically generated](img/B17580_03_11.png)
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_03_11.png)
- en: 'Figure 3.11: Returning every single row from a query using an unhelpful index'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11：使用无用的索引从查询中返回每一行
- en: Now imagine it with two values. Half of the rows of the table are returned first,
    and then we need to query them. This is better, but using the index has some overhead
    compared with just performing a full table scan, so in practice, this is not very
    advantageous.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象有两个值的情况。首先返回表的一半行，然后我们需要查询它们。这比之前好，但与全表扫描相比，使用索引有一些开销，所以在实际应用中，这并不很有优势。
- en: '![A picture containing text, clock'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '![包含文本、时钟的图片'
- en: Description automatically generated](img/B17580_03_12.png)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_03_12.png)
- en: 'Figure 3.12: Returning rows using an index with two values'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12：使用两个值的索引返回行
- en: As we increase the cardinality of the index, adding more and more values, the
    index is more useful.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 随着索引的卡尔达数增加，即添加越来越多的值，索引就越有用。
- en: '![Diagram, box and whisker chart'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '![图表、箱线图'
- en: Description automatically generated with medium confidence](img/B17580_03_13.png)
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述，中等置信度](img/B17580_03_13.png)
- en: 'Figure 3.13: Returning rows using an index with four values'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13：使用四个值的索引返回行
- en: With a higher cardinality, the database is able to discriminate better and to
    point to a smaller subsection of values, which speeds up greatly access to the
    proper data.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 随着卡尔达数的提高，数据库能够更好地区分，并指向更小的值子集，这极大地加快了对正确数据的访问。
- en: As a rule of thumb, ensure that the cardinality of an index is always 10 or
    higher. Lower than that is probably not good enough to use as an index. The query
    analyzer will take the cardinality value into account to see whether to use the
    index or not.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 作为经验法则，确保索引的卡尔达数始终为10或更高。低于这个值可能不足以用作索引。查询分析器将考虑卡尔达数值，以确定是否使用索引。
- en: Keep in mind that the cardinality of fields that only allow a small number of
    values, such as `Booleans` and `Enums`, is always limited and makes them bad candidates
    to be indexed, at least on their own. On the other hand, values that are unique
    will always have the highest possible cardinality and they are good candidates
    for indexing. Primary keys are always indexed automatically for this reason.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，只允许少量值的字段（如`布尔值`和`枚举`）的卡尔达数总是有限的，这使得它们不适合作为索引，至少单独使用时是这样。另一方面，唯一的值总是具有最高的可能卡尔达数，它们是索引的良好候选者。由于这个原因，主键总是自动索引。
- en: Summary
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we described different methods and techniques to deal with
    the storage layer, both from the point of view of the different capacities and
    options available in the database itself, and how the code of our application
    can interact to store and retrieve information.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了处理存储层的方法和技术，既从数据库本身提供的不同容量和选项的角度，也从我们的应用程序代码如何交互以存储和检索信息的角度进行了描述。
- en: We described the different kinds of databases, both relational and non-relational,
    and what the differences and usages of each are, and how the concept of a transaction,
    one of the fundamental characteristics of relational databases, allows compliance
    with ACID properties. As some of the non-relational databases are aimed at dealing
    with data on a large scale and are distributed, we presented some of the techniques
    to scale up relational systems, as that kind of database was not initially designed
    to deal with multiple servers.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述了不同类型的数据库，包括关系型和非关系型，以及每种数据库的区别和用途，以及事务的概念，这是关系型数据库的基本特性之一，它如何允许符合ACID属性。由于一些非关系型数据库旨在处理大规模数据并且是分布式的，我们介绍了提高关系型系统扩展性的技术，因为这种类型的数据库最初并没有设计用来处理多个服务器。
- en: We continued by describing how we can design a schema and what the pros and
    cons are for normalizing and denormalizing the data. We also described why we
    index fields and when it's counterproductive.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续描述了如何设计模式以及数据规范化与反规范化的优缺点。我们还解释了为什么我们需要索引字段以及何时这样做是适得其反的。
- en: In *Chapter 4*, *The Data Layer*, we will see how to design the data layer.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第4章*，*数据层*中，我们将了解如何设计数据层。
