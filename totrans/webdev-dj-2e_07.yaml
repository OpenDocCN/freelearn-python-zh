- en: 7\. Advanced Form Validation and Model Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: Continuing your journey with the Bookr application, you will begin this chapter
    by adding a new form to your app with custom multi-field validation and form cleaning.
    You will learn how to set the initial values on your form and customize the widgets
    (the HTML input elements that are being generated). Then you will be introduced
    to the `ModelForm` class, which allows a form to be automatically created from
    a model. You will use it in a view to automatically save the new or changed `Model`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know how to add extra multi-field validation
    to Django forms, how to customize and set form widgets for fields, how to use
    `ModelForms` to automatically create a form from a Django model, and how to automatically
    create `Model` instances from `ModelForms`.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter builds upon the knowledge we gained in *Chapter 6*, *Forms*, where
    we learned how to submit data from an HTML form to a Django view, both with a
    manually built HTML form and with a Django form. We used Django's `form` library
    to build and automatically validate forms with basic validation. For example,
    now we can build forms that check whether a date is entered in its desired format,
    whether a number is input where a user must enter their age, and whether a dropdown
    is selected before the user clicks the `Submit` button. However, most large-scale
    websites require validation that is a bit more advanced.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, a certain field might only be required if another field is set.
    Let''s say we want to add a checkbox to allow users to sign up for our monthly
    newsletter. It has a textbox below it that lets them enter their email address.
    With some basic validation, we can check whether:'
  prefs: []
  type: TYPE_NORMAL
- en: The user has checked the checkbox.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user has entered their email address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user clicks the `Submit` button, we will be able to validate whether
    both fields are actioned. But what if the user doesn't want to sign up for our
    newsletter? If they click the `Submit` button, ideally, both fields should be
    blank. That's where validating each individual field might not work.
  prefs: []
  type: TYPE_NORMAL
- en: Another example could be a case where we have two fields and each has a maximum
    value of, say, 50\. But the total of values added to each one must be less than
    75\. We will start the chapter by looking at how to write custom validation rules
    to solve such problems.
  prefs: []
  type: TYPE_NORMAL
- en: Later, as we progress in the chapter, we will look at how to set initial values
    on a form. This can be useful when automatically filling out information that
    is already known to the user. For example, we can automatically put a user's contact
    information into a form if that user is logged in.
  prefs: []
  type: TYPE_NORMAL
- en: We will finish the chapter by looking at model forms, which will let us automatically
    create a form from a Django `Model` class. This cuts down the amount of code that
    needs to be written to create a new `Model` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Field Validation and Cleaning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how a Django form converts values from an HTTP request, which are
    strings, into Python objects. In a non-custom Django form, the target type is
    dependent on the field class. For example, the Python type derived from `IntegerField`
    is `int`, and string values are given to us verbatim, as the user entered them.
    But we can also implement methods on our `Form` class to alter the output values
    from our fields in any way we choose. The allows us to clean or filter the user's
    input data to fit what we expect better. We could round an integer to the nearest
    multiple of ten to fit into a batch size for ordering specific items. Or we could
    transform an email address to lowercase so that the data is consistent for searching.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also implement some custom validators. We will look at a couple of different
    ways of validating fields: by writing a custom validator, and by writing a custom
    `clean` method for the field. Each method has its pros and cons: a custom validator
    can be applied to different fields and forms, so you do not have to write the
    validation logic for each field; a custom `clean` method must be implemented on
    each form you want to clean, but is more powerful and allows validation using
    other fields in the form or changing the cleaned value that the field returns.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom Validators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A validator is simply a function that accepts a value and raises `django.core.exceptions.ValidationError`
    if the value is invalid – the validity is determined by the code you write. The
    value is a Python object (that is, `cleaned_data` that has already been converted
    from the `POST` request string).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example that validates whether a value is lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice the function does not return anything, for either success or failure.
    It will just raise `ValidationError` if the value is not valid.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that the behavior and handling of `ValidationError` differ from how other
    exceptions behave in Django. Normally, if you raise an exception in your view,
    you will end up with a `500` response from Django (if you do not handle the exception
    in your code).
  prefs: []
  type: TYPE_NORMAL
- en: When raising `ValidationError` in your validation/cleaning code, the Django
    `form` class will catch the error for you and then the `is_valid` method of `form`
    will return `False`. You do not have to write `try`/`except` handlers around the
    code that might raise `ValidationError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The validator can be passed to the `validators` argument of a field constructor
    on a form, inside a list; for example, to our `text_input` field from our `ExampleForm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we submit the form and the fields contain uppercase values, we will
    get an error, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: Lowercase text validator in action'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_07_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.1: Lowercase text validator in action'
  prefs: []
  type: TYPE_NORMAL
- en: The validator function can be used on any number of fields. In our example,
    if we wanted lots of fields to have lowercase enforced, `validate_lowercase` could
    be passed to all of them. Let's now look at how we could implement this another
    way, with a custom `clean` method.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `clean` method is created on the `Form` class and is named in the format `clean_field-name`.
    For example, the `clean` method for `text_input` would be called `clean_text_input`,
    the `clean` method for `books_you_own` would be `clean_books_you_own`, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning methods take no arguments; instead, they should use the `cleaned_data`
    attribute on `self` to access the field data. This dictionary will contain the
    data after being cleaned in the standard Django way, as we saw in the previous
    example. The `clean` method must return the cleaned value, which will replace
    the original value in the `cleaned_data` dictionary. Even if the method does not
    change the value, a value must be returned. You can also use the `clean` method
    to raise `ValidationError`, and the error will be attached to the field (the same
    as with a validator).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s re-implement the lowercase validator as a `clean` method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can see the logic is essentially the same, except we must return the validated
    value at the end. If we submit the form, we get the same result as the previous
    time we tried (*Figure 7.1*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at one more cleaning example. Instead of raising an exception when
    the value is invalid, we could just convert the value to lowercase. We would implement
    that with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, consider that we enter text into the input as uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: ALL UPPERCASE text entered'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_07_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.2: ALL UPPERCASE text entered'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to examine the cleaned data using our debug output from the view,
    we would see that it is lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: The cleaned data has been transformed to lowercase'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_07_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.3: The cleaned data has been transformed to lowercase'
  prefs: []
  type: TYPE_NORMAL
- en: These were just a couple of simple examples of how to validate fields using
    both validators and `clean` methods. You can, of course, make each type of validation
    much more complex if you wish and transform the data in more complex ways using
    a `clean` method.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you have only learned simple methods for form validation, where you
    have treated each field independently. A field is valid (or not) based only on
    the information it contains and nothing else. What if the validity of one field
    depends on what the user entered into another field? An example of this might
    be that you have an `email` field to collect someone's email address if they want
    to be signed up to a mailing list. The field is only required if they check a
    checkbox that indicates they wanted to be signed up. Neither of these fields is
    required on their own – we do not want the checkbox to be required to be checked,
    but if it is checked, then the `email` field should be required too.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will show how you can validate a form whose fields depend
    on each other by overriding the `clean` method in your form.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-Field Validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just looked at the `clean_<field-name>` methods that can be added to
    a Django form, to clean a specific field. Django also allows us to override the
    `clean` method, in which we can access all the `cleaned_data` from all fields,
    and we know that all custom field methods have been called. This allows the validation
    of fields based on another field's data.
  prefs: []
  type: TYPE_NORMAL
- en: Referring to our previous example with a form that has an email address that
    is only required if a checkbox is checked, we will see how we can implement this
    using the `clean` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a `Form` class and add two fields – make them both optional with
    the `required=False` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We have also introduced two new arguments that can be used for any field:'
  prefs: []
  type: TYPE_NORMAL
- en: '`label`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This allows setting the label text for a field. As we have seen, Django will
    automatically generate label text from the field name. If you set the `label`
    argument, you can override this default. Use this argument if you want to have
    a more descriptive label.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`help_text`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to have more information displayed regarding what input a field
    requires, you can use this argument. By default, it is displayed after the field.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When rendered, the form looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: Email signup form with custom label and help text'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_07_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.4: Email signup form with custom label and help text'
  prefs: []
  type: TYPE_NORMAL
- en: If we were to submit the form now, without entering any data, nothing would
    happen. Neither field is required, so the form validates fine.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can add the multi-field validation to the `clean` method. We will check
    whether the `signup` checkbox is checked, and then check that the `email` field
    has a value. The built-in Django methods have already validated that the email
    address is valid at this point, so we then just need to check that a value exists
    for it. We will then use the `add_error` method to set an error for the `email`
    field. This is a method you haven't seen before but it's very simple; it takes
    two arguments – the name of the field to set the error on, and the text of the
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the `clean` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Your `clean` method must always call the `super().clean()` method to retrieve
    the cleaned data. When `add_error` is called to add errors to the form, the form
    will no longer validate (the `is_valid` method returns `False`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if we submit the form without the checkbox checked, there is still no error
    generated, but if you check the checkbox without an email address, you will receive
    the error we just wrote the code for:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: Error displayed when attempting to sign up with no email address'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_07_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.5: Error displayed when attempting to sign up with no email address'
  prefs: []
  type: TYPE_NORMAL
- en: You might notice that we are retrieving the email from the `cleaned_data` dictionary
    using the `get` method. The reason for doing this is if the `email` value in the
    form is invalid, then the `email` key will not exist in the dictionary. The browser
    should prevent the user from submitting the form if an invalid email has been
    entered, but a user might be using an older browser that does not support this
    client-side validation, so for safety, we use the `get` method. Since the `signup`
    field is `BooleanField`, and not required, it will only be invalid if a custom
    validation function is used. We are not using one here, so it is safe to access
    its value using square bracket notation.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more validation scenario to consider before moving on to our first
    exercise, and that is adding errors that are not specific to any field. Django
    calls these *non-field errors*. There are many scenarios where you might want
    to use these when multiple fields are dependent on each other.
  prefs: []
  type: TYPE_NORMAL
- en: Take, for example, a shopping website. Your order form could have two numeric
    fields whose totals could not exceed a certain value. If the total were exceeded,
    the value of either field could be decreased to bring the total below the maximum
    value, so the error is not specific to either one of the fields. To add a non-field
    error, call the `add_error` method with `None` as the first argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at how to implement this. In this example, we will have a form
    where the user can specify a certain number of items to order, for item A or item
    B. The user cannot order more than 100 items in total. The fields will have a
    `max_value` of `100`, and `min_value` of `0`, but custom validation in the `clean`
    method will need to be written to handle the validation of the total amount:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The fields (`item_a` and `item_b`) are added in the normal way, with standard
    validation rules. You can see that we have used the `clean` method the same way
    we used it before. Moreover, we have implemented the maximum item logic inside
    this method. The following line is what registers the non-field error if the maximum
    items are exceeded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we access the values of `item_a` and `item_b` using the `get` method,
    with a default value of `0`. This is in case the user has an older browser (from
    2011 or earlier) and was able to submit the form with invalid values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a browser, the field-level validation ensures values between 0 and 100 have
    been entered in each field, and prevents the form from being submitted otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6: The form cannot be submitted if one field exceeds the maximum
    value'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_07_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.6: The form cannot be submitted if one field exceeds the maximum value'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we put in two values that sum to more than 100, we can see how
    Django displays the non-field error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7: Django non-field error displayed at the start of the form'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_07_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.7: Django non-field error displayed at the start of the form'
  prefs: []
  type: TYPE_NORMAL
- en: Django non-field errors are always displayed at the start of a form, before
    other fields or errors. In the next exercise, we will build a form that implements
    a validation function, a field clean method, and a form clean method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.01: Custom Clean and Validation Methods'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will build a new form that allows the user to create
    an order for books or magazines. It must have the following validation criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: The user may order up to 80 magazines and/or 50 books, but the total number
    of items must not be more than 100\.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user can choose to receive an order confirmation, and if they do, they must
    enter an email address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user should not enter an email address if they have not chosen to receive
    an order confirmation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To ensure they are part of our company, the email address must be part of our
    company domain (in our case, we will just use `example.com`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For consistency with other email addresses in our fictional company, the address
    should be converted to lowercase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This sounds like a lot of rules, but with Django, it is simple if we tackle
    them one by one. We will carry on with the `form_project` app we started in *Chapter
    6*, *Forms*. If you haven''t completed *Chapter 6*, *Forms*, you can download
    the code from [http://packt.live/2LRCczP](http://packt.live/2LRCczP):'
  prefs: []
  type: TYPE_NORMAL
- en: In PyCharm, open the `form_example` app's `forms.py` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Make sure the Django dev server is not running, otherwise, it may crash as you
    make changes to this file, causing PyCharm to jump into the debugger.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since our work with `ExampleForm` is done, you can remove it from this file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new class called `OrderForm` that inherits from `forms.Form`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add four fields to the class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`magazine_count,` `IntegerField` with `min_value` of `0` and `max_value` of
    `80`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`book_count`, `IntegerField` with `min_value` of `0` and `max_value` of `50`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`send_confirmation`, `BooleanField`, which is not required'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`, `EmailField`, which is also not required'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The class should look like this:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a validation function to check that the user''s email address is on the
    right domain. First, `ValidationError` needs to be imported; add this line at
    the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then write this function after the `import` line (before the `OrderForm` class implementation):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function splits the email address on the `@` symbol, then checks whether
    the part after it is equal to `example.com`. This function alone would validate
    non-email addresses. For example, the string `not-valid@someotherdomain@example.com`
    would not cause `ValidationError` to be raised in this function. This is acceptable
    in our case because as we are using `EmailField`, the other standard field validators
    will check the email address validity.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the `validate_email_domain` function as a validator to the `email` field
    on `OrderForm`. Update the `EmailField` constructor call to add a `validators`
    argument, passing in a list containing the validation function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `clean_email` method to the form to make sure the email address is lowercase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the `clean` method to perform all the cross-field validation. First,
    we will just add the logic for making sure that an email address is only entered
    if an order confirmation is requested:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the final check, also inside the `clean` method. The total number of items
    should not be more than 100\. We will add a non-field error if the sum of `magazine_count`
    and `book_count` is greater than 100:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `reviews` app''s `views.py` file. We will change the form `import`
    so that `OrderForm` is being imported instead of `ExampleForm`. Consider the following
    import line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change it as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `form_example` view, change the two lines that use `ExampleForm` to
    use `OrderForm` instead. Consider the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change this as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, consider the following line of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change this as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The rest of the function can stay as it is.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We don''t have to make changes to the template. Start the Django dev server
    and navigate to `http://127.0.0.1:8000/form-example/` in your browser. You should
    see the form rendered as in *Figure 7.10*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.10: OrderForm in the browser'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_07_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.10: OrderForm in the browser'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Try submitting the form with a `Magazine count` of `80` and `Book count` of
    `50`. The browser will allow this, but as they sum to more than 100, an error
    will be triggered by the `clean` method in the form and displayed on the page:![Figure
    7.11: A non-field error displayed on the form when'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the maximum number of allowed items is exceeded
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_07_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.11: A non-field error displayed on the form when the maximum number
    of allowed items is exceeded'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Try submitting the form with `Send confirmation` checked but the `Email` field
    blank. Then fill the `Email` textbox but uncheck `Send confirmation`. Either combination
    will give an error that both must be present. The error will differ based on which
    field is missing:![Figure 7.12: Error message if no email address is present'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_07_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.12: Error message if no email address is present'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now try submitting the form with `Send confirmation` checked and an email address
    that is on the `example.com` domain. You should receive a message that your email
    address must have the domain `example.com`. You should also receive a message
    that `email` must be set – since email does not end up in the `cleaned_data` dictionary,
    as it is not valid:![Figure 7.13: The error message is shown when the email domain
    is not example.com'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_07_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.13: The error message is shown when the email domain is not example.com'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, enter valid values for `Magazine count` and `Book count` (such as
    `20` and `20`). Check `Send confirmation`, and enter `UserName@Example.Com` as
    the email (make sure you match the letter case, including the mixed uppercase
    and lowercase characters):![Figure 7.14: The form after being submitted with valid
    values'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_07_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.14: The form after being submitted with valid values'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Switch to PyCharm and look in the debug console. You''ll see that the email
    has been converted to lowercase when it is printed by our debug code:![Figure
    7.15: Email in lowercase, as well as other fields'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_07_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.15: Email in lowercase, as well as other fields'
  prefs: []
  type: TYPE_NORMAL
- en: This is our `clean_email` method in action – even though we entered data in
    both uppercase and lowercase, it has been converted to all lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we created a new `OrderForm` that implemented form and field
    clean methods. We used a custom validator to ensure that the `Email` field met
    our specific validation rules – only a specific domain was allowed. We used a
    custom field cleaning method (`clean_email`) to convert the email address to lowercase.
    We then implemented a `clean` method to validate the forms that were dependent
    on each other. In this method, we added both field and non-field errors. In the
    next section, we will cover how to add placeholders and initial values to the
    form.
  prefs: []
  type: TYPE_NORMAL
- en: Placeholders and Initial Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two things our first manually built form had that our current Django
    form still does not have –placeholders and initial values. Adding placeholders
    is simple; they are just added as an attribute to the widget constructor for the
    form field. This is similar to what we have already seen for setting the type
    of `DateField` in our previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the preceding form looks like when rendered in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16: Django form with placeholders'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_07_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.16: Django form with placeholders'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if we are manually setting `Widget` for each field, we need to know
    which `Widget` class to use. The ones that support placeholders are `TextInput`,
    `NumberInput`, `EmailInput`, `URLInput`, `PasswordInput`, and `Textarea`.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we are examining the `Form` class itself, we will look at the first of
    two ways of setting an initial value for a field. We can do it by using the `initial`
    argument on a `Field` constructor, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The other method is to pass in a dictionary of data when instantiating the
    form in our view. The keys are the field names. The dictionary should have zero
    or more items (that is, an empty dictionary is valid). Any extra keys are ignored.
    This dictionary should be supplied as the `initial` argument in our view as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Or for a `POST` request, pass in `request.POST` as the first argument, as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Values in `request.POST` will override values in `initial`. This means that
    even if we have an initial value for a required field, if it is left blank when
    submitted, then it will not validate. The field will not fall back to the value
    in `initial`.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you decide to set initial values in the `Form` class itself or the view
    is up to you and depends on your use case. If you had a form that was used in
    multiple views but usually had the same value, it would be better to set the `initial`
    value in the form. Otherwise, it can be more flexible to use `setting` in the
    view.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will add placeholders and initial values to the `OrderForm`
    class from the previous exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.02: Placeholders and Initial Values'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will enhance the `OrderForm` class by adding placeholder
    text. You will simulate passing an initial email address to the form. It will
    be a hardcoded address, but once the user can log in, it could be an email address
    associated with their account – you will learn about sessions and authentication
    in *Chapter 9*, *Sessions and Authentication*:'
  prefs: []
  type: TYPE_NORMAL
- en: In PyCharm, open the `reviews` app's `forms.py` file. You will add placeholders
    to the `magazine_count`, `book_count`, and `email` fields on the `OrderForm`,
    which means also setting the `widget`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To the `magazine_count` field, add a `NumberInput` `widget` with `placeholder`
    in the `attrs` dictionary. The `placeholder` should be set to *Number of Magazines*.
    Write the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a placeholder to the `book_count` field in the same manner. The placeholder
    text should be `Number of Books`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final change to `OrderForm` is to add a placeholder to the email field.
    This time the widget is `EmailInput`. The placeholder text should be `Your company
    email address`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `clean_email` and `clean` methods should remain as they were in
    *Exercise 7.01, Custom Clean and Validation Methods*. Save the file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `reviews` app''s `views.py` file. In the `form_example` view function,
    create a new dictionary variable called `initial` with one key, `email`, like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the two places that you are instantiating `OrderForm`, also pass in the
    `initial` variable using the `initial` kwarg. The first instance is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second instance is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code for `views.py` can be found at [http://packt.live/3szaPM6](http://packt.live/3szaPM6).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Save the `views.py` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the Django dev server if it is not already running. Browse to `http://127.0.0.1:8000/form-example/`
    in your browser. You should see that your form now has placeholders and an initial
    value set:![Figure 7.17: Order form with initial values and placeholders'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_07_17.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.17: Order form with initial values and placeholders'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we added placeholders to form fields. This was done by setting
    a `form` widget when defining the `form` field on the form class and setting a
    *placeholder* value in the `attrs` dictionary. We also set an initial value for
    the form using a dictionary and passing it to the `form` instance using the `initial`
    kwarg.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will talk about how to work with Django models using
    data from forms, and how `ModelForm` makes this easier.
  prefs: []
  type: TYPE_NORMAL
- en: Creating or Editing Django Models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have seen how to define a form, and in *Chapter 2*, *Models and Migrations*,
    you learned how to create Django model instances. By using these things together,
    you could build a view that displayed a form and also saved a model instance to
    the database. This gives you an easy method to save data without having to write
    a lot of boilerplate code or create custom forms. In Bookr, we will use this method
    to allow users to add reviews without requiring access to the Django admin site.
    Without using `ModelForm`, we could do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: We can create a form based on an existing model, for example, `Publisher`. The
    form would be called `PublisherForm`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can manually define the fields on `PublisherForm`, using the same rules
    defined on the `Publisher` model, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the view, the `initial` values would be retrieved from the model queried
    from the database, then passed to the form using the `initial` argument. If we
    were creating a new instance, the `initial` value would be blank – something like
    this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, in the `POST` flow of the view, we can either create or update the model
    based on `cleaned_data`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a lot of work, and we have to consider how much duplicated logic we
    have. For example, we are defining the length of the name in the `name` form field.
    If we made a mistake here, we could allow a longer name in the field than the
    model allows. We also have to remember to set all the fields in the `initial`
    dictionary, as well as setting the values on the new or updated model with `cleaned_data`
    from the form. There are many opportunities to make mistakes here, as well as
    remembering to add or remove field setting data for each of these steps if the
    model changes. All this code would have to be duplicated for each Django model
    you work with as well, expounding the duplication problem.
  prefs: []
  type: TYPE_NORMAL
- en: The ModelForm Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Luckily, Django provides a method of building `Model` instances from forms
    much more simply, with the `ModelForm` class. `ModelForm` is a form that is built
    automatically from a particular model. It will inherit the validation rules from
    the model (such as whether fields are required or the maximum length of `CharField`
    instances, and so on). It provides an extra `__init__` argument (called `instance`)
    to automatically populate the initial values from an existing model. It also adds
    a `save` method to automatically persist the form data to the database. All that
    needs to be done to set up `ModelForm` is to specify its model and what fields
    should be used: this is done on the `class Meta` attribute of the `form` class.
    Let us see how to build a form from `Publisher`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the file that contains the form (for example, the `forms.py` file we
    have been working with), the only change is that the model must be imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the `Form` class can then be defined. The class requires a `class Meta`
    attribute, which in turn must define a `model` attribute and either `fields` or
    `excludes` attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`fields` is a list or tuple of the fields to include in the form. When manually
    setting the list of fields, if you add extra fields to the model, you must also
    add their name here to have them displayed on the form.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the special value `__all__` instead of a list or tuple to
    automatically include all the fields, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If the `model` field has its `editable` attribute set to `False`, then it will
    not be automatically included.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the contrary, the `exclude` attribute sets the fields to not display in
    the form. Any fields added to the model will automatically be added to the form.
    We could define the preceding form using `exclude` with any empty tuple since
    we want all the fields. The code is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This saves some work because you don't need to add a field to both the model
    and in the `fields` list, however, it is not as safe, as you might automatically
    expose fields to the end user that you don't want to. For example, if you had
    a `User` model with `UserForm`, you might add an `is_admin` field to the `User`
    model to give admin users extra privileges. If this field did not have the `exclude`
    attribute, it would be displayed to the user. A user would then be able to make
    themselves an administrator, which is something you probably wouldn't want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whichever of these three approaches to choosing the forms to display that we
    decide to use, in our case, they will display the same in the browser. This is
    because we are choosing to display *all* the fields. They all look like this when
    rendered in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.18: PublisherForm'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_07_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.18: PublisherForm'
  prefs: []
  type: TYPE_NORMAL
- en: Note that `help_text` from the `Publisher` model is automatically rendered as well.
  prefs: []
  type: TYPE_NORMAL
- en: Usage in a view is similar to the other forms we have seen. Also, as mentioned,
    there is an extra argument that can be provided, called `instance`. This can be
    set to `None`, which will render an empty form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming, in your view function, you have some method of determining whether
    you are creating or editing a model instance (we will discuss how to do this later),
    this will determine a variable called `is_create` (`True` if creating an instance,
    or `False` if editing an existing one). Your view function to create the form
    could then be written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in either branch, the instance is passed to the `PublisherForm`
    constructor, although it is `None` if we are in create mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the form is valid, we can then save the `model` instance. This is done simply
    by calling the `save` method on the form. This will automatically create the instance,
    or simply save changes to the old one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `save` method returns the `model` instance that was saved. It takes one
    optional argument, `commit`, which determines whether the changes should be written
    to the database. You can pass `False` instead, which allows you to make additional
    changes to the instance before manually saving the changes. This would be required
    to set attributes that have not been included in the form. As we mentioned, maybe
    you would set the `is_admin` flag to `False` on a `User` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In *Activity 7.02*, *Review Creation UI*, at the end of this chapter, we will
    be using this feature as well.
  prefs: []
  type: TYPE_NORMAL
- en: If your model uses `ManyToMany` fields, and you also call `form.save(False)`,
    you should also call `form.save_m2m()` to save any many-to-many relationships
    that have been set. It is not necessary to call this method if you call the form
    `save` method with `commit` set to `True` (that is, the default).
  prefs: []
  type: TYPE_NORMAL
- en: 'Model forms can be customized by making changes to their `Meta` attributes.
    The `widgets` attribute can be set. It can contain a dictionary keyed on the field
    names, with widget classes or instances as the values. For example, this is how
    to set up `PublisherForm` to have placeholders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The values behave the same as setting the `kwarg` widget in the field definition;
    they can be a class or an instance. For example, to display `CharField` as a password
    input, the `PasswordInput` class can be used; it does not need to be instantiated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Model forms can also be augmented with extra fields added in the same way as
    they are added to a normal form. For example, suppose we wanted to give the option
    of sending a notification email after saving a `Publisher` object. We can add
    an `email_on_save` field to `PublisherForm` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When rendered, the form looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.19: PublisherForm with an additional field'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_07_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.19: PublisherForm with an additional field'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional fields are placed after the `Model` fields. The extra fields are
    not handled automatically – they do not exist on the model, so Django won''t attempt
    to save them on the `model` instance. Instead, you should handle the saving of
    their values by examining the `cleaned_data` values of the form, as you would
    with a standard form, for example (inside your view function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the next exercise, you will write a new view function to create or edit a `Publisher`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.03: Creating and Editing a Publisher'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will return to Bookr. We want to add the ability to create
    and edit a `Publisher` without using the Django admin. To do this, we will add
    a `ModelForm` for the `Publisher` model. It will be used in a new view function.
    The view function will take an optional argument, `pk`, which will either be the
    ID of the `Publisher` being edited or `None` to create a new `Publisher`. We will
    add two new URL maps to facilitate this. When this is complete, we will be able
    to see and update any publisher using their ID. For example, information for `Publisher
    1` will be viewable/editable at URL path `/publishers/1`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In PyCharm, open the `reviews` app''s `forms.py` file. After the `forms` import,
    also import the `Publisher` model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `PublisherForm` class, inheriting from `forms.ModelForm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `class Meta` attribute on `PublisherForm`. The attributes that `Meta`
    requires are the model (`Publisher`) and fields (`"__all__"`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save `forms.py`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The complete file can be found at [http://packt.live/3qh9bww](http://packt.live/3qh9bww).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `reviews` app''s `views.py` file. At the top of the file, import `PublisherForm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure you import the `get_object_or_404` and `redirect` functions from
    `django.shortcuts`, if you aren''t already:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also make sure you''re importing the `Publisher` model if you aren''t already.
    You may already be importing this and other models:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final import you will need is the `messages` module. This will allow us
    to register a message letting the user know that a `Publisher` object was edited
    or created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once again, add this import if you do not already have it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new view function called `publisher_edit`. It takes two arguments,
    `request` and `pk` (the ID of the `Publisher` object to edit). This is optional,
    and if it is `None`, then a `Publisher` object will be created instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the view function, we need to try to load the existing `Publisher` instance
    if `pk` is not `None`. Otherwise, the value of `publisher` should be `None`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After getting a `Publisher` instance or `None`, complete the branch for a `POST`
    request. Instantiate the form in the same way as seen earlier in the chapter,
    but now make sure that it takes `instance` as a kwarg. Then, if the form is valid,
    save it using the `form.save()` method. The method will return the updated `Publisher`
    instance, which is stored in the `updated_publisher` variable. Then, register
    a different success message depending on whether the `Publisher` instance was
    created or updated. Finally, redirect back to this `publisher_edit` view, since
    `updated_publisher` will always have an ID at this point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the form is not valid, the execution falls through to just return the `render`
    function call with the invalid form (this will be implemented in *step 12*). The
    redirect uses a named URL map, which will be added later in the exercise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, fill in the non-`POST` branch of the code. In this case, just instantiate
    the form with the `instance`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, you can reuse the `form-example.html` file that you''ve used in previous
    exercises. Render it with the `render` function, passing in the HTTP method and
    `form` as the context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save this file. You can refer to it at [http://packt.live/3nI62En](http://packt.live/3nI62En).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open `urls.py` in the `reviews` directory. Add two new URL maps; they will both
    go to the `publisher_edit` view. One will capture the ID of `Publisher` we want
    to edit and pass it into the view as the `pk` argument. The other will use the
    word `new` instead, and will not pass the `pk`, which will indicate we want to
    create a new `Publisher`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To your `urlpatterns` variable, add the path `'publishers/<int:pk>/'` mapping
    to the view `reviews.views.publisher_edit`, with the name of `'publisher_edit'`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Also, add the path `''publishers/new/''` mapping to the `reviews.views.publisher_edit`
    view, with the name of `''publisher_create''`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since the second mapping does not capture anything, the `pk` that is passed
    to the `publisher_detail` view function is `None`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Save the `urls.py` file. The completed version for reference is at [http://packt.live/39CpUnw](http://packt.live/39CpUnw).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `form-example.html` file inside the `reviews` app''s `templates` directory.
    Since this is a standalone template (it does not extend any other templates),
    we need to render the messages inside it. Add this code just after the opening
    `<body>` tag to iterate through all the messages and display them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will loop over the messages we have added and display the tag (in our case,
    `Success`) and then the message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, add the normal form rendering and submission code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save and close this file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can refer to the full version of this file at [http://packt.live/38I8XZx](http://packt.live/38I8XZx).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the Django dev server, then navigate to `http://127.0.0.1:8000/publishers/new/`.
    You should see a blank `PublisherForm` being displayed:![Figure 7.20: Blank publisher
    form'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_07_20.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.20: Blank publisher form'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The form has inherited the model''s validation rules, so you cannot submit
    the form with too many characters for `Name`, or with an invalid `Website` or
    `Email`. Put in some valid information, then submit the form. After submission,
    you should see the success message and the form will be populated with information
    that was saved to the database:![Figure 7.21: Form after submission'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_07_21.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.21: Form after submission'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the URL has also been updated and now includes the ID of the publisher
    that was created. In this case, it is `http://127.0.0.1:8000/publishers/19/` but
    the ID on your setup will depend on how many `Publisher` instances were already
    in your database.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that if you refresh the page, you will not receive a message confirming
    whether you want to re-send the form data. This is because we redirected after
    saving, so it is safe to refresh this page as many times as you want, and no new
    `Publisher` instances will be created. If you had not redirected it, then every
    time the page was refreshed, a new `Publisher` instance would be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have other `Publisher` instances in your database, you can change the
    ID in the URL to edit other ones. Since the ID in this instance is `3`, we can
    assume that `Publisher` `1` and `Publisher` `2` already exist and can substitute
    in their IDs to see the existing data. Here is the view of the existing `Publisher
    1` (at `http://127.0.0.1:8000/publishers/1/`) – your information may be different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.22: Existing Publisher 1 information'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_07_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.22: Existing Publisher 1 information'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try making changes to the existing `Publisher` instance. Notice that after
    you save, the message is different – it is telling the user that the `Publisher`
    instance was *updated* rather than *created*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.23: Publisher after updating instead of creating'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_07_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.23: Publisher after updating instead of creating'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we implemented a `ModelForm` from a model (`PublisherForm`
    was created from `Publisher`) and saw how Django automatically generated the form
    fields with the correct validation rules. We then used the form's built-in `save`
    method to save changes to the `Publisher` instance (or automatically create it)
    inside the `publisher_edit` view. We mapped two URLs to the view. The first URL,
    which was for editing an existing `Publisher`, passed `pk` to the view. The other
    did not pass `pk` to the view, indicating that the `Publisher` instance should
    be created. Finally, we used the browser to experiment with creating a new `Publisher`
    instance and then editing an existing one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 7.01: Styling and Integrating the Publisher Form'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Exercise 7.03*, *Creating and Editing a Publisher*, you added `PublisherForm`
    to create and edit `Publisher` instances. You built this with a standalone template
    that did not extend any other templates, so it lacked the global styles. In this
    activity, you will build a generic form detail page that will display a Django
    form, similar to `form-example.html` but extending from a base template. The template
    will accept a variable to display the type of model being edited. You will also
    update the main `base.html` template to render the Django messages, using Bootstrap
    styling.
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by editing the `base.html` project. Wrap the `content` block in a container
    `div` for a nicer layout with some spacing. Surround the existing `content` block
    with a `<div>` element with `class="container-fluid"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Render each `message` in `messages` (similar to *step 14* of *Exercise 7.03*,
    *Creating and Editing a Publisher*). Add the `{% for %}` block after the `<div>`
    you just created but before the `content` block. You should use the Bootstrap
    framework classes – this snippet will help you:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Bootstrap class and Django `message` tags have corresponding names for the
    most part (for example, `success` and `alert-success`). The exception is Django's
    `error` tag. The corresponding Bootstrap class is `alert-danger`. See more information
    about Bootstrap alerts at [https://getbootstrap.com/docs/4.0/components/alerts/](https://getbootstrap.com/docs/4.0/components/alerts/).
    This is why you need to use the `if` template tag in this snippet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a new template called `instance-form.html`, inside the `reviews` app's
    namespaced `templates` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`instance-form.html` should extend from the `reviews` app''s `base.html`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The context being passed to this template will contain a variable called `instance`.
    This will be the `Publisher` instance being edited, or `None` if we are creating
    a new `Publisher` instance. The context will also contain a `model_type` variable,
    which is a string indicating the model type (in this case, `Publisher`). Use these
    two variables to populate the `title` block template tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the instance is `None`, the title should be `New Publisher`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Otherwise, the title should be `Editing Publisher <Publisher Name>`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`instance-form.html` should contain a `content` `block` template tag to override
    the `base.html` `content` block.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `<h2>` element inside the `content` block and populate it using the same
    logic as the title. For better styling, wrap the publisher name in an `<em>` element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `<form>` element to the template with a `method` of `post`. Since we are
    posting back to the same URL, an `action` does not need to be specified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include the CSRF token template tag in the `<form>` body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Render the Django form (its context variable will be `form`) inside `<form>`,
    using the `as_p` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `submit` `<button>` to the form. Its text should depend on whether you
    are editing or creating. Use the text `Save` for editing or `Create` for creating.
    You can use the Bootstrap classes for the button styling here. It should have
    the attribute `class="btn btn-primary"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `reviews/views.py`, the `publisher_edit` view does not need many changes.
    Update the `render` call to render `instance-form.html` instead of `form-example.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the context dictionary being passed to the `render` call. It should include
    the `Publisher` instance (the `publisher` variable that was already defined) and
    `model_type` string. The context dictionary already includes `form` (a `PublisherForm`
    instance). You can remove the `method` key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we're finished with the `form-example.html` template, it can be deleted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you''ve finished, the `Publisher` creation page (at `http://127.0.0.1:8000/publishers/new/`)
    should look like *Figure 7.24*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.24: The Publisher creation page'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_07_24.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.24: The Publisher creation page'
  prefs: []
  type: TYPE_NORMAL
- en: 'When editing a `Publisher` (for example, at the URL `http://127.0.0.1:8000/publishers/1/`),
    your page should look like *Figure 7.25*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.25: The Editing Publisher page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_07_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.25: The Editing Publisher page'
  prefs: []
  type: TYPE_NORMAL
- en: 'After saving a `Publisher` instance, whether creating or editing, you should
    see the success message at the top of the page (*Figure 7.26*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.26: Success message rendered as a Bootstrap alert'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_07_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.26: Success message rendered as a Bootstrap alert'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 7.02: Review Creation UI'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Activity 7.01*, *Styling and Integrating the Publisher Form*, was quite extensive;
    however, by completing it, you have created a foundation that makes it easier
    to add other *edit* and *create* views. You will experience this first-hand in
    this activity when you will build forms for creating and editing reviews. Because
    the `instance-form.html` template was made generically, you can reuse it in other
    views.'
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, you will create a review `ModelForm`, then add a `review_edit`
    view to create or edit a `Review` instance. You can reuse `instance-form.html`
    from *Activity 7.01*, *Styling and Integrating the Publisher Form*, and pass in
    different context variables to make it work with the `Review` model. When working
    with reviews, you will operate within the context of a book, that is, the `review_edit`
    view must accept a book's `pk` as an argument. You will fetch the `Book` instance
    separately and assign it to the `Review` instance that you create.
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: In `forms.py`, add a `ReviewForm` subclass of `ModelForm`; its model should
    be `Review` (make sure you `import` the `Review` model).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ReviewForm` should exclude the `date_edited` and `book` fields since the user
    should not be setting these in the form. The database allows any rating, but we
    can override the `rating` field with an `IntegerField` that requires a minimum
    value of *0* and a maximum value of *5*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new view called `review_edit`. It should accept two arguments after
    `request`: `book_pk`, which is required, and `review_pk`, which is optional (defaults
    to `None`). Fetch the `Book` instance and `Review` instance using the `get_object_or_404`
    shortcut (call it once for each type). When fetching the review, make sure the
    review belongs to the book. If `review_pk` is `None`, then the `Review` instance
    should be `None` too.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `request` method is `POST`, then instantiate a `ReviewForm` using `request.POST`
    and the review instance. Make sure you `import` the `ReviewForm`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the form is valid, save the form but set the `commit` argument to `save`
    to `False`. Then, set the `book` attribute on the returned `Review` instance to
    the book fetched in *step 2*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the `Review` instance was being updated instead of created, then you should
    also set the `date_edited` attribute to the current date and time. Use the `from`
    `django.utils.timezone.now()` function. Then, save the `Review` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finish the valid form branch by registering a success message and redirecting
    back to the `book_detail` view. Since the `Review` model doesn't really contain
    a meaningful text description, use the book title in the message. For example,
    `Review for "<book title>" created`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `request` method is not `POST`, instantiate a `ReviewForm` and just pass
    in the `Review` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Render the `instance-form.html` template. In the context dictionary, include
    the same items as were used in `publisher_view`: `form`, `instance`, and `model_type`
    (`Review`). Include two extra items, `related_model_type`, which should be `Book`,
    and `related_instance`, which will be the `Book` instance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit `instance-form.html` to add a place to display the related instance information
    added in *step 6*. Under the `<h2>` element, add a `<p>` element that is only
    displayed if both `related_model_type` and `related_instance` are set. It should
    show the text `For <related_model_type> <related_instance>`. For example: `For
    Book Advanced Deep Learning with Keras`. Put the `related_instance` output in
    an `<em>` element for better readability.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `reviews` app's `urls.py` file, add URL maps to the `review_edit` view.
    The URLs `/books/` and `/books/<pk>/` are already configured. Add the URLs `/books/<book_pk>/reviews/new/`
    to create a review, and `/books/<book_pk>/reviews/<review_pk>/` to edit a review.
    Make sure you give these names such as `review_create` and `review_edit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `book_detail.html` template, add links that a user can click to create
    or edit a review. Add a link inside the `content` block, just before the `endblock`
    closing template tag. It should use the `url` template tag to link to the `review_edit`
    view when in creation mode. Also, use the attribute `class="btn btn-primary"`
    to make the link display like a Bootstrap button. The link text should be `Add
    Review`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, add a link to edit a review, inside the `for` loop that iterates over
    `Reviews` for `Book`. After all the instances of `text-info` `<span>`, add a link
    to the `review_edit` view using the `url` template tag. You will need to provide
    `book.pk` and `review.pk` as arguments. The text of the link should be `Edit Review`.
    When you are finished, the `Review Comments` page should look like *Figure 7.27*:![Figure
    7.27: Book detail page with added Add Review button'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_07_27.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.27: Book detail page with added Add Review button'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the `Add Review` button. Clicking it will take you to the `Create
    Book Review` page, which should look like *Figure 7.28*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.28: Review creation page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_07_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.28: Review creation page'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter some details in the form and click `Create`. You will be redirected to
    the `Book Details` page, and you should see the success message and your review,
    as in *Figure 7.29*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.29: Book Details page with review added'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_07_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.29: Book Details page with review added'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also see the `Edit Review` link, and if you click it, you will be taken
    to a form that is pre-populated with your review data (see *Figure 7.30*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.30: Review form when editing a review'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_07_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.30: Review form when editing a review'
  prefs: []
  type: TYPE_NORMAL
- en: 'After saving an existing review, you should see the `Modified on` date is updated
    on the `Book Details` page (*Figure 7.31*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.31: The Modified on date is now populated'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_07_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.31: The Modified on date is now populated'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was a deep dive into forms. We saw how to enhance Django forms
    with custom validation advanced rules for cleaning data and validating fields.
    We saw how custom cleaning methods can transform the data that we get out of forms.
    A nice feature we saw that can be added to forms is the ability to set initial
    and placeholder values on fields, so the user does not have to fill them out.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at how to use the `ModelForm` class to automatically create a
    form from a Django model. We saw how to only show some fields to the user and
    how to apply custom form validation rules to the `ModelForm`. We also saw how
    Django can automatically save the new or updated model instance to the database
    inside the view. In the activities for this chapter, we enhanced Bookr some more
    by adding forms for creating and editing publishers and submitting reviews. The
    next chapter will carry on the theme of submitting user input, and along with
    that, we'll discuss how Django handles uploading and downloading files.
  prefs: []
  type: TYPE_NORMAL
