- en: 7\. Advanced Form Validation and Model Forms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 高级表单验证和模型表单
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: Continuing your journey with the Bookr application, you will begin this chapter
    by adding a new form to your app with custom multi-field validation and form cleaning.
    You will learn how to set the initial values on your form and customize the widgets
    (the HTML input elements that are being generated). Then you will be introduced
    to the `ModelForm` class, which allows a form to be automatically created from
    a model. You will use it in a view to automatically save the new or changed `Model`
    instance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续使用Bookr应用程序的旅程中，你将开始本章，通过添加一个新的表单到你的应用程序中，并使用自定义的多字段验证和表单清理。你将学习如何设置表单的初始值并自定义小部件（正在生成的HTML输入元素）。然后，你将介绍`ModelForm`类，它允许从模型自动创建表单。你将在视图中使用它来自动保存新的或更改的`Model`实例。
- en: By the end of this chapter, you will know how to add extra multi-field validation
    to Django forms, how to customize and set form widgets for fields, how to use
    `ModelForms` to automatically create a form from a Django model, and how to automatically
    create `Model` instances from `ModelForms`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将知道如何为Django表单添加额外的多字段验证，如何自定义和设置字段的表单小部件，如何使用`ModelForms`从Django模型自动创建表单，以及如何从`ModelForms`自动创建`Model`实例。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter builds upon the knowledge we gained in *Chapter 6*, *Forms*, where
    we learned how to submit data from an HTML form to a Django view, both with a
    manually built HTML form and with a Django form. We used Django's `form` library
    to build and automatically validate forms with basic validation. For example,
    now we can build forms that check whether a date is entered in its desired format,
    whether a number is input where a user must enter their age, and whether a dropdown
    is selected before the user clicks the `Submit` button. However, most large-scale
    websites require validation that is a bit more advanced.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章建立在我们在*第6章*，*表单*中获得的知识之上，我们学习了如何从HTML表单提交数据到Django视图，无论是手动构建的HTML表单还是Django表单。我们使用了Django的`form`库来构建和自动验证具有基本验证的表单。例如，现在我们可以构建检查日期是否以期望的格式输入的表单，是否在用户输入年龄时输入了数字，以及用户点击`提交`按钮之前是否选择了下拉菜单。然而，大多数大型网站需要更高级的验证。
- en: 'For instance, a certain field might only be required if another field is set.
    Let''s say we want to add a checkbox to allow users to sign up for our monthly
    newsletter. It has a textbox below it that lets them enter their email address.
    With some basic validation, we can check whether:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，某个字段可能只有在另一个字段被设置时才是必需的。假设我们想添加一个复选框，允许用户注册我们的月度通讯录。它下面有一个文本框，让他们输入他们的电子邮件地址。通过一些基本的验证，我们可以检查以下内容：
- en: The user has checked the checkbox.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户是否勾选了复选框。
- en: The user has entered their email address.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户已经输入了他们的电子邮件地址。
- en: When the user clicks the `Submit` button, we will be able to validate whether
    both fields are actioned. But what if the user doesn't want to sign up for our
    newsletter? If they click the `Submit` button, ideally, both fields should be
    blank. That's where validating each individual field might not work.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击`提交`按钮时，我们将能够验证两个字段是否都被操作。但如果用户不想注册我们的通讯录呢？如果他们点击`提交`按钮，理想情况下，两个字段都应该为空。这就是验证每个单独字段可能不起作用的地方。
- en: Another example could be a case where we have two fields and each has a maximum
    value of, say, 50\. But the total of values added to each one must be less than
    75\. We will start the chapter by looking at how to write custom validation rules
    to solve such problems.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子可能是有两个字段，每个字段的最高值是，比如说，50。但每个字段添加的总值必须小于75。我们将从查看如何编写自定义验证规则来解决此类问题开始本章。
- en: Later, as we progress in the chapter, we will look at how to set initial values
    on a form. This can be useful when automatically filling out information that
    is already known to the user. For example, we can automatically put a user's contact
    information into a form if that user is logged in.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本章的深入，我们将探讨如何在表单上设置初始值。这在自动填写用户已知的信息时可能很有用。例如，如果用户已登录，我们可以自动将用户的联系信息放入表单中。
- en: We will finish the chapter by looking at model forms, which will let us automatically
    create a form from a Django `Model` class. This cuts down the amount of code that
    needs to be written to create a new `Model` instance.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过查看模型形式来结束本章，这将使我们能够自动从Django `Model`类创建一个表单。这减少了创建新的`Model`实例所需编写的代码量。
- en: Custom Field Validation and Cleaning
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义字段验证和清理
- en: We have seen how a Django form converts values from an HTTP request, which are
    strings, into Python objects. In a non-custom Django form, the target type is
    dependent on the field class. For example, the Python type derived from `IntegerField`
    is `int`, and string values are given to us verbatim, as the user entered them.
    But we can also implement methods on our `Form` class to alter the output values
    from our fields in any way we choose. The allows us to clean or filter the user's
    input data to fit what we expect better. We could round an integer to the nearest
    multiple of ten to fit into a batch size for ordering specific items. Or we could
    transform an email address to lowercase so that the data is consistent for searching.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 Django 表单如何将 HTTP 请求中的值（字符串）转换为 Python 对象。在非自定义 Django 表单中，目标类型取决于字段类。例如，从
    `IntegerField` 衍生的 Python 类型是 `int`，字符串值将按用户输入的原文提供给我们。但我们可以为我们的 `Form` 类实现方法，以任何我们选择的方式更改字段的输出值。这使我们能够清理或过滤用户的输入数据，使其更好地符合我们的预期。我们可以将整数四舍五入到最接近的十的倍数，以便适应批量大小以订购特定项目。或者，我们可以将电子邮件地址转换为小写，以便数据在搜索时保持一致性。
- en: 'We can also implement some custom validators. We will look at a couple of different
    ways of validating fields: by writing a custom validator, and by writing a custom
    `clean` method for the field. Each method has its pros and cons: a custom validator
    can be applied to different fields and forms, so you do not have to write the
    validation logic for each field; a custom `clean` method must be implemented on
    each form you want to clean, but is more powerful and allows validation using
    other fields in the form or changing the cleaned value that the field returns.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以实现一些自定义验证器。我们将探讨几种不同的验证字段的方法：通过编写自定义验证器，以及为字段编写自定义的 `clean` 方法。每种方法都有其优缺点：自定义验证器可以应用于不同的字段和表单，因此你不必为每个字段编写验证逻辑；自定义的
    `clean` 方法必须为每个你想要清理的表单实现，但它更强大，允许使用表单中的其他字段进行验证或更改字段返回的清理值。
- en: Custom Validators
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义验证器
- en: A validator is simply a function that accepts a value and raises `django.core.exceptions.ValidationError`
    if the value is invalid – the validity is determined by the code you write. The
    value is a Python object (that is, `cleaned_data` that has already been converted
    from the `POST` request string).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器是一个简单的函数，它接受一个值，如果该值无效，则引发 `django.core.exceptions.ValidationError` – 有效性由你编写的代码确定。该值是一个
    Python 对象（即，已经从 `POST` 请求字符串转换而来的 `cleaned_data`）。
- en: 'Here is a simple example that validates whether a value is lowercase:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的示例，用于验证值是否为小写：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice the function does not return anything, for either success or failure.
    It will just raise `ValidationError` if the value is not valid.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该函数对于成功或失败都不会返回任何内容。如果值无效，它将仅引发 `ValidationError`。
- en: Note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the behavior and handling of `ValidationError` differ from how other
    exceptions behave in Django. Normally, if you raise an exception in your view,
    you will end up with a `500` response from Django (if you do not handle the exception
    in your code).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ValidationError` 的行为和处理方式与 Django 中其他异常的行为不同。通常，如果你在视图中引发异常，你将得到 Django
    的 `500` 响应（如果你没有在代码中处理该异常）。
- en: When raising `ValidationError` in your validation/cleaning code, the Django
    `form` class will catch the error for you and then the `is_valid` method of `form`
    will return `False`. You do not have to write `try`/`except` handlers around the
    code that might raise `ValidationError`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当在验证/清理代码中引发 `ValidationError` 时，Django 的 `form` 类会为你捕获错误，然后 `form` 的 `is_valid`
    方法将返回 `False`。你不需要在可能引发 `ValidationError` 的代码周围编写 `try`/`except` 处理程序。
- en: 'The validator can be passed to the `validators` argument of a field constructor
    on a form, inside a list; for example, to our `text_input` field from our `ExampleForm`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器可以作为表单中字段构造函数的 `validators` 参数传递，在列表中；例如，将我们的 `text_input` 字段从我们的 `ExampleForm`
    传递：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, if we submit the form and the fields contain uppercase values, we will
    get an error, as shown in the following figure:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们提交表单并且字段包含大写值，我们将得到一个错误，如图下所示：
- en: '![Figure 7.1: Lowercase text validator in action'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1：小写文本验证器在作用中'
- en: '](img/B15509_07_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15509_07_01.jpg]'
- en: 'Figure 7.1: Lowercase text validator in action'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：小写文本验证器在作用中
- en: The validator function can be used on any number of fields. In our example,
    if we wanted lots of fields to have lowercase enforced, `validate_lowercase` could
    be passed to all of them. Let's now look at how we could implement this another
    way, with a custom `clean` method.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器函数可以用在任何数量的字段上。在我们的例子中，如果我们想强制许多字段使用小写，可以将`validate_lowercase`传递给所有这些字段。现在让我们看看我们如何以另一种方式实现它，使用自定义的`clean`方法。
- en: Cleaning Methods
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理方法
- en: A `clean` method is created on the `Form` class and is named in the format `clean_field-name`.
    For example, the `clean` method for `text_input` would be called `clean_text_input`,
    the `clean` method for `books_you_own` would be `clean_books_you_own`, and so
    on.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Form`类上创建了一个名为`clean_field-name`格式的`clean`方法。例如，`text_input`的`clean`方法将被调用为`clean_text_input`，`books_you_own`的`clean`方法将是`clean_books_you_own`，依此类推。
- en: Cleaning methods take no arguments; instead, they should use the `cleaned_data`
    attribute on `self` to access the field data. This dictionary will contain the
    data after being cleaned in the standard Django way, as we saw in the previous
    example. The `clean` method must return the cleaned value, which will replace
    the original value in the `cleaned_data` dictionary. Even if the method does not
    change the value, a value must be returned. You can also use the `clean` method
    to raise `ValidationError`, and the error will be attached to the field (the same
    as with a validator).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 清理方法不接受任何参数；相反，它们应该使用`self`上的`cleaned_data`属性来访问字段数据。这个字典将包含以标准Django方式清理后的数据，正如我们在前面的例子中所看到的。`clean`方法必须返回清理后的值，这将替换`cleaned_data`字典中的原始值。即使方法没有改变值，也必须返回一个值。你还可以使用`clean`方法来引发`ValidationError`，错误将被附加到字段（与validator相同）。
- en: 'Let''s re-implement the lowercase validator as a `clean` method, like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新实现小写验证器作为一个`clean`方法，如下所示：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can see the logic is essentially the same, except we must return the validated
    value at the end. If we submit the form, we get the same result as the previous
    time we tried (*Figure 7.1*).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到逻辑基本上是相同的，除了我们必须在最后返回验证过的值。如果我们提交表单，我们会得到与之前尝试时相同的结果（*图 7.1*）。
- en: 'Let''s look at one more cleaning example. Instead of raising an exception when
    the value is invalid, we could just convert the value to lowercase. We would implement
    that with this code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个清理示例。当值无效时，我们不是抛出异常，而是直接将值转换为小写。我们可以用以下代码实现：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, consider that we enter text into the input as uppercase:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑我们以大写形式输入文本到输入框中：
- en: '![Figure 7.2: ALL UPPERCASE text entered'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2：输入的全大写文本'
- en: '](img/B15509_07_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15509_07_02.jpg](img/B15509_07_02.jpg)'
- en: 'Figure 7.2: ALL UPPERCASE text entered'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：输入的全大写文本
- en: 'If we were to examine the cleaned data using our debug output from the view,
    we would see that it is lowercase:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用视图的调试输出检查清理后的数据，我们会看到它已经被转换为小写：
- en: '![Figure 7.3: The cleaned data has been transformed to lowercase'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.3：清理后的数据已转换为小写'
- en: '](img/B15509_07_03.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15509_07_03.jpg](img/B15509_07_03.jpg)'
- en: 'Figure 7.3: The cleaned data has been transformed to lowercase'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：清理后的数据已转换为小写
- en: These were just a couple of simple examples of how to validate fields using
    both validators and `clean` methods. You can, of course, make each type of validation
    much more complex if you wish and transform the data in more complex ways using
    a `clean` method.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是使用验证器和`clean`方法验证字段的一些简单示例。当然，如果你愿意，你可以使每种类型的验证更加复杂，并使用`clean`方法以更复杂的方式转换数据。
- en: So far, you have only learned simple methods for form validation, where you
    have treated each field independently. A field is valid (or not) based only on
    the information it contains and nothing else. What if the validity of one field
    depends on what the user entered into another field? An example of this might
    be that you have an `email` field to collect someone's email address if they want
    to be signed up to a mailing list. The field is only required if they check a
    checkbox that indicates they wanted to be signed up. Neither of these fields is
    required on their own – we do not want the checkbox to be required to be checked,
    but if it is checked, then the `email` field should be required too.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只学习了简单的表单验证方法，其中你独立地处理每个字段。一个字段是否有效（或无效）仅基于它包含的信息，而不是其他任何东西。如果某个字段的验证性依赖于用户在另一个字段中输入的内容怎么办？这种情况的一个例子可能是有`email`字段来收集某人的电子邮件地址，如果他们想要注册邮件列表。只有当他们在复选框中勾选表示他们想要注册时，该字段才是必需的。这两个字段本身都不是必需的——我们不希望复选框必须被勾选，但如果它被勾选，那么`email`字段也应该是必需的。
- en: In the next section, we will show how you can validate a form whose fields depend
    on each other by overriding the `clean` method in your form.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将展示如何通过在你的表单中重写 `clean` 方法来验证字段相互依赖的表单。
- en: Multi-Field Validation
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多字段验证
- en: We have just looked at the `clean_<field-name>` methods that can be added to
    a Django form, to clean a specific field. Django also allows us to override the
    `clean` method, in which we can access all the `cleaned_data` from all fields,
    and we know that all custom field methods have been called. This allows the validation
    of fields based on another field's data.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚查看的 `clean_<field-name>` 方法可以添加到 Django 表单中，以清理特定字段。Django 还允许我们重写 `clean`
    方法，在其中我们可以访问所有字段的 `cleaned_data`，并且我们知道所有自定义字段方法都已调用。这允许基于另一个字段的数据进行字段验证。
- en: Referring to our previous example with a form that has an email address that
    is only required if a checkbox is checked, we will see how we can implement this
    using the `clean` method.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 参考我们之前的示例，其中有一个只有在复选框被勾选时才需要的电子邮件地址的表单，我们将看到如何使用 `clean` 方法实现这一点。
- en: 'First, create a `Form` class and add two fields – make them both optional with
    the `required=False` argument:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个 `Form` 类并添加两个字段——使用 `required=False` 参数使它们都为可选：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We have also introduced two new arguments that can be used for any field:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还引入了两个新参数，可以用于任何字段：
- en: '`label`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label`'
- en: This allows setting the label text for a field. As we have seen, Django will
    automatically generate label text from the field name. If you set the `label`
    argument, you can override this default. Use this argument if you want to have
    a more descriptive label.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这允许设置字段的标签文本。正如我们所见，Django 将自动从字段名称生成标签文本。如果你设置 `label` 参数，你可以覆盖这个默认值。如果你想要一个更具描述性的标签，请使用此参数。
- en: '`help_text`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`help_text`'
- en: If you need to have more information displayed regarding what input a field
    requires, you can use this argument. By default, it is displayed after the field.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你需要显示有关字段所需输入的更多信息，你可以使用此参数。默认情况下，它显示在字段之后。
- en: 'When rendered, the form looks like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当渲染时，表单看起来像这样：
- en: '![Figure 7.4: Email signup form with custom label and help text'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.4：带有自定义标签和帮助文本的电子邮件注册表单](img/B15509_07_05.jpg)'
- en: '](img/B15509_07_04.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.5：尝试无电子邮件地址注册时显示的错误](img/B15509_07_04.jpg)'
- en: 'Figure 7.4: Email signup form with custom label and help text'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.4：带有自定义标签和帮助文本的电子邮件注册表单](img/B15509_07_05.jpg)'
- en: If we were to submit the form now, without entering any data, nothing would
    happen. Neither field is required, so the form validates fine.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在提交表单而不输入任何数据，将不会发生任何事情。两个字段都不是必需的，所以表单验证良好。
- en: Now we can add the multi-field validation to the `clean` method. We will check
    whether the `signup` checkbox is checked, and then check that the `email` field
    has a value. The built-in Django methods have already validated that the email
    address is valid at this point, so we then just need to check that a value exists
    for it. We will then use the `add_error` method to set an error for the `email`
    field. This is a method you haven't seen before but it's very simple; it takes
    two arguments – the name of the field to set the error on, and the text of the
    error.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将多字段验证添加到 `clean` 方法中。我们将检查 `signup` 复选框是否被勾选，然后检查 `email` 字段是否有值。内置的
    Django 方法已经验证了电子邮件地址的有效性，所以我们只需检查是否存在值。然后我们将使用 `add_error` 方法为 `email` 字段设置错误。这是一个你之前没有见过的方法，但它非常简单；它接受两个参数——设置错误的字段名称和错误文本。
- en: 'Here is the code for the `clean` method:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `clean` 方法的代码：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Your `clean` method must always call the `super().clean()` method to retrieve
    the cleaned data. When `add_error` is called to add errors to the form, the form
    will no longer validate (the `is_valid` method returns `False`).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `clean` 方法必须始终调用 `super().clean()` 方法来检索清理后的数据。当调用 `add_error` 添加错误到表单时，表单将不再验证（`is_valid`
    方法返回 `False`）。
- en: 'Now if we submit the form without the checkbox checked, there is still no error
    generated, but if you check the checkbox without an email address, you will receive
    the error we just wrote the code for:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们提交表单而不勾选复选框，仍然不会生成错误，但如果你勾选复选框而没有电子邮件地址，你将收到我们刚刚编写的代码错误：
- en: '![Figure 7.5: Error displayed when attempting to sign up with no email address'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.5：尝试无电子邮件地址注册时显示的错误](img/B15509_07_04.jpg)'
- en: '](img/B15509_07_05.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.4：带有自定义标签和帮助文本的电子邮件注册表单](img/B15509_07_04.jpg)'
- en: 'Figure 7.5: Error displayed when attempting to sign up with no email address'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.5：尝试无电子邮件地址注册时显示的错误](img/B15509_07_04.jpg)'
- en: You might notice that we are retrieving the email from the `cleaned_data` dictionary
    using the `get` method. The reason for doing this is if the `email` value in the
    form is invalid, then the `email` key will not exist in the dictionary. The browser
    should prevent the user from submitting the form if an invalid email has been
    entered, but a user might be using an older browser that does not support this
    client-side validation, so for safety, we use the `get` method. Since the `signup`
    field is `BooleanField`, and not required, it will only be invalid if a custom
    validation function is used. We are not using one here, so it is safe to access
    its value using square bracket notation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到我们正在使用`get`方法从`cleaned_data`字典中检索电子邮件。这样做的原因是，如果表单中的`email`值无效，那么`email`键将不会存在于字典中。浏览器应该阻止用户提交包含无效电子邮件的表单，但用户可能正在使用不支持此客户端验证的较旧浏览器，因此为了安全起见，我们使用`get`方法。由于`signup`字段是`BooleanField`，并且不是必需的，它只有在使用自定义验证函数时才会无效。我们在这里没有使用，所以使用方括号表示法访问其值是安全的。
- en: There is one more validation scenario to consider before moving on to our first
    exercise, and that is adding errors that are not specific to any field. Django
    calls these *non-field errors*. There are many scenarios where you might want
    to use these when multiple fields are dependent on each other.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行我们的第一个练习之前，还有一个需要考虑的验证场景，那就是添加不特定于任何字段的错误。Django将这些称为*非字段错误*。有许多场景，你可能想在多个字段相互依赖时使用这些错误。
- en: Take, for example, a shopping website. Your order form could have two numeric
    fields whose totals could not exceed a certain value. If the total were exceeded,
    the value of either field could be decreased to bring the total below the maximum
    value, so the error is not specific to either one of the fields. To add a non-field
    error, call the `add_error` method with `None` as the first argument.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以购物网站为例。你的订单表单可能包含两个数值字段，其总和不能超过某个值。如果总和超过了，任一字段的值可以减少以使总和低于最大值，因此错误不是特定于任一字段的。要添加非字段错误，请使用`add_error`方法，并将`None`作为第一个参数。
- en: 'Let us look at how to implement this. In this example, we will have a form
    where the user can specify a certain number of items to order, for item A or item
    B. The user cannot order more than 100 items in total. The fields will have a
    `max_value` of `100`, and `min_value` of `0`, but custom validation in the `clean`
    method will need to be written to handle the validation of the total amount:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现这一点。在这个例子中，我们将有一个表单，用户可以指定要订购的特定数量的项目，对于项目A或项目B。用户总共不能订购超过100个项目。字段将具有`max_value`为`100`和`min_value`为`0`，但需要在`clean`方法中编写自定义验证来处理总金额的验证：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The fields (`item_a` and `item_b`) are added in the normal way, with standard
    validation rules. You can see that we have used the `clean` method the same way
    we used it before. Moreover, we have implemented the maximum item logic inside
    this method. The following line is what registers the non-field error if the maximum
    items are exceeded:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 字段（`item_a`和`item_b`）以正常方式添加，并使用标准验证规则。你可以看到我们像以前一样使用了`clean`方法。此外，我们在该方法内部实现了最大项目逻辑。以下行是注册超过最大项目时记录非字段错误的：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once again, we access the values of `item_a` and `item_b` using the `get` method,
    with a default value of `0`. This is in case the user has an older browser (from
    2011 or earlier) and was able to submit the form with invalid values.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们使用`get`方法访问`item_a`和`item_b`的值，默认值为`0`。这是以防用户使用较旧的浏览器（2011年或更早）并能提交包含无效值的表单。
- en: 'In a browser, the field-level validation ensures values between 0 and 100 have
    been entered in each field, and prevents the form from being submitted otherwise:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，字段级验证确保每个字段都输入了0到100之间的值，否则将阻止表单提交：
- en: '![Figure 7.6: The form cannot be submitted if one field exceeds the maximum
    value'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.6：如果一个字段超过最大值，则无法提交表单'
- en: '](img/B15509_07_06.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15509_07_06.jpg](img/B15509_07_06.jpg)'
- en: 'Figure 7.6: The form cannot be submitted if one field exceeds the maximum value'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：如果一个字段超过最大值，则无法提交表单
- en: 'However, if we put in two values that sum to more than 100, we can see how
    Django displays the non-field error:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们输入两个总和超过100的值，我们可以看到Django如何显示非字段错误：
- en: '![Figure 7.7: Django non-field error displayed at the start of the form'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7：Django非字段错误在表单开始处显示'
- en: '](img/B15509_07_07.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15509_07_07.jpg](img/B15509_07_07.jpg)'
- en: 'Figure 7.7: Django non-field error displayed at the start of the form'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：Django非字段错误在表单开始处显示
- en: Django non-field errors are always displayed at the start of a form, before
    other fields or errors. In the next exercise, we will build a form that implements
    a validation function, a field clean method, and a form clean method.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Django的非字段错误始终在表单的开始处显示，在其他字段或错误之前。在下一个练习中，我们将构建一个实现验证函数、字段清理方法和表单清理方法的表单。
- en: 'Exercise 7.01: Custom Clean and Validation Methods'
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.01：自定义清理和验证方法
- en: 'In this exercise, you will build a new form that allows the user to create
    an order for books or magazines. It must have the following validation criteria:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将构建一个新的表单，允许用户为书籍或杂志创建订单。它必须满足以下验证标准：
- en: The user may order up to 80 magazines and/or 50 books, but the total number
    of items must not be more than 100\.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以订购最多80本杂志和/或50本书，但物品总数不得超过100。
- en: The user can choose to receive an order confirmation, and if they do, they must
    enter an email address.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以选择接收订单确认，如果他们这样做，则必须输入电子邮件地址。
- en: The user should not enter an email address if they have not chosen to receive
    an order confirmation.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户没有选择接收订单确认，则不应输入电子邮件地址。
- en: To ensure they are part of our company, the email address must be part of our
    company domain (in our case, we will just use `example.com`).
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确保他们是我们的公司的一员，电子邮件地址必须是我们的公司域名的一部分（在我们的例子中，我们将只使用`example.com`）。
- en: For consistency with other email addresses in our fictional company, the address
    should be converted to lowercase.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了与其他虚构公司的电子邮件地址保持一致，地址应转换为小写。
- en: 'This sounds like a lot of rules, but with Django, it is simple if we tackle
    them one by one. We will carry on with the `form_project` app we started in *Chapter
    6*, *Forms*. If you haven''t completed *Chapter 6*, *Forms*, you can download
    the code from [http://packt.live/2LRCczP](http://packt.live/2LRCczP):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来像是一大堆规则，但如果我们逐一解决，使用Django就很简单了。我们将继续使用我们在第6章“表单”中开始的`form_project`应用程序。如果您还没有完成第6章“表单”，可以从[http://packt.live/2LRCczP](http://packt.live/2LRCczP)下载代码：
- en: In PyCharm, open the `form_example` app's `forms.py` file.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PyCharm中，打开`form_example`应用程序的`forms.py`文件。
- en: Note
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure the Django dev server is not running, otherwise, it may crash as you
    make changes to this file, causing PyCharm to jump into the debugger.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保Django开发服务器没有运行，否则，在您更改此文件时，它可能会崩溃，导致PyCharm跳入调试器。
- en: Since our work with `ExampleForm` is done, you can remove it from this file.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的`ExampleForm`工作已完成，您可以将其从该文件中删除。
- en: 'Create a new class called `OrderForm` that inherits from `forms.Form`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的类`OrderForm`，它从`forms.Form`继承：
- en: '[PRE8]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add four fields to the class as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式向类中添加四个字段：
- en: '`magazine_count,` `IntegerField` with `min_value` of `0` and `max_value` of
    `80`'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`magazine_count`，`IntegerField`，最小值为`0`，最大值为`80`'
- en: '`book_count`, `IntegerField` with `min_value` of `0` and `max_value` of `50`'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`book_count`，`IntegerField`，最小值为`0`，最大值为`50`'
- en: '`send_confirmation`, `BooleanField`, which is not required'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send_confirmation`，`BooleanField`，不是必需的'
- en: '`email`, `EmailField`, which is also not required'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`，`EmailField`，也不是必需的'
- en: 'The class should look like this:'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类应该看起来像这样：
- en: '[PRE9]'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add a validation function to check that the user''s email address is on the
    right domain. First, `ValidationError` needs to be imported; add this line at
    the top of the file:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个验证函数来检查用户的电子邮件地址是否在正确的域名下。首先，需要导入`ValidationError`；在文件顶部添加此行：
- en: '[PRE10]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then write this function after the `import` line (before the `OrderForm` class implementation):'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后在`import`行之后（在`OrderForm`类实现之前）编写此函数：
- en: '[PRE11]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The function splits the email address on the `@` symbol, then checks whether
    the part after it is equal to `example.com`. This function alone would validate
    non-email addresses. For example, the string `not-valid@someotherdomain@example.com`
    would not cause `ValidationError` to be raised in this function. This is acceptable
    in our case because as we are using `EmailField`, the other standard field validators
    will check the email address validity.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该函数将电子邮件地址在`@`符号处分割，然后检查其后的部分是否等于`example.com`。这个函数本身将验证非电子邮件地址。例如，字符串`not-valid@someotherdomain@example.com`不会在这个函数中引发`ValidationError`。在我们的情况下这是可以接受的，因为我们使用的是`EmailField`，其他标准字段验证器将检查电子邮件地址的有效性。
- en: 'Add the `validate_email_domain` function as a validator to the `email` field
    on `OrderForm`. Update the `EmailField` constructor call to add a `validators`
    argument, passing in a list containing the validation function:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`validate_email_domain`函数作为验证器添加到`OrderForm`中的`email`字段。更新`EmailField`构造函数调用，添加一个`validators`参数，传递包含验证函数的列表：
- en: '[PRE12]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add a `clean_email` method to the form to make sure the email address is lowercase:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表单中添加一个`clean_email`方法，以确保电子邮件地址是小写的：
- en: '[PRE13]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, add the `clean` method to perform all the cross-field validation. First,
    we will just add the logic for making sure that an email address is only entered
    if an order confirmation is requested:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加`clean`方法以执行所有跨字段验证。首先，我们将仅添加确保只有在请求订单确认时才输入电子邮件地址的逻辑：
- en: '[PRE14]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the final check, also inside the `clean` method. The total number of items
    should not be more than 100\. We will add a non-field error if the sum of `magazine_count`
    and `book_count` is greater than 100:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`clean`方法内部添加最终的检查。项目总数不应超过100。如果`magazine_count`和`book_count`的总和大于100，我们将添加一个非字段错误：
- en: '[PRE15]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Open the `reviews` app''s `views.py` file. We will change the form `import`
    so that `OrderForm` is being imported instead of `ExampleForm`. Consider the following
    import line:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`reviews`应用的`views.py`文件。我们将更改表单`import`，以便导入`OrderForm`而不是`ExampleForm`。考虑以下导入行：
- en: '[PRE16]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Change it as follows:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按照以下方式更改：
- en: '[PRE17]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the `form_example` view, change the two lines that use `ExampleForm` to
    use `OrderForm` instead. Consider the following line of code:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`form_example`视图中，将使用`ExampleForm`的两行更改为使用`OrderForm`。考虑以下代码行：
- en: '[PRE18]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Change this as follows:'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按照以下方式更改：
- en: '[PRE19]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Similarly, consider the following line of code:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似地，考虑以下代码行：
- en: '[PRE20]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Change this as follows:'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按照以下方式更改：
- en: '[PRE21]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The rest of the function can stay as it is.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数的其余部分可以保持不变。
- en: 'We don''t have to make changes to the template. Start the Django dev server
    and navigate to `http://127.0.0.1:8000/form-example/` in your browser. You should
    see the form rendered as in *Figure 7.10*:'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不需要更改模板。启动Django开发服务器，并在浏览器中导航到`http://127.0.0.1:8000/form-example/`。你应该会看到像*图7.10*中渲染的表单：
- en: '![Figure 7.10: OrderForm in the browser'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图7.10：浏览器中的OrderForm'
- en: '](img/B15509_07_10.jpg)'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_07_10.jpg)'
- en: 'Figure 7.10: OrderForm in the browser'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.10：浏览器中的OrderForm
- en: 'Try submitting the form with a `Magazine count` of `80` and `Book count` of
    `50`. The browser will allow this, but as they sum to more than 100, an error
    will be triggered by the `clean` method in the form and displayed on the page:![Figure
    7.11: A non-field error displayed on the form when'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试提交一个`Magazine count`为`80`和`Book count`为`50`的表单。浏览器会允许这样做，但由于它们的总和超过100，表单中的`clean`方法会触发错误并在页面上显示：![图7.11：当允许的最大项目数量超出时在表单上显示的非字段错误
- en: the maximum number of allowed items is exceeded
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 允许的最大项目数量已超出
- en: '](img/B15509_07_11.jpg)'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_07_11.jpg)'
- en: 'Figure 7.11: A non-field error displayed on the form when the maximum number
    of allowed items is exceeded'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.11：当允许的最大项目数量超出时在表单上显示的非字段错误
- en: 'Try submitting the form with `Send confirmation` checked but the `Email` field
    blank. Then fill the `Email` textbox but uncheck `Send confirmation`. Either combination
    will give an error that both must be present. The error will differ based on which
    field is missing:![Figure 7.12: Error message if no email address is present'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试提交一个带有`Send confirmation`勾选但`Email`字段为空的表单。然后填写`Email`文本框，但取消勾选`Send confirmation`。任何一种组合都会给出一个错误，指出两者都必须存在。错误将根据缺少的字段而有所不同：![图7.12：如果没有电子邮件地址时的错误信息
- en: '](img/B15509_07_12.jpg)'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_07_12.jpg)'
- en: 'Figure 7.12: Error message if no email address is present'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.12：如果没有电子邮件地址时的错误信息
- en: 'Now try submitting the form with `Send confirmation` checked and an email address
    that is on the `example.com` domain. You should receive a message that your email
    address must have the domain `example.com`. You should also receive a message
    that `email` must be set – since email does not end up in the `cleaned_data` dictionary,
    as it is not valid:![Figure 7.13: The error message is shown when the email domain
    is not example.com'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试提交带有`Send confirmation`勾选和`example.com`域电子邮件地址的表单。你应该会收到一条消息，指出你的电子邮件地址必须具有`example.com`域。你还应该收到一条消息，指出`email`必须设置
    – 因为电子邮件最终没有进入`cleaned_data`字典，因为它不是有效的：![图7.13：当电子邮件域不是example.com时显示的错误信息
- en: '](img/B15509_07_13.jpg)'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_07_13.jpg)'
- en: 'Figure 7.13: The error message is shown when the email domain is not example.com'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.13：当电子邮件域不是example.com时显示的错误信息
- en: 'Finally, enter valid values for `Magazine count` and `Book count` (such as
    `20` and `20`). Check `Send confirmation`, and enter `UserName@Example.Com` as
    the email (make sure you match the letter case, including the mixed uppercase
    and lowercase characters):![Figure 7.14: The form after being submitted with valid
    values'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，输入有效的`杂志数量`和`书籍数量`（例如`20`和`20`）。勾选`发送确认`，并将`UserName@Example.Com`作为电子邮件输入（确保匹配字母大小写，包括混合的大小写字符）：![图7.14：提交有效值后的表单
- en: '](img/B15509_07_14.jpg)'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15509_07_14.jpg]'
- en: 'Figure 7.14: The form after being submitted with valid values'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.14：提交有效值后的表单
- en: 'Switch to PyCharm and look in the debug console. You''ll see that the email
    has been converted to lowercase when it is printed by our debug code:![Figure
    7.15: Email in lowercase, as well as other fields'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到PyCharm并查看调试控制台。你会看到，当我们的调试代码打印时，电子邮件已经被转换为小写：![图7.15：电子邮件字段已转换为小写，以及其他字段
- en: '](img/B15509_07_15.jpg)'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15509_07_15.jpg]'
- en: 'Figure 7.15: Email in lowercase, as well as other fields'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15：电子邮件字段已转换为小写，以及其他字段
- en: This is our `clean_email` method in action – even though we entered data in
    both uppercase and lowercase, it has been converted to all lowercase.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`clean_email`方法在起作用——即使我们输入了大小写混合的数据，它已经被转换为全小写。
- en: In this exercise, we created a new `OrderForm` that implemented form and field
    clean methods. We used a custom validator to ensure that the `Email` field met
    our specific validation rules – only a specific domain was allowed. We used a
    custom field cleaning method (`clean_email`) to convert the email address to lowercase.
    We then implemented a `clean` method to validate the forms that were dependent
    on each other. In this method, we added both field and non-field errors. In the
    next section, we will cover how to add placeholders and initial values to the
    form.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们创建了一个新的`OrderForm`，该表单实现了表单和字段清理方法。我们使用自定义验证器来确保`Email`字段符合我们的特定验证规则——只允许特定的域名。我们使用自定义字段清理方法（`clean_email`）将电子邮件地址转换为小写。然后我们实现了`clean`方法来验证相互依赖的表单。在这个方法中，我们添加了字段和非字段错误。在下一节中，我们将介绍如何向表单添加占位符和初始值。
- en: Placeholders and Initial Values
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 占位符和初始值
- en: There are two things our first manually built form had that our current Django
    form still does not have –placeholders and initial values. Adding placeholders
    is simple; they are just added as an attribute to the widget constructor for the
    form field. This is similar to what we have already seen for setting the type
    of `DateField` in our previous examples.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一个手动构建的表单有两个我们当前的Django表单还没有的特性——占位符和初始值。添加占位符很简单；它们只是作为表单字段的`widget`构造函数的属性添加。这与我们在之前的示例中设置`DateField`类型的方法类似。
- en: 'Here is an example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is what the preceding form looks like when rendered in the browser:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是浏览器中渲染的前一个表单的样子：
- en: '![Figure 7.16: Django form with placeholders'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.16：带有占位符的Django表单'
- en: '](img/B15509_07_16.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15509_07_16.jpg]'
- en: 'Figure 7.16: Django form with placeholders'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16：带有占位符的Django表单
- en: Of course, if we are manually setting `Widget` for each field, we need to know
    which `Widget` class to use. The ones that support placeholders are `TextInput`,
    `NumberInput`, `EmailInput`, `URLInput`, `PasswordInput`, and `Textarea`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们为每个字段手动设置`Widget`，我们需要知道要使用哪个`Widget`类。支持占位符的类有`TextInput`、`NumberInput`、`EmailInput`、`URLInput`、`PasswordInput`和`Textarea`。
- en: 'While we are examining the `Form` class itself, we will look at the first of
    two ways of setting an initial value for a field. We can do it by using the `initial`
    argument on a `Field` constructor, like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查`Form`类本身时，我们将探讨设置字段初始值的两种方法之一。我们可以通过在`Field`构造函数上使用`initial`参数来实现，如下所示：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The other method is to pass in a dictionary of data when instantiating the
    form in our view. The keys are the field names. The dictionary should have zero
    or more items (that is, an empty dictionary is valid). Any extra keys are ignored.
    This dictionary should be supplied as the `initial` argument in our view as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是，在视图中实例化表单时传入一个包含数据的字典。键是字段名称。该字典应该有零个或多个项（即空字典是有效的）。任何额外的键都将被忽略。这个字典应该作为`initial`参数在我们的视图中提供如下：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Or for a `POST` request, pass in `request.POST` as the first argument, as usual:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 或者对于`POST`请求，像往常一样传入`request.POST`作为第一个参数：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Values in `request.POST` will override values in `initial`. This means that
    even if we have an initial value for a required field, if it is left blank when
    submitted, then it will not validate. The field will not fall back to the value
    in `initial`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`request.POST` 中的值将覆盖 `initial` 中的值。这意味着即使我们对一个必填字段有一个初始值，如果提交时留空，则它将不会验证。该字段不会回退到
    `initial` 中的值。'
- en: Whether you decide to set initial values in the `Form` class itself or the view
    is up to you and depends on your use case. If you had a form that was used in
    multiple views but usually had the same value, it would be better to set the `initial`
    value in the form. Otherwise, it can be more flexible to use `setting` in the
    view.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你决定在 `Form` 类本身或视图中设置初始值，这取决于你的用例。如果你有一个在多个视图中使用但通常具有相同值的表单，那么在表单中设置 `initial`
    值会更好。否则，在视图中使用 `setting` 可能会更加灵活。
- en: In the next exercise, we will add placeholders and initial values to the `OrderForm`
    class from the previous exercise.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将向上一个练习中的 `OrderForm` 类添加占位符和初始值。
- en: 'Exercise 7.02: Placeholders and Initial Values'
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.02：占位符和初始值
- en: 'In this exercise, you will enhance the `OrderForm` class by adding placeholder
    text. You will simulate passing an initial email address to the form. It will
    be a hardcoded address, but once the user can log in, it could be an email address
    associated with their account – you will learn about sessions and authentication
    in *Chapter 9*, *Sessions and Authentication*:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将通过添加占位符文本来增强 `OrderForm` 类。你将模拟向表单传递一个初始电子邮件地址。它将是一个硬编码的地址，但一旦用户可以登录，它可能是与他们的账户关联的电子邮件地址——你将在
    *第 9 章*、*会话和身份验证* 中学习关于会话和身份验证的内容：
- en: In PyCharm, open the `reviews` app's `forms.py` file. You will add placeholders
    to the `magazine_count`, `book_count`, and `email` fields on the `OrderForm`,
    which means also setting the `widget`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PyCharm 中，打开 `reviews` 应用程序的 `forms.py` 文件。你将在 `OrderForm` 上的 `magazine_count`、`book_count`
    和 `email` 字段中添加占位符，这意味着还需要设置 `widget`。
- en: 'To the `magazine_count` field, add a `NumberInput` `widget` with `placeholder`
    in the `attrs` dictionary. The `placeholder` should be set to *Number of Magazines*.
    Write the following code:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `magazine_count` 字段中，向 `attrs` 字典添加一个带有 `placeholder` 的 `NumberInput` `widget`。`placeholder`
    应设置为 *杂志数量*。请编写以下代码：
- en: '[PRE26]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add a placeholder to the `book_count` field in the same manner. The placeholder
    text should be `Number of Books`:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以相同的方式为 `book_count` 字段添加占位符。占位符文本应为 `书籍数量`：
- en: '[PRE27]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The final change to `OrderForm` is to add a placeholder to the email field.
    This time the widget is `EmailInput`. The placeholder text should be `Your company
    email address`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 `OrderForm` 的最终修改是向电子邮件字段添加占位符。这次小部件是 `EmailInput`。占位符文本应为 `您的公司电子邮件地址`：
- en: '[PRE28]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that the `clean_email` and `clean` methods should remain as they were in
    *Exercise 7.01, Custom Clean and Validation Methods*. Save the file.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`clean_email` 和 `clean` 方法应保持与 *练习 7.01，自定义清理和验证方法* 中相同。保存文件。
- en: 'Open the `reviews` app''s `views.py` file. In the `form_example` view function,
    create a new dictionary variable called `initial` with one key, `email`, like
    this:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `reviews` 应用程序的 `views.py` 文件。在 `form_example` 视图函数中，创建一个新的字典变量 `initial`，其中有一个键
    `email`，如下所示：
- en: '[PRE29]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the two places that you are instantiating `OrderForm`, also pass in the
    `initial` variable using the `initial` kwarg. The first instance is as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你实例化 `OrderForm` 的两个地方，也使用 `initial` 关键字参数传入 `initial` 变量。第一个实例如下：
- en: '[PRE30]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The second instance is as follows:'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二个实例如下：
- en: '[PRE31]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The complete code for `views.py` can be found at [http://packt.live/3szaPM6](http://packt.live/3szaPM6).
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`views.py` 的完整代码可以在 [http://packt.live/3szaPM6](http://packt.live/3szaPM6)
    找到。'
- en: Save the `views.py` file.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保存 `views.py` 文件。
- en: 'Start the Django dev server if it is not already running. Browse to `http://127.0.0.1:8000/form-example/`
    in your browser. You should see that your form now has placeholders and an initial
    value set:![Figure 7.17: Order form with initial values and placeholders'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Django 开发服务器尚未运行，请启动它。在浏览器中浏览到 `http://127.0.0.1:8000/form-example/`。你应该会看到你的表单现在有了占位符和设置的初始值：![图
    7.17：带有初始值和占位符的订单表单
- en: '](img/B15509_07_17.jpg)'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_07_17.jpg)'
- en: 'Figure 7.17: Order form with initial values and placeholders'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17：带有初始值和占位符的订单表单
- en: In this exercise, we added placeholders to form fields. This was done by setting
    a `form` widget when defining the `form` field on the form class and setting a
    *placeholder* value in the `attrs` dictionary. We also set an initial value for
    the form using a dictionary and passing it to the `form` instance using the `initial`
    kwarg.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们在表单字段中添加了占位符。这是通过在表单类上定义`form`字段时设置`form`小部件，并在`attrs`字典中设置一个`*placeholder*`值来完成的。我们还使用字典设置表单的初始值，并通过`initial`关键字参数将其传递给`form`实例。
- en: In the next section, we will talk about how to work with Django models using
    data from forms, and how `ModelForm` makes this easier.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何使用表单中的数据与Django模型一起工作，以及`ModelForm`如何使这变得更加容易。
- en: Creating or Editing Django Models
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建或编辑Django模型
- en: 'You have seen how to define a form, and in *Chapter 2*, *Models and Migrations*,
    you learned how to create Django model instances. By using these things together,
    you could build a view that displayed a form and also saved a model instance to
    the database. This gives you an easy method to save data without having to write
    a lot of boilerplate code or create custom forms. In Bookr, we will use this method
    to allow users to add reviews without requiring access to the Django admin site.
    Without using `ModelForm`, we could do something like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何定义一个表单，在*第二章*，*模型和迁移*中，你学习了如何创建Django模型实例。通过结合使用这些功能，你可以构建一个显示表单并保存模型实例到数据库的视图。这为你提供了一个简单的方法来保存数据，而无需编写大量的模板代码或创建自定义表单。在Bookr中，我们将使用这种方法来允许用户添加评论，而无需访问Django管理站点。不使用`ModelForm`，我们可以这样做：
- en: We can create a form based on an existing model, for example, `Publisher`. The
    form would be called `PublisherForm`.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以基于现有的模型创建一个表单，例如`Publisher`。表单将被称为`PublisherForm`。
- en: 'We can manually define the fields on `PublisherForm`, using the same rules
    defined on the `Publisher` model, as shown here:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以手动在`PublisherForm`上定义字段，使用与`Publisher`模型上定义的相同规则，如下所示：
- en: '[PRE32]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the view, the `initial` values would be retrieved from the model queried
    from the database, then passed to the form using the `initial` argument. If we
    were creating a new instance, the `initial` value would be blank – something like
    this:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视图中，`initial`值将从数据库查询到的模型中检索，然后通过`initial`参数传递给表单。如果我们正在创建一个新的实例，`initial`值将是空的——就像这样：
- en: '[PRE33]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, in the `POST` flow of the view, we can either create or update the model
    based on `cleaned_data`:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，在视图的`POST`流程中，我们可以根据`cleaned_data`创建或更新模型：
- en: '[PRE34]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is a lot of work, and we have to consider how much duplicated logic we
    have. For example, we are defining the length of the name in the `name` form field.
    If we made a mistake here, we could allow a longer name in the field than the
    model allows. We also have to remember to set all the fields in the `initial`
    dictionary, as well as setting the values on the new or updated model with `cleaned_data`
    from the form. There are many opportunities to make mistakes here, as well as
    remembering to add or remove field setting data for each of these steps if the
    model changes. All this code would have to be duplicated for each Django model
    you work with as well, expounding the duplication problem.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要做很多工作，我们必须考虑我们有多少重复的逻辑。例如，我们在`name`表单字段中定义了名称的长度。如果我们在这里犯了一个错误，我们可能会允许字段中的名称比模型允许的更长。我们还要记住设置`initial`字典中的所有字段，以及使用表单的`cleaned_data`设置新或更新模型的值。在这里有很多出错的机会，以及记住如果模型发生变化，为每个这些步骤添加或删除字段设置数据。所有这些代码都必须为每个你工作的Django模型重复，这加剧了重复问题。
- en: The ModelForm Class
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ModelForm 类
- en: 'Luckily, Django provides a method of building `Model` instances from forms
    much more simply, with the `ModelForm` class. `ModelForm` is a form that is built
    automatically from a particular model. It will inherit the validation rules from
    the model (such as whether fields are required or the maximum length of `CharField`
    instances, and so on). It provides an extra `__init__` argument (called `instance`)
    to automatically populate the initial values from an existing model. It also adds
    a `save` method to automatically persist the form data to the database. All that
    needs to be done to set up `ModelForm` is to specify its model and what fields
    should be used: this is done on the `class Meta` attribute of the `form` class.
    Let us see how to build a form from `Publisher`.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Django 提供了一种更简单的方法来从表单构建 `Model` 实例，使用 `ModelForm` 类。`ModelForm` 是一个从特定模型自动构建的表单。它将继承模型的验证规则（例如，字段是否必需或
    `CharField` 实例的最大长度等）。它提供了一个额外的 `__init__` 参数（称为 `instance`），用于自动从现有模型中填充初始值。它还添加了一个
    `save` 方法，用于自动将表单数据持久化到数据库。要设置 `ModelForm`，只需指定其模型和应使用的字段：这是在 `form` 类的 `class
    Meta` 属性上完成的。让我们看看如何从 `Publisher` 构建表单。
- en: 'Inside the file that contains the form (for example, the `forms.py` file we
    have been working with), the only change is that the model must be imported:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含表单的文件中（例如，我们一直在工作的 `forms.py` 文件），唯一的改变是模型必须被导入：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then the `Form` class can then be defined. The class requires a `class Meta`
    attribute, which in turn must define a `model` attribute and either `fields` or
    `excludes` attributes:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以定义 `Form` 类。该类需要一个 `class Meta` 属性，该属性反过来必须定义一个 `model` 属性以及 `fields` 或
    `excludes` 属性：
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`fields` is a list or tuple of the fields to include in the form. When manually
    setting the list of fields, if you add extra fields to the model, you must also
    add their name here to have them displayed on the form.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`fields` 是一个包含在表单中要包含的字段的列表或元组。当手动设置字段列表时，如果你向模型中添加了额外的字段，你也必须在这里添加它们的名称，以便它们在表单中显示。'
- en: 'You can also use the special value `__all__` instead of a list or tuple to
    automatically include all the fields, like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用特殊值 `__all__` 来代替列表或元组，以自动包含所有字段，如下所示：
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If the `model` field has its `editable` attribute set to `False`, then it will
    not be automatically included.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `model` 字段的 `editable` 属性设置为 `False`，则它将不会自动包含。
- en: 'On the contrary, the `exclude` attribute sets the fields to not display in
    the form. Any fields added to the model will automatically be added to the form.
    We could define the preceding form using `exclude` with any empty tuple since
    we want all the fields. The code is like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`exclude` 属性将字段设置为不在表单中显示。添加到模型中的任何字段都会自动添加到表单中。我们可以使用 `exclude` 和任何空元组来定义前面的表单，因为我们想要显示所有字段。代码如下：
- en: '[PRE38]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This saves some work because you don't need to add a field to both the model
    and in the `fields` list, however, it is not as safe, as you might automatically
    expose fields to the end user that you don't want to. For example, if you had
    a `User` model with `UserForm`, you might add an `is_admin` field to the `User`
    model to give admin users extra privileges. If this field did not have the `exclude`
    attribute, it would be displayed to the user. A user would then be able to make
    themselves an administrator, which is something you probably wouldn't want.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这节省了一些工作，因为你不需要在模型和 `fields` 列表中添加字段，然而，这并不安全，因为你可能会自动向最终用户暴露你不希望他们看到的字段。例如，如果你有一个
    `User` 模型和一个 `UserForm`，你可能会在 `User` 模型中添加一个 `is_admin` 字段，以给管理员用户额外的权限。如果这个字段没有
    `exclude` 属性，它就会显示给用户。然后，用户就可以将自己变成管理员，这可能是你不太希望发生的事情。
- en: 'Whichever of these three approaches to choosing the forms to display that we
    decide to use, in our case, they will display the same in the browser. This is
    because we are choosing to display *all* the fields. They all look like this when
    rendered in the browser:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们决定使用这三种选择要显示的表单的方法中的哪一种，在我们的情况下，它们在浏览器中都会显示相同的内容。这是因为我们选择显示 *所有* 字段。当在浏览器中渲染时，它们看起来都像这样：
- en: '![Figure 7.18: PublisherForm'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.18：PublisherForm'
- en: '](img/B15509_07_18.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15509_07_18.jpg)'
- en: 'Figure 7.18: PublisherForm'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.18：PublisherForm
- en: Note that `help_text` from the `Publisher` model is automatically rendered as well.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Publisher` 模型的 `help_text` 也会自动渲染。
- en: Usage in a view is similar to the other forms we have seen. Also, as mentioned,
    there is an extra argument that can be provided, called `instance`. This can be
    set to `None`, which will render an empty form.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中使用与我们所看到的其他表单类似。此外，如前所述，还有一个额外的参数可以提供，称为`instance`。它可以设置为`None`，这将渲染一个空表单。
- en: 'Assuming, in your view function, you have some method of determining whether
    you are creating or editing a model instance (we will discuss how to do this later),
    this will determine a variable called `is_create` (`True` if creating an instance,
    or `False` if editing an existing one). Your view function to create the form
    could then be written like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在你的视图函数中，你有一些方法来确定你是否正在创建或编辑模型实例（我们将在稍后讨论如何做到这一点），这将确定一个名为`is_create`的变量（如果创建实例则为`True`，如果编辑现有实例则为`False`）。然后，你的创建表单的视图函数可以写成这样：
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, in either branch, the instance is passed to the `PublisherForm`
    constructor, although it is `None` if we are in create mode.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在任一分支中，实例都传递给了`PublisherForm`构造函数，尽管在创建模式中它是`None`。
- en: 'If the form is valid, we can then save the `model` instance. This is done simply
    by calling the `save` method on the form. This will automatically create the instance,
    or simply save changes to the old one:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表单有效，然后我们可以保存`model`实例。这是通过在表单上调用`save`方法来完成的。这将自动创建实例，或者简单地保存对旧实例的更改：
- en: '[PRE40]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `save` method returns the `model` instance that was saved. It takes one
    optional argument, `commit`, which determines whether the changes should be written
    to the database. You can pass `False` instead, which allows you to make additional
    changes to the instance before manually saving the changes. This would be required
    to set attributes that have not been included in the form. As we mentioned, maybe
    you would set the `is_admin` flag to `False` on a `User` instance:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`save`方法返回已保存的`model`实例。它接受一个可选参数`commit`，它确定是否将更改写入数据库。你可以传递`False`，这允许你在手动保存更改之前对实例进行更多更改。这可能需要设置未包含在表单中的属性。正如我们提到的，也许你会在`User`实例上将`is_admin`标志设置为`False`：'
- en: '[PRE41]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In *Activity 7.02*, *Review Creation UI*, at the end of this chapter, we will
    be using this feature as well.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾的*活动7.02*，*创建UI回顾*中，我们将使用这个功能。
- en: If your model uses `ManyToMany` fields, and you also call `form.save(False)`,
    you should also call `form.save_m2m()` to save any many-to-many relationships
    that have been set. It is not necessary to call this method if you call the form
    `save` method with `commit` set to `True` (that is, the default).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的模型使用`ManyToMany`字段，并且你也调用了`form.save(False)`，你应该也调用`form.save_m2m()`来保存任何已设置的许多对多关系。如果你使用带有`commit`设置为`True`（即默认值）的表单`save`方法，则不需要调用此方法。
- en: 'Model forms can be customized by making changes to their `Meta` attributes.
    The `widgets` attribute can be set. It can contain a dictionary keyed on the field
    names, with widget classes or instances as the values. For example, this is how
    to set up `PublisherForm` to have placeholders:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过修改其`Meta`属性来自定义模型表单。可以设置`widgets`属性。它可以包含一个以字段名称为键的字典，其中包含小部件类或实例作为值。例如，这是如何设置`PublisherForm`以具有占位符的：
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The values behave the same as setting the `kwarg` widget in the field definition;
    they can be a class or an instance. For example, to display `CharField` as a password
    input, the `PasswordInput` class can be used; it does not need to be instantiated:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值的行为与在字段定义中设置`kwarg`小部件相同；它们可以是类或实例。例如，要显示`CharField`作为密码输入，可以使用`PasswordInput`类；它不需要实例化：
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Model forms can also be augmented with extra fields added in the same way as
    they are added to a normal form. For example, suppose we wanted to give the option
    of sending a notification email after saving a `Publisher` object. We can add
    an `email_on_save` field to `PublisherForm` like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 模型表单也可以通过添加与添加到普通表单相同方式添加的额外字段来增强。例如，假设我们想在保存`Publisher`对象后发送通知电子邮件的选项。我们可以在`PublisherForm`中添加一个`email_on_save`字段，如下所示：
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When rendered, the form looks like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当渲染时，表单看起来像这样：
- en: '![Figure 7.19: PublisherForm with an additional field'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.19：带有额外字段的PublisherForm]'
- en: '](img/B15509_07_19.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15509_07_19.jpg]'
- en: 'Figure 7.19: PublisherForm with an additional field'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19：带有额外字段的PublisherForm
- en: 'Additional fields are placed after the `Model` fields. The extra fields are
    not handled automatically – they do not exist on the model, so Django won''t attempt
    to save them on the `model` instance. Instead, you should handle the saving of
    their values by examining the `cleaned_data` values of the form, as you would
    with a standard form, for example (inside your view function):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的字段放置在 `Model` 字段之后。额外的字段不会自动处理——它们在模型上不存在，所以 Django 不会尝试在 `model` 实例上保存它们。相反，你应该通过检查表单的
    `cleaned_data` 值来处理它们的值的保存，就像使用标准表单一样（在你的视图函数内部）：
- en: '[PRE45]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the next exercise, you will write a new view function to create or edit a `Publisher`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，你将编写一个新的视图函数来创建或编辑一个 `Publisher`。
- en: 'Exercise 7.03: Creating and Editing a Publisher'
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.03：创建和编辑一个出版商
- en: 'In this exercise, we will return to Bookr. We want to add the ability to create
    and edit a `Publisher` without using the Django admin. To do this, we will add
    a `ModelForm` for the `Publisher` model. It will be used in a new view function.
    The view function will take an optional argument, `pk`, which will either be the
    ID of the `Publisher` being edited or `None` to create a new `Publisher`. We will
    add two new URL maps to facilitate this. When this is complete, we will be able
    to see and update any publisher using their ID. For example, information for `Publisher
    1` will be viewable/editable at URL path `/publishers/1`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将回到 Bookr。我们想要添加创建和编辑 `Publisher` 而不使用 Django 管理员的能力。为此，我们将为 `Publisher`
    模型添加一个 `ModelForm`。它将用于一个新的视图函数。视图函数将接受一个可选参数 `pk`，它将是正在编辑的 `Publisher` 的 ID 或
    `None` 以创建一个新的 `Publisher`。我们将添加两个新的 URL 映射来简化这个过程。当完成时，我们将能够通过它们的 ID 查看 和更新任何出版商。例如，`Publisher
    1` 的信息将在 URL 路径 `/publishers/1` 上可查看/可编辑：
- en: 'In PyCharm, open the `reviews` app''s `forms.py` file. After the `forms` import,
    also import the `Publisher` model:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PyCharm 中打开 `reviews` 应用的 `forms.py` 文件。在 `forms` 导入之后，也导入 `Publisher` 模型：
- en: '[PRE46]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a `PublisherForm` class, inheriting from `forms.ModelForm`:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个继承自 `forms.ModelForm` 的 `PublisherForm` 类：
- en: '[PRE47]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Define the `class Meta` attribute on `PublisherForm`. The attributes that `Meta`
    requires are the model (`Publisher`) and fields (`"__all__"`):'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在 `PublisherForm` 上定义 `Meta` 属性。`Meta` 所需的属性是模型 (`Publisher`) 和字段 (`"__all__"`):'
- en: '[PRE48]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Save `forms.py`.
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保存 `forms.py`。
- en: Note
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The complete file can be found at [http://packt.live/3qh9bww](http://packt.live/3qh9bww).
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整的文件可以在 [http://packt.live/3qh9bww](http://packt.live/3qh9bww) 找到。
- en: 'Open the `reviews` app''s `views.py` file. At the top of the file, import `PublisherForm`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `reviews` 应用程序的 `views.py` 文件。在文件顶部，导入 `PublisherForm`：
- en: '[PRE49]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Make sure you import the `get_object_or_404` and `redirect` functions from
    `django.shortcuts`, if you aren''t already:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保如果你还没有导入，你已经从 `django.shortcuts` 中导入了 `get_object_or_404` 和 `redirect` 函数：
- en: '[PRE50]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Also make sure you''re importing the `Publisher` model if you aren''t already.
    You may already be importing this and other models:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保如果你还没有导入 `Publisher` 模型，你已经导入了它。你可能已经导入了这个和其他模型：
- en: '[PRE51]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The final import you will need is the `messages` module. This will allow us
    to register a message letting the user know that a `Publisher` object was edited
    or created:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要的最后一个导入是 `messages` 模块。这将允许我们注册一个消息，让用户知道 `Publisher` 对象已被编辑或创建：
- en: '[PRE52]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Once again, add this import if you do not already have it.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次提醒，如果你还没有导入，请添加此导入。
- en: 'Create a new view function called `publisher_edit`. It takes two arguments,
    `request` and `pk` (the ID of the `Publisher` object to edit). This is optional,
    and if it is `None`, then a `Publisher` object will be created instead:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的视图函数，命名为 `publisher_edit`。它接受两个参数，`request` 和 `pk`（要编辑的 `Publisher` 对象的
    ID）。这是可选的，如果它是 `None`，则将创建一个新的 `Publisher` 对象：
- en: '[PRE53]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Inside the view function, we need to try to load the existing `Publisher` instance
    if `pk` is not `None`. Otherwise, the value of `publisher` should be `None`:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图函数内部，如果 `pk` 不是 `None`，我们需要尝试加载现有的 `Publisher` 实例。否则，`publisher` 的值应该是 `None`：
- en: '[PRE54]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'After getting a `Publisher` instance or `None`, complete the branch for a `POST`
    request. Instantiate the form in the same way as seen earlier in the chapter,
    but now make sure that it takes `instance` as a kwarg. Then, if the form is valid,
    save it using the `form.save()` method. The method will return the updated `Publisher`
    instance, which is stored in the `updated_publisher` variable. Then, register
    a different success message depending on whether the `Publisher` instance was
    created or updated. Finally, redirect back to this `publisher_edit` view, since
    `updated_publisher` will always have an ID at this point:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在获取到 `Publisher` 实例或 `None` 之后，完成 `POST` 请求的分支。以与本章前面看到的方式实例化表单，但现在确保它接受 `instance`
    作为关键字参数。然后，如果表单有效，使用 `form.save()` 方法保存它。该方法将返回更新的 `Publisher` 实例，该实例存储在 `updated_publisher`
    变量中。然后，根据 `Publisher` 实例是创建还是更新，注册不同的成功消息。最后，由于此时 `updated_publisher` 总是具有 ID，重定向回此
    `publisher_edit` 视图：
- en: '[PRE55]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If the form is not valid, the execution falls through to just return the `render`
    function call with the invalid form (this will be implemented in *step 12*). The
    redirect uses a named URL map, which will be added later in the exercise.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果表单无效，执行将跳过，只返回带有无效表单的 `render` 函数调用（这将在第 12 步中实现）。重定向使用命名 URL 映射，该映射将在练习的后续部分添加。
- en: 'Next, fill in the non-`POST` branch of the code. In this case, just instantiate
    the form with the `instance`:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，填写代码中的非 `POST` 分支。在这种情况下，只需使用 `instance` 实例化表单：
- en: '[PRE56]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, you can reuse the `form-example.html` file that you''ve used in previous
    exercises. Render it with the `render` function, passing in the HTTP method and
    `form` as the context:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以重用之前练习中使用的 `form-example.html` 文件。使用 `render` 函数渲染它，传入 HTTP 方法以及 `form`
    作为上下文：
- en: '[PRE57]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Save this file. You can refer to it at [http://packt.live/3nI62En](http://packt.live/3nI62En).
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保存此文件。你可以参考它，请见 [http://packt.live/3nI62En](http://packt.live/3nI62En)。
- en: Open `urls.py` in the `reviews` directory. Add two new URL maps; they will both
    go to the `publisher_edit` view. One will capture the ID of `Publisher` we want
    to edit and pass it into the view as the `pk` argument. The other will use the
    word `new` instead, and will not pass the `pk`, which will indicate we want to
    create a new `Publisher`.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `reviews` 目录中打开 `urls.py` 文件。添加两个新的 URL 映射；它们都将导向 `publisher_edit` 视图。一个将捕获我们想要编辑的
    `Publisher` 的 ID，并将其作为 `pk` 参数传递给视图。另一个将使用单词 `new`，并且不会传递 `pk`，这表示我们想要创建一个新的 `Publisher`。
- en: To your `urlpatterns` variable, add the path `'publishers/<int:pk>/'` mapping
    to the view `reviews.views.publisher_edit`, with the name of `'publisher_edit'`.
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将 `'publishers/<int:pk>/'` 映射添加到 `urlpatterns` 变量中，映射到 `reviews.views.publisher_edit`
    视图，名称为 `'publisher_edit'`。
- en: 'Also, add the path `''publishers/new/''` mapping to the `reviews.views.publisher_edit`
    view, with the name of `''publisher_create''`:'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还需添加 `'publishers/new/'` 映射到 `reviews.views.publisher_edit` 视图，名称为 `'publisher_create'`：
- en: '[PRE58]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Since the second mapping does not capture anything, the `pk` that is passed
    to the `publisher_detail` view function is `None`.
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于第二个映射没有捕获任何内容，传递给 `publisher_detail` 视图函数的 `pk` 是 `None`。
- en: Save the `urls.py` file. The completed version for reference is at [http://packt.live/39CpUnw](http://packt.live/39CpUnw).
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保存 `urls.py` 文件。参考的完成版本请见 [http://packt.live/39CpUnw](http://packt.live/39CpUnw)。
- en: 'Create a `form-example.html` file inside the `reviews` app''s `templates` directory.
    Since this is a standalone template (it does not extend any other templates),
    we need to render the messages inside it. Add this code just after the opening
    `<body>` tag to iterate through all the messages and display them:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `reviews` 应用程序的 `templates` 目录中创建一个 `form-example.html` 文件。由于这是一个独立的模板（它不扩展任何其他模板），我们需要在其中渲染消息。在
    `<body>` 标签打开后添加此代码，遍历所有消息并显示它们：
- en: '[PRE59]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This will loop over the messages we have added and display the tag (in our case,
    `Success`) and then the message.
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将遍历我们添加的消息，并显示标签（在我们的例子中是 `Success`）然后是消息。
- en: 'Then, add the normal form rendering and submission code:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加正常的表单渲染和提交代码：
- en: '[PRE60]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Save and close this file.
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保存并关闭此文件。
- en: You can refer to the full version of this file at [http://packt.live/38I8XZx](http://packt.live/38I8XZx).
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以参考此文件的完整版本，请见 [http://packt.live/38I8XZx](http://packt.live/38I8XZx)。
- en: 'Start the Django dev server, then navigate to `http://127.0.0.1:8000/publishers/new/`.
    You should see a blank `PublisherForm` being displayed:![Figure 7.20: Blank publisher
    form'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Django 开发服务器，然后导航到 `http://127.0.0.1:8000/publishers/new/`。你应该看到一个空白的 `PublisherForm`
    正在被显示：![图 7.20：空白出版者表单](img/B15509_07_20.jpg)
- en: '](img/B15509_07_20.jpg)'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15509_07_20.jpg](img/B15509_07_20.jpg)'
- en: 'Figure 7.20: Blank publisher form'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.20：空白出版者表单
- en: 'The form has inherited the model''s validation rules, so you cannot submit
    the form with too many characters for `Name`, or with an invalid `Website` or
    `Email`. Put in some valid information, then submit the form. After submission,
    you should see the success message and the form will be populated with information
    that was saved to the database:![Figure 7.21: Form after submission'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表单继承了模型的验证规则，因此你不能提交包含过多字符的`Name`或包含无效的`Website`或`Email`的表单。输入一些有效信息，然后提交表单。提交后，你应该看到成功消息，表单将填充保存到数据库中的信息：![图7.21：提交后的表单
- en: '](img/B15509_07_21.jpg)'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15509_07_21.jpg](img/B15509_07_21.jpg)'
- en: 'Figure 7.21: Form after submission'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.21：提交后的表单
- en: Notice that the URL has also been updated and now includes the ID of the publisher
    that was created. In this case, it is `http://127.0.0.1:8000/publishers/19/` but
    the ID on your setup will depend on how many `Publisher` instances were already
    in your database.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，URL也已更新，现在包括创建的出版商的ID。在这种情况下，它是`http://127.0.0.1:8000/publishers/19/`，但你的设置中的ID将取决于你的数据库中已经有多少个`Publisher`实例。
- en: Notice that if you refresh the page, you will not receive a message confirming
    whether you want to re-send the form data. This is because we redirected after
    saving, so it is safe to refresh this page as many times as you want, and no new
    `Publisher` instances will be created. If you had not redirected it, then every
    time the page was refreshed, a new `Publisher` instance would be created.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你刷新页面，你将不会收到确认是否重新发送表单数据的消息。这是因为我们在保存后进行了重定向，所以你可以多次刷新这个页面，而不会创建新的`Publisher`实例。如果你没有重定向，那么每次刷新页面都会创建一个新的`Publisher`实例。
- en: 'If you have other `Publisher` instances in your database, you can change the
    ID in the URL to edit other ones. Since the ID in this instance is `3`, we can
    assume that `Publisher` `1` and `Publisher` `2` already exist and can substitute
    in their IDs to see the existing data. Here is the view of the existing `Publisher
    1` (at `http://127.0.0.1:8000/publishers/1/`) – your information may be different:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你数据库中有其他`Publisher`实例，你可以更改URL中的ID来编辑其他实例。由于这个实例的ID是`3`，我们可以假设`Publisher`
    `1`和`Publisher` `2`已经存在，可以用它们的ID来替换以查看现有数据。以下是现有`Publisher 1`的视图（在`http://127.0.0.1:8000/publishers/1/`）——你的信息可能不同：
- en: '![Figure 7.22: Existing Publisher 1 information'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.22：现有出版商1信息'
- en: '](img/B15509_07_22.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15509_07_22.jpg](img/B15509_07_22.jpg)'
- en: 'Figure 7.22: Existing Publisher 1 information'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.22：现有出版商1信息
- en: 'Try making changes to the existing `Publisher` instance. Notice that after
    you save, the message is different – it is telling the user that the `Publisher`
    instance was *updated* rather than *created*:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改现有的`Publisher`实例。注意，在你保存后，消息是不同的——它告诉用户`Publisher`实例已被*更新*而不是*创建*：
- en: '![Figure 7.23: Publisher after updating instead of creating'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.23：更新而不是创建后的出版商'
- en: '](img/B15509_07_23.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15509_07_23.jpg](img/B15509_07_23.jpg)'
- en: 'Figure 7.23: Publisher after updating instead of creating'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.23：更新而不是创建后的出版商
- en: In this exercise, we implemented a `ModelForm` from a model (`PublisherForm`
    was created from `Publisher`) and saw how Django automatically generated the form
    fields with the correct validation rules. We then used the form's built-in `save`
    method to save changes to the `Publisher` instance (or automatically create it)
    inside the `publisher_edit` view. We mapped two URLs to the view. The first URL,
    which was for editing an existing `Publisher`, passed `pk` to the view. The other
    did not pass `pk` to the view, indicating that the `Publisher` instance should
    be created. Finally, we used the browser to experiment with creating a new `Publisher`
    instance and then editing an existing one.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们从一个模型（`PublisherForm`是从`Publisher`创建的）实现了`ModelForm`，并看到了Django如何自动生成带有正确验证规则的表单字段。然后，我们使用表单的内置`save`方法将更改保存到`Publisher`实例（或自动创建它）中的`publisher_edit`视图。我们将两个URL映射到该视图。第一个URL用于编辑现有的`Publisher`，将`pk`传递给视图。另一个没有将`pk`传递给视图，表示应该创建`Publisher`实例。最后，我们使用浏览器来尝试创建一个新的`Publisher`实例，然后编辑现有的一个。
- en: 'Activity 7.01: Styling and Integrating the Publisher Form'
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动7.01：样式化和集成出版商表单
- en: In *Exercise 7.03*, *Creating and Editing a Publisher*, you added `PublisherForm`
    to create and edit `Publisher` instances. You built this with a standalone template
    that did not extend any other templates, so it lacked the global styles. In this
    activity, you will build a generic form detail page that will display a Django
    form, similar to `form-example.html` but extending from a base template. The template
    will accept a variable to display the type of model being edited. You will also
    update the main `base.html` template to render the Django messages, using Bootstrap
    styling.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在*练习7.03*，*创建和编辑出版商*中，你添加了`PublisherForm`来创建和编辑`Publisher`实例。你是通过一个不扩展任何其他模板的独立模板构建的，因此它缺少全局样式。在这个活动中，你将构建一个通用的表单详情页面，该页面将显示Django表单，类似于`form-example.html`，但扩展自基础模板。该模板将接受一个变量以显示正在编辑的模型类型。你还将更新主要的`base.html`模板以使用Bootstrap样式渲染Django消息。
- en: 'These steps will help you complete this activity:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助你完成这个活动：
- en: Start by editing the `base.html` project. Wrap the `content` block in a container
    `div` for a nicer layout with some spacing. Surround the existing `content` block
    with a `<div>` element with `class="container-fluid"`.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先编辑`base.html`项目。将`content`块包裹在一个带有一些间距的容器`div`中，以获得更美观的布局。使用`class="container-fluid"`的`<div>`元素包围现有的`content`块。
- en: 'Render each `message` in `messages` (similar to *step 14* of *Exercise 7.03*,
    *Creating and Editing a Publisher*). Add the `{% for %}` block after the `<div>`
    you just created but before the `content` block. You should use the Bootstrap
    framework classes – this snippet will help you:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你刚刚创建的`<div>`之后但在`content`块之前渲染`messages`中的每个`message`（类似于*练习7.03*，*创建和编辑出版商*中的*步骤14*）。你应该使用Bootstrap框架类
    - 这个片段将帮助你：
- en: '[PRE61]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The Bootstrap class and Django `message` tags have corresponding names for the
    most part (for example, `success` and `alert-success`). The exception is Django's
    `error` tag. The corresponding Bootstrap class is `alert-danger`. See more information
    about Bootstrap alerts at [https://getbootstrap.com/docs/4.0/components/alerts/](https://getbootstrap.com/docs/4.0/components/alerts/).
    This is why you need to use the `if` template tag in this snippet.
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大部分情况下，Bootstrap类和Django的`message`标签有相应的名称（例如，`success`和`alert-success`）。例外的是Django的`error`标签，对应的Bootstrap类是`alert-danger`。有关Bootstrap警报的更多信息，请参阅[https://getbootstrap.com/docs/4.0/components/alerts/](https://getbootstrap.com/docs/4.0/components/alerts/)。这就是为什么你需要在这个片段中使用`if`模板标签的原因。
- en: Create a new template called `instance-form.html`, inside the `reviews` app's
    namespaced `templates` directory.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`reviews`应用的命名空间`templates`目录中创建一个新的模板`instance-form.html`。
- en: '`instance-form.html` should extend from the `reviews` app''s `base.html`.'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`instance-form.html`应该从`reviews`应用的`base.html`扩展。'
- en: 'The context being passed to this template will contain a variable called `instance`.
    This will be the `Publisher` instance being edited, or `None` if we are creating
    a new `Publisher` instance. The context will also contain a `model_type` variable,
    which is a string indicating the model type (in this case, `Publisher`). Use these
    two variables to populate the `title` block template tag:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传递给此模板的上下文将包含一个名为`instance`的变量。这将是要编辑的`Publisher`实例，或者如果我们正在创建新的`Publisher`实例，则为`None`。上下文还将包含一个`model_type`变量，它是一个表示模型类型的字符串（在这种情况下，`Publisher`）。使用这两个变量来填充`title`块模板标签：
- en: If the instance is `None`, the title should be `New Publisher`.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果实例是`None`，标题应该是`新出版商`。
- en: Otherwise, the title should be `Editing Publisher <Publisher Name>`.
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 否则，标题应该是`编辑出版商 <出版商名称>`。
- en: '`instance-form.html` should contain a `content` `block` template tag to override
    the `base.html` `content` block.'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`instance-form.html`应包含一个`content` `block`模板标签以覆盖`base.html`的`content`块。'
- en: Add an `<h2>` element inside the `content` block and populate it using the same
    logic as the title. For better styling, wrap the publisher name in an `<em>` element.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`content`块内添加一个`<h2>`元素，并使用与标题相同的逻辑进行填充。为了更好的样式，将出版商名称包裹在一个`<em>`元素中。
- en: Add a `<form>` element to the template with a `method` of `post`. Since we are
    posting back to the same URL, an `action` does not need to be specified.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板中添加一个`method`为`post`的`<form>`元素。由于我们正在将数据发送回相同的URL，因此不需要指定`action`。
- en: Include the CSRF token template tag in the `<form>` body.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<form>`体中包含CSRF令牌模板标签。
- en: Render the Django form (its context variable will be `form`) inside `<form>`,
    using the `as_p` method.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`as_p`方法在`<form>`内渲染Django表单（其上下文变量将是`form`)。
- en: Add a `submit` `<button>` to the form. Its text should depend on whether you
    are editing or creating. Use the text `Save` for editing or `Create` for creating.
    You can use the Bootstrap classes for the button styling here. It should have
    the attribute `class="btn btn-primary"`.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `reviews/views.py`, the `publisher_edit` view does not need many changes.
    Update the `render` call to render `instance-form.html` instead of `form-example.html`.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the context dictionary being passed to the `render` call. It should include
    the `Publisher` instance (the `publisher` variable that was already defined) and
    `model_type` string. The context dictionary already includes `form` (a `PublisherForm`
    instance). You can remove the `method` key.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we're finished with the `form-example.html` template, it can be deleted.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you''ve finished, the `Publisher` creation page (at `http://127.0.0.1:8000/publishers/new/`)
    should look like *Figure 7.24*:'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.24: The Publisher creation page'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_07_24.jpg)'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.24: The Publisher creation page'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'When editing a `Publisher` (for example, at the URL `http://127.0.0.1:8000/publishers/1/`),
    your page should look like *Figure 7.25*:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.25: The Editing Publisher page'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_07_25.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.25: The Editing Publisher page'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'After saving a `Publisher` instance, whether creating or editing, you should
    see the success message at the top of the page (*Figure 7.26*):'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.26: Success message rendered as a Bootstrap alert'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_07_26.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.26: Success message rendered as a Bootstrap alert'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 7.02: Review Creation UI'
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Activity 7.01*, *Styling and Integrating the Publisher Form*, was quite extensive;
    however, by completing it, you have created a foundation that makes it easier
    to add other *edit* and *create* views. You will experience this first-hand in
    this activity when you will build forms for creating and editing reviews. Because
    the `instance-form.html` template was made generically, you can reuse it in other
    views.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, you will create a review `ModelForm`, then add a `review_edit`
    view to create or edit a `Review` instance. You can reuse `instance-form.html`
    from *Activity 7.01*, *Styling and Integrating the Publisher Form*, and pass in
    different context variables to make it work with the `Review` model. When working
    with reviews, you will operate within the context of a book, that is, the `review_edit`
    view must accept a book's `pk` as an argument. You will fetch the `Book` instance
    separately and assign it to the `Review` instance that you create.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete this activity:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: In `forms.py`, add a `ReviewForm` subclass of `ModelForm`; its model should
    be `Review` (make sure you `import` the `Review` model).
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ReviewForm` should exclude the `date_edited` and `book` fields since the user
    should not be setting these in the form. The database allows any rating, but we
    can override the `rating` field with an `IntegerField` that requires a minimum
    value of *0* and a maximum value of *5*.'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ReviewForm`应该排除`date_edited`和`book`字段，因为用户不应该在表单中设置这些。数据库允许任何评分，但我们可以用需要最小值为*0*和最大值为*5*的`IntegerField`覆盖`rating`字段。'
- en: 'Create a new view called `review_edit`. It should accept two arguments after
    `request`: `book_pk`, which is required, and `review_pk`, which is optional (defaults
    to `None`). Fetch the `Book` instance and `Review` instance using the `get_object_or_404`
    shortcut (call it once for each type). When fetching the review, make sure the
    review belongs to the book. If `review_pk` is `None`, then the `Review` instance
    should be `None` too.'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的视图`review_edit`。它在`request`之后接受两个参数：必需的`book_pk`，可选的`review_pk`（默认为`None`）。使用`get_object_or_404`快捷方式（对每种类型调用一次）获取`Book`实例和`Review`实例。在获取评论时，确保评论属于该书籍。如果`review_pk`是`None`，那么`Review`实例也应该是`None`。
- en: If the `request` method is `POST`, then instantiate a `ReviewForm` using `request.POST`
    and the review instance. Make sure you `import` the `ReviewForm`.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`request`方法为`POST`，则使用`request.POST`和评论实例实例化一个`ReviewForm`。确保你`导入`了`ReviewForm`。
- en: If the form is valid, save the form but set the `commit` argument to `save`
    to `False`. Then, set the `book` attribute on the returned `Review` instance to
    the book fetched in *step 2*.
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果表单有效，保存表单但将`commit`参数设置为`save`为`False`。然后，将返回的`Review`实例上的`book`属性设置为在*步骤2*中获取的书籍。
- en: If the `Review` instance was being updated instead of created, then you should
    also set the `date_edited` attribute to the current date and time. Use the `from`
    `django.utils.timezone.now()` function. Then, save the `Review` instance.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果正在更新`Review`实例而不是创建它，那么你还应该将`date_edited`属性设置为当前日期和时间。使用`from` `django.utils.timezone.now()`函数。然后，保存`Review`实例。
- en: Finish the valid form branch by registering a success message and redirecting
    back to the `book_detail` view. Since the `Review` model doesn't really contain
    a meaningful text description, use the book title in the message. For example,
    `Review for "<book title>" created`.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过注册成功消息并将重定向回`book_detail`视图来完成有效的表单分支。由于`Review`模型实际上不包含有意义的文本描述，所以使用书籍标题作为消息。例如，`Review
    for "<book title>" created`。
- en: If the `request` method is not `POST`, instantiate a `ReviewForm` and just pass
    in the `Review` instance.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`request`方法不是`POST`，实例化一个`ReviewForm`并仅传递`Review`实例。
- en: 'Render the `instance-form.html` template. In the context dictionary, include
    the same items as were used in `publisher_view`: `form`, `instance`, and `model_type`
    (`Review`). Include two extra items, `related_model_type`, which should be `Book`,
    and `related_instance`, which will be the `Book` instance.'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染`instance-form.html`模板。在上下文字典中，包括与在`publisher_view`中使用的相同项：`form`、`instance`和`model_type`（`Review`）。包括两个额外项，`related_model_type`，它应该是`Book`，以及`related_instance`，它将是`Book`实例。
- en: 'Edit `instance-form.html` to add a place to display the related instance information
    added in *step 6*. Under the `<h2>` element, add a `<p>` element that is only
    displayed if both `related_model_type` and `related_instance` are set. It should
    show the text `For <related_model_type> <related_instance>`. For example: `For
    Book Advanced Deep Learning with Keras`. Put the `related_instance` output in
    an `<em>` element for better readability.'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`instance-form.html`以添加一个显示在*步骤6*中添加的相关实例信息的地方。在`<h2>`元素下添加一个`<p>`元素，只有当`related_model_type`和`related_instance`都设置时才显示。它应该显示文本`For
    <related_model_type> <related_instance>`。例如：`For Book Advanced Deep Learning with
    Keras`。将`related_instance`输出放在`<em>`元素中以获得更好的可读性。
- en: In the `reviews` app's `urls.py` file, add URL maps to the `review_edit` view.
    The URLs `/books/` and `/books/<pk>/` are already configured. Add the URLs `/books/<book_pk>/reviews/new/`
    to create a review, and `/books/<book_pk>/reviews/<review_pk>/` to edit a review.
    Make sure you give these names such as `review_create` and `review_edit`.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`reviews`应用的`urls.py`文件中，向`review_edit`视图添加URL映射。URL `/books/` 和 `/books/<pk>/`
    已经配置好了。添加URL `/books/<book_pk>/reviews/new/` 来创建评论，以及 `/books/<book_pk>/reviews/<review_pk>/`
    来编辑评论。确保你给出这些名称，例如`review_create`和`review_edit`。
- en: Inside the `book_detail.html` template, add links that a user can click to create
    or edit a review. Add a link inside the `content` block, just before the `endblock`
    closing template tag. It should use the `url` template tag to link to the `review_edit`
    view when in creation mode. Also, use the attribute `class="btn btn-primary"`
    to make the link display like a Bootstrap button. The link text should be `Add
    Review`.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`book_detail.html`模板中，添加用户可以点击以创建或编辑评论的链接。在`content`块内，紧接在`endblock`关闭模板标签之前添加一个链接。它应该使用`url`模板标签在创建模式时链接到`review_edit`视图。同时，使用属性`class="btn
    btn-primary"`使链接显示为Bootstrap按钮。链接文本应该是`添加评论`。
- en: 'Finally, add a link to edit a review, inside the `for` loop that iterates over
    `Reviews` for `Book`. After all the instances of `text-info` `<span>`, add a link
    to the `review_edit` view using the `url` template tag. You will need to provide
    `book.pk` and `review.pk` as arguments. The text of the link should be `Edit Review`.
    When you are finished, the `Review Comments` page should look like *Figure 7.27*:![Figure
    7.27: Book detail page with added Add Review button'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在遍历`Book`的`Reviews`的`for`循环中添加一个编辑评论的链接。在所有`text-info` `<span>`实例之后添加一个链接到`review_edit`视图，使用`url`模板标签。你需要提供`book.pk`和`review.pk`作为参数。链接的文本应该是`编辑评论`。完成之后，`评论详情`页面应该看起来像*图7.27*：![图7.27：添加了添加评论按钮的书籍详情页面
- en: '](img/B15509_07_27.jpg)'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15509_07_27.jpg)'
- en: 'Figure 7.27: Book detail page with added Add Review button'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.27：添加了添加评论按钮的书籍详情页面
- en: 'You can see the `Add Review` button. Clicking it will take you to the `Create
    Book Review` page, which should look like *Figure 7.28*:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`添加评论`按钮。点击它将带你到`创建书籍评论`页面，它应该看起来像*图7.28*：
- en: '![Figure 7.28: Review creation page'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.28：评论创建页面'
- en: '](img/B15509_07_28.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15509_07_28.jpg)'
- en: 'Figure 7.28: Review creation page'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.28：评论创建页面
- en: 'Enter some details in the form and click `Create`. You will be redirected to
    the `Book Details` page, and you should see the success message and your review,
    as in *Figure 7.29*:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单中输入一些详细信息并点击`创建`。你将被重定向到`书籍详情`页面，你应该看到成功消息和你的评论，就像*图7.29*：
- en: '![Figure 7.29: Book Details page with review added'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.29：添加了评论的书籍详情页面'
- en: '](img/B15509_07_29.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15509_07_29.jpg)'
- en: 'Figure 7.29: Book Details page with review added'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.29：添加了评论的书籍详情页面
- en: 'You can also see the `Edit Review` link, and if you click it, you will be taken
    to a form that is pre-populated with your review data (see *Figure 7.30*):'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以看到`编辑评论`链接，如果你点击它，你将被带到包含你的评论数据的表单（见*图7.30*）：
- en: '![Figure 7.30: Review form when editing a review'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.30：编辑评论时的评论表单'
- en: '](img/B15509_07_30.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15509_07_30.jpg)'
- en: 'Figure 7.30: Review form when editing a review'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.30：编辑评论时的评论表单
- en: 'After saving an existing review, you should see the `Modified on` date is updated
    on the `Book Details` page (*Figure 7.31*):'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 保存现有的评论后，你应该在`书籍详情`页面上看到`修改于`日期已更新（*图7.31*）：
- en: '![Figure 7.31: The Modified on date is now populated'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.31：修改日期现在已填充'
- en: '](img/B15509_07_31.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15509_07_31.jpg)'
- en: 'Figure 7.31: The Modified on date is now populated'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.31：修改日期现在已填充
- en: Note
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在[http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ)找到。
- en: Summary
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was a deep dive into forms. We saw how to enhance Django forms
    with custom validation advanced rules for cleaning data and validating fields.
    We saw how custom cleaning methods can transform the data that we get out of forms.
    A nice feature we saw that can be added to forms is the ability to set initial
    and placeholder values on fields, so the user does not have to fill them out.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了表单。我们看到了如何通过自定义验证规则、清理数据和验证字段来增强Django表单。我们看到了如何通过自定义清理方法转换从表单中获取的数据。我们看到了可以添加到表单中的一个很好的功能，即能够在字段上设置初始值和占位符值，这样用户就不必填写它们。
- en: We then looked at how to use the `ModelForm` class to automatically create a
    form from a Django model. We saw how to only show some fields to the user and
    how to apply custom form validation rules to the `ModelForm`. We also saw how
    Django can automatically save the new or updated model instance to the database
    inside the view. In the activities for this chapter, we enhanced Bookr some more
    by adding forms for creating and editing publishers and submitting reviews. The
    next chapter will carry on the theme of submitting user input, and along with
    that, we'll discuss how Django handles uploading and downloading files.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来探讨了如何使用`ModelForm`类从Django模型自动创建表单。我们看到了如何只向用户显示一些字段，以及如何将自定义表单验证规则应用到`ModelForm`上。我们还了解到Django如何在视图中自动将新或更新的模型实例保存到数据库中。在本章的活动部分，我们通过添加创建和编辑出版社以及提交评论的表单，进一步增强了Bookr的功能。下一章将继续探讨提交用户输入的主题，并在此基础上，我们将讨论Django如何处理文件的上传和下载。
