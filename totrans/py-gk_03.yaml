- en: '*Chapter 2*: Using Modularization to Handle Complex Projects'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you start programming in Python, it is very tempting to put all your program
    code in a single file. There is no problem in defining functions and classes in
    the same file where your main program is. This option is attractive to beginners
    because of the ease of execution of the program and to avoid managing code in
    multiple files. But a single-file program approach is not scalable for medium-
    to large-size projects. It becomes challenging to keep track of all the various
    functions and classes that you define.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome the situation, modular programming is the way to go for medium to
    large projects. Modularity is a key tool to reduce the complexity of a project.
    Modularization also facilitates efficient programming, easy debugging and management,
    collaboration, and reusability. In this chapter, we will discuss how to build
    and consume modules and packages in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to modules and packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading and initializing a module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing reusable modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing packages from any location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing a package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will help you understand the concepts of modules and packages in
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the technical requirements for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to have Python 3.7 or later installed on your computer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to register an account with Test PyPI and create an API token under
    your account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sample code for this chapter can be found at [https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter02](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to modules and packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modules in Python are Python files with a `.py` extension. In reality, they
    are a way to organize functions, classes, and variables using one or more Python
    files such that they are easy to manage, reuse across the different modules, and
    extend as the programs become complex.
  prefs: []
  type: TYPE_NORMAL
- en: A Python package is the next level of modular programming. A package is like
    a folder for organizing multiple modules or sub-packages, which is fundamental
    for sharing the modules for reusability.
  prefs: []
  type: TYPE_NORMAL
- en: Python source files that use only the standard libraries are easy to share and
    easy to distribute using email, GitHub, and shared drives, with the only caveat
    being that there should be Python version compatibility. But this sharing approach
    will not scale for projects that have a decent number of files and have dependencies
    on third-party libraries and may be developed for a specific version of Python.
    To rescue the situation, building and sharing packages is a must for efficient
    sharing and reusability of Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss how to import modules and the different types of import
    techniques supported in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Importing modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python code in one module can get access to the Python code in another module
    by a process called importing modules.
  prefs: []
  type: TYPE_NORMAL
- en: To elaborate on the different module and package concepts, we will build two
    modules and one main script that will use those two modules. These two modules
    will be updated or reused throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new module, we will create a `.py` file with the name of the module.
    We will create a `mycalculator.py` file with two functions: `add` and `subtract`.
    The `add` function computes the sum of the two numbers provided to the function
    as arguments and returns the computed value. The `subtract` function computes
    the difference between the two numbers provided to the function as arguments and
    returns the computed value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A code snippet of `mycalculator.py` is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that the name of the module is the name of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a second module by adding a new file with the name `myrandom.py`.
    This module has two functions: `random_1d` and `random_2d`. The `random_1d` function
    is for generating a random number between 1 and 9 and the `random_2d` function
    is for generating a random number between 10 and 99\. Note that this module is
    also using the `random` library, which is a built-in module from Python.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code snippet of `myrandom.py` is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To consume these two modules, we also created the main Python script (`calcmain1.py`),
    which imports the two modules and uses them to achieve these two calculator functions.
    The `import` statement is the most common way to import built-in or custom modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'A code snippet of `calcmain1.py` is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this main script (another module), we import the two modules using the `import`
    statement. We defined the main function (`my_main`), which will be executed only
    if this script or the `calcmain1` module is executed as the main program. The
    details of executing the main function from the main program will be covered later
    in the *Setting special variables* section. In the `my_main` function, we are
    generating two random numbers using the `myrandom` module and then calculating
    the sum and difference of the two random numbers using the `mycalculator` module.
    In the end, we are sending the results to the console using the `print` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: A module is loaded only once. If a module is imported by another module or by
    the main Python script, the module will be initialized by executing the code in
    the module. If another module in your program imports the same module again, it
    will not be loaded twice but only once. This means if there are any local variables
    inside the module, they will act as a Singleton (initialized only once).
  prefs: []
  type: TYPE_NORMAL
- en: There are other options available to import a module, such as `importlib.import_module()`
    and the built-in `__import__()` function. Let's discuss how `import` and other
    alternative options works.
  prefs: []
  type: TYPE_NORMAL
- en: Using the import statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned already, the `import` statement is a common way to import a module.
    The next code snippet is an example of using an `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `import` statement is responsible for two operations: first, it searches
    for the module given after the `import` keyword, and then it binds the results
    of that search to a variable name (which is the same as the module name) in the
    local scope of the execution. In the next two subsections, we will discuss how
    `import` works and also how to import specific elements from a module or a package.'
  prefs: []
  type: TYPE_NORMAL
- en: Learning how import works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we need to understand how the `import` statement works. First, we need
    to remind ourselves that all global variables and functions are added to the global
    namespace by the Python interpreter at the start of an execution. To illustrate
    the concept, we can write a small Python program to spit out of the contents of
    the `globals` namespace, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This program has two functions: `print_globals` and `hello`. The `print_globals`
    function will spit out the contents of the global namespace. The `hello` function
    will not be executed and is added here to show its reference in the console output
    of the global namespace. The console output after executing this Python code will
    be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The key points to be noticed in this console output are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `__name__` variable is set to the `__main__` value. This will be discussed
    in more detail in the *Loading and initializing a module* section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__file__` variable is set to the file path of the main module here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A reference to each function is added at the end.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we add `print(globals())` to our `calcmain1.py` script, the console output
    after adding this statement will be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: An important point to note is that there are two additional variables (`mycalculator`
    and `myrandom`) added to the global namespace corresponding to each `import` statement
    used to import these modules. Every time we import a library, a variable with
    the same name is created, which holds a reference to the module just like a variable
    for the global functions (`my_main` in this case).
  prefs: []
  type: TYPE_NORMAL
- en: We will see, in other approaches of importing modules, that we can explicitly
    define some of these variables for each module. The `import` statement does this
    automatically for us.
  prefs: []
  type: TYPE_NORMAL
- en: Specific import
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also import something specific (variable or function or class) from
    a module instead of importing the whole module. This is achieved using the `from`
    statement, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Another best practice is to use a different name for an imported module for
    convenience or sometimes when the same names are being used for different resources
    in two different libraries. To illustrate this idea, we will be updating our `calcmain1.py`
    file (the updated program is `calcmain2.py`) from the earlier example by using
    the `calc` and `rand` aliases for the `mycalculator` and `myrandom` modules, respectively.
    This change will make use of the modules in the main script much simpler, as shown
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As a next step, we will combine the two concepts discussed earlier in the next
    iteration of the `calcmain1.py` program (the updated program is `calcmain3.py`).
    In this update, we will use the `from` statement with the module names and then
    import the individual functions from each module. In the case of the `add` and
    `subtract` functions, we used the `as` statement to define a different local definition
    of the module resource for illustration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A code snippet of `calcmain3.py` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As we used the `print (globals())` statement with this program, the console
    output of this program will show that the variables corresponding to each function
    are created as per our alias. The sample console output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that the variables in bold correspond to the changes we made in the `import`
    statements in the `calcmain3.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: Using the __import__ statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `__import__` statement is a low-level function in Python that takes a string
    as input and triggers the actual import operation. Low-level functions are part
    of the core Python language and are typically meant to be used for library development
    or for accessing operating system resources, and are not commonly used for application
    development. We can use this keyword to import the `random` library in our `myrandom.py`
    module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the code in `myrandom.py` can be used as it is without any change.
  prefs: []
  type: TYPE_NORMAL
- en: We illustrated a simple case of using the `__import__` method for academic reasons
    and we will skip the advanced details for those of you who are interested in exploring
    as further reading. The reason for this is that the `__import__` method is not
    recommended to be used for user applications; it is designed more for interpreters.
  prefs: []
  type: TYPE_NORMAL
- en: The `importlib.import_module` statement is the one to be used other than the
    regular import for advanced functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Using the importlib.import_module statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can import any module using the `importlib` library. The `importlib` library
    offers a variety of functions, including `__import__`, related to importing modules
    in a more flexible way. Here is a simple example of how to import a `random` module
    in our `myrandom.py` module using `importlib`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the code in `myrandom.py` can be used as it is without any change.
  prefs: []
  type: TYPE_NORMAL
- en: The `importlib` module is best known for importing modules dynamically and is
    very useful in cases where the name of the module is not known in advance and
    we need to import the modules at runtime. This is a common requirement for the
    development of plugins and extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Commonly used functions available in the `importlib` module are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__import__`: This is the implementation of the `__import__` function, as already
    discussed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import_module`: This is used to import a module and is most commonly used
    to load a module dynamically. In this method, you can specify whether you want
    to import a module using an absolute or relative path. The `import_module` function
    is a wrapper around `importlib.__import__`. Note that the former function brings
    back the package or module (for example, `packageA.module1`), which is specified
    with the function, while the latter function always returns the top-level package
    or module (for example, `packageA`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`importlib.util.find_spec`: This is a replaced method for the `find_loader`
    method, which is deprecated since Python release 3.4\. This method can be used
    to validate whether the module exists and it is valid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invalidate_caches`: This method can be used to invalidate the internal caches
    of finders stored at `sys.meta_path`. The internal cache is useful to load the
    module faster without triggering the finder methods again. But if we are dynamically
    importing a module, especially if it is created after the interpreter began execution,
    it is a best practice to call the `invalidate_caches` method. This function will
    clear all modules or libraries from the cache to make sure the requested module
    is loaded from the system path by the `import` system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reload`: As the name suggests, this function is used to reload a previously
    imported module. We need to provide the module object as an input parameter for
    this function. This means the `import` function has to be done successfully. This
    function is very helpful when module source code is expected to be edited or changed
    and you want to load the new version without restarting the program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Absolute versus relative import
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have fairly a good idea of how to use `import` statements. Now it is time
    to understand **absolute** and **relative** imports, especially when we are importing
    custom or project-specific modules. To illustrate the two concepts, let''s take
    an example of a project with different packages, sub-packages, and modules, as
    shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using this project structure, we will discuss how to use absolute and relative
    imports.
  prefs: []
  type: TYPE_NORMAL
- en: Absolute import
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use absolute paths starting from the top-level package and drilling
    down to the sub-package and module level. A few examples of importing different
    modules are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: For absolute import statements, we must give a detailed path for each package
    or file, from the top-level package folder, which is similar to a file path.
  prefs: []
  type: TYPE_NORMAL
- en: Absolute imports are recommended because they are easy to read and easy to follow
    the exact location of imported resources. Absolute imports are least impacted
    by project sharing and changes in the current location of `import` statements.
    In fact, PEP 8 explicitly recommends the use of absolute imports.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, however, absolute imports are quite long statements depending on
    the size of the project folder structure, which is not convenient to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Relative import
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A relative import specifies the resource to be imported relative to the current
    location, which is mainly the current location of the Python code file where the
    `import` statement is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the project examples discussed earlier, here are a few scenarios of relative
    import. The equivalent relative import statements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`funct1` inside `module1.py`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`module4` inside `module1.py`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Func2` inside `module1.py`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: One advantage of relative imports is that they are simple and can significantly
    reduce long `import` statements. But relative `import` statements can be messy
    and difficult to maintain when projects are shared across teams and organizations.
    Relative imports are not easy to read and manage.
  prefs: []
  type: TYPE_NORMAL
- en: Loading and initializing a module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever the Python interpreter interacts with an `import` or equivalent statement,
    it does three operations, which are described in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Python interpreter searches for the specified module on a `sys.path` (to
    be discussed in the *Accessing packages from any location* section) and loads
    the source code. This has been explained in the *Learning how import works* section.
  prefs: []
  type: TYPE_NORMAL
- en: Setting special variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this step, the Python interpreter defines a few special variables, such as
    `__name__`, which basically defines the namespace that a Python module is running
    in. The `__name__` variable is one of the most important variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of our example of the `calcmain1.py`, `mycalculator.py`, and `myrandom.py`
    modules, the `__name__` variable will be set for each module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.1 – The __name__ attribute value for different modules](img/table.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 2.1 – The __name__ attribute value for different modules
  prefs: []
  type: TYPE_NORMAL
- en: There are two cases of setting the `__name__` variable, which are described
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Case A – module as the main program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you are running your module as the main program, the `__name__` variable
    will be set to the `__main__` value regardless of whatever the name of the Python
    file or module is. For example, when `calcmain1.py` is executed, the interpreter
    will assign the hardcoded `__main__` string to the `__name__` variable. If we
    run `myrandom.py` or `mycalculator.py` as the main program, the `__name__` variable
    will automatically get the value of `__main__`.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we added an `if __name__ == '__main__'` line to all main scripts
    to check whether this is the main execution program.
  prefs: []
  type: TYPE_NORMAL
- en: Case B – module is imported by another module
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this case, your module is not the main program, but it is imported by another
    module. In our example, `myrandom` and `mycalculator` are imported in `calcmain1.py`.
    As soon as the Python interpreter finds the `myrandom.py` and `mycalculator.py`
    files, it will assign the `myrandom` and `mycalculator` names from the `import`
    statement to the `__name__` variable for each module. This assignment is done
    prior to executing the code inside these modules. This is reflected in *Table
    2.1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the other noticeable special variables are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__file__`: This variable contains the path to the module that is currently
    being imported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__doc__`: This variable will output the docstring that is added in a class
    or a method. As discussed in [*Chapter 1*](B17189_01_Final_PG_ePub.xhtml#_idTextAnchor013),
    *Optimal Python Development Life Cycle*, a docstring is a comment line added right
    after the class or method definition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__package__`: This is used to indicate whether the module is a package or
    not. Its value can be a package name, an empty string, or `none`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__dict__`: This will return all attributes of a class instance as a dictionary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dir`: This is actually a method that returns every associated method or attribute
    as a list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Locals` and `globals`: These are also used as methods that display the local
    and global variables as dictionary entries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing the code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After the special variables are set, the Python interpreter executes the code
    in the file line by line. It is important to know that functions (and the code
    under the classes) are not executed unless they are not called by other lines
    of code. Here is a quick analysis of the three modules from the execution point
    of view when `calcmain1.py` is run:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mycalculator.py`: After setting the special variables, there is no code to
    be executed in this module at the initialization time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`myrandom.py`: After setting the special variables and the `import` statement,
    there is no further code to be executed in this module at initialization time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calcmain1.py`: After setting the special variables and executing the `import`
    statements, it executes the following `if` statement: `if __name__ == "__main__":`.
    This will return `true` because we launched the `calcmain1.py` file. Inside the
    `if` statement, the `my_main ()` function will be called, which in fact then calls
    methods from the `myrandom.py` and `mycalculator.py` modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can add an `if __name__ == "__main__"` statement to any module regardless
    of whether it is the main program or not. The advantage of using this approach
    is that the module can be used both as a module or as a main program. There is
    also another application of using this approach, which is to add unit tests within
    the module.
  prefs: []
  type: TYPE_NORMAL
- en: Standard modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python comes with a library of over 200 standard modules. The exact number
    varies from one distribution to the other. These modules can be imported into
    your program. The list of these modules is very extensive but only a few commonly
    used modules are mentioned here as an example of standard modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`math`: This module provides mathematical functions for arithmetic operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`random`: This module is helpful to generate pseudo-random numbers using different
    types of distributions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`statistics`: This module offers statistics functions such as `mean`, `median`,
    and `variance`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`base64`: This module provides functions to encode and decode data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calendar`: This module offers functions related to the calendar, which is
    helpful for calendar-based computations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collections`: This module contains specialized container data types other
    than the general-purpose built-in containers (such as `dict`, `list`, or `set`).
    These specialized data types include `deque`, `Counter`, and `ChainMap`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`csv`: This module helps in reading from and writing to comma-based delimited
    files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`datetime`: This module offers general-purpose data and time functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal`: This module is specific for decimal-based arithmetic operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logging`: This module is used to facilitate logging into your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os` and `os.path`: These modules are used to access operating system-related
    functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket`: This module provides low-level functions for socket-based network
    communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sys`: This module provides access to a Python interpreter for low-level variables
    and functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time`: This module offers time-related functions such as converting to different
    time units.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing reusable modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For a module to be declared reusable, it has to have the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Independent functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General-purpose functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conventional coding style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well-defined documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a module or package does not have these characteristics, it would be very
    hard, if not impossible, to reuse it in other programs. We will discuss each characteristic
    one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Independent functionality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The functions in a module should offer functionality independent of other modules
    and independent of any local or global variables. The more independent the functions
    are, the more reusable the module is. If it has to use other modules, it has to
    be minimal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example of `mycalculator.py`, the two functions are completely independent
    and can be reused by other programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – The mycalculator module with add and subtract functions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_02_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – The mycalculator module with add and subtract functions
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of `myrandom.py`, we are using the `random` system library to provide
    the functionality of generating random numbers. This is still a very reusable
    module because the `random` library is one of the built-in modules in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – The myrandom module with function dependency on the random library'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_02_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – The myrandom module with function dependency on the random library
  prefs: []
  type: TYPE_NORMAL
- en: In cases where we have to use third-party libraries in our modules, we can get
    into problems when sharing our modules with others if the target environment does
    not have the third-party libraries already installed.
  prefs: []
  type: TYPE_NORMAL
- en: To elaborate this problem further, we'll introduce a new module, `mypandas.py`,
    which will leverage the basic functionality of the famous `pandas` library. For
    simplicity, we added only one function to it, which is to print the DataFrame
    as per the dictionary that is provided as an input variable to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code snippet of `mypandas.py` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `mypandas.py` module will be using the `pandas` library to create a `dataframe`
    object from the dictionary. This dependency is shown in the next block diagram
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – The mypandas module with dependency on a third-party pandas
    library'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_02_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – The mypandas module with dependency on a third-party pandas library
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `pandas` library is not a built-in or system library. When we
    try to share this module with others without defining a clear dependency on a
    third-party library (`pandas` in this case), the program that will try to use
    this module will give the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is why it is important that the module is as independent as possible. If
    we have to use third-party libraries, we need to define clear dependencies and
    use an appropriate packaging approach. This will be discussed in the *Sharing
    a package* section.
  prefs: []
  type: TYPE_NORMAL
- en: Generalization functionality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An ideal reusable module should focus on solving a general problem rather than
    a very specific problem. For example, we have a requirement of converting inches
    to centimeters. We can easily write a function that converts inches into centimeters
    by applying a conversion formula. What about writing a function that converts
    any value in the imperial system to a value in the metric system? We can have
    one function for different conversions that may handle inches to centimeters,
    feet to meters, or miles to kilometers, or separate functions for each type of
    these conversions. What about the reverse functions (centimeters to inches)? This
    may not be required now but may be required later on or by someone who is reusing
    this module. This generalization will make the module functionality not only comprehensive
    but also more reusable without extending it.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the generalization concept, we will revise the design of the `myrandom`
    module to make it more general and thus more reusable. In the current design,
    we define separate functions for one-digit and two-digit numbers. What if we need
    to generate a three-digit random number or to generate a random number between
    20 and 30? To generalize the requirement, we introduce a new function, `get_random`,
    in the same module, which takes user input for lower and upper limits of the random
    numbers. This newly added function is a generalization of the two random functions
    we already defined. With this new function in the module, the two existing functions
    can be removed, or they can stay in the module for convenience of use. Note that
    the newly added function is also offered by the `random` library out of the box;
    the reason for providing the function in our module is purely for illustration
    of the generalized function (`get_random` in this case) versus the specific functions
    (`random_1d` and `random_2d` in this case).
  prefs: []
  type: TYPE_NORMAL
- en: 'The updated version of the `myrandom.py` module (`myrandomv2.py`) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Conventional coding style
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This primarily focuses on how we write function names, variable names, and module
    names. Python has a coding system and naming conventions, which were discussed
    in the previous chapter of this book. It is important to follow the coding and
    naming conventions, especially when building reusable modules and packages. Otherwise,
    we will be discussing such modules as bad examples of reusable modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this point, we will show the following code snippet with function
    and parameter names using camel case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you are coming from a Java background, this code style will seem fine. But
    it is considered bad practice in Python. The use of the non-Pythonic style of
    coding makes the reusability of such modules very difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another snippet of a module with appropriate coding style for function
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example of a good reusable coding style is illustrated in the next
    screenshot, which is taken from the PyCharm IDE for the `pandas` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – The pandas library view in the PyCharm IDE'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_02_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – The pandas library view in the PyCharm IDE
  prefs: []
  type: TYPE_NORMAL
- en: The functions and the variable names are easy to follow even without reading
    any documentation. Following a standard coding style makes the reusability more
    convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Well-defined documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Well-defined and clear documentation is as important as writing a generalized
    and independent module with the Python coding guidelines. Without clear documentation,
    the module will not increase the interest of developers to reuse with convenience.
    But as programmers, we put more focus on the code than the documentation. Writing
    a few lines of documentation can make 100 lines of our code more usable and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will provide a couple of good examples of documentation from a module point
    of view by using our `mycalculator.py` module example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python, it is important to remember the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use three quote characters to mark a string that goes across more than
    one line of the Python source file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triple-quoted strings are used at the start of a module, and then this string
    is used as the documentation for the module as a whole.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any function starts with a triple-quoted string, then this string is used
    as documentation for that function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a general conclusion, we can make as many modules as we want by writing hundreds
    of lines of code, but it takes more than writing code to make a reusable module,
    including generalization, coding style, and most importantly, documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Building packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of techniques and tools available for creating and distributing
    packages. The truth is that Python does not have a great history of standardizing
    the packaging process. There have been multiple projects started in the first
    decade of the 21st century to streamline this process but not with a lot of success.
    In the last decade, we have had some success, thanks to the initiatives of the
    **Python Packaging Authority** (**PyPA**).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will be covering techniques of building packages, accessing
    the packages in our program, and publishing and sharing the packages as per the
    guidelines provided by PyPA.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with package names, followed by the use of an initialization file,
    and then jump into building a sample package.
  prefs: []
  type: TYPE_NORMAL
- en: Naming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Package names should follow the same rule for naming as for modules, which is
    lowercase with no underscores. Packages act like structured modules.
  prefs: []
  type: TYPE_NORMAL
- en: Package initialization file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A package can have an optional source file named `__init__.py` (or simply an
    `init` file). The presence of the `init` file (even a blank one) is recommended
    to mark folders as packages. Since Python release 3.3 or later, the use of an
    `init` file is optional (PEP 420: Implicit Namespace Packages). There can be multiple
    purposes of using this `init` file and there is always a debate about what can
    go inside an `init` file versus what cannot go in. A few uses of the `init` file
    are discussed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Empty __init__.py**: This will force developers to use explicit imports and
    manage the namespaces as they like. As expected, developers have to import separate
    modules, which can be tedious for a large package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__init__` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init` file from different modules and manage them under the package namespace.
    This provides the additional benefit of providing a wrapper around the underlying
    module''s functionality. If by any chance we have to refactor the underlying modules,
    we have an option to keep the namespace the same, especially for API consumers.
    The only drawback of this approach is that it requires extra effort to manage
    and maintain such `init` files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, developers add code to the `init` file that is executed when a module
    is imported from a package. An example of such code is to create a session for
    remote systems such as a database or remote SSH server.
  prefs: []
  type: TYPE_NORMAL
- en: Building a package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we will discuss how to build a package with one sample package example.
    We will build a `masifutil` package using the following modules and a sub-package:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mycalculator.py` module: We already built this module for the *Importing
    modules* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `myrandom.py` module: This module was also built for the *Importing modules*
    section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `advcalc` sub-package: This will be a sub-package and will contain one
    module in it (`advcalculator.py`). We will define an `init` file for this sub-package
    but it will be empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `advcalculator.py` module has additional functions for calculating the
    square root and log using base 10 and base 2\. The source code for this module
    is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The file structure of the `masifutil` package with `init` files will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Folder structure of the masifutil package with modules and sub-packages'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_02_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – Folder structure of the masifutil package with modules and sub-packages
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next step, we will build a new main script (`pkgmain1.py`) to consume
    the modules from the package or `masifutil` subfolder. In this script, we will
    import the modules from the main package and sub-package using the folder structure,
    and then use the module functions to compute two random numbers, the sum and difference
    of the two numbers, and the square root and logarithmic values of the first random
    numbers. The source code for `pkgmain1.py` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will be using the package name and module name to import the modules,
    which is cumbersome especially when we need to import the sub-packages. We can
    also use the following statements with the same results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, the use of the empty `__init__.py` file is optional. But
    we have added it in this case for illustration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will explore how to add some `import` statements to the `init` file.
    Let''s start with importing the modules inside the `init` file. In this top-level
    `init` file, we will import all functions as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of `.` before the module name. This is required for Python for
    the strict use of relative imports.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result of these three lines inside the `init` file, the new main script
    will become simple and the sample code is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The functions of the two main modules and the sub-package module are available
    at the main package level and the developers do not need to know the underlying
    hierarchy and structure of the modules within the package. This is the convenience
    we discussed earlier of using `import` statements inside the `init` file.
  prefs: []
  type: TYPE_NORMAL
- en: We build the package by keeping the package source code in the same folder where
    the main program or script resides. This works only to share the modules within
    a project. Next, we will discuss how to access the package from other projects
    and from any program from anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing packages from any location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The package we built in the previous subsection is accessible only if the program
    calling the modules is at the same level as the package location. This requirement
    is not practical for code reusability and code sharing.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss a few techniques to make packages available
    and usable from any program on any location in our system.
  prefs: []
  type: TYPE_NORMAL
- en: Appending sys.path
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a useful option for setting `sys.path` dynamically. Note that `sys.path`
    is a list of directories on which a Python interpreter searches every time it
    executes an `import` statement in a source program. By using this approach, we
    are appending (adding) paths of directories or folders containing our packages
    to `sys.path`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `masifutil` package, we will build a new program, `pkgmain3.py`, which
    is a copy of `pkgmain2.py` (to be updated later) but is kept outside the folder
    where our `masifutil` package is residing. `pkgmain3.py` can be in any folder
    other than the `mypackages` folder. Here is the folder structure with a new main
    script (`pkgmain3.py`) and the `masifutil` package for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Folder structure of the masifutil package and a new main script,
    pkgmain3.py'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_02_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – Folder structure of the masifutil package and a new main script,
    pkgmain3.py
  prefs: []
  type: TYPE_NORMAL
- en: 'When we execute the `pkgmain3.py` program, it returns an error: `ModuleNotFoundError:
    No module named ''masifutil''`. This is expected as the path of the `masifutil`
    package is not added to `sys.path`. To add the package folder to `sys.path`, we
    will update the main program; let''s name it `pkgmain4.py`, with additional statements
    for appending `sys.path`, which is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: After adding the additional lines of appending `sys.path`, we executed the main
    script without any error and with the expected console output. This is because
    our `masifutil` package is now available on a path where the Python interpreter
    can load it when we are importing it in our main script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternative to appending `sys.path`, we can also use the `site.addsitedir`
    function from the site module. The only advantage of using this approach is that
    this function also looks for `.pth` files within the included folders, which is
    helpful for adding additional folders such as sub-packages. A snippet of a sample
    main script (`pktpamin5.py`) with the `addsitedir` function is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note that the directories we append or add using this approach are available
    only during the program execution. To set `sys.path` permanently (at the session
    or system level), the approaches that we will discuss next are more helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Using the PYTHONPATH environment variable
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is a convenient way to add our package folder to `sys.path`, which the
    Python interpreter will use to search for the package and modules if not present
    in the built-in library. Depending on the operating system we are using, we can
    define this variable as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Windows, the environment variable can be defined using either of the following
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PYTHONPATH = "C:\pythonpath1;C:\pythonpath2"`. This is good for one active
    session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The graphical user interface**: Go to **My Computer** | **Properties** |
    **Advanced System Settings** | **Environment Variables**. This is a permanent
    setting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Linux and macOS, it can be set using `` export PYTHONPATH= `/some/path/`
    ``. If set using Bash or an equivalent terminal, the environment variable will
    be effective for the terminal session only. To set it permanently, it is recommended
    to add the environment variable at the end of a profile file, such as `~/bash_profile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we execute the `pkgmain3.py` program without setting `PYTHONPATH`, it returns
    an error: `ModuleNotFoundError: No module named ''masifutil''`. This is again
    expected as the path of the `masifutil` package is not added to `PYTHONPATH`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we will add the folder path containing `masifutil` to the
    `PYTHONPATH` variable and rerun the `pkgmain3` program. This time, it works without
    any error and with the expected console output.
  prefs: []
  type: TYPE_NORMAL
- en: Using the .pth file under the Python site package
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is another convenient way of adding packages to `sys.path`. This is achieved
    by defining a `.pth` file under the Python site packages. The file can hold all
    the folders we want to add to `sys.path`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For illustration purposes, we created a `my.pth` file under `venv/lib/Python3.7/site-packages`.
    As we can see in *Figure 2.7*, we added a folder that contains our `masifutil`
    package. With this simple `.pth` file, our main script `pkymain3.py` program works
    fine without any error and with expected console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – A view of a virtual environment with the my.pth file](img/B17189_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – A view of a virtual environment with the my.pth file
  prefs: []
  type: TYPE_NORMAL
- en: The approaches we discussed to access custom packages are effective to reuse
    the packages and modules on the same system with any program. In the next section,
    we will explore how to share packages with other developers and communities.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing a package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To distribute Python packages and projects across communities, there are many
    tools available. We will focus only on the tools that are recommended as per the
    guidelines provided by PyPA.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will be covering installing and distributing packaging
    techniques. A few tools that we will use or are at least worth mentioning in this
    section as a reference are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**distutils**: This comes with Python with base functionality. It is not easy
    to extend for complex and custom package distribution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**setuputils**: This is a third-party tool and an extension of distutils and
    is recommended for building packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**wheel**: This is for the Python packaging format and it makes installations
    faster and easier as compared to its predecessors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pip install <module name>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Python Package Index (PyPI)**: This is a repository of software for the
    Python programming language. PyPI is used to find and install software developed
    and shared by the Python community.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Twine**: This is a utility for publishing Python packages to PyPI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next subsections, we will update the `masifutil` package to include additional
    components as per the guidelines provided by PyPA. This will be followed by installing
    the updated `masifutil` package system-wide using pip. In the end, we will publish
    the updated `masifutil` package to **Test PyPI** and install it from Test PyPI.
  prefs: []
  type: TYPE_NORMAL
- en: Building a package as per the PyPA guidelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'PyPA recommends using a sample project for building reusable packages and it
    is available at [https://github.com/pypa/sampleproject](https://github.com/pypa/sampleproject).
    A snippet of the sample project from the GitHub location is as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – A view of the sample project on GitHub by PyPA'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_02_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8 – A view of the sample project on GitHub by PyPA
  prefs: []
  type: TYPE_NORMAL
- en: 'We will introduce key files and folders, which are important to understand
    before we use them for updating our `masifutil` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setup.py`: This is the most important file, which has to exist at the root
    of the project or package. It is a script for building and installing the package.
    This file contains a global `setup()` function. The setup file also provides a
    command-line interface for running various commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setup.cfg`: This is an `ini` file that can be used by `setup.py` to define
    defaults.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setup()` args: The key arguments that can be passed to the setup function
    are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a) Name
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b) Version
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c) Description
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d) URL
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: e) Author
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: f) License
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`README.rst`/`README.md`: This file (either reStructured or Markdown format)
    can contain information about the package or project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`license.txt`: The `license.txt` file should be included with every package
    with details of the terms and conditions of distribution. The license file is
    important, especially in countries where it is illegal to distribute packages
    without the appropriate license.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MANIFEST.in`: This file can be used to specify a list of additional files
    to include in the package. This list of files doesn''t include the source code
    files (which are automatically included).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<package>`: This is the top-level package containing all the modules and packages
    inside it. It is not mandatory to use, but it is a recommended approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data`: This is a place to add data files if needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tests`: This is a placeholder to add unit tests for the modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a next step, we will update our previous `masifutil` package as per the
    PyPA guidelines. Here is the new folder and file structure of the updated `masifutilv2`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – A view of the updated masifutilv2 file structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_02_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.9 – A view of the updated masifutilv2 file structure
  prefs: []
  type: TYPE_NORMAL
- en: We have added `data` and `tests` directories, but they are actually empty for
    now. We will evaluate the unit tests in a later chapter to complete this topic.
  prefs: []
  type: TYPE_NORMAL
- en: The contents of most of the additional files are covered in the sample project
    and thus will not be discussed here, except the `setup.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We updated `setup.py` with basic arguments as per our package project. The
    details of the rest of the arguments are available in the sample `setup.py` file
    provided with the sample project by PyPA. Here is a snippet of our `setup.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: With this `setup.py` file, we are ready to share our `masifutilv2` package locally
    as well as remotely, which we will discuss in the next subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Installing from the local source code using pip
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we have updated the package with new files, we are ready to install it
    using the pip utility. The simplest way to install it is by executing the following
    command with the path to the `masifutilv2` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the console output of the command when run without installing
    the wheel package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The pip utility installed the package successfully but using the egg format
    since the `wheel` package was not installed. Here is a view of our virtual environment
    after the installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – A view of the virtual environment after installing masifutilv2
    using pip'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_02_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.10 – A view of the virtual environment after installing masifutilv2
    using pip
  prefs: []
  type: TYPE_NORMAL
- en: After installing the package under the virtual environment, we tested it with
    our `pkgmain3.py` program, which worked as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: To uninstall the package, we can use `pip uninstall masifutilv2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a next step, we will install the `wheel` package and then reinstall the
    same package again. Here is the installation command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output will be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The package is installed successfully using `wheel` this time and we can see
    it appears in our virtual environment as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – A view of the virtual environment after installing masifutilv2
    with wheel and using pip'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_02_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.11 – A view of the virtual environment after installing masifutilv2
    with wheel and using pip
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have installed a package using the pip utility from the
    local source code. In the next section, we will publish the package to a centralized
    repository (Test PyPI).
  prefs: []
  type: TYPE_NORMAL
- en: Publishing a package to Test PyPI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a next step, we will add our sample package to the PyPI repository. Before
    executing any command for publishing our package, we will need to create an account
    on Test PyPI. Note that Test PyPI is a separate instance of the package index
    specifically for testing. In addition to the account with Test PyPI, we also need
    to add an **API token** to the account. We will leave the details of creating
    an account and adding an API token to the account for you by following the instructions
    available on the Test PyPI website ([https://test.pypi.org/](https://test.pypi.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To push the package to Test PyPI, we will need the Twine utility. We assume
    Twine is installed using the pip utility. To upload the `masifutilv2` package,
    we will execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a distribution using the following command. This `sdist` utility will
    create a TAR ZIP file under a `dist` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Upload the distribution file to Test PyPI. When prompted for a username and
    password, provide `__token__` as the username and the API token as the password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This command will push the package TAR ZIP file to the Test PyPI repository
    and the console output will be similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can view the uploaded file at [https://test.pypi.org/project/masifutilv2/0.1.0/](https://test.pypi.org/project/masifutilv2/0.1.0/)
    after a successful upload.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the package from PyPI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Installing the package from Test PyPI is the same as installing from a regular
    repository, except that we need to provide the repository URL by using the `index-url`
    arguments. The command and the console output will be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will present console output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the console output, pip is searching for the module in Test
    PyPI. Once it finds the package with the name `masifutilv2`, it starts downloading
    and then installing it in the virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: In short, we have observed that once we create a package using the recommended
    format and style, then publishing and accessing the package is just a matter of
    using Python utilities and following the standard steps.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the concept of modules and packages in Python.
    We discussed how to build reusable modules and how they can be imported by other
    modules and programs. We also covered the loading and initializing of modules
    when included (by an import process) by other programs. In the later part of this
    chapter, we discussed building simple and advanced packages. We also provided
    a lot of code examples to access the packages, as well as installing and publishing
    the package for efficient reusability.
  prefs: []
  type: TYPE_NORMAL
- en: After going through this chapter, you have learned how to build modules and
    packages and how to share and publish the packages (and modules). These skills
    are important if you are working on a project as a team in an organization or
    you are building Python libraries for a larger community.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the next level of modularization using
    object-oriented programming in Python. This will encompass encapsulation, inheritance,
    polymorphism, and abstraction, which are key tools to build and manage complex
    projects in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between a module and a package?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are absolute and relative imports in Python?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is PyPA?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Test PyPI and why do we need it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is an `init` file a requirement to build a package?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Modular Programming with Python* by Erik Westra'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Expert Python Programming* by Michał Jaworski and Tarek Ziadé'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python Packaging User Guide ([https://packaging.python.org/](https://packaging.python.org/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PEP 420: Implicit Namespace Packages ([https://www.python.org/dev/peps/pep-0420/](https://www.python.org/dev/peps/pep-0420/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A module is meant to organize functions, variables, and classes into separate
    Python code files. A Python package is like a folder to organize multiple modules
    or sub-packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Absolute import requires the use of the absolute path of a package starting
    from the top level, whereas relative import is based on the relative path of the
    package as per the current location of the program in which the `import` statement
    is to be used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Python Packaging Authority** (**PyPA**) is a working group that maintains
    a core set of software projects used in Python packaging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test PyPI is a repository of software for the Python programming language for
    testing purposes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `init` file is optional since Python version 3.3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
