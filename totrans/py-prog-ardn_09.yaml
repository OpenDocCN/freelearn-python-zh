- en: Chapter 9. Arduino and the Internet of Things
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to access Arduino using Ethernet from
    a remote location. The main objective was to get you started with developing Arduino-based
    network applications using Python. We were able to accomplish this using various
    tools such as the `web.py` Python library, Mosquitto MQTT broker, and the Arduino
    Ethernet library. Remote access to sensor data via a Python-like extensible language
    can open up limitless possibilities for sensor-based web applications. In recent
    years, the rapid growth of these applications has enabled the development of a
    domain called the **Internet of Things** (**IoT**).
  prefs: []
  type: TYPE_NORMAL
- en: In the last chapter, we worked on Arduino networking. However, it was limited
    to LAN and the premise of the exercises was limited to your home or office. We
    didn't even involve the Internet to enable global access in our exercises. Traditional
    IoT applications require Arduino to be accessed remotely from any part of the
    world via the Internet. In this chapter, we will extend the Arduino networking
    concepts by interfacing Arduino with cloud-based platforms. We will also develop
    web applications to access the sensor data from these cloud platforms. Later in
    the chapter, we will go through the process of setting up your cloud-based messaging
    platform to serve sensor data. At the end of this chapter, you should be able
    to design and develop full-stack IoT applications, using Arduino, Python, and
    the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the IoT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Long before the Internet, sensor- and actuator-based electronic control systems
    existed in high-tech automation systems. In those systems, sensors were interfaced
    to the microcontroller via hard-wired connections. Due to extensibility limitations,
    the coverage area of these systems was geographically restricted. Examples of
    these high-tech systems included factory automation, satellite systems, weapon
    systems, and so on. In most cases, the sensors used in these systems were huge
    and the microcontrollers were also limited by their low computational capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: With recent advancements in technology, especially in the semiconductor industry,
    the physical size of sensors and microcontrollers has significantly reduced. It
    has also been made possible to manufacture low-cost and highly efficient electronic
    components, hence today it is relatively inexpensive to develop small and efficient
    sensor-based hardware products. Arduino and Raspberry Pi are great examples of
    these achievements. These sensor-and actuator-based hardware systems interface
    with the physical world that we live in. The sensors measure various elements
    from the physical environment, while the actuators manipulate the physical environment.
    These types of hardware-based electronic systems are also known as **physical
    systems**.
  prefs: []
  type: TYPE_NORMAL
- en: On the other front, advancements in the semiconductor industry also enabled
    the development of highly efficient computation units, empowering personal computer
    and networking industries. This movement led to the worldwide network of connected
    computers called CyberWorld or the Internet. Every day, petabytes of data get
    generated and transferred across the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: The domain of IoT stands at the crossroads of these progresses in physical and
    cyber systems, where ancient hardwired sensor-based systems are ready to get upgraded
    to more powerful and efficient systems that are also highly connected through
    the Internet. Due to the large number of sensors involved, these systems generate
    and send an avalanche of data. The data generated by these sensors has already
    eclipsed the data generated by humans.
  prefs: []
  type: TYPE_NORMAL
- en: The IoT has started to become a significant domain in recent years after a large
    number of consumer IoT products have started entering the market. These products
    include applications in home automation, health care, activity tracking, smart
    energy, and so on. One of the major reasons behind the rapid growth of the IoT
    domain is the introduction of these visible solutions. In a large number of cases,
    this was made possible due to fast and inexpensive prototyping that was enabled
    by Arduino and other open source hardware platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point in the book, we have learned various methods of interfacing
    sensors and then developing applications using these connected sensors. In this
    chapter, we will learn the last step in the development of a full-stack IoT application—enabling
    access for your Python-Arduino application through the Internet. Now, let's try
    to first understand the architecture of the IoT.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture of IoT web applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this book, we have covered three major concepts in the first eight chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Physical layer**: We used various sensors and actuators with the Arduino
    board to deal with the physical environment. The sensors such as the temperature
    sensor, humidity sensor, and motion sensor were used measured the physical phenomenon,
    while the actuators such as LEDs were utilized to alter or produce physical elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Computation layer**: We used Arduino sketches and Python programs to convert
    these physical elements into numerical data. We also utilized these high-level
    languages to perform various computations such as calculating relative humidity,
    developing user interfaces, plotting data, and providing web interfaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interfacing layer**: Throughout the material that we covered, we also utilized
    various interfacing methods to establish communication between Arduino and Python.
    For interfacing part of the interfacing layer between the physical and computation
    layers, we used serial port libraries, established network-based communication
    using the REST and MQTT protocol, and developed web applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, we have developed applications with tightly-coupled physical,
    computation, and interfacing layers. In the research domain, these types of applications
    are also known as cyber-physical systems. One of the widely used and popular terms
    for the domain of cyber-physical system is the IoT. Although the cyber-physical
    domain is thoroughly defined compared to the IoT, the IoT has recently gained
    more popularity due to the large number of subdomains—industrial Internet, wearable
    devices, connected devices, smart grid, and so on—that are covered under this
    umbrella term. In simple terms, an application can qualify as an IoT application
    if it consists of hardware devices that deal with the physical world and have
    sufficient computational capabilities with Internet connectivity. Let's try to
    understand the architecture of the IoT from the material that we have already
    covered.
  prefs: []
  type: TYPE_NORMAL
- en: On the physical side, the following figure shows the hardware components that
    we utilized to deal with the physical environment. The sensors and actuators that
    interface with the actual physical world can be connected to Arduino using multiple
    low-level protocols. These components can be connected using GPIO pins and using
    the I2C or SPI protocols. The data acquired from these components gets processed
    on the Arduino board using the code that is uploaded by the user. Although the
    Arduino code can be made self-reliant to execute tasks without any external inputs,
    these inputs from users or other applications are required in advanced applications.
  prefs: []
  type: TYPE_NORMAL
- en: '![Architecture of IoT web applications](img/5938OS_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As part of the communication layer, Arduino can be connected locally to other
    computers using USB. One can extend the coverage range by utilizing Ethernet,
    Wi-Fi, or any other radio communication method.
  prefs: []
  type: TYPE_NORMAL
- en: As illustrated in the following figure, the sensor data is collected using computation
    units for advance processing. These computation units are powerful enough to host
    operating systems and programming platforms. In this book, we utilized Python
    to develop various features at the computation layer. At this level, we performed
    high-level computation tasks such as developing graphical user interfaces using
    the `Tkinter` library, plotting charts using the `matplotlib` library, and developing
    web applications using the `web.py` library.
  prefs: []
  type: TYPE_NORMAL
- en: '![Architecture of IoT web applications](img/5938OS_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In all the coding exercises that we performed previously, the physical coverage
    areas of the projects were limited because of hardwired serial interfaces or local
    Ethernet network, as displayed in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Architecture of IoT web applications](img/5938OS_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To develop full-stack IoT applications, we need to remotely access Arduino or
    host the computation layer on the Internet. In this chapter, we are going to work
    on this missing link and develop various applications to provide Internet connectivity
    to the exercises. To perform this operation, we are going to utilize a commercial
    cloud platform in the first section and develop our customized platform in the
    later section.
  prefs: []
  type: TYPE_NORMAL
- en: As the focus of this chapter is going to be on cloud connectivity, we are not
    going to develop a hardware circuit for each exercise. We will go through the
    hardware design exercise only once and keep using the same hardware for all the
    programming exercises. Similarly, we will also reuse the `web.py` programs that
    we developed in the previous chapter to focus on code snippets that are associated
    with Python libraries to develop cloud applications.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's begin by developing standard hardware for all the upcoming exercises.
    We will need the Arduino board that is attached to the Ethernet Shield to use
    the Ethernet protocol for network connectivity. In terms of components, you will
    be using simple sensors and actuators that you already used in the previous coding
    exercises. We will use the PIR motion sensor and the HIH-4030 humidity sensor
    to provide digital and analog outputs, respectively. We will also have an LED
    as part of the hardware design and this will be used in coding exercises as an
    actuator. For more information regarding the properties and detailed explanations
    of these sensors, you can refer to previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: To begin assembly of the hardware components, first attach the Ethernet Shield
    on top of the Arduino board. Connect the sensors and actuators to the appropriate
    pins, as displayed in the following figure. Once you have the hardware assembled,
    you can connect the Ethernet Shield to your home router using the Ethernet cable.
    You will need to power the board using the USB cable to upload the Arduino code
    from your computer. In case you want to deploy the Arduino board to a remote location,
    you will need an external 5V supply to power Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: '![Hardware design](img/5938OS_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The IoT cloud platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term **IoT cloud platform** is used for the cloud platforms that provide
    very specific services, protocol support, and web-based tools for IoT applications.
    In more informal terms, these cloud IoT platforms can be used to upload your sensor
    data and access them from anywhere using the Internet. With these basic features,
    they also provide tools to access, visualize, and process your sensor data on
    various platforms such as computers and smartphones. Examples of similar IoT cloud
    platforms include Xively ([http://www.xively.com](http://www.xively.com)), 2lemetry
    ([http://www.2lemetry.com](http://www.2lemetry.com)), Carriots ([http://www.carriots.com](http://www.carriots.com)),
    ThingSpeak ([http://thingspeak.com](http://thingspeak.com)), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the architecture of an IoT system with an Arduino-based
    sensor system that is sending data to a cloud platform, while a computation unit
    is accessing the data remotely from the cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The IoT cloud platforms](img/5938OS_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xively, being the oldest and most popular IoT platform, has a large amount of
    community-based online help that is available for beginners. This is one of the
    major reasons why we have chosen Xively as our platform of choice for the upcoming
    exercises. Recently, Xively has changed their policy of creating free developer
    accounts and a user has to request access to this free account instead of obtaining
    one freely. In case you want to use another platform other than Xively, we have
    briefly covered a few similar platforms at the end of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Xively – a cloud platform for the IoT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Xively is one of the very first IoT-specific cloud platforms that was founded
    in 2007 as Pachube. It went through multiple name changes, as it was called Cosm,
    but it is currently known as Xively. Xively provides an IoT cloud platform with
    tools and services to develop connected devices, products, and solutions. As mentioned
    on its website, Xively is the public cloud that is specifically built for the
    IoT.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an account on Xively
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we can go ahead and set up a new user account for the Xively platform.
    To set up an account, you need to execute following steps in the given order:'
  prefs: []
  type: TYPE_NORMAL
- en: To begin the sign up process on [Xively.com](http://Xively.com), open [https://xively.com/signup](https://xively.com/signup)
    in a web browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the sign up page, you will be prompted to select the username and the password,
    as displayed in the following screenshot:![Setting up an account on Xively](img/5938OS_09_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next page, you will be asked to enter some additional information that
    includes your full name, organization's name, country, zip code, time zone, and
    so on. Fill out the form appropriately and click on the **Sign Up** button:![Setting
    up an account on Xively](img/5938OS_09_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Xively will send an activation e-mail to the e-mail account that you specified
    in the form. Open the e-mail and click on the activation link. Check your spam
    folder if you don't see the e-mail in your inbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you click on the activation link, you will be redirected to the welcome
    page on Xively's website. We advise you to go through the tutorials provided on
    the welcome page, as it will help you to get familiar with the Xively platform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After completing the tutorials, you can come back to the main user screen from
    the page using the [https://xively.com/login](https://xively.com/login) link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are not already logged in, you will require your e-mail address as the
    username and an appropriate password to log into the Xively platform.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Working with Xively
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Xively platform lets you create cloud device instances that can be connected
    to the actual hardware device, app, or service. Perform the following steps in
    order to work with Xively:'
  prefs: []
  type: TYPE_NORMAL
- en: To begin working with the Xively platform, add a device from the main page,
    as displayed in the following screenshot:![Working with Xively](img/5938OS_09_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you click on the **Add Device** button, it will prompt you to the following
    window where you will be asked to provide the device name, description, and privacy
    status of the device that you are going to assign. In the form, select a device
    name that you want your development device to be called, provide a brief description,
    and select **Private Device** as the privacy status:![Working with Xively](img/5938OS_09_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you click the **Add Device** button, Xively will create a device instance
    with automatically-generated parameters and prompt you to the development workbench
    environment. On the page of the device that you just added, you can see various
    identification and security parameters such as **Product ID**, **Serial Number**,
    **Feed ID**, **Feed URL**, and **API Endpoint**. From among these parameters,
    you will frequently need the **Feed ID** information for the upcoming exercises:![Working
    with Xively](img/5938OS_09_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A unique and secure API key of the newly created device is also located in the
    right-hand side bar of the page. This API key is very important and needs to be
    secured just like your password, as anyone with the API key can access the device.![Working
    with Xively](img/5938OS_09_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, to remotely access this device, open the terminal and use the cURL command
    to send data to it. In the following command, change the `<Your_Feed_ID>` and
    `<Your_API_key>` values with the ones available for your device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the previous command sent the value of 10 on channel 0 of your
    device on Xively. After executing the previous command, you will notice that the
    Xively workbench is updated with the information that you just sent using cURL:![Working
    with Xively](img/5938OS_09_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try sending multiple values on channel 0 using the previous command. On the
    Xively workbench, you will be able to see a plot being generated by these values
    in real time. Access the plot by clicking on channel 0 in the workbench:![Working
    with Xively](img/5938OS_09_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the method that we used in this example, we can also configure Arduino
    to send sensor values automatically to the Xively platform. This will enable the
    storage and visualization of Arduino data on Xively.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative IoT platforms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we have provided important links for the ThingSpeak and Carriots
    platforms. As we are not covering these platforms in detail, these links will
    help you to find similar examples to interface Arduino and Python with ThingSpeak
    and Carriots.
  prefs: []
  type: TYPE_NORMAL
- en: ThingSpeak
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The tutorials in the following links will help you to get familiar with the
    ThingSpeak platform if you chose to use it instead of Xively:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The official website**: [https://thingspeak.com/](https://thingspeak.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using Arduino and Ethernet to update a ThingSpeak channel**: [http://community.thingspeak.com/tutorials/arduino/using-an-arduino-ethernet-shield-to-update-a-thingspeak-channel/](http://community.thingspeak.com/tutorials/arduino/using-an-arduino-ethernet-shield-to-update-a-thingspeak-channel/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Arduino examples for ThingSpeak**: [https://github.com/iobridge/ThingSpeak-Arduino-Examples](https://github.com/iobridge/ThingSpeak-Arduino-Examples)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Communicating with ThingSpeak using Python**: [http://www.australianrobotics.com.au/news/how-to-talk-to-thingspeak-with-python-a-memory-cpu-monitor](http://www.australianrobotics.com.au/news/how-to-talk-to-thingspeak-with-python-a-memory-cpu-monitor)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using Arduino and Python to talk to a ThingSpeak channel**: [http://vimeo.com/19064691](http://vimeo.com/19064691)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Series of ThingSpeak tutorials**: [http://community.thingspeak.com/tutorials/](http://community.thingspeak.com/tutorials/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ThingSpeak is an open source platform and you can create your own customized
    version of ThingSpeak using the files provided. You can obtain these files and
    the associated guideline from [https://github.com/iobridge/ThingSpeak](https://github.com/iobridge/ThingSpeak).
  prefs: []
  type: TYPE_NORMAL
- en: Carriots
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Carriots also provides a free, basic account for developers. If you want to
    use Carriots as an alternative to Xively, use the tutorials in the following links
    to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The official website**: [https://www.carriots.com/](https://www.carriots.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Setting up an account on Carriots**: [https://learn.adafruit.com/wireless-gardening-arduino-cc3000-wifi-modules/setting-up-your-carriots-account](https://learn.adafruit.com/wireless-gardening-arduino-cc3000-wifi-modules/setting-up-your-carriots-account)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Carriots library for Arduino**: [https://github.com/carriots/arduino_library](http://github.com/carriots/arduino_library)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A Carriots example for Arduino**: [https://github.com/carriots/arduino_examples](https://github.com/carriots/arduino_examples)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connect Carriots to the Python web application**: [http://www.instructables.com/id/Connect-your-Carriots-Device-to-Panics-Status-Boa/](http://www.instructables.com/id/Connect-your-Carriots-Device-to-Panics-Status-Boa/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing cloud applications using Python and Xively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, you have a basic idea about the available commercial IoT platforms and
    you can select one according to your comfort level and requirements. It will be
    very difficult to comprehensively explain every cloud platform with practical
    examples, as the objective of this chapter is to make you familiar with integrating
    the cloud platform with Python and Arduino. For this reason, we are going to use
    Xively as the de facto IoT cloud platform for the rest of the integration exercises.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to create an account on Xively and work with the Xively
    platform, it is time to start interfacing real hardware with the Xively platform.
    In this section, we will go through methods to upload and download data from Xively.
    We will combine the Arduino hardware that we built with the Python programs to
    show you basic methods of communicating with Xively.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing Arduino with Xively
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first stage to establish communication with Xively includes interfacing
    the Arduino board with the Xively platform via standalone Arduino code. We have
    already built the necessary hardware using the Arduino Uno, Ethernet Shield, and
    a few sensors. Let's connect it to your computer using the USB port. You also
    need to connect the Ethernet Shield to your home router using the Ethernet cable.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading Arduino data to Xively
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Arduino IDE has a built-in example that can be used to communicate with
    the Xively service. This is known as **PachubeClient** (Pachube was Xively's previous
    name).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to note that the reason behind using this default example is
    to give you a jump-start in the interfacing exercises. This particular sketch
    is rather old and may get dropped as a default exercise in the upcoming releases
    of the Arduino IDE. In that case, you can directly jump to the next exercise or
    develop your custom sketch to perform the same exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to upload Arduino data to Xively:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Arduino IDE and then open the **PachubeClient** example by navigating
    to **File** | **Examples** | **Ethernet** | **PachubeClient**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To establish communication with Xively, you will need the feed ID and the API
    key of your Xively device, which you obtained in the last section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the opened Arduino sketch, perform the following changes using the obtained
    feed ID and API key. You can specify any project name for the `USERAGENT` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the Arduino sketch, you will also have to change the MAC address and the
    IP address of your Ethernet Shield. You should be familiar with obtaining these
    addresses from the exercise that you performed in the previous chapter. Use these
    values and modify the following lines of code appropriately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As the opened Arduino example was created for the Pachube, you need to update
    the server address to `api.xively.com` as specified in the following code snippet.
    Comment the IP address line as we will not need it anymore and add the `server[]`
    parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `sendData()` function, change the channel name to `HumidityRaw` as we
    have our HIH-4030 humidity sensor connected to the analog port. We are not performing
    any relative humidity calculations at this stage and are going to upload just
    the raw data from the sensor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once you have performed these changes, open the `XivelyClientBasic.ino` file
    from the folder containing codes for this chapter. Compare them with your current
    sketch and compile/upload the sketch to the Arduino board if everything seems
    satisfactory. Once you have uploaded the code, open the **Serial Monitor** window
    in the Arduino IDE to observe the following output:![Uploading Arduino data to
    Xively](img/5938OS_09_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you see an output in the **Serial Monitor** window that is similar to the
    one displayed in the previous screenshot, your Arduino is successfully connected
    to Xively and is uploading data on the HumidityRaw channel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your device in Xively's website and you will be able to see an output that
    is similar to the following screenshot on the web page. This confirms that you
    have successfully uploaded data to an IoT cloud platform using your remotely-located
    Arduino:![Uploading Arduino data to Xively](img/5938OS_09_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Downloading data to Arduino from Xively
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous coding exercise, we used a default Arduino example to communicate
    with Xively. However, Xively also provides a very efficient Arduino library with
    built-in functions for rapid programming. In the next exercise, we will use an
    alternative method to communicate with the Xively platform using the `Xively-Arduino`
    library. Although you can use either of these methods, we recommend that you use
    the `Xively-Arduino` library as it is officially maintained by Xively.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we will download digital values from a channel called LED.
    Later, we will use these digital values, 0 and 1, to switch an LED that is connected
    to our Arduino board. As an input to this channel, we will alter the current value
    of the channel on the Xively platform's website while letting the Arduino download
    that value and perform the appropriate task.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by importing the `Xively-Arduino` library and its dependencies.
    As you already know how to import libraries in the Arduino IDE, visit [https://github.com/amcewen/HttpClient](https://github.com/amcewen/HttpClient)
    to download and import the `HttpClient` library. This is a dependency that is
    required by the `Xively-Arduino` library to function.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have imported the `HttpClient` library, download the `Xively-Arduino`
    library from [https://github.com/xively/xively_arduino](https://github.com/xively/xively_arduino)
    and repeat the import process.
  prefs: []
  type: TYPE_NORMAL
- en: The `Xively-Arduino` library ships with few examples so that you can get started.
    We will use their example as base code for downloading data for our exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Arduino IDE, navigate to **File** | **Examples** | **Xively_arduino**
    | **DatastreamDownload** and open the **DatastreamDownload** example. Change the
    default API key to your own API key that was obtained from the device that you
    created. As displayed in the following code snippet, you need to also identify
    your channel name, which is LED in this case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Xively-Arduino` library requires you to define the `XivelyDatastream`
    variable as an array. You can also specify multiple data streams according to
    your application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You also need to declare a variable called `feed` using the `XivelyFeed` function.
    As displayed in the following line of code, replace the default feed ID with the
    appropriate one. In the initialization of the `feed` variable, the value `1` represents
    the number of `datastreams` in the `XivelyDatastream` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our exercise, we want to periodically retrieve the value of the LED channel
    and turn the actual LED on or off accordingly. In the following code snippet,
    we obtain the float value from `feed[0]`, where `0` specifies the data stream
    located at the `0` position in the `datastreams` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you now know that the parameters need to be changed for this exercise, open
    the `XivelyLibBasicRetrieveData.ino` Arduino sketch from the code folder. This
    sketch contains the exact code that you need to use for the exercise. Although
    this sketch includes the necessary modifications, you will still have to change
    the values for account-specific parameters, that is, the API key, feed ID, and
    so on. Before you go ahead and upload this sketch, go to the Xively platform and
    create a channel called `LED` with **Current Value** as `1`, as displayed in the
    following screenshot:![Downloading data to Arduino from Xively](img/5938OS_09_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, compile and upload the code to your Arduino.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have uploaded the compiled code to your Arduino, open the **Serial
    Monitor** window and wait for an output that is similar to the one displayed in
    following screenshot. You will notice that the LED on the Arduino hardware is
    turned on:![Downloading data to Arduino from Xively](img/5938OS_09_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can go back to the Xively LED channel and change the **Current Value** field
    to `0`. Within a few seconds, you will notice that the LED on the Arduino hardware
    is turned off. With this exercise, you have successfully established two-way communication
    between Arduino and the Xively platform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Advanced code to upload and download data using Arduino
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous two Arduino exercises, we individually performed the uploading
    and downloading tasks. In this exercise, we want to create an Arduino program
    where we can upload data from the connected sensors (the PIR motion sensor and
    the HIH-4030 humidity sensor) while retrieving the value to control the LED. Open
    the Arduino sketch, `XivelyLibAdvance.ino`, which contains the code that demonstrates
    both the functionalities. As you can see in the following code snippet, we have
    defined three separate channels for each component while having independent `XivelyDatastream`
    objects for upload (`datastreaU[]`) and download (`datastreamD[]`). Similarly,
    we have also created two different feeds, `feedU` and `feedD`. The main reason
    behind delegating the upload and download tasks to different objects is to independently
    update the value of the LED channel while uploading the data stream for channels,
    `HumidityRaw` and `MotionRaw`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `loop()` function of the Arduino code, we periodically fetch the current
    value of the LED channel from `feedD` and then perform the LED action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second stage of the periodic function, we obtain the raw sensor values
    from the analog and digital pins of the Arduino board and then upload those values
    using `feedU`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Make the appropriate changes in the code to accommodate feed ID and API key
    and then upload the sketch to the Arduino board. Once you upload this Arduino
    sketch to your platform, you should be able to see the following output on the
    **Serial Monitor** window. You can now disconnect your Arduino from the USB port
    and connect the external power supply. Now that you have connected your Arduino
    assembly to your local network using an Ethernet cable, you can place the Arduino
    assembly at any location in your workplace.
  prefs: []
  type: TYPE_NORMAL
- en: '![Advanced code to upload and download data using Arduino](img/5938OS_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Python – uploading data to Xively
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to how we interfaced Arduino to Xively, we will now explore methods
    to connect the Xively platform via Python and thus complete the loop. In this
    section, we will focus on different ways of uploading data to Xively using Python.
    We will start with a basic method of communicating with Xively and extend it further
    with `web.py` to implement the interface using a web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, let''s first install Xively''s Python library, `xively-python`,
    on your computer using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The basic method for sending data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once again, you will need the API key and feed ID of your virtual device that
    you created on the Xively platform. Python, assisted by the `xively-python` library,
    provides very simple methods to establish a communication channel with the Xively
    platform. From your code folder, open the `uploadBasicXively.py` file. As specified
    in the code, replace the `FEED_ID` and `API_KEY` variables with the appropriate
    feed ID and API key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `XivelyAPIClient` method, create an `api` instance and create the
    `feed` variable by using the `api.feeds.get()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as we did in the Arduino exercises, you will need to create data streams
    for each channel from the feeds. As specified in the following code snippet, try
    to get the specified channel from the feed or create one if it is not present
    on the Xively virtual device. You can also specify tags and other variables while
    creating a new channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have opened the data stream for a channel, you can specify the current
    value using the `datastream.cuurent_value` method and update the value, which
    will upload this value to the specified channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have performed the specified modifications to the `uploadBasicXively.py`
    file, execute it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Open your virtual device on the Xively website to find the `Random` channel
    populated with the data that you uploaded. It will look similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The basic method for sending data](img/5938OS_09_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Uploading data using a web interface based on web.py
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous chapter, we worked with the `web.py` library while developing
    templates and web applications. In this exercise, we will utilize one of the programs
    in which we created the `web.py` forms with the Xively code that we developed
    in the previous exercise. The goal of this exercise is to send data to the LED
    channel using a web application while observing the LED's behavior on the Arduino
    hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the Python program for this exercise in this chapter''s folder
    with the name `uploadWebpyXively.py`. As you can see in the code, we are using
    the `web.py` forms to obtain two inputs, `Channel` and `Value`. We will use these
    inputs to modify the current value of the LED channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The template file, `base.html`, is also modified to accommodate minor changes
    that are required by this exercise. As you can see in the opened Python file,
    we are using the same code that we used to interface with Xively in the previous
    exercise. The only major modification is done to the `datastream.update()` method,
    which is now placed in the `POST()` function. This method will be executed when
    you submit the form. Once you change the API key and feed ID in this file, execute
    the Python code and open `http://localhost:8080` in your web browser. You can
    see the web application running, as displayed in the following screenshot. Enter
    the value as displayed in the figure to turn on the LED on the Arduino board.
    You can change the **Value** parameter to `0` to turn off the LED.
  prefs: []
  type: TYPE_NORMAL
- en: '![Uploading data using a web interface based on web.py](img/5938OS_09_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Python – downloading data from Xively
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The process of downloading data from Xively includes requesting the **Current
    Value** parameter for the specified channel. In the next exercise, we will develop
    a reference code that will be used in the next downloading exercise. In that exercise,
    we will develop an advanced web application to retrieve data from a specific Xively
    channel.
  prefs: []
  type: TYPE_NORMAL
- en: As we are using functions based on the REST protocol to communicate with Xively,
    Xively will not simply notify you about any new, available update, instead you
    will have to request it. At this point, it is important to note that we will have
    to periodically request data from Xively. However, Xively provides an alternative
    method called **triggers** to overcome this problem, which is explained later
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The basic method for retrieving data from Xively
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just like the uploading exercises, the downloading exercises also require a
    similar code to instantiate the `XivelyAPIClient()` and `api.feeds.get()` methods.
    As we are retrieving the data instead of sending it, we will only use the `feed.datastreams.get()`
    method and avoid the `feed.datastreams.create()` method. The download process
    requires the channel to be already present and this is the main reason why we
    only have to use the `get()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `datastream` object is initialized, the latest available value from
    the channel can be obtained using the `datastream.current_value` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable the complete code to perform this exercise, open the `downloadXivelyBasic.py`
    code and change the values for the feed ID and API key to the appropriate ones.
    In this exercise, we are working with the `Random` channel that we created in
    the uploading exercise. Before you execute this Python code, you need to execute
    the `uploadXivelyBasic.py` file that will continuously provide random data to
    the `Random` channel. Now, you can execute the `downloadXivelyBasic.py` file that
    will fetch the current value of the `Random` channel periodically (with a delay
    specified by the `sleep()` function). As you can see in the following screenshot,
    we are getting a new value for the `Random` channel every 10 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The basic method for retrieving data from Xively](img/5938OS_09_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Retrieving data from the web.py web interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is an advanced exercise where we will upload data to one Xively channel
    after fetching data from another Xively channel, and process it by using the data
    entered via the web form. As you know, the analog pin on which the HIH-4030 sensor
    is connected provides you with raw sensor value, whereas the relative humidity
    depends upon the value of the current temperature. In this exercise, we will develop
    a web application so that the user can manually enter the temperature value and
    we will use this to calculate relative humidity from the raw sensor data.
  prefs: []
  type: TYPE_NORMAL
- en: Before we begin with the details of the code, let's first open the `uploadWebpyXively.py`
    file, change the appropriate parameters, and execute the file. Now, in a web browser,
    open the `http://localhost:8080` location. You will be able to see following web
    application, asking you to provide it with the current temperature value. Meanwhile,
    upload the `XivelyLibAdvance.ino` sketch to the Arduino board after making the
    appropriate changes. With this program, Arduino will start sending raw motion
    and humidity values to the `MotionRaw` and `HumidityRaw` channels. In the web
    application that is running, submit the form with the custom temperature value
    and you will be able to see the web application load the current relative humidity
    in percentage units. Internally, when you submitted the form, the web application
    retrieved the current raw humidity value from the `HumidityRaw` channel, executed
    the `relativeHumidity(data, temperature)` function, uploaded the calculated humidity
    value to a new channel called `Humidity`, and then displayed that value in the
    web application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving data from the web.py web interface](img/5938OS_09_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you open your Xively platform page on a web browser, you will be able to
    see a newly created `Humidity` channel with the current value for relative humidity.
    You can submit multiple values for temperature in the web application to see the
    results reflected on the graph of the `Humidity` channel, as displayed in the
    following screenshot. Although this exercise demonstrates a single use case, this
    web application can be extended in multiple ways to create complex applications.
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving data from the web.py web interface](img/5938OS_09_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Triggers – custom notifications from Xively
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Xively platform primarily deploys services based on the REST protocol,
    which doesn''t have a provision to automatically publish data when it is updated
    with a new value. In order to overcome this limitation, Xively implements the
    concept of triggers, which provide additional functionality beyond just publishing
    data when it is changed. Through this, you can basically create a trigger for
    any channel to perform the `POST` operation on the specified location when conditions
    that are set for that trigger get satisfied by the incoming data. For example,
    you can set a trigger on the `Humidity` channel to send you a notification when
    the value of humidity changes, that is, increases above or decrease below a given
    threshold. You can create a trigger in your Xively platform account by just clicking
    on the **Add Trigger** button, as displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Triggers – custom notifications from Xively](img/5938OS_09_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'While creating a trigger, you can specify the channel you want to monitor and
    the condition to trigger a notification on the specified HTTP `POST` URL. As shown
    in the following screenshot, complete the information for **Channel**, **Condition**,
    and **HTTP POST URL** before saving the trigger. The major drawback with this
    approach is that Xively requires an actual URL to send the `POST` notification.
    If your current computer doesn''t have a static IP address or a DNS address, the
    trigger won''t be able to send you the notification:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Triggers – custom notifications from Xively](img/5938OS_09_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Your own cloud platform for the IoT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we worked with a commercial IoT platform that also
    provides restricted, free access to basic functionalities. We also learned various
    ways to communicate with Xively that is based on the REST protocol. For any small
    projects or prototypes, Xively and other similar IoT platforms provide a sufficient
    solution and are therefore recommended by us. However, the limited free service
    provided by Xively may not satisfy all of your requirements to develop a full-stack
    IoT product. The following are a few cases where you may want to configure or
    develop your own IoT platform:'
  prefs: []
  type: TYPE_NORMAL
- en: Develop your own commercial IoT platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop custom features that are exclusive to your product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add more control features and communication protocols while also securing your
    data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Require an inexpensive solution for large-scale projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section will guide you through the step-by-step process of creating an
    elementary small-level IoT cloud platform. The goal of the section is to make
    you familiar with the requirements and the process of creating an IoT platform.
    To develop a large-scale, diverse, and feature-rich platform such as Xively, you
    will need a significant amount of knowledge and experience in the domains of cloud
    and distributed computing. Unfortunately, cloud and distributed computing are
    out of scope of this book and we will stick with the implementation of the basic
    features.
  prefs: []
  type: TYPE_NORMAL
- en: To develop a cloud platform that is accessible through the Internet, you will
    at least require a computational unit with Internet connection and a static IP
    or DNS address. Today, the majority of consumer-oriented **Internet Service Providers**
    (**ISPs**) do not provide static IPs with their Internet service, making it difficult
    to host a server at home. However, various companies such as Amazon, Google, and
    Microsoft, provide free or cost-effective cloud computing services, which make
    it easier to host your cloud on their platforms. These services are highly scalable
    and they are equipped with a large amount of features to satisfy the majority
    of consumer requirements. In the following section, you will be creating your
    first cloud computing instance on **Amazon Web Services** (**AWS**). Later in
    this chapter, we will install and configure the appropriate software tools such
    as Python, Mosquitto broker, and so on, to utilize this Amazon instance as an
    IoT cloud platform.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The major reason behind developing or configuring a personal cloud platform
    is to have access to your IoT hardware through the Internet. Due to the lack of
    a static IP address for your home network, you may not be able to access you prototypes
    or projects from a remote location. A cloud platform can be used as the de facto
    computation unit for your network-based projects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting familiar with the Amazon AWS platform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AWS is a collection of various cloud services offered by Amazon, which together
    make up a cloud computing platform. One of the original and most popular services
    offered by AWS is its **Elastic Computer Cloud** (**EC2**) service. The EC2 service
    lets a user create instances of a virtual machine with different combinations
    of computation power and operating systems from their large cloud infrastructure.
    It is also really easy to change the computational properties of these virtual
    instances at any time, making them highly scalable. When you are trying to create
    your own IoT platform using EC2, this scalability feature greatly helps you as
    you can expand or compress the size of your instances according to demand. If
    you are not familiar with the concept of cloud computing or AWS as a particular
    product, you can learn more about them from [http://aws.amazon.com](http://aws.amazon.com).
  prefs: []
  type: TYPE_NORMAL
- en: The EC2 cloud platform is different from Xively as it provides general-purpose
    cloud instances, virtual machines, with computation power and storage that can
    be converted to any feature-specific platform by installing and configuring platform-specific
    software. It is important to note that you really do not have to be an expert
    in cloud computing to further advance in this chapter. The upcoming sections provide
    an intuitive guide to perform basic tasks, such as setting up an account, creating
    and configuring your virtual machines, and installing software tools to create
    IoT platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an account on AWS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Amazon provides one year of free access to the basic instance of the cloud-based
    virtual machine. This instance includes 750 hours of free usage time per month
    and this is greater than the number of hours in any month, thereby making it free
    for the entire month. The data storage capacity and bandwidth of the AWS account
    are sufficient for basic IoT or Arudino projects. To create a free account for
    a year on Amazon''s AWS cloud platform, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open [http://aws.amazon.com](http://aws.amazon.com) and click on the button
    that asks you to try AWS for free or some other similar text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This action will lead you to a **Sign In or Create an AWS Account** page as
    displayed in the following screenshot. Enter the e-mail address that you want
    to use for this account when you select the **I am a new user.** option and click
    on the **Sign in using our secure server** button. If you already have an AWS
    account and you know how to create an account on Amazon AWS, you can use those
    credentials and skip to the next section:![Setting up an account on AWS](img/5938OS_09_26.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Amazon only allows one free instance for each account. If you are an existing
    AWS user and your free instance is already occupied with another application,
    you can use the same instance to accommodate the MQTT broker or buy another instance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the next page, you will be prompted to enter your name, e-mail address, and
    a password, as displayed in the following screenshot. Fill in the information
    to continue with the sign up process:![Setting up an account on AWS](img/5938OS_09_27.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will be asked to enter your credit card information during the sign up process.
    However, you won't be charged for using the services included in the free account.
    Your credit card will be only used if you exceed any limitations or buy any additional
    services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next stage includes the verification of your account using your phone number.
    Follow the instructions that are displayed in the following screenshot to complete
    the identity verification process:![Setting up an account on AWS](img/5938OS_09_28.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have verified your identity, you will be redirected to the page that
    lists the available Amazon AWS plans. Select the appropriate plan that you want
    to subscribe to and continue. If you are not sure, you can select the **Basic
    (Free)** plan option, which we recommend for our purpose. The **Amazon Management
    Console** page will let you select other plans if you want to upgrade the current
    one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the Amazon management console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you have an Amazon AWS account now, let's create your virtual instance on
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a virtual instance on the AWS EC2 service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to create a virtual instance on Amazon''s EC2 platform, first log
    in to AWS using your credentials and open the management console. Next, click
    on the **EC2** tab and execute the following instructions step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: On the **EC2 Console** page, go to **Create Instance** and click on the **Launch
    Instance** button. This will open a wizard to create an instance that will guide
    you through the setup process:![Creating a virtual instance on the AWS EC2 service](img/5938OS_09_29.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the first page of the wizard, you will be prompted to select an operating
    system for your virtual instance. Select **Ubuntu Server 14.04 LTS** as displayed
    in the next screenshot, which is eligible for the free tier. To avoid any charges
    for using an advanced instance, make sure that the option you select is eligible
    for the free tier:![Creating a virtual instance on the AWS EC2 service](img/5938OS_09_30.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In next window, you will be prompted with a list of options that have different
    configurations of computational capacity. From the **General purpose** family,
    select the **t2.micro** type, which is eligible for the free tier. The computational
    capabilities provided by the **t2.micro** tier are sufficient for the exercises
    that we are going to perform in the book and for most of the DIY projects. Make
    sure that you do not select any other tier unless you are confident of your selection.![Creating
    a virtual instance on the AWS EC2 service](img/5938OS_09_31.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have selected the specified tier, click on the **Review and Launch**
    button to review the final configuration of the instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the configuration and make sure that you have selected the appropriate
    options, as mentioned earlier. You can now click on the **Launch** button to proceed
    further.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will open a pop-up window that will prompt you to create a new key pair
    that will be used for authentication in the upcoming steps:![Creating a virtual
    instance on the AWS EC2 service](img/5938OS_09_32.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As shown in the previous screenshot, select **Create a new key pair** from the
    first drop-down menu while providing a name for the key pair. Click on the **Download
    Key Pair** button to download the key. The downloaded key will have the name that
    you provided in the previous option with the `.pem` extension. If you already
    have an existing key, you can select the appropriate options from the first drop-down
    menu. You will need this key every time you want to log in to this instance. Save
    this key in a safe place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once again, click on the **Launch Instances** button to finally start the instance.
    Your virtual instance is launched on AWS now and it is running in the EC2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, click on the **View Instance** button that will take you back to the EC2
    console window. You will be able to see your recently created `t2.micro` instance
    in the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To find out more details about your virtual instance, select it from the list.
    As soon as you select your instance, you will be able to see additional information
    in the bottom tab. This information includes the public DNS, private DNS, public
    IP address, and so on.![Creating a virtual instance on the AWS EC2 service](img/5938OS_09_33.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save this information, as you will need it to log in to your instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you have successfully created and turned on a virtual cloud instance using
    Amazon AWS. However, this instance is running in the Amazon EC2 and you will have
    to remotely authenticate into this instance to access its resources.
  prefs: []
  type: TYPE_NORMAL
- en: Logging into your virtual instance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In reality, your virtual instance is a virtual computer on a cloud with computation
    resources that are similar to your regular computer. You now need to log in to
    the running virtual instance to access files, run scripts, and install additional
    packages. To establish a secure authentication and access procedure, you need
    to use the **Secure Shell** (**SSH**) protocol and there are multiple ways to
    use SSH from your computer. If you are using Mac OS X or Ubuntu, an SSH client
    program already exists within your operating system. For Windows, you can download
    the PuTTY SSH client from [http://www.putty.org/](http://www.putty.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'From the EC2 management window, retrieve the public IP address of your instance.
    To use the default SSH client in the Linux or Mac environment, open the terminal
    and navigate to the folder where you have saved your key file with the `.pem`
    extension. In the terminal window, execute the following command to make your
    key accessible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have changed permission for your key file, run the following command
    to log in to the virtual instance. In the command, you will have to replace `<key-name>`
    with the file name of your key and `<public-IP>` with the public IP that you retrieved
    from the management console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Once you execute this command, you will be asked to continue with the connection
    process if you are authenticating the instance for the very first time. At the
    prompt, write `yes` and press *Enter* to continue. On successful authentication,
    you will be able to see the command prompt of your virtual instance in the same
    terminal window.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you are using the Windows operating system and are not sure about the
    status of your SSH client, select your instance in the EC2 window and click on
    the **Connect** button in the top navigation bar, which is displayed in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Logging into your virtual instance](img/5938OS_09_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This action will open a pop-up window with a short tutorial that explains the
    connection process. This tutorial is also linked to the step-by-step authentication
    guide for PuTTY.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an IoT platform on the EC2 instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you have successfully set up an Amazon EC2 instance, you have a virtual computer
    that is running in the cloud and has a static IP address to enable remote access.
    However, this instance cannot be categorized as an IoT platform, as it only contains
    a plain operating system (Ubuntu Linux in our case) and lacks the necessary software
    packages and configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two distinct ways of setting up a custom IoT cloud platform on your
    virtual instance:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an open source IoT platform such as ThingSpeak
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separately installing and configuring the required software tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keep the following points in mind when setting up an open source IoT platform:'
  prefs: []
  type: TYPE_NORMAL
- en: ThingSpeak is one of the open source IoT platforms that provides supporting
    files to create and host your own replica of the ThingSpeak platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up this platform on your AWS instance is quite simple and you can obtain
    the necessary files and guidelines to install it via [https://github.com/iobridge/ThingSpeak](https://github.com/iobridge/ThingSpeak).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although this personalized version of the ThingSpeak platform will provide sufficient
    tools to start developing IoT applications, the functionalities of the platform
    will be confined to the supplied feature set. To have complete control over customization,
    you may have to use the next option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to separately install and configure the necessary software tools,
    here''s what you need to remember:'
  prefs: []
  type: TYPE_NORMAL
- en: This option includes furnishing project-specific software tools such as Python
    and the Mosquitto broker with the required Python libraries such as `web.py` and
    `paho_mqtt`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have already worked with exercises that implemented applications which were
    based on the Mosquitto broker and `web.py`. This version of the custom IoT cloud
    platform can reduce the complexity of installing additional open source platform
    tools and still provide the necessary support to host applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Arduino program can directly communicate with this custom platform using
    REST or MQTT protocols. It can also behave as the remote computation unit to communicate
    with Xively or other third-party IoT cloud platforms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will begin the platform deployment process by installing
    the Mosquitto broker and the necessary packages on your virtual instance. This
    will be followed by the configuration of the virtual instance to support the MQTT
    protocol. Once your IoT cloud platform is up and running, you can just run the
    Python-based Mosquitto code from the last chapter from the instance with minor
    or no modifications. In future, this IoT platform that contains the Mosquitto
    broker and the Python project can be extended to accommodate additional features,
    protocols, and extra security.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the necessary packages on AWS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the SSH protocol and the key pair, log into your virtual instance. Once
    you are at the Command Prompt, the first task that you need to perform is to update
    all the outdated packages in Ubuntu, the operating system of your virtual instance.
    Successively execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Ubuntu already comes with the latest version of Python. However, you will still
    need to install Setuptools to install the additional Python packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Ubuntu''s package repository also hosts Mosquitto and it can be directly installed
    using the following command. With this command, we will install the Mosquitto
    broker, Mosquitto client, and all other dependencies together. During the installation,
    you will be asked to confirm the installation of additional packages. Enter `Yes`
    at the terminal and proceed with the installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you have installed the Mosquitto broker on your virtual instance and you
    can run it by executing the Mosquitto command. To develop Python-based Mosquitto
    applications, we need the Python Mosquitto library on our instance. Let''s install
    the library using Setuptools, through the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous chapter, we developed a web application based on `web.py` that
    utilizes the `paho_mqtt` library to support the MQTT protocol. As with the first
    project, we are going to deploy the same web application on the EC2-based virtual
    instance to demonstrate your custom IoT cloud platform. As a dependency of this
    project, you first need the `web.py` Python library, which you can install using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now you have all the necessary software packages to run the IoT application.
    To make your web application accessible via the Internet, you need to configure
    the security of you virtual instance.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the security of the virtual instance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, we will configure the virtual instance to securely host the Mosquitto
    broker. Later, we will go through the methods to set up basic security to prevent
    the abuse of your Mosquitto server by automated bots or spamming attempts.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change any parameters on your virtual instance, you will have to use the
    **Security Groups** tools from the **Network & Security** section of your **AWS
    Management Console** page. Open the **Security Groups** section, as displayed
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the security of the virtual instance](img/5938OS_09_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each virtual instance has a default security group that is generated automatically
    to allow access to your instance through the SSH port 22\. This security configuration
    is responsible for letting you access your virtual instance through the SSH client
    from your computer. The Mosquitto broker uses the TCP port number `1883` to establish
    communication with publishers and subscriber clients. To allow incoming access
    from this Mosquitto port, you will have to edit the current inbound rules and
    add an entry for port `1883`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the security of the virtual instance](img/5938OS_09_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you click on the **Edit** button, the website will open a pop-up window
    to add new rules and edit the existing rules. Click on the **Add Rule** button
    to create an additional rule to accommodate the Mosquitto broker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the security of the virtual instance](img/5938OS_09_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As displayed in the following screenshot, enter the TCP port''s number as `1883`
    and complete the other information in the form. Once you have completed the form
    with the given values, save the rules and exit the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the security of the virtual instance](img/5938OS_09_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, with this configuration, port `1883` is accessible by other devices and
    enables remote communication with the Mosquitto broker. You can use the same method
    to add a rule for port `8080` to allow access to Python's web applications that
    were developed using `web.py`. In future, you can add any additional ports to
    allow access to various services. Although it is very easy to change the security
    rules on your virtual instance, make sure that you refrain from opening excessive
    ports to avoid any security risk.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your cloud platform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this testing section, we will first perform checks for the Mosquitto broker
    from your computer and then set up authentication parameters for the Mosquitto
    broker. Later, we will upload files and folders containing the Python code to
    our virtual instance using the SSH file transfer protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Mosquitto service
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first thing that we are going to check on our IoT platform is the accessibility
    of the Mosquitto broker. Open the terminal on your computer and execute the following
    command, after replacing `<Public-IP>` with the public IP or public DNS address
    of your virtual instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will publish the message value `3` for the `test` topic for the
    Mosquitto broker that is specified at the given IP address; in our case, this
    is the virtual instance. Now, open a separate terminal window and execute the
    following command to subscribe to the `test` topic on our broker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: On the execution of this command, you will be able to see the latest value that
    is published for this topic. Use the `mosquitto_pub` command to post multiple
    messages and you can see the output of these messages in the other terminal window
    that is running the `mosquitto_sub` command.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring and testing basic security
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As you saw in the previous example, the publishing and subscribing commands
    just used the IP address to send and receive data without using any authentication
    parameters. This is a major security loophole, as anyone on the Internet can send
    data to your Mosquitto broker. To avoid unauthorized access to your broker, you
    have to establish authentication credentials. You can specify these parameters
    by following these steps in the given order:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have not already logged into your instance through SSH, open a terminal
    window and log in using SSH. Once you are logged in, navigate to the Mosquitto
    directory and create a new file called `passwd` using the following set of commands.
    We will use this file to store the usernames and passwords:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the file, enter the username and password information separated by using
    the colon operator (`:`). For testing purposes, we will use the following credentials,
    which can be changed any time once you are more familiar with the Mosquitto configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Press *Ctrl* + *X* to save and exit the file from the nano editor. When you
    are prompted to confirm the save operation, select **Y** and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the same folder, open the Mosquitto configuration file using thenano editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the opened file, scroll down the text content until you reach the security
    section. In this section, find the `#allow_anonymous true` line of the code and
    replace it with `allow_anonymous false`. Make sure that you have removed the `#`
    symbol. With this operation, we have disabled the anonymous access to the Mosquitto
    broker and only those clients with proper credentials can access it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After performing the previous changes, scroll further down in the file, uncomment
    the line `#password_file`, and replace it with this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that you have configured the basic security parameters for your broker,
    you must restart the Mosquitto service for the changes to take effect. In Ubuntu,
    Mosquitto is installed as part of the background service and you can restart it
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To test these authentication configurations, open another terminal window in
    your computer and execute the following command with the public IP address of
    your instance. If you are able to successfully publish your message without any
    errors, your Mosquitto broker now has a security configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, check your Mosquitto subscriber using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Uploading and testing a project on the instance
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we discussed in the previous chapters, you can always use your computer for
    development purposes. Once you are ready for deployment, you can utilize this
    newly configured virtual instance as the deployment unit. You can copy your files
    from your local computer to the virtual instance using a utility called PuTTY
    ([https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/putty.html](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/putty.html))
    or using the SCP (SSH copy) command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it is time to upload the project files from the final coding exercise of
    the previous chapter, which implemented the MQTT protocol using Python and the
    Mosquitto library. As a reminder, the final exercise is located in the folder
    named `Exercise 4 - MQTT gateway` of the previous chapter''s code repository.
    We will be using the SCP utility to upload these files to your virtual instance.
    Before we use this utility, let''s first create a directory on your virtual instance.
    Log in to your virtual instance and go to the user directory of the virtual instance
    by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the character tilde (`~`) with the `cd` command will change the current
    directory to the home directory, unless you are planning to use any other location
    on your virtual instance. At this location, create a new empty directory named
    `project` by using following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, on the computer you are working on (Mac OS X or Linux), open another terminal
    window and use the following command to copy the entire directory to the remote
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have successfully copied the files to this location, you can go back
    to the terminal that is logged in to your virtual instance and change the directory
    to `project`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Before running any commands, make sure that you have changed the appropriate
    IP addresses in the Arduino sketch and the Python programs. You will have to replace
    the previous IP address with the one of your virtual instance. Now that you have
    made these changes, you can execute the Python code containing the Mosquitto Gateway
    and web application to start the program. Open your web browser from the `http://<Public-Ip>:8080`
    location to see you web application running on the custom IoT platform. From now
    on, you should be able to access this application from any remote location through
    the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not forget to change the IP address of the Mosquitto broker in the Arduino
    sketch and upload the sketch to the Arduino board again. You may not be able to
    obtain the sensor data if the appropriate IP address changes are not applied.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the end of this chapter, and hence the end of the contextual part of the
    book, you should be able to develop your own Internet of Things projects. In this
    chapter, we used a commercial IoT cloud platform to handle your sensor data. We
    also deployed a cloud instance to host open source IoT tools and created our own
    version of the customized IoT cloud platform. Certainly, the content that you
    learned is not sufficient to develop scalable and fully-stacked commercial products,
    but it is really helpful to get you started with them. In a large number of cases,
    this material is sufficient to develop DIY projects and product prototypes that
    will ultimately lead you to the final product. In the next two chapters, we will
    put the material that we learned to the test and develop two complete IoT hardware
    projects. We are also going to learn a project development methodology that is
    specific to hardware-based IoT products, which can be applied to convert your
    prototypes into real products.
  prefs: []
  type: TYPE_NORMAL
