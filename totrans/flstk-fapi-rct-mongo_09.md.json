["```py\n    python -m venv venv\n    ```", "```py\n    source venv/bin/activate\n    ```", "```py\n    venv\\Scripts\\activate.bat\n    ```", "```py\n    fastapi==0.111.0\n    fastapi_cors==0.0.6\n    beanie==1.26.00\n    bcrypt==4.0.1\n    cloudinary==1.40.0\n    uvicorn==0.30.1\n    pydantic-settings\n    PyJWT==2.8.0\n    python-multipart==0.0.9\n    openai==1.33.0\n    resend==2.0.0\n    ```", "```py\n    pip install –r requirements.txt\n    ```", "```py\n    .env\n    .venv\n    env/\n    venv/\n    ```", "```py\n    from datetime import datetime\n    from typing import List, Optional\n    from beanie import Document, Link, PydanticObjectId\n    from pydantic import BaseModel, Field\n    ```", "```py\n    class User(Document):\n        username: str = Field(min_length=3, max_length=50)\n        password: str\n        email: str\n        created: datetime = Field(default_factory=datetime.now)\n        class Settings:\n            name = \"user\"\n        class Config:\n            json_schema_extra = {\n                \"example\": {\n                    \"username\": \"John\",\n                    \"password\": \"password\",\n                    \"email\": \"john@mail.com\",\n                }\n            }\n    ```", "```py\n    class RegisterUser(BaseModel):\n        username: str\n        password: str\n        email: str\n    class LoginUser(BaseModel):\n        username: str\n        password: str\n    class CurrentUser(BaseModel):\n        username: str\n        email: str\n        id: PydanticObjectId\n    ```", "```py\n    class Car(Document):\n        brand: str\n        make: str\n        year: int\n        cm3: int\n        price: float\n        description: Optional[str] = None\n        picture_url: Optional[str] = None\n        pros: List[str] = []\n        cons: List[str] = []\n        date: datetime = datetime.now()\n        user: Link[User] = None\n        class Settings:\n            name = \"car\"\n    ```", "```py\n    class UpdateCar(BaseModel):\n        price: Optional[float] = None\n        description: Optional[str] = None\n        pros: Optional[List[str]] = None\n        cons: Optional[List[str]] = None\n    ```", "```py\n    DB_URL=mongodb://localhost:27017/ or the Atlas address\n    CLOUDINARY_SECRET_KEY=<cloudinary.secret.key>\n    CLOUDINARY_API_KEY=<cloudinary.api.key>\n    CLOUDINARY_CLOUD_NAME=<cloudinary.cloud.name>\n    OPENAI_API_KEY=<openai.api.key>\n    RESEND_API_KEY=<resend.api.key>\n    ```", "```py\n    from typing import Optional\n    from pydantic_settings import BaseSettings, SettingsConfigDict\n    class BaseConfig(BaseSettings):\n        DB_URL: Optional[str]\n        CLOUDINARY_SECRET_KEY: Optional[str]\n        CLOUDINARY_API_KEY: Optional[str]\n        CLOUDINARY_CLOUD_NAME: Optional[str]\n        OPENAI_API_KEY: Optional[str]\n        RESEND_API_KEY: Optional[str]\n        model_config = SettingsConfigDict(\n            env_file=\".env\", extra=\"ignore\"\n        )\n    ```", "```py\n    import motor.motor_asyncio\n    from beanie import init_beanie\n    from config import BaseConfig\n    from models import Car, User\n    settings = BaseConfig()\n    async def init_db():\n        client = motor.motor_asyncio.AsyncIOMotorClient(\n            settings.DB_URL\n        )\n        await init_beanie(database=client.carAds,\n            document_models=[User, Car]\n        )\n    ```", "```py\n    from contextlib import asynccontextmanager\n    from fastapi import FastAPI\n    from fastapi_cors import CORS\n    from database import init_db\n    @asynccontextmanager\n    async def lifespan(app: FastAPI):\n        await init_db()\n        yield\n    app = FastAPI(lifespan=lifespan)\n    init_db function, you imported the fastapi_cors package, which allows easier management of CORS.All you need to do now is add one line to the `.env` file to specify the allowed origins: `ALLOW_ORIGINS=*`.You can explore the documentation of this simple package here: [https://pypi.org/project/fastapi-cors/](https://pypi.org/project/fastapi-cors/).\n    ```", "```py\n    @app.get(\"/\", tags=[\"Root\"])\n    async def read_root() -> dict:\n        return {\"message\": \"Welcome to your beanie powered app!\"}\n    ```", "```py\n    fastapi dev\n    ```", "```py\n    uvicorn app:app --reload\n    ```", "```py\nimport datetime\nimport jwt\nfrom fastapi import HTTPException, Security\nfrom fastapi.security import HTTPAuthorizationCredentials, HTTPBearer\nfrom passlib.context import CryptContext\nclass AuthHandler:\n    security = HTTPBearer()\n    pwd_context = CryptContext(\n        schemes=[\"bcrypt\"], deprecated=\"auto\"\n        )\n    secret = \"FARMSTACKsecretString\"\n    def get_password_hash(self, password):\n        return self.pwd_context.hash(password)\n    def verify_password(\n        self, plain_password, hashed_password\n    ):\n        return self.pwd_context.verify(\n            plain_password, hashed_password\n        )\n    def encode_token(self, user_id, username):\n        payload = {\n            \"exp\": datetime.datetime.now(datetime.timezone.utc)\n            + datetime.timedelta(minutes=30),\n            \"iat\": datetime.datetime.now(datetime.timezone.utc),\n            \"sub\": {\"user_id\": user_id, \"username\": username},\n        }\n        return jwt.encode(payload, self.secret, algorithm=\"HS256\")\n    def decode_token(self, token):\n        try:\n            payload = jwt.decode(token, self.secret, algorithms=[\"HS256\"])\n            return payload[\"sub\"]\n        except jwt.ExpiredSignatureError:\n            raise HTTPException(\n              status_code=401,\n              detail=\"Signature has expired\"\n            )\n        except jwt.InvalidTokenError:\n            raise HTTPException(status_code=401, detail=\"Invalid token\")\n    def auth_wrapper(self, auth: HTTPAuthorizationCredentials = Security(security)):\n        return self.decode_token(auth.credentials)\n```", "```py\n    from fastapi import APIRouter, Body, Depends, HTTPException\n    from fastapi.responses import JSONResponse\n    from authentication import AuthHandler\n    from models import CurrentUser, LoginUser, RegisterUser, User\n    auth_handler = AuthHandler()\n    router = APIRouter()\n    @router.post(\n        \"/register\",\n        response_description=\"Register user\",\n        response_model=CurrentUser\n    )\n    async def register(\n        newUser: RegisterUser = Body(...),\n        response_model=User):\n        newUser.password = auth_handler.get_password_hash(\n            newUser.password)\n        query = {\n    \"$or\": [{\"username\": newUser.username},\n        \t{\"email\": newUser.email}]}\n        existing_user = await User.find_one(query)\n        if existing_user is not None:\n            raise HTTPException(\n                status_code=409,\n                detail=f\"{newUser.username} or {newUser.email}\n                already exists\"\n            )\n        user = await User(**newUser.model_dump()).save()\n        return user\n    ```", "```py\n    @router.post(\"/login\", response_description=\"Login user and return token\")\n    async def login(loginUser: LoginUser = Body(...)) -> str:\n        user = await User.find_one(\n            User.username == loginUser.username\n        )\n        if user and auth_handler.verify_password(\n            loginUser.password, user.password):\n            token = auth_handler.encode_token(\n              str(user.id),\n              user.username\n              )\n            response = JSONResponse(\n                content={\n                    \"token\": token,\n                    \"username\": user.username})\n            return response\n        else:\n            raise HTTPException(\n                status_code=401,\n                detail=\"Invalid username or password\")\n    ```", "```py\n    @router.get(\n        \"/me\", response_description=\"Logged in user data\", response_model=CurrentUser\n    )\n    async def me(\n        user_data=Depends(auth_handler.auth_wrapper)\n    ):\n        currentUser = await User.get(user_data[\"user_id\"])\n        return currentUser\n    ```", "```py\n    from typing import List\n    import cloudinary\n    from beanie import PydanticObjectId, WriteRules\n    from cloudinary import uploader  # noqa: F401\n    from fastapi import (APIRouter, Depends, File, Form,\n        HTTPException, UploadFile, status)\n    from authentication import AuthHandler\n    from config import BaseConfig\n    from models import Car, UpdateCar, User\n    ```", "```py\n    auth_handler = AuthHandler()\n    settings = BaseConfig()\n    cloudinary.config(\n        cloud_name=settings.CLOUDINARY_CLOUD_NAME,\n        api_key=settings.CLOUDINARY_API_KEY,\n        api_secret=settings.CLOUDINARY_SECRET_KEY,\n    )\n    router = APIRouter()\n    ```", "```py\n    @router.get(\"/\", response_model=List[Car])\n    async def get_cars():\n        return await find_all() Beanie method is asynchronous, like all Beanie methods, and it simply returns all the documents in the database. Other querying methods are .find(search query) and .first_or_none(), which are often used to check for the existence of a certain condition (such as a user with a given username or email). Finally, the to_list() method, like with Motor, returns a list of documents, but you could also use the async for construct (shown in *Chapter 4*, *Getting Started with FastAPI*) and generate a list that way.\n    ```", "```py\n    @router.get(\"/{car_id}\", response_model=Car)\n    async def get_car(car_id: PydanticObjectId):\n        car = await Car.get(car_id)\n        if not car:\n            raise HTTPException(status_code=404, detail=\"Car not found\")\n        return car\n    ```", "```py\n    @router.post(\n        \"/\",\n        response_description=\"Add new car with picture\",\n        response_model=Car,\n        status_code=status.HTTP_201_CREATED,\n    )\n    async def add_car_with_picture(\n        brand: str = Form(\"brand\"),\n        make: str = Form(\"make\"),\n        year: int = Form(\"year\"),\n        cm3: int = Form(\"cm3\"),\n        km: int = Form(\"km\"),\n        price: int = Form(\"price\"),\n        picture: UploadFile = File(\"picture\"),\n        user_data=Depends(auth_handler.auth_wrapper),\n    ):\n        cloudinary_image = cloudinary.uploader.upload(\n          picture.file,\n          folder=\"FARM2\",\n          crop=\"fill\",\n          width=800,\n          gravity=\"auto\" )\n        picture_url = cloudinary_image[\"url\"]\n        user = await User.get(user_data[\"user_id\"])\n        car = Car(\n            brand=brand,\n            make=make,\n            year=year,\n            cm3=cm3,\n            km=km,\n            price=price,\n            picture_url=picture_url,\n            user=user,\n        )\n        return await car.insert(link_rule=WriteRules.WRITE)\n    ```", "```py\n    @router.put(\"/{car_id}\", response_model=Car)\n    async def update_car(\n        car_id: PydanticObjectId,\n        cardata: UpdateCar):\n        car = await Car.get(car_id)\n        if not car:\n            raise HTTPException(\n                status_code=404,\n                detail=\"Car not found\")\n        updated_car = {\n            k: v for k, v in cardata.model_dump().items()   if v is not None}\n        return await car.set(updated_car)\n    ```", "```py\n    @router.delete(\"/{car_id}\")\n    async def delete_car(car_id: PydanticObjectId):\n        car = await Car.get(car_id)\n        if not car:\n            raise HTTPException(status_code=404, detail=\"Car not found\")\n        await car.delete()\n    ```", "```py\nfrom contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nfrom database import init_db\nfrom routers import cars as cars_router\nfrom routers import user as user_router\nfrom fastapi_cors import CORS\n```", "```py\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    await init_db()\n    yield\napp = FastAPI(lifespan=lifespan)\nCORS(app)\napp.include_router(\n    cars_router.router,\n    prefix=\"/cars\",\n    tags=[\"Cars\"]\n)\napp.include_router(\n    user_router.router,\n    prefix=\"/users\",\n    tags=[\"Users\"]\n)\n@app.get(\"/\", tags=[\"Root\"])\nasync def read_root() -> dict:\n    return {\"message\": \"Welcome to your beanie powered app!\"}\n```", "```py\n    from time import sleep\n    def delayed_task(username: str) -> None:\n        sleep(5)\n        print(\n            f\"User just logged in: {username}\"\n        )\n    ```", "```py\n    from fastapi import APIRouter, BackgroundTasks, Body, Depends, HTTPException\n    from background import delayed_task\n    # code continues …\n    @router.post(\"/login\", response_description=\"Login user and return token\")\n    async def login(\n        background_tasks: BackgroundTasks,\n        loginUser: LoginUser = Body(...)\n    ) -> str:\n        user = await User.find_one(\n            User.username == loginUser.username\n        )\n        if user and auth_handler.verify_password(\n            loginUser.password, user.password\n        ):\n            token = auth_handler.encode_token(\n                str(user.id), user.username\n            )\n            background_tasks.add_task(\n                delayed_task,\n                username=user.username\n            )\n            response = JSONResponse(\n                content={\n                    \"token\": token,\n                    \"username\": user.username\n                    }\n                )\n            return response\n        else:\n            raise HTTPException(\n                    status_code=401,\n                    detail=\"Invalid username or password\"\n        )\n    fastapi dev\n    ```", "```py\n    http POST 127.0.0.1:8000/users/login username=tanja password=tanja123\n    ```", "```py\n    User just logged in: tanja\n    ```", "```py\n    import json\n    from openai import OpenAI\n    from config import BaseConfig\n    from models import Car\n    settings = BaseConfig()\n    json for decoding the OpenAI response, the openai module, as well as the config module for reading the API keys. After instantiating the settings and the OpenAI client, you will create a helper function that will generate the prompt for OpenAI.Although these tasks are handled much more elegantly with a library called LangChain—the de facto standard when working with LLMs in Python—for simplicity’s sake, you will use a simple Python `f-string` to regenerate the prompt on each request.Remember, the prompt needs to provide a text description and two arrays—one for the positive aspects and one for the negative aspects of the car.\n    ```", "```py\n    def generate_prompt(brand: str, model: str, year: int) -> str:\n        return f\"\"\"\n        You are a helpful car sales assistant. Describe the {brand} {model} from {year} in a playful manner.\n        Also, provide five pros and five cons of the model, but formulate the cons in a not overly negative way.\n        You will respond with a JSON format consisting of the following:\n        a brief description of the {brand} {model}, playful and positive, but not over the top.\n        This will be called *description*. Make it at least 350 characters.\n        an array of 5 brief *pros* of the car model, short and concise, maximum 12 words, slightly positive and playful\n        an array of 5 brief *cons* drawbacks of the car model, short and concise, maximum 12 words, not too negative, but in a slightly negative tone\n        make the *pros* sound very positive and the *cons* sound negative, but not too much\n        \"\"\"\n    ```", "```py\n    async def create_description(\n        brand,\n        make,\n        year,\n        picture_url):\n        prompt = generate_prompt(brand, make, year)\n        try:\n            response = client.chat.completions.create(\n                model=\"gpt-4\",\n                messages=[{\"role\": \"user\", \"content\": prompt}],\n                max_tokens=500,\n                temperature=0.2,\n            )\n            content = response.choices[0].message.content\n            car_info = json.loads(content)\n            await Car.find(\n                Car.brand == brand,\n                Car.make == make,\n                Car.year == year\n            ).set(\n                {\n                    \"description\": car_info[\"description\"],\n                    \"pros\": car_info[\"pros\"],\n                    \"cons\": car_info[\"cons\"],\n                }\n            )\n        except Exception as e:\n            print(e)\n    ```", "```py\n    from background import create_description\n    ```", "```py\n    @router.post(\n        \"/\",\n        response_description=\"Add new car with picture\",\n        response_model=Car,\n        status_code=status.HTTP_201_CREATED,\n    )\n    async def add_car_with_picture(\n        background_tasks: BackgroundTasks,\n        brand: str = Form(\"brand\"),\n        make: str = Form(\"make\"),\n        year: int = Form(\"year\"),\n        cm3: int = Form(\"cm3\"),\n        km: int = Form(\"km\"),\n        price: int = Form(\"price\"),\n        picture: UploadFile = File(\"picture\"),\n        user_data=Depends(auth_handler.auth_wrapper),\n    ):\n        cloudinary_image = cloudinary.uploader.upload(\n          picture.file,\n          folder=\"FARM2\",\n          crop=\"fill\",\n          width=800,\n          height=600,\n          gravity=\"auto\"\n        )\n        picture_url = cloudinary_image[\"url\"]\n        user = await User.get(user_data[\"user_id\"])\n        car = Car(\n            brand=brand,\n            make=make,\n            year=year,\n            cm3=cm3,\n            km=km,\n            price=price,\n            picture_url=picture_url,\n            user=user,\n        )\n        background_tasks.add_task(\n            create_description, brand=brand, make=make,\n            year=year, picture_url=picture_url\n        )\n        return await car.insert(link_rule=WriteRules.WRITE)\n    ```", "```py\n    pip install resend==2.0.0\n    ```", "```py\n    import json\n    import resend\n    from openai import OpenAI\n    from config import BaseConfig\n    from models import Car\n    settings = BaseConfig()\n    client = OpenAI(api_key=settings.OPENAI_API_KEY)\n    resend.api_key = settings.RESEND_API_KEY\n    # code continues …\n    ```", "```py\n    async def create_description(brand, make, year, picture_url):\n        prompt = generate_prompt(brand, make, year)\n        try:\n            response = client.chat.completions.create(\n                model=\"gpt-4\",\n                messages=[\n                    {\"role\": \"user\", \"content\": prompt}],\n                max_tokens=500,\n                temperature=0.2,\n            )\n            content = response.choices[0].message.content\n            car_info = json.loads(content)\n            await Car.find(\n                Car.brand == brand,\n                Car.make == make,\n                 Car.year == year).set(\n                {\n                    \"description\": car_info[\"description\"],\n                    \"pros\": car_info[\"pros\"],\n                    \"cons\": car_info[\"cons\"],\n                }\n            )\n            def generate_email():\n                pros_list = \"<br>\".join([f\"- {pro}\" for pro in car_info[\"pros\"]])\n                cons_list = \"<br>\".join([f\"- {con}\" for con in car_info[\"cons\"]])\n                return f\"\"\"\n                Hello,\n                We have a new car for you: {brand} {make} from {year}.\n                <p><img src=\"img/{picture_url}\"/></p>\n                {car_info['description']}\n                <h3>Pros</h3>\n                {pros_list}\n                <h3>Cons</h3>\n                {cons_list}\n                \"\"\"\n            params: resend.Emails.SendParams = {\n                \"from\":\"FARM Cars <onboarding@resend.dev>\",\n                \"to\": [\"youremail@gmail.com\"],\n                \"subject\": \"New Car On Sale!\",\n                \"html\": generate_email(),\n            }\n            resend.Emails.send(params)\n        except Exception as e:\n            print(e)\n    ```"]