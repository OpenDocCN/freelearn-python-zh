- en: Chapter 2. Dealing with Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we started with a simple command-line script and gradually
    transformed it into an object-oriented code. Several new features were added in
    the process. So far, we have paid little attention to the application quality.
    We neglected to look for any obvious errors encountered during the program execution.
    Such errors detected during the application runtime are referred to as **exceptions**.
    In this chapter, you will learn techniques to make the application more robust
    by handling exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the exceptions in Python?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the program flow with the `try…except` clause
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with common problems by handling exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using custom exception classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by reviewing the feedback you received from the users.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting Attack of the Orcs v1.0.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The heal feature added in v1.0.0 became a hit among the core users. The OOP
    approach put you in a better position to implement new features (or so you thought!).
    As the feature requests started pouring in, so did the reported bugs.
  prefs: []
  type: TYPE_NORMAL
- en: '| *The game is OK, but there are several annoyances. For example, when prompted
    to choose a hut, sometimes I input a number greater than 5 or input a character
    by mistake. After this, it just prints some weird error message and the application
    terminates. Can you fix this?* |'
  prefs: []
  type: TYPE_TB
- en: '![Revisiting Attack of the Orcs v1.0.0](img/B05034_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Debugging the problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s try to reproduce the reported problem. Run the example from [Chapter
    1](ch01.html "Chapter 1. Developing Simple Applications"), *Developing Simple
    Applications*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When prompted for the hut number, enter any character, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging the problem](img/B05034_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The application is terminated with an error **traceback** in the console. A
    traceback is a snapshot of the call stack at the point where the exception (the
    error) occurred. In this particular example, the `_process_user_choice` method
    is called by the `play` method, which is called directly from the module. The
    line numbers show where these calls occur. It is useful for debugging. The reported
    error in this case is `ValueError`. It occurred because we assumed the user choice
    as an integer. The other problem reported is when the hut number does not fall
    in the range 1 to 5\. The traceback error received is `IndexError`. It occurs
    while accessing the entry in the `huts` list corresponding to the user input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging the problem](img/B05034_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you look at the two tracebacks closely, both these errors occur in the `_process_user_choice`
    method of the `AttackOfTheOrcs` class. Let''s review the original method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging the problem](img/B05034_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Good! We have pinpointed where the problem is. Now, the next task is to fix
    these bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the bugs…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| *Sir Foo has some thoughts on fixing bugs…* |'
  prefs: []
  type: TYPE_TB
- en: '![Fixing the bugs…](img/B05034_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| *Sure. One way to fix the reported problems is to add conditional blocks
    which ensure that the user input is a number between 1 and 5.* |'
  prefs: []
  type: TYPE_TB
- en: But like many other languages, Python provides an elegant way to handle such
    situations using the `try…except` clause. It is based on the **Easier to Ask for
    Forgiveness than Permission** (**EAFP**) principle.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The EAFP principle**'
  prefs: []
  type: TYPE_NORMAL
- en: When coding, you assume some things exist and try writing the code accordingly.
    But if this turns out to be a wrong assumption, you ask for forgiveness by catching
    that exception. This is a very common approach used in Python development. You
    can check out the Python 3 documentation ([https://docs.python.org/3/glossary.html](https://docs.python.org/3/glossary.html))
    that defines this idiom. In some cases, exception handling can affect the performance
    when compared to the use of the `if` condition blocks; however, you will most
    likely find more good things than bad ones when using the `try…except` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before jumping straight into the code and fixing these issues, let's first understand
    what an exception is and what we mean by handling an exception.
  prefs: []
  type: TYPE_NORMAL
- en: What is an exception?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An **exception** is an object in Python. It gives us information about an error
    detected during the program execution. The errors noticed while debugging the
    application were **unhandled exceptions** as we didn't see those coming. Later
    in the chapter, you will learn the techniques to handle these exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: The `ValueError` and `IndexError` exceptions seen in the earlier tracebacks
    are examples of built-in exception types in Python. In the following section,
    you will learn about some other built-in exceptions supported in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Most common exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s quickly review some of the most frequently encountered exceptions. The
    easiest way is to try running some buggy code and let it report the problem as
    an error traceback! Start your Python interpreter and write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Most common exceptions](img/B05034_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are a few more exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Most common exceptions](img/B05034_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, each line of the code throws an error traceback with an exception
    type (shown highlighted). These are a few of the built-in exceptions in Python.
    A comprehensive list of built-in exceptions can be found at [https://docs.python.org/3/library/exceptions.html#bltin-exceptions](https://docs.python.org/3/library/exceptions.html#bltin-exceptions).
  prefs: []
  type: TYPE_NORMAL
- en: Python provides `BaseException` as the base class for all built-in exceptions.
    However, most of the built-in exceptions do not directly inherit `BaseException`.
    Instead, they are derived from a class called `Exception` that in turn inherits
    from `BaseException`. The built-in exceptions that deal with program exit (for
    example, `SystemExit`) are derived directly from `BaseException`. You can also
    create your own exception class as a subclass of `Exception`. You will learn about
    that later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we saw have seen the exceptions occur. Now it is time to learn how
    to use the `try…except` clause to handle these exceptions. The following pseudocode
    shows a very simple example of the `try…except` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exception handling](img/B05034_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s review the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the program tries to execute the code inside the `try` clause.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During this execution, if something goes wrong (if an exception occurs), it
    jumps out of this `try` clause. The remaining code in the `try` block is not executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then looks for an appropriate exception handler in the `except` clause and
    executes it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `except` clause used here is a universal one. It will catch all types of
    exceptions occurring within the `try` clause. Instead of having this "catch-all"
    handler, a better practice is to catch the errors that you anticipate and write
    an exception handling code specific to those errors. For example, the code in
    the `try` clause might throw an `AssertionError`. Instead of using the universal
    `except` clause, you can write a specific exception handler, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exception handling](img/B05034_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we have an `except` clause that exclusively deals with `AssertionError`.
    What it also means is that any error other than the `AssertionError` will slip
    through as an unhandled exception. For that, we need to define multiple `except`
    clauses with different exception handlers. However, at any point in time, only
    one exception handler will be called. This can be better explained with an example.
    Let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exception handling](img/B05034_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `try` block calls `solve_something()`. This function accepts a number as
    a user input and makes an assertion that the number is greater than zero. If the
    assertion fails, it jumps directly to the handler, `except AssertionError`.
  prefs: []
  type: TYPE_NORMAL
- en: In the other scenario, with `a > 0`, the rest of the code in `solve_something()`
    is executed. You will notice that the variable `x` is not defined, which results
    in `NameError`. This exception is handled by the other exception clause, `except
    NameError`. Likewise, you can define specific exception handlers for anticipated
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: Raising and re-raising an exception
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `raise` keyword in Python is used to force an exception to occur. Put another
    way, it raises an exception. The syntax is simple; just open the Python interpreter
    and type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following error traceback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In some situations, we need to re-raise an exception. To understand this concept
    better, here is a trivial scenario. Suppose, in the `try` clause, you have an
    expression that divides a number by zero. In ordinary arithmetic, this expression
    has no meaning. It's a bug! This causes the program to raise an exception called
    `ZeroDivisionError`. If there is no exception handling code, the program will
    just print the error message and terminate.
  prefs: []
  type: TYPE_NORMAL
- en: What if you wish to write this error to some log file and then terminate the
    program? Here, you can use an `except` clause to log the error first. Then, use
    the `raise` keyword without any arguments to re-raise the exception. The exception
    will be propagated upwards in the stack. In this example, it terminates the program.
    The exception can be re-raised with the `raise` keyword without any arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that shows how to re-raise an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Raising and re-raising an exception](img/B05034_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As can be seen, a division by zero exception is raised while solving the `a/b`
    expression. This is because the value of variable `b` is set to `0`. For illustration
    purposes, we assumed that there is no specific exception handler for this error.
    So, we will use the general `except` clause where the exception is re-raised after
    logging the error. If you want to try this yourself, just write the code illustrated
    earlier in a new Python file, and run it from a terminal window. The following
    screenshot shows the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Raising and re-raising an exception](img/B05034_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The else block of try…except
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is an optional `else` block that can be specified in the `try…except`
    clause. The `else` block is executed only if no exception occurs in the `try…except`
    clause. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The else block of try…except](img/B05034_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `else` block is executed before the `finally` clause, which we will study
    next.
  prefs: []
  type: TYPE_NORMAL
- en: finally...clean it up!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is something else to add to the `try…except…else` story: an optional
    `finally` clause. As the name suggests, the code within this clause is executed
    at the end of the associated `try…except` block. Whether or not an exception is
    raised, the `finally` clause, if specified, will certainly get executed at the
    end of the `try…except` clause. Imagine it as an all-weather guarantee given by
    Python! The following code snippet shows the `finally` block in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![finally...clean it up!](img/B05034_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Running this simple code will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The last line in the output is the `print` statement from the `finally` clause.
  prefs: []
  type: TYPE_NORMAL
- en: '![finally...clean it up!](img/B05034_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| *That''s a good question! Let''s add a twist to the tale. What if the new
    code in the except clause forces a return from the function? In such a scenario,
    will your solution execute the last line of code shown in the earlier screenshot?*
    |'
  prefs: []
  type: TYPE_TB
- en: The code snippets with and without the `finally` clause are shown in the following
    screenshot. The code in the `finally` clause is assured to be executed in the
    end, even when the `except` clause instructs the code to return from the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![finally...clean it up!](img/B05034_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `finally` clause is typically used to perform clean-up tasks before leaving
    the function. An example use case is to close a database connection or a file.
    However, note that, for this purpose, you can also use the `with` statement in
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: Back to the game – Attack of the Orcs v1.1.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this knowledge of the exception handling, let's work on the next incremental
    version of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Preparatory work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before writing any code, let's first understand how the rest of the section
    is organized. In a nutshell, we will start with v1.0.0 of the code from [Chapter
    1](ch01.html "Chapter 1. Developing Simple Applications"), *Developing Simple
    Applications,* progressively add the exception handling code, and call the new
    version v1.1.0.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Python files in the supporting code bundle already include the exception
    handling code to be discussed in this section as well as in a later section of
    this chapter, *Defining custom exceptions*
  prefs: []
  type: TYPE_NORMAL
- en: 'The following points elaborate further details:'
  prefs: []
  type: TYPE_NORMAL
- en: We will start by downloading the v1.0.0 of the game from [Chapter 1](ch01.html
    "Chapter 1. Developing Simple Applications"), *Developing Simple Applications*.
    The file name is `ch01_ex03_AbstractBaseClass.py` (recall that this was provided
    as a solution to an exercise in [Chapter 1](ch01.html "Chapter 1. Developing Simple
    Applications"), *Developing Simple Applications*). You can find this file in this
    chapter's code bundle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compare the aforementioned file with `ch01_ex03.py`. The only difference here
    is the use of an abstract base class, `AbstractGameUnit`, instead of an ordinary
    base class, `GameUnit`. The rest of the code is identical.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's copy `ch01_ex03_AbstractBaseClass.py` and save it as `attackoftheorcs_v1_1.py`.
    or give it any name you like. In the following discussion, we will refer to the
    file by this new name and incrementally add exception handling code to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As noted before, the supporting code bundle has all the exception handling code
    that we will review. You will find a file by the same name (`attackoftheorcs_v1_1.py`)
    in the code bundle with all the changes included.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the exception handling code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This will essentially be a bug-fix version with no new features added. The
    debugging done earlier has already helped us find where the problems are. Open
    the Python file (`attackoftheorcs_v1_1.py`) and update the `_process_user_choice`
    method of the `AbstractGameUnit` class. The updated version of this method with
    the new `try…except` clauses is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the exception handling code](img/B05034_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In case you missed reading this earlier, you should copy the `ch01_ex03_AbstractBaseClass.py`
    file and name it `attackoftheorcs_v1_1.py`. Then work with this new file to add
    the preceding exception handling code. Alternatively, you can simply review the
    file with the same name provided in the code bundle for this chapter. It includes
    all the changes we will discuss next. The Python 2.7.9 compatible source file
    is also provided in the code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `try` clause, if the `user_choice` variable is not a number, the `ValueError`
    exception occurs, which is handled by `except ValueError as e`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `as` keyword is used to assign exception to an `e` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, you can just use the syntax `except ValueError`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second `try…except` clause takes care of the situation where the input number
    goes out of range of the `huts` list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the `IndexError` exception occurs, the `continue` statement in the `except`
    clause makes the user re-enter the input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's all we need. Now, let's run the application next.
  prefs: []
  type: TYPE_NORMAL
- en: Running Attack of the Orcs v1.1.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is time to run the application and see if these changes fix the reported
    problems. Run the program in a terminal window, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When prompted for an input, enter some unacceptable value for the hut number:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running Attack of the Orcs v1.1.0](img/B05034_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Looks good! At least the reported problems have been resolved. It is easy to
    find more such errors. For example, a user can still enter 0 or a negative number
    while choosing a hut, or, when the program asks for permission to attack the enemy,
    any input other than `y` or `n` is not handled gracefully. As an exercise, have
    a go at fixing these issues yourself!
  prefs: []
  type: TYPE_NORMAL
- en: Defining custom exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can define your own exception class by inheriting from the `Exception` base
    class or any other exception class. Why do we need such customization? Firstly,
    you can create an exception class with a descriptive name. This allows us to identify
    the purpose of the exception just by looking at the descriptive name. For example,
    instead of `ValueError`, a custom exception named `ValueGreaterThanFiveError`
    will immediately help identify the problem. There are other advantages as well.
    You can use such classes to add customized messages based on error subcategories,
    writing error logs, and so on. Let's learn how to define custom exceptions next.
  prefs: []
  type: TYPE_NORMAL
- en: Preparatory work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a list of files we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`attackoftheorcs_v1_1.py`: This is the file from the previous section that
    we will use. As mentioned earlier, the supporting code bundle already has a file
    by the same name. It includes all the modifications we will discuss.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gameuniterror.py`: This is a new module to hold a custom exception class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`heal_exception_example.py`: This is where the top-level control code will
    be written. This is a simplified version of the game where we do not need to play
    the whole game in order to reproduce the problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to put all the aforementioned files in the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: Custom exception – The problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To demonstrate the use of custom exceptions, let's identify a trivial problem.
    Observe the `heal` method shown next (recall that it is defined in `AbstractGameUnit`,
    the superclass of `Knight`). You can find it in the `attackoftheorcs_v1_1.py`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom exception – The problem](img/B05034_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The method has two optional arguments. If `full_healing` is set to `True`, the
    game unit will regain all its lost hit points. The other option, `heal_by`, heals
    the game unit by a small amount. In this version, we are not using the `heal_by`
    option. But in a future version, you may want to introduce a turn-based feature
    in the game, where the injured units are healed by a small amount on every turn*.*
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate how to create and use custom exceptions, let's introduce an artificial
    bug in the `heal_by` feature! Save the following code as `heal_exception_example.py`
    and place this file in the same directory as `attackoftheorcs_v1_1.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom exception – The problem](img/B05034_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a simplified version of the game where we do not need to play the whole
    game in order to create this artificial bug! It is a top-level control code that
    creates a `Knight` instance, forcefully reduces the hit points (check out `knight.health_meter`)
    as if the knight has fought a combat and sustained injuries. In the end, it calls
    the `heal` function with the `heal_by` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have you noticed a problem here? Recall that the `knight` instance can have
    a maximum of `40` hit points (check out the instance attribute `Knight.max_hp`).
    The preceding code is trying to `heal` the knight by `100` points using the `heal_by`
    argument. Clearly, it will exceed the limit. One way of preventing this is to
    add an assertion statement in the `heal` method, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will raise an `AssertionError`. This is an acceptable solution. Another
    way to accomplish this is to use a custom exception class. It is demonstrated
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a new exception class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is trivial to create a new exception class derived from `Exception`. Open
    your Python interpreter and create the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all! We have a new exception class, `GameUnitError`, ready to be deployed.
    How to test this exception? Just `raise` it. Type the following line of code in
    your Python interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Raising the newly created exception will print the following traceback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Copy the `GameUnitError` class into its own module, `gameuniterror.py`, and
    save it in the same directory as `attackoftheorcs_v1_1.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, update the `attackoftheorcs_v1_1.py` file to include the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the following import statement at the beginning of the file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The second change is in the `AbstractGameUnit.heal` method. The updated code
    is shown in the following code snippet. Observe the highlighted code that raises
    the custom exception whenever the value of `self.health_meter` exceeds that of
    `self.max_hp`.![Writing a new exception class](img/B05034_02_21.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these two changes, run `heal_exception_example.py` created earlier. You
    will see the new exception being raised, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a new exception class](img/B05034_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Expanding the exception class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Can we do something more with the `GameUnitError` class? Certainly! Just like
    any other class, we can define attributes and use them. Let''s expand this class
    further. In the modified version, it will accept an additional argument and some
    predefined error code. The updated `GameUnitError` class is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Expanding the exception class](img/B05034_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at the code in the preceding screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it calls the `__init__` method of the `Exception` superclass and then
    defines some additional instance variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new dictionary object, `self.error_dict`, holds the error integer code and
    the error information as key-value pairs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `self.error_message` stores the information about the current error depending
    on the error code provided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `try…except` clause ensures that `error_dict` actually has the key specified
    by the `code` argument. It doesn't in the `except` clause; we just retrieve the
    value with the default error code of `000`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s take look at the consumer of this class. Observe the modified `heal`
    method. The only change here is the additional argument to the `GameUnitError`
    instance. Here, we pass an error code as the second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Expanding the exception class](img/B05034_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, we have made changes to the `GameUnitError` class and the `AbstractGameUnit.heal`
    method. We are not done yet. The last piece of the puzzle is to modify the `main`
    program in the `heal_exception_example.py` file. The code is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Expanding the exception class](img/B05034_02_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s review the code:'
  prefs: []
  type: TYPE_NORMAL
- en: As the `heal_by` value is too large, the `heal` method in the `try` clause raises
    the `GameUnitError` exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new `except` clause handles the `GameUnitError` exception just like any
    other built-in exceptions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within the `except` clause, we have two `print` statements. The first one prints
    `health_meter > max_hp!` (recall that, when this exception was raised in the `heal`
    method, this string was given as the first argument to the `GameUnitError` instance).
    The second `print` statement retrieves and prints the `error_message` attribute
    of the `GameUnitError` instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have got all the changes in place. We can run this example from a terminal
    window as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Expanding the exception class](img/B05034_02_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this simple example, we have just printed the error information to the console.
    You can further write verbose error logs to a file and keep track of all the error
    messages generated while the application is running.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting from the exception class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| *Sir Foo has* *something to say about the error codes maintained in* `GameUnitError.error_dict`
    *seen earlier…* |'
  prefs: []
  type: TYPE_TB
- en: '![Inheriting from the exception class](img/B05034_02_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| *You are right. While raising an exception, you need to remember what each
    error number corresponds to. Let''s discuss a few alternatives.* |'
  prefs: []
  type: TYPE_TB
- en: 'One option is to use unique strings as keys of `error_dict` in place of the
    error numbers, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This alleviates the problem of remembering the error codes. However, this approach
    is not suitable if you want to do something beyond just printing a message. For
    example, depending on the error type, you may want to do some additional processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better approach is to use `GameUnitError` as a base exception class and derive
    new classes that target specific errors. The descriptive names of these exception
    classes should help convey the same information. The following code snippet shows
    an example of how to do it. You can replace the existing code in `gameuniterror.py`
    with the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inheriting from the exception class](img/B05034_02_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, in the `heal` method, instead of raising the `GameUnitError` exception,
    just `raise` the `HealthMeterException`. Be sure to `import` the `HealthMeterException`
    module as indicated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inheriting from the exception class](img/B05034_02_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Running the code with the aforementioned changes produces a similar output.
    It is just that we have revised `error_message` of the `HealthMeterException`
    class. The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Likewise, you can create other subclasses to deal with specific issues.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Identify any code that can benefit from exception handling. For example, create
    a new `HutError` exception, and use it to raise errors related to the `Hut` class.
    Here is a cheat sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercise](img/B05034_02_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Instead of using `error_dict`, you can also create subclasses, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter served as an introduction to the basics of exception handling in
    Python. We saw how the exceptions occur, learned about some common built-in exception
    classes, and wrote simple code to handle these exceptions using the `try…except`
    clause. By handling exceptions, we fixed some obvious bugs in the *Attack of the
    Orcs* game.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter also demonstrated techniques, such as raising and re-raising exceptions,
    using the `finally` clause, and so on. The later part of the chapter focused on
    implementing custom exception classes. We defined a new exception class and used
    it for raising custom exceptions for our application.
  prefs: []
  type: TYPE_NORMAL
- en: With exception handling, the code is in a better shape. However, we still have
    the majority of the code squished inside a single file (`attackoftheorcs_v1_1.py`).
    In the next chapter, you will learn how to package the application code and release
    it to a broader audience.
  prefs: []
  type: TYPE_NORMAL
