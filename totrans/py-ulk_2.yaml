- en: Chapter 2. Namespaces and Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we covered how objects worked. In this chapter, we
    will explore how objects are made available to code via reference, specifically
    how namespaces work, what modules are, and how they are imported. We will also
    cover topics related to classes, such as language protocols, MRO, and abstract
    classes. We will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imports and modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class multiple inheritance, MRO, super
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How referencing objects work – namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 1: Interrelations between objects.**'
  prefs: []
  type: TYPE_NORMAL
- en: The scope is the visibility of a name within a code block. Namespace is mapping
    from names to objects. Namespaces are important in order to maintain localization
    and avoid name collision. Every module has a global namespace. Modules store mapping
    from variable name to objects in their `__dict__` attribute, which is a normal
    Python dictionary along with information to reload it, package information, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Every module's global namespace has an implicit reference to the built-in module;
    hence, objects that are in the built-in module are always available. We can also
    import other modules in the main script. When we use the syntax import module
    name, a mapping with module name to module object is created in the global namespace
    of the current module. For import statements with syntax such as `import modname
    as modrename`, mapping is created with a new name to module object.
  prefs: []
  type: TYPE_NORMAL
- en: We are always in the `__main__` module's global namespace when the program starts,
    as it is the module that imports all others. When we import a variable from another
    module, only an entry is created for that variable in the global namespace pointing
    at the referenced object. Now interestingly, if this variable references a function
    object, and if this function uses a global variable, then this variable will be
    searched in the global namespace of the module that the function was defined in,
    not in the module that we imported this function to. This is possible because
    functions have the `__globals__` attribute that points to its `__dict__` modules,
    or in short, its modules namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'All modules that are loaded and referenced are cached in `sys.modules`. All
    imported modules are names pointing to objects in `sys.modules`. Let''s define
    a new module like this with the name `new.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'By importing this module in the interactive session, we can see how global
    namespaces work. When this module is reloaded, its namespace dictionary is updated,
    not recreated. Hence, if you attach anything new from the outside of the module
    to it, it will survive reload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If we use the functions that are defined in different modules to compose a class
    on runtime, such as using metaclasses, or class decorators, this can bring up
    surprises as each function could be using a different global namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Locals are simple and they work in the way that you expect. Each function call
    gets its own copy of variables. Nonlocal variables make variables that are defined
    in the outer scope (not global namespace) accessible to the current code block.
    In the following code example, we can see how variables can be referenced in enclosed
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code blocks are able to reference variables that are defined in enclosing scopes.
    Hence, if a variable is not defined in a function but in an enclosing function,
    we are able to get its value. If, after referencing a variable in an outer scope,
    we assign a value to this variable in a code block, it will confuse the interpreter
    in finding the right variable, and we will get the value from the current local
    scope. If we assign a value to the variable, it defaults to the local variable.
    We can specify that we want to work with an enclosing variable using a nonlocal
    keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As variables are searched without any dictionary lookup for the local namespace,
    it is faster to look up variables inside a function with a small number of variables
    than to search in a global namespace. On similar lines, we will get a little speed
    boost if we pull objects that are referenced in loops in a function''s local namespace
    inside a function block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Functions with state – closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 2: Creating cheap state-remembering functions.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A closure is a function that has access to variables in an enclosing scope,
    which has completed its execution. This means that referenced objects are kept
    alive until the function is in memory. The main utility of such a setup is to
    easily retain some state, or to create specialized functions whose functioning
    depends on the initial setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do the same by creating a class and using the instance object to save
    state. The benefit with closures is that variables are stored in a `__closure__`
    tuple, and hence, they are fast to access. Less code is required to create a closure
    as compared to classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'One such function is available from the standard library, named partial, that
    makes use of closure to create a new function that is always invoked with some
    predefined arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Understanding import and modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 3: Creating a custom loader for modules.**'
  prefs: []
  type: TYPE_NORMAL
- en: Import statements get references of other module objects in the current module's
    namespace. It consists of searching the module, executing code to create a module
    object, updating caches (`sys.modules`), updating modules namespace, and creating
    a reference to new module being imported.
  prefs: []
  type: TYPE_NORMAL
- en: 'The built-in `__import__` function searches and executes the module to create
    a module object. The `importlib` library has the implementation, and it also provides
    a customizable interface to the import mechanism. Various classes interact to
    get the job done. The `__import__` function should return a module object. For
    example, in the following example, we are creating a module finder, which checks
    for modules in any path that is given as an argument during construction. Here,
    an empty file named `names.py` should be present at the given path. We have loaded
    the module, then inserted its module object in `sys.modules` and added a function
    to this module''s global namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Customizing imports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the module has an `__all__` attribute, only the names that are specified
    by the iterable in this attribute will be imported from module import `*`. Let''s
    assume that we created a module named `mymod.py`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We will not be able to import `spidey` from `mymod` as it is not included in
    `__all__`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Class inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already discussed how instances and classes are created. We also discussed
    how attributes are accessed in a class. Let's dive deeper into how this works
    for multiple base classes. As type is searched for the presence of an attribute
    for an instance, if the type inherits from a number of classes, they all are searched
    as well. There is a defined pattern to this (**Method Resolution Order** (**MRO**)).
    This order plays an important role in determining the method in cases of multiple
    inheritance and diamond-shaped inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Method resolution order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Key 4: Understanding MRO.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The methods are searched in the base classes of a class in predefined manner.
    This sequence or order is known as method resolution order. In Python 3, when
    an attribute is not found in a class, it is searched in all the base classes of
    that class. If the attribute is still not found, the base classes of the base
    classes are searched. This process goes on until we exhaust all base classes.
    This is similar to how if we have to ask a question, we will first go to our parents
    and then to uncles, and aunts (the same level base classes). If we still do not
    get an answer, we will approach grandparents. The following code snippet shows
    this sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Super's superpowers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Key 6: Get superclass''s methods without a superclass definition.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We mostly create subclasses to specialize methods or add a new functionality.
    We may need to add some feature, which is 80% the same as one in the base class.
    Then it will be natural to call base class''s method for that portion of functionality
    and add extra functionality in new method in the subclass. To call a method in
    superclass, we can either use its class name to access the method, or super it
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Using language protocols in classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All objects that provide a specific functionality have certain methods that
    facilitate that behavior, for example, you can create an object of type worker
    and expect it to have the `submit_work(function, kwargs)`, and is `_completed()`
    methods. Now, we can expect all objects that have these methods to be usable as
    workers in any application portion. Similarly, the Python language has defined
    some methods that are needed to add a certain functionality to an object. If an
    object possesses these methods, it has that functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss two very import protocols: iteration protocol, and context
    protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: Iteration protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For iteration protocol, objects must possess the `__iter__` method. If the
    object possesses it, we can use the object anywhere that we use an iterator object.
    When we are using the iterator object in a `for` loop or passing it to the `iter`
    built-in function, we are calling its `__iter__` method. This method returns another
    or the same object that is responsible for maintaining the index during iteration,
    and this object that is returned from `__iter__` must have a `__next__` method
    that provides the next values in sequence and raises `StopIteration` on the finish
    of this sequence. In the following code snippet, the `BooksIterState` objects
    help retain the index that is used for iteration. If the books `__iter__` method
    returned self, then it would be difficult to maintain a state index when the object
    is accessed from two loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Context manager protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The objects providing context for execution are like try finally statements.
    If an object has the `__enter__` and `__exit__` methods, then this object can
    be used as a replacement of try finally statements. The most common uses are releasing
    locks and resources, or flushing and closing files. In the following example,
    we are creating a `Ctx` class to serve as context manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the `contextmanager` decorator of `contextlib` to easily create
    context managers like the one shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'There are other methods that one should know, such as `__str__`, `__add__`,
    `__getitem__`, and so on, that define various functionalities of the objects.
    There is a list of them at the language reference''s `datamodel.html`. You should
    at least read it once to get to know what methods are available. Here is the link:
    [https://docs.python.org/3/reference/datamodel.html#special-method-names](https://docs.python.org/3/reference/datamodel.html#special-method-names).'
  prefs: []
  type: TYPE_NORMAL
- en: Using abstract classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 6: Making interfaces for conformity.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Abstract classes are available via the standard `abc` library package. They
    are useful for the definition of interfaces and common functionality. These abstract
    classes can implement a portion of the interface and make the rest of the API
    mandatory for subclasses by defining their methods as abstract. Also, classes
    can be turned into subclasses of the abstract class by simply registering them.
    These classes are useful to make a set of classes conform to a single interface.
    Here is how to use them. Here, worker class defines an interface with two methods,
    do and `is_busy`, which each type of worker must implement. `ApiWorker` is the
    implementation for this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we have seen how to manipulate namespaces, and to create custom module-loading
    classes. We can use multiple inheritance to create mixin classes in which each
    mixin class provides a new functionality to the subclass. Context manager and
    iterator protocols are very useful constructs to create clean code. We created
    abstract classes that can help us in setting up API contracts for classes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover the functions and utilities that are available
    to us from a standard Python installation.
  prefs: []
  type: TYPE_NORMAL
