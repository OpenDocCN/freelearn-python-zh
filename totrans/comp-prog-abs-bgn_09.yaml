- en: '*Chapter 7:* Program Control Structures'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If all of our code was simply executed in sequence, our programs would always
    do the same thing, no matter what data we provided them with. We must be able
    to control the path through the program so that some part of the code executes
    at the designated time, and other parts at other times, depending on the values
    provided by the data. For instance, only if it is cold outside do you put on warm
    clothes, not always. The same thing applies to our code. When things are a certain
    way, we want something to happen.
  prefs: []
  type: TYPE_NORMAL
- en: In a way, we can say that we, by this, will introduce some sort of intelligence,
    or at least some decision-making capabilities into our code. If things are this
    way, do this, if not, do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the execution path of the program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making decisions with the help of `if` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting one out of many options with `switch` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeating code execution with `for` loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating over code until a condition is false using `while` and `do while`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going over a sequence of data, one item at the time using `for each`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will dive into some real programming. In the topics that
    we will cover here, we will be able to control the execution path of the program.
    Let's first explore what that means.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the execution path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B15554_05_Final_NM_ePub.xhtml#_idTextAnchor081), *Sequence
    – The Basic Building Block of a Computer Program*, we learned that the code within
    a program is executed in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: A sequence is one of the three basic logical structures we have in programming.
    So, in this chapter, we will cover the other two, *selection* and *iteration*.
  prefs: []
  type: TYPE_NORMAL
- en: Selection statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are situations when we only want to execute some code if a condition
    is met. For example, if you recall our application from [*Chapter 5*](B15554_05_Final_NM_ePub.xhtml#_idTextAnchor081),
    *Sequence - The Basic Building Block of a Computer Program* which turned on the
    outdoor light, we had a condition that said if our phone detected that we were
    within a given range from our house, it should send a signal to the home computer.
    To refresh your memory, let''s take a look at some images you have seen before.
    *Figure 7.1* was used to illustrate the action of us entering the range:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: The phone detects that it is within a given range from our house](img/B15554_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: The phone detects that it is within a given range from our house'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have a condition. We used the illustration shown in *Figure 7.2* to
    indicate that when the condition was true, that is, we are within the range, a
    signal should be sent to the home computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: The condition is met, so the code for sending the message can
    be executed](img/B15554_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: The condition is met, so the code for sending the message can be
    executed'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break it down a bit more and consider the actual steps involved. The
    application on the phone would need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ask the GPS on the phone for the current position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the help of the given coordinates, calculate the distance to our home.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the distance is within a given range from our house, then send a signal to
    the home computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you can see, in *step 3*, we have a condition that states that the signal
    will only be sent if the condition is true. So, here, we have some code that will
    not always be executed. We call this selection. We could define selection like
    this: *selection is the ability to execute a section of code only if a condition
    is met.*'
  prefs: []
  type: TYPE_NORMAL
- en: Now we can ask ourselves another question. What should we do if the condition
    is false, that is, we are not within the range? Well, for this application, the
    answer is nothing. If we are not in the range, then we won't need to do anything.
  prefs: []
  type: TYPE_NORMAL
- en: The phone app also had another feature that is interesting to us now. When we
    have finished checking whether we are within the range or not, we will either
    send a signal to the home computer or do nothing. After that, we will go back
    to the beginning and repeat everything again so that we can be ready to check
    whether, after the movement, we are in the given range. We call this an *iteration*.
    We will learn what this is next.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An iteration is when we want to repeat something several times. It can also
    be referred to as a loop. The number of times we want to iterate something can
    be in the range of 2 to infinity. Now, in programming, infinity has a somewhat
    different perspective on things than you and I would usually have. Infinity in
    programming does not mean forever and ever, but more like as long as the program
    is running. So, in programming, infinity ends when the program ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the outdoor light app, we had an iteration. The following diagram illustrates
    the sequence for our phone app, and here we can clearly see the iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: The two arrows pointing at the top item indicate iteration](img/B15554_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: The two arrows pointing at the top item indicate iteration'
  prefs: []
  type: TYPE_NORMAL
- en: The diamond shape in the diagram is a condition. If the condition is true, that
    is, the answer is yes, that we send the signal. We can also see that no matter
    whether the condition was true or false, we will go back to the beginning. This
    app will continue to repeat these steps over and over an infinite number of times,
    that is, until you close the app or turn off your phone.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we only want to iterate a fixed number of times. Let's say that you
    are implementing an e-commerce solution, and a customer wants to check out all
    of the items that are currently in the shopping cart. You would need to iterate
    over all of the items in the cart to calculate the total price. If there were
    5 items in the cart, then you would need to iterate 5 times.
  prefs: []
  type: TYPE_NORMAL
- en: Both selection and iteration use conditions, so before we look at the different
    kinds of selection and iteration statements, let's take a closer look at what
    a conditional statement is and how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have covered the basics of this in several chapters already. A conditional
    statement is just a statement that can result in either true or false. The following
    is a list of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: It is raining today.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your age is below 20.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your credit card has expired.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your coffee cup is empty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these will result in either true or false. There are no maybes. It is
    either raining or not; you are either below 20 or not, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also seen that conditional statements can be combined with logical
    AND, or logical OR, to form a new, compound conditional statement. Here are some
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: It is raining today, and I have blue shoes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your age is below 20, or it is above 60.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your credit card has expired, and you have no cash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your coffee cup is empty, and your coffee machine is broken.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These compound, or full, statements are made up of two individual statements.
    *It is raining today* is one part, and *I have blue shoes* is another part. The
    two now need to be combined to form a full statement that can be either true or
    false. In the preceding example, we use *and* to combine them. This means that
    both individual statements need to be true for the whole statement to be true.
    It must be raining, *and* I must have blue shoes.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the second statement, the two smaller statements are combined
    with an *or*. This means that, for the whole statement to be true, at least one
    of the parts must be true. Either your card has expired, *or* you have no cash.
    It could also be unfortunate that both are true, and then the entire statement
    will be true.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know that we have selection and iteration statements and that they work
    with conditions, so let's see how we can write code that uses them. Let's start
    with the most common selection statement, `if`.
  prefs: []
  type: TYPE_NORMAL
- en: Selection with the if statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using selection in our programs, we could argue that the application uses
    some sort of *intelligence* because it can now make decisions and do different
    things depending on various conditions. So, how can we make our applications smart?
    Well, the easiest way is with the use of `if` statements, which are, sometimes,
    just referred to as *conditions*. In most languages, they will have a similar
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we write a small program that asks the user for their age, the first part
    might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, the program prints `Enter your age:` on the screen. The user then enters
    an age and presses the *Enter* key to confirm the input. The value entered will
    be stored in the `age` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we want to give different feedback depending on the age entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have the condition where we check whether the age is below `18`. If
    so, we will print the message, `You are young`. The condition is that the age
    must be below `18`. If it is `18` or above, nothing will happen, as the program
    will skip everything between them and end the `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, instead, we want to check for an interval, we could create a compound conditional
    statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are combining the two parts that make up the condition with
    an `and`. This means that both conditions must be true for the whole condition
    to be true. The age must be greater or equal to `13`, and, at the same time, it
    must be less than or equal to `19`. This will give us a range between 13 and 19,
    with both values included. If the age falls into this range, we will enter the
    `if` statement and print the text. If it is either less than 13 or greater than
    19, nothing will happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `if` statement comes with an optional part. This section is called `else`
    and marks a block of code that will be executed only if the condition in the `if`
    statement is false. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The difference here is that, now, we will always have something printed on the
    screen. Either the condition is true, and the message will be printed, or the
    condition is false and the section between `else` and `end_if` will be executed.
    Additionally, note that the part that will be executed when the condition is true
    now ends with the `else` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can have more than one statement in each of the sections if we want to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, if the age falls into the teenage range, we will print two lines. And,
    if it is false, we will still only print one line.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to have more complex logic, we can have nested `if` statements. That
    means we can have new `if` statements either in the section that executes if the
    condition is true or on the part that only executes if the condition is false.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if the condition in the preceding code is false, we know that
    you are either younger or older than the teenage years. If we want to distinguish
    this further, it is in this section of the code that we can check it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now the logic is a bit more complicated. If the user of our program responded
    with an age that is between 13 and 19, nothing has changed. However, if the age
    is anything else, we have a new `if` statement. As this one is located within
    the `else` section of the first one, we know that the age is either below `13`
    or above `13`. The second `if` statement checks whether it is less than `13`.
    And, if so, prints the `You are a child` message.
  prefs: []
  type: TYPE_NORMAL
- en: Now, think about what condition we have if we enter the second `else` section.
    First, we know that age is not between 13 and 19, or we would not be in this part
    of the program at all. We also know that the age is not below 13 because, if it
    was, we would have executed the `You are a child` part. We only have one option
    left; the age must be above 19.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have an `if` statement directly following an `else` statement, like we just
    saw, is so common that some languages have a special construct for it, called
    `elif`. In such a language, the same code would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The logic of the program is the same, but the code is more compact. As you can
    see, we have the second condition, if the age is below 13, on the same line as
    the old `else` statement, and the `else` statement has now changed into an `elif`
    statement. The word, `elif`, is just made up of the two words, `else` and `if`.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, note that, in the first example, the program ended with two lines
    containing `end_if`. The second version just has one.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the second program, you can now clearly see that there are three
    different sections and that only one of them will be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: If the age is between 13 and 19, we enter the first section and execute the
    code within that block. After that, we are done, and the rest of the code will
    be skipped.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the age is below 13, we will first skip the first part and go to the `elif`
    part. The condition here is true, so we will enter this part and execute the code
    within. After that, we are done and can, again, skip to the end.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, if the age is greater than 19, we will first skip over the first section
    and go to the `elif` part. The condition found here will also be evaluated to
    false, so we skip ahead to the `else` part. As this part does not contain any
    condition, we will always end up here if none of the preceding conditions were
    true.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Even if the language we are using does not have an `elif` statement, we can
    create the same logic anyway. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the only thing that has changed here is that the `elif` statement
    has been replaced with the two words, `else` and `if`. The rest is the same and
    the logic is also unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this idea with nested `if` statements such as this can be very efficient.
    First, we must understand that we can have as many of these as we need. The structure
    can then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at this structure, you can see that this looks like a fork, where
    we only can choose one of the tines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: Nested if statements are like a fork](img/B15554_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Nested if statements are like a fork'
  prefs: []
  type: TYPE_NORMAL
- en: When we have one out of many things that can be true, we do have an option.
    It is another fork-like structure that works pretty much the same way as the nested
    `if` statement we just saw. It is called a `switch` statement. We will study this
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Selection with the switch statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One alternative, when we have one option out of many that can be true, is the
    `switch` statement. It also works with conditions even if they are not as apparent
    as they are in an `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Another difference is that a `switch` statement only compares values for equality.
    The reason for it is that it is not suitable for the age logic we used when we
    explored the `if` statement, as we wanted to see whether the age was between two
    values. Instead, it is perfect if we're going to match it to a value that is fixed.
    We will soon look at a real example. However, first, let's explore the structure
    of a `switch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: What a `switch` statement looks like depends on what language we use. What we
    will see here is a structure that is rather common, but when applying it, you
    will need to look up the correct syntax for your language.
  prefs: []
  type: TYPE_NORMAL
- en: A `switch` statement begins by stating what variable we want to check. It is
    common for languages to use the `switch` keyword for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the name, `variable`, is just a placeholder for the actual
    variable we want to work with. Between the `switch` keyword and `end_switch`,
    we will need to specify each value we want to compare the variable to. It could
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Each case specifies the value that we compare the variable to. The first case
    compares it to `1`, the second to `2`, and so on. The ellipsis (`...`) marks the
    location where we will insert the code for each option. The first ellipsis is
    to indicate which code will be executed if the variable is `1`, the second for
    when the value is `2`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In many languages, we have something that is called a *fallthrough*. What this
    means is that when the right value is found, the code within that `case` statement
    will execute, but then the code in all the `case` statements that follow will
    also execute. So, if the value of the variable is `2`, the code for both `2` and
    `3` will execute. The reason it does that is so that we can have multiple `case`
    instances following each other and just one code block for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To indicate that we want the fallthrough to stop, we must give an instruction
    that we are done, and we can now jump to the end of the `switch` statement. This
    instruction is, usually, `break`. It is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, we have one value for each case block, so the code will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If the value of the variable is `2`, the code within that block will execute,
    and when the `break` statement is reached, the execution of the whole `switch`
    statement will end. This is good, as only one of the options can be true. So,
    if one has been executed, we know that we are done.
  prefs: []
  type: TYPE_NORMAL
- en: You could argue that the `break` statement in the `case` block for the value
    of `3` is unnecessary as we don't have any more statements that we can fall through
    to. However, it is a good practice to have it there because we might add more
    options in the future, and then we wouldn't want to take the risk of forgetting
    to add that `break`.
  prefs: []
  type: TYPE_NORMAL
- en: '`switch` statements also have something that resembles the `else` part of an
    `if` statement, that is, a block that would execute if no other values evaluated
    to true. In a `switch` statement, this is called `default`. It usually comes at
    the very end, after all of the `case` statements. It can look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Again, the last `break` statement is optional, but we keep it there for consistency.
    Note that now we can appreciate that we had a break within number `3`, since,
    without it, a value of `3` would first execute the code in the `3` block and then
    fall through to the default block.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have all the parts of a `switch` statement in place, so let's look at
    an example of when and how it can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will ask the user of our program to input the numeric value for a
    month, that is, `1` for January, `2` for February, and so on. We will store the
    number the user entered in a variable we call `month`. We can now use this variable
    in a `switch` statement to figure out the name that matches the number the user
    gave us. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, months 4 to 11 are left out, but they are repeated using
    the same pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say the user enters `8`. The program will start at the top and check
    case `1`. If this has been an `if` statement instead of a `switch`, case `1` would
    be equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Since the user entered `8` and not `1`, this is false, so the program will go
    to the next case, `case 2`, and try again. There is still no luck, so it will
    continue all the way down to `case 8`, where it finally gets a match. It will
    now enter this block and create a variable called `month_string` and assign the
    value of `August` to it.
  prefs: []
  type: TYPE_NORMAL
- en: On the next line, it hits a `break`. This means, "get me out of here," so the
    program will now skip all of the other tests because it knows that it is done.
  prefs: []
  type: TYPE_NORMAL
- en: If the user entered an invalid month, say `14`, all cases will first be checked,
    but as none will be true, the code in the `default` block will execute and the
    `month_string` variable will get an `Invalid` value.
  prefs: []
  type: TYPE_NORMAL
- en: On the very last line, the text, `The name of the month you entered is`, will
    be printed, and the value we have in our `month_string` variable will be appended
    to the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'The execution of the program would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With the help of the selection structures, `if` and `switch`, we can build complex
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'When designing a solution, you should keep a couple of things in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is easy to get a bit confused as the logic will, at times, feel entangled
    and hard to understand. It is, therefore, essential to remember what we said earlier
    in this book: try to zoom in to one small subproblem, understand it, and design
    a solution for it. When that is in place, you can zoom out a bit and examine how
    it works in a bigger context. Then, you can repeat this process. This might sound
    very abstract but keep it in the back of your mind, and try to use this approach
    when you feel that a problem is getting too complex.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always remember that the readability of your code counts. What this means is
    that if you have a solution that works but the code is very complex and hard to
    read, you should go back and try to rewrite it, making sure that it still works
    but also that another programmer (or you in the future) easily can read and understand
    what the code does.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have covered two of the three fundamental pillars that programming
    rests upon, sequence and selection, it is time to tackle the last one, iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration with the for loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first type of iteration we will look at is the `for` loop. This is a kind
    of loop when we, in one way or the other, know how many times we want to repeat
    something. This can be a fixed number of times, such as iterating over a list
    using the days of the week. We know it is always 7\. It can also be that we have
    values in an array. We might not know precisely how many items there are in the
    array at any given time; however, as we will see, there are ways to ask the array
    how many objects it is currently holding.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using a `for` loop, we will work with a variable that keeps track of how
    many times we have iterated. We can decide what value this variable shall start
    on. It is this variable that helps us to know when to stop iterating. Let''s look
    at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create (or declare, as a programmer would say) a variable called `i`.
    The name, `i`, is frequently used as the name for this variable since it is often
    used as an index. However, we will discuss that in more detail later. After the
    assignment operator (`=`), we say that we want to give `i` a starting value of
    `0`. We will then repeat the code within the `for` block and `i` will be increased
    by one for each iteration. The value of `10` is the stop condition. When `i` has
    reached this value, it should stop repeating and continue executing the code that
    comes after the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we print the value that `i` currently has inside the loop, the code will
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Most languages will print the values of 0 to 9 and not 0 to 10\. That might
    seem strange, but if we look at the logic that the `for` loop uses, we can understand
    why that is.
  prefs: []
  type: TYPE_NORMAL
- en: When we first hit the line with the `for` loop, the variable, `i`, is created
    and initialized with the value of `0`, since we said that we want this as our
    starting value.
  prefs: []
  type: TYPE_NORMAL
- en: It will then compare the value that `i` has with the second value we gave, `10`.
    If they are equal, the loop will stop. As this is the first iteration, the value
    is 0 and they are not equal; therefore, the code inside the loop will execute.
    When we come back up to the line with the `for` loop again, the value in `i` is
    incremented by one, that is, 0 + 1 = 1\. This value is now compared to our end
    value, `10`. This is still not a match. It will continue like this until the value
    of `i` is `9`. When returning to the line with the `for` loop again, it will increase
    `i` by `1`, making it `10`. Now, when the values are compared, they will be equal
    and the `for` loop will end. So, we will never enter the loop when `i` has the
    value of `10` and that is why we only see the values of 0 to 9 printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned before in this book, the C programming language has had a huge
    impact on the syntax of many other languages. The way in which `for` loops are
    written is such an example. Let''s examine what the same `for` loop would look
    like in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: On the first line, we declare the variable, `i`, also stating that it shall
    work with the data type, `int`. In the C language, statements end with a semicolon.
    That is why we have one after the `i` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Then comes the `for` loop. In C, we have three sections in a `for` loop. They
    are separated using semicolons. The first is the initialization. That is where
    we say `i = 0`. This means that `i` will have a value of `0` in the first iteration.
  prefs: []
  type: TYPE_NORMAL
- en: The second part is the condition that states how long we shall continue to loop.
    Here, we say `i < 10.` We can read this as *continue as long as i is less than
    10*.
  prefs: []
  type: TYPE_NORMAL
- en: The last section indicates how `i` will change in each iteration. Here, we say
    `i++`. This is C's way of saying, *take whatever is in the variable,* `i`, *right
    now and increase it by one, then store the new value in* `i`.
  prefs: []
  type: TYPE_NORMAL
- en: The line inside the loop might look a bit strange. But there is no need to go
    into all of the details of how C handles printing values, as it is far more complicated
    than in most languages. The only thing we need to know is that it will print the
    current value of `i`.
  prefs: []
  type: TYPE_NORMAL
- en: The output will be the same as in our earlier example, `0` to `9`. Here, we
    can see why the value of 10 is not printed because the condition says `i < 10`.
    When `i` is `10`, this is no longer true, and the loop will exit. If we, instead,
    had `i <= 10`, the value of `10` would be included.
  prefs: []
  type: TYPE_NORMAL
- en: The languages that use this style include C++, C#, Java, JavaScript, PHP, and
    Go. With slight variations, they all have `for` loops that use the three sections
    that we saw in the C loop.
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, we will not use the C-style loops in this book but stick to
    the first version we looked at instead. This will help us to focus on how `for`
    loops work without being distracted by the syntax for writing them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to change the loop variable in any other way than just increasing
    it by one, we can do that as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will increment the value that `i` has by `2` each time. The output
    of this program will be similar the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It still starts at 0, but as we increment by `2`, all the odd numbers will be
    skipped. Just like earlier, we are exiting the loop when `i` reaches `10`.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we want to put a `for` loop inside another `for` loop. This is called
    a nested `for` loop. We will need two different variables for these loops so that
    they don't interfere with each other. As an example, we might want to go over
    all 7 days of the week. We will print the days such as `day 0`, `day 1`, and so
    on. We will start at 0 for simplicity, but we could, of course, have started at
    1 if we wanted to.
  prefs: []
  type: TYPE_NORMAL
- en: For each day, we want to print all of the hours of that day. If we think about
    it, we will need a loop for the days. When we are inside this loop, we can imagine
    that we are working with one single day. For this day, we will need to print all
    of the hours. Then, when we are done, we will need to repeat the process for the
    next day. Instead of using the variable name, `i`, we can use more meaningful
    names for the two loops. We will use `day` for the loop that handles the days
    and `hour` for the loop that controls the hours.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the program should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We are leaving out parts of this long output. The parts left out are indicated
    by an ellipsis.
  prefs: []
  type: TYPE_NORMAL
- en: If we follow the logic of this program, we can see that we first start out with
    the outermost loop, that is, the one that handles the days. We have a variable
    called `day` and assign it to the starting value of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we print the text, `day`, and append the value stored in the variable
    named `day`. Note that `day` within quotes is a string that will be printed as
    it is, and `day` without quotes is the variable.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we come to the innermost loop. This will handle the hours. This also starts
    out with a value of `0` and uses a variable called `hour`. It will print the current
    hour in the same way that we did with the days.
  prefs: []
  type: TYPE_NORMAL
- en: The program will run inside the inner loop until we get a value of `24` inside
    the variable, `hour`. Then, it will exit. The program will now go back to the
    beginning of the outer loop, the one handling days. It will increase the `day`
    variable by one, and check whether it is less than `7`. And, because it is, we
    will enter the loop, and the process will repeat.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to go backward in a `for` loop. We just need to switch
    the starting and end values and decrease the loop variable instead of increasing
    it. It can look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we will count down from `10` to `0`. Since we want the value of `0` to
    be printed, we have set the stop value to `-1`. We can see the stop value as the
    first value that should not be part of the range. Since we are decreasing the
    variable by `1`, the first value after `0` is `-1`. We have also changed the step
    to `-1`. This will cause the variable to decrement by 1 each time.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we don't know how many times we want to repeat something. We can
    use another type of `for` loop, that is, the `while` loop. Let's explore what
    that is.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration with the while loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's assume that we want to write a small dice-guessing game. The user will
    need to enter a guess between 1 and 6\. The computer will then roll a dice and
    let the user know whether their guess was correct or not. The program will then
    allow the user to guess again, and again, and again. However, if the user enters
    a value of 0 as their guess, we will let them exit the game.
  prefs: []
  type: TYPE_NORMAL
- en: We have no way of knowing how many times the user wants to play the game. They
    might give up after the first try or go on for hundreds of attempts (which is
    not that likely as this is a rather dull game, but you get the point).
  prefs: []
  type: TYPE_NORMAL
- en: A `for` loop would not work that well for us here as we would need to say how
    many times the user would need to play before we let them out of the loop. Instead,
    another type of loop that is perfect for this scenario is the `while` loop. This
    loop works on a condition instead of a count. If the condition is true, it will
    continue to loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If the condition is true, we will continue looping. This means that somewhere
    within the loop, the condition must be able to change or it will never get out
    of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will still need a variable to use in the condition. For example, we could
    use a Boolean variable for this. Recall that a Boolean variable only can hold
    the values of `true` and `false`, and a condition is something that will be evaluated
    to either true or false. It can look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, we declare a variable called `continue` and set it to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop will look at the content of this variable, and, since it is
    `true`, it will enter the loop.
  prefs: []
  type: TYPE_NORMAL
- en: It will now continue to loop as the variable has the value of `true`. It is,
    therefore, vital that we, at some point inside the loop, assign a value of `false`
    to the variable so that we can get out of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now build our guessing game using a `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Before going over the program and how it works, take a look at the following
    output from a potential game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the code, we can observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that we first create our variable that will keep track of when to
    stop looping. Since the `while` loop runs if something is true, we set this variable
    to `true`. If it is set to `false`, we will not enter the loop and the game will
    be over before we even had a chance to play.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then comes the actual loop. Since the variable initially is set to `true`, we
    will enter the loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first thing that happens in the loop is that there is some text that provides
    instructions to the user. This is an excellent idea to let the user know how to
    exit the game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then take the input from the user and store it in a variable called `guess`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now it is time to roll a virtual dice. The `random(1, 6)` will give us a random
    number between 1 and 6\. We store that random number in a variable named `dice`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we check whether the user made a correct guess or not, we will examine
    whether the user has entered `0` to indicate that the game is over. The reason
    we do that before we check whether the guess is correct or not is because if the
    user wants to end the game, we don't want to check their guess as we know 0 will
    indicate a wrong guess. We don't want to treat the input of `0` as a guess.
  prefs: []
  type: TYPE_NORMAL
- en: If `guess` is equal to `0`, we want to exit the loop. We do that by assigning
    `false` to the `continue` variable.
  prefs: []
  type: TYPE_NORMAL
- en: As the rest of the content of the loop is in an `else` block, we will skip that
    if the input was `0`. When we move to the line with `while`, `continue` will now
    be `false`, and we will exit the loop and print the thank you line at the end
    of the program.
  prefs: []
  type: TYPE_NORMAL
- en: If the user has, instead, entered something other than `0`, we will enter the
    first `else` block.
  prefs: []
  type: TYPE_NORMAL
- en: The first line inside of this block is where we check whether the user made
    a correct guess. If the value we store in `guess` and the value that is in the
    `dice` variable is equal, we have a winner.
  prefs: []
  type: TYPE_NORMAL
- en: If so, we will print a message congratulating the user. If not, we will let
    the user know that the guess was wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the code, we can see that the indentation of the code helps us to
    see which part belongs to which block. Note the block that starts with the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This can only be reached if the user did not enter a value of `0` since it is
    within an `else` block.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, a `while` loop is a handy feature. It has a sibling, the `do
    while` loop, which is almost identical to the `while` loop but with a little twist.
    Let's examine that next.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration with the do while loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `do while` loop has the same features as the `while` loop. `do while` works
    on a condition and can be used when we don't know how many iterations we will
    need to make.
  prefs: []
  type: TYPE_NORMAL
- en: The difference from the `while` loop is that where a `while` loop might never
    execute because the condition could be `false` the first time we test it. In comparison,
    the `do while` loop is guaranteed to run at least once. The reason for this is
    because the condition is moved from the beginning of the loop to the end of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be good for several reasons, and it can make our guessing game slightly
    less complicated. However, before we do that, we should look at what a `do while`
    loop looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `do` keyword marks the beginning of the loop. As you can see, there is nothing
    more on this line, so the program must run through the code inside the loop at
    least once to reach the condition at the very end.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with the `while` loop, we must have some code that somehow modifies
    the condition so that we can get out of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'One interesting aspect, when compared with the `while` loop, is that we don''t
    need to create a variable outside the loop to hold a value that we can use for
    our condition. The reason for this is that, since we are checking the condition
    at the very end, we might be able to perform the condition check using a variable
    that we create inside the loop. To see this in action, let''s modify our guessing
    game to use a `do while` loop. Take a look at the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The program is a bit shorter. This is because the `continue` variable is gone.
    If you look at the condition found on the penultimate line, you will see that
    we are using the `guess` variable directly to check whether it is not `0` (remember
    that the `!=` operator means, does not equal to). This means if the user does
    not input `0`, we will repeat.
  prefs: []
  type: TYPE_NORMAL
- en: We have also changed the `if` statement inside the loop. It now checks whether
    the `guess` variable is not equal to `0`, and only if it is, we will treat it
    as a proper guess.
  prefs: []
  type: TYPE_NORMAL
- en: If we have a sequence of things, such as an array, for example, it can be handy
    to go through that sequence one item at a time. We do have a loop for that too,
    which is the `for each` loop. Let's explore how that works next.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over sequences using for each
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we have a sequence of things, we often want to go through it item by item.
    We can, of course, do that using a `for` loop, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: On the first line, we declare an array of strings containing some names. We
    are using a variable called `names` to store the values.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we use a `for` loop, starting at `0`. To find out how many times we will
    iterate, we ask the array how many items it currently has stored. We do that by
    using the `names` variable, and, by using a dot, we can get what is known as a
    property from the array. This property is a value that stores how many items the
    array currently has. The way we can ask a sequence how many items it has will
    differ from language to language, but it will most likely be something like what
    we have done.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to remember two things here:'
  prefs: []
  type: TYPE_NORMAL
- en: When using an index to retrieve a value from the array, we start at `0`. This
    means that we need to give our loop a start value of `0`, since `Anna` will be
    stored at that index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to make sure that the ending value is one that is greater than the last
    index in the `for` loop. Our array has four values, so when we ask it for its
    length, that is the value we get. However, when indexing into the array, we need
    to use the values of 0, 1, 2, and 3\. This is four values, and the counting starts
    at 0, not 1\. Since we know that the second value we give in the `for` loop is
    the ending value, and it is the next value outside the range we want, then saying
    that we want to end at `names.length` ensures that we only get the values of 0,
    1, 2, and 3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the loop, you can see that we are using the `loop` variable to index
    into the array. The first time, we will get `Anna`, the next time, we will get
    `Bob`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'An easier and safer way to do this is by using something known as a `for each`
    loop. What this will do is it will go through a sequence and give us one of its
    items, one at a time. Taking the same previous code and using such a loop will
    now be like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this is much nicer. We can read this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: From the sequence names, give us the first item and store its value in the `name`
    variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first iteration, `name` will contain `Anna`. The loop keeps track of
    where it is in the sequence. So, in the next iteration,  `name` will be given
    the value of `Bob`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, note that we don't need to keep track of how many things there
    are in the sequence, and we don't need to use any indexing, since indexing starts
    at 0 and not 1.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This kind of loop gives us cleaner and more readable code that also reduces
    the risk of us inserting any errors into the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this loop to iterate over any sequence. As a string is a sequence
    of characters, using this loop on a string will give us each character that the
    string is made up of. Consider the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, we ask the user for a name and store the answer in a variable called `name`.
    We will then iterate through the variable, one character at the time. The current
    character will be stored in a variable called `character`. Inside the loop, we
    will just print that character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this program will give us an output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We have looked at four different ways to make iterations and all of them have
    their different use cases. View them as a set of tools that we have at our disposal
    and can pick and use as needed. Add to that the tools for selection that we looked
    at earlier in this chapter and the toolset will keep improving!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sequence, selection, and iteration are the three pillars that programming rests
    upon, and, in this chapter, we have covered the latter two.
  prefs: []
  type: TYPE_NORMAL
- en: Selection is when we test values in variables using a condition that can be
    either true or false. If our test turns out to be true, we can let the program
    execute a block of code. If it turns out to be false, we can have another block
    that only runs if in the case. This is done with the help of `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we have multiple options to choose from, and we need to pick one.
    We could then use a `switch` statement. Using it instead of an `if` statement
    can make your code less verbose and easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: The common task of repetition can be done in at least four ways, with the most
    common being the `for` loop. This loop will let us iterate a fixed number of times.
  prefs: []
  type: TYPE_NORMAL
- en: When we don't know how many times we want to iterate, we can use either a `while`
    loop or a `do while` loop. They will both iterate as long as a condition is true.
    This will let us write very flexible applications that might repeat something
    twice.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the `while` loop and the `do while` loop is where the
    condition is located. In a `while` loop, it comes at the beginning, and, in a
    `do while`, it comes at the end.
  prefs: []
  type: TYPE_NORMAL
- en: If we have a sequence of something, using a `for each` loop is the best choice,
    since it will go through the sequence and give us one of its objects at a time.
    It is a safe structure to use because it makes sure that we actually get all the
    values and don't miss out on the first or the last one.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will structure our code with the help of functions.
    They are a great way to make our code easier to read, understand, and maintain.
    They are also perfect for helping us to reuse the code that we have written.
  prefs: []
  type: TYPE_NORMAL
