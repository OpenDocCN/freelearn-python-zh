- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More Possibilities with Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any IDE worth its salt is extensible via a plugin architecture. The big names
    from Microsoft, Eclipse, and JetBrains support plugins as do the smaller, free,
    and open source IDE projects such as Geany and Ninja IDE. Even vim, which is as
    bare bones as it gets given it has no GUI, has a plethora of plugins available
    that allow you to customize your experience beyond the capabilities of the shipped
    product. In the case of JetBrains IDEs, the plugin architecture is at the heart
    of everything they build.
  prefs: []
  type: TYPE_NORMAL
- en: Consider that JetBrains started with IntelliJ and from that, built a dozen or
    so specialty IDEs. The reason this was possible is that their architecture is
    based on plugins. PyCharm Professional includes all the core functionality of
    two other IDEs, WebStorm and DataGrip, because those features are simply sets
    of plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to discuss some important plugins both from JetBrains
    and from third-party developers. By the end of this chapter, you will know the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to leverage JetBrains remote development features that allow you to work
    on your local laptop while leveraging a remote environment such as a virtual machine,
    workstation, or server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work collaboratively with JetBrains *Code* *With Me*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work with Docker using the JetBrains Docker plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to leverage development infrastructure as code using HashiCorp Vagrant within
    PyCharm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’ll also cover some smaller, quality-of-life plugins including themes, specialized
    highlighters, additional languages, and of course, the Black code formatter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to proceed through this chapter, and indeed the rest of the book,
    you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An installed and working copy of PyCharm. Installation was covered in [*Chapter
    2*](B19644_02.xhtml#_idTextAnchor028)*, Installation and Configuration*, if are
    jumping into the middle of the book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many of the sections in this chapter require connecting to services on the internet.
    A high-speed connection or a lot of patience is required for some of the demonstrations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the section on remote development, you’ll need a remote computer accessible
    via SSH and running a Linux operating system. This can be a physical machine or
    a virtual machine running via a cloud provider. I only cover connecting to a remote.
    I won’t go into a deep dive on setting up a Linux computer or virtual machine
    to serve as a remote.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the section on Docker, I’ll be using Docker Desktop. You can find the installation
    instructions for your computer’s operating system at [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This book’s example source code from GitHub. We covered cloning the code in
    [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028)*, Installation and Configuration*.
    You’ll find this chapter’s relevant code at [https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-15](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-15).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bundled plugins and JetBrains Marketplace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There have been several cases throughout the book where I pointed out useful
    plugins. I just couldn’t wait, and the plugins I showed you were either highly
    relevant to the particular chapter in play or just really cool and exciting. In
    the interest of being a responsible PyCharm mentor, I will collect myself, contain
    my enthusiasm (as much as I can), and pretend that you skipped immediately to
    this chapter, which might just be the best chapter in the book. Or not, you decide.
  prefs: []
  type: TYPE_NORMAL
- en: 'A great many features throughout JetBrains IDE products are built as plugins.
    You’re going to encounter two types of plugins: plugins made by JetBrains, and
    third-party plugins available in JetBrains Marketplace. Many plugins made by JetBrains
    are bundled in the various IDEs they make, but some have to be added or activated.
    Let’s start by exploring the **Plugins** panel available in the IDE’s settings.'
  prefs: []
  type: TYPE_NORMAL
- en: The plugins window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several ways to get to the **Plugins** window. Perhaps the simplest
    is to just close whatever project you might have open in PyCharm, which gives
    you the window we started with 15 chapters ago in *Figure 15**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1: The Plugins window contains all the tools you need to manage
    plugins in PyCharm](img/B19644_15_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.1: The Plugins window contains all the tools you need to manage plugins
    in PyCharm'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the **Plugins** window, you’ll find two important tabs: one shows
    you the plugins you have installed (**2**) and the other takes you to Marketplace
    where you can buy and install new plugins (**1**). Many of the plugins in Marketplace
    are free, but many of the better ones are not.'
  prefs: []
  type: TYPE_NORMAL
- en: The gear icon (**3**) allows you to configure additional plugin repositories.
    I’ve never needed this, but it’s there if you do. You can also install a plugin
    from a local folder using the relevant menu found under the gear.
  prefs: []
  type: TYPE_NORMAL
- en: The search box (**4**) allows you to find plugins in the list. When you select
    a plugin you’ll usually get some information about it on the right side (**5**).
    Plugins can be enabled and disabled (**6**), so if your IDE behaves erratically
    after installing a plugin, you can turn it off temporarily or uninstall it completely.
  prefs: []
  type: TYPE_NORMAL
- en: Bundled plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you study the list in *Figure 15**.2*, you’ll find that most of the plugins
    on this screen are bundled with PyCharm. These are plugins created by JetBrains
    and included in the normal PyCharm installation. It’s not a bad idea to examine
    this list and disable plugins you aren’t likely to use. For example, I use **Terraform**
    and **Ansible** for my DevOps and **Infrastructure as Code** (**IaC**). I am not
    likely to use Puppet, so I should disable that plugin.
  prefs: []
  type: TYPE_NORMAL
- en: As you do this, you might find PyCharm warning you about dependent plugins.
    For example, there is a plugin for Less, which is a CSS meta-framework. I don’t
    use it, so it’s tempting to disable it. However, the JSX Styled Components plugin,
    which I do use in React projects, is dependent on Less. See *Figure 15**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2: I am warned when I try to disable a plugin that is needed by
    another plugin](img/B19644_15_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.2: I am warned when I try to disable a plugin that is needed by another
    plugin'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, I’d better leave **Less** enabled.
  prefs: []
  type: TYPE_NORMAL
- en: JetBrains Marketplace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re up for some retail IDE therapy, you can click the **Marketplace**
    tab and go shopping. Some plugins are free, some aren’t. You can search for and
    install plugins from Marketplace easily from this screen. If you buy one, you’ll
    likely be routed to the JetBrains Marketplace website so you can control your
    license.
  prefs: []
  type: TYPE_NORMAL
- en: Making your own plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Anyone can make an IDE plugin using the Java programming language and IntelliJ
    Community or Ultimate editions. I won’t cover how to make a plugin, I’ll at least
    show you how to get started. In *Figure 15**.3*, I have IntelliJ Community Edition
    open on the new project dialog. Given you have extensive experience with creating
    projects in PyCharm, I’ll tell you that all the IDEs are identical. IntelliJ is
    the original flagship IDE product from JetBrains.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3: IntelliJ Community Edition has a project template for creating
    your own IDE plugins](img/B19644_15_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.3: IntelliJ Community Edition has a project template for creating
    your own IDE plugins'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the project template, there is also a hyperlink to a tutorial
    on building your plugin project.
  prefs: []
  type: TYPE_NORMAL
- en: Requiring plugins for your projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as we have a `requirements.txt` text file to list the names and versions
    of the packages necessary for a given Python project, we can specify particular
    plugins as requirements for a PyCharm project. This will ensure other developers
    have access to any plugin functionality you deem crucial to their success in collaborating
    on your project. *Figure 15**.4* shows you how to set the required plugins for
    your project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4: The steps for requiring plugins](img/B19644_15_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.4: The steps for requiring plugins'
  prefs: []
  type: TYPE_NORMAL
- en: First, having gone into your project’s settings and located **Build, Execution,
    Deployment**, find the **Required Plugins** menu item (**1**) and click it. Next,
    click the **+** icon (**2**) and select your required plugins from the dialog
    box that appears (**3**). Click **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: Useful miscellaneous plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I want to devote the bulk of this chapter to some very impactful plugins that
    are packed with complex features. Before I do that, though, let’s get the easy
    stuff out of the way. I’ll cover the small, interesting plugins you’re most likely
    going to think of when you search for IDE plugins. Some of these we have seen
    in other chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: The CSV plugin was covered in [*Chapter 13*](B19644_13.xhtml#_idTextAnchor318).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Markdown plugin. This didn’t used to come bundled, but now it does and it
    definitely makes the cut.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cell mode plugin, which we also covered in [*Chapter 13*](B19644_13.xhtml#_idTextAnchor318).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s talk about a few more, which I’ll group based on what they do.
  prefs: []
  type: TYPE_NORMAL
- en: Theme plugins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You spend 8 to 16 hours a day staring at the IDE. You might as well spend some
    time making it look cool. There are lots of color themes available. *Figure 15**.5*
    shows my current favorite: the dark purple theme.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5: The Dark Purple Theme is one of my favorites because it’s different
    than the standard VS Code dark theme](img/B19644_15_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.5: The Dark Purple Theme is one of my favorites because it’s different
    than the standard VS Code dark theme'
  prefs: []
  type: TYPE_NORMAL
- en: When people walk by and see the IDE up, they’ll immediately know you aren’t
    one of those VS Code slaves with their ubiquitous out-of-the-box Microsoft dark
    theme. You could use the stock Darcula theme that comes with PyCharm, but for
    a University of Oklahoma grad like me, that theme has entirely too much orange
    in it. Pick something you don’t see every day and soon everyone at the cube farm
    will know you are the real deal!
  prefs: []
  type: TYPE_NORMAL
- en: I also like the Material Theme UI in a nice solarized blue. This plugin comes
    in a lite (free) and a paid version. If you look around, you’ll find a color theme
    that suits you as there are many from which to choose. The easy way to find your
    new favorite is to type a tag into the search box shown in *Figure 15**.6*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6: You can filter your plugin search using tags such as “Theme”](img/B19644_15_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.6: You can filter your plugin search using tags such as “Theme”'
  prefs: []
  type: TYPE_NORMAL
- en: I recommend you try this because for whatever reason, leaving the search box
    blank doesn’t yield a very long list of options.
  prefs: []
  type: TYPE_NORMAL
- en: File handler plugins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This class of plugins provides colored highlighting for some of the non-code
    files we use every day.
  prefs: []
  type: TYPE_NORMAL
- en: The .ignore plugin provides some nice formatting for any of the common ignore
    files such as `.gitignore` and `.dockerignore`.
  prefs: []
  type: TYPE_NORMAL
- en: Tools integration plugins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Paul Everitt, one of the developer advocates for PyCharm, often reminds us that
    the I in IDE stands for *Integrated*. You should never need to leave PyCharm for
    any reason. Besides writing code, developers need to interact with issue trackers,
    VCSs, continuous build environments, and potentially a plethora of infrastructure
    tooling. It is no surprise there are plugins to help with these types of integration.
    *Figure 15**.7* shows the tag used to find these plugins.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7: Use the Tools Integration tag to find integrations to your favorite
    infrastructure and DevOps tools](img/B19644_15_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.7: Use the Tools Integration tag to find integrations to your favorite
    infrastructure and DevOps tools'
  prefs: []
  type: TYPE_NORMAL
- en: I used to be a heavy TeamCity user. If you use TeamCity, or any of the other
    JetBrains team tools, you’ll find plugins that allow you to monitor your builds,
    deal with issues, and more right from your IDE. For the record, Team City is still
    my favorite **continuous integration** (**CI**) server.
  prefs: []
  type: TYPE_NORMAL
- en: Productivity plugins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Developer productivity is the main reason to use an IDE in the first place.
    There are many additional features and integrations you’ll find under this tag.
    *Figure 15**.8* shows this tag in action.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.8: Use the productivity tag to find tools to make you more productive](img/B19644_15_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.8: Use the productivity tag to find tools to make you more productive'
  prefs: []
  type: TYPE_NORMAL
- en: My favorite DevOps plugin by far is GitToolbox. Take a look at one of my projects
    open in PyCharm with GitToolbox enabled.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.9: The GitToolbox plugin provides a lot of information about your
    project’s repository](img/B19644_15_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.9: The GitToolbox plugin provides a lot of information about your
    project’s repository'
  prefs: []
  type: TYPE_NORMAL
- en: At a glance, I can see the branch I am currently using along with how many commits
    ahead or behind I am relative to my remote. The plugin will help you clean up
    old branches you haven’t used in a while, perform regular fetches at timed intervals,
    and validate your commit messages. My favorite feature might be that you see the
    `git blame` information for each line. I’m not the blaming type, but I find it
    very useful as a lead developer to see which of my colleagues has worked on a
    particular file. It definitely helps code reviews go a little bit faster.
  prefs: []
  type: TYPE_NORMAL
- en: Completion plugins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'AI has become a game-changing integral part of software development. Using
    the `/tag: Completion` tag will list dozens of traditional and AI-powered code
    completion plugins, as seen in *Figure 15**.10*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.10: Completion plugins including the most popular AI implementations](img/B19644_15_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.10: Completion plugins including the most popular AI implementations'
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, GitHub Copilot and any of the dozens of ChatGPT plugins are very
    popular autocompletion plugins. Before you pay money for them though, check out
    my discussion of JetBrains **AI Assistant** plugin in *Chapter 17*. It is currently
    in closed beta, so I can’t really include it here, but it is really good and more
    tightly integrated than any of these plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Code with me (and never be lonely again)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pair programming is a popular practice introduced many years ago via the agile
    methodology known as **Extreme Programming** (**XP**). While not as well known
    as Scrum or Kanban, XP has many of the same practices and goals, but with pair
    programming as a mandatory component. In XP, two programmers sit in front of one
    computer and write code together. One person types while the other watches, coaches,
    looks things up, and generally contributes by helping out. At fixed intervals
    the programmers trade places. Adherents to the practice swear by it, claiming
    it eliminates the need for code reviews and generally leads to better code. Detractors,
    which include every non-technical manager alive, say it doesn’t make sense to
    have two expensive, specialized workers doing half as much work as they should.
  prefs: []
  type: TYPE_NORMAL
- en: Love it or hate it, you have to admit there is a great deal of utility in direct
    collaboration. The real issue is in a post-Covid world where a great many developers
    work remotely, the idea of two developers at one screen is no longer feasible,
    at least until now.
  prefs: []
  type: TYPE_NORMAL
- en: JetBrains has an integrated tool called *Code With Me*. This tool allows multiple
    developers to join a shared session online, where everybody works on a project
    at the same time on one computer. This plugin comes bundled with all JetBrains
    IDEs including PyCharm. You can activate this by clicking the icon shown in *Figure
    15**.11*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.11: To start a Code With Me session, click the icon indicated with
    the arrow](img/B19644_15_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.11: To start a Code With Me session, click the icon indicated with
    the arrow'
  prefs: []
  type: TYPE_NORMAL
- en: You can set permissions for your guests. Remember, you are granting access to
    your computer! You should engage in sessions only with people you trust, and likewise
    only send your session links to people you trust.
  prefs: []
  type: TYPE_NORMAL
- en: Once you click **Start Session**, PyCharm creates a hyperlink you can share
    as you see fit. You can email it, but I most often see it sent to other developers
    via Slack or similar private chat services. Anyone who has the link can click
    to join the session. In addition to sharing the IDE, you also have normal conferencing
    tools. Participants can see and hear each other like you’d expect on a product
    such as Zoom or WebEx. *Figure 15**.12* shows me conferencing with nobody, but
    it gives you an idea of what to expect.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.12: A Code With Me session in progress. Unfortunately, since I
    spend all my time writing books, I don’t have any friends to call, so it’s just
    me](img/B19644_15_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.12: A Code With Me session in progress. Unfortunately, since I spend
    all my time writing books, I don’t have any friends to call, so it’s just me'
  prefs: []
  type: TYPE_NORMAL
- en: This feature is useful in a lot of scenarios beyond the obvious pair programming
    use case. You can use this for each class, or conduct a coding interview using
    something more realistic than a Google Doc.
  prefs: []
  type: TYPE_NORMAL
- en: If you intend to use this service often, you will need a subscription since
    there are limitations on session length and the number of participants you can
    invite. You can find out more at [https://www.jetbrains.com/code-with-me/buy/#commercial](https://www.jetbrains.com/code-with-me/buy/#commercial).
  prefs: []
  type: TYPE_NORMAL
- en: Remote development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At my office I have a large, powerful, 60 lb full-tower HP workstation with
    dual Intel Xeon processors (a total of 48 cores), 128 GB of memory, a professional-grade
    NVidia GPU, and 24 GB GPU accelerator! It even has a **serially attached small
    computer system interface** (**SAS**) for running enterprise-grade storage! You
    really can’t get this kind of power in a laptop and there are days when I push
    it to its limits.
  prefs: []
  type: TYPE_NORMAL
- en: Our industry loves alphabet soup!
  prefs: []
  type: TYPE_NORMAL
- en: I’m just going to clear this up for all you engineering types who are trying
    to figure out how the **three letter acronym** (**TLA**) *SAS* stands for no fewer
    than six words. It’s because the acronym *SAS* contains one letter that itself
    stands for another acronym. It’s **Serially Attached SCSI** (**SAS**). **SCSI**
    stands for *small computer system interface*. SAS drives are spinning disks that
    are capable of higher rotational speeds than your standard **serial advanced technology
    attachment** (**SATA**) drives, but they are still nowhere near as fast as a **solid-state
    drive** (**SSD)** or **non-volatile memory express** (**NVME**) drives that feature
    **NOT-AND** or **NAND** memory. SAS drives are, however, designed to be used in
    **redundant arrays of inexpensive disks** (**RAID**), which makes them useful
    for inexpensively storing very large files in a fault-tolerant way.
  prefs: []
  type: TYPE_NORMAL
- en: All these acronyms and jargon are part of an industry-wide conspiracy designed
    to make your relatives, who have no idea what you do, both proud and uncomfortable
    at family gatherings and holidays.
  prefs: []
  type: TYPE_NORMAL
- en: But like probably every other developer out there, I’d also like to be able
    to work from home. Obviously, I’m not willing to lug my 60 lb workstation around
    with me. Even if I were, our security team isn’t going to like our source code
    leaving the building. True, I could use a remote technology such as VNC Viewer
    or Microsoft Remote Desktop, but those can be laggy and lack the creature comforts,
    such as support for four monitors, to which I have become accustomed.
  prefs: []
  type: TYPE_NORMAL
- en: I could also just work over SSH using **neovim**. But I think you and I, we’re
    past that, right? If you think that’s a good idea, skip back to [*Chapter 1*](B19644_01.xhtml#_idTextAnchor014)
    where I talked about it being a bad idea. So, what am I to do?
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, JetBrains has me covered. Using its remote plugins, which are pre-installed
    on PyCharm Professional, I can run my IDE on my PC at home, but operate on my
    workstation in my office. This is done using **secure shell** (**SSH**), which
    is an encrypted communications protocol typically used to administer Linux and
    Unix-based servers.
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, you can configure PyCharm to use a virtual environment (`venv`)
    that is installed and configured on your remote PC, along with the code on the
    remote hard drive. Everything runs on the remote except for the IDE itself. Your
    run configurations will execute your code on the remote. When you debug, the debugger
    is running on the remote rather than your local machine. It is fairly seamless,
    but there are a couple of downsides.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, you have to be somewhat knowledgeable about networking to configure
    a project to do this. You need to have the IP address of the remote, and you need
    to have valid access credentials that allow you access to the remote computer.
    In my case, I also need a **virtual private network** (**VPN**) client running
    in order to access the network in my office, and this is external to PyCharm.
    While a VPN isn’t technically a requirement, in most scenarios, it should be.
  prefs: []
  type: TYPE_NORMAL
- en: The second trade-off is performance. PyCharm isn’t exactly zippy on a good day.
    We have to wait for indexing to take place before we can use any of those amazing
    features we’ve been talking about throughout the book. It isn’t uncommon to get
    out-of-memory errors from PyCharm, which requires you to increase the amount of
    memory PyCharm is allowed to use. Updating or installing plugins requires you
    to restart the IDE, and even the initial loading screen hangs there longer than
    many of us would like. All in all, sometimes PyCharm can be a little clunky, but
    we put up with it because of the value it brings in easing our overall workflow.
  prefs: []
  type: TYPE_NORMAL
- en: I tend to think of PyCharm like a diesel truck. Such a truck isn’t going to
    win a quarter-mile sprint race against a Porsche or a Tesla Model 3\. Being from
    rural Oklahoma, I can tell you nobody owns sports cars where I’m from because
    our diesel trucks are more than transportation, they are part of our livelihood.
    I can’t use a Tesla to tow a load of cows to auction, nor can I use a Porsche
    to haul hay to the back 40 to feed the horses. Likewise, we use heavy IDEs because
    we are willing to trade the “zippiness” of a minimal editor such as VS Code for
    some pretty extreme value presented by PyCharm’s indexing. The ability to find
    usages, jump directly to function definitions, and have such a tightly integrated
    set of tools covering everything from editing to database management is worth
    a little lag.
  prefs: []
  type: TYPE_NORMAL
- en: With that said, that lag can become more evident when you are working on a remote
    project. You can expect your indexing times to be longer because the indexing
    is happening remotely and is then transmitted back to you. Network latency and
    VPNs will always make things slower, and that isn’t PyCharm’s fault. We put up
    with it because you get to work from home in your pajamas, with your music turned
    up, close to your own kitchen and snacks, and you can limit your interaction with
    other humans, which normally just slows people like us down. It’s worth it. Now
    that your expectations have been set, let’s look at how to make this work.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring remote development in PyCharm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In all my books and courses, I pride myself on keeping everything as realistic
    as possible. For example in [*Chapter 7*](B19644_07.xhtml#_idTextAnchor172), I
    had trouble with the PyCharm feature that is supposed to download Node.js for
    me automatically. I didn’t hide it, because that legitimately happened to me,
    which means it might also happen to you. There is value in learning to work around
    these kinds of issues.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you might have noticed this chapter’s screen captures look different
    that those in previous chapters. I am writing this chapter on a day when I am
    working at home, and I’m using a Windows 11 PC that has not been configured to
    work remotely before today. Since this is my home computer, the screenshots might
    look a little different than those from previous chapters, particularly with respect
    to dark mode. I turned dark mode off for most of the book because the light mode
    is easier to read in a printed book, and I’m saving my publisher money on ink.
    Not today though. Because I’m keeping it real.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing I’ll do is install and open PyCharm. Obviously, we’ve covered
    that already in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028), so there’s no
    need to do that again. The welcome screen provides the option for opening a remote
    project, as shown in *Figure 15**.13*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.13: The remote development options are clearly available on the
    right side of the welcome window](img/B19644_15_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.13: The remote development options are clearly available on the right
    side of the welcome window'
  prefs: []
  type: TYPE_NORMAL
- en: There are several options here including SSH, which is what I’ll be using. JetBrains
    Space is a separate product, and I don’t own it, so I can’t really cover it. **WSL**,
    or **Windows Subsystem for Linux**, is likely only going to show up if you’re
    using Windows. WSL allows you to run a Linux virtual machine directly in Windows
    without using an obvious hypervisor such as VMware or Virtual Box. I say *obvious*,
    because of course there is a hypervisor at play here – it is Microsoft’s **HyperV**,
    which is built in to the professional editions of Windows 11 and Windows Server
    products. Windows 11 makes it seamless by allowing you to select one or more Linux
    installations via the Windows Terminal program that is new in Windows 11.
  prefs: []
  type: TYPE_NORMAL
- en: Since WSL is technically a virtual machine, it counts as remote development
    even though it happens on your local computer. For now, I’m going to focus on
    real remote development by accessing my workstation, currently about 12 miles
    away, over SSH. To be clear, my local computer is running Windows 11, but my workstation
    is running **Pop_OS! 22**, which is a variant of Ubuntu Linux. You’ve seen it
    in the screenshots throughout the book. This adds to the magic! I can use a consumer-grade
    OS such as Windows or macOS to connect to a professional-grade Linux workhorse.
  prefs: []
  type: TYPE_NORMAL
- en: Before you jump on Twitter (now called X) to flame me for disrespecting your
    favorite OS, realize that this is the only possible combination. You have to connect
    to a Linux remote as Windows and Macs are not yet supported. I’m not sure what
    the hold-up is on macOS since it comes with an SSH server preinstalled. This workflow
    would make sense for a use case where you have a Mac Pro at work and something
    else at home. The setup screens that follow do indicate this functionality is
    intended for future releases.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15**.14* starts us off by showing what happens when we click the SSH
    option shown in *Figure 15**.13*. We are given a screen that allows us to create
    a new project on our remote, but only after we first configure our connection.
    This is going to be like creating an SSH connection for publishing our web projects,
    which we covered in [*Chapter 7*](B19644_07.xhtml#_idTextAnchor172).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.14: The remote configuration dialog could only be improved by stacking
    another configuration dialog on top of it](img/B19644_15_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.14: The remote configuration dialog could only be improved by stacking
    another configuration dialog on top of it'
  prefs: []
  type: TYPE_NORMAL
- en: Before you can do anything, you need to configure an SSH connection by clicking
    the gear icon indicated by the arrow in *Figure 15**.14*. This brings us to yet
    another dialog, shown in *Figure 15**.5*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 15.15: Here\uFEFF, I am creating an SSH configuration to be used in\
    \ my remote setup](img/B19644_15_015.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.15: Here, I am creating an SSH configuration to be used in my remote
    setup'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve gone ahead and clicked the `22`, so I’ve left the default set (**6**).
  prefs: []
  type: TYPE_NORMAL
- en: If you go back to the first position (**1**), you can click that pencil icon
    and give it a different name if you don’t like the aesthetics of a username and
    an IP. I’m renaming mine in *Figure 15**.16* to something a little more appropriate
    given its hardware specifications.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.16: The Beast is the name for my remote workstation](img/B19644_15_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.16: The Beast is the name for my remote workstation'
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the options aren’t important to me because I don’t have to go through
    a proxy to get to my workstation. I went ahead and expanded all the closed options
    in *Figure 15**.15* so you can see any additional settings you might need.
  prefs: []
  type: TYPE_NORMAL
- en: Click **OK**, which takes you back to the earlier dialog. You’ll need to select
    the connection you just created from the dropdown. For me, the re-naming didn’t
    stick so it’s back to the username and IP as shown in *Figure 15**.17*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.17: Having created a connection, you need to select it here and
    the username and host fields will be filled in for you](img/B19644_15_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.17: Having created a connection, you need to select it here and the
    username and host fields will be filled in for you'
  prefs: []
  type: TYPE_NORMAL
- en: Note that you have the option here to go passwordless and use a private key.
    Using the SSH keys potentially limits the need for a password, but you can still
    be challenged to unlock the key. In either case, PyCharm can remember your password
    or your SSH key phrase for you if you’d like. If you work for a security-conscious
    company, you might check your guidelines to understand where it is considered
    appropriate for an application to store your passwords and key phrases.
  prefs: []
  type: TYPE_NORMAL
- en: Click the button labeled **Check Connection and Continue**. Assuming you gain
    access, PyCharm copies some software and settings over to the host and then presents
    you with our original dialog box, as shown in *Figure 15**.18*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.18: We now have a connected system with three options!](img/B19644_15_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.18: We now have a connected system with three options!'
  prefs: []
  type: TYPE_NORMAL
- en: From here, we have three options. You can connect to the host with a terminal
    session by clicking it icon shown at (**1**). Clicking the **+** icon at (**2**)
    allows you to create or open a project on the remote. The gear (**2**) allows
    you to either remove the host or manage the backends on the host. This latter
    option is explained by my earlier remark. When we connected for the first time,
    I told you that PyCharm copied some software to the host. The software in question
    is a lot like our toolbox application. It’s going to help us manage the IDE backends
    we’ll upload as part of our project creation process. There are several other
    IDEs you can use in this way and you have the ability to manage these backends
    here. If you click it right now, there won’t be any, because we haven’t created
    any projects yet. Let’s rectify that.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a remote project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Click the **+** button indicated at position (**2**) in *Figure 15**.18*. You’ll
    be rewarded with the screen shown in *Figure 15**.19*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.19: We’re about to create a new remote project, which requires
    downloading the IDE backend and selecting a project folder on the remote](img/B19644_15_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.19: We’re about to create a new remote project, which requires downloading
    the IDE backend and selecting a project folder on the remote'
  prefs: []
  type: TYPE_NORMAL
- en: Remote project creation requires you to specify which IDE you want to use and
    where you’d like to store your code on the remote hard drive. Given we’re invoking
    PyCharm to create the project, it might seem odd that it is asking us to choose
    which IDE we need. Remember, though, this isn’t really PyCharm. It is a plugin
    that can be leveraged by many of the JetBrains IDEs. Right now, you are really
    interacting with a different piece of software that just happens to be hosted
    in PyCharm.
  prefs: []
  type: TYPE_NORMAL
- en: We do get PyCharm as the default, so that’s something. Pay attention to the
    version. Mine is defaulting to the EAP version, which might not be what you want.
    Personally, I don’t use EAP unless I’m just testing them for backward project
    compatibility. I use the stable release in my day-to-day work. Pick the appropriate
    entry from the dropdown as shown in *Figure 15**.20*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.20: Select the IDE you want to use on the remote](img/B19644_15_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.20: Select the IDE you want to use on the remote'
  prefs: []
  type: TYPE_NORMAL
- en: The other, perhaps obvious consideration is you will need to have a license
    for whichever IDE you choose. Next, we need to pick a location. This can be confusing
    since the layout of a Linux filesystem is different than what you encounter in
    Windows. Linux doesn’t use drive letters, and it uses forward slashes to separate
    path elements while Windows uses backslashes. Thankfully, I can just browse by
    clicking the three dots next to the project directory setting. Check out *Figure
    15**.21*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.21: Click the three dots to browse the filesystem on the remote
    to pick your project directory](img/B19644_15_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.21: Click the three dots to browse the filesystem on the remote to
    pick your project directory'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the directory browser will display your home folder on the remote.
    You can browse to the folder of your choosing. Unfortunately at the moment, one
    big missing feature is an option to create a new folder for your project. I’m
    sure that’s coming, but right now it is absent. We’re going to have to work around
    this. Click **Cancel**, then **Back** to navigate back to the screen shown in
    *Figure 15**.5*. Click the terminal button to launch an SSH terminal session on
    the host, as shown in *Figure 15**.22*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.22: Use a terminal session to create your folder](img/B19644_15_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.22: Use a terminal session to create your folder'
  prefs: []
  type: TYPE_NORMAL
- en: Use the commands shown to create a new folder. I already had a `PyCharmProjects`
    folder on the remote in my home folder. This is because PyCharm is actually installed
    on the remote since it’s my daily-use computer. You can make any folder that suits
    you within your home folder on the remote. You can exit the terminal session by
    typing `exit`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try that again
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like before, click the **+** icon, pick your IDE from the dropdown, and browse
    to the folder you just created.
  prefs: []
  type: TYPE_NORMAL
- en: Just think of this as being PyCharm without the UI. We’re connecting the frontend
    on our computer with the uploaded PyCharm backend on the remote.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s bring our focus back to working on a project on the remote. Click the
    **Download IDE and Connect** button shown in *Figure 15**.23*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.23: Click the button to create the project on the remote](img/B19644_15_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.23: Click the button to create the project on the remote'
  prefs: []
  type: TYPE_NORMAL
- en: This next part takes a few minutes. After you click the **Download IDE and Connect**
    button, a delightful orchestration of commands runs on your remote. The result
    is a running IDE backend, as shown in *Figure 15**.24*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.24: You now have an IDE backend server running on the remote](img/B19644_15_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.24: You now have an IDE backend server running on the remote'
  prefs: []
  type: TYPE_NORMAL
- en: Click the link shown back in *Figure 15**.11* to connect to your remote IDE.
    You will likely see password challenges, and maybe a note from Windows asking
    whether it’s OK to let the traffic through the firewall, but eventually, you’ll
    be live on the remote like I am in *Figure 15**.25*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.25: Magical! It looks the same as working locally!](img/B19644_15_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.25: Magical! It looks the same as working locally!'
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, you mostly know what to do. Your IDE will function normally except
    for one step that was skipped: you were never prompted to create a virtual environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a virtual environment on the remote
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve done this before, in [*Chapter 3*](B19644_03.xhtml#_idTextAnchor052),
    so I won’t do another deep dive here, but there is one point that is confusing.
    Let’s look at it.
  prefs: []
  type: TYPE_NORMAL
- en: To create a virtual environment you need to go to the project settings and locate
    the setting for the project’s interpreter. Mine is shown in *Figure 15**.26*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.26: When you add the interpreter, remember that while it is remote,
    it is treated as local](img/B19644_15_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.26: When you add the interpreter, remember that while it is remote,
    it is treated as local'
  prefs: []
  type: TYPE_NORMAL
- en: The interpreter has defaulted to `/usr/bin/python3.9`, which is the global instance
    and not what I want. When I click the **Add Interpreter** button it gets a little
    confusing. You might be tempted to use **On SSH** because, well, we’re using SSH
    to connect to the remote. However, we are connected to the remote already, so
    PyCharm is running on the remote, which makes it a local interpreter. When you
    click **Add Local Interpreter**, you’ll note like in *Figure 15**.14*, the path
    is Linux-like rather than a Windows path. This would be less obvious to macOS
    users since the pathing looks the same.
  prefs: []
  type: TYPE_NORMAL
- en: Other considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have this setup, you are effectively running PyCharm on the remote
    computer. All your file paths will show as Linux paths. Git and other revision
    control clients work with the remote folder. If you use SSH keys to authenticate
    with GitHub or your revision control host, you will need to configure the keys
    from the remote rather than just using your local public keys. Essentially, forget
    about your local computer entirely. You are operating completely on the remote.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.27: Even though we picked the local option, everything happens
    on the remote](img/B19644_15_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.27: Even though we picked the local option, everything happens on
    the remote'
  prefs: []
  type: TYPE_NORMAL
- en: Click `venv` has been created for the project. You are now ready to start working
    on your project!
  prefs: []
  type: TYPE_NORMAL
- en: Working with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Container technology is one of the most important advances in DevOps technology
    since the virtual machine. **Docker** and similar container technologies have
    revolutionized the way software applications are developed, deployed, and managed.
    Imagine containers as lightweight, standalone units that encapsulate all the necessary
    components to run an application, including code, runtime, system libraries, and
    settings. This encapsulation ensures that the application runs consistently across
    different environments, from a developer’s laptop to production servers.
  prefs: []
  type: TYPE_NORMAL
- en: Docker, in particular, is a widely used platform for building, shipping, and
    running containers. It provides a standardized way to package applications and
    their dependencies, isolating them from the underlying host system. This isolation
    enables developers to avoid the notorious “*it works on my machine*” issue, as
    containers behave consistently across various environments.
  prefs: []
  type: TYPE_NORMAL
- en: Another major advantage of containers is their portability. Developers can package
    an application and all its dependencies into a container image, which can then
    easily be shared with others. This makes collaboration more efficient and reduces
    the chances of compatibility issues. Furthermore, containers are highly scalable.
    They can be quickly replicated to handle increased workloads, offering an excellent
    solution for modern, dynamic, and resource-demanding applications.
  prefs: []
  type: TYPE_NORMAL
- en: Docker also brings about improved resource utilization. Since containers share
    the host operating system’s kernel, they are more lightweight than traditional
    virtual machines, which require separate operating systems. This translates to
    faster startup times, lower memory overhead, and a higher density of containerized
    applications on a single host.
  prefs: []
  type: TYPE_NORMAL
- en: The bundled Docker plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PyCharm Professional comes with the JetBrains Docker plugin already bundled
    and enabled. You don’t have to do anything further to use the Docker plugin. You
    do, however, need to install Docker. On my development computers, I usually run
    Docker Desktop because I find the product’s GUI useful. It will be useful today
    as I show you how much you can do in PyCharm with Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a Flask project and run it in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Create the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In PyCharm Professional, create a new Flask project. If you’re skipping around,
    I showed you how to do this in [*Chapter 8*](B19644_08.xhtml#_idTextAnchor203).
    You can see my project settings in *Figure 15**.28*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.28: Create a Flask project so we can run it in Docker](img/B19644_15_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.28: Create a Flask project so we can run it in Docker'
  prefs: []
  type: TYPE_NORMAL
- en: We won’t be making any changes to the generated project except for adding a
    **Dockerfile**. *Figure 15**.29* shows me doing this.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.29: Right-click the project and click New | Dockerfile](img/B19644_15_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.29: Right-click the project and click New | Dockerfile'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding figure, I’m right-clicking the project, hovering over **New**,
    and clicking the **Dockerfile** menu option. This generates a Dockerfile template
    for me with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first line indicates which Linux kernel will serve as the basis for our
    container image. I’m a pretty big fan of Ubuntu, but there are other possibilities.
    Alpine Linux is also very popular.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second line is just what it says: a label for the image containing the
    author’s names. We don’t really need this, nor do we need the last line, at least
    in its current form. Let’s replace the generated template with something more
    useful. The corporation behind Docker maintains a large registry of pre-made containers
    you can use as a starting point for your work. Among them is a container with
    any given version of Python 3 already installed. I’m going to use Python 3.9,
    even though that isn’t the most current, because I happened to notice 3.9 is the
    version on my PC when I generated the sample project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'On the next line, I’ll set the working directory inside the container. The
    container has a minimal file system with limited space. This is where our app
    code will live:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, I need to instruct Docker to copy my requirements text file and use `pip`
    to install my project’s requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, I’ll copy my code to the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `COPY` instruction will copy the entire contents of my project folder,
    which would include the `venv` folder. Since the `pip` command will install our
    requirements, we don’t need a `venv` folder. I’ll fix this in just a moment. My
    next step in this file is to expose port `5000` on the container’s firewall so
    I can access the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, I’ll define the command to run the Flask app when the container starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To fix the copy problem, I’ll make a file in the project folder called `.dockerignore`.
    This works the same way a `.gitignore` works, except obviously it is used to set
    file exclusions for Docker. The contents of the `.dockerignore` file are simply
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Incidentally, you can find a plugin in Marketplace called `.ignore` that adds
    formatting to an array of ignore files.
  prefs: []
  type: TYPE_NORMAL
- en: Add a Docker run configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We covered creating and using run configurations in [*Chapter 3*](B19644_03.xhtml#_idTextAnchor052),
    so we won’t cover it again here. I’ll merely point out the option for creating
    a run configuration using Docker as seen in *Figure 15**.30*.
  prefs: []
  type: TYPE_NORMAL
- en: x
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.30: Use the Dockerfile option to create a run configuration that
    uses Docker](img/B19644_15_030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.30: Use the Dockerfile option to create a run configuration that
    uses Docker'
  prefs: []
  type: TYPE_NORMAL
- en: Much of your run configuration will be filled in for you. PyCharm will see your
    Dockerfile and use that as the default. My settings are shown in *Figure 15**.31*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.31: My Docker configuration](img/B19644_15_031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.31: My Docker configuration'
  prefs: []
  type: TYPE_NORMAL
- en: If we were to run this, Docker would pull the Python 3.9 image, make a container,
    and run the app. If we actually want to use the app, there’s one more thing we
    need to do. The arrow in *Figure 15**.31* points to a menu that allows you to
    tailor your `docker run` command. There are normally things you’ll want to do
    here depending on your app, such as mapping persistent storage volumes, or in
    our case mapping the port in the container to the port on our local computer.
  prefs: []
  type: TYPE_NORMAL
- en: Click **Modify** | **Bind** **ports**, as shown in *Figure 15**.32*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.32: You have to add a bind port for the Docker container in order
    to see the application running from your browser](img/B19644_15_032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.32: You have to add a bind port for the Docker container in order
    to see the application running from your browser'
  prefs: []
  type: TYPE_NORMAL
- en: Once you click the **Bind ports** option, PyCharm adds a configuration parameter
    for **Bind ports**. Oddly, there is a folder icon indicated by the right arrow
    in *Figure 15**.33*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.33: Click the folder to bring up the Port Bindings dialog and set
    the port mapping](img/B19644_15_033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.33: Click the folder to bring up the Port Bindings dialog and set
    the port mapping'
  prefs: []
  type: TYPE_NORMAL
- en: It’s odd because we won’t be browsing for a file or folder. When you click it,
    you get a `5000`, so all you need to do is specify a binding between `5000` on
    the container and `5000` on your computer. Click **OK** until you’re out of the
    run configuration. Run the run configuration. We explained run configurations
    way back in [*Chapter 3*](B19644_03.xhtml#_idTextAnchor052), so if you’re joining
    us late, go back and review.
  prefs: []
  type: TYPE_NORMAL
- en: You should be treated to a textual light-show as Docker downloads the chunks
    to the container image, builds the container, and finally runs the app. You can
    see mine running in *Figure 15**.34*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.34: My Flask app is running in a Docker container](img/B19644_15_034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.34: My Flask app is running in a Docker container'
  prefs: []
  type: TYPE_NORMAL
- en: If you care to compare the UI for Docker versus Docker Desktop, you’ll see many
    of the same features exist. A quick tour is shown in *Figure 15**.35*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.35: PyCharm has many of the features you’d expect from a competent
    Docker UI](img/B19644_15_035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.35: PyCharm has many of the features you’d expect from a competent
    Docker UI'
  prefs: []
  type: TYPE_NORMAL
- en: At position (**1**) we can see three tabs. **Build Log** allows us to examine
    the output generated when Docker built the container from our Dockerfile. We have
    some basic controls to stop and restart the container at (**2**). Naturally, when
    the container is stopped, the option to start it will appear here as well. Then
    perhaps most usefully, you can use the **Terminal** button (**3**) to start a
    terminal session inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: On the left side (**4**) we see a full display showing all our running containers,
    downloaded images, networks, and mounted volumes.
  prefs: []
  type: TYPE_NORMAL
- en: In sum, you can really do almost anything in PyCharm that you can do in Docker
    Desktop. Once again, PyCharm’s mission to give you an integrated experience with
    one of the most important technologies in use today is fully realized!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PyCharm plugins are customized add-ons that can further add to the list of features
    and functionalities one can take advantage of while using PyCharm. We have seen
    how to browse through, download, and manage different plugins in the PyCharm environment.
    By taking advantage of these plugins, we can further customize our workspace and
    improve our own productivity. Plugin management in PyCharm can be done in the
    **Plugins** tab in the settings.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at some simple plugins to enhance your quality of life while coding,
    such as theme plugins and some useful file handlers. We looked at one of my favorites,
    GitToolbox, which allows you to see a lot more details from your Git repository
    right in your IDE window.
  prefs: []
  type: TYPE_NORMAL
- en: We then branched out and looked at some very big-feature plugins that are fairly
    new to PyCharm 2023\. Remote development is very useful in a post-pandemic world
    where more and more of us find ourselves working remotely. Even if you’re not,
    chances are you’re finding yourself working increasingly with cloud servers and
    virtual machines rather than always using the hard drive on your local laptop.
  prefs: []
  type: TYPE_NORMAL
- en: Another big advance is PyCharm’s support for Docker. The bundled Docker plugin
    provides full integration, from giving you autocomplete and syntax highlighting
    in Dockerfiles and composer files to a full GUI for managing your containers.
    You’ll find yourself never needing to leave PyCharm to jump over to Docker Desktop
    to handle your Docker operations. Naturally, if you’d like to, you’ll find both
    environments fully synchronized, and you could also use the **Terminal** window
    in PyCharm to interact with your containers that way if that is your preference.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins are responsible for adding a lot of very cool and very useful features
    to our IDE. There are a few plugins that I didn’t cover because, to be honest,
    they’re not quite ready yet. I have some access to some closed beta features and
    some buried gems I want to cover in the next chapter. I can’t wait to show you
    some of the things that are coming up in future releases!
  prefs: []
  type: TYPE_NORMAL
