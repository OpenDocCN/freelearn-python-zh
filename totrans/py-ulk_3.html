<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Functions and Utilities"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Functions and Utilities</h1></div></div></div><p>After learning about how objects are linked to one another, let's take a look at the functions that are the means to execute code in language. We will discuss how to define and call functions with various combinations. Then, we will cover some very useful utilities that are available to us to use in day-to-day programming. We will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Defining functions</li><li class="listitem" style="list-style-type: disc">Decorating callables</li><li class="listitem" style="list-style-type: disc">Utilities</li></ul></div><div class="section" title="Defining functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Defining functions</h1></div></div></div><p>
<span class="strong"><strong>Key 1: How to define functions.</strong></span>
</p><p>Functions are <a id="id70" class="indexterm"/>used to group a set of instructions and logic that performs a specific task. So, we should make functions perform one specific task and choose a name that gives us a hint about that. If a function is important and performs complex stuff, we should always add docstrings to this function so that it is easy for us to later visit and modify this function.</p><p>While defining a function, we can define the following:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Positional arguments (simply pass the object according to position), which are as follows:<div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; def foo(a,b):
...   print(a,b)
... 
&gt;&gt;&gt; foo(1,2)
1 2</pre></div></li><li class="listitem">Default arguments (if value is not passed, the default is used), which are as follows:<div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; def foo(a,b=3):
...    print(a,b)
... 
&gt;&gt;&gt; foo(3)  
3 3
&gt;&gt;&gt; foo(3,4)
3 4</pre></div></li><li class="listitem">Keyword only <a id="id71" class="indexterm"/>arguments (must be passed as a positional or as a keyword argument), which are as follows:<div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; def  foo(a,*,b):
...   print(a,b)
... 
&gt;&gt;&gt; foo(2,3)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: foo() takes 1 positional argument but 2 were given
&gt;&gt;&gt; foo(1,b=4)
1 4</pre></div></li><li class="listitem">An argument list, which is as follows:<div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; def foo(a,*pa):
...   print(a,pa)
... 
&gt;&gt;&gt; foo(1)
1 ()
&gt;&gt;&gt; foo(1,2)
1 (2,)
&gt;&gt;&gt; foo(1,2,3)
1 (2, 3)</pre></div></li><li class="listitem">A keyword argument dictionary, which is as follows:<div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; def foo(a,**kw):
...   print(a,kw)
... 
&gt;&gt;&gt; foo(2)     
2 {}
&gt;&gt;&gt; foo(2,b=4)
2 {'b': 4}
&gt;&gt;&gt; foo(2,b=4,v=5)
2 {'b': 4, 'v': 5}</pre></div><p>When a function is called, this is how arguments are passed on:</p></li><li class="listitem">All positional arguments that are passed are consumed.</li><li class="listitem">If the function takes an argument list and there are more passed positional arguments after the first step, then the rest of the arguments are collected in an argument list:<div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; def foo1(a,*args):
...   print(a,args)
... 
&gt;&gt;&gt; def foo2(a,):
...   print(a)
... 
&gt;&gt;&gt; foo1(1,2,3,4)
1 (2, 3, 4)
&gt;&gt;&gt; foo2(1,2,3,4)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: foo2() takes 1 positional argument but 4 were given</pre></div></li><li class="listitem">If passed position <a id="id72" class="indexterm"/>arguments are less than the defined positional arguments, then the passed keyword arguments are used for values for positional arguments. If no keyword argument is found for the positional argument, we get an error:<div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; def foo(a,b,c):
...   print(a,b,c)
... 
&gt;&gt;&gt; foo(1,c=3,b=2)
1 2 3
&gt;&gt;&gt; foo(1,b=2)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: foo() missing 1 required positional argument: 'c'</pre></div></li><li class="listitem">Passed keyword variables are used only for keyword arguments:<div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; def foo(a,b,*,c):           
...   print(a,b,c)
... 
&gt;&gt;&gt; foo(1,2,3)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: foo() takes 2 positional arguments but 3 were given
&gt;&gt;&gt; foo(1,2,c=3)
1 2 3
&gt;&gt;&gt; foo(c=3,b=2,a=1)
1 2 3</pre></div></li><li class="listitem">If more keywords remain and the called function takes a keyword argument list, then the rest of the keyword arguments are passed as a keyword argument list. If the keyword argument list is not taken by the function, we get an error:<div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; def foo(a,b,*args,c,**kwargs):
...   print(a,b,args,c,kwargs)
... 
&gt;&gt;&gt; foo(1,2,3,4,5,c=6,d=7,e=8)        
1 2 (3, 4, 5) 6 {'d': 7, 'e': 8}</pre></div><p>Here is an<a id="id73" class="indexterm"/> example function that uses all of the preceding combinations:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; def foo(a,b,c=2,*pa,d,e=5,**ka):
...   print(a,b,c,d,e,pa,ka)
... 
&gt;&gt;&gt; foo(1,2,d=4)
1 2 2 4 5 () {}
&gt;&gt;&gt; foo(1,2,3,4,5,d=6,e=7,g=10,h=11)
1 2 3 6 7 (4, 5) {'h': 11, 'g': 10}</pre></div></li></ol></div></div></div>
<div class="section" title="Decorating callables"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Decorating callables</h1></div></div></div><p>
<span class="strong"><strong>Key 2: Changing the behavior of callables.</strong></span>
</p><p>Decorators<a id="id74" class="indexterm"/> are callable objects, which replace the original callable objects with some other objects. In this <a id="id75" class="indexterm"/>case, as we are replacing a callable with another object, what we mostly want mostly is the replaced object to be callable.</p><p>Language provides syntax to do so easily, but first, let's take a look at how we can manually do this:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; def wrap(func):
...     def newfunc(*args):
...         print("newfunc",args)
...     return newfunc
...
&gt;&gt;&gt; def realfunc(*args):
...     print("real func",args)
...
&gt;&gt;&gt;
&gt;&gt;&gt; realfunc = wrap(realfunc)
&gt;&gt;&gt;
&gt;&gt;&gt; realfunc(1,2,4)
('newfunc', (1, 2, 4))</pre></div><p>With the decorator syntax, it becomes easy. Taking the definition of wrap and <code class="literal">newfunc</code> from the preceding code snippet, we get this:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; @wrap
... def realfunc(args):
...     print("real func",args)
...
&gt;&gt;&gt; realfunc(1,2,4)
('newfunc', (1, 2, 4))</pre></div><p>To store some kind<a id="id76" class="indexterm"/> of state in the decorator function, say to make decorator more useful and applicable to wider application code base, we can use closures or class instances as decorators. In the second chapter, we saw that closures can be used to store state; let's look at how we can utilize them to store information in decorators. In this snippet, the <code class="literal">deco</code> function is the new function that will replace the add function. A prefix variable is available in the closure of this function. This variable can be injected at decorator creation time:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; def closure_deco(prefix):
...     def deco(func):
...         return lambda x:x+prefix
...     return deco
... 
&gt;&gt;&gt; @closure_deco(2)
... def add(a):
...     return a+1
... 
&gt;&gt;&gt; add(2)
4
&gt;&gt;&gt; add(3)
5
&gt;&gt;&gt; @closure_deco(3)
... def add(a):
...     return a+1
... 
&gt;&gt;&gt; add(2)
5
&gt;&gt;&gt; add(3)
6</pre></div><p>We could have used a class to do the same thing as well. Here, we save state on an instance of class:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; class Deco:
...     def __init__(self,addval):
...         self.addval = addval
...     def __call__(self, func):
...         return lambda x:x+self.addval
... 
&gt;&gt;&gt; @Deco(2)
... def add(a):
...     return a+1
... 
&gt;&gt;&gt; add(1)
3
&gt;&gt;&gt; add(2)
4
&gt;&gt;&gt; @Deco(3)
... def add(a):
...     return a+1
... 
&gt;&gt;&gt; add(1)
4
&gt;&gt;&gt; add(2)
5</pre></div><p>As decorator works <a id="id77" class="indexterm"/>on any callable, it works similarly on methods and class definitions as well, but when doing so, we should take into consideration the different arguments that are implicitly passed for the method that is being decorated. Let's first take a simple method being decorated like this:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; class K:
...     def do(*args):
...         print("imethod",args)
...
&gt;&gt;&gt; k = K()
&gt;&gt;&gt; k.do(1,2,3)
('imethod', (&lt;__main__.K instance at 0x7f12ea070bd8&gt;, 1, 2, 3))
&gt;&gt;&gt;
&gt;&gt;&gt; # using a decorator on methods give similar results
...
&gt;&gt;&gt; class K:
...     @wrap
...     def do(*args):
...         print("imethod",args)
...
&gt;&gt;&gt; k = K()
&gt;&gt;&gt; k.do(1,2,3)
('newfunc', (&lt;__main__.K instance at 0x7f12ea070b48&gt;, 1, 2, 3))</pre></div><p>As the function that is replaced becomes the method of the class itself, this works perfectly. This is not true for static and class methods. They employ descriptors to call methods, hence, their behavior breaks with decorators and the returned function behaves like a simple method. We can make this work by first checking whether the overridden function is a <a id="id78" class="indexterm"/>descriptor and if yes, then calling its <code class="literal">__get__</code> method instead:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; class K:
...     @wrap
...     @staticmethod
...     def do(*args):
...         print("imethod",args)
...     @wrap
...     @classmethod
...     def do2(*args):
...         print("imethod",args)
...
&gt;&gt;&gt; k = K()
&gt;&gt;&gt; k.do(1,2,3)
('newfunc', (&lt;__main__.K instance at 0x7f12ea070cb0&gt;, 1, 2, 3))
&gt;&gt;&gt; k.do2(1,2,3)
('newfunc', (&lt;__main__.K instance at 0x7f12ea070cb0&gt;, 1, 2, 3))</pre></div><p>We can also make this work easily using static and class methods decorators on top of any other decorator. This makes the actual method that is found by the attribute look up as a descriptor and normal execution happens for <code class="literal">staticmethod</code> and <code class="literal">classmethod</code>.</p><p>This works fine, as follows:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; class K:
...     @staticmethod
...     @wrap
...     def do(*args):
...         print("imethod",args)
...     @classmethod
...     @wrap
...     def do2(*args):
...         print("imethod",args)
...
&gt;&gt;&gt; k = K()
&gt;&gt;&gt; k.do(1,2,3)
('newfunc', (1, 2, 3))
&gt;&gt;&gt; k.do2(1,2,3)
('newfunc', (&lt;class __main__.K at 0x7f12ea05e1f0&gt;, 1, 2, 3))</pre></div><p>We can use decorators for classes as class is just a type of callable. Hence, we can use decorators to alter the instance creation process so that when we call class, we get an instance. A class object will be passed to decorator and then decorator can replace it with another callable <a id="id79" class="indexterm"/>or class. Here, the <code class="literal">cdeco</code> decorator is passing a new class that replaced <code class="literal">cls</code>:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; def cdeco(cls):
...     print("cdecorator working")
...     class NCls:
...         def do(*args):
...             print("Ncls do",args)
...     return NCls
...
&gt;&gt;&gt; @cdeco
... class Cls:
...     def do(*args):
...         print("Cls do",args)
...
cdecorator working
&gt;&gt;&gt; b = Cls()
&gt;&gt;&gt; c = Cls()
&gt;&gt;&gt; c.do(1,2,3)
('Ncls do', (&lt;__main__.NCls instance at 0x7f12ea070cf8&gt;, 1, 2, 3))</pre></div><p>Normally, we use this to change the attributes, and add new attributes to the class definition. We can also use this to register the class to some registry, and so on. In the following code snippet, we check whether class has a do method. If we find one, we replace it with <code class="literal">newfunc</code>:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; def cdeco(cls):
...     if hasattr(cls,'do'):
...         cls.do = wrap(cls.do)
...     return cls
...
&gt;&gt;&gt; @cdeco
... class Cls:
...     def do(*args):
...         print("Cls do",args)
...
&gt;&gt;&gt; c = Cls()
&gt;&gt;&gt; c.do(1,2,3)
('newfunc', (&lt;__main__.Cls instance at 0x7f12ea070cb0&gt;, 1, 2, 3))</pre></div></div>
<div class="section" title="Utilities"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Utilities</h1></div></div></div><p>
<span class="strong"><strong>Key 3: Easy iterations by comprehensions.</strong></span>
</p><p>We have various syntax and utilities to iterate efficiently over iterators. Comprehensions <a id="id80" class="indexterm"/>work on<a id="id81" class="indexterm"/> iterator and provide results as another iterator. They are implemented in native C, and hence, they are faster than for loops.</p><p>We have list, dictionary, and set comprehensions, which produce list, dictionary, and set as result, respectively. Also, iterators avoid declaring extra variables that we need in a loop:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; ll = [ i+1 for i in range(10)]
&gt;&gt;&gt; print(type(ll),ll)
&lt;class 'list'&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
&gt;&gt;&gt; ld = { i:'val'+str(i) for i in range(10) }
&gt;&gt;&gt; print(type(ld),ld)
&lt;class 'dict'&gt; {0: 'val0', 1: 'val1', 2: 'val2', 3: 'val3', 4: 'val4', 5: 'val5', 6: 'val6', 7: 'val7', 8: 'val8', 9: 'val9'}
&gt;&gt;&gt; ls = {i for i in range(10)}
&gt;&gt;&gt; print(type(ls),ls)
&lt;class 'set'&gt; {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}</pre></div><p>Generator expression creates generators, which can be used to produce generators for an iteration like this. To materialize a generator, we use it to create <code class="literal">set</code>, <code class="literal">dict</code>, or <code class="literal">list</code>:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; list(( i for i in range(10)))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; dict(( (i,'val'+str(i)) for i in range(10)))
{0: 'val0', 1: 'val1', 2: 'val2', 3: 'val3', 4: 'val4', 5: 'val5', 6: 'val6', 7: 'val7', 8: 'val8', 9: 'val9'}
&gt;&gt;&gt; set(( i for i in range(10)))
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}</pre></div><p>Generator objects do not compute all the values of the iterable at once but one by one when requested by a loop. This conserves memory, and we may not be interested in using the whole iterable. Generators are not silver bullets to be used everywhere. They do not always result in a performance increase. It depends on the consumer, and the cost of generating one sequence:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; def func(val):
...     for i in (j for j in range(1000)):
...         k = i + 5
... 
&gt;&gt;&gt; def func_iter(val):
...     for i in [ j for j in range(1000)]:
...         k = i + 5
... 
&gt;&gt;&gt; timeit.timeit(stmt="func(1000)", globals={'func':func_iter},number=10000)
0.6765081569974427
&gt;&gt;&gt; timeit.timeit(stmt="func(1000)", globals={'func':func},number=10000)
0.838760247999744</pre></div><p>
<span class="strong"><strong>Key 4: Some helpful utilities.</strong></span>
</p><p>The <code class="literal">itertools</code> utility is a <a id="id82" class="indexterm"/>good module with many helpful functions for iterations. Some <a id="id83" class="indexterm"/>of my<a id="id84" class="indexterm"/> favorites are the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>itertools.chain(* iterable)</strong></span>: This returns a single iterable from a list of iterables. First, all the <a id="id85" class="indexterm"/>elements of the first iterable are exhausted, and then of the second, and so on until all iterables are exhausted:<div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; list(itertools.chain(range(3),range(2),range(4)))
[0, 1, 2, 0, 1, 0, 1, 2, 3]
&gt;&gt;&gt; </pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>itertools.cycle</strong></span>: This <a id="id86" class="indexterm"/>creates a copy of the iterator and continues to replay the results infinitely:<div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; cc = cycle(range(4))
&gt;&gt;&gt; cc.__next__()
0
&gt;&gt;&gt; cc.__next__()
1
&gt;&gt;&gt; cc.__next__()
2
&gt;&gt;&gt; cc.__next__()
3
&gt;&gt;&gt; cc.__next__()
0
&gt;&gt;&gt; cc.__next__()
1
&gt;&gt;&gt; cc.__next__()</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>itertools.tee(iterable,number)</strong></span>: This<a id="id87" class="indexterm"/> returns <code class="literal">n</code> independent iterables from a single iterable:<div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; i,j = tee(range(10),2)
&gt;&gt;&gt; i
&lt;itertools._tee object at 0x7ff38e2b2ec8&gt;
&gt;&gt;&gt; i.__next__()
0
&gt;&gt;&gt; i.__next__()
1
&gt;&gt;&gt; i.__next__()
2
&gt;&gt;&gt; j.__next__()
0</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>functools.lru_cache</strong></span>: This decorator uses memorizing. It saves the results that are <a id="id88" class="indexterm"/>mapped to arguments. Hence, it is very useful to speed up functions that take a similar argument, and whose results are not dependent on time or state:<div class="informalexample"><pre class="programlisting">In [7]: @lru_cache(maxsize=None)
def fib(n):
    if n&lt;2:
        return n
    return fib(n-1) + fib(n-2)
   ...: 

In [8]: %timeit fib(30)
10000000 loops, best of 3: 105 ns per loop

In [9]:                         
def fib(n):
    if n&lt;2:
        return n
    return fib(n-1) + fib(n-2)
   ...: 

In [10]: %timeit fib(30)
1 loops, best of 3: 360 ms per loop</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>functools.wraps</strong></span>: We have just seen how to create decorators, and how to wrap functions. The <a id="id89" class="indexterm"/>returned function from decorator retains its name and attributes, such as docstrings, which is not helpful for the users or fellow developers. We can use this decorator to match the returned function to the decorated function. The following snippet shows how it is used:<div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; def deco(func):
...     @wraps(func) # this will update wrapper to match func
...     def wrapper(*args, **kwargs):
...         """i am imposter"""
...         print("wrapper")
...         return func(*args, **kwargs)
...     return wrapper
... 
&gt;&gt;&gt; @deco
... def realfunc(*args,**kwargs):
...     """i am real function """
...     print("realfunc",args,kwargs)
... 
&gt;&gt;&gt; realfunc(1,2)
wrapper
realfunc (1, 2) {}
&gt;&gt;&gt; print(realfunc.__name__, realfunc.__doc__)
realfunc i am real function </pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lambda functions</strong></span>: These functions are simple anonymous functions.Lambda functions<a id="id90" class="indexterm"/> cannot have statements or annotations. They are very useful in creating closures and callbacks in GUI programming:<div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; def log(prefix):
...     return lambda x:'%s : %s'%(prefix,x)
... 
&gt;&gt;&gt; err = log("error")
&gt;&gt;&gt; warn = log("warn")
&gt;&gt;&gt; 
&gt;&gt;&gt; print(err("an error occurred"))
error : an error occurred
&gt;&gt;&gt; print(warn("some thing is not right"))
warn : some thing is not right</pre></div><p>Sometimes, lambda functions make code easy to understand.</p><p>The following is a small program to create the diamond pattern using the iterations technique and the lambda function:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; import itertools
&gt;&gt;&gt; af = lambda x:[i for i in itertools.chain(range(1,x+1),range(x-1,0,-1))]
&gt;&gt;&gt; output = '\n'.join(['%s%s'%('  '*(5-i),' '.join([str(j) for j in af(i)])) for i in af(5)])
&gt;&gt;&gt; print(output)
        1
      1 2 1
    1 2 3 2 1
  1 2 3 4 3 2 1
1 2 3 4 5 4 3 2 1
  1 2 3 4 3 2 1
    1 2 3 2 1
      1 2 1
        1</pre></div></li></ul></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Summary</h1></div></div></div><p>In this chapter, we covered how to define functions and pass arguments to them. Then, we discussed decorators in detail; decorators are very popular in frameworks. Toward the end, we collected various utilities that are available in Python, which makes coding a little easier for us.</p><p>In the next chapter, we will discuss algorithms and data structures.</p></div></body></html>