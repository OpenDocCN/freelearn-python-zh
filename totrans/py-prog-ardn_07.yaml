- en: Chapter 7. The Midterm Project – a Portable DIY Thermostat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After the first Python-Arduino project, you learned the process of prototyping
    various sensors, developing user interfaces, and plotting sensor data. The concepts
    that you learned in the previous chapters can be utilized to create a wide variety
    of Arduino-based hardware projects. The inception of a good application concept
    always begins with a real-world necessity and ends up as a practical project if
    it is executed properly. In this chapter, we will demonstrate this project-building
    process with an example of a portable sensor unit. As you can estimate from the
    chapter title, we will be building a simple and portable DIY thermostat that can
    be deployed without a desktop computer or a laptop.
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, we will describe the proposed thermostat with specific goals
    and processes to achieve them. Once the strategy to achieve these goals has been
    laid down, you will be introduced to the two successive programming stages to
    develop the deployable and portable unit. In the first stage, we will utilize
    a traditional computer to successfully develop the program to interface Arduino
    with Python. In the second stage, we will replace this computer with a Raspberry
    Pi to make it portable and deployable.
  prefs: []
  type: TYPE_NORMAL
- en: Thermostat – the project description
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the multiple projects that we can build using the things that you learned,
    a project that helps you to monitor your surrounding environment really stands
    out as an important real-world application. From the various environment-monitoring
    projects such as weather station, thermostat, and plant monitoring system, we
    will be developing the thermostat as it focuses on indoor environment and can
    be part of your daily routine.
  prefs: []
  type: TYPE_NORMAL
- en: The thermostat is one of the most important components of any remote home monitoring
    system and home automation system. A popular commercial example of a connected
    thermostat is the Nest Thermostat ([https://www.nest.com](https://www.nest.com)),
    which provides intelligent remote monitoring and scheduling features for your
    existing home's heating and cooling system. Before we think about a full-stack
    product such as Nest, we need first need to build a DIY thermostat with the basic
    set of features. Later, we can build upon this project by adding features to improve
    the DIY thermostat experience. Let's first outline the features that we are planning
    to implement in this version of the thermostat project.
  prefs: []
  type: TYPE_NORMAL
- en: Project background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Temperature, humidity, and ambient light are the three main physical characteristics
    that we want to monitor using the thermostat. In terms of user experience, we
    want to have an elegant user interface to display the measured sensor data. The
    user experience can be more resourceful if any of this sensor data is plotted
    as a line graph. In the case of a thermostat, the visual representation of the
    sensor data provides a more meaningful comprehension of the environment than just
    displaying plain numerical values.
  prefs: []
  type: TYPE_NORMAL
- en: One of the major objectives of the project is to make the thermostat portable
    and deployable so that it can be used in your day-to-day life. To satisfy this
    requirement, the thermostat display needs to be changed from a regular monitor
    to something small and more portable. To ensure its real-world and meaningful
    application, the thermostat should demonstrate real-time operation.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the thermostat will not be interfacing with any
    actuators such as home cooling and heating systems. As the interfacing of these
    systems with the thermostat project requires high-level understanding and experience
    of working with heating and cooling systems, it will deviate the flow of the chapter
    from its original goal of teaching you Arduino and Python programming.
  prefs: []
  type: TYPE_NORMAL
- en: Project goals and stages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to describe the features that we want to have in the thermostat, let''s
    first identify the goals and milestones to achieve these objectives. The major
    goals for the project can be determined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the necessary sensors and hardware components for the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design and assemble the circuit for the thermostat using these sensors and the
    Arduino board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design an effective user experience and develop software to accommodate the
    user experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop and implement code to interface the designed hardware with the software
    components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code development process of the thermostat project is divided into two
    major stages. The objectives of the first stage include sensor interfacing, the
    development of the Arduino sketch, and the development of the Python code on your
    regular computer that you have been using all along. The coding milestone for
    the first stage can be further distributed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Develop the Arduino sketch to interface sensors and buttons while providing
    output of the sensor data to the Python program via the serial port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop the Python code to obtain sensor data from the serial port using the
    `pySerial` library and display the data using GUI that is designed in `Tkinter`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a plot to demonstrate the real-time humidity readings using the `matplotlib`
    library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the second stage, we will attach the Arduino hardware to a single-board
    computer and a miniature display to make it mobile and deployable. The milestone
    to achieve objective of the second stage are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Install and configure a single-board computer, Raspberry Pi, to run the Python
    code from the first stage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface and configure the miniature screen with the Raspberry Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimize the GUI and plot window to adjust to this small screen's resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following subsection of this section, you will be notified about the
    list of required components for both the stages, followed by the hardware circuit
    design and the software flow design. The programming exercises for these stages
    are explained in the next two sections of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The list of required components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of going through the process of identifying the required components,
    we have already selected the components for this project based on their utilization
    in the previous exercises, ease of use, and availability. You can replace these
    components according to their availability at the time you are building this project
    or your familiarity with other sensors. Just make sure that you take care of modifications
    in the circuit connections and code, if these new components are not compatible
    with the ones that we are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first stage of prototyping, we will need components to develop the electronic
    circuit for the thermostat unit. As we mentioned earlier, we are going to measure
    temperature, humidity, and ambient light through our unit. We already learned
    about the temperature sensor TMP102 and the ambient light sensor BH1750 in [Chapter
    4](ch04.html "Chapter 4. Diving into Python-Arduino Prototyping"), *Diving into
    Python-Arduino Prototyping*. We will be using these sensors for this project with
    the humidity sensor HIH-4030\. The project will utilize the same Arduino Uno board
    that you have been using throughout the previous chapters with the necessary cables.
    We will also need two push buttons to provide manual inputs to the unit. The summary
    of the required components for the first stage is provided in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Component (first stage) | Quantity | Website |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Arduino Uno | 1 | [https://www.sparkfun.com/products/11021](https://www.sparkfun.com/products/11021)
    |'
  prefs: []
  type: TYPE_TB
- en: '| USB cable for Arduino | 1 | [https://www.sparkfun.com/products/512](https://www.sparkfun.com/products/512)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Breadboard | 1 | [https://www.sparkfun.com/products/9567](https://www.sparkfun.com/products/9567)
    |'
  prefs: []
  type: TYPE_TB
- en: '| TMP102 temperature sensor | 1 | [https://www.sparkfun.com/products/11931](https://www.sparkfun.com/products/11931)
    |'
  prefs: []
  type: TYPE_TB
- en: '| HIH-4030 humidity sensor | 1 | [https://www.sparkfun.com/products/9569](https://www.sparkfun.com/products/9569)
    |'
  prefs: []
  type: TYPE_TB
- en: '| BH1750 ambient light sensor | 1 | [http://www.robotshop.com/en/dfrobot-light-sensor-bh1750.html](http://www.robotshop.com/en/dfrobot-light-sensor-bh1750.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Push button switch | 2 | [https://www.sparkfun.com/products/97](https://www.sparkfun.com/products/97)
    |'
  prefs: []
  type: TYPE_TB
- en: '| 1 kilo-ohm resistor | 2 |   |'
  prefs: []
  type: TYPE_TB
- en: '| 10 kilo-ohm resistor | 2 |   |'
  prefs: []
  type: TYPE_TB
- en: '| Connection wires | As required |   |'
  prefs: []
  type: TYPE_TB
- en: 'Although the table provides links for few specific website, you can obtain
    these components from your preferred providers. The two major components HIH-4030
    humidity sensor and push button switch that we haven''t used previously are described
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HIH-4030 humidity sensor**: This measures and provides relative humidity
    results as an analog output. The output of the sensor can be directly connected
    to any analog pin of Arduino. The following image shows the breakout board with
    the HIH-4030 sensor that is sold by SparkFun Electronics. You can learn more about
    the HIH-4030 sensor from its datasheet, which can be obtained from [https://www.sparkfun.com/datasheets/Sensors/Weather/SEN-09569-HIH-4030-datasheet.pdf](https://www.sparkfun.com/datasheets/Sensors/Weather/SEN-09569-HIH-4030-datasheet.pdf):![The
    list of required components](img/5938OS_07_06.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Push button switch**: Push button switches are small switches that can be
    used on a breadboard. When pressed, the switch output changes its status to **HIGH**,
    which is **LOW** otherwise.![The list of required components](img/5938OS_07_07.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the second stage, we are going to make the sensor unit mobile by replacing
    your computer with a Raspberry Pi. For that, you will need the following components
    to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Component (second stage) | Quantity | Image |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Raspberry Pi | 1 | [https://www.sparkfun.com/products/11546](https://www.sparkfun.com/products/11546)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Micro USB cable with a power adapter | 1 | [http://www.amazon.com/CanaKit-Raspberry-Supply-Adapter-Charger/dp/B00GF9T3I0/](http://www.amazon.com/CanaKit-Raspberry-Supply-Adapter-Charger/dp/B00GF9T3I0/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| 8 GB SD card | 1 | [https://www.sparkfun.com/products/12998](https://www.sparkfun.com/products/12998)
    |'
  prefs: []
  type: TYPE_TB
- en: '| TFT LCD screen | 1 | [http://www.amazon.com/gp/product/B00GASHVDU/](http://www.amazon.com/gp/product/B00GASHVDU/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| A USB hub | Optional |   |'
  prefs: []
  type: TYPE_TB
- en: Further explanations of these components are provided later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The entire hardware architecture of the thermostat can be divided into two units,
    a physical world interfacing unit and a computation unit. The physical world interfacing
    unit, as its name indicates, monitors phenomenon of the physical world such as
    temperature, humidity, and ambient light using sensors connected to the Arduino
    board. The physical world interfacing unit is interchangeably mentioned as the
    thermostat sensor unit throughout the chapter. The computational unit is responsible
    for displaying the sensor information via the GUI and plots.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the hardware components for the first stage where
    the thermostat sensor unit is connected to a computer using the USB port. In the
    thermostat sensor unit, various sensor components are connected to the Arduino
    board using I2C, analog, and digital pins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hardware design](img/5938OS_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the second programming stage where we are going make our thermostat into
    a mobile and deployable unit, you will be using a single-board computer, Raspberry
    Pi, as the computational device. In this stage, we will use a miniature **thin-film
    transistor liquid-crystal display** (**TFT LCD**) screen that is connected to
    a Raspberry Pi via **general-purpose input/output** (**GPIO**) pins and is used
    as a display unit to replace the traditional monitor or laptop screen. The following
    diagram shows this new thermostat computational unit, which truly reduces the
    overall size of the thermostat and makes it portable and mobile. Circuit connections
    for the Arduino board are unchanged for this stage and we will use the same hardware
    without any major modifications.
  prefs: []
  type: TYPE_NORMAL
- en: '![Hardware design](img/5938OS_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the common unit for both stages of the project, the Arduino-centric thermostat
    sensor unit requires slightly more complex circuit connections compared to other
    exercises that you have been through. In this section, we are going to interface
    the necessary sensors and push buttons to their respective pins on the Arduino
    board and you will need a breadboard to make these connections. If you are familiar
    with PCB prototyping, you can create your own PCB board by soldering these components
    and avoid the breadboard. PCB boards are more robust compared to breadboards and
    less prone to loose connections. Use the following instructions and the Fritzing
    diagram to complete the circuit connections:'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the following diagram, connect the SDA and SCL pins of TMP102
    and BH1750 to analog pins 4 and 5 of the Arduino board and create an I2C bus.
    To make these connections, you can use multiple color-coded wires to simplify
    the debugging process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use two 10 kilo-ohm pull-up resistors with the SDA and SCL lines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Contrary to these I2C sensors, the HIH-4030 humidity sensor is a simple analog
    sensor and can be directly connected to the analog pin. Connect the HIH-4030 to
    the analog pin A0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect VCC and the ground of TMP102, BH1750, and HIH-4030 to +5V and the ground
    of the Arduino board using power strips of the breadboard, as displayed in the
    diagram. We recommend that you use red and black wires to represent the +5V and
    ground lines respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The push button provides the output as **HIGH** or **LOW** state and interfaced
    using digital pins. As displayed in the circuit, connect these push buttons to
    digital pins 2 and 3 using two 1 kilo-ohm resistors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Complete the remaining connections as displayed in the following diagram. Make
    sure that you have firmly connected all the wires before powering up the Arduino
    board:![Hardware design](img/5938OS_07_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure that you always disconnect your Arduino board from the power source
    or a USB port before making any connections. This will prevent any damage to the
    board due to short circuiting.
  prefs: []
  type: TYPE_NORMAL
- en: Complete all the connections for the thermostat sensor unit before heading to
    the next section. As this unit is being used in both the programming stages, you
    won't be performing any further changes to the thermostat sensor unit.
  prefs: []
  type: TYPE_NORMAL
- en: Software flow for user experience design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the critical components of any project is its usability or accessibility.
    When you are working on making your project prototype into a product, it is necessary
    to have an intuitive and resourceful user interface so that the user can easily
    interact with your product. Hence, it is necessary to define the user experience
    and software flow of a project before you start coding. The software flow includes
    the flow chart and the logical components of the program that are derived from
    the project requirements. According to the goals that we have defined for the
    thermostat project, the software flow can be demonstrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Software flow for user experience design](img/5938OS_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the implementation, the software flow of the project begins by measuring
    the temperature, humidity, and ambient light from Arduino and printing them on
    a serial port line by line. The Python program obtains the sensor data from Arduino
    via the serial port before presenting the data on the screen. Meanwhile, the Python
    program keeps looking for a new line of data.
  prefs: []
  type: TYPE_NORMAL
- en: A user can interact with the thermostat using a push button, which will let
    the user change the unit for the temperature data. Once the button is pressed,
    the flag gets changed to **HIGH** and the temperature unit is changed to **Celsius**
    from its default unit, **Fahrenheit**. If the button is pressed again, the opposite
    process will happen and the unit will be changed back to its default value. Similarly,
    another user interaction point is the second push button that allows a user to
    open a plot for real-time humidity values. The second push button also utilizes
    a similar method of using flags to capture the input and opens a new plot window.
    If the same button is pushed sequentially, the program will close the plot window.
  prefs: []
  type: TYPE_NORMAL
- en: Stage 1 – prototyping the thermostat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this prototyping stage, we will develop the Arduino and Python code for our
    thermostat, which will be later used in the second stage with minor changes. Before
    you start the coding exercise, make sure that you have the thermostat sensor unit
    ready with the Arduino board and the connected sensors, as described in the previous
    section. For this stage, you will be using your regular computer which is equipped
    with the Arduino IDE and the Python programming environment. The prototyping stage
    requires two levels of programming, the Arduino sketch for the thermostat sensor
    unit and the Python code for the computational unit. Let's get started with coding
    for our thermostat.
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino sketch for the thermostat
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goal of this Arduino program is to interface sensors, get measurements from
    the sensors, and print them on the serial port. As we discussed earlier, rather
    than using the standard Firmata sketch that we used in the previous project, we
    are going to develop a custom Arduino sketch in this project. To get started,
    open the `Thermostat_Arduino.ino` sketch from this chapter's code folder, which
    is part of the source code that you received for the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect the USB port of the Arduino board, which is now part of the thermostat
    sensor unit, to your computer. Select the appropriate board and port names in
    the Arduino IDE and verify the code. Upload the code to your Arduino board and
    open the **Serial Monitor** window once the code is successfully uploaded. You
    should be able to see text similar to that displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Arduino sketch for the thermostat](img/5938OS_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Arduino code structure and basic declarations are already explained in various
    sections throughout the book. Instead of explaining the entire code line by line,
    we will focus here on the main components of the software flow that we described
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing the temperature sensor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the Arduino sketch, the temperature data is obtained from the TMP102 sensor
    using the `getTemperature()` function. The function implements the `Wire` library
    on the I2C address of TMP102 to read the sensor data. This is then converted into
    proper temperature values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `getTemperature()` function returns the temperature values in Celsius, which
    is then sent to the serial port.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing the humidity sensor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although the humidity sensor provides the analog output, it is not straightforward
    to obtain relative humidity since it also depends upon the temperature. The `getHumidity()`
    function calculates the relative humidity from the analog output provided by the
    HIH-4030 sensor. The formulas to calculate the relative humidity are obtained
    from the datasheet and reference examples of the sensor. If you are using a different
    humidity sensor, please make sure that you change the formulas accordingly, as
    they may change the results significantly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we are calculating relative humidity, the returned humidity values are sent
    to the serial port with percentage as the unit.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing the light sensor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To interface the BH1750 light sensor, we will use the BH1750 Arduino library,
    which we used earlier. Using this library, the ambient light value can be directly
    obtained using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This line provides the luminance values in the unit of `lux`. These values are
    also sent to the serial port so the Python program can utilize it further.
  prefs: []
  type: TYPE_NORMAL
- en: Using Arduino interrupts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Until now you used the Arduino program to read the physical state of an I/O
    pin using the `DigitalRead()` or `AnalogRead()` functions. How would you automatically
    obtain the state change instead of periodically reading the pins and waiting for
    the state to change? Arduino interrupts provide a very convenient way of capturing
    signals for the Arduino board. Interrupts are a very powerful way of automatically
    controlling various things in Arduino. Arduino supports interrupts using the `attachInterrupt()`
    method. In terms of the physical pins, Arduino Uno provides two interrupts: interrupt
    0 (on digital pin 2) and interrupt 1 (on digital pin 3). Various Arduino boards
    have different specifications for interrupt pins. If you are using any board other
    than Uno, please refer to Arduino''s website to find out about the interrupt pin
    for your board.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `attachInterrupt()` function takes three input arguments (`pin`, `ISR`,
    and `mode`). In these input arguments, `pin` refers to the number of the interrupt
    pin, `ISR` (which stands for Interrupt Service Routine) refers to the function
    that gets called when the interrupt occurs, and `mode` defines the condition when
    the interrupt should be triggered. We have utilized this function in our Arduino
    program, as described in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The supported `mode` for `attachInterrupt()` are `LOW`, `CHANGE`, `RISING`,
    and `FALLING`. In our case, the interrupts are triggered when the mode is `RISING`,
    that is, the pin goes from low to high. For interrupts declared at 0 and 1, we
    call the `button1Press` and `button2Press` functions that will change `flagTemperature`
    and `flagPlot` respectively. When `flagTemperature` is set to `HIGH`, Arduino
    sends the temperature in Celsius, otherwise it sends the temperature in Fahrenheit.
    When `flagPlot` is `HIGH`, Arduino will print the flag on the serial port, which
    will be used by the Python program later to open the plot window. You can learn
    more about Arduino interrupts from the tutorial at [http://arduino.cc/en/Reference/attachInterrupt](http://arduino.cc/en/Reference/attachInterrupt).
  prefs: []
  type: TYPE_NORMAL
- en: Designing the GUI and plot in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once your thermostat sensor unit starts sending sensor data to the serial port,
    it is time to execute the second part of this stage, the Python code for the GUI
    and the plot. From this chapter''s code folder, open the Python file called `Thermostat_Stage1.py`.
    In the file, go to the line that contains the `Serial()` function where the serial
    port is declared. Change the serial port name from `COM5` to the appropriate one.
    You can find this information from the Arduino IDE. Save the change and exit the
    editor. From the same folder, run the following command on the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will execute the Python code and you will be able to see the GUI window
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Using pySerial to stream sensor data in your Python program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As described in the software flow, the program receives the sensor data from
    the Arduino using the `pySerial` library. The code that declares the serial port
    in the Python code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It is very important to specify the `timeout` parameter while using the `pySerial`
    library, as the code may have an error if `timeout` is not specified.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the GUI using Tkinter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The GUI for this project is designed using the `Tkinter` library that we used
    earlier. As a GUI-building exercise, three columns of labels (labels to display
    the sensor type, the observation values, and observation units) are programmed
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you initialize the code and before you click on the **Start** button,
    you will be able to see the following window. The observation labels are populated
    without any values at this stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the GUI using Tkinter](img/5938OS_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the **Start** button is clicked, the program will engage the thermostat
    sensor unit and start reading the sensor values from the serial port. Using the
    lines that are obtained from the serial port, the program will populate the observation
    labels with the obtained values. The following code snippet updates the temperature
    values in the observation label and also updates the temperature unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the program, we are using similar methods for humidity and ambient light
    to update their labels respectively. As you can see in the following screenshot,
    the GUI now has the values for the temperature, humidity, and ambient light readings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the GUI using Tkinter](img/5938OS_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Start** and **Exit** buttons are programmed to call the `onStartButtonPress()`
    and `onExitButtonPress()` functions when they are clicked by the user. The `onStartButtonPress()`
    function executes the code necessary to create the user interface, while the `onExitButtonPress()`
    function closes all the opened windows, disconnects the thermostat sensor unit,
    and exits the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can play with the **Start** and **Exit** buttons to explore the Python code.
    To observe the changes in the sensor readings, try to blow air or place an obstacle
    over the thermostat sensor unit. If the program doesn't behave appropriately,
    check the terminal for error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting percentage humidity using matplotlib
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will use the `matplotlib` library to plot the relative humidity values in
    real time. We will plot the relative humidity values in this project, as the range
    of the data is fixed between 0 and 100 percent. Using a similar method, you can
    also plot temperature and ambient light sensor values. While developing the code
    to plot temperature and ambient light sensor data, make sure that you are using
    appropriate ranges to cover the sensor data in the same plot. Now, as we have
    specified in the `onStartButtonPress()` function, a window similar to the following
    screenshot will pop up once you press the push button for the plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Plotting percentage humidity using matplotlib](img/5938OS_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code snippet is responsible for plotting the line chart using
    the humidity sensor values. The values are limited between 0 and 100 on the *y*
    axis, where the *y* axis represents the relative humidity range. The plot is updated
    every time the program receives a new humidity value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using button interrupts to control the parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The push button interrupts are a critical part of the user experience, as the
    user can control the temperature unit and the plot using these interrupts. The
    Python features implemented using the push button interrupts are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the temperature unit by pressing a button
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Arduino sketch contains the logic to handle interrupts from push buttons
    and use them to change the temperature unit. When an interrupt occurs, instead
    of printing the temperature in Fahrenheit, it sends the temperature in Celsius
    to the serial port. As you can see in the following screenshot, the Python code
    just prints the obtained numeric value of the temperature observation and the
    associated unit of measurement with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the temperature unit by pressing a button](img/5938OS_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the following code snippet, if the Python code receives the
    `Temperature(C)` string, it prints the temperature in `Celsius`, and if it receives
    the `Temperature(F)` string, it prints the temperature in `Fahrenheit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Swapping between the GUI and the plot by pressing a button
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If the Python code receives the value of the flag from the serial port as `1`
    (HIGH), it creates a new plot and draws the humidity values as a line chart. However,
    it closes any open plots if it receives `0` (LOW) as the value of the flag. As
    you can see in the following code snippet, the program will always try to update
    the plot with the latest values for humidity readings. If the program can''t find
    an opened plot to draw this value from, it will create a new plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: By now, you should have a complete idea about the programs that are required
    by the thermostat sensor unit and the computation unit. Due to the complexity
    involved, you may face a few known problems during the execution of these programs.
    You can refer to the *Troubleshooting* section in case you run into any trouble.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some of the errors that you may find, and their fixes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'I2C sensor returns the error string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the connections to the SDA and SCL pins.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Confirm that you are providing enough delay between the reading cycles of the
    sensor. Check the datasheet for the delay and message sequence.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The plot window flickers instead of staying on when the button is pressed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't try to press it multiple times. Hold and let go quickly. Make sure that
    your button is connected properly.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjust the delay in the Arduino sketch.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Stage 2 – using a Raspberry Pi for the deployable thermostat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now created a thermostat that exists as an Arduino prototype while the
    Python program runs from your computer. This prototype is still nowhere near a
    deployable or mobile state due to the connected computer, and the display monitor
    if you are using a desktop computer. A real-world thermostat device should have
    a small footprint, portable size, and miniature display to show limited information.
    The popular and practical way to achieve this goal is to use a small single-board
    computer that is capable of hosting an operating system and hence providing the
    essential Python programming interface. For this stage of the project, we will
    be utilizing a single-board computer—a Raspberry Pi—with a small LCD display.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this stage of the project is optional unless you want to extend the
    previous stage of the project to a device that can be used on a regular basis.
    If you are referring to the project to just learn Python programming, you can
    skip this entire section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an image of the Raspberry Pi Model B:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stage 2 – using a Raspberry Pi for the deployable thermostat](img/5938OS_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you haven't worked with a single-board computer before, you may have a lot
    of unanswered questions, such as "What exactly does a Raspberry Pi consists of?",
    "What are the benefits of using a Raspberry Pi in our project?", and "Can't we
    just use Arduino for that?". These are legitimate questions and we will try to
    answer them in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Raspberry Pi?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Raspberry Pi is a small (almost the size of a credit card) single-board
    computer that was developed with the initial aim of helping students learn the
    basics of computer science. Today, the Raspberry Pi movement, guided by the Raspberry
    Pi Foundation, has turned into a DIY phenomenon and captured the attention of
    enthusiasts and developers around the world. The capabilities and features shipped
    with a Raspberry Pi at a nominal cost ($35) have boosted the popularity of the
    device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The term single-board computer is used for devices that have all the necessary
    components to run an operating system on one board, such as a processor, RAM,
    graphics processor, storage device, and basic adaptors for expansion. This makes
    a single-board computer an appropriate candidate for portable applications, as
    they can be part of the portable hardware device that we are trying to create.
    Although there were a number of single-board computers in the market before the
    introduction of the Raspberry Pi, the open source nature of the hardware and the
    economical price are the main reasons behind the popularity and rapid adoption
    of the Raspberry Pi. The following figure shows the Raspberry Pi Model B with
    its major components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is a Raspberry Pi?](img/5938OS_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The computational capabilities of the Raspberry Pi are adequate for running
    a trimmed down version of Linux OS. Although people had tried to use many types
    of operating systems on a Raspberry Pi, we will be using the default and recommended
    operating system called **Raspbian**. Raspbian is a Debian distribution-based
    open source Linux OS, which is optimized for the Raspberry Pi. The Raspberry Pi
    uses an SD card as the storage device, which will be used to store your OS and
    program files. In Raspbian, you can avoid running the unnecessary OS components
    that are shipped with traditional OSes. These include the Internet browser, communication
    application, and in some cases even the graphical interface.
  prefs: []
  type: TYPE_NORMAL
- en: After its introduction, the Raspberry Pi has gone through a few major upgrades.
    The earlier version, called **Model A**, did not include the Ethernet port and
    only had a memory of 256 MB. In our project, we are using the Raspberry Pi's Model
    B that has a dedicated Ethernet port, 512 MB memory, and dual USB ports. The latest
    versions of Raspberry Pi, Model B+, can be also used as it is also equipped with
    an Ethernet port.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the operating system and configuring the Raspberry Pi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the Raspberry Pi is a computer, it is different than traditional desktop
    computers when it comes to interfacing peripheral devices. Instead of supporting
    traditional VGA or DVI display ports, the Raspberry Pi provides a RCA video port
    for TVs and an HDMI port for the latest generation of monitors and TVs. In addition,
    the Raspberry Pi has only two USB ports that need to be utilized for connecting
    various peripheral devices such as the mouse, the keyboard, the USB wireless adapter,
    and the USB memory stick. Let's get started by collecting components and cables
    to start working with a Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: What do you need to begin using the Raspberry Pi?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The hardware components required to get started with a Raspberry Pi are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A Raspberry Pi**: For this stage of the project, you will need a Raspberry
    Pi version Model B or latest. You can buy the Raspberry Pi from [http://www.raspberrypi.org/buy](http://www.raspberrypi.org/buy).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A power cable**: The Raspberry Pi runs on 5V DC and requires at least 750
    mA current. The power is applied through the micro USB port that is located on
    the board. In this project, you will need a micro USB power supply. Optionally,
    you can use a micro USB-based phone charger to supply power to the Raspberry Pi.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A display cable**: If you have an HDMI monitor or a TV, you can use an HDMI
    cable to connect it to your Raspberry Pi. If you want to use your VGA or DVI-based
    monitor, you will need a VGA to HDMI or DVI to HDMI adapter converter. You can
    buy these adapter converters from Amazon or Best Buy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An SD card**: You are required to have at least an 8 GB SD card to get started.
    It is preferable to use an SD card that has a quality of class 4 or better. You
    can also buy an SD card with the preinstalled OS at [http://swag.raspberrypi.org/collections/frontpage/products/noobs-8gb-sd-card](http://swag.raspberrypi.org/collections/frontpage/products/noobs-8gb-sd-card).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The Raspberry Pi Model B+ requires a microSD card instead of a regular SD card.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**A mouse and keyboard**: You will need a standard USB keyboard and a USB mouse
    to work with the Raspberry Pi.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A USB hub (optional)**: Since the Model B has just two USB ports, you will
    have to remove existing devices from the USB ports to make space for another device
    if you want to connect a Wi-Fi adapter or memory stick to it. A USB hub can be
    handy to attach multiple peripheral components to your Raspberry Pi. We recommend
    that you use a USB hub with external power supply, as the Raspberry Pi can drive
    a limited number of peripheral devices through the USB ports due to power limitations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing an SD card
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To install and configure software components such as Python and the required
    libraries, first we need an operating system for the Raspberry Pi. A Raspberry
    Pi officially supports Linux-based open source operating systems that are preconfigured
    for custom Raspberry Pi hardware components. Various versions of these operating
    systems are available on Raspberry Pi's website ([http://www.raspberrypi.org/downloads](http://www.raspberrypi.org/downloads)).
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi's website provides a variety of OSes for users who range from newbies
    to experts. It is difficult for a first-time user to identify the appropriate
    OS and its installation process. If this is your first attempt with a Raspberry
    Pi, we recommend that you use the **New Out Of Box Software** (**NOOBS**) package.
    Download the latest version of `NOOBS` from the previous link. The `NOOBS` package
    includes few different operating systems such as Raspbian, Pidora, Archlinux,
    and RaspBMC. `NOOBS` streamlines the entire installation process and helps you
    to install and configure your preferred version of the OS easily. It is important
    to note that `NOOBS` is just an installation package and you will be left with
    only the Raspbian OS once you complete the given installation steps.
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi uses the SD card to host the operating system and you need to prepare
    the SD card from your computer before placing it into the SD card slot of the
    Raspberry Pi. Insert your SD card into your computer and make sure that you have
    a backup of any important information that is on the SD card. During the installation
    process, you will lose all the data stored on the SD card. Let's start by preparing
    your SD card.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to prepare an SD card from Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: You will require a software tool to format and prepare the SD card for Windows.
    You can download the freely available formatting tool from [https://www.sdcard.org/downloads/formatter_4/eula_windows/](https://www.sdcard.org/downloads/formatter_4/eula_windows/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download and install the formatting tool on your Windows computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert your SD card and start the formatting tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the formatting tool, open the **Options** menu and set **FORMAT SIZE ADJUSTMENT**
    to **ON**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the appropriate SD card and click on **Format**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, wait for the formatting tool to finish formatting the SD card. Once this
    is done, extract the downloaded `NOOBS` ZIP file to the SD card. Make sure that
    you extract the content of the ZIP folder to the root location of the SD card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Follow these directions to prepare SD card from Mac OS X:'
  prefs: []
  type: TYPE_NORMAL
- en: You will require a software tool to format and prepare the SD card for Mac OS
    X. You can download the freely available formatting tool from [https://www.sdcard.org/downloads/formatter_4/eula_mac/](https://www.sdcard.org/downloads/formatter_4/eula_mac/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download and install the formatting tool on your machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert your SD card and run the formatting tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the formatting tool, select **Overwrite Format**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the appropriate SD card and click on **Format**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, wait for the formatting tool to finish formatting the SD card. Once this
    is done, extract the downloaded `NOOBS` ZIP file to the SD card. Make sure that
    you extract the content of the ZIP folder to the root location of the SD card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Follow these steps to prepare the SD card from Ubuntu Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To format the SD card on Ubuntu, you can use a formatting tool called `gparted`.
    Install `gparted` using the following command on the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Insert your SD card and run `gparted`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `gparted` window, select the entire SD card and format it using **FAT32**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the format process is complete, extract the downloaded `NOOBS` ZIP file
    to the SD card. Make sure that you extract the content of the ZIP folder to the
    root location of the SD card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have any trouble following these steps, you can refer to the official
    documentation for preparing the SD card for a Raspberry Pi at [http://www.raspberrypi.org/documentation/installation/installing-images/](http://www.raspberrypi.org/documentation/installation/installing-images/).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Raspberry Pi setup process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you have prepared your SD card with `NOOBS`, insert it into the SD card
    slot of the Raspberry Pi. Connect your monitor, mouse, and keyboard before connecting
    the micro USB cable for the power adapter. Once you connect the power adapter,
    the Raspberry Pi will turn on automatically and you will be able to see the installation
    process on the monitor. If you are not able to see any progress on the monitor
    after connecting the power adapter, refer to the troubleshooting section that
    is available later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the Raspberry Pi boots up, it will repartition the SD card and show you
    the following installation screen so that you can get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Raspberry Pi setup process](img/5938OS_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding screenshot is taken from `raspberry_pi_F01_02_5a.jpg` by Simon
    Monk and is licensed under Attribution Creative Commons license ([https://learn.adafruit.com/assets/11384](https://learn.adafruit.com/assets/11384)).
  prefs: []
  type: TYPE_NORMAL
- en: As a first-time user, select **Raspbian [RECOMMENDED]** as the recommended operating
    system and click on the **Install OS** button. Raspbian is a Debian-based OS that
    is optimized for the Raspberry Pi and it supports useful Linux commands that we
    have already learned in the previous chapters. The process will take about 10
    to 20 minutes to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On successful completion, you will be able to see a screen similar to the one
    displayed in the following screenshot. The screenshot displays the `raspi-config`
    tool that will let you set up the initial parameters. We will skip this process
    to complete the installation. Select **<Finish>** and press *Enter*:![The Raspberry
    Pi setup process](img/5938OS_07_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can go back to this screen again, in case you want to change any parameter,
    by typing the following command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Raspberry Pi will now reboot and you will be prompted to the default login screen.
    Log in using the default username `pi` and password `raspberry`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can start the graphical desktop of the Raspberry Pi by typing the following
    command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the Python code that we developed in the first stage, you will need
    to set up required Python libraries on the Raspberry Pi. You will have to connect
    your Raspberry Pi to the Internet using the Ethernet cable to install the packages.
    Install the required Python packages on the Raspberry Pi terminal using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install `pySerial` using Setuptools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, your Raspberry Pi is ready with an operating system and the necessary components
    to support Python-Arduino programming.
  prefs: []
  type: TYPE_NORMAL
- en: Using a portable TFT LCD display with the Raspberry Pi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TFT LCD is a great way to expand the Raspberry Pi's functionalities and avoid
    the use of large display devices. These TFT LCD displays can be interfaced directly
    with GPIO pins. TFT LCD screens are available in various shapes and size, but
    for the Raspberry Pi we recommend that you use a screen with a size smaller than
    or equal to 3.2 inches due to interfacing convenience. Most of these small screens
    do not require additional power supply and can be directly powered using the GPIO
    pins. In a few cases, touch screen versions are also available to extend the functionality
    of the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, we are using a Tontec 2.4 inch TFT LCD screen that can be
    directly interfaced with the Raspberry Pi via GPIO. Although you can use any available
    TFT LCD screen, this book only cover the setup and configuration process for this
    particular screen. In most cases, manufacturers of these screens provide detailed
    configuration tutorials on their websites. Raspberry Pi forums and blogs are another
    good places to look for help if you are using a different type of the TFT LCD
    screen. The following image shows the back of the Tontec 2.4 inch TFT LCD screen
    with the location of the GPIO pins. Let''s get started and use this screen with
    your Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a portable TFT LCD display with the Raspberry Pi](img/5938OS_07_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Connecting the TFT LCD using GPIO
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we can use the screen, we will have to connect it to the Raspberry Pi.
    Let''s disconnect the micro USB power adapter from the Raspberry Pi and locate
    the GPIO male pins near the RCA video port on the Raspberry Pi. Get your TFT screen
    and connect the GPIO pins as such you can see Raspberry Pi and the screen as displayed
    in the following image. In handful cases, the notations on the screen will be
    misleading, and therefore we suggest that you follow the guidelines from the manufacturer
    to make the connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting the TFT LCD using GPIO](img/5938OS_07_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once your screen is connected to the Raspberry Pi, power it up using the micro
    USB cable. Do not disconnect your HDMI cable yet, as your screen is still not
    ready. Before we go ahead with any of the configuration steps, let's first connect
    the Raspberry Pi to the Internet. Connect the Ethernet port of the Raspberry Pi
    to your home or office network using an Ethernet cable. Now, let's configure the
    TFT LCD screen in the Raspbian OS to make it work properly.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the TFT LCD with the Raspberry Pi OS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once your Raspberry Pi is powered up, log in using your username and password.
    Complete the following steps to configure the screen with your Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the supporting files and manual using the following command on the
    terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Unzip the file. The following command will extract the files into the same
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the `src` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter following command to compile the source files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the boot configuration files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `config.txt` file, locate and uncomment the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save and exit the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, every time the Raspberry Pi restarts we need to execute a command to start
    the TFT LCD screen. To do this, open the `rc.local` file using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following line of code to the file that starts the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and exit the file. Then, reboot the Raspberry Pi using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can remove your HDMI monitor now and start working with your TFT LCD screen.
    One thing that you will have to keep in mind is that the screen resolution is
    very small and it is not optimized for coding. We prefer to use the HDMI monitor
    to perform the major code modifications that are required in the next section.
    The utilization of the TFT LCD screen in this project is to accommodate the mobility
    and portability requirements of the thermostat.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the GUI for the TFT LCD screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The resolution of the TFT LCD screen that we configured in the previous section
    is only 320 x 240 pixels, but the windows that we created in first programming
    stage are quite large. Therefore, before we copy and run our Python code on the
    Raspberry Pi, we need to adjust a few parameters in the code.
  prefs: []
  type: TYPE_NORMAL
- en: In your regular computer where you have this chapter's folder from the book's
    source code, open the `Thermostat_Stage2.py` file. This file contains the details
    of the modification required to obtain the optimum size with minor cosmetic changes.
    You will be using this file, instead of the one that we used in the previous stage,
    on your Raspberry Pi. These adjustments in the code are explained in the following
    lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first major alteration is in the port name. For the Raspberry Pi, you need
    to change the name of the Arduino port from that you were using in the first stage
    to `/dev/ttyACM0`, which is the address assigned to Arduino in the majority of
    the cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In this program file, the size of the `Tkinter` main window and the `matplotlib`
    figure are also adjusted to fit the screen size. If you are using a different-sized
    screen, change the following lines of code appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, with the preceding changes, the GUI window should be able to fit within
    Raspberry Pi''s screen. As the Raspberry Pi''s screen will be used as the dedicated
    screen for the thermostat application, we need to adjust the text size on the
    screen to fit the window properly. Add the `font=("Helvetica", 20)` text in the
    declaration of the labels to increase the font size. The following line of code
    shows changes that are performed on the labels to contain the sensor names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the `font` option is added to the observation labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The labels for the observation unit also carry similar modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Thermostat_ Stage2.py` file already includes the preceding modifications
    and is ready to run on your Raspberry Pi. Before you run the file, first we need
    to copy the file to the Raspberry Pi. At this stage, the USB hub will be very
    handy to copy the files. If you don''t have a USB hub, you can utilize two available
    USB ports simultaneously to attach the USB pen drive, mouse, and keyboard. With
    the use of the USB hub, connect the USB pen drive containing the Python files
    and copy them to the home folder. Attach the USB port of the Arduino board to
    one of the ends of the USB hub. From the start menu of the Raspberry Pi, open
    the **LXTerminal** program by navigating to **Accessories** | **LXterminal**.
    Run the Python code from the home folder and you will be able to see the optimized
    user interface window that opens on the Raspberry Pi''s screen. If every step
    mentioned in the chapter is performed correctly, you will be able to see the sensor
    observation being printed when you click on the **Start** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimizing the GUI for the TFT LCD screen](img/5938OS_07_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At the end of the chapter, you must be wondering what a mobile unit with sensors,
    Arduino, Raspberry Pi, and TFT screen might look like. The following image shows
    a sample thermostat that was developed using the instructions given in this chapter.
    We used an acrylic sheet to hold the Raspberry Pi and the Arduino board together
    and created a compact form factor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimizing the GUI for the TFT LCD screen](img/5938OS_07_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few known problems that you may face in this stage of the project.
    The following section describes these problems and their quick fixes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Raspberry Pi is not booting up:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that the SD card is formatted properly with the specified tools. The
    Raspberry Pi won't boot if the SD card is not prepared properly.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the HDMI cable and the monitor to see whether they are working fine.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that the power adapter is compatible with the Raspberry Pi.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The TFT LCD screen doesn''t turn on:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that the screen is properly connected to the GPIO pins of the Raspberry
    Pi.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using any other TFT LCD screen, make sure from its datasheet that
    your screen doesn't require additional power.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether the screen is properly configured using the steps described in
    the *Optimizing the GUI for the TFT LCD screen* section.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is a slow refresh rate of the sensor data on the Raspberry Pi:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try decreasing the delay between each serial message that is sent by Arduino.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminate any other application that is running in the background.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this project, we successfully created a portable and deployable thermostat
    using Arduino, which monitors temperature, humidity, and ambient light. During
    this process, we assembled the thermostat sensor unit using the necessary components
    and developed custom Arduino program to support them. We also utilized Python
    programming methods including GUI development and plots using `Tkinter` and `matplotlib`
    libraries respectively. Later in the chapter, we utilized the Raspberry Pi to
    convert a mere project prototype into a practical application. Henceforth, you
    should be able to develop similar projects that require you to observe and visualize
    real-time sensor information.
  prefs: []
  type: TYPE_NORMAL
- en: Going forward, we will be expanding this project to accommodate upcoming topics
    such as Arduino networking, cloud communication, and remote monitoring. In the
    next level of the thermostat project, we will integrate these advanced features
    and make it a really resourceful DIY project that can be used in everyday life.
    In the next chapter, we are going to start the next stage of our journey from
    making simple Python-Arduino projects to Internet-connected and remotely accessible
    IoT projects.
  prefs: []
  type: TYPE_NORMAL
