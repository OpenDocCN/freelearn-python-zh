<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer125">
<h1 class="chapter-number" id="_idParaDest-91"><a id="_idTextAnchor091"/>6</h1>
<h1 id="_idParaDest-92"><a id="_idTextAnchor092"/>Building an IoT Alarm Module</h1>
<p>In the previous chapter, we explored the Raspberry Pi’s GPIO port and built a basic alarm system. We learned about different communication protocols and worked with a set of sensors, which we accessed using the GPIO port. In this chapter, we will enhance our basic alarm system using a Raspberry Pi Pico W, a public <strong class="bold">Message Queuing Telemetry Transport</strong> (<strong class="bold">MQTT</strong>) server, and the MQTTHQ web client (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">).</span></p>
<p>We will use a Raspberry Pi Pico W to host a <strong class="bold">passive infrared</strong> (<strong class="bold">PIR</strong>) sensor and buzzer as we build our IoT alarm module. In our setup, when motion is detected, a <strong class="source-inline">motion</strong> message is sent to the MQTT server and viewed using the MQTTHQ <span class="No-Break">web client:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer101">
<img alt="Figure 6.1 – IoT-powered alarm module using MQTT" height="519" src="image/B21282_06_1.jpg" width="1142"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – IoT-powered alarm module using MQTT</p>
<p>We will send a <strong class="source-inline">buzzer</strong> message to the Raspberry Pi Pico W from the MQTTHQ web client to activate the buzzer. This Raspberry Pi Pico W and MQTTHQ web client setup forms the foundation of our IoT home <span class="No-Break">security system.</span></p>
<p>We’ll begin this chapter with an exploration of MQTT, using a public server as our development platform. Then, we’ll familiarize ourselves with the Raspberry Pi Pico W, highlighting its strengths in IoT applications. Finally, we’ll conclude by installing the components of our IoT alarm module into a custom <span class="No-Break">3D-printed case.</span></p>
<p>As such, we will cover the following main topics in <span class="No-Break">the chapter:</span></p>
<ul>
<li><span class="No-Break">Investigating MQTT</span></li>
<li>Using a Raspberry Pi Pico W <span class="No-Break">with MQTT</span></li>
<li>Building an IoT alarm <span class="No-Break">module case</span></li>
</ul>
<p><span class="No-Break">Let’s begin!</span></p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor093"/>Technical requirements</h1>
<p>The following are the requirements for completing <span class="No-Break">this chapter:</span></p>
<ul>
<li>Intermediate knowledge of <span class="No-Break">Python programming.</span></li>
<li>1 x Raspberry Pi Pico WH (with headers) to use with breadboard or Raspberry Pi Pico <span class="No-Break">GPIO expander.</span></li>
<li>1 x Raspberry Pi Pico W (no headers) to be installed in an optional <span class="No-Break">3D-printed case.</span></li>
<li>1 x HC-SR501 <span class="No-Break">PIR sensor.</span></li>
<li>1 x LED connected with a 220 Ohm resistor (refer to <a href="B21282_03.xhtml#_idTextAnchor048"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> <span class="No-Break">for construction).</span></li>
<li>1 x SFM-27 <span class="No-Break">active buzzer.</span></li>
<li>Access to a 3D printer or 3D printing service to print an <span class="No-Break">optional case.</span></li>
</ul>
<p>The code for this chapter can be <span class="No-Break">found here:</span></p>
<p><span class="No-Break">https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter6</span></p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor094"/>Investigating MQTT</h1>
<p><strong class="bold">MQTT</strong> is a pivotal<a id="_idIndexMarker460"/> component in IoT, enabling lightweight and efficient communication among connected devices. In <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.1</em>, we illustrate MQTT within the ubiquitous cloud symbolizing the internet. MQTT operates <a id="_idIndexMarker461"/>on a <strong class="bold">publish-subscribe</strong> model, allowing devices to publish messages to specific topics while subscribing to relevant topics. This framework ensures efficient and selective communication, enabling devices to receive only messages relevant to their functions. MQTT’s lightweight design minimizes resource overhead, making it an ideal choice for devices with <span class="No-Break">constrained capabilities.</span></p>
<p>We start our investigation into MQTT by looking at how the publish-subscribe model in <span class="No-Break">MQTT works.</span></p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor095"/>Understanding the publish-subscribe model in MQTT</h2>
<p>The effectiveness <a id="_idIndexMarker462"/>of MQTT<a id="_idIndexMarker463"/> in enabling communication among IoT devices is due to its publish-subscribe model. This model provides a flexible and scalable way for devices to communicate with <span class="No-Break">each other.</span></p>
<p>In MQTT, devices are categorized into two roles – publishers <span class="No-Break">and subscribers:</span></p>
<ul>
<li><strong class="bold">Publishers</strong>: Publishers<a id="_idIndexMarker464"/> create data or messages for sharing with other devices. They send these messages to designated <strong class="bold">topics</strong> to organize information for distribution. In <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.2</em>, both the PIR sensor and the temperature sensor act as publishers, utilizing a microcontroller (such as the Raspberry Pi Pico W, which is not depicted) for this purpose. The PIR sensor sends a <strong class="source-inline">motion</strong> message under the <strong class="source-inline">IoTAlarm</strong> topic, while the temperature sensor communicates a <strong class="source-inline">25 C</strong> message under the <span class="No-Break"><strong class="source-inline">temp</strong></span><span class="No-Break"> topic.</span></li>
<li><strong class="bold">Subscribers</strong>: Subscribers subscribe to one or more topics and receive any messages published under those topics. In <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.2</em>, the PC is subscribed to both the <strong class="source-inline">IoTAlarm</strong> and <strong class="source-inline">temp</strong> topics, while the phone is only subscribed to the <span class="No-Break"><strong class="source-inline">IoTAlarm</strong></span><span class="No-Break"> topic.</span></li>
</ul>
<p>Topics in MQTT serve as channels or communication pathways. We may think of topics as labels or categories that messages fall under, such as the <strong class="source-inline">IoTAlarm</strong> and <strong class="source-inline">temp</strong> topics marked with black boxes with white lettering in <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.2</em>. When a publisher sends a message to a specific topic, the MQTT broker (server) manages <span class="No-Break">the message.</span></p>
<p>The broker maintains a list of all subscribers to that topic, guaranteeing message delivery to each. This mechanism allows for efficient and selective communication because devices only receive messages from topics they have subscribed to. In <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.2</em>, we see our PC subscribing to the <strong class="source-inline">IoTAlarm</strong> and <strong class="source-inline">temp</strong> topics and our phone subscribing to<a id="_idIndexMarker465"/> only the <span class="No-Break"><strong class="source-inline">IoTAlarm</strong></span><span class="No-Break"> topic:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer102">
<img alt="Figure 6.2 – MQTT communications illustrated" height="642" src="image/B21282_06_2.jpg" width="1210"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – MQTT communications illustrated</p>
<p>Before we try some hands-on experience with MQTT, we will look at <strong class="bold">Quality-of-Service</strong> (<strong class="bold">QoS</strong>) levels<a id="_idIndexMarker466"/> in <a id="_idIndexMarker467"/>MQTT. Understanding QoS levels is crucial as they determine the reliability and delivery assurance of messages <span class="No-Break">in MQTT.</span></p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor096"/>Understanding QoS in MQTT</h2>
<p><strong class="bold">QoS</strong> is an important <a id="_idIndexMarker468"/>aspect of MQTT <a id="_idIndexMarker469"/>that determines the level of guarantee for message delivery between the MQTT broker (server) and MQTT clients (devices <span class="No-Break">or applications).</span></p>
<p>MQTT offers three levels <span class="No-Break">of QoS:</span></p>
<ul>
<li><strong class="bold">QoS 0 (At Most Once)</strong>: In this mode, the message is delivered at most once, meaning that the message may not be delivered to the recipient, and it may get lost without any acknowledgment or guarantee of receipt. This level of QoS is suitable for scenarios where message loss is acceptable and message delivery is <span class="No-Break">not critical.</span></li>
<li><strong class="bold">QoS 1 (At Least Once)</strong>: QoS 1 ensures that the message is delivered at least once to the recipient. If the broker or client doesn’t receive an acknowledgment (<strong class="source-inline">ACK</strong>) that the message was received, it will resend the message. This level of QoS guarantees that the message is received by the recipient but may result in <span class="No-Break">duplicate messages.</span></li>
<li><strong class="bold">QoS 2 (Exactly Once)</strong>: QoS 2 provides the highest level of guarantee. It ensures that the message is delivered exactly once to the recipient. This level of QoS involves a more complex handshake between the sender and receiver to ensure no duplicates or message <span class="No-Break">loss occur.</span></li>
</ul>
<p>For our development purposes, QoS 0 is adequate, as it offers reasonable message delivery without the need for the more intricate message tracking and acknowledgment mechanisms required by QoS 1 and QoS 2. QoS 0 simplifies message handling in code, making it a practical choice for <span class="No-Break">development scenarios.</span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor097"/>Exploring MQTT fundamentals with the MQTTHQ web client</h2>
<p>To acquire <a id="_idIndexMarker470"/>practical knowledge of <a id="_idIndexMarker471"/>MQTT, we’ll utilize the <strong class="bold">MQTTHQ web client</strong>. This web-based service streamlines the process of learning MQTT, eliminating the need for complex installations or extensive programming. As a public resource aimed at development and testing, it provides an accessible environment for us to explore and understand the features <span class="No-Break">of MQTT.</span></p>
<p>We begin by opening the web client in a <span class="No-Break">web browser:</span></p>
<ol>
<li>In our browser, we navigate to the client using the following <span class="No-Break">URL: </span><a href="https://mqtthq.com/client"><span class="No-Break">https://mqtthq.com/client</span></a><span class="No-Break">.</span></li>
<li>To ensure that we can use the client for our testing, we verify that we are connected to <a href="https://public.mqtthq.com/">public.mqtthq.com</a> from the message at the top right of <span class="No-Break">the screen:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer103">
<img alt="Figure 6.3 – Connected to the mqtthq.com client" height="101" src="image/B21282_06_3.jpg" width="407"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Connected to the mqtthq.com client</p>
<p class="list-inset">If the <a id="_idIndexMarker472"/>message<a id="_idIndexMarker473"/> indicating <em class="italic">connected</em> does not appear, we continue refreshing the page until <span class="No-Break">it does.</span></p>
<ol>
<li value="3">In the <strong class="bold">Subscribe to topic</strong> section, we change the topic to <strong class="source-inline">IoTAlarm</strong>, keep the <strong class="bold">QoS</strong> level at <strong class="source-inline">0</strong>, and click on the <span class="No-Break"><strong class="bold">Subscribe</strong></span><span class="No-Break"> button.</span></li>
<li>We should notice that the text under <strong class="bold">Received payloads</strong> updates to display <strong class="bold">Waiting for data…</strong> and the <strong class="bold">Subscribe</strong> button has turned into an <span class="No-Break"><strong class="bold">Unsubscribe</strong></span><span class="No-Break"> button:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer104">
<img alt="Figure 6.4 – Subscribing to the IoTAlarm topic" height="418" src="image/B21282_06_4.jpg" width="801"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Subscribing to the IoTAlarm topic</p>
<ol>
<li value="5">In the <strong class="bold">Publish to topic</strong> section, we<a id="_idIndexMarker474"/> change<a id="_idIndexMarker475"/> the topic to <strong class="source-inline">IoTAlarm</strong>, keep the <strong class="bold">QoS</strong> level at <strong class="source-inline">0</strong>, replace the <strong class="source-inline">Hello World!</strong> message with <strong class="source-inline">motion</strong>, and then click on the <span class="No-Break"><strong class="bold">Publish</strong></span><span class="No-Break"> button:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer105">
<img alt="Figure 6.5 – Publishing a message to the IoTAlarm topic" height="487" src="image/B21282_06_5.jpg" width="796"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Publishing a message to the IoTAlarm topic</p>
<ol>
<li value="6">We should <a id="_idIndexMarker476"/>notice <a id="_idIndexMarker477"/>that our <strong class="source-inline">motion</strong> message has now appeared under the <strong class="bold">Received payloads</strong> box in the <strong class="bold">Subscribe to </strong><span class="No-Break"><strong class="bold">topic</strong></span><span class="No-Break"> section:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer106">
<img alt="Figure 6.6 – MQTT message received" height="377" src="image/B21282_06_6.jpg" width="797"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – MQTT message received</p>
<ol>
<li value="7">To confirm that we are successfully sending MQTT messages from a publisher to a subscriber, we can use two separate computers: one to publish messages and the other to subscribe and <span class="No-Break">receive them.</span></li>
</ol>
<p>Through this exercise, we have effectively demonstrated the process of publishing and subscribing to MQTT messages using the MQTTHQ web client. In the next section, we will start building our<a id="_idIndexMarker478"/> IoT <a id="_idIndexMarker479"/>alarm module by leveraging the capabilities of the Raspberry Pi <span class="No-Break">Pico W.</span></p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor098"/>Using a Raspberry Pi Pico W with MQTT</h1>
<p>In this section, we will build <a id="_idIndexMarker480"/>the physical alarm part of <a id="_idIndexMarker481"/>our application using a <strong class="bold">Raspberry Pi Pico W</strong>. This microcontroller not only is affordable but also brings a range of capabilities to our project, allowing us to execute tasks efficiently without the full <a id="_idIndexMarker482"/>power of a <strong class="bold">Single-Board Computer</strong> (<strong class="bold">SBC</strong>) such as the <span class="No-Break">Raspberry Pi.</span></p>
<p>The Raspberry Pi Pico W doesn’t replace our Raspberry Pi; it complements it, adding unique strengths to our toolkit. Being a microcontroller, the Pico W is substantially more cost-effective compared to the Raspberry Pi, and it typically doesn’t heat up as much due to its simpler architecture and lower power consumption. This distinction is pivotal for projects such as our IoT alarm module, where the primary task is to capture sensory data – a function that does not require the computational power of an SBC. This allows us to reserve our Raspberry Pi for tasks that demand more <span class="No-Break">computational resources.</span></p>
<p>Being a microcontroller, our Raspberry Pi Pico W boots up quickly, providing a rapid start for our program. We do not need to load a heavy <span class="No-Break">operating system.</span></p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor099"/>Introducing the RP2040 chip</h2>
<p>The Raspberry Pi Pico <a id="_idIndexMarker483"/>W utilizes the dual-core <a id="_idIndexMarker484"/>ARM Cortex-M0+ processor RP2040 chip created by the Raspberry Pi Foundation. This chip was designed as a bridge between microcontrollers and microcomputers by merging the streamlined operation typical of microcontrollers with the capacity to undertake more demanding <span class="No-Break">microcomputer-type tasks.</span></p>
<p>The <em class="italic">W</em> in our Raspberry Pi Pico W denotes that our microcontroller supports Wi-Fi. Besides the Raspberry Pi Pico W, there is the standard Pico (without Wi-Fi), the Pico H (without Wi-Fi and with soldered headers), and the Pico WH (with Wi-Fi and <span class="No-Break">soldered headers).</span></p>
<p>The RP2040 chip our Raspberry Pi Pico W is based on may also be found on other microcontrollers such as the <em class="italic">Arduino Nano RP2040 Connect</em>, <em class="italic">Pimoroni Tiny 2040</em>, and <em class="italic">Adafruit Feather RP2040</em>. In <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.7</em>, we see a Waveshare RP2040-Zero-M (<em class="italic">A</em>) a Raspberry Pi <a id="_idIndexMarker485"/>Pico (<em class="italic">B</em>), and a Raspberry Pi<a id="_idIndexMarker486"/> Pico <span class="No-Break">W (</span><span class="No-Break"><em class="italic">C</em></span><span class="No-Break">):</span></p>
<div>
<div class="IMG---Figure" id="_idContainer107">
<img alt="Figure 6.7 – RP2040-based microcontrollers" height="504" src="image/B21282_06_7.jpg" width="921"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – RP2040-based microcontrollers</p>
<p>To construct our alarm circuit on a breadboard, we need headers on our Raspberry Pi Pico W. We can <a id="_idIndexMarker487"/>either solder them on ourselves or choose to purchase the Pico <span class="No-Break">WH version.</span></p>
<p>We will start the construction of our IoT alarm module by building out the circuit on <span class="No-Break">a breadboard.</span></p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor100"/>Configuring our alarm circuit</h2>
<p>In this section, we’ll <a id="_idIndexMarker488"/>build our alarm<a id="_idIndexMarker489"/> circuit using an SFM-27 active buzzer, an LED with a resistor, and an HC-SR501 PIR sensor. We will configure our circuit on a breadboard before moving our components to a 3D-printed case. We may use a Raspberry Pi Pico GPIO expander in place of a breadboard. For the breadboard, we use male jumpers soldered to our components for connection to the breadboard. For the GPIO expander, we use female jumper wires soldered to our components <span class="No-Break">for connections.</span></p>
<p>In <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.8</em>, we can see our circuit illustrated in a Fritzing diagram. To create our circuit, we wire our components to our Raspberry Pi Pico W with the connections outlined in <span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.8</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer108">
<img alt="Figure 6.8 – Raspberry Pi Pico W alarm circuit" height="1514" src="image/B21282_06_8.jpg" width="838"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – Raspberry Pi Pico W alarm circuit</p>
<p>It’s important to note our connection to the VBUS port on the Raspberry Pi Pico W. When the Pico is powered via USB, components connected to the VBUS port will receive approximately 5V, which is the standard USB voltage. We will be powering our IoT alarm module through the <span class="No-Break">USB port.</span></p>
<p>The following table outlines the power ports on the Raspberry Pi Pico W and provides insights into how <a id="_idIndexMarker490"/>we might utilize <a id="_idIndexMarker491"/>them in <span class="No-Break">future projects:</span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Port</strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Input </strong><span class="No-Break"><strong class="bold">Voltage Use</strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Output </strong><span class="No-Break"><strong class="bold">Voltage Use</strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">VBUS</span></p>
</td>
<td class="No-Table-Style">
<p>Used to supply power from a 5V <span class="No-Break">USB source.</span></p>
</td>
<td class="No-Table-Style">
<p>Can be used to supply 5V to external components when the Pico <span class="No-Break">is USB-powered.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">VSYS</span></p>
</td>
<td class="No-Table-Style">
<p>Accepts an external power supply ranging from 1.8V <span class="No-Break">to 5.5V.</span></p>
</td>
<td class="No-Table-Style">
<p>Not typically used to supply power to <span class="No-Break">external components.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">3V3(OUT)</span></p>
</td>
<td class="No-Table-Style">
<p>Not commonly used <span class="No-Break">for input.</span></p>
</td>
<td class="No-Table-Style">
<p>Provides a regulated 3.3V supply to power external <span class="No-Break">3.3V components.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">3V3_EN</span></p>
</td>
<td class="No-Table-Style">
<p>Not a power supply port, but a control pin to enable/disable the <span class="No-Break">3.3V supply.</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break">Not applicable.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 6.1 – Power ports on the Raspberry Pi Pico (W)</p>
<p>With our circuit <a id="_idIndexMarker492"/>wired up, we are ready <a id="_idIndexMarker493"/>to start coding. We will start by setting up Thonny for <span class="No-Break">microcontroller development.</span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor101"/>Setting up our development environment</h2>
<p>As with all<a id="_idIndexMarker494"/> the<a id="_idIndexMarker495"/> software development we have done so far, we will use Thonny as our <strong class="bold">Integrated Development Environment</strong> (<strong class="bold">IDE</strong>). The <a id="_idIndexMarker496"/>choice of Thonny’s OS version (Windows, macOS, Linux, Raspberry Pi OS, and so on) is flexible since our focus is on writing code for a connected microcontroller rather than the computer used <span class="No-Break">for coding.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">It’s important to note that different OS versions of Thonny may exhibit varying levels of functionality necessary for this chapter. The content in this section is based on the Windows version of Thonny, and the screenshots provided <span class="No-Break">reflect this.</span></p>
<p>We’ll develop our <a id="_idIndexMarker497"/>code using <strong class="bold">MicroPython</strong>, a lightweight version of Python optimized for microcontrollers. MicroPython shares core syntax and functionality with Python, but it’s important to note that due to its focus on resource-constrained environments, it may lack some of the extensive libraries and features available in standard Python. These differences, however, are a trade-off for the efficiencies of MicroPython when used for <span class="No-Break">microcontroller programming.</span></p>
<p>To install <a id="_idIndexMarker498"/>MicroPython on our <a id="_idIndexMarker499"/>Raspberry Pi Pico W, we do <span class="No-Break">the following:</span></p>
<ol>
<li>If Thonny is not available on our operating system, we visit the Thonny website and download an appropriate <span class="No-Break">version (</span><a href="https://thonny.org"><span class="No-Break">https://thonny.org</span></a><span class="No-Break">).</span></li>
<li>We then launch Thonny using the appropriate method for our <span class="No-Break">operating system.</span></li>
<li>While holding the <em class="italic">BOOTSEL</em> button on the Pico W (the small white button near the USB port), we insert it into an available USB port and disregard any pop-up windows that <span class="No-Break">may appear.</span></li>
<li>We then click on the interpreter information at the bottom right-hand side of the screen and select <span class="No-Break"><strong class="bold">Install MicroPython…</strong></span><span class="No-Break">:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer109">
<img alt="Figure 6.9 – Install MicroPython… option" height="140" src="image/B21282_06_9.jpg" width="643"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – Install MicroPython… option</p>
<ol>
<li value="5">For the <strong class="bold">MicroPython variant</strong>, we select <strong class="bold">Raspberry Pi • Pico W / </strong><span class="No-Break"><strong class="bold">Pico WH</strong></span><span class="No-Break">:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer110">
<img alt="Figure 6.10 – Installing MicroPython on the Raspberry Pi Pico W" height="537" src="image/B21282_06_10.jpg" width="582"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – Installing MicroPython on the Raspberry Pi Pico W</p>
<ol>
<li value="6">We click <a id="_idIndexMarker500"/>on <a id="_idIndexMarker501"/>the <strong class="bold">Install</strong> button and then the <strong class="bold">Close</strong> button once the installation has <span class="No-Break">been completed.</span></li>
<li>To have Thonny configured to run the MicroPython interpreter on our Pico W, we select it from the bottom right-hand side of <span class="No-Break">the screen:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer111">
<img alt="Figure 6.11 – Selecting the MicroPython interpreter from our Pico W" height="140" src="image/B21282_06_11.jpg" width="643"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11 – Selecting the MicroPython interpreter from our Pico W</p>
<ol>
<li value="8">We confirm that Thonny is using the MicroPython interpreter on our Raspberry Pi Pico W by <a id="_idIndexMarker502"/>checking<a id="_idIndexMarker503"/> <span class="No-Break">the </span><span class="No-Break"><strong class="bold">Shell</strong></span><span class="No-Break">:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer112">
<img alt="Figure 6.12 – MicroPython prompt in Thonny" height="223" src="image/B21282_06_12.jpg" width="854"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12 – MicroPython prompt in Thonny</p>
<ol>
<li value="9">To run the MQTT code, we will require an MQTT library to be installed. To do so, we select <strong class="bold">Tools</strong> | <strong class="bold">Manage packages….</strong>, enter <strong class="source-inline">umqtt</strong> in the search box, and click on <strong class="bold">Search </strong><span class="No-Break"><strong class="bold">on PyPI</strong></span><span class="No-Break">:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer113">
<img alt="Figure 6.13 – Installing an MQTT library onto our Pico W" height="601" src="image/B21282_06_13.jpg" width="823"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13 – Installing an MQTT library onto our Pico W</p>
<ol>
<li value="10">We select the <strong class="source-inline">micropython-umqtt.simple</strong> package and click on the <span class="No-Break"><strong class="bold">Install</strong></span><span class="No-Break"> button.</span></li>
<li>We then close the dialog by clicking on the <span class="No-Break"><strong class="bold">Close</strong></span><span class="No-Break"> button.</span></li>
</ol>
<p>Now that we have MicroPython and an MQTT library installed on our Raspberry Pi Pico W, we’re <a id="_idIndexMarker504"/>prepared to begin <a id="_idIndexMarker505"/>coding. Our initial focus will be on connecting the components, followed by the implementation of <span class="No-Break">MQTT-related code.</span></p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor102"/>Writing the alarm module client code</h2>
<p>By now, we <a id="_idIndexMarker506"/>should be well<a id="_idIndexMarker507"/> acquainted with the Thonny IDE. Connecting to the MicroPython interpreter on the Raspberry Pi Pico W doesn’t significantly alter our interaction <span class="No-Break">with Thonny.</span></p>
<p>Nonetheless, it’s advantageous for our development process to have visibility into files stored on both the Pico W and our computer. This visibility allows us to easily verify file locations and manage our <span class="No-Break">project effectively.</span></p>
<p>To open the <strong class="bold">Files</strong> view in Thonny, we click on the <strong class="bold">View</strong> menu at the top and <span class="No-Break">select </span><span class="No-Break"><strong class="bold">Files</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer114">
<img alt="Figure 6.14 – Enabling Files view in Thonny" height="116" src="image/B21282_06_14.jpg" width="221"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.14 – Enabling Files view in Thonny</p>
<p>We should see a view of our project files on both the Raspberry Pi Pico W and our computer on<a id="_idIndexMarker508"/> the left-hand <a id="_idIndexMarker509"/>side <span class="No-Break">of Thonny.</span></p>
<p>We are now ready to start writing code. We will start with <span class="No-Break">the buzzer.</span></p>
<h3>Activating the buzzer through code</h3>
<p><span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.1</em> illustrates an <strong class="source-inline">IoTAlarm</strong> type message sent from the MQTT broker to our Raspberry Pi Pico W. This <a id="_idIndexMarker510"/>message serves the purpose of activating the buzzer in our alarm module. To handle this task, we’ll create a separate program. Activating the buzzer involves a slightly more complex process compared to monitoring the PIR sensor or LED components in our circuit, and thus a desire to separate <span class="No-Break">its code.</span></p>
<p>To do this, we do <span class="No-Break">the following:</span></p>
<ol>
<li>We connect our Raspberry Pi Pico W to a USB port and launch Thonny. We may use our Raspberry Pi or another operating system <span class="No-Break">for this.</span></li>
<li>We then activate the MicroPython environment on our Pico W by selecting it from the bottom right-hand side of <span class="No-Break">the screen.</span></li>
<li>In a new editor tab, we enter the <span class="No-Break">following code:</span><pre class="source-code">
from machine import Pin, PWM
import utime
BUZZER_PIN = 16
buzzer = PWM(Pin(BUZZER_PIN))
BUZZER_FREQ = 4000
def activate_buzzer(duration=5):
    buzzer.freq(BUZZER_FREQ)
    buzzer.duty_u16(32768)
    utime.sleep(duration)
    buzzer.duty_u16(0)</pre></li> <li>To save the <a id="_idIndexMarker511"/>file, we click on <strong class="bold">File</strong> | <strong class="bold">Save as...</strong> from the drop-down menu. This will open the <span class="No-Break">following dialog:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer115">
<img alt="Figure 6.15 – Saving a file to our Raspberry Pi Pico W" height="246" src="image/B21282_06_15.jpg" width="272"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.15 – Saving a file to our Raspberry Pi Pico W</p>
<ol>
<li value="5">In this dialog, we are given the option to choose where to store our file. To save it on our Raspberry Pi Pico W, we click on the <span class="No-Break">corresponding button.</span></li>
<li>We then name the file <strong class="source-inline">buzzer.py</strong> and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">OK</strong></span><span class="No-Break">.</span><p class="list-inset">Before we test<a id="_idIndexMarker512"/> out our code, let’s break <span class="No-Break">it down:</span></p><ol><li class="upper-roman">We start by importing the <strong class="source-inline">Pin</strong> and <strong class="source-inline">PWM</strong> (for <strong class="bold">pulse-width modulation</strong>, or <strong class="bold">PWM</strong>) classes<a id="_idIndexMarker513"/> from the <span class="No-Break"><strong class="source-inline">machine</strong></span><span class="No-Break"> module.</span></li><li class="upper-roman">We import the <strong class="source-inline">utime</strong> class for <span class="No-Break">timer functionality.</span></li><li class="upper-roman">We set the <strong class="source-inline">BUZZER_PIN</strong> constant to 16. This corresponds to our wiring diagram for <span class="No-Break">the buzzer.</span></li><li class="upper-roman">We create a <strong class="source-inline">buzzer</strong> object by initializing the <strong class="source-inline">PWM</strong> class on the specified <strong class="source-inline">BUZZER_PIN</strong> constant. This PWM-based approach allows us to vary the voltage supplied to the buzzer rapidly, enabling control over the sound’s tone <span class="No-Break">and volume.</span></li><li class="upper-roman">We then set the <strong class="source-inline">BUZZER_FREQ</strong> constant to <strong class="source-inline">4000</strong>, representing the frequency of the PWM signal used for <span class="No-Break">the buzzer.</span></li><li class="upper-roman">We then define an <strong class="source-inline">activate_buzzer()</strong> function. This function takes an optional <strong class="source-inline">duration</strong> parameter (default is <span class="No-Break">5 seconds).</span></li><li class="upper-roman">Inside the <strong class="source-inline">activate_buzzer()</strong> function, we do <span class="No-Break">the following:</span><ol><li class="lower-roman">We set the frequency of the <strong class="source-inline">buzzer</strong> object to the specified <span class="No-Break"><strong class="source-inline">BUZZER_FREQ</strong></span><span class="No-Break"> constant.</span></li><li class="lower-roman">We set the buzzer’s duty cycle to 50% (32768 out of the full 16-bit range of 65536), creating a balanced tone, with the buzzer active for half of the signal’s 16-bit cycle and inactive for the <span class="No-Break">other half.</span></li><li class="lower-roman">Our code then pauses the program for the specified duration in seconds using the <span class="No-Break"><strong class="source-inline">utime.sleep()</strong></span><span class="No-Break"> function.</span></li><li class="lower-roman">After the specified duration, set the duty cycle of the <strong class="source-inline">buzzer</strong> object back to <strong class="source-inline">0</strong>, turning off <span class="No-Break">the buzzer.</span></li></ol></li></ol></li>
</ol>
<p>We can test our code <a id="_idIndexMarker514"/>using the Shell in Thonny. To do so, we do <span class="No-Break">the following:</span></p>
<ol>
<li>In the Shell, we import the <strong class="source-inline">activate_buzzer()</strong> function from the <span class="No-Break">buzzer file:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer116">
<img alt="Figure 6.16 – Importing the activate_buzzer() function" height="267" src="image/B21282_06_16.jpg" width="911"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.16 – Importing the activate_buzzer() function</p>
<ol>
<li value="2">With the function imported, we can run it by simply calling it and hitting <em class="italic">Enter</em> on <span class="No-Break">the keyboard:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer117">
<img alt="Figure 6.17 – Activating the buzzer" height="267" src="image/B21282_06_17.jpg" width="1012"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.17 – Activating the buzzer</p>
<ol>
<li value="3">With our buzzer wired correctly, we should hear it sound for 5 seconds. To adjust the duration, we simply pass another value into the <span class="No-Break"><strong class="source-inline">activate_buzzer()</strong></span><span class="No-Break"> function.</span></li>
</ol>
<p>We must congratulate<a id="_idIndexMarker515"/> ourselves as we have just written and executed our first MicroPython program! With the buzzer code done, it is time to create the main program for our <span class="No-Break">alarm module.</span></p>
<h3>Creating the main code</h3>
<p>In this section, we <a id="_idIndexMarker516"/>will write the code to power our IoT alarm module. In this code, we will connect to the PIR sensor and LED, as well as the Wi-Fi and <span class="No-Break">MQTT broker.</span></p>
<p>In MicroPython, two files control Pico W’s startup and code execution: <strong class="source-inline">boot.py</strong> handles essential initialization during boot, while <strong class="source-inline">main.py</strong> contains the primary user code for custom logic <span class="No-Break">and functions.</span></p>
<p>For our code, we won’t concern ourselves with <strong class="source-inline">boot.py</strong>. We will, however, concentrate on <strong class="source-inline">main.py</strong>, the program responsible for launching our application on Pico W when it is <span class="No-Break">first powered.</span></p>
<p>To write our IoT alarm module code, we do <span class="No-Break">the following:</span></p>
<ol>
<li>In a new tab in Thonny, we start by entering our code <span class="No-Break">for imports:</span><pre class="source-code">
import machine
import utime
import network
import _thread
from umqtt.simple import MQTTClient
from buzzer import activate_buzzer</pre><p class="list-inset">In our preceding code, we have <span class="No-Break">the following:</span></p><ul><li><strong class="source-inline">machine</strong>: Provides access to hardware-related functions and classes for <span class="No-Break">our microcontroller.</span></li><li><strong class="source-inline">utime</strong>: Offers time-related functions and timing control for managing delays <span class="No-Break">and timestamps.</span></li><li><strong class="source-inline">network</strong>: Provides network-related functions for configuring and managing <span class="No-Break">network connections.</span></li><li><strong class="source-inline">_thread</strong>: Allows creating and managing threads for concurrent execution <span class="No-Break">of code.</span></li><li><strong class="source-inline">MQTTClient</strong> (from <strong class="source-inline">umqtt.simple</strong>): Provides MQTT client functionality for communication <span class="No-Break">over MQTT.</span></li><li><strong class="source-inline">activate_buzzer</strong> (from <strong class="source-inline">buzzer</strong>): Our custom function for activating <span class="No-Break">a buzzer.</span></li></ul></li> <li>We then<a id="_idIndexMarker517"/> set <span class="No-Break">our variables:</span><pre class="source-code">
SSID = "WiFiNetworkName"
PASSWORD = "xxxxxxxxx"
MQTT_SERVER = "broker.mqtthq.com"
MQTT_PORT = 1883
pir = machine.Pin(26, machine.Pin.IN)
led = machine.Pin(21, machine.Pin.OUT)
wlan = network.WLAN(network.STA_IF)
mqtt_client = None</pre><p class="list-inset">In the preceding code, we have the <span class="No-Break">following variables:</span></p><ul><li><strong class="source-inline">SSID</strong>: Variable storing the name (SSID) of the Wi-Fi network our program <span class="No-Break">connects to</span></li><li><strong class="source-inline">PASSWORD</strong>: Variable storing the password for the <span class="No-Break">Wi-Fi network</span></li><li><strong class="source-inline">MQTT_SERVER</strong>: Variable storing the MQTT broker’s/server’s address (we will be <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">broker.mqtt.com</strong></span><span class="No-Break">)</span></li><li><strong class="source-inline">MQTT_PORT</strong>: Variable storing the MQTT <span class="No-Break">port number</span></li><li><strong class="source-inline">pir</strong>: Configures a GPIO pin 26 as an input pin for our <span class="No-Break">PIR sensor</span></li><li><strong class="source-inline">led</strong>: Configures a GPIO pin 21 as an output pin to control <span class="No-Break">our LED</span></li><li><strong class="source-inline">wlan</strong>: Initializes a WLAN (Wi-Fi) interface for connecting to a Wi-Fi network in the station (client) mode, allowing our MicroPython device to act as a client and join an existing wireless network. This initialization is essential, as it allows our Pico W to connect to an existing Wi-Fi network, enabling <span class="No-Break">networked communication</span></li></ul></li> <li>After defining<a id="_idIndexMarker518"/> our variables, we create a function to connect our Raspberry Pi Pico W to our <span class="No-Break">Wi-Fi network:</span><pre class="source-code">
def connect_wifi():
    wlan.active(True)
    wlan.connect(SSID, PASSWORD)
    while not wlan.isconnected():
        print('Trying to connect to WiFi...')
        utime.sleep(5)
    print('WIFI connection established')</pre><p class="list-inset">In our code, we have <span class="No-Break">the following:</span></p><ul><li><strong class="source-inline">wlan.active(True)</strong>: Activates the <span class="No-Break">Wi-Fi interface</span></li><li><strong class="source-inline">wlan.connect(SSID, PASSWORD)</strong>: Initiates the connection to the Wi-Fi network using the specified SSID (network name) and password (<span class="No-Break">network password)</span></li><li><strong class="source-inline">while not wlan.isconnected():</strong>: This loop continuously checks whether the device is connected to the <span class="No-Break">Wi-Fi network:</span><ul><li><strong class="source-inline">print('Trying to connect to WiFi...')</strong>: If not connected, it prints a message indicating the ongoing <span class="No-Break">connection attempt</span></li><li><strong class="source-inline">utime.sleep(5)</strong>: It pauses for 5 seconds before checking the connection <span class="No-Break">status again</span></li></ul></li><li><strong class="source-inline">print('WIFI connection established')</strong>: Once connected, our code prints a message confirming the successful connection to the <span class="No-Break">Wi-Fi network</span></li></ul></li> <li>With our <a id="_idIndexMarker519"/>Wi-Fi connection function in place, we then add a function responsible for handling the <strong class="source-inline">buzzer</strong> message received from our <span class="No-Break">MQTT broker:</span><pre class="source-code">
def sub_iotalarm(topic, msg):
    print((topic, msg))
    if topic == b'IoTAlarm' and msg == b'buzzer':
        print("buzzer is detected")
        activate_buzzer()</pre><p class="list-inset">In our code, the <span class="No-Break">following happens:</span></p><ol><li class="upper-roman">Our <strong class="source-inline">sub_iotalarm()</strong> function handles incoming MQTT messages by first printing the topic and <span class="No-Break">message received</span></li><li class="upper-roman">If the topic is <strong class="source-inline">IoTAlarm</strong> and the message is <strong class="source-inline">buzzer</strong>, it calls the <strong class="source-inline">activate_buzzer()</strong> function to trigger <span class="No-Break">the buzzer</span></li></ol></li> <li>The <strong class="source-inline">motion_handler()</strong> function is responsible for handling motion detection events, printing notifications, and, if the MQTT client is connected, publishing a <strong class="source-inline">motion</strong> message to the <span class="No-Break"><strong class="source-inline">IoTAlarm</strong></span><span class="No-Break"> topic:</span><pre class="source-code">
def motion_handler(pin):
    print('Motion detected!!')
    if mqtt_client is not None:
        mqtt_client.publish(b"IoTAlarm", b"motion")
    else:
        print("MQTT client is not connected.")</pre><p class="list-inset">In our code, the <span class="No-Break">following happens:</span></p><ol><li class="upper-roman">Our <strong class="source-inline">motion_handler()</strong> function takes in a parameter called <strong class="source-inline">pin</strong>. This parameter<a id="_idIndexMarker520"/> is needed as a placeholder for the interrupt handler’s expected argument; even though we don’t use it within the function, it is required to maintain compatibility with the <span class="No-Break">interrupt system.</span></li><li class="upper-roman">We use the <strong class="source-inline">b</strong> prefix to denote that the string (<strong class="source-inline">IoTAlarm</strong> and <strong class="source-inline">motion</strong>) should be treated as a byte object rather than a text (Unicode) string, which is required for sending binary data in protocols such <span class="No-Break">as MQTT.</span></li></ol></li> <li>The <strong class="source-inline">connect_mqtt()</strong> function establishes a connection between our code and the <span class="No-Break">MQTT broker:</span><pre class="source-code">
def connect_mqtt(device_id, callback):
    global mqtt_client
    while mqtt_client is None:
        try:
            print("Trying to connect to
   MQTT Server...")
            mqtt_client = MQTTClient(
                                      device_id,
                                      MQTT_SERVER,
                                      MQTT_PORT)
            mqtt_client.set_callback(callback)
            mqtt_client.connect()
            print('MQTT connection established')
        except:
            mqtt_client = None
            print('Failed to connect to MQTT Server, retrying...')
            utime.sleep(5)</pre><p class="list-inset">In our code, the <span class="No-Break">following happens:</span></p><ol><li class="upper-roman">The <strong class="source-inline">connect_mqtt()</strong> function establishes a connection between our code and the MQTT server, taking two parameters: <strong class="source-inline">device_id</strong> for device identification<a id="_idIndexMarker521"/> and <strong class="source-inline">callback</strong> for specifying a function that processes incoming messages (known as a callback function). The <strong class="source-inline">device_id</strong> parameter is a unique identifier assigned to each MQTT client, allowing our MQTT broker to distinguish specific devices on <span class="No-Break">the network.</span></li><li class="upper-roman">Within the <strong class="source-inline">while</strong> loop, our code attempts to connect to the MQTT server using the given device ID, configures the <strong class="source-inline">callback</strong> function to handle messages, and successfully establishes an MQTT connection. If the connection encounters any issues, our function retries after a <span class="No-Break">5-second pause.</span></li></ol></li> </ol>
<p class="callout-heading">What is a callback function?</p>
<p class="callout">In the context of our IoT alarm system, a callback function is used as part of the MQTT communication process. In our code, we use the <strong class="source-inline">sub_iotalarm()</strong> function as the callback, which means that when relevant MQTT messages are received from the MQTT broker, the <strong class="source-inline">sub_iotalarm()</strong> function is automatically invoked. Inside our callback function, we have defined specific actions to be taken based on the received messages, such as activating <span class="No-Break">the buzzer.</span></p>
<ol>
<li value="7">The final method controls the LED’s blinking pattern, indicating the application’s connection status, and enables troubleshooting when the Raspberry Pi Pico W is running<a id="_idIndexMarker522"/> independently from <span class="No-Break">a computer:</span><pre class="source-code">
def connection_status():
    while True:
        if wlan.isconnected():
            if mqtt_client is not None:
                led.on()  # Steady on when both WiFi and MQTT connected
            else:
                led.on()  # Blink every half-second when only WiFi is connected
                utime.sleep(0.5)
                led.off()
                utime.sleep(0.5)
        else:
            led.on()  # Blink every second when WiFi is not connected
            utime.sleep(1)
            led.off()
            utime.sleep(1)</pre><p class="list-inset">In our code, we have <span class="No-Break">the following:</span></p><ul><li><strong class="source-inline">Steady On</strong>: The LED remains constantly on when both Wi-Fi and MQTT are connected. This occurs when Wi-Fi is connected (<strong class="source-inline">wlan.isconnected()</strong> is <strong class="source-inline">True</strong>) and there is a value <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">mqtt_client</strong></span><span class="No-Break">.</span></li><li><strong class="source-inline">Fast Blink</strong>: When only Wi-Fi is connected (MQTT client is <strong class="source-inline">None</strong>), the LED blinks rapidly <span class="No-Break">every half-second.</span></li><li><strong class="source-inline">Slow Blink</strong>: When neither Wi-Fi nor MQTT is connected, the LED blinks more slowly, with a 1-second interval for on and <span class="No-Break">off states.</span></li></ul></li> <li>To enable independent execution of the <strong class="source-inline">connection_status()</strong> function, our code starts a new thread. Threading enables concurrent execution of multiple tasks or functions, making <a id="_idIndexMarker523"/>efficient use of the RP2040’s dual-core processor to run distinct <span class="No-Break">operations simultaneously:</span><pre class="source-code">
_thread.start_new_thread(connection_status, ())</pre></li> <li>Our code then calls functions to connect to the Wi-Fi and MQTT broker using a unique client <span class="No-Break">ID, </span><span class="No-Break"><strong class="source-inline">IoTAlarmSystem</strong></span><span class="No-Break">:</span><pre class="source-code">
connect_wifi()
connect_mqtt("IoTAlarmSystem", sub_iotalarm)</pre></li> <li>We then subscribe to the <span class="No-Break"><strong class="source-inline">IoTAlarm</strong></span><span class="No-Break"> message:</span><pre class="source-code">
mqtt_client.subscribe("IoTAlarm")</pre></li> <li>To enable our PIR sensor, we set its <strong class="source-inline">irq()</strong> method with <span class="No-Break">the following:</span><pre class="source-code">
pir.irq(trigger=machine.Pin.IRQ_RISING,
handler=motion_handler)</pre><p class="list-inset">In our code, the <span class="No-Break">following happens:</span></p><ol><li class="upper-roman">An <strong class="bold">interrupt request</strong> (<strong class="bold">IRQ</strong>) triggers<a id="_idIndexMarker524"/> when the pin detects a rising edge, indicating a change from low to <span class="No-Break">high voltage.</span></li><li class="upper-roman">When an IRQ is triggered, the <strong class="source-inline">motion_handler()</strong> function is invoked to publish a <strong class="source-inline">motion</strong> message to the <span class="No-Break">MQTT broker.</span></li></ol></li> <li>In an infinite loop, we wait for <span class="No-Break">a message:</span><pre class="source-code">
while True:
    mqtt_client.wait_msg()</pre><p class="list-inset">Once a message is received it is processed by the callback function, which we defined as <strong class="source-inline">sub_iotalarm()</strong> earlier in <span class="No-Break">the code.</span></p></li> <li>We save the code as <strong class="source-inline">main.py</strong> onto our Raspberry Pi Pico W to ensure that when we power it on or reset it, our code runs automatically. This is standard <span class="No-Break">with MicroPython.</span></li>
</ol>
<p>With the code <a id="_idIndexMarker525"/>written, it is time to test it out with the MQTTHQ <span class="No-Break">web client.</span></p>
<h3>Running our alarm module application</h3>
<p>We have two <a id="_idIndexMarker526"/>options for<a id="_idIndexMarker527"/> running the code on our Raspberry Pi Pico W. One is to power up the Pico W with a standard USB power cable, which is suitable for use after testing, but it won’t provide access to debug print messages. The second option is to run our code in Thonny. This will allow us to troubleshoot any issues we encounter. To do this, we follow <span class="No-Break">these steps:</span></p>
<ol>
<li>We select the <strong class="source-inline">main.py</strong> tab in Thonny, ensuring that we pick the version installed on our Pico W rather than our <span class="No-Break">operating system.</span></li>
<li>We click on the green run button, hit <em class="italic">F5</em> on the keyboard, or click on the <strong class="bold">Run</strong> menu option at the top and then <strong class="bold">Run </strong><span class="No-Break"><strong class="bold">current script</strong></span><span class="No-Break">.</span></li>
<li>We should observe messages in the Shell that our code is connecting first to the Wi-Fi network and then to the <span class="No-Break">MQTT server.</span></li>
<li>We should also observe that our LED blinks accordingly, slowly before connecting to the Wi-Fi network, faster after connecting to the Wi-Fi network but before connecting to the MQTT server, and steady once both connections <span class="No-Break">are made.</span></li>
<li>Moving our hand in front of the PIR sensor, we should observe a <strong class="source-inline">Motion detected!!</strong> message followed by a message coming back from the <span class="No-Break">MQTT server:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer118">
<img alt="Figure 6.18 – Detecting motion with the PIR sensor" height="227" src="image/B21282_06_18.jpg" width="730"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.18 – Detecting motion with the PIR sensor</p>
<ol>
<li value="6">If we only <a id="_idIndexMarker528"/>receive<a id="_idIndexMarker529"/> a <strong class="source-inline">Motion detected!!</strong> message but not a message coming back from the MQTT server (broker), then our application has lost connection to the server. This should also be indicated by our LED flashing slowly. To fix this, we stop and restart our program using the <strong class="bold">Stop</strong> and <strong class="bold">Run</strong> <span class="No-Break">buttons respectively.</span></li>
<li>To verify that our code is sending MQTT messages, we follow the steps from the previous section, <em class="italic">Exploring MQTT fundamentals with the MQTTHQ web client</em>. After subscribing to the <strong class="source-inline">IoTAlarm</strong> topic, the web client should receive a <strong class="source-inline">motion</strong> message whenever our PIR sensor <span class="No-Break">is triggered:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer119">
<img alt="Figure 6.19 – Receiving motion messages" height="480" src="image/B21282_06_19.jpg" width="790"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.19 – Receiving motion messages</p>
<ol>
<li value="8">To test out our <a id="_idIndexMarker530"/>buzzer, we<a id="_idIndexMarker531"/> publish a <strong class="source-inline">buzzer</strong> message using the MQTTHQ <span class="No-Break">web client:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer120">
<img alt="Figure 6.20 – Publishing a buzzer message" height="488" src="image/B21282_06_20.jpg" width="793"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.20 – Publishing a buzzer message</p>
<ol>
<li value="9">After clicking the <strong class="bold">Publish</strong> button, we should hear our alarm sound for <span class="No-Break">5 seconds.</span></li>
</ol>
<p>We have now created our first MQTT application! We have sent MQTT messages from our Raspberry Pi Pico W to and from the internet. As we can imagine, the possibilities of our application are vast. For instance, we can extend our IoT alarm system by adding more sensors such as a door/window contact sensor for security, or a temperature and humidity sensor for home climate monitoring. In the next chapter, we will add monitoring and remote arming of our alarm module as we continue to build our IoT home <a id="_idIndexMarker532"/><span class="No-Break">security</span><span class="No-Break"><a id="_idIndexMarker533"/></span><span class="No-Break"> system.</span></p>
<p>To finish off our IoT alarm module, we will now install our components into a custom <span class="No-Break">3D-printed case.</span></p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor103"/>Building an IoT alarm module case</h1>
<p>As we have done <a id="_idIndexMarker534"/>previously, we will install our components into a custom-designed 3D-printed case. <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.21</em> features a rendering of our alarm module case, designed to accommodate the PIR sensor, buzzer, LED with a resistor, and the Raspberry Pi <span class="No-Break">Pico W.</span></p>
<p>In the interest of compactness, we’ve opted for the Raspberry Pi Pico W without headers, simplifying component fitting and wire soldering. It’s important to note that this choice is optional, and we can use the header-equipped Raspberry Pi <span class="No-Break">Pico WH:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer121">
<img alt="Figure 6.21 – Alarm module custom case" height="482" src="image/B21282_06_21.jpg" width="446"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.21 – Alarm module custom case</p>
<p>We will start by identifying the parts before we move on to constructing and then testing our IoT<a id="_idIndexMarker535"/> <span class="No-Break">alarm module.</span></p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor104"/>Identifying the parts of the custom case</h2>
<p>In <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.22</em>, we <a id="_idIndexMarker536"/>can see the parts required to assemble the custom case for our IoT <span class="No-Break">alarm module:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer122">
<img alt="Figure 6.22 – Parts for the alarm module" height="798" src="image/B21282_06_22.jpg" width="1211"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.22 – Parts for the alarm module</p>
<p>Let’s break down <span class="No-Break">each part:</span></p>
<ul>
<li><strong class="bold">Raspberry Pi Pico W</strong> (<em class="italic">A</em>): Header version (shown here), or header-less <span class="No-Break">version (preferred).</span></li>
<li><strong class="bold">Backplate</strong> (<em class="italic">B</em>): 3D <a id="_idIndexMarker537"/>printed<a id="_idIndexMarker538"/> using <strong class="bold">Polylactic Acid</strong> (<strong class="bold">PLA</strong>), <strong class="bold">Acrylonitrile Butadiene Styrene</strong> (<strong class="bold">ABS</strong>), or <strong class="bold">Polyethylene Terephthalate </strong><span class="No-Break"><strong class="bold">Glycol</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">PETG</strong></span><span class="No-Break">).</span></li>
<li><strong class="bold">Hook</strong> (<em class="italic">C</em>): 3D<a id="_idIndexMarker539"/> printed using PLA, ABS, PETG, or engineering-grade resin using a liquid resin printer (as shown here). For <strong class="bold">Fused Deposition Modeling</strong> (<strong class="bold">FDM</strong>) printers, the<a id="_idIndexMarker540"/> part should be printed on its side with supports <span class="No-Break">for strength.</span></li>
<li><strong class="bold">SFM-27 active buzzer</strong> (<em class="italic">D</em>): Case designed to fit <span class="No-Break">this buzzer.</span></li>
<li><strong class="bold">Side mount stand</strong> (<em class="italic">E</em>): 3D-printed optional stand for mounting alarm module on a wall. May be printed in PLA, ABS, PETG, or engineering-grade resin using a <a id="_idIndexMarker541"/>liquid resin printer (as <span class="No-Break">shown here).</span></li>
</ul>
<p class="callout-heading">Printing the split stand with FDM printers</p>
<p class="callout">The split stand in the SenseHAT case files (<strong class="source-inline">Build Files</strong> folder, <a href="B21282_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a> repository) is ideal for FDM printing. By splitting and printing each half on its side, the stand gains significant strength. An accompanying base is <span class="No-Break">also provided.</span></p>
<ul>
<li><strong class="bold">LED with resistor</strong> (<em class="italic">F</em>): Refer to <a href="B21282_03.xhtml#_idTextAnchor048"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> <span class="No-Break">for construction.</span></li>
<li><strong class="bold">LED holder</strong> (<em class="italic">G</em>): To hold LED into <span class="No-Break">the case.</span></li>
<li><strong class="bold">Front shell</strong> (<em class="italic">H</em>): 3D printed using PLA, ABS, <span class="No-Break">or PETG.</span></li>
<li><strong class="bold">HC-SR501 PIR sensor</strong> (<em class="italic">I</em>): Case designed to fit this <span class="No-Break">PIR sensor.</span></li>
<li>6 x M2 5 mm screws (<span class="No-Break">not shown).</span></li>
<li>2 x M4 10 mm bolts (<span class="No-Break">not shown).</span></li>
<li>2 x M4 nuts (<span class="No-Break">not shown).</span></li>
<li>4 x M3 10 mm bolts (<span class="No-Break">not shown).</span></li>
<li>Glue gun with a glue stick (<span class="No-Break">not shown).</span></li>
</ul>
<p class="callout-heading">What is an engineering-grade resin?</p>
<p class="callout">Liquid resin 3D printers<a id="_idIndexMarker542"/> function by creating shapes layer by layer using UV light to solidify liquid resin. Standard resins are typically used for small artistic prints, offering excellent detail but often resulting in brittle parts. Engineering resins such as Siraya Tech Blu, on the other hand, provide superior strength, making them suitable for functional components. Parts <em class="italic">C</em> and <em class="italic">E</em> in <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.22</em> were printed with an 80–20 mix of standard resin and Siraya Tech Tenacious, giving the parts more flexibility and reducing <span class="No-Break">their brittleness.</span></p>
<p>Files for the 3D-printed parts are in the <strong class="source-inline">Build Files</strong> directory of this chapter’s <span class="No-Break">GitHub repository.</span></p>
<p>Now that<a id="_idIndexMarker543"/> we have identified the parts needed to construct the case for our alarm module, let’s put <span class="No-Break">it together.</span></p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor105"/>Building the alarm module case</h2>
<p><span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.23</em> illustrates the<a id="_idIndexMarker544"/> steps to build the IoT alarm <span class="No-Break">module case:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer123">
<img alt="Figure 6.23 – Steps to build the alarm module case" height="897" src="image/B21282_06_23.jpg" width="1280"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.23 – Steps to build the alarm module case</p>
<p>To build the <a id="_idIndexMarker545"/>case, we do the following (the letters representing the different components in <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.23</em> are mentioned beside the respective component’s name in the <span class="No-Break">following steps):</span></p>
<ol>
<li>Using two M2 5 mm screws, we screw the hook (<em class="italic">C</em>) onto the backplate (<em class="italic">B</em>) (<span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.23</em>, <em class="italic">Step 1</em>). We may also use epoxy glue <span class="No-Break">for this.</span></li>
<li>Using four M2 5 mm screws, we secure the Raspberry Pi Pico W to the backplate (<em class="italic">B</em>) such that the USB port is facing down and toward the opening (<span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.23</em>, <span class="No-Break"><em class="italic">Step 2</em></span><span class="No-Break">).</span></li>
<li>We secure the buzzer (<em class="italic">D</em>) to the front shell (<em class="italic">H</em>) with two M4 10 mm bolts and M4 nuts (<span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.23</em>, <span class="No-Break"><em class="italic">Step 3</em></span><span class="No-Break">).</span></li>
<li>We then install the LED with the resistor (<em class="italic">F</em>) into the front shell (<em class="italic">H</em>) using the LED holder (<em class="italic">G</em>) (<span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.23</em>, <span class="No-Break"><em class="italic">Step 4</em></span><span class="No-Break">).</span></li>
<li>Using the glue gun, we secure the PIR sensor (<em class="italic">I</em>) to the front shell (<em class="italic">H</em>). Ensure that the PIR controls face the opening. We may also use the glue gun to reinforce the placement of the LED (<span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.23</em>, <span class="No-Break"><em class="italic">Step 5</em></span><span class="No-Break">).</span></li>
<li>Using a soldering iron, we solder the components to the Raspberry Pi Pico W using the wiring diagram from <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.8</em> as a reference (<span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.23</em>, <span class="No-Break"><em class="italic">Step 6</em></span><span class="No-Break">).</span></li>
<li>Using four M3 10 mm bolts, we secure the backplate (<em class="italic">B</em>) to the front shell (<em class="italic">H</em>) (<span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.23</em>, <span class="No-Break"><em class="italic">Step 7</em></span><span class="No-Break">).</span></li>
<li>If not already installed, we install MicroPython and our client code onto our Raspberry Pi Pico W <span class="No-Break">using Thonny.</span></li>
</ol>
<p>For our design, we use the micro-USB port for both power and access to the installed programs on our Raspberry Pi Pico W. This allows us to easily update our client software, such as changing the Wi-Fi network and password or the MQTT <span class="No-Break">topic used.</span></p>
<p>Also, our case <a id="_idIndexMarker546"/>provides access to the controls on our PIR sensor so that we may control the sensitivity and <span class="No-Break">off time.</span></p>
<p class="callout-heading">What are the controls on the HC-SR501 PIR sensor?</p>
<p class="callout">The HC-SR501 PIR <a id="_idIndexMarker547"/>sensor is equipped with two adjustable controls: the sensitivity control, which fine-tunes the sensor’s responsiveness to motion by increasing sensitivity when turned clockwise and decreasing it when turned counterclockwise, and the time delay control, which regulates the duration of the output signal after detecting motion, with clockwise rotation extending the signal duration and counterclockwise rotation shortening it. These controls sit beside each other and may be adjusted using a <span class="No-Break">small screwdriver.</span></p>
<p>To operate our IoT alarm module, we simply connect a micro-USB cable from our Raspberry Pi Pico W to a standard USB charger. The LED should blink quickly at first as a Wi-Fi connection is established, followed by a slow blink while our program connects to the MQTT broker, and finally, a solid light indicating our module is ready for use. If we decide not to print the stand from <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.22 E</em>, we may mount our module onto a GoPro camera mount of <span class="No-Break">our choice:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer124">
<img alt="Figure 6.24 – Alarm module installed on a GoPro camera mount" height="755" src="image/B21282_06_24.jpg" width="576"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.24 – Alarm module installed on a GoPro camera mount</p>
<p>To test our IoT <a id="_idIndexMarker548"/>alarm module, we connect to the <strong class="source-inline">mqtthq.com</strong> web client and subscribe to the <strong class="source-inline">IoTAlarm</strong> topic. Passing our hands over the PIR sensor, we should see <strong class="source-inline">motion</strong> messages appear in the client. Publishing the <strong class="source-inline">IoTAlarm</strong> topic and sending <strong class="source-inline">buzzer</strong> messages should activate our buzzer for <span class="No-Break">5 seconds.</span></p>
<p>We have just built our first MQTT-based IoT alarm module, enclosed in a physical case, capable of sensing motion and activating an alarm remotely through MQTT messages. With its built-in <a id="_idIndexMarker549"/>GoPro hook, we can easily install our IoT alarm module anywhere there is a <span class="No-Break">Wi-Fi connection.</span></p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor106"/>Summary</h1>
<p>In this chapter, we explored MQTT and used it to create an MQTT-based IoT alarm module. We introduced the amazing Raspberry Pi Pico W, a microcontroller that complements our Raspberry Pi. We began by understanding MQTT’s publish-subscribe model, which enables efficient and selective communication among connected devices. Additionally, we examined the significance of threading in maximizing the utilization of the Raspberry Pi Pico’s <span class="No-Break">dual-core processor.</span></p>
<p>We created code for connecting to Wi-Fi and MQTT servers, handling motion detection, and activating alarm components. We learned how to use callback functions to process <span class="No-Break">MQTT messages.</span></p>
<p>Furthermore, we covered saving and running our code on the Raspberry Pi Pico W, making it a standalone IoT alarm system. We also 3D printed a custom case to house the PIR sensor, LED, buzzer, and Raspberry Pi <span class="No-Break">Pico W.</span></p>
<p>With our MQTT-based IoT alarm module now complete, we are ready to explore further enhancements as we expand the capabilities of our IoT home security system. In the next chapter, we will build an IoT button that we will use to control our <span class="No-Break">alarm module.</span></p>
</div>
</div></body></html>