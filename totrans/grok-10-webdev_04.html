<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Models</h1></div></div></div><p>In Chapter 3, we learned how to display information on a web page by using views. In fact, as we saw, the view machinery is powerful enough to create complete applications, like our to-do list manager. We'll now turn our attention to where the data for these views comes from: the content objects, or models that define Grok applications. Here's a list of what we'll cover in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What a model is and what relationship it has with views</li><li class="listitem" style="list-style-type: disc">How to persist model data on the ZODB</li><li class="listitem" style="list-style-type: disc">How to structure our code to maintain the separation of display logic from application logic</li><li class="listitem" style="list-style-type: disc">What a container is and how to use one</li><li class="listitem" style="list-style-type: disc">How to use multiple models and associate specific views to each</li><li class="listitem" style="list-style-type: disc">How to use the Grok introspector to navigate models</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec01"/>Models and applications</h1></div></div></div><p>Although the views do the actual work of showing our data and handling user interaction, they are just one possible way of displaying the data. In the previous chapter, we started with a very simple view with no styles or client-side scripting, and by the end of the chapter, we had a completely different looking application. What remained constant throughout was the thing we were working with: to-do lists.<a id="id105" class="indexterm"/>
</p><p>Whenever we added lists or list items and checked off items, we were interacting with the model for our application, which in this case was defined with just two lines of code:</p><div><pre class="programlisting">class Todo(grok.Application, grok.Model):
todolists = []
</pre></div><p>A Grok application is composed of one or more models. The models can be simple Python objects, but generally use<code class="literal"> grok.Model</code> as a base class. The main model of an application should inherit from<code class="literal"> grok.Application</code> as well, which is what happens in the preceding code.</p><p>The model contains the application data and all of the logic that's not directly related to how this data is shown. In the case of our to-do list manager, the model consists of only a<code class="literal"> todolists</code> class attribute that holds all the lists and their items.<a id="id106" class="indexterm"/>
</p><p>Even though this model is so simple, the views work for the model and not the other way around. If we look at the code in both the<code class="literal"> index</code> and<code class="literal"> check</code> views, we'll see that every time something important happens the value of<code class="literal"> self.context.todolists</code> is modified. As we mentioned before, all views have a<code class="literal"> context</code> attribute that refers to their associated model. Through it, views can access all of the attributes of this model.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec02"/>Storing model data</h1></div></div></div><p>So far, we can create and manage lists successfully, but once we restart the application we lose all the data. We need a way to persist the information.<a id="id107" class="indexterm"/>
</p><p>For web applications, this usually means creating some tables in a relational database and storing the information by using direct SQL queries or an<strong> Object Relational Mapper</strong> (<strong>ORM</strong>). An ORM is a good solution as it takes our objects and transparently stores their attributes in the corresponding tables. Each time we need to work with our objects, the ORM reassembles them from the database once again, without the need for us to worry about SQL.<a id="id108" class="indexterm"/>
</p><p>Grok can store data in relational databases using plain SQL as well as a diverse range of ORMs for Python, such as SQLAlchemy (<a class="ulink" href="http://www.sqlalchemy.org">http://www.sqlalchemy.org</a>) or Storm (<a class="ulink" href="https://storm.canonical.com">https://storm.canonical.com</a>). However, Grok gives us another interesting option that is a more natural fit for our Python objects, and can work even more transparently than ORMs: the <strong> Zope Object Database</strong> (<strong>ZODB</strong>).<a id="id109" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec01"/>The ZODB</h2></div></div></div><p>We discussed the ZODB in the first chapter, where we mentioned that it is very well integrated with Grok. We'll show a simple example of storing data now, and come back to the details, later.<a id="id110" class="indexterm"/>
</p><p>Right now, the to-do list manager application has its title defined inside the<code class="literal">&lt;h1&gt;</code> tag on the<code class="literal"> index</code> template. Let's give each application instance a<code class="literal"> title</code> attribute, so that the user can set the title himself. First, we'll replace the simplistic model definition that we have been using so far with more realistic code:</p><div><pre class="programlisting">class Todo(grok.Application, grok.Model):
def __init__(self):
<strong>super(Todo, self).__init__()
</strong>
self.title = 'To-Do list manager'
self.todolists = []
</pre></div><p>We have added an<code class="literal"> __init__</code> method that is called when the application is created. Inside this method, we make sure that we call the superclass'<code class="literal"> __init__</code> method as well, so that our method extends, rather than replaces the original code. We then define two instance attributes,<code class="literal"> title</code> and<code class="literal"> todolists</code>.</p><p>In Python, there are two kinds of objects:<strong> mutable objects</strong>, which can have their values changed, and<strong> immutable objects</strong>, that cannot. For immutable objects, such as strings or numbers, we gain automatic persistence in the ZODB merely by inheriting from<code class="literal"> grok.Model</code>. In the case of the title, now we can transparently store it in the ZODB. The<code class="literal"> todolists</code>, as they are stored inside a list (a mutable object), need a little more work, but we'll get to them later.<a id="id111" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec02"/>Changing the title dynamically</h2></div></div></div><p>Now that we have a<code class="literal"> title</code> attribute, we can modify the<code class="literal"> index.pt</code> template to show that, instead of the old text. Both the<code class="literal">&lt;title&gt;</code> and<code class="literal">&lt;h1&gt;</code> tags need a<code class="literal"> tal:content</code> statement, like in the following example:<a id="id112" class="indexterm"/>
</p><div><pre class="programlisting">&lt;h1 tal:content="context/title"&gt;To-Do list manager&lt;/h1&gt;
</pre></div><p>Now, the template will use whatever title is stored in the application instance. Now we need a way for the user to set the title. Let's create a simple Ajax view that can do this:</p><div><pre class="programlisting">class SetTitle(grok.View):
def update(self,new_title):
self.context.title = new_title
def render(self):
return self.context.title
</pre></div><p>All this does is checks for the key<code class="literal"> new_title</code> in the request, and sets the<code class="literal"> title</code> attribute to its value. As we did with the<code class="literal"> Check</code> view back in Chapter 3, the response does not use a template, but a simple Python code that returns plain text. We just return the<code class="literal"> title</code> attribute that was changed in the<code class="literal"> update</code> method, so that the JavaScript callback function can change it immediately after it's set.</p><p>On the client side, we use a couple of JavaScript functions to produce an<em> edit-in-place</em> effect, so that the user can click on the title and change it right there. We won't go into the code here, but you can find it in the Chapter 4 directory in the book's code package. You can look at the result in the following screenshot:<a id="id113" class="indexterm"/>
</p><div><img src="img/7481_04_01.jpg" alt="Changing the title dynamically"/></div><p>If we run the application now, it will be possible to edit the title, restart the application, and see that its value is saved across server restarts. One word of warning though: because we added an attribute to the application instance inside the<code class="literal"> __init__</code> method, it's necessary to delete any existing application instances before trying this code. That's because the<code class="literal"> title</code> attribute is added at the time of application creation, when the<code class="literal"> __init__</code> method is run, which didn't happen when we created applications in the previous chapter. If we try to use an older application instance, we'll get an attribute error when we try to access the<code class="literal"> title</code> attribute.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec03"/>The rules of persistence</h2></div></div></div><p>As we mentioned earlier, the<code class="literal"> todolists</code> attribute will not get persisted to the ZODB that easily. The reason is that whenever changes are made to mutable attributes, the application needs to inform the ZODB that there has been a change. This is done by setting the special<code class="literal"> _p_changed</code> attribute of the instance to<code class="literal"> True.</code>
<a id="id114" class="indexterm"/>
</p><p>In the case of the<code class="literal"> todolists</code> attribute, all we have to do is set<code class="literal"> _p_changed</code> to<code class="literal"> True</code> after any modification to the attribute. We'll just need to add this code at the end of the<code class="literal"> update</code> methods in the index and check views:</p><div><pre class="programlisting">self.context.p_changed_ = True
</pre></div><p>Thankfully, this is the only rule that we have to keep in mind when working with the ZODB in Grok. Well, there are a few more rules, but Grok already follows them, so this is the only one that will require us to modify the code. Let's look at the rules of persistence for the ZODB:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Inherit from<code class="literal"> persistent.Persistent</code> (a class defined in the ZODB code) or one of its subclasses. The Grok classes,<code class="literal"> grok.Model</code> and<code class="literal"> grok.Container</code> already do this for us, so by extending them we will automatically persist our classes.</li><li class="listitem" style="list-style-type: disc">Class instances have to be related to each other in a hierarchical structure. The ZODB has a root object and this object contains other objects, which can in turn contain some other objects, forming a tree.</li><li class="listitem" style="list-style-type: disc">When modifying mutable attributes of persistent objects that are not persistent themselves, the persistence machinery has to be notified, by setting the special<code class="literal"> _p_changed</code> attribute of the instance to<code class="literal"> True</code>.</li></ul></div><p>Like we said, Grok follows these rules, so that by using Grok's models and containers we automatically have persistent data storage for our applications. In this way, we can think only in terms of classes and attributes instead of translating them back and forth in our minds (and code) into tables and columns.</p><p>That's all we have to do to store the to-do lists inside the ZODB. We almost have a complete application, so now let's focus on how to better structure our code.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec03"/>Display logic and application logic</h1></div></div></div><p>We keep talking about the separation of display and application logic, but our code so far is clearly not enforcing this rule. The model only holds the lists and everything else happens inside the views.<a id="id115" class="indexterm"/>
</p><p>The problem with this approach is that our views need to know too much about how the model is implemented, and it becomes very hard to change it without needing to modify some or all of the views.</p><p>For example, when we add a list item in the<code class="literal"> update</code> method of our index view, we have to know that list items are stored as dictionaries with<code class="literal"> description</code> and<code class="literal"> check</code> keys . We also have to know that the list of items is stored under the key items in a dictionary representing the list itself. These are too many internal details, and writing view code, which relies on this knowledge may require heavy modifications to it, if the model implementation changes.</p><p>Worse, relying on this knowledge makes our code more repetitive than it should be, and forces us to make the same change in multiple places when there are modifications. Look at this line of code from the to-do list manager:</p><div><pre class="programlisting">items = self.context.todolists[list_index]['items']
</pre></div><p>We only have two views, and this line shows up in both of them. If we add more views and need to look at the items from some list in them, we'll have to repeat this code again. Now suppose we add projects to our application and wish to store the lists inside a project. In this case, we would have to change every occurrence of this line in every view, to reflect the new structure.</p><p>This is why separation of display and application logic is so important. It helps to structure our applications and allows us to change the way the data is displayed without modifying its internal representation, or the other way around.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec04"/>Separating display and application logic</h2></div></div></div><p>Let's think about how we could restructure the application so that this principle is taken into account. Remember, the model shouldn't know anything about how it is displayed and the views should not depend on any implementation details from the model.<a id="id116" class="indexterm"/>
</p><p>We could start by adding some method to the model to add lists and get all the items from a list, so that we can call these new methods from the view and stop depending on how list data are stored in the main list of the to-do lists. We might be tempted to write something like this:</p><div><pre class="programlisting">class Todo(grok.Application, grok.Model):
def __init__(self):
super(Todo, self).__init__()
self.title = 'To-Do list manager'
self.todolists = []
def createList(self, title, description):
self.todolists.append({'title':title, 'description':description, 'items':[]})
self._p_changed = True
def getListItems(self, index):
items = self.todolists[index]['items']
return items
</pre></div><p>However, we must resist the temptation. If we go down this path, our code will be filled with<code class="literal"> self._p_changed</code> lines, and we'll be passing list indexes around like crazy. Having the to-do lists represented as a simple list is really not the way to go. We should instead use a more carefully designed model, and take full advantage of Grok's model classes.<a id="id117" class="indexterm"/>
</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec04"/>Using containers and multiple models</h1></div></div></div><p>Up to this point, we are using<code class="literal"> grok.Model</code> as a base class for our application, which mostly buys us nearly transparent ZODB storage, as we have seen. Most non-trivial applications, however, will require more than one type of object to be useful. Also, it's fairly common to organize application data using parent and child relationships, so that one main object is the parent and contains a number of child objects. In our to-do list manager application, the main application is a container of to-do lists and each list in turn can contain a number of items.</p><p>Because this is a very common pattern, Grok offers a<code class="literal"> grok.Container</code> class which allows us to store other models and also handles ZODB persistence. Using it, we can structure our code better, simplify it, and also eliminate the need to signal to the framework every time a change is made to a list or one of its items (no more<code class="literal"> self._p_changed</code> lines). Instead of dealing with an ad hoc list structure and keeping track of indexes, we can think about list objects and item objects.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec05"/>Adding containers to our application</h2></div></div></div><p>Conceptually, then, our application will consist of a container of lists. A list object will also be a container, where the items will be stored. Let's start by defining the main model:<a id="id118" class="indexterm"/>
</p><div><pre class="programlisting">class Todo(grok.Application, grok.Container):
def __init__(self):
super(Todo, self).__init__()
self.next_id = 0
self.title = 'To-Do list manager'
</pre></div><p>This is not very different from what we had before. The important change is that we now inherit from<code class="literal"> grok.Container</code> instead of<code class="literal"> grok.Model</code>. This will allow the application to store list objects. We also define a<code class="literal"> next_id</code> attribute to create identifiers for the lists. OK, let's define the list model now:</p><div><pre class="programlisting">class TodoList(grok.Container):
def __init__(self,list_title,list_description):
super(TodoList, self).__init__()
self.next_id = 0
self.title = list_title
self.description = list_description
</pre></div><p>A list has<code class="literal"> title</code> and<code class="literal"> description</code> attributes, both mandatory parameters at instance creation. As with the list model, we also define a<code class="literal"> next_id</code> attribute to keep track of individual items. Notice that<code class="literal"> grok.Application</code> is not a base class here, because this is a model that will be used by the application defined earlier. In some cases, we could have a need for more than one application in a project, and technically we could define both in the same file, but generally it's suggested that we use a separate file for different applications.<a id="id119" class="indexterm"/>
</p><p>The<code class="literal"> TodoList</code> class is also a<code class="literal"> grok.Container</code> because it will contain to-do items. These items will not contain other types of models, so the list item class definition will simply be a model:</p><div><pre class="programlisting">class TodoItem(grok.Model):
def __init__(self,item_description):
super(TodoItem, self).__init__()
self.description = item_description
self.checked = False
</pre></div><p>The<code class="literal"> TodoItem</code> class just inherits from<code class="literal"> grok.Model</code>. It only has a<code class="literal"> description</code> attribute, which is a mandatory parameter at instance creation.<a id="id120" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec06"/>Adding behavior to the models</h2></div></div></div><p>Now that we have our application model structured, we should think about which model will perform which actions. We are talking about the different actions, such as list and item creation, that our application performs. However, in the previous version they were crowded inside the<code class="literal"> update</code> method of the<code class="literal"> index</code> view. With a clean model structure we can now separate these actions and put each one where it better belongs.<a id="id121" class="indexterm"/>
</p><p>The main application is the list manager, so the methods for list creation and deletion should be added to the<code class="literal"> Todo</code> class. Let's get going with the code:</p><div><pre class="programlisting">def addList(self,title,description):
id = str(self.next_id)
self.next_id = self.next_id+1
self[id] = TodoList(title,description)
def deleteList(self,list):
del self[list]
</pre></div><p>The<code class="literal"> addList</code> method takes a<code class="literal"> title</code> and<code class="literal"> description</code> and simply creates an instance of<code class="literal"> TodoList</code>. The new list is stored in the container using a key, just like a Python dictionary works (in fact, it supports the same methods, such as keys, values, and items). The key is generated using the<code class="literal"> next_id</code> attribute that we discussed earlier, which is then incremented for the next list creation.</p><p>The<code class="literal"> deleteList</code> method is even simpler, as we just need to delete the desired key from the dictionary using the<code class="literal"> del</code> statement. As promised, notice the absence of any code dealing directly with persistence. The lists will be correctly stored in the ZODB without the need for explicit notification.<a id="id122" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec07"/>The TodoList model</h2></div></div></div><p>Now let's turn our attention to the<code class="literal"> TodoList</code> model. We need a way to add and delete items, similar to what we did with the main application. Also, if we want to keep our non-JavaScript-enabled version of the application working, we need a way to change the<code class="literal"> checked</code> status of multiple items at the same time. Here's the code that we have to add to the<code class="literal"> TodoList</code> class:<a id="id123" class="indexterm"/>
</p><div><pre class="programlisting">def addItem(self,description):
id = str(self.next_id)
self.next_id = self.next_id+1
self[id] = TodoItem(description)
def deleteItem(self,item):
del self[item]
def updateItems(self, items):
for name,item in self.items():
if name in items:
self[item].checked = True
else:
self[item].checked = False
</pre></div><p>The<code class="literal"> addItem</code> method is almost a verbatim copy of the<code class="literal"> addList</code> method that we saw earlier. We use the<code class="literal"> next_id</code> pattern to create the ID, and create a new instance of<code class="literal"> TodoItem</code>. The<code class="literal"> deleteItem</code> method is identical to the<code class="literal"> deleteList</code> method discussed earlier. The<code class="literal"> updateItems</code> method is different because it expects a list of item IDs to mark as checked. We iterate through all of the items in the list and set their<code class="literal"> checked</code> attribute to<code class="literal"> True</code> if they are on the received list, or set it to<code class="literal"> False</code> otherwise.<a id="id124" class="indexterm"/>
</p><p>The<code class="literal"> TodoItem</code> model is the simplest of the three. We can directly set the<code class="literal"> checked</code> attribute to<code class="literal"> True</code> or<code class="literal"> False</code>, so we probably don't need separate methods to do that. We will only add a convenience method to toggle the<code class="literal"> checked</code> state of an item, without requiring us to know the current state. This will be useful for the Ajax-enabled check view that we created earlier:<a id="id125" class="indexterm"/>
</p><div><pre class="programlisting">def toggleCheck(self):
self.checked = not self.checked
</pre></div><p>The<code class="literal"> toggleCheck</code> method simply sets the value of the<code class="literal"> checked</code> attribute of the<code class="literal"> TodoItem</code> to the opposite of the current value, thus acting as a toggle.</p><p>We now have a complete model that uses Grok's features and includes all of the application logic. The views will now be able to perform the display work without messing with the application's internals.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec08"/>Reorganizing the views</h2></div></div></div><p>Speaking of views, we need to refactor those, too. So far, we have been doing everything with only one view, but this needs to change. We'd like to keep the application as having one single main view and showing all modifications to the different models on the same page, but method calls to each model's actions should come from the views associated with that model. This is because in this way Grok will take care of setting the context for the view correctly, and we will not have to worry about making sure that we act on the correct model in our code. Remember that earlier we used a hidden<code class="literal">&lt;input&gt;</code> tag with a list index to tell our<code class="literal"> update</code> method on which list we wanted to operate. We don't need to do this anymore if we associate our views with the right models.<a id="id126" class="indexterm"/>
</p><p>For the main application, then, we will keep the<code class="literal"> index</code> view and the<code class="literal"> setTitle</code> views. We'll also add views for calling the<code class="literal"> addList</code> and<code class="literal"> deleteList</code> methods. The new<code class="literal"> TodoList</code> model will have a view for each of its three actions, which are<code class="literal"> addItem, deleteItem</code>, and<code class="literal"> updateItem</code>. For the<code class="literal"> TodoItem</code> model, we'll reuse the existing<code class="literal"> check</code> view, but the one associated with this model instead of the main application.<a id="id127" class="indexterm"/>
</p><p>That's it. So, previously we had a single model with three views, but now we have three models, and each will require a couple of views. How will Grok know which views are associated with which model?</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec09"/>Introducing class annotations</h2></div></div></div><p>One of Grok's conventions is that all views defined in a module where there's only one model definition will be associated with this model. Grok knows that this is the only possibility, and so automatically sets the<code class="literal"> context</code> attribute on all views to be this model. Now that we have three models, each view that we create has to explicitly tell Grok to which model it belongs.<a id="id128" class="indexterm"/>
</p><p>The mechanism Grok uses to do this is called a<strong> class annotation</strong>. Grok has many conventions that help it decide what to do when no information is available, but we can certainly tell Grok what to do when we need to. A class annotation is just a declarative way of telling Grok something about a class.</p><p>To explicitly associate a view with a model, we use the<code class="literal"> grok.context</code> class annotation. This class takes as a parameter the model to which we want to associate a view. Let's redefine our<code class="literal"> index</code> view:</p><div><pre class="programlisting">class Index(grok.View):
grok.context(Todo)
</pre></div><p>We use the<code class="literal"> grok.context</code> class annotation to tell Grok that this view will work with the<code class="literal"> Todo</code> model as context. This is in fact all of the code that we need for this view, as we have separated the model responsibilities into three different views. No more gigantic<code class="literal"> update</code> methods full of<code class="literal"> if</code> statements.</p><p>Before going on with the other views, let's think a bit about how<code class="literal"> index</code> views work. As we saw in the previous chapter, if a view has the name<code class="literal"> index</code> it will be treated as the default view for a model. We also learned that the name of a view is automatically given by the lowercase version of its own class name. Now, for the case where we have more than one model and for each of them we want to have a default view, how do we name the view classes? There can't be two<code class="literal"> Index</code> classes defined in the same module.<a id="id129" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec10"/>Setting view names explicitly</h2></div></div></div><p>If you guessed that class annotations would come into play again, you were absolutely right. For cases like these, we have the<code class="literal"> grok.name</code> class annotation, which can be used to explicitly set the name of a view. Right now, we need only one<code class="literal"> index</code> view in our code, but we may need to add default views for the other models later, so we might as well change the code at this point:<a id="id130" class="indexterm"/>
</p><div><pre class="programlisting">class TodoIndex(grok.View):
grok.context(Todo)
grok.name('index')
</pre></div><p>We change the view class name to<code class="literal"> TodoIndex</code>, which would result in URLs with the name<code class="literal"> todoindex</code>. We then use the<code class="literal"> grok.name</code> annotation to set the view name to<code class="literal"> index</code>, thus allowing us to call the default view without using its name.</p><p>Now let's take a look at the action views for this model. First, the<code class="literal"> addlist</code> view, which will be used to add new lists to the application:</p><div><pre class="programlisting">class TodoAddList(grok.View):
grok.context(Todo)
grok.name('addlist')
def update(self,title,description):
self.context.addList(title,description)
def render(self):
self.redirect(self.url('index'))
</pre></div><p>The<code class="literal"> TodoAddList</code> view is also associated with the<code class="literal"> Todo</code> model, but uses a different name. This view will be called when the user fills the create list form and clicks on the submit button.</p><p>Notice in this code how the<code class="literal"> update</code> method is just one line long. We just call the<code class="literal"> addList</code> method of the<code class="literal"> context</code> and pass the two required parameters to it. No need to grapple with form parameters or make<code class="literal"> if</code> checks to see what action is desired.<a id="id131" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec11"/>Redirecting views</h2></div></div></div><p>In this application we want the index page to show all changes immediately. Therefore, in the<code class="literal"> render</code> method, instead of using a template to produce HTML, or sending a plain text string as we have done before, we perform a redirection to the index view, using the<code class="literal"> redirect</code> method available to the view.<a id="id132" class="indexterm"/>
</p><p>The<code class="literal"> deletelist</code> view is very similar to the<code class="literal"> addlist</code> view. We hadn't implemented this functionality in the initial version of our application, but you'll see it's really cheap to do that now that we have the proper structure:<a id="id133" class="indexterm"/>
</p><div><pre class="programlisting">class TodoDeleteList(grok.View):
grok.context(Todo)
grok.name('deletelist')
def update(self,list):
self.context.deleteList(list)
def render(self):
self.redirect(self.url('index'))
</pre></div><p>We just use a different name and call the<code class="literal"> deleteList</code> method of the model, but otherwise the code is the same.<a id="id134" class="indexterm"/>
</p><p>The last view for the<code class="literal"> Todo</code> model is the<code class="literal"> setTitle</code> view that we added at the beginning of this chapter. Here's how it looks:<a id="id135" class="indexterm"/>
</p><div><pre class="programlisting">class TodoSetTitle(grok.View):
grok.context(Todo)
grok.name('settitle')
def update(self,title):
self.context.title = title
def render(self):
return self.context.title
</pre></div><p>In this case, we keep the old behavior of returning the new title when rendering. The only change here is that the association with the model is explicit, and we give it a different name than its class name.</p><p>The three views associated to the<code class="literal"> TodoList</code> model are almost carbon copies of the<code class="literal"> addlist</code> and<code class="literal"> deletelist</code> views of the<code class="literal"> Todo</code> model. Let's take a look and talk about what's different:</p><div><pre class="programlisting">class TodoListAddItem(grok.View):
grok.context(TodoList)
grok.name('additem')
def update(self,description):
self.context.addItem(description)
def render(self):
self.redirect(self.url(self.context.__parent__,'index'))
class TodoListDeleteItem(grok.View):
grok.context(TodoList)
grok.name('deleteitem')
def update(self,item):
self.context.deleteItem(item)
def render(self):
self.redirect(self.url(self.context.__parent__,'index'))
class TodoListUpdateItems(grok.View):
grok.context(TodoList)
grok.name('updateitems')
def update(self,items):
self.context.updateItems(items)
def render(self):
self.redirect(self.url(self.context.__parent__,'index'))
</pre></div><p>Notice how the three of them use the<code class="literal"> grok.context</code> annotation to associate themselves with the<code class="literal"> TodoList</code> model. The<code class="literal"> update</code> methods of all three are very similar to the other ones, and just call the correct<code class="literal"> update</code> method from the<code class="literal"> context</code>, which in this case we know is a<code class="literal"> TodoList</code> instance.</p><p>The<code class="literal"> redirect</code> call on the<code class="literal"> render</code> method is a little different, though. As the context is a<code class="literal"> TodoList</code> and we want to show the index view for the<code class="literal"> Todo</code> model, we need to get at the container of this list to pass it to the<code class="literal"> url</code> function of the view, so that it can generate the correct URL. To do this, we use another characteristic of a Grok model object, a<code class="literal"> __parent__</code> attribute, which points to its container. As we know that the list is contained by the<code class="literal"> Todo</code> model, we can get at it in this way. Model objects also have a<code class="literal"> __name__</code> attribute, which stores the key that is used to access the object inside its container. We'll use that in a minute when we see how the index template has to change to accommodate the new model structure.</p><p>As for the<code class="literal"> TodoItem</code> model, we just need the<code class="literal"> check</code> view that was already used in the previous version of our application:</p><div><pre class="programlisting">class TodoItemCheck(grok.View):
grok.context(TodoItem)
grok.name('check')
def update(self):
self.div_id = 'div_item_%s_%s' % (self.context.__parent__.__name__,self. context.__name__)
self.context.toggleCheck()
def render(self):
return self.div_id
</pre></div><p>There are a few differences. The view is now explicitly associated with the<code class="literal"> TodoItem</code> model using<code class="literal"> grok.context</code>, obviously. Also, we now call the new<code class="literal"> toggleCheck</code> method of the<code class="literal"> TodoItem</code> instead of making the change in the view. Finally, we construct the ID for the<code class="literal">&lt;div&gt;</code> tag that the view will be returning, by using the<code class="literal"> __parent__</code> and<code class="literal"> __name__</code> attributes of the model. In this way, we avoid the need to have list and item indexes passed as view parameters.</p><p>We now have a much better separation of application and display logic in our to-do list manager application. Let's see how this impacts the code for the<code class="literal"> index</code> view, which now has to display data from three models instead of one. Look at the code for the loop that shows the lists and their items. First, note that we now iterate over the lists using<code class="literal"> context/values</code> instead of the list elements that we had in the old model:</p><div><pre class="programlisting">&lt;tal:block repeat="todolist context/values"&gt;
&lt;div class="todolist"&gt;
</pre></div><p>After that, we define the<code class="literal"> todo</code> list form. Notice how we use<code class="literal"> view.url()</code> to generate the correct URL for posting the form. Remember that this function works by passing the object for which we want to generate a URL and an optional view name to append to it. In the following code, the action for the first form is defined by calling the<code class="literal"> view url</code> method, passing the current<code class="literal"> todolist</code> object and the<code class="literal"> updateitems</code> view name to it.</p><div><pre class="programlisting">&lt;form method="post" tal:attributes="action python:view.url(todolist,'updateitems')"&gt;
&lt;fieldset&gt;
</pre></div><p>Next, we have the code to delete a list. Take a look at how we use the<code class="literal"> __name__</code> attribute to create URLs that include the name of the object that we are interested in. In this way, methods that expect a key to work will receive it directly from this view. We don't need to do any list and item index calculations, or add hidden fields with list data:</p><div><pre class="programlisting">&lt;legend&gt;&lt;span tal:content="todolist/title"&gt;title&lt;/span&gt;
&lt;a tal:define="url python:view.url('deletelist')" tal:attributes="href string:${url}?list=${todolist/__name__}"&gt;
&lt;img border="0" tal:attributes="src static/bin_closed.png" /&gt;
&lt;/a&gt;
&lt;/legend&gt;
</pre></div><p>The rest of the form has very similar changes, which are mostly the use of<code class="literal"> __name__</code> and<code class="literal"> view.url:</code>
</p><div><pre class="programlisting">&lt;p tal:content="todolist/description"&gt;description&lt;/p&gt;
&lt;div tal:repeat="item todolist/values" tal:attributes="class python:item.checked and 'done' or 'pending'; id string:div_item_${todolist/__name__} _${item/__name__}"&gt;
&lt;input type="checkbox" name="items:list" tal:define="check_url python:view.url(item,'check');" tal:attributes="checked item/checked; onclick string:getRequest('{check_url}', processReqChange)"/&gt;
&lt;span tal:content="item/description"&gt;&lt;/span&gt;
&lt;a tal:define="url python:view.url(todolist,'deleteitem')" tal:attributes="href string:${url}?item=${item/__name__}"&gt;
&lt;img border="0" tal:attributes="src static/bin_closed.png" /&gt;
&lt;/a&gt;
&lt;br/&gt;
&lt;/div&gt;
&lt;input type="submit" class="update_button" name="update_list" value="Update list"/&gt;
&lt;/fieldset&gt;
&lt;/form&gt;
</pre></div><p>Finally, the form for adding list items now also uses<code class="literal"> view.url</code> to generate the form action:</p><div><pre class="programlisting">&lt;form method="post" tal:attributes="action python:view.url(todolist,'add item')"&gt;
&lt;label for="description"tal:attributes="onclick string:toggleAddControls('add_controls_${repeat/todolist/index}');; this.form.description.focus();"&gt;New item&lt;/label&gt;&lt;br/&gt;
&lt;div class="controls" tal:attributes="id string:add_controls_${repeat/todolist/index}"&gt;
&lt;input type="text" size="60" name="description"&gt;
&lt;br/&gt;
&lt;input type="submit" class="new_button" name="new_item" value="Add to list"/&gt;
&lt;/div&gt;
&lt;/form&gt;
&lt;/tal:block&gt;
</pre></div><p>One would think that having to use three models could complicate things in the view, but we actually have to use less code this time around. It's also a lot cleaner. Instead of a big form with multiple submit buttons that all go to the same<code class="literal"> update</code> method in the same view, we now use several forms, and direct the form submissions to the respective view by using<code class="literal"> view.url()</code> to generate the correct URL in each case.</p><p>Other than these changes, the code for the template is mostly the same as we already had, so no big changes are required to make it work.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec05"/>The Grok introspector</h1></div></div></div><p>So we now have a fully working application. Play with it a little and create some lists and tasks. Everything will be safely stored inside the ZODB.</p><p>We'll now take a quick look at one tool that Grok offers that can be very helpful to understand object relationships and responsibilities when we are dealing with applications developed by someone else (or revisiting applications we wrote years ago).</p><p>The Grok introspector is a tool that is accessible from the application list at<code class="literal"> http://localhost:8080/applications</code>. Go there and, under<strong> Installed Applications</strong>, you'll see your instance of the<code class="literal"> Todo</code> application. The application name is a link to run it, but to the right of that name there is a link that says<strong> object browser</strong>. Click on this link and you'll see something similar to the next screenshot:</p><div><img src="img/7481_04_02.jpg" alt="The Grok introspector"/></div><p>In this case, we can see the data from the current instance of the<code class="literal"> Todo</code> model. Notice how the parent information used for the<code class="literal"> __parent__</code> attribute is there at the top. Below we can see the base classes of the object, which we know are<code class="literal"> grok.Application</code> and<code class="literal"> grok.Container</code>. Under the<strong> Base classes</strong> section there is an<strong> Interfaces provided</strong> section. We'll have more to say about interfaces later, so for now let's skip that.</p><p>Below that you can see a section called<strong> Attributes and Properties</strong>. Under<strong> Attributes</strong>, you'll find the<code class="literal"> title</code> and<code class="literal"> next_id</code> attributes of the<code class="literal"> Todo</code> model, with their current values. Then comes the<strong> Mappings</strong> section, where the values for all of the objects stored in this container are shown. If you click on any of these values, you'll get a page with the data for the corresponding model instance, so you can easily navigate the whole data structure produced by the application and look at the information within.</p><p>Finally, the names and documentation strings for all of the methods of the object are shown. Try adding a documentation string to a method of our application, and you will see it reflected in that section (after a server restart, of course).</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec06"/>Summary</h1></div></div></div><p>In this chapter, we extended our demonstration application using models. The amount of code did not increase greatly from the previous chapter, but we have a much more elegant and better-structured application. The code is also more maintainable and pretty extensible, as we'll learn next when we deal with forms in Grok.</p></div></div>
</body></html>