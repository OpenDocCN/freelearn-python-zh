- en: Chapter 4. Using Mock Objects to Test Interactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having looked at the `Rule` and `Stock` classes, let us now turn our attention
    to the `Event` class. The `Event` class is very simple: receivers can register
    with the event to be notified when the event occurs. When the event fires, all
    the receivers are notified of the event.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A more detailed description is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Event classes have a `connect` method, which takes a method or function to be
    called when the event fires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the `fire` method is called, all the registered callbacks are called with
    the same parameters that are passed to the `fire` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests for the `connect` method is fairly straightforward—we just need
    to check that the receivers are being stored properly. But, how do we write the
    tests for the fire method? This method does not change any state or store any
    value that we can assert on. The main responsibility of this method is to call
    other methods. How do we test that this is being done correctly?
  prefs: []
  type: TYPE_NORMAL
- en: This is where mock objects come into the picture. Unlike ordinary unit tests
    that assert on object *state*, mock objects are used to test that the *interactions*
    between multiple objects occurs as it should.
  prefs: []
  type: TYPE_NORMAL
- en: Hand writing a simple mock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start with, let us look at the code for the `Event` class so that we can
    understand what the tests need to do. The following code is in the file `event.py`
    in the source directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The way this code works is fairly simple. Classes that want to get notified
    of the event should call the `connect` method and pass a function. This will register
    the function for the event. Then, when the event is fired using the `fire` method,
    all the registered functions will be notified of the event. The following is a
    walk-through of how this class is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, every time the `fire` method is called, all the functions that
    registered with the `connect` method get called with the given parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do we test the `fire` method? The walk-through above gives a hint.
    What we need to do is to create a function, register it using the `connect` method,
    and then verify that the method got notified when the `fire` method was called.
    The following is one way to write such a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Put this code into the `test_event.py` file in the tests folder and run the
    test. The test should pass. The following is what we are doing:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a variable named called and set it to `False`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we create a dummy function. When the function is called, it sets called
    to `True`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we connect the dummy function to the event and fire the event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the dummy function was successfully called when the event was fired, then
    the `called` variable would be changed to `True`, and we assert that the variable
    is indeed what we expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The dummy function we created above is an example of a mock. A **mock** is simply
    an object that is substituted for a real object in the test case. The mock then
    records some information such as whether it was called, what parameters were passed,
    and so on, and we can then assert that the mock was called as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Talking about parameters, we should write a test that checks that the parameters
    are being passed correctly. The following is one such test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This test is the same as the previous one, except that it saves the parameters
    that are then used in the assert to verify that they were passed properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we can see some repetition coming up in the way we set up the
    mock function and then save some information about the call. We can extract this
    code into a separate class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we do this, we can use our `Mock` class in our tests as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: What we have just done is to create a simple mocking class that is quite lightweight
    and good for simple uses. However, there are often times when we need much more
    advanced functionality, such as mocking a series of calls or checking the order
    of specific calls. Fortunately, Python has us covered with the `unittest.mock`
    module that is supplied as a part of the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Python mocking framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `unittest.mock` module provided by Python is an extremely powerful mocking
    framework, yet at the same time it is very easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us redo our tests using this library. First, we need to import the `mock`
    module at the top of our file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we rewrite our first test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The only change that we've made is to replace our own custom `Mock` class with
    the `mock.Mock` class provided by Python. That is it. With that single line change,
    our test is now using the inbuilt mocking class.
  prefs: []
  type: TYPE_NORMAL
- en: The `unittest.mock.Mock` class is the core of the Python mocking framework.
    All we need to do is to instantiate the class and pass it in where it is required.
    The mock will record if it was called in the `called` instance variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we check that the right parameters were passed? Let us look at the rewrite
    of the second test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The mock object automatically records the parameters that were passed in. We
    can assert on the parameters by using the `assert_called_with` method on the `mock`
    object. The method will raise an assertion error if the parameters don't match
    what was expected. In case we are not interested in testing the parameters (maybe
    we just want to check that the method was called), then we can pass the value
    `mock.ANY`. This value will match any parameter passed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a subtle difference in the way normal assertions are called compared
    to assertions on mocks. Normal assertions are defined as a part of the `unittest.Testcase`
    class. Since our tests inherit from that class, we call the assertions on self,
    for example, `self.assertEquals`. On the other hand, the mock assertion methods
    are a part of the `mock` object, so you call them on the mock object, for example,
    `listener.assert_called_with`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mock objects have the following four assertions available out of the box:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assert_called_with`: This method asserts that the last call was made with
    the given parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert_called_once_with`: This assertion checks that the method was called
    exactly once and was with the given parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert_any_call`: This checks that the given call was made at some point during
    the execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert_has_calls`: This assertion checks that a list of calls occurred'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The four assertions are very subtly different, and that shows up when the mock
    has been called more than one. The `assert_called_with` method only checks the
    last call, so if there was more than one call, then the previous calls will not
    be asserted. The `assert_any_call` method will check if a call with the given
    parameters occurred anytime during execution. The `assert_called_once_with` assertion
    asserts for a single call, so if the mock was called more than once during execution,
    then this assert would fail. The `assert_has_calls` assertion can be used to assert
    that a set of calls with the given parameters occurred. Note that there might
    have been more calls than what we checked for in the assertion, but the assertion
    would still pass as long as the given calls are present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a closer look at the `assert_has_calls` assertion. Here is how
    we can write the same test using this assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The mocking framework internally uses `_Call` objects to record calls. The `mock.call`
    function is a helper to create these objects. We just call it with the expected
    parameters to create the required call objects. We can then use these objects
    in the `assert_has_calls` assertion to assert that the expected call occurred.
  prefs: []
  type: TYPE_NORMAL
- en: This method is useful when the mock was called multiple times and we want to
    assert only some of the calls.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While testing the `Event` class, we only needed to mock out single functions.
    A more common use of mocking is to mock a class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The rest of this chapter builds on `test_driven_python-CHAPTER4_PART2` of the
    code bundle. Download it from from [https://github.com/siddhi/test_driven_python/archive/CHAPTER4_PART2.zip](https://github.com/siddhi/test_driven_python/archive/CHAPTER4_PART2.zip).
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the implementation of the `Alert` class in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down how this class works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Alert` class takes a `Rule` and an `Action` in the initializer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the `connect` method is called, it takes all the dependent stocks and connects
    to their `updated` event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `updated` event is an instance of the `Event` class that we saw earlier.
    Each `Stock` class has an instance of this event, and it is fired whenever a new
    update is made to that stock.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The listener for this event is the `self.check_rule` method of the `Alert` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this method, the alert checks if the new update caused a rule to be matched.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the rule matched, it calls the execute method on the `Action`. Otherwise,
    nothing happens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This class has a few requirements, as shown in the following, that need to be
    met. Each of these needs to be made into a unit test.
  prefs: []
  type: TYPE_NORMAL
- en: If a stock is updated, the class should check if the rule matches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the rule matches, then the corresponding action should be executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the rule doesn't match, then nothing happens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a number of different ways in which we could test this; let us go
    through some of the options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first option is not to use mocks at all. We could create a rule, hook it
    up to a test action, and then update the stock and verify that the action was
    executed. The following is what such a test would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is the most straightforward option, but it requires a bit of code to set
    up and there is the `TestAction` that we need to create just for the test case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of creating a test action, we could instead replace it with a mock
    action. We can then simply assert on the mock that it got executed. The following
    code shows this variation of the test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of observations about this test:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you notice, alert is not the usual `Mock` object that we have been using
    so far, but a `MagicMock` object. A `MagicMock` object is like a `Mock` object
    but it has special support for Python''s magic methods which are present on all
    classes, such as `__str__`, `hasattr`. If we don''t use `MagicMock`, we may sometimes
    get errors or strange behavior if the code uses any of these methods. The following
    example illustrates the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In general, we will be using `MagicMock` in most places where we need to mock
    a class. Using `Mock` is a good option when we need to mock stand alone functions,
    or in rare situations where we specifically don't want a default implementation
    for the magic methods.
  prefs: []
  type: TYPE_NORMAL
- en: The other observation about the test is the way methods are handled. In the
    test above, we created a mock action object, but we didn't specify anywhere that
    this mock class should contain an `execute` method and how it should behave. In
    fact, we don't need to. When a method or attribute is accessed on a mock object,
    Python conveniently creates a mock method and adds it to the mock class. Therefore,
    when the `Alert` class calls the `execute` method on our mock action object, that
    method is added to our mock action. We can then check that the method was called
    by asserting on `action.execute.called`.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of Python's behavior of automatically creating mock methods when
    they are accessed is that a typo or change in interface can go unnoticed.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose we rename the `execute` method in all the `Action` classes
    to run. But if we run our test cases, it still passes. Why does it pass? Because
    the `Alert` class calls the `execute` method, and the test only checks that the
    `execute` method was called, which it was. The test does not know that the name
    of the method has been changed in all the real `Action` implementations and that
    the `Alert` class will not work when integrated with the actual actions.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this problem, Python supports using another class or object as a specification.
    When a specification is given, the mock object only creates the methods that are
    present in the specification. All other method or attribute accesses will raise
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifications are passed to the mock at initialization time via the `spec`
    parameter. Both the `Mock` as well as `MagicMock` classes support setting a specification.
    The following code example shows the difference when a `spec` parameter is set
    compared to a default `Mock` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice in the above example that `mock_1` goes ahead and executes the `execute`
    method without any error, even though the method has been renamed in the `PrintAction`.
    On the other hand, by giving a spec, the method call to the nonexistent `execute`
    method raises an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking return values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second variant above showed how we could use a mock `Action` class in the
    test instead of a real one. In the same way, we can also use a mock rule instead
    of creating a `PriceRule` in the test. The alert calls the rule to see whether
    the new stock update caused the rule to be matched. What the alert does depends
    on whether the rule returned `True` or `False`.
  prefs: []
  type: TYPE_NORMAL
- en: All the mocks we've created so far have not had to return a value. We were just
    interested in whether the right call was made or not. If we mock the rule, then
    we will have to configure it to return the right value for the test. Fortunately,
    Python makes that very simple to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we have to do is to set the return value as a parameter in the constructor
    to the mock object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see above, the mock just blindly returns the set value, irrespective
    of the parameters. Even the type or number of parameters is not considered. We
    can use the same procedure to set the return value of a method in a mock object
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There is another way to set the return value, which is very convenient when
    dealing with methods in mock objects. Each mock object has a `return_value` attribute.
    We simply set this attribute to the return value and every call to the mock will
    return that value, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, the moment we access `rule.matches`, Python automatically
    creates a mock `matches` object and puts it in the `rule` object. This allows
    us to directly set the return value in one statement without having to create
    a mock for the `matches` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve seen how to set the return value, we can go ahead and change
    our test to use a mocked rule object, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two calls that the `Alert` makes to the rule: one to the `depends_on`
    method and the other to the matches method. We set the return value for both of
    them and the test passes.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In case no return value is explicitly set for a call, the default return value
    is to return a new mock object. The mock object is different for each method that
    is called, but is consistent for a particular method. This means if the same method
    is called multiple times, the same mock object will be returned each time.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking side effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, we come to the `Stock` class. This is the final dependency of the `Alert`
    class. We're currently creating `Stock` objects in our test, but we could replace
    it with a mock object just like we did for the `Action` and `PriceRule` classes.
  prefs: []
  type: TYPE_NORMAL
- en: The `Stock` class is again slightly different in behavior from the other two
    mock objects. The `update` method doesn't just return a value—it's primary behavior
    in this test is to trigger the updated event. Only if this event is triggered
    will the rule check occur.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do this, we must tell our mock stock class to fire the event when
    the `update` event is called. Mock objects have a `side_effect` attribute to enable
    us to do just this.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many reasons we might want to set a side effect. Some of them are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We may want to call another method, like in the case of the `Stock` class, which
    needs to fire the event when the `update` method is called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To raise an exception: this is particularly useful when testing error situations.
    Some errors such as a network timeout might be very difficult to simulate, and
    it is better to test using a mock that simply raises the appropriate exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To return multiple values: these may be different values each time the mock
    is called, or specific values, depending on the parameters passed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Setting the side effect is just like setting the return value. The only difference
    is that the side effect is a lambda function. When the mock is executed, the parameters
    are passed to the lambda function and the lambda is executed. The following is
    how we would use this with a mocked out `Stock` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: So what is going on in that test?
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a mock of the `Stock` class instead of using the real one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we add in the `updated` event. We need to do this because the `Stock`
    class creates the attribute at runtime in the `__init__` scope. Because the attribute
    is set dynamically, `MagicMock` does not pick up the attribute from the `spec`
    parameter. We are setting an actual `Event` object here. We could set it as a
    mock as well, but it is probably overkill to do that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we set the side effect for the `update` method in the mock stock object.
    The lambda takes the two parameters that the method does. In this particular example,
    we just want to fire the event, so the parameters aren't used in the lambda. In
    other cases, we might want to perform different actions based on the values of
    the parameters. Setting the `side_effect` attribute allows us to do that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just like with the `return_value` attribute, the `side_effect` attribute can
    also be set in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Run the test and it should pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `side_effect` attribute can also be set to an exception or a list. If it
    is set to an exception, then the given exception will be raised when the mock
    is called, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If it is set to a list, then the mock will return the next element of the list
    each time it is called. This is a good way to mock a function that has to return
    different values each time it is called, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As we have seen, the mocking framework's method of handling side effects using
    the `side_effect` attribute is very simple, yet quite powerful.
  prefs: []
  type: TYPE_NORMAL
- en: How much mocking is too much?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous few sections, we've seen the same test written with different
    levels of mocking. We started off with a test that didn't use any mocks at all,
    and subsequently mocked out each of the dependencies one by one. Which one of
    these solutions is the best?
  prefs: []
  type: TYPE_NORMAL
- en: As with many things, this is a point of personal preference. A purist would
    probably choose to mock out all dependencies. My personal preference is to use
    real objects when they are small and self-contained. I would not have mocked out
    the `Stock` class. This is because mocks generally require some configuration
    with return values or side effects, and this configuration can clutter the test
    and make it less readable. For small, self-contained classes, it is simpler to
    just use the real object.
  prefs: []
  type: TYPE_NORMAL
- en: At the other end of the spectrum, classes that might interact with external
    systems, or that take a lot of memory, or are slow are good candidates for mocking
    out. Additionally, objects that require a lot of dependencies on other object
    to initialize are candidates for mocking. With mocks, you just create an object,
    pass it in, and assert on parts that you are interested in checking. You don't
    have to create an entirely valid object.
  prefs: []
  type: TYPE_NORMAL
- en: Even here there are alternatives to mocking. For example, when dealing with
    a database, it is common to mock out the database calls and hardcode a return
    value into the mock. This is because the database might be on another server,
    and accessing it makes the tests slow and unreliable. However, instead of mocks,
    another option could be to use a fast in-memory database for the tests. This allows
    us to use a live database instead of a mocked out database. Which approach is
    better depends on the situation.
  prefs: []
  type: TYPE_NORMAL
- en: Mocks versus stubs versus fakes versus spies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've been talking about mocks so far, but we've been a little loose on the
    terminology. Technically, everything we've talked about falls under the category
    of a **test double**. A test double is some sort of fake object that we use to
    stand in for a real object in a test case.
  prefs: []
  type: TYPE_NORMAL
- en: Mocks are a specific kind of test double that record information about calls
    that have been made to it, so that we can assert on them later.
  prefs: []
  type: TYPE_NORMAL
- en: '**Stubs** are just an empty do-nothing kind of object or method. They are used
    when we don''t care about some functionality in the test. For example, imagine
    we have a method that performs a calculation and then sends an e-mail. If we are
    testing the calculation logic, we might just replace the e-mail sending method
    with an empty do-nothing method in the test case so that no e-mails are sent out
    while the test is running.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fakes** are a replacement of one object or system with a simpler one that
    facilitates easier testing. Using an in-memory database instead of the real one,
    or the way we created a dummy `TestAction` earlier in this chapter would be examples
    of fakes.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, **spies** are objects that are like middlemen. Like mocks, they record
    the calls so that we can assert on them later, but after recording, they continue
    execution to the original code. Spies are different from the other three in the
    sense that they do not replace any functionality. After recording the call, the
    real code is still executed. Spies sit in the middle and do not cause any change
    in execution pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Patching methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far we have looked at simple mocking patterns. These are the methods that
    you will use most of the time. Python's mocking framework doesn't stop there and
    has tremendous support for doing more complex things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at the `PrintAction` class (put this code in the file `action.py`
    in the `stock_alerter` directory) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple action, which, when the `execute` method is called, will just
    print out the alert description to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now, how do we go about testing this? What we want to test is that the action
    actually calls the print method with the right parameters. In the previous examples,
    we could create a mock object and pass it into the class instead of a real object.
    Here, there is no parameter or attribute that we can simply replace with a mock
    object.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this is to use **patching**. Patching is a way to replace a
    class or function in the global namespace with a mock version. Because Python
    allows dynamic access to the globals as well as all imported modules, we can just
    go in and change which object an identifier points to.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following sequence, you can see how we replace the `print` function
    with another one that takes one parameter and returns the double:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As we can see above, all calls to `print` now call our own function instead
    of the default printing implementation.
  prefs: []
  type: TYPE_NORMAL
- en: This gives us the hint we need to proceed with our mocking. What if we just
    replace the `print` with a mock before running the test? This way the code will
    end up executing our mock instead of the default print implementation, and we
    can then assert on the mock that it was called with the right parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: What's going on here?
  prefs: []
  type: TYPE_NORMAL
- en: First, we create the mock function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we save the default print implementation. We need to do this so that we
    can restore it properly at the end of the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we replace the default print with our mock function. Now, every time
    the print function is called, it will call our mock.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We run the test, wrapped around a `try` - `finally` block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `finally` block, we restore back the default print implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is very, very important to restore the default implementation back. Remember,
    we are changing the global information here, so if we don't restore it back, print
    will point to our mock function in all the subsequent tests as well. This can
    lead to some very strange behavior, for example, somewhere else we might expect
    some output on the screen and nothing is printed, and we end up spending hours
    trying to figure out why. This is the reason why the test is wrapped in the `try`
    - `finally` block. This way, the mock gets reset back to the default even if there
    is an exception thrown in the test.
  prefs: []
  type: TYPE_NORMAL
- en: We just saw how to patch in functions and classes with a mock, and since this
    is a fairly common task, Python gives us a really nice way to perform patching
    through the `mock.patch` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `mock.patch` function takes away a lot of the work needed to patch functions.
    Let us look at a couple of ways to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first way replicates the way we did our manual patching. We create a patcher
    and then use the `start` method to execute the patch, and the `stop` method to
    reset back the original implementation, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Like our manual patching, we have to be careful that the stop method gets called
    even if an exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'The patch can also be used as a context manager in conjunction with the `with`
    keyword. This syntax is a lot cleaner and generally preferable to calling start
    and stop ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us walk through what is going on here:'
  prefs: []
  type: TYPE_NORMAL
- en: The code where we want the patch to be active is wrapped inside the `with` block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We call the `patch` function, which returns the patcher to be used as a context
    manager. The mock object is set in the variable specified in the `as` section.
    In this case, the patched mock is set to `mock_print`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the block, we perform the test and assert as usual.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The patch is removed once execution comes out of the context block. This could
    be because all the statements were executed or due to an exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this syntax, we don't need to worry about unhandled exceptions causing
    a problem with the patch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `patch` function can also be used as a method decorator, as the following
    example shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: With this syntax, the patcher patches the required function and passes in the
    replacement mock object as the first parameter to the test method. We can then
    use the mock object as normal. The patch is reset once the test completes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to patch the same object for a number of tests, then we can use
    the class decorator syntax instead, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This syntax decorates all the tests in the class with the patch. By default,
    the decorator searches for methods that start with `test`. However, this can be
    changed by setting the `patch.TEST_PREFIX` attribute, and the class decorator
    will patch all methods that start with that prefix.
  prefs: []
  type: TYPE_NORMAL
- en: An important gotcha when patching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When patching, we should remember to patch exactly the object that the class
    is using. Python allows multiple references to an object, and it is easy to end
    up patching the wrong object. We would then spend hours wondering why the mock
    object isn't being executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, support file `alert.py` uses an import like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in the alert test, if we want to patch out `PriceRule`, then the following
    is the way we need to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Only if we do it this way will we patch the `PriceRule` object that is used
    in `alert.py` file. The following way will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This code will patch out `rule.PriceRule`, which is different from the actual
    object that we want to patch out. When we run this test, we'll see that the alert
    executes the real `PriceRule` object and not the one that we patched out.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is such a common mistake, we should check this first if ever we have
    problems with the test not executing the patched object correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Tying it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us tie this chapter together with a more complex example. The following
    is the code for the `EmailAction` class. This action sends an e-mail to the user
    when the rule is matched.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is how the library works:'
  prefs: []
  type: TYPE_NORMAL
- en: We instantiate the `SMTP` class in the `smtplib` library, passing it the server
    we want to connect to. This returns the `SMTP` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We call the `send_message` method on the `SMTP` object, passing in the e-mail
    message details in the form of a `MIMEText` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we call the `quit` method. This method always needs to be called, even
    if there was an exception in sending the message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Given this, we need to test the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The right calls are made to the `smtplib` library, with the right parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The message contents (from, to, subject, body) are correct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `quit` method is called even if an exception was thrown when sending the
    message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us start with a simple test. This test is for verifying that the `SMTP`
    class is initialized with the right parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: First, we start out by patching out the `SMTP` class in the `smtplib` module.
    Since we'll be doing this for every test, we set this up as a class decorator.
    We then instantiate the `EmailAction` that we want to test in the `setUp`.
  prefs: []
  type: TYPE_NORMAL
- en: The test itself is fairly simple. We call the `execute` method of the action
    and assert that the mock class was instantiated with the right parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following test verifies that the right calls are made to `SMTP` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There are a few new approaches in this test that are worth discussing.
  prefs: []
  type: TYPE_NORMAL
- en: First is the subtle difference in this series of tests where we are mocking
    the `SMTP` class and not an *object*. In the first test, we were checking the
    parameters passed to the constructor. Since we mocked the class, we could assert
    directly on our mock object.
  prefs: []
  type: TYPE_NORMAL
- en: In this test, we need to check that the right calls are made on the `SMTP` *object*.
    Since an object is the return value from initializing the class, we can access
    the mock `smtp` object from the return value of the mock `smtp` class. This is
    exactly what we are doing in the first line of the test.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we execute the action as usual.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we are using the `assert_has_calls` method to assert that the right
    calls were made. We could have asserted the calls like the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The main difference is that the above assertions do not assert the sequence.
    Suppose the action calls the `quit` method first and then calls `send_message`,
    it would still pass these two assertions. However, the `assert_has_calls` assertion
    not only checks that the methods were called, but also checks that the `quit`
    method is called after `send_message`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following third test checks that the connection is closed even if an exception
    is raised when sending the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we use the `side_effect` attribute to set the send message mock
    to raise an exception. We then check that the `quit` method was called even when
    the exception was raised.
  prefs: []
  type: TYPE_NORMAL
- en: In the last test, we need to check that the right message contents are passed
    to `send_message`. The function takes a `MIMEText` object as a parameter. How
    do we check that the right object was passed?
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is one way that *does not* work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the above test, we''ll get a failure like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that although the contents of the expected `MIMEText` object
    and the actual one passed to `send_message` are the same, the test still fails
    because they are both different objects. The mocking framework compares the two
    parameters by equality, and since both are two different objects, the test for
    equality fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'One approach around this problem is to go into the mock, extract the arguments
    that were passed in the call, and check that they contained the right data. The
    following is a test that uses this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Once the `execute` method is called, we then access the `call_args` attribute
    of the `mock` object to get the arguments that were passed to `send_message`.
    We take the first parameter, which is the `MIMEText` object that we are interested
    in. We then assert that the subject was as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more elegant way is possible. Remember we said that the mocking framework
    compares parameters by equality? This means that we can pass in an object that
    implements the `__eq__` special method and use that to perform any comparison
    that we want. The following is one such class for checking equality between two
    `MIMEText` messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This class basically takes a dictionary of values, and then can be used to
    compare whether a `MIMEText` object contains those values (at least the values
    we are interested in). Since it implements the `__eq__` method, a direct equality
    can be used to check, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this technique to pass in such an object as the expected parameter
    of a test like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Writing custom parameter matchers like this is an easy way to assert on parameters
    for which we might not have direct object access, or when we want to compare only
    a few attributes of the object for the purposes of the test.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you looked at how to use mocks to test interactions between
    objects. You saw how to hand write our own mocks, followed by using the mocking
    framework provided in the Python standard library. Next, you saw how to use patching
    for more advanced mocking. We wrapped it up by looking at a slightly more complex
    mocking example that had us put all the mocking techniques into practice.
  prefs: []
  type: TYPE_NORMAL
- en: So far you have been looking at writing tests for new code. In the next chapter,
    you will take a look at how to deal with existing code that does not have tests.
  prefs: []
  type: TYPE_NORMAL
