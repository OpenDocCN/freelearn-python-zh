- en: Chapter 4. Using Mock Objects to Test Interactions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：使用模拟对象测试交互
- en: 'Having looked at the `Rule` and `Stock` classes, let us now turn our attention
    to the `Event` class. The `Event` class is very simple: receivers can register
    with the event to be notified when the event occurs. When the event fires, all
    the receivers are notified of the event.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看`Rule`和`Stock`类之后，现在让我们将注意力转向`Event`类。`Event`类非常简单：接收者可以注册事件，以便在事件发生时收到通知。当事件触发时，所有接收者都会收到事件的通知。
- en: 'A more detailed description is as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细的描述如下：
- en: Event classes have a `connect` method, which takes a method or function to be
    called when the event fires
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件类有一个`connect`方法，该方法在事件触发时调用一个方法或函数
- en: When the `fire` method is called, all the registered callbacks are called with
    the same parameters that are passed to the `fire` method
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用`fire`方法时，所有注册的回调函数都会用传递给`fire`方法的相同参数被调用
- en: Writing tests for the `connect` method is fairly straightforward—we just need
    to check that the receivers are being stored properly. But, how do we write the
    tests for the fire method? This method does not change any state or store any
    value that we can assert on. The main responsibility of this method is to call
    other methods. How do we test that this is being done correctly?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为`connect`方法编写测试相当直接——我们只需检查接收者是否被正确存储。但是，我们如何编写`fire`方法的测试？此方法不会更改任何状态或存储任何我们可以断言的值。此方法的主要责任是调用其他方法。我们如何测试这是否被正确执行？
- en: This is where mock objects come into the picture. Unlike ordinary unit tests
    that assert on object *state*, mock objects are used to test that the *interactions*
    between multiple objects occurs as it should.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是模拟对象出现的地方。与断言对象*状态*的普通单元测试不同，模拟对象用于测试多个对象之间的*交互*是否按预期发生。
- en: Hand writing a simple mock
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手写一个简单的模拟
- en: 'To start with, let us look at the code for the `Event` class so that we can
    understand what the tests need to do. The following code is in the file `event.py`
    in the source directory:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看`Event`类的代码，以便我们了解测试需要做什么。以下代码位于源目录中的`event.py`文件中：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The way this code works is fairly simple. Classes that want to get notified
    of the event should call the `connect` method and pass a function. This will register
    the function for the event. Then, when the event is fired using the `fire` method,
    all the registered functions will be notified of the event. The following is a
    walk-through of how this class is used:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的工作方式相当简单。希望收到事件通知的类应该调用`connect`方法并传递一个函数。这将注册该函数用于事件。然后，当使用`fire`方法触发事件时，所有注册的函数都会收到事件的通知。以下是如何使用此类的一个概述：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, every time the `fire` method is called, all the functions that
    registered with the `connect` method get called with the given parameters.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每次调用`fire`方法时，所有使用`connect`方法注册的函数都会用给定的参数被调用。
- en: 'So, how do we test the `fire` method? The walk-through above gives a hint.
    What we need to do is to create a function, register it using the `connect` method,
    and then verify that the method got notified when the `fire` method was called.
    The following is one way to write such a test:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何测试`fire`方法？上面的概述提供了一个提示。我们需要做的是创建一个函数，使用`connect`方法注册它，然后验证当调用`fire`方法时该方法是否被通知。以下是一种编写此类测试的方法：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Put this code into the `test_event.py` file in the tests folder and run the
    test. The test should pass. The following is what we are doing:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码放入测试文件夹中的`test_event.py`文件，并运行测试。测试应该通过。以下是我们所做的工作：
- en: First, we create a variable named called and set it to `False`.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为`called`的变量并将其设置为`False`。
- en: Next, we create a dummy function. When the function is called, it sets called
    to `True`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个虚拟函数。当函数被调用时，它将`called`设置为`True`。
- en: Finally, we connect the dummy function to the event and fire the event.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将虚拟函数连接到事件并触发事件。
- en: If the dummy function was successfully called when the event was fired, then
    the `called` variable would be changed to `True`, and we assert that the variable
    is indeed what we expected.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在事件触发时成功调用了虚拟函数，则`called`变量将被更改为`True`，我们断言该变量确实是我们预期的。
- en: The dummy function we created above is an example of a mock. A **mock** is simply
    an object that is substituted for a real object in the test case. The mock then
    records some information such as whether it was called, what parameters were passed,
    and so on, and we can then assert that the mock was called as expected.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面创建的虚拟函数是一个模拟的例子。**模拟**简单地说是一个在测试用例中替代真实对象的对象。模拟会记录一些信息，例如它是否被调用，传入了哪些参数等，然后我们可以断言模拟按预期被调用。
- en: 'Talking about parameters, we should write a test that checks that the parameters
    are being passed correctly. The following is one such test:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到参数，我们应该编写一个测试来检查参数是否被正确传入。以下是一个这样的测试：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This test is the same as the previous one, except that it saves the parameters
    that are then used in the assert to verify that they were passed properly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试与上一个测试相同，只是它保存了参数，然后在断言中用来验证它们是否正确传入。
- en: 'At this point, we can see some repetition coming up in the way we set up the
    mock function and then save some information about the call. We can extract this
    code into a separate class as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以看到我们在设置模拟函数和保存调用信息的方式上出现了一些重复。我们可以将这段代码提取到一个单独的类中，如下所示：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once we do this, we can use our `Mock` class in our tests as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做，我们就可以在我们的测试中使用`Mock`类，如下所示：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What we have just done is to create a simple mocking class that is quite lightweight
    and good for simple uses. However, there are often times when we need much more
    advanced functionality, such as mocking a series of calls or checking the order
    of specific calls. Fortunately, Python has us covered with the `unittest.mock`
    module that is supplied as a part of the standard library.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚做的是创建了一个简单的模拟类，它相当轻量级，适用于简单用途。然而，我们经常需要更高级的功能，比如模拟一系列调用或检查特定调用的顺序。幸运的是，Python通过标准库提供的`unittest.mock`模块为我们提供了支持。
- en: Using the Python mocking framework
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python模拟框架
- en: The `unittest.mock` module provided by Python is an extremely powerful mocking
    framework, yet at the same time it is very easy to use.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供的`unittest.mock`模块是一个非常强大的模拟框架，同时它也非常容易使用。
- en: 'Let us redo our tests using this library. First, we need to import the `mock`
    module at the top of our file as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个库重做我们的测试。首先，我们需要在文件顶部导入`mock`模块，如下所示：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we rewrite our first test as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将我们的第一个测试重写如下：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The only change that we've made is to replace our own custom `Mock` class with
    the `mock.Mock` class provided by Python. That is it. With that single line change,
    our test is now using the inbuilt mocking class.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的唯一改变是将我们自己的自定义`Mock`类替换为Python提供的`mock.Mock`类。就是这样。通过这一行更改，我们的测试现在正在使用内置的模拟类。
- en: The `unittest.mock.Mock` class is the core of the Python mocking framework.
    All we need to do is to instantiate the class and pass it in where it is required.
    The mock will record if it was called in the `called` instance variable.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest.mock.Mock`类是Python模拟框架的核心。我们只需要实例化这个类，并将其传递到需要的地方。模拟将在`called`实例变量中记录是否被调用。'
- en: 'How do we check that the right parameters were passed? Let us look at the rewrite
    of the second test as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何检查是否传入了正确的参数？让我们看看第二个测试的重写如下：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The mock object automatically records the parameters that were passed in. We
    can assert on the parameters by using the `assert_called_with` method on the `mock`
    object. The method will raise an assertion error if the parameters don't match
    what was expected. In case we are not interested in testing the parameters (maybe
    we just want to check that the method was called), then we can pass the value
    `mock.ANY`. This value will match any parameter passed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象会自动记录传入的参数。我们可以通过在`mock`对象上使用`assert_called_with`方法来断言参数。如果参数与预期不符，该方法将引发断言错误。如果我们对测试参数不感兴趣（可能我们只想检查方法是否被调用），则可以传递`mock.ANY`值。这个值将匹配任何传入的参数。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is a subtle difference in the way normal assertions are called compared
    to assertions on mocks. Normal assertions are defined as a part of the `unittest.Testcase`
    class. Since our tests inherit from that class, we call the assertions on self,
    for example, `self.assertEquals`. On the other hand, the mock assertion methods
    are a part of the `mock` object, so you call them on the mock object, for example,
    `listener.assert_called_with`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与模拟上的断言相比，调用正常断言的方式有细微的差别。正常断言定义为`unittest.Testcase`类的一部分。由于我们的测试继承自该类，我们通过self调用断言，例如`self.assertEquals`。另一方面，模拟断言方法属于`mock`对象的一部分，所以你通过模拟对象调用它们，例如`listener.assert_called_with`。
- en: 'Mock objects have the following four assertions available out of the box:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象默认有四个断言可用：
- en: '`assert_called_with`: This method asserts that the last call was made with
    the given parameters'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert_called_with`：此方法断言最后一次调用是用给定的参数进行的'
- en: '`assert_called_once_with`: This assertion checks that the method was called
    exactly once and was with the given parameters'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert_called_once_with`：这个断言检查方法是否恰好一次被调用，并且带有给定的参数'
- en: '`assert_any_call`: This checks that the given call was made at some point during
    the execution'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert_any_call`：这个方法检查在执行过程中是否在某个时刻调用了给定的调用'
- en: '`assert_has_calls`: This assertion checks that a list of calls occurred'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert_has_calls`：这个断言检查是否发生了一系列调用'
- en: The four assertions are very subtly different, and that shows up when the mock
    has been called more than one. The `assert_called_with` method only checks the
    last call, so if there was more than one call, then the previous calls will not
    be asserted. The `assert_any_call` method will check if a call with the given
    parameters occurred anytime during execution. The `assert_called_once_with` assertion
    asserts for a single call, so if the mock was called more than once during execution,
    then this assert would fail. The `assert_has_calls` assertion can be used to assert
    that a set of calls with the given parameters occurred. Note that there might
    have been more calls than what we checked for in the assertion, but the assertion
    would still pass as long as the given calls are present.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 四个断言非常微妙地不同，当模拟被多次调用时就会显现出来。`assert_called_with`方法只检查最后一次调用，所以如果有多次调用，则之前的调用将不会被断言。`assert_any_call`方法将检查在执行过程中是否发生了具有给定参数的调用。`assert_called_once_with`断言断言单个调用，所以如果模拟在执行过程中被多次调用，则此断言将失败。`assert_has_calls`断言可以用来断言具有给定参数的一组调用发生了。请注意，断言中检查的调用可能比我们检查的更多，但只要给定的调用存在，断言仍然会通过。
- en: 'Let us take a closer look at the `assert_has_calls` assertion. Here is how
    we can write the same test using this assertion:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看`assert_has_calls`断言。以下是我们可以使用此断言编写的相同测试：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The mocking framework internally uses `_Call` objects to record calls. The `mock.call`
    function is a helper to create these objects. We just call it with the expected
    parameters to create the required call objects. We can then use these objects
    in the `assert_has_calls` assertion to assert that the expected call occurred.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟框架内部使用`_Call`对象来记录调用。`mock.call`函数是一个创建这些对象的辅助工具。我们只需用预期的参数调用它来创建所需的调用对象。然后我们可以使用这些对象在`assert_has_calls`断言中，以断言预期的调用发生了。
- en: This method is useful when the mock was called multiple times and we want to
    assert only some of the calls.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当模拟被多次调用时，此方法很有用，我们只想断言一些调用。
- en: Mocking objects
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟对象
- en: While testing the `Event` class, we only needed to mock out single functions.
    A more common use of mocking is to mock a class.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试`Event`类时，我们只需要模拟单个函数。模拟的更常见用途是模拟一个类。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The rest of this chapter builds on `test_driven_python-CHAPTER4_PART2` of the
    code bundle. Download it from from [https://github.com/siddhi/test_driven_python/archive/CHAPTER4_PART2.zip](https://github.com/siddhi/test_driven_python/archive/CHAPTER4_PART2.zip).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分基于代码包中的`test_driven_python-CHAPTER4_PART2`。您可以从[https://github.com/siddhi/test_driven_python/archive/CHAPTER4_PART2.zip](https://github.com/siddhi/test_driven_python/archive/CHAPTER4_PART2.zip)下载。
- en: 'Take a look at the implementation of the `Alert` class in the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`Alert`类实现的查看：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s break down how this class works as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按以下方式分解这个类的工作原理：
- en: The `Alert` class takes a `Rule` and an `Action` in the initializer.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Alert`类在初始化器中接受一个`Rule`和一个`Action`。'
- en: When the `connect` method is called, it takes all the dependent stocks and connects
    to their `updated` event.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用`connect`方法时，它获取所有依赖的股票并将它们连接到它们的`updated`事件。
- en: The `updated` event is an instance of the `Event` class that we saw earlier.
    Each `Stock` class has an instance of this event, and it is fired whenever a new
    update is made to that stock.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updated`事件是我们之前看到的`Event`类的一个实例。每个`Stock`类都有一个此事件的实例，并且每当对那个股票进行新更新时，它就会被触发。'
- en: The listener for this event is the `self.check_rule` method of the `Alert` class.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此事件的监听器是`Alert`类的`self.check_rule`方法。
- en: In this method, the alert checks if the new update caused a rule to be matched.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种方法中，警报检查新更新是否导致匹配了规则。
- en: If the rule matched, it calls the execute method on the `Action`. Otherwise,
    nothing happens.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果规则匹配，它会在`Action`上调用执行方法。否则，不会发生任何操作。
- en: This class has a few requirements, as shown in the following, that need to be
    met. Each of these needs to be made into a unit test.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 该类有一些要求，如下所示，需要满足。这些要求中的每一个都需要被制作成一个单元测试。
- en: If a stock is updated, the class should check if the rule matches
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果股票被更新，类应该检查规则是否匹配
- en: If the rule matches, then the corresponding action should be executed
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果规则匹配，则应该执行相应的操作
- en: If the rule doesn't match, then nothing happens
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果规则不匹配，则不会发生任何操作
- en: There are a number of different ways in which we could test this; let us go
    through some of the options.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以多种不同的方式测试这一点；让我们来看看一些选项。
- en: 'The first option is not to use mocks at all. We could create a rule, hook it
    up to a test action, and then update the stock and verify that the action was
    executed. The following is what such a test would look like:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项是完全不使用模拟。我们可以创建一个规则，将其连接到测试操作，然后更新库存并验证操作是否已执行。以下是一个这样的测试示例：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is the most straightforward option, but it requires a bit of code to set
    up and there is the `TestAction` that we need to create just for the test case.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最直接的选择，但需要一些代码来设置，并且我们需要为测试用例创建一个`TestAction`。
- en: 'Instead of creating a test action, we could instead replace it with a mock
    action. We can then simply assert on the mock that it got executed. The following
    code shows this variation of the test case:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不用创建测试动作，而是用模拟动作来替换它。然后我们可以简单地断言模拟动作已被执行。以下代码展示了这种测试用例的变体：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A couple of observations about this test:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个测试的一些观察：
- en: 'If you notice, alert is not the usual `Mock` object that we have been using
    so far, but a `MagicMock` object. A `MagicMock` object is like a `Mock` object
    but it has special support for Python''s magic methods which are present on all
    classes, such as `__str__`, `hasattr`. If we don''t use `MagicMock`, we may sometimes
    get errors or strange behavior if the code uses any of these methods. The following
    example illustrates the difference:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到，警报不是我们迄今为止常用的普通`Mock`对象，而是一个`MagicMock`对象。`MagicMock`对象就像一个`Mock`对象，但它对Python上所有类都存在的特殊方法提供了支持，例如`__str__`、`hasattr`。如果我们不使用`MagicMock`，当代码使用这些方法中的任何一种时，我们有时可能会遇到错误或奇怪的行为。以下示例说明了这种差异：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In general, we will be using `MagicMock` in most places where we need to mock
    a class. Using `Mock` is a good option when we need to mock stand alone functions,
    or in rare situations where we specifically don't want a default implementation
    for the magic methods.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们将在需要模拟类的大多数地方使用`MagicMock`。当我们需要模拟独立函数，或者在罕见情况下我们明确不想为魔法方法提供默认实现时，使用`Mock`是一个好选择。
- en: The other observation about the test is the way methods are handled. In the
    test above, we created a mock action object, but we didn't specify anywhere that
    this mock class should contain an `execute` method and how it should behave. In
    fact, we don't need to. When a method or attribute is accessed on a mock object,
    Python conveniently creates a mock method and adds it to the mock class. Therefore,
    when the `Alert` class calls the `execute` method on our mock action object, that
    method is added to our mock action. We can then check that the method was called
    by asserting on `action.execute.called`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个测试的另一个观察点是处理方法的方式。在上面的测试中，我们创建了一个模拟动作对象，但我们在任何地方都没有指定这个模拟类应该包含一个`execute`方法以及它的行为方式。实际上，我们不需要这样做。当在模拟对象上访问方法或属性时，Python会方便地创建一个模拟方法并将其添加到模拟类中。因此，当`Alert`类在我们的模拟动作对象上调用`execute`方法时，该方法就被添加到我们的模拟动作中。然后我们可以通过断言`action.execute.called`来检查该方法是否被调用。
- en: The downside of Python's behavior of automatically creating mock methods when
    they are accessed is that a typo or change in interface can go unnoticed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Python在访问时自动创建模拟方法的特性有一个缺点，那就是打字错误或接口更改可能不会被察觉。
- en: For example, suppose we rename the `execute` method in all the `Action` classes
    to run. But if we run our test cases, it still passes. Why does it pass? Because
    the `Alert` class calls the `execute` method, and the test only checks that the
    `execute` method was called, which it was. The test does not know that the name
    of the method has been changed in all the real `Action` implementations and that
    the `Alert` class will not work when integrated with the actual actions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们将所有 `Action` 类中的 `execute` 方法重命名为 `run`。但如果我们运行测试用例，它仍然通过。为什么它会通过？因为
    `Alert` 类调用了 `execute` 方法，而测试只检查 `execute` 方法是否被调用，它确实被调用了。测试不知道在所有真实的 `Action`
    实现中方法名称已被更改，并且当与实际操作集成时，`Alert` 类将无法工作。
- en: To avoid this problem, Python supports using another class or object as a specification.
    When a specification is given, the mock object only creates the methods that are
    present in the specification. All other method or attribute accesses will raise
    an error.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，Python 支持使用另一个类或对象作为规范。当提供规范时，模拟对象只创建规范中存在的那些方法。所有其他方法或属性访问将引发错误。
- en: 'Specifications are passed to the mock at initialization time via the `spec`
    parameter. Both the `Mock` as well as `MagicMock` classes support setting a specification.
    The following code example shows the difference when a `spec` parameter is set
    compared to a default `Mock` object:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 规范是通过初始化时的 `spec` 参数传递给模拟的。`Mock` 和 `MagicMock` 类都支持设置规范。以下代码示例显示了设置 `spec`
    参数与默认 `Mock` 对象之间的差异：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice in the above example that `mock_1` goes ahead and executes the `execute`
    method without any error, even though the method has been renamed in the `PrintAction`.
    On the other hand, by giving a spec, the method call to the nonexistent `execute`
    method raises an exception.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在上述示例中，`mock_1` 在没有错误的情况下执行了 `execute` 方法，尽管在 `PrintAction` 中该方法已被重命名。另一方面，通过提供一个规范，对不存在的
    `execute` 方法的调用将引发异常。
- en: Mocking return values
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟返回值
- en: The second variant above showed how we could use a mock `Action` class in the
    test instead of a real one. In the same way, we can also use a mock rule instead
    of creating a `PriceRule` in the test. The alert calls the rule to see whether
    the new stock update caused the rule to be matched. What the alert does depends
    on whether the rule returned `True` or `False`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的第二个变体展示了我们如何在测试中使用模拟的 `Action` 类而不是真实的一个。同样，我们也可以在测试中使用模拟规则而不是创建 `PriceRule`。警报调用规则以查看新的库存更新是否导致规则匹配。警报的行为取决于规则返回
    `True` 还是 `False`。
- en: All the mocks we've created so far have not had to return a value. We were just
    interested in whether the right call was made or not. If we mock the rule, then
    we will have to configure it to return the right value for the test. Fortunately,
    Python makes that very simple to do.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止创建的所有模拟都不需要返回值。我们只对是否调用了正确的调用感兴趣。如果我们模拟规则，那么我们必须配置它以返回测试的正确值。幸运的是，Python
    使这变得非常简单。
- en: 'All we have to do is to set the return value as a parameter in the constructor
    to the mock object as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所需要做的就是将返回值作为参数设置在模拟对象的构造函数中，如下所示：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As we can see above, the mock just blindly returns the set value, irrespective
    of the parameters. Even the type or number of parameters is not considered. We
    can use the same procedure to set the return value of a method in a mock object
    as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，模拟只是盲目地返回设置的值，不考虑参数。甚至不考虑参数的类型或数量。我们可以使用相同的程序来设置模拟对象中方法的返回值，如下所示：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There is another way to set the return value, which is very convenient when
    dealing with methods in mock objects. Each mock object has a `return_value` attribute.
    We simply set this attribute to the return value and every call to the mock will
    return that value, as shown in the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 设置返回值还有另一种方法，当处理模拟对象中的方法时非常方便。每个模拟对象都有一个 `return_value` 属性。我们只需将此属性设置为返回值，每次调用模拟对象都会返回该值，如下所示：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the example above, the moment we access `rule.matches`, Python automatically
    creates a mock `matches` object and puts it in the `rule` object. This allows
    us to directly set the return value in one statement without having to create
    a mock for the `matches` method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，当我们访问 `rule.matches` 时，Python 会自动创建一个模拟的 `matches` 对象并将其放入 `rule` 对象中。这允许我们直接在一条语句中设置返回值，而无需为
    `matches` 方法创建模拟。
- en: 'Now that we''ve seen how to set the return value, we can go ahead and change
    our test to use a mocked rule object, as shown in the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何设置返回值，我们可以继续更改我们的测试，使用模拟规则对象，如下所示：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There are two calls that the `Alert` makes to the rule: one to the `depends_on`
    method and the other to the matches method. We set the return value for both of
    them and the test passes.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Alert` 对规则进行了两次调用：一次是 `depends_on` 方法，另一次是 `matches` 方法。我们为这两个方法都设置了返回值，并且测试通过了。'
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In case no return value is explicitly set for a call, the default return value
    is to return a new mock object. The mock object is different for each method that
    is called, but is consistent for a particular method. This means if the same method
    is called multiple times, the same mock object will be returned each time.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有为调用显式设置返回值，则默认返回值是返回一个新的模拟对象。对于每个被调用的方法，模拟对象都不同，但对于特定方法是一致的。这意味着如果多次调用相同的方法，每次都会返回相同的模拟对象。
- en: Mocking side effects
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟副作用
- en: Finally, we come to the `Stock` class. This is the final dependency of the `Alert`
    class. We're currently creating `Stock` objects in our test, but we could replace
    it with a mock object just like we did for the `Action` and `PriceRule` classes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到 `Stock` 类。这是 `Alert` 类的最终依赖项。我们目前在测试中创建 `Stock` 对象，但我们可以像对 `Action`
    和 `PriceRule` 类所做的那样，用模拟对象替换它。
- en: The `Stock` class is again slightly different in behavior from the other two
    mock objects. The `update` method doesn't just return a value—it's primary behavior
    in this test is to trigger the updated event. Only if this event is triggered
    will the rule check occur.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stock` 类在行为上与其他两个模拟对象略有不同。`update` 方法不仅仅返回一个值——在这个测试中，其主要行为是触发更新事件。只有当这个事件被触发时，规则检查才会发生。'
- en: In order to do this, we must tell our mock stock class to fire the event when
    the `update` event is called. Mock objects have a `side_effect` attribute to enable
    us to do just this.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们必须告诉我们的模拟股票类在调用 `update` 事件时触发事件。模拟对象有一个 `side_effect` 属性，使我们能够做到这一点。
- en: 'There are many reasons we might want to set a side effect. Some of them are
    as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能有多种原因想要设置副作用。以下是一些原因：
- en: We may want to call another method, like in the case of the `Stock` class, which
    needs to fire the event when the `update` method is called.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能想要调用另一个方法，比如在 `Stock` 类的例子中，当调用 `update` 方法时需要触发事件。
- en: 'To raise an exception: this is particularly useful when testing error situations.
    Some errors such as a network timeout might be very difficult to simulate, and
    it is better to test using a mock that simply raises the appropriate exception.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了引发异常：这在测试错误情况时特别有用。一些错误，如网络超时，可能很难模拟，使用仅引发适当异常的模拟进行测试会更好。
- en: 'To return multiple values: these may be different values each time the mock
    is called, or specific values, depending on the parameters passed.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了返回多个值：这些值可能每次调用模拟时都不同，或者根据传递的参数返回特定的值。
- en: 'Setting the side effect is just like setting the return value. The only difference
    is that the side effect is a lambda function. When the mock is executed, the parameters
    are passed to the lambda function and the lambda is executed. The following is
    how we would use this with a mocked out `Stock` class:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 设置副作用就像设置返回值一样。唯一的区别是副作用是一个 lambda 函数。当模拟执行时，参数会被传递给 lambda 函数，然后执行 lambda。以下是我们如何使用模拟的
    `Stock` 类来做到这一点：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So what is going on in that test?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，那个测试中发生了什么？
- en: First, we create a mock of the `Stock` class instead of using the real one.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建 `Stock` 类的模拟而不是使用真实的一个。
- en: Next, we add in the `updated` event. We need to do this because the `Stock`
    class creates the attribute at runtime in the `__init__` scope. Because the attribute
    is set dynamically, `MagicMock` does not pick up the attribute from the `spec`
    parameter. We are setting an actual `Event` object here. We could set it as a
    mock as well, but it is probably overkill to do that.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加了 `updated` 事件。我们需要这样做，因为 `Stock` 类在 `__init__` 范围内运行时创建属性。因为属性是动态设置的，`MagicMock`
    不会从 `spec` 参数中获取属性。我们在这里设置了一个实际的 `Event` 对象。我们也可以将其设置为模拟，但这可能有些过度。
- en: Finally, we set the side effect for the `update` method in the mock stock object.
    The lambda takes the two parameters that the method does. In this particular example,
    we just want to fire the event, so the parameters aren't used in the lambda. In
    other cases, we might want to perform different actions based on the values of
    the parameters. Setting the `side_effect` attribute allows us to do that.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在模拟股票对象中设置了`update`方法的副作用。lambda函数接受方法所需的两个参数。在这个特定的例子中，我们只想触发事件，所以参数在lambda函数中没有使用。在其他情况下，我们可能希望根据参数的值执行不同的操作。设置`side_effect`属性允许我们做到这一点。
- en: Just like with the `return_value` attribute, the `side_effect` attribute can
    also be set in the constructor.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`return_value`属性一样，`side_effect`属性也可以在构造函数中设置。
- en: Run the test and it should pass.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试，它应该通过。
- en: 'The `side_effect` attribute can also be set to an exception or a list. If it
    is set to an exception, then the given exception will be raised when the mock
    is called, as shown in the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`side_effect`属性也可以设置为异常或列表。如果设置为异常，那么在调用模拟时将抛出给定的异常，如下所示：'
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If it is set to a list, then the mock will return the next element of the list
    each time it is called. This is a good way to mock a function that has to return
    different values each time it is called, as shown in the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将其设置为列表，那么每次调用模拟时，模拟将返回列表的下一个元素。这是一种模拟每次调用都要返回不同值的函数的好方法，如下所示：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we have seen, the mocking framework's method of handling side effects using
    the `side_effect` attribute is very simple, yet quite powerful.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，模拟框架通过使用`side_effect`属性来处理副作用的方法非常简单，但非常强大。
- en: How much mocking is too much?
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟过多怎么办？
- en: In the previous few sections, we've seen the same test written with different
    levels of mocking. We started off with a test that didn't use any mocks at all,
    and subsequently mocked out each of the dependencies one by one. Which one of
    these solutions is the best?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的几个部分中，我们看到了使用不同级别的模拟编写的相同测试。我们从一个完全不使用任何模拟的测试开始，然后逐个模拟每个依赖项。这些解决方案中哪一个最好？
- en: As with many things, this is a point of personal preference. A purist would
    probably choose to mock out all dependencies. My personal preference is to use
    real objects when they are small and self-contained. I would not have mocked out
    the `Stock` class. This is because mocks generally require some configuration
    with return values or side effects, and this configuration can clutter the test
    and make it less readable. For small, self-contained classes, it is simpler to
    just use the real object.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多事情一样，这是一个个人偏好的问题。一个纯粹主义者可能会选择模拟所有依赖项。我个人的偏好是在对象小且自包含时使用真实对象。我不会模拟`Stock`类。这是因为模拟通常需要与返回值或副作用进行一些配置，这种配置可能会使测试变得杂乱无章，并使其可读性降低。对于小而自包含的类，直接使用真实对象会更简单。
- en: At the other end of the spectrum, classes that might interact with external
    systems, or that take a lot of memory, or are slow are good candidates for mocking
    out. Additionally, objects that require a lot of dependencies on other object
    to initialize are candidates for mocking. With mocks, you just create an object,
    pass it in, and assert on parts that you are interested in checking. You don't
    have to create an entirely valid object.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一端，可能与外部系统交互的类、占用大量内存或运行缓慢的类是模拟的好候选。此外，需要大量其他对象来初始化的对象也是模拟的候选。使用模拟，你只需创建一个对象，传递它，并断言你感兴趣检查的部分。你不需要创建一个完全有效的对象。
- en: Even here there are alternatives to mocking. For example, when dealing with
    a database, it is common to mock out the database calls and hardcode a return
    value into the mock. This is because the database might be on another server,
    and accessing it makes the tests slow and unreliable. However, instead of mocks,
    another option could be to use a fast in-memory database for the tests. This allows
    us to use a live database instead of a mocked out database. Which approach is
    better depends on the situation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这里，也有模拟的替代方案。例如，当处理数据库时，通常会将数据库调用模拟出来，并将返回值硬编码到模拟中。这是因为数据库可能位于另一台服务器上，访问它会使测试变慢且不可靠。然而，而不是使用模拟，另一个选择可能是为测试使用快速内存数据库。这允许我们使用实时数据库而不是模拟数据库。哪种方法更好取决于具体情况。
- en: Mocks versus stubs versus fakes versus spies
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟与存根与伪造与间谍之间的比较
- en: We've been talking about mocks so far, but we've been a little loose on the
    terminology. Technically, everything we've talked about falls under the category
    of a **test double**. A test double is some sort of fake object that we use to
    stand in for a real object in a test case.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在谈论模拟，但在术语上我们有点宽松。从技术上讲，我们谈论的所有内容都属于**测试双倍**的范畴。测试双倍是我们用来在测试用例中代替真实对象的某种假对象。
- en: Mocks are a specific kind of test double that record information about calls
    that have been made to it, so that we can assert on them later.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是一种特定的测试双倍，它会记录对它的调用信息，这样我们就可以稍后对它们进行断言。
- en: '**Stubs** are just an empty do-nothing kind of object or method. They are used
    when we don''t care about some functionality in the test. For example, imagine
    we have a method that performs a calculation and then sends an e-mail. If we are
    testing the calculation logic, we might just replace the e-mail sending method
    with an empty do-nothing method in the test case so that no e-mails are sent out
    while the test is running.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**存根**只是一个空的不做任何事情的对象或方法。当我们对测试中的某些功能不关心时，我们会使用它们。例如，假设我们有一个执行计算然后发送电子邮件的方法。如果我们正在测试计算逻辑，我们可能会在测试用例中将电子邮件发送方法替换为一个空的不做任何事情的方法，这样在测试运行时就不会发送任何电子邮件。'
- en: '**Fakes** are a replacement of one object or system with a simpler one that
    facilitates easier testing. Using an in-memory database instead of the real one,
    or the way we created a dummy `TestAction` earlier in this chapter would be examples
    of fakes.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**伪造**是用一个更简单的对象或系统替换一个对象或系统，以简化测试。使用内存数据库而不是真实数据库，或者我们在本章前面创建的`TestAction`的示例，都是伪造的例子。'
- en: Finally, **spies** are objects that are like middlemen. Like mocks, they record
    the calls so that we can assert on them later, but after recording, they continue
    execution to the original code. Spies are different from the other three in the
    sense that they do not replace any functionality. After recording the call, the
    real code is still executed. Spies sit in the middle and do not cause any change
    in execution pattern.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**间谍**是类似于中间人的对象。像模拟一样，它们记录调用以便我们稍后可以对它们进行断言，但在记录之后，它们继续执行原始代码。与另外三个不同，间谍不会替换任何功能。在记录调用后，真实代码仍然被执行。间谍位于中间，不会导致执行模式发生变化。
- en: Patching methods
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法修补
- en: So far we have looked at simple mocking patterns. These are the methods that
    you will use most of the time. Python's mocking framework doesn't stop there and
    has tremendous support for doing more complex things.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了简单的模拟模式。这些是在大多数情况下你会使用的的方法。Python的模拟框架并没有止步于此，它对更复杂的事情提供了巨大的支持。
- en: 'Let us look at the `PrintAction` class (put this code in the file `action.py`
    in the `stock_alerter` directory) as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`PrintAction`类（将此代码放入`stock_alerter`目录下的`action.py`文件中）如下：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is a simple action, which, when the `execute` method is called, will just
    print out the alert description to the screen.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的动作，当调用`execute`方法时，它只会将警报描述打印到屏幕上。
- en: Now, how do we go about testing this? What we want to test is that the action
    actually calls the print method with the right parameters. In the previous examples,
    we could create a mock object and pass it into the class instead of a real object.
    Here, there is no parameter or attribute that we can simply replace with a mock
    object.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们如何进行测试呢？我们想要测试的是动作实际上以正确的参数调用打印方法。在先前的例子中，我们可以创建一个模拟对象并将其传递到类中，而不是传递一个真实对象。在这里，没有参数或属性我们可以简单地用模拟对象替换。
- en: The solution to this is to use **patching**. Patching is a way to replace a
    class or function in the global namespace with a mock version. Because Python
    allows dynamic access to the globals as well as all imported modules, we can just
    go in and change which object an identifier points to.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是使用**修补**。修补是一种用模拟版本替换全局命名空间中的类或函数的方法。因为Python允许动态访问全局以及所有导入的模块，我们可以直接进入并更改标识符指向的对象。
- en: 'In the following sequence, you can see how we replace the `print` function
    with another one that takes one parameter and returns the double:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的序列中，你可以看到我们如何用另一个接受一个参数并返回双倍的函数替换`print`函数：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we can see above, all calls to `print` now call our own function instead
    of the default printing implementation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，现在所有的`print`调用都调用我们自己的函数，而不是默认的打印实现。
- en: This gives us the hint we need to proceed with our mocking. What if we just
    replace the `print` with a mock before running the test? This way the code will
    end up executing our mock instead of the default print implementation, and we
    can then assert on the mock that it was called with the right parameters.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们提供了进行模拟所需的提示。如果我们只是在运行测试之前将`print`替换为模拟，会怎样？这样代码最终会执行我们的模拟而不是默认的打印实现，然后我们可以在模拟上断言它是否以正确的参数被调用。
- en: 'The following is an example of this technique:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个技术的示例：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: What's going on here?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？
- en: First, we create the mock function.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建模拟函数。
- en: Next, we save the default print implementation. We need to do this so that we
    can restore it properly at the end of the test.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们保存默认的打印实现。我们需要这样做，以便在测试结束时能够正确地恢复它。
- en: Finally, we replace the default print with our mock function. Now, every time
    the print function is called, it will call our mock.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们用我们的模拟函数替换默认的打印。现在，每次调用打印函数时，它都会调用我们的模拟。
- en: We run the test, wrapped around a `try` - `finally` block.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在一个`try` - `finally`块中运行测试。
- en: In the `finally` block, we restore back the default print implementation.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`finally`块中，我们恢复默认的打印实现。
- en: It is very, very important to restore the default implementation back. Remember,
    we are changing the global information here, so if we don't restore it back, print
    will point to our mock function in all the subsequent tests as well. This can
    lead to some very strange behavior, for example, somewhere else we might expect
    some output on the screen and nothing is printed, and we end up spending hours
    trying to figure out why. This is the reason why the test is wrapped in the `try`
    - `finally` block. This way, the mock gets reset back to the default even if there
    is an exception thrown in the test.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 非常、非常重要的是要恢复默认实现。记住，我们在这里更改的是全局信息，如果我们不恢复它，打印将指向我们的模拟函数，在所有后续的测试中也是如此。这可能会导致一些非常奇怪的行为，例如，在其他地方我们可能期望在屏幕上有输出，但没有打印出来，我们最终花费数小时试图弄清楚原因。这就是为什么测试被包裹在`try`
    - `finally`块中的原因。这样，即使在测试中抛出异常，模拟也会被重置回默认值。
- en: We just saw how to patch in functions and classes with a mock, and since this
    is a fairly common task, Python gives us a really nice way to perform patching
    through the `mock.patch` function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何使用模拟修补函数和类，由于这是一个相当常见的任务，Python通过`mock.patch`函数给了我们一个非常好的进行修补的方法。
- en: The `mock.patch` function takes away a lot of the work needed to patch functions.
    Let us look at a couple of ways to use it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`mock.patch`函数去除了修补函数所需的大量工作。让我们看看使用它的几种方法。'
- en: 'The first way replicates the way we did our manual patching. We create a patcher
    and then use the `start` method to execute the patch, and the `stop` method to
    reset back the original implementation, as shown in the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法复制了我们手动修补的方式。我们创建一个修补器，然后使用`start`方法来执行修补，使用`stop`方法来重置回原始实现，如下所示：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Like our manual patching, we have to be careful that the stop method gets called
    even if an exception is raised.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的手动修补一样，我们必须小心，即使在抛出异常的情况下也要调用停止方法。
- en: 'The patch can also be used as a context manager in conjunction with the `with`
    keyword. This syntax is a lot cleaner and generally preferable to calling start
    and stop ourselves:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 修补也可以与`with`关键字一起用作上下文管理器。这种语法要干净得多，通常比我们自己调用开始和停止更可取：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let us walk through what is going on here:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这里发生了什么：
- en: The code where we want the patch to be active is wrapped inside the `with` block.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望修补激活的代码被包裹在`with`块中。
- en: We call the `patch` function, which returns the patcher to be used as a context
    manager. The mock object is set in the variable specified in the `as` section.
    In this case, the patched mock is set to `mock_print`.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用`patch`函数，它返回要作为上下文管理器使用的修补器。模拟对象被设置在`as`部分指定的变量中。在这种情况下，修补后的模拟对象被设置为`mock_print`。
- en: Inside the block, we perform the test and assert as usual.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个块中，我们像往常一样执行测试和断言。
- en: The patch is removed once execution comes out of the context block. This could
    be because all the statements were executed or due to an exception.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修补一旦执行离开上下文块就会被移除。这可能是因为所有语句都已执行，或者由于异常。
- en: With this syntax, we don't need to worry about unhandled exceptions causing
    a problem with the patch.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种语法，我们不需要担心未处理的异常会导致修补出现问题。
- en: 'The `patch` function can also be used as a method decorator, as the following
    example shows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`patch`函数也可以用作方法装饰器，如下面的示例所示：'
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With this syntax, the patcher patches the required function and passes in the
    replacement mock object as the first parameter to the test method. We can then
    use the mock object as normal. The patch is reset once the test completes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此语法，修补器修补所需的函数，并将替换模拟对象作为测试方法的第一个参数传入。然后我们可以像正常使用一样使用模拟对象。测试完成后，修补将被重置。
- en: 'If we need to patch the same object for a number of tests, then we can use
    the class decorator syntax instead, as shown in the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要为多个测试修补相同的对象，则可以使用类装饰器语法，如下所示：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This syntax decorates all the tests in the class with the patch. By default,
    the decorator searches for methods that start with `test`. However, this can be
    changed by setting the `patch.TEST_PREFIX` attribute, and the class decorator
    will patch all methods that start with that prefix.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此语法用修补装饰了类中的所有测试。默认情况下，装饰器会搜索以`test`开头的方法。但是，可以通过设置`patch.TEST_PREFIX`属性来更改此行为，类装饰器将修补所有以该前缀开头的方法。
- en: An important gotcha when patching
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修补时的一个重要注意事项
- en: When patching, we should remember to patch exactly the object that the class
    is using. Python allows multiple references to an object, and it is easy to end
    up patching the wrong object. We would then spend hours wondering why the mock
    object isn't being executed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在修补时，我们应该记住修补类所使用的确切对象。Python 允许多个对象引用，很容易修补错误的对象。然后我们可能会花费数小时 wondering 为什么模拟对象没有被执行。
- en: 'For example, support file `alert.py` uses an import like the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，支持文件`alert.py`使用如下导入：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now in the alert test, if we want to patch out `PriceRule`, then the following
    is the way we need to do it:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在警报测试中，如果我们想要修补`PriceRule`，那么我们需要这样做：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Only if we do it this way will we patch the `PriceRule` object that is used
    in `alert.py` file. The following way will not work:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 只有这样做，我们才能修补在`alert.py`文件中使用的`PriceRule`对象。以下方式将不起作用：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This code will patch out `rule.PriceRule`, which is different from the actual
    object that we want to patch out. When we run this test, we'll see that the alert
    executes the real `PriceRule` object and not the one that we patched out.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将修补`rule.PriceRule`，这与我们想要修补的实际对象不同。当我们运行此测试时，我们会看到警报执行的是真实的`PriceRule`对象，而不是我们修补出的那个。
- en: Since this is such a common mistake, we should check this first if ever we have
    problems with the test not executing the patched object correctly.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个常见的错误，所以当我们遇到测试无法正确执行修补对象的问题时，我们应该首先检查这一点。
- en: Tying it all together
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容串联起来
- en: Let us tie this chapter together with a more complex example. The following
    is the code for the `EmailAction` class. This action sends an e-mail to the user
    when the rule is matched.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个更复杂的例子来总结这一章。以下是`EmailAction`类的代码。此操作在规则匹配时向用户发送电子邮件。
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following is how the library works:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用该库：
- en: We instantiate the `SMTP` class in the `smtplib` library, passing it the server
    we want to connect to. This returns the `SMTP` object.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`smtplib`库中实例化`SMTP`类，并传入我们想要连接的服务器。这将返回`SMTP`对象。
- en: We call the `send_message` method on the `SMTP` object, passing in the e-mail
    message details in the form of a `MIMEText` object.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`SMTP`对象上调用`send_message`方法，传入电子邮件消息详情，以`MIMEText`对象的形式。
- en: Finally, we call the `quit` method. This method always needs to be called, even
    if there was an exception in sending the message.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调用`quit`方法。此方法始终需要调用，即使在发送消息时发生异常。
- en: 'Given this, we need to test the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，我们需要测试以下内容：
- en: The right calls are made to the `smtplib` library, with the right parameters.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`smtplib`库时，使用正确的参数。
- en: The message contents (from, to, subject, body) are correct.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息内容（发件人、收件人、主题、正文）是正确的。
- en: The `quit` method is called even if an exception was thrown when sending the
    message.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使在发送消息时抛出异常，也会调用`quit`方法。
- en: 'Let us start with a simple test. This test is for verifying that the `SMTP`
    class is initialized with the right parameters:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的测试开始。此测试是为了验证`SMTP`类是否使用正确的参数初始化：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: First, we start out by patching out the `SMTP` class in the `smtplib` module.
    Since we'll be doing this for every test, we set this up as a class decorator.
    We then instantiate the `EmailAction` that we want to test in the `setUp`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在每个测试中修补`smtplib`模块中的`SMTP`类。由于我们将为此做每个测试，我们将此设置为一个类装饰器。然后在`setUp`中实例化我们想要测试的`EmailAction`。
- en: The test itself is fairly simple. We call the `execute` method of the action
    and assert that the mock class was instantiated with the right parameter.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 测试本身相当简单。我们调用动作的`execute`方法，并断言模拟类是用正确的参数实例化的。
- en: 'The following test verifies that the right calls are made to `SMTP` object:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试验证了对`SMTP`对象是否执行了正确的调用：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There are a few new approaches in this test that are worth discussing.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，有几个新的方法值得讨论。
- en: First is the subtle difference in this series of tests where we are mocking
    the `SMTP` class and not an *object*. In the first test, we were checking the
    parameters passed to the constructor. Since we mocked the class, we could assert
    directly on our mock object.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是这个测试系列中的一个微妙差异，其中我们模拟的是`SMTP`类而不是一个*对象*。在第一个测试中，我们检查了传递给构造函数的参数。由于我们模拟了类，我们可以在我们的模拟对象上直接断言。
- en: In this test, we need to check that the right calls are made on the `SMTP` *object*.
    Since an object is the return value from initializing the class, we can access
    the mock `smtp` object from the return value of the mock `smtp` class. This is
    exactly what we are doing in the first line of the test.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们需要检查是否在`SMTP` *对象*上执行了正确的调用。由于对象是初始化类的返回值，我们可以从模拟`smtp`类的返回值中访问模拟的`smtp`对象。这正是测试的第一行所做的事情。
- en: Next, we execute the action as usual.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们像往常一样执行动作。
- en: 'Finally, we are using the `assert_has_calls` method to assert that the right
    calls were made. We could have asserted the calls like the following instead:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`assert_has_calls`方法断言执行了正确的调用。我们可以像以下这样断言调用：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The main difference is that the above assertions do not assert the sequence.
    Suppose the action calls the `quit` method first and then calls `send_message`,
    it would still pass these two assertions. However, the `assert_has_calls` assertion
    not only checks that the methods were called, but also checks that the `quit`
    method is called after `send_message`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于上述断言没有断言序列。假设动作首先调用`quit`方法，然后调用`send_message`，它仍然会通过这两个断言。然而，`assert_has_calls`断言不仅检查方法是否被调用，还检查`quit`方法是在`send_message`之后被调用的。
- en: 'The following third test checks that the connection is closed even if an exception
    is raised when sending the message:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下第三个测试检查即使在发送消息时抛出异常，连接也会关闭：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this test, we use the `side_effect` attribute to set the send message mock
    to raise an exception. We then check that the `quit` method was called even when
    the exception was raised.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们使用`side_effect`属性将发送消息的模拟设置为抛出异常。然后我们检查即使在抛出异常的情况下，`quit`方法也被调用了。
- en: In the last test, we need to check that the right message contents are passed
    to `send_message`. The function takes a `MIMEText` object as a parameter. How
    do we check that the right object was passed?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个测试中，我们需要检查正确的消息内容是否传递给了`send_message`。该函数接受一个`MIMEText`对象作为参数。我们如何检查传递了正确的对象？
- en: 'The following is one way that *does not* work:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一种*不工作*的方法：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If we run the above test, we''ll get a failure like the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述测试，我们会得到如下失败：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The problem is that although the contents of the expected `MIMEText` object
    and the actual one passed to `send_message` are the same, the test still fails
    because they are both different objects. The mocking framework compares the two
    parameters by equality, and since both are two different objects, the test for
    equality fails.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，尽管预期的`MIMEText`对象和传递给`send_message`的实际对象的内容相同，但测试仍然失败，因为它们是两个不同的对象。模拟框架通过相等性比较这两个参数，由于它们都是两个不同的对象，所以相等性测试失败。
- en: 'One approach around this problem is to go into the mock, extract the arguments
    that were passed in the call, and check that they contained the right data. The
    following is a test that uses this approach:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一是进入模拟，提取调用中传递的参数，并检查它们是否包含正确的数据。以下是一个使用此方法的测试：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Once the `execute` method is called, we then access the `call_args` attribute
    of the `mock` object to get the arguments that were passed to `send_message`.
    We take the first parameter, which is the `MIMEText` object that we are interested
    in. We then assert that the subject was as expected.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用`execute`方法，我们就访问`mock`对象的`call_args`属性，以获取传递给`send_message`的参数。我们取第一个参数，即我们感兴趣的`MIMEText`对象。然后我们断言主题符合预期。
- en: 'A more elegant way is possible. Remember we said that the mocking framework
    compares parameters by equality? This means that we can pass in an object that
    implements the `__eq__` special method and use that to perform any comparison
    that we want. The following is one such class for checking equality between two
    `MIMEText` messages:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种更优雅的方法。记住我们说过模拟框架是通过相等性来比较参数的吗？这意味着我们可以传递一个实现了`__eq__`特殊方法的对象，并使用它来执行我们想要的任何比较。以下是一个用于检查两个`MIMEText`消息之间相等性的此类类：
- en: '[PRE40]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This class basically takes a dictionary of values, and then can be used to
    compare whether a `MIMEText` object contains those values (at least the values
    we are interested in). Since it implements the `__eq__` method, a direct equality
    can be used to check, as shown in the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类基本上接受一个值字典，然后可以用来比较`MIMEText`对象是否包含这些值（至少是我们感兴趣的值）。由于它实现了`__eq__`方法，可以直接使用相等性进行检查，如下所示：
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can use this technique to pass in such an object as the expected parameter
    of a test like the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这种技术将这样的对象作为测试的预期参数传递，如下所示：
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Writing custom parameter matchers like this is an easy way to assert on parameters
    for which we might not have direct object access, or when we want to compare only
    a few attributes of the object for the purposes of the test.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 编写像这样的自定义参数匹配器是一种简单的方法，可以断言我们可能没有直接对象访问的参数，或者当我们只想为了测试目的比较对象的一些属性时。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you looked at how to use mocks to test interactions between
    objects. You saw how to hand write our own mocks, followed by using the mocking
    framework provided in the Python standard library. Next, you saw how to use patching
    for more advanced mocking. We wrapped it up by looking at a slightly more complex
    mocking example that had us put all the mocking techniques into practice.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用模拟来测试对象之间的交互。你看到了如何手动编写我们的模拟，然后是使用Python标准库中提供的模拟框架。接下来，你看到了如何使用补丁进行更高级的模拟。我们通过查看一个稍微复杂一些的模拟示例来结束，这个示例让我们将所有模拟技术付诸实践。
- en: So far you have been looking at writing tests for new code. In the next chapter,
    you will take a look at how to deal with existing code that does not have tests.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直在查看编写新代码的测试。在下一章中，你将了解如何处理没有测试的现有代码。
