<html><head></head><body>
<div id="_idContainer079">
<h1 class="chapter-number" id="_idParaDest-266"><a id="_idTextAnchor502"/><a id="_idTextAnchor503"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-267"><a id="_idTextAnchor504"/><span class="koboSpan" id="kobo.2.1">Debugging, Error Handling, and Testing</span></h1>
<p><span class="koboSpan" id="kobo.3.1">So far in this book, we have concentrated on developing applications and adding features to them one at a time. </span><span class="koboSpan" id="kobo.3.2">It is very important to know how robust our application is and to keep track of how it has been working and performing. </span><span class="koboSpan" id="kobo.3.3">This, in turn, gives rise to the need to be informed when something goes wrong in the application. </span><span class="koboSpan" id="kobo.3.4">It is normal to miss out on certain edge cases while developing the application, and usually, even the test cases miss them out. </span><span class="koboSpan" id="kobo.3.5">It would be great to know about these edge cases whenever they occur so that they can be </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">handled accordingly.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Effective logging and the ability to debug quickly are a couple of the deciding factors when choosing a framework for application development. </span><span class="koboSpan" id="kobo.5.2">The better the logging and debugging support from the framework, the quicker the process of application development and maintenance is. </span><span class="koboSpan" id="kobo.5.3">A better level of logging and debugging support helps developers quickly find out the issues in the application, and on many occasions, logging points out issues even before they are identified by end users. </span><span class="koboSpan" id="kobo.5.4">Effective error handling plays an important role in end user satisfaction and eases the pain of debugging at the developer’s end. </span><span class="koboSpan" id="kobo.5.5">Even if its code is perfect, the application is bound to throw errors at times. </span><span class="koboSpan" id="kobo.5.6">Why? </span><span class="koboSpan" id="kobo.5.7">The answer is simple – the code might be perfect, but the world in which it works is not. </span><span class="koboSpan" id="kobo.5.8">There can be innumerable issues that can occur, and as developers, we always want to know the reason behind any anomaly. </span><span class="koboSpan" id="kobo.5.9">Writing test cases along with the application is one of the most important pillars of </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">software writing.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Python’s built-in logging system works pretty well with Flask. </span><span class="koboSpan" id="kobo.7.2">We will work with this logging system in this chapter before moving on to an awesome service called </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">Sentry</span></strong><span class="koboSpan" id="kobo.9.1">, which eases the pain of debugging and error logging to a </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">huge extent.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">As we have already talked about the importance of testing for application development, we will now see how to write test cases for a Flask application. </span><span class="koboSpan" id="kobo.11.2">We will also see how we can measure code coverage and profile our application to tackle </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">any bottlenecks.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">Testing in itself is a huge topic and has several books attributed to it. </span><span class="koboSpan" id="kobo.13.2">Here, we will try to understand the basics of testing </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">with Flask.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">following recipes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.17.1">Setting up basic </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">file logging</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Sending emails on the occurrence </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">of errors</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Using Sentry to </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">monitor exceptions</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Debugging </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.25.1">pdb</span></strong></span></li>
<li><span class="koboSpan" id="kobo.26.1">Creating </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">application factories</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">Creating the first </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">simple test</span></span></li>
<li><span class="koboSpan" id="kobo.30.1">Writing more tests for views </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">and logic</span></span></li>
<li><span class="koboSpan" id="kobo.32.1">Integrating the </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">nose2 library</span></span></li>
<li><span class="koboSpan" id="kobo.34.1">Using mocking to avoid external </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">API access</span></span></li>
<li><span class="koboSpan" id="kobo.36.1">Determining </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">test coverage</span></span></li>
<li><span class="koboSpan" id="kobo.38.1">Using profiling to </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">find bottlenecks</span></span></li>
</ul>
<h1 id="_idParaDest-268"><a id="_idTextAnchor505"/><span class="koboSpan" id="kobo.40.1">Setting up basic file logging</span></h1>
<p><a id="_idTextAnchor506"/><span class="koboSpan" id="kobo.41.1">By default, Flask </span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.42.1">will not log anything for us anywhere, except for the errors with the stack traces, which are sent to the logger (we will see more of this in the rest of the chapter). </span><span class="koboSpan" id="kobo.42.2">It does create a lot of stack traces while we run the application in the development mode using </span><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">run.py</span></strong><span class="koboSpan" id="kobo.44.1">, but in production systems, we don’t have this luxury. </span><span class="koboSpan" id="kobo.44.2">Thankfully, the logging library provides a whole lot of log handlers, which can be used as per requirements. </span><span class="koboSpan" id="kobo.44.3">In this recipe, we will understand how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">logging</span></strong><span class="koboSpan" id="kobo.46.1"> library can be leveraged to ensure that effective logs are being captured from </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">Flask applications.</span></span><a id="_idTextAnchor507"/></p>
<h2 id="_idParaDest-269"><a id="_idTextAnchor508"/><span class="koboSpan" id="kobo.48.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.49.1">We will start with our catalog application from the previous chapter and add some basic logging to it using </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">FileHandler</span></strong><span class="koboSpan" id="kobo.51.1">, which logs messages to a specified file on the filesystem. </span><span class="koboSpan" id="kobo.51.2">We will start with a basic log format and then see how to format the log messages to be </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">more informative.</span></span><a id="_idTextAnchor509"/></p>
<h2 id="_idParaDest-270"><a id="_idTextAnchor510"/><span class="koboSpan" id="kobo.53.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.54.1">Follow these steps to configure and set up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">logging</span></strong><span class="koboSpan" id="kobo.56.1"> library to use with </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">our application:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.58.1">The first change is made to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">my_app/__init__.py</span></strong><span class="koboSpan" id="kobo.60.1"> file, which serves as the </span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.61.1">application’s </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">configuration file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.63.1">
app.config['LOG_FILE'] = 'application.log'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.64.1">
if not app.debug:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.65.1">
    import logging</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.66.1">
    from logging import FileHandler, Formatter</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.67.1">
    file_handler = FileHandler(app.config['LOG_FILE'])</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.68.1">
    app.logger.setLevel(logging.INFO)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.69.1">
    app.logger.addHandler(file_handler)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.70.1">Here, we added a configuration parameter to specify the log file’s location. </span><span class="koboSpan" id="kobo.70.2">This takes the relative path from the application folder unless an absolute path is explicitly specified. </span><span class="koboSpan" id="kobo.70.3">Next, we will check whether the application is already in debug mode, and then we will add a handler logging to a file with the logging level as </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">INFO</span></strong><span class="koboSpan" id="kobo.72.1">. </span><span class="koboSpan" id="kobo.72.2">Now, </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">DEBUG</span></strong><span class="koboSpan" id="kobo.74.1"> is the lowest logging level and will log everything at any level. </span><span class="koboSpan" id="kobo.74.2">For more details, refer to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">logging</span></strong><span class="koboSpan" id="kobo.76.1"> library documentation (in the </span><em class="italic"><span class="koboSpan" id="kobo.77.1">See also</span></em><span class="koboSpan" id="kobo.78.1"> section).</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.79.1">After this, add loggers to the application wherever they are needed, and the application will start logging to the deputed file. </span><span class="koboSpan" id="kobo.79.2">Now, let’s add a couple of loggers to </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">my_app/catalog/views.py</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.81.1">for demonstration:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.82.1">
@catalog.route('/')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.83.1">
@catalog.route('/&lt;lang&gt;/')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.84.1">
@catalog.route('/&lt;lang&gt;/home')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.85.1">
@template_or_json('home.html')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.86.1">
def home():</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.87.1">
    products = Product.query.all()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.88.1">
    app.logger.info(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.89.1">
        'Home page with total of %d products'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.90.1">
          % len(products)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.91.1">
    )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.92.1">
    return {'count': len(products)}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.93.1">
@catalog.route('/&lt;lang&gt;/product/&lt;id&gt;')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.94.1">
def product(id):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.95.1">
    product = Product.query.filter_by(id=id).first()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.96.1">
    if not product:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.97.1">
        app.logger.warning('Requested product not</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.98.1">
          found.')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.99.1">
        abort(404)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.100.1">
    return render_template('product.html',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.101.1">
      product=product)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.102.1">In the </span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.103.1">preceding code, we have added loggers for a couple of our view handlers. </span><span class="koboSpan" id="kobo.103.2">Note that the first of the loggers in </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">home()</span></strong><span class="koboSpan" id="kobo.105.1"> is at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">info</span></strong><span class="koboSpan" id="kobo.107.1"> level, and the other in </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">product()</span></strong><span class="koboSpan" id="kobo.109.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">warning</span></strong><span class="koboSpan" id="kobo.111.1">. </span><span class="koboSpan" id="kobo.111.2">If we set our log level in </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">__init__.py</span></strong><span class="koboSpan" id="kobo.113.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">INFO</span></strong><span class="koboSpan" id="kobo.115.1">, then both will be logged, and if we set the level as </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">WARNING</span></strong><span class="koboSpan" id="kobo.117.1">, then only the warning logger will be logged.</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.118.1">Information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.119.1">Make sure to import </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">abort</span></strong><span class="koboSpan" id="kobo.121.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">Flask</span></strong><span class="koboSpan" id="kobo.123.1"> if this has not already been done – </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">from flask </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">import abor</span><a id="_idTextAnchor511"/><span class="koboSpan" id="kobo.126.1">t</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">.</span></span></p>
<h2 id="_idParaDest-271"><a id="_idTextAnchor512"/><span class="koboSpan" id="kobo.128.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.129.1">The preceding steps will create a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">application.log</span></strong><span class="koboSpan" id="kobo.131.1"> in the root application folder. </span><span class="koboSpan" id="kobo.131.2">The logger statements as specified will be logged to </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">application.log</span></strong><span class="koboSpan" id="kobo.133.1"> and will look something like the following snippet, depending on the handler called; the first one is from the</span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.134.1"> home page, and the second is from requesting a product that does </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">not exist:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.136.1">
Home page with total of 0 products
Requested product not found.</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.137.1">Important</span></p>
<p class="callout"><span class="koboSpan" id="kobo.138.1">To enable logging, either run your application with a WSGI server (refer to </span><a href="B19111_11.xhtml#_idTextAnchor610"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.139.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.140.1">) or run using </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">flask run</span></strong><span class="koboSpan" id="kobo.142.1"> on your terminal prompt (refer to </span><a href="B19111_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.143.1">Chapter 1</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.144.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">Running the application using </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">run.py</span></strong><span class="koboSpan" id="kobo.147.1"> will always make it run with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">debug</span></strong><span class="koboSpan" id="kobo.149.1"> flag as </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">True</span></strong><span class="koboSpan" id="kobo.151.1">, which will not allow logging to work </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">as expected.</span></span></p>
<p><span class="koboSpan" id="kobo.153.1">The information logged does not help much. </span><span class="koboSpan" id="kobo.153.2">It would be great to know when the issue was logged, with what level, which file caused the issue at what line number, and so on. </span><span class="koboSpan" id="kobo.153.3">This can be achieved using advanced logging formats. </span><span class="koboSpan" id="kobo.153.4">For this, we need to add a couple of statements to the configuration file – that </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">is, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">my_app/__init__.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.157.1">
if not app.debug:
    import logging
    from logging import FileHandler, Formatter
    file_handler = FileHandler(app.config['LOG_FILE'])
    app.logger.setLevel(logging.INFO)
    app.logger.addHandler(file_handler)
    file_handler.setFormatter(Formatter(
        '%(asctime)s %(levelname)s: %(message)s '
        '[in %(pathname)s:%(lineno)d]'
    ))</span></pre>
<p><span class="koboSpan" id="kobo.158.1">In the preceding code, we added a formatter to </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">file_handler</span></strong><span class="koboSpan" id="kobo.160.1">, which will log the time, log level, message, file</span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.161.1"> path, and line number. </span><span class="koboSpan" id="kobo.161.2">After this, the logged message will look </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.163.1">
2023-01-02 13:01:25,125 INFO: Home page with total of 0 products [in /Users/apple/workspace/flask-cookbook-3/Chapter-10/Chapter-10/my_app/catalog/views.py:72]
2023-01-02 13:01:27,657 WARNING: Requested product not found. </span><span class="koboSpan" id="kobo.163.2">[in /Users/apple/workspace/flask-cookbook-3/Chapter-10/Chapter-10/my_app/catalog/views.py</span><a id="_idTextAnchor513"/><span class="koboSpan" id="kobo.164.1">:82]</span></pre>
<h2 id="_idParaDest-272"><a id="_idTextAnchor514"/><span class="koboSpan" id="kobo.165.1">There’s more…</span></h2>
<p><span class="koboSpan" id="kobo.166.1">We might also want to log all the errors when a page is not found (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">404</span></strong><span class="koboSpan" id="kobo.168.1"> error). </span><span class="koboSpan" id="kobo.168.2">For this, we can just tweak the </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">errorhandler</span></strong><span class="koboSpan" id="kobo.170.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">a bit:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.172.1">
@app.errorhandler(404)
def page_not_found(e):
    app.logger.error(e)
    return render_template('404.html'),</span><a id="_idTextAnchor515"/><span class="koboSpan" id="kobo.173.1"> 404</span></pre>
<h2 id="_idParaDest-273"><a id="_idTextAnchor516"/><span class="koboSpan" id="kobo.174.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.175.1">Go to Python’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">logging</span></strong><span class="koboSpan" id="kobo.177.1"> library documentation about handlers at </span><a href="https://docs.python.org/dev/library/logging.handlers.html"><span class="koboSpan" id="kobo.178.1">https://docs.python.org/dev/library/logging.handlers.html</span></a><span class="koboSpan" id="kobo.179.1"> to learn more about </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">logging handl</span><a id="_idTextAnchor517"/><span class="koboSpan" id="kobo.181.1">ers.</span></span></p>
<h1 id="_idParaDest-274"><a id="_idTextAnchor518"/><span class="koboSpan" id="kobo.182.1">Sending emails on the occurrence of errors</span></h1>
<p><span class="koboSpan" id="kobo.183.1">It is a good idea </span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.184.1">to receive notifications when something unexpected happens with the application. </span><span class="koboSpan" id="kobo.184.2">Setting this up is pretty easy and adds a lot of convenience to the process of </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">error hand</span><a id="_idTextAnchor519"/><span class="koboSpan" id="kobo.186.1">ling.</span></span></p>
<h2 id="_idParaDest-275"><a id="_idTextAnchor520"/><span class="koboSpan" id="kobo.187.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.188.1">We will take the application from the last recipe and add </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">mail_handler</span></strong><span class="koboSpan" id="kobo.190.1"> to it to make our application send emails when an error occurs. </span><span class="koboSpan" id="kobo.190.2">Also, we will demonstrate the email setup using Gmail as the </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">SMTP se</span><a id="_idTextAnchor521"/><span class="koboSpan" id="kobo.192.1">rver.</span></span></p>
<h2 id="_idParaDest-276"><a id="_idTextAnchor522"/><span class="koboSpan" id="kobo.193.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.194.1">First, add the handler to the configuration in </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">my_app/__init__.py</span></strong><span class="koboSpan" id="kobo.196.1">. </span><span class="koboSpan" id="kobo.196.2">This is similar to how we added </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">file_handler</span></strong><span class="koboSpan" id="kobo.198.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">previous recipe:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.200.1">
RECEPIENTS = ['some_receiver@gmail.com']
if not app.debug:
    import logging
    from logging import FileHandler, Formatter
    from logging.handlers import SMTPHandler
    file_handler = FileHandler(app.config['LOG_FILE'])
    app.logger.setLevel(logging.INFO)
    app.logger.addHandler(file_handler)
    mail_handler = SMTPHandler(
        ("smtp.gmail.com", 587), 'sender@gmail.com',
          RECEPIENTS,
        'Error occurred in your application',
        ('some_email@gmail.com', 'some_gmail_password'),
          secure=())
    mail_handler.setLevel(logging.ERROR)
    app.logger.addHandler(mail_handler)
    for handler in [file_handler, mail_handler]:
        handler.setFormatter(Formatter(
            '%(asctime)s %(levelname)s: %(message)s '
            '[in %(pathname)s:%(lineno)d]'
        ))</span></pre>
<p><span class="koboSpan" id="kobo.201.1">Here, we have a list of email addresses to which the error notification email will be sent. </span><span class="koboSpan" id="kobo.201.2">Also, note that we have set the log level to </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">ERROR</span></strong><span class="koboSpan" id="kobo.203.1"> in the case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">mail_handler</span></strong><span class="koboSpan" id="kobo.205.1">. </span><span class="koboSpan" id="kobo.205.2">This is because emails will be necessary only in the case of </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">crucial matters.</span></span></p>
<p><span class="koboSpan" id="kobo.207.1">For more details on the configuration of </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">SMTPHandler</span></strong><span class="koboSpan" id="kobo.209.1">, refer to </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">the documentation.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.211.1">Important</span></p>
<p class="callout"><span class="koboSpan" id="kobo.212.1">Always make sure that you run your application with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">debug</span></strong><span class="koboSpan" id="kobo.214.1"> flag set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">off</span></strong><span class="koboSpan" id="kobo.216.1"> to enable the application to log and send emails for internal application errors (the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">500</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.218.1"> er</span><a id="_idTextAnchor523"/><span class="koboSpan" id="kobo.219.1">ror).</span></span></p>
<h2 id="_idParaDest-277"><a id="_idTextAnchor524"/><span class="koboSpan" id="kobo.220.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.221.1">To cause an internal </span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.222.1">application error, just misspell some keyword in any of your handlers. </span><span class="koboSpan" id="kobo.222.2">You will receive an email in your mailbox, with the formatting as set in the configuration and a complete stack trace for </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">your refe</span><a id="_idTextAnchor525"/><span class="koboSpan" id="kobo.224.1">rence.</span></span></p>
<h1 id="_idParaDest-278"><a id="_idTextAnchor526"/><span class="koboSpan" id="kobo.225.1">Using Sentry to monitor exceptions</span></h1>
<p><span class="koboSpan" id="kobo.226.1">Sentry is a tool </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.227.1">that eases the process of monitoring</span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.228.1"> exceptions and also provides insights into the errors that users of the application face while using it. </span><span class="koboSpan" id="kobo.228.2">It is highly possible that there are errors in log files that get overlooked by the human eye. </span><span class="koboSpan" id="kobo.228.3">Sentry categorizes the errors under different categories and keeps a count of the recurrence of errors. </span><span class="koboSpan" id="kobo.228.4">This helps us to understand the severity of the errors on multiple criteria and how to handle them accordingly. </span><span class="koboSpan" id="kobo.228.5">It has a nice GUI that facilitates all of these features. </span><span class="koboSpan" id="kobo.228.6">In this recipe, we will set up Sentry and use it as an effective </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">error-monitori</span><a id="_idTextAnchor527"/><span class="koboSpan" id="kobo.230.1">ng tool.</span></span></p>
<h2 id="_idParaDest-279"><a id="_idTextAnchor528"/><span class="koboSpan" id="kobo.231.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.232.1">Sentry is available as a cloud service, which is available free for developers and basic users. </span><span class="koboSpan" id="kobo.232.2">For the purposes of this recipe, this freely available cloud service will be enough. </span><span class="koboSpan" id="kobo.232.3">Head over to </span><a href="https://sentry.io/signup/"><span class="koboSpan" id="kobo.233.1">https://sentry.io/signup/</span></a><span class="koboSpan" id="kobo.234.1"> and get started with the registration process. </span><span class="koboSpan" id="kobo.234.2">This being said, we need to install the Python SDK </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">for Sentry:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.236.1">
$ pip install 'sentry-sdk</span><a id="_idTextAnchor529"/><span class="koboSpan" id="kobo.237.1">[flask]'</span></pre>
<h2 id="_idParaDest-280"><a id="_idTextAnchor530"/><span class="koboSpan" id="kobo.238.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.239.1">Once the Sentry</span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.240.1"> registration is complete, a screen will be </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.241.1">shown that will ask about the type of project that needs to be integrated with Sentry. </span><span class="koboSpan" id="kobo.241.2">See the </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer072">
<span class="koboSpan" id="kobo.243.1"><img alt="Figure 10.1 – The Sentry project creation screen" src="image/B19111_10_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.244.1">Figure 10.1 – The Sentry project creation screen</span></p>
<p><span class="koboSpan" id="kobo.245.1">This will be followed by another screen that shows the steps on how to configure your Flask application to send events to the newly created and configured Sentry instance. </span><span class="koboSpan" id="kobo.245.2">This is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<span class="koboSpan" id="kobo.247.1"><img alt="Figure 10.2 – The Sentry project configuration steps" src="image/B19111_10_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.248.1">Figure 10.2 – The Sentry project configuration steps</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.249.1">Information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.250.1">Sentry can also be downloaded for free and installed as an on-premises application. </span><span class="koboSpan" id="kobo.250.2">There are multiple ways of installing and configuring Sentry as per your needs. </span><span class="koboSpan" id="kobo.250.3">You are free to try this approach on your own, as it goes beyond the scope of </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">this recipe.</span></span></p>
<p><span class="koboSpan" id="kobo.252.1">After the </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.253.1">previous </span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.254.1">setup is complete, add the following code to your Flask application in </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">my_app/__init__.py</span></strong><span class="koboSpan" id="kobo.256.1">, replacing </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">https://1234:5678@fake-sentry-server/1</span></strong><span class="koboSpan" id="kobo.258.1"> with the Sentry </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">project URI:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.260.1">
import sentry_sdk
from sentry_sdk.integrations.flask import FlaskIntegration
sentry_sdk.init(
    dsn="https://1234:5678@fake-sentry-server/1",
    integrations=[FlaskIntegr</span><a id="_idTextAnchor531"/><span class="koboSpan" id="kobo.261.1">ation()]
)</span></pre>
<h2 id="_idParaDest-281"><a id="_idTextAnchor532"/><span class="koboSpan" id="kobo.262.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.263.1">An error logged in Sentry will look like the </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer074">
<span class="koboSpan" id="kobo.265.1"><img alt="Figure 10.3 – The Sentry error log screen" src="image/B19111_10_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.266.1">Figure 10.3 – The Sentry error log screen</span></p>
<p><span class="koboSpan" id="kobo.267.1">It is also </span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.268.1">possible </span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.269.1">to log messages and user-defined exceptions in Sentry. </span><span class="koboSpan" id="kobo.269.2">I will leave this to you to figure out </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">b</span><a id="_idTextAnchor533"/><span class="koboSpan" id="kobo.271.1">y yourself.</span></span></p>
<h1 id="_idParaDest-282"><a id="_idTextAnchor534"/><span class="koboSpan" id="kobo.272.1">Debugging with pdb</span></h1>
<p><span class="koboSpan" id="kobo.273.1">Most of the Python</span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.274.1"> developers reading this book might already be aware of the usage of </span><strong class="bold"><span class="koboSpan" id="kobo.275.1">python debugger</span></strong><span class="koboSpan" id="kobo.276.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.277.1">pdb</span></strong><span class="koboSpan" id="kobo.278.1">). </span><span class="koboSpan" id="kobo.278.2">For those who are not aware of it, </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">pdb</span></strong><span class="koboSpan" id="kobo.280.1"> is an interactive source code debugger for Python programs. </span><span class="koboSpan" id="kobo.280.2">We can set breakpoints wherever needed, debug using single stepping at the source line level, and inspect the </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">stack frames.</span></span></p>
<p><span class="koboSpan" id="kobo.282.1">Many new developers might be of the opinion that the job of a debugger can be handled using a logger, but debuggers provide a much deeper insight into the flow of control, preserve the state at each step, and hence, potentially save a lot of development time. </span><span class="koboSpan" id="kobo.282.2">In this recipe, let’s have a look at what </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">pdb</span></strong><span class="koboSpan" id="kobo.284.1"> brings t</span><a id="_idTextAnchor535"/><span class="koboSpan" id="kobo.285.1">o </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">the table.</span></span></p>
<h2 id="_idParaDest-283"><a id="_idTextAnchor536"/><span class="koboSpan" id="kobo.287.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.288.1">We will use Python’s built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">pdb</span></strong><span class="koboSpan" id="kobo.290.1"> module for this recipe and use it in our application from the </span><a id="_idTextAnchor537"/><span class="No-Break"><span class="koboSpan" id="kobo.291.1">last recipe.</span></span></p>
<h2 id="_idParaDest-284"><a id="_idTextAnchor538"/><span class="koboSpan" id="kobo.292.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.293.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">pdb</span></strong><span class="koboSpan" id="kobo.295.1"> is pretty simple in most cases. </span><span class="koboSpan" id="kobo.295.2">We just need to insert the following statement wherever we want to insert a breakpoint to inspect a certain block </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.297.1">
import pdb; pdb.set_trace()</span></pre>
<p><span class="koboSpan" id="kobo.298.1">This will trigger the application to break execution at this point, and then we can step through the stack frames one by one using the </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">debugger commands.</span></span></p>
<p><span class="koboSpan" id="kobo.300.1">So, let’s insert this statement in one of our methods – say, the handler </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">for products:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.302.1">
@catalog.route('/&lt;lang&gt;/products')
@catalog.route('/&lt;lang&gt;/products/&lt;int:page&gt;')
def products(page=1):
    products = Product.query.paginate(page=page,
      per_page=10)
    import pdb; pdb.set_trace()
    return render_template('products.html',
      produc</span><a id="_idTextAnchor539"/><span class="koboSpan" id="kobo.303.1">ts=products)</span></pre>
<h2 id="_idParaDest-285"><a id="_idTextAnchor540"/><span class="koboSpan" id="kobo.304.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.305.1">Whenever the</span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.306.1"> control comes to this line, the debugger prompt will fire up; this will appear </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.308.1">
&gt; /Users/apple/workspace/flask-cookbook-3/Chapter-10/Chapter-10/my_app/catalog/views.py(93)products()
-&gt; return render_template('products.html', products=products)
(Pdb) u
&gt; /Users/apple/workspace/flask-cookbook-3/Chapter-10/lib/python3.10/site-packages/flask/app.py(1796)dispatch_request()
-&gt; return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)
(Pdb) u
&gt; /Users/apple/workspace/flask-cookbook-3/Chapter-10/lib/python3.10/site-packages/flask/app.py(1820)full_dispatch_request()
-&gt; rv = self.dispatch_request()
(Pdb) u
&gt; /Users/apple/workspace/flask-cookbook-3/Chapter-10/lib/python3.10/site-packages/flask/app.py(2525)wsgi_app()
-&gt; response = self.full_dispatch_request()
(Pdb) u
&gt; /Users/apple/workspace/flask-cookbook-3/Chapter-10/lib/python3.10/site-packages/flask/app.py(2548)__call__()
-&gt; return self.wsgi_app(environ, start_response)</span></pre>
<p><span class="koboSpan" id="kobo.309.1">Note </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">u</span></strong><span class="koboSpan" id="kobo.311.1"> written against </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">(Pdb)</span></strong><span class="koboSpan" id="kobo.313.1">. </span><span class="koboSpan" id="kobo.313.2">This signifies that I am moving the current frame one level up in the stack trace. </span><span class="koboSpan" id="kobo.313.3">All the variables, parameters, and properties used in that statement will be available in the same context to help figure out the issue, or just understand the flow of code. </span><span class="koboSpan" id="kobo.313.4">There are other debugger commands that could prove helpful in your navigation</span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.314.1"> of the debug logs. </span><span class="koboSpan" id="kobo.314.2">Check the following </span><em class="italic"><span class="koboSpan" id="kobo.315.1">See also</span></em><span class="koboSpan" id="kobo.316.1"> sect</span><a id="_idTextAnchor541"/><span class="koboSpan" id="kobo.317.1">ion </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">for these.</span></span></p>
<h2 id="_idParaDest-286"><a id="_idTextAnchor542"/><span class="koboSpan" id="kobo.319.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.320.1">Go to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">pdb</span></strong><span class="koboSpan" id="kobo.322.1"> module documentation at </span><a href="https://docs.python.org/3/library/pdb.html#debugger-commands"><span class="koboSpan" id="kobo.323.1">https://docs.python.org/3/library/pdb.html#debugger-commands</span></a><span class="koboSpan" id="kobo.324.1"> to get hold of the various </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">debu</span><a id="_idTextAnchor543"/><span class="koboSpan" id="kobo.326.1">gger commands.</span></span></p>
<h1 id="_idParaDest-287"><a id="_idTextAnchor544"/><span class="koboSpan" id="kobo.327.1">Creating application factories</span></h1>
<p><span class="koboSpan" id="kobo.328.1">Leveraging a</span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.329.1"> factory pattern is a great way of organizing your application object, allowing for multiple application objects with different settings. </span><span class="koboSpan" id="kobo.329.2">As discussed in </span><a href="B19111_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.330.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.331.1">, it is always possible to create multiple application instances by using different configurations, but application factories allow you to have multiple application objects inside the same application process. </span><span class="koboSpan" id="kobo.331.2">It also aids in testing, as you can choose to have a fresh or different application object with different settings for </span><a id="_idTextAnchor545"/><span class="koboSpan" id="kobo.332.1">each </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">test case.</span></span></p>
<h2 id="_idParaDest-288"><a id="_idTextAnchor546"/><span class="koboSpan" id="kobo.334.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.335.1">We will use our application from the previous recipe and modify it to use the application </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">f</span><a id="_idTextAnchor547"/><span class="koboSpan" id="kobo.337.1">actory pattern.</span></span></p>
<h2 id="_idParaDest-289"><a id="_idTextAnchor548"/><span class="koboSpan" id="kobo.338.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.339.1">The following are the changes that need to </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">be made:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.341.1">We will </span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.342.1">start by creating a function named </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">create_app()</span></strong><span class="koboSpan" id="kobo.344.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">our </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">my_app/__init__.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.348.1">
def create_app(alt_config={}):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.349.1">
    app = Flask(__name__, template_folder=alt_config</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.350.1">
      .get('TEMPLATE_FOLDER', 'templates'))</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.351.1">
    app.config['UPLOAD_FOLDER'] =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.352.1">
      os.path.realpath('.') + '/my_app/static/uploads'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.353.1">
    app.config['SQLALCHEMY_DATABASE_URI'] =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.354.1">
      'sqlite:////tmp/test.db'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.355.1">
    app.config['WTF_CSRF_SECRET_KEY'] = 'random key</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.356.1">
      for form'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.357.1">
    app.config['LOG_FILE'] = 'application.log'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.358.1">
    app.config.update(alt_config)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.359.1">
    if not app.debug:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.360.1">
        import logging</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.361.1">
        from logging import FileHandler, Formatter</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.362.1">
        from logging.handlers import SMTPHandler</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.363.1">
        file_handler =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.364.1">
          FileHandler(app.config['LOG_FILE'])</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.365.1">
        app.logger.setLevel(logging.INFO)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.366.1">
        app.logger.addHandler(file_handler)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.367.1">
        mail_handler = SMTPHandler(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.368.1">
            ("smtp.gmail.com", 587),</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.369.1">
              'sender@gmail.com', RECEPIENTS,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.370.1">
            'Error occurred in your application',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.371.1">
            ('some_email@gmail.com',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.372.1">
              'some_gmail_password'), secure=())</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.373.1">
        mail_handler.setLevel(logging.ERROR)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.374.1">
        # app.logger.addHandler(mail_handler)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.375.1">
        for handler in [file_handler, mail_handler]:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.376.1">
            handler.setFormatter(Formatter(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.377.1">
                '%(asctime)s %(levelname)s:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.378.1">
                  %(message)s '</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.379.1">
                '[in %(pathname)s:%(lineno)d]'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.380.1">
            ))</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.381.1">
    app.secret_key = 'some_random_key'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.382.1">
    return app</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.383.1">In this function, we </span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.384.1">have just rearranged all the application configurations inside a function named </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">create_app()</span></strong><span class="koboSpan" id="kobo.386.1">. </span><span class="koboSpan" id="kobo.386.2">This will allow us to create as many application objects as needed by simply calling this function.</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.387.1">Next, we create a method named </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">create_db()</span></strong><span class="koboSpan" id="kobo.389.1">, which initializes the database and then </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">creates tables:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.391.1">
db = SQLAlchemy()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.392.1">
def create_db(app):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.393.1">
    db.init_app(app)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.394.1">
    with app.app_context():</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.395.1">
        db.create_all()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.396.1">
    return db</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.397.1">Again in this function, we have just moved the database-specific code to a function. </span><span class="koboSpan" id="kobo.397.2">This </span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.398.1">method has been kept separate because you might want to use different database configs with different application instances.</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.399.1">The final step in </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">my_app/__init__.py</span></strong><span class="koboSpan" id="kobo.401.1"> would be to call/execute these methods and register </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">the blueprints:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.403.1">
def get_locale():</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.404.1">
    return g.get('current_lang', 'en')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.405.1">
app = create_app()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.406.1">
babel = Babel(app)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.407.1">
babel.init_app(app, locale_selector=get_locale)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.408.1">
from my_app.catalog.views import catalog</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.409.1">
app.register_blueprint(catalog)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.410.1">
db = create_db(app)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.411.1">We have created the objects for </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">app</span></strong><span class="koboSpan" id="kobo.413.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">db</span></strong><span class="koboSpan" id="kobo.415.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">babel</span></strong><span class="koboSpan" id="kobo.417.1"> by calling relevant methods and initializing the extensions.</span></p>
<p><span class="koboSpan" id="kobo.418.1">A downside of the application factory pattern is that you cannot use the application object in blueprints during import time. </span><span class="koboSpan" id="kobo.418.2">However, you can always utilize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">current_app</span></strong><span class="koboSpan" id="kobo.420.1"> proxy</span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.421.1"> to access the current application object. </span><span class="koboSpan" id="kobo.421.2">Let’s see how this is done </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">my_app/catalog/views.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.425.1">
from flask import current_app
@catalog.before_request
def before():
    # Existing code
@catalog.context_processor
def inject_url_for():
    # Existing code
# Similarly simply replace all your references to `app` by
  `current_app`. </span><span class="koboSpan" id="kobo.425.2">Refer to code provided with the book for a
</span><a id="_idTextAnchor549"/><span class="koboSpan" id="kobo.426.1">  complete example.</span></pre>
<h2 id="_idParaDest-290"><a id="_idTextAnchor550"/><span class="koboSpan" id="kobo.427.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.428.1">The application will continue to work in the same way as it did in the last recipe. </span><span class="koboSpan" id="kobo.428.2">It’s just that the code </span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.429.1">has been rearranged to implement the applicat</span><a id="_idTextAnchor551"/><span class="koboSpan" id="kobo.430.1">ion </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">factory pattern.</span></span></p>
<h2 id="_idParaDest-291"><a id="_idTextAnchor552"/><span class="koboSpan" id="kobo.432.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.433.1">The next couple of recipes will help you understand how the factory pattern is used while</span><a id="_idTextAnchor553"/><span class="koboSpan" id="kobo.434.1"> writing </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">test cases.</span></span></p>
<h1 id="_idParaDest-292"><a id="_idTextAnchor554"/><span class="koboSpan" id="kobo.436.1">Creating the first simple test</span></h1>
<p><span class="koboSpan" id="kobo.437.1">Testing is one </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.438.1">of the strongest pillars of any software during development and, later, during maintenance and expansion. </span><span class="koboSpan" id="kobo.438.2">Especially in the case of web applications, where the application will handle high traffic and be scrutinized by a large number of end users at all times, testing becomes pretty important, as the user feedback determines the fate of the application. </span><span class="koboSpan" id="kobo.438.3">In this recipe, we will see how to start with test writing and also see more complex tests in t</span><a id="_idTextAnchor555"/><span class="koboSpan" id="kobo.439.1">he recipes </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">to follow.</span></span></p>
<h2 id="_idParaDest-293"><a id="_idTextAnchor556"/><span class="koboSpan" id="kobo.441.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.442.1">We will start with the creation of a new test file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">app_tests.py</span></strong><span class="koboSpan" id="kobo.444.1"> at the root application level – that is, alongsi</span><a id="_idTextAnchor557"/><span class="koboSpan" id="kobo.445.1">de the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">my_app</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.447.1"> folder.</span></span></p>
<h2 id="_idParaDest-294"><a id="_idTextAnchor558"/><span class="koboSpan" id="kobo.448.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.449.1">Let’s write our first </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">test case:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.451.1">To start with, the content of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">app_tests.py</span></strong><span class="koboSpan" id="kobo.453.1"> test file will be </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.455.1">
import os</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.456.1">
from my_app import create_app, db, babel</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.457.1">
import unittest</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.458.1">
import tempfile</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.459.1">The preceding code describes the imports needed for this test suite. </span><span class="koboSpan" id="kobo.459.2">We will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">unittest</span></strong><span class="koboSpan" id="kobo.461.1"> to write our tests. </span><span class="koboSpan" id="kobo.461.2">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">tempfile</span></strong><span class="koboSpan" id="kobo.463.1"> instance is needed to create SQLite databases on the fly.</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.464.1">All the test</span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.465.1"> cases need to subclass </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">unittest.TestCase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.469.1">
class CatalogTestCase(unittest.TestCase):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.470.1">
    def setUp(self):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.471.1">
        test_config = {}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.472.1">
        self.test_db_file = tempfile.mkstemp()[1]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.473.1">
        test_config['SQLALCHEMY_DATABASE_URI'] =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.474.1">
          'sqlite:///' + self.test_db_file</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.475.1">
        test_config['TESTING'] = True</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.476.1">
        self.app = create_app(test_config)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.477.1">
        db.init_app(self.app)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.478.1">
        babel.init_app(self.app)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.479.1">
        with self.app.app_context():</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.480.1">
            db.create_all()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.481.1">
        from my_app.catalog.views import catalog</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.482.1">
        self.app.register_blueprint(catalog)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.483.1">
        self.client = self.app.test_client()</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.484.1">The preceding method is run before each test is run and creates a new test client. </span><span class="koboSpan" id="kobo.484.2">A test is represented by the methods in this class that start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">test_</span></strong><span class="koboSpan" id="kobo.486.1"> prefix. </span><span class="koboSpan" id="kobo.486.2">Here, we set a database name in the app configuration, which is a timestamp-based value that will always be unique. </span><span class="koboSpan" id="kobo.486.3">We also set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">TESTING</span></strong><span class="koboSpan" id="kobo.488.1"> flag to </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">True</span></strong><span class="koboSpan" id="kobo.490.1">, which disables error catching to enable better testing. </span><span class="koboSpan" id="kobo.490.2">Do pay special attention to how the application factory is used to create an application object before initializing </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">db</span></strong><span class="koboSpan" id="kobo.492.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">babel</span></strong><span class="koboSpan" id="kobo.494.1">.</span></p>
<p><span class="koboSpan" id="kobo.495.1">Finally, we run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">create_all()</span></strong><span class="koboSpan" id="kobo.497.1"> method on </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">db</span></strong><span class="koboSpan" id="kobo.499.1"> to create all the tables from our application in the test database created.</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.500.1">Remove the temporary database created in the previous step after the test </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">has executed:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.502.1">
    def tearDown(self):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.503.1">
        os.remove(self.test_db_file)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.504.1">The preceding </span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.505.1">method is called after each test is run. </span><span class="koboSpan" id="kobo.505.2">Here, we will remove the current database file and use a fresh database file for each test.</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.506.1">Finally, write the </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">test case:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.508.1">
    def test_home(self):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.509.1">
        rv = self.client.get('/')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.510.1">
        self.assertEqual(rv.status_code, 200)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.511.1">The preceding code is our first test, where we sent an HTTP </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">GET</span></strong><span class="koboSpan" id="kobo.513.1"> request to our application at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">/</span></strong><span class="koboSpan" id="kobo.515.1"> URL and tested the response for the status code, which should be </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">200</span></strong><span class="koboSpan" id="kobo.517.1">, representing a s</span><a id="_idTextAnchor559"/><span class="koboSpan" id="kobo.518.1">uccessful </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">GET</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.520.1"> response.</span></span></p>
<h2 id="_idParaDest-295"><a id="_idTextAnchor560"/><span class="koboSpan" id="kobo.521.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.522.1">To run the test file, just execute the following command in </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">the terminal:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.524.1">
$ python app_tests.py</span></pre>
<p><span class="koboSpan" id="kobo.525.1">The following screenshot shows the output that signifies the outcome of </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">the tests:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer075">
<span class="koboSpan" id="kobo.527.1"><img alt="Figure 10.4 –﻿ The first test result" src="image/B19111_10_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.528.1">Figure 10.4 –</span><a id="_idTextAnchor561"/><span class="koboSpan" id="kobo.529.1"> The first test result</span></p>
<h2 id="_idParaDest-296"><a id="_idTextAnchor562"/><span class="koboSpan" id="kobo.530.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.531.1">Refer to</span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.532.1"> the next recipe, </span><em class="italic"><span class="koboSpan" id="kobo.533.1">Writing more tests for views and logic</span></em><span class="koboSpan" id="kobo.534.1">, to see more on how </span><a id="_idTextAnchor563"/><span class="koboSpan" id="kobo.535.1">to write </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">complex tests.</span></span></p>
<h1 id="_idParaDest-297"><a id="_idTextAnchor564"/><span class="koboSpan" id="kobo.537.1">Writing more tests for views and logic</span></h1>
<p><span class="koboSpan" id="kobo.538.1">In the last </span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.539.1">recipe, we got started with writing tests for our Flask application. </span><span class="koboSpan" id="kobo.539.2">In this recipe, we will build upon the same test file and add more tests for our application; these tests will cover testing the views</span><a id="_idTextAnchor565"/><span class="koboSpan" id="kobo.540.1"> for behavior </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">and logic.</span></span></p>
<h2 id="_idParaDest-298"><a id="_idTextAnchor566"/><span class="koboSpan" id="kobo.542.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.543.1">We will build upon the test file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">app_tests.py</span></strong><span class="koboSpan" id="kobo.545.1"> cre</span><a id="_idTextAnchor567"/><span class="koboSpan" id="kobo.546.1">ated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">last recipe.</span></span></p>
<h2 id="_idParaDest-299"><a id="_idTextAnchor568"/><span class="koboSpan" id="kobo.548.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.549.1">Before we write any tests, we need to add a small bit of configuration to </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">setUp()</span></strong><span class="koboSpan" id="kobo.551.1"> to disable the CSRF tokens, as they are not generated by default for </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">test environments:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.553.1">
        test_config['WTF_CSRF_ENABLED'] = False</span></pre>
<p><span class="koboSpan" id="kobo.554.1">The following are some tests that are created as a part of this recipe. </span><span class="koboSpan" id="kobo.554.2">Each test will be described as we </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">go further:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.556.1">Firstly, write a test to make a </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">GET</span></strong><span class="koboSpan" id="kobo.558.1"> request to the </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">products list:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.560.1">
    def test_products(self):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.561.1">
        "Test Products list page"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.562.1">
        rv = self.client.get('/en/products')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.563.1">
        self.assertEqual(rv.status_code, 200)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.564.1">
        self.assertTrue('No Previous Page' in</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.565.1">
          rv.data.decode("utf-8"))</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.566.1">
        self.assertTrue('No Next Page' in</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.567.1">
          rv.data.decode("utf-8"))</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.568.1">The preceding test sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">GET</span></strong><span class="koboSpan" id="kobo.570.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">/products</span></strong><span class="koboSpan" id="kobo.572.1"> endpoint and asserts that the status code of the response is </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">200</span></strong><span class="koboSpan" id="kobo.574.1">. </span><span class="koboSpan" id="kobo.574.2">It also asserts that there is no previous page and no next page (rendered as a part of the template logic).</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.575.1">Next, create a</span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.576.1"> category and verify that it has been </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">created correctly:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.578.1">
    def test_create_category(self):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.579.1">
        "Test creation of new category"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.580.1">
        rv = self.client.get('/en/category-create')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.581.1">
        self.assertEqual(rv.status_code, 200)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.582.1">
        rv = self.client.post('/en/category-create')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.583.1">
        self.assertEqual(rv.status_code, 200)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.584.1">
        self.assertTrue('This field is required.' </span><span class="koboSpan" id="kobo.584.2">In</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.585.1">
          rv.data.decode("utf-8"))</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.586.1">
        rv = self.client.get('/en/categories')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.587.1">
        self.assertEqual(rv.status_code, 200)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.588.1">
        self.assertFalse('Phones' in</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.589.1">
          rv.data.decode("utf-8"))</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.590.1">
        rv = self.client.post('/en/category-create',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.591.1">
          data={</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.592.1">
            'name': 'Phones',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.593.1">
        })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.594.1">
        self.assertEqual(rv.status_code, 302)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.595.1">
        rv = self.client.get('/en/categories')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.596.1">
        self.assertEqual(rv.status_code, 200)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.597.1">
        self.assertTrue('Phones' in</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.598.1">
          rv.data.decode("utf-8"))</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.599.1">
        rv = self.client.get('/en/category/1')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.600.1">
        self.assertEqual(rv.status_code, 200)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.601.1">
        self.assertTrue('Phones' in</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.602.1">
          rv.data.decode("utf-8"))</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.603.1">The preceding </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.604.1">test creates a category and asserts for corresponding status messages. </span><span class="koboSpan" id="kobo.604.2">When a category is successfully created, we will be redirected to the newly created category page, and hence, the status code will be </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">302</span></strong><span class="koboSpan" id="kobo.606.1">.</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.607.1">Now, similar to category creation, create a product and then verify </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">its creation:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.609.1">
    def test_create_product(self):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.610.1">
        "Test creation of new product"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.611.1">
        rv = self.client.get('/en/product-create')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.612.1">
        self.assertEqual(rv.status_code, 200)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.613.1">
        # Raise a ValueError for a valid category not</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.614.1">
          found</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.615.1">
        self.assertRaises(ValueError,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.616.1">
          self.client.post, '/en/product-create')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.617.1">
        # Create a category to be used in product</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.618.1">
          creation</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.619.1">
        rv = self.client.post('/en/category-create',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.620.1">
          data={</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.621.1">
            'name': 'Phones',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.622.1">
        })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.623.1">
        self.assertEqual(rv.status_code, 302)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.624.1">
        rv = self.client.post('/en/product-create',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.625.1">
          data={</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.626.1">
            'name': 'iPhone 5',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.627.1">
            'price': 549.49,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.628.1">
            'company': 'Apple',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.629.1">
            'category': 1,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.630.1">
            'image': tempfile.NamedTemporaryFile()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.631.1">
        })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.632.1">
        self.assertEqual(rv.status_code, 302)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.633.1">
        rv = self.client.get('/en/products')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.634.1">
        self.assertEqual(rv.status_code, 200)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.635.1">
        self.assertTrue('iPhone 5' in</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.636.1">
          rv.data.decode("utf-8"))</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.637.1">The preceding test creates a product and asserts for corresponding status messages on each call/request.</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.638.1">Information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.639.1">As a part of this test, we identified a small improvement in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">create_product()</span></strong><span class="koboSpan" id="kobo.641.1"> method. </span><span class="koboSpan" id="kobo.641.2">We had not initiated the </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">filename</span></strong><span class="koboSpan" id="kobo.643.1"> variable before the </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">if</span></strong><span class="koboSpan" id="kobo.645.1"> condition to check for the allowed file type. </span><span class="koboSpan" id="kobo.645.2">The earlier code would work fine only when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">if</span></strong><span class="koboSpan" id="kobo.647.1"> condition passed. </span><span class="koboSpan" id="kobo.647.2">Now, we have just adjusted the code to initiate </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">filename</span></strong><span class="koboSpan" id="kobo.649.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">filename = secure_filename(image.filename)</span></strong><span class="koboSpan" id="kobo.651.1"> before the </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">if</span></strong><span class="koboSpan" id="kobo.653.1"> condition, instead of doing it inside </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">the condition.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.655.1">Finally, create </span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.656.1">multiple products and search for the products that were </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">just created:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.658.1">
    def test_search_product(self):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.659.1">
        "Test searching product"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.660.1">
        # Create a category to be used in product</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.661.1">
          creation</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.662.1">
        rv = self.client.post('/en/category-create',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.663.1">
          data={</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.664.1">
            'name': 'Phones',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.665.1">
        })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.666.1">
        self.assertEqual(rv.status_code, 302)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.667.1">
        # Create a product</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.668.1">
        rv = self.client.post('/en/product-create',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.669.1">
          data={</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.670.1">
            'name': 'iPhone 5',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.671.1">
            'price': 549.49,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.672.1">
            'company': 'Apple',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.673.1">
            'category': 1,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.674.1">
            'image': tempfile.NamedTemporaryFile()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.675.1">
        })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.676.1">
        self.assertEqual(rv.status_code, 302)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.677.1">
        # Create another product</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.678.1">
        rv = self.client.post('/en/product-create',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.679.1">
          data={</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.680.1">
            'name': 'Galaxy S5',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.681.1">
            'price': 549.49,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.682.1">
            'company': 'Samsung',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.683.1">
            'category': 1,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.684.1">
            'image': tempfile.NamedTemporaryFile()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.685.1">
        })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.686.1">
        self.assertEqual(rv.status_code, 302)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.687.1">
        self.client.get('/')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.688.1">
        rv = self.client.get('/en/product-</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.689.1">
          search?name=iPhone')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.690.1">
        self.assertEqual(rv.status_code, 200)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.691.1">
        self.assertTrue('iPhone 5' in</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.692.1">
          rv.data.decode("utf-8"))</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.693.1">
        self.assertFalse('Galaxy S5' in</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.694.1">
          rv.data.decode("utf-8"))</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.695.1">
        rv = self.client.get('/en/product-</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.696.1">
          search?name=iPhone 6')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.697.1">
        self.assertEqual(rv.status_code, 200)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.698.1">
        self.assertFalse('iPhone 6' in</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.699.1">
          rv.data.decode("utf-8"))</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.700.1">The preceding test first creates a category and two products. </span><span class="koboSpan" id="kobo.700.2">Then, it searches for one product </span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.701.1">and makes sure that only the searched produc</span><a id="_idTextAnchor569"/><span class="koboSpan" id="kobo.702.1">t is returned in the result.</span></p>
<h2 id="_idParaDest-300"><a id="_idTextAnchor570"/><span class="koboSpan" id="kobo.703.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.704.1">To run the test file, just execute the following command in </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">the terminal:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.706.1">
$ python app_tests.py -v
test_create_category (__main__.CatalogTestCase)
Test creation of new category ... </span><span class="koboSpan" id="kobo.706.2">ok
test_create_product (__main__.CatalogTestCase)
Test creation of new product ... </span><span class="koboSpan" id="kobo.706.3">ok
test_home (__main__.CatalogTestCase) ... </span><span class="koboSpan" id="kobo.706.4">ok
test_products (__main__.CatalogTestCase)
Test Products list page ... </span><span class="koboSpan" id="kobo.706.5">ok
test_search_product (__main__.CatalogTestCase)
Test searching product ... </span><span class="koboSpan" id="kobo.706.6">ok
----------------------------------------------------------------------
Ran 5 tests in 0.390s
OK</span></pre>
<p><span class="koboSpan" id="kobo.707.1">What follows </span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.708.1">the command is the output that sh</span><a id="_idTextAnchor571"/><span class="koboSpan" id="kobo.709.1">ows the outcome of </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">the tests.</span></span></p>
<h2 id="_idParaDest-301"><a id="_idTextAnchor572"/><span class="koboSpan" id="kobo.711.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.712.1">Another interesting and popular library that can be used for unit</span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.713.1"> testing is </span><strong class="bold"><span class="koboSpan" id="kobo.714.1">pytest</span></strong><span class="koboSpan" id="kobo.715.1">. </span><span class="koboSpan" id="kobo.715.2">It is similar to Python’s </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.716.1">in-built </span><strong class="bold"><span class="koboSpan" id="kobo.717.1">unittest</span></strong><span class="koboSpan" id="kobo.718.1"> library but with more out-of-the-box features. </span><span class="koboSpan" id="kobo.718.2">Feel free to explore </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">it: </span></span><a href="https://docs.pytest.org/en/stable/"><span class="No-Break"><span class="koboSpan" id="kobo.720.1">http</span><span id="_idTextAnchor573"/><span class="koboSpan" id="kobo.721.1">s://docs.pytest.org/en/stable/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.722.1">.</span></span></p>
<h1 id="_idParaDest-302"><a id="_idTextAnchor574"/><span class="koboSpan" id="kobo.723.1">Integrating the nose2 library</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.724.1">nose2</span></strong><span class="koboSpan" id="kobo.725.1"> is a library</span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.726.1"> that makes testing easier and much more fun. </span><span class="koboSpan" id="kobo.726.2">It provides a whole lot of tools to enhance our tests. </span><span class="koboSpan" id="kobo.726.3">Although </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">nose2</span></strong><span class="koboSpan" id="kobo.728.1"> can be used for multiple purposes, the most important usage remains that of a test collector and runner. </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">nose2</span></strong><span class="koboSpan" id="kobo.730.1"> automatically collects tests from Python source files, directories, and packages found in the current working directory. </span><span class="koboSpan" id="kobo.730.2">In this recipe, we will focus on how to run individual tests using </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">nose2</span></strong><span class="koboSpan" id="kobo.732.1"> rather than the whole bunch of tests </span><span class="No-Break"><span class="koboSpan" id="kobo.733.1">every time.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.734.1">Important</span></p>
<p class="callout"><span class="koboSpan" id="kobo.735.1">In earlier editions of this book, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">nose</span></strong><span class="koboSpan" id="kobo.737.1"> library. </span><span class="koboSpan" id="kobo.737.2">It has since not been under active maintenance and can be deemed deprecated. </span><span class="koboSpan" id="kobo.737.3">A replacement for it has been created, with the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">nose2</span></strong><span class="koboSpan" id="kobo.739.1">. </span><span class="koboSpan" id="kobo.739.2">This library behaves similarly to </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">nose</span></strong><span class="koboSpan" id="kobo.741.1"> but is not exactly the same. </span><span class="koboSpan" id="kobo.741.2">However, for the purpose of our demonstration, the majo</span><a id="_idTextAnchor575"/><span class="koboSpan" id="kobo.742.1">r functionality </span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">remains similar.</span></span></p>
<h2 id="_idParaDest-303"><a id="_idTextAnchor576"/><span class="koboSpan" id="kobo.744.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.745.1">First, we need to install the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">nose2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.747.1"> library:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.748.1">
$ pip install nose2</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">nose2</span></strong><span class="koboSpan" id="kobo.750.1"> has a mechanism for test file discovery that mandates that a file should start with </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">test</span></strong><span class="koboSpan" id="kobo.752.1">. </span><span class="koboSpan" id="kobo.752.2">Since, in our case, the test file is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">app_tests.py</span></strong><span class="koboSpan" id="kobo.754.1">, we should now rename it </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">test_app.py</span></strong><span class="koboSpan" id="kobo.756.1">. </span><span class="koboSpan" id="kobo.756.2">On a terminal, you can simply run </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">the followin</span><a id="_idTextAnchor577"/><span class="koboSpan" id="kobo.758.1">g:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.759.1">
$ mv app_tests.py test_app.py</span></pre>
<h2 id="_idParaDest-304"><a id="_idTextAnchor578"/><span class="koboSpan" id="kobo.760.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.761.1">We can execute all</span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.762.1"> the tests in our application using </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">nose2</span></strong><span class="koboSpan" id="kobo.764.1"> by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.766.1">
$ nose2 -v
test_create_category (test_app.CatalogTestCase)
Test creation of new category ... </span><span class="koboSpan" id="kobo.766.2">ok
test_create_product (test_app.CatalogTestCase)
Test creation of new product ... </span><span class="koboSpan" id="kobo.766.3">ok
test_home (test_app.CatalogTestCase) ... </span><span class="koboSpan" id="kobo.766.4">ok
test_products (test_app.CatalogTestCase)
Test Products list page ... </span><span class="koboSpan" id="kobo.766.5">ok
test_search_product (test_app.CatalogTestCase)
Test searching product ... </span><span class="koboSpan" id="kobo.766.6">ok
----------------------------------------------------------------------
Ran 5 tests in 0.241s
OK</span></pre>
<p><span class="koboSpan" id="kobo.767.1">This will pick out all the tests in our application and run them, even if we have multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">test files.</span></span></p>
<p><span class="koboSpan" id="kobo.769.1">To run a single test file, simply run the </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.771.1">
$ nose2 test_app</span></pre>
<p><span class="koboSpan" id="kobo.772.1">Now, if you want to run a single test, simply run </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">this command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.774.1">
$ nose2 test_app.CatalogTestCase.test_home</span></pre>
<p><span class="koboSpan" id="kobo.775.1">This becomes important when we have a memory-intensive application and a large number of test cases. </span><span class="koboSpan" id="kobo.775.2">In that instance, the tests themselves can take a long time to run, and doing so every</span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.776.1"> time can be very frustrating for a developer. </span><span class="koboSpan" id="kobo.776.2">Instead, we will prefer to run only those tests that concern the change made, or the test that</span><a id="_idTextAnchor579"/><span class="koboSpan" id="kobo.777.1"> broke following a </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">certain change.</span></span></p>
<h2 id="_idParaDest-305"><a id="_idTextAnchor580"/><span class="koboSpan" id="kobo.779.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.780.1">There are many other ways to configure </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">nose2</span></strong><span class="koboSpan" id="kobo.782.1"> for optimal and effective usage as per requirements. </span><span class="koboSpan" id="kobo.782.2">Refer to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">nose2</span></strong><span class="koboSpan" id="kobo.784.1"> documentation at </span><a href="https://docs.nose2.io/en/latest/index.html"><span class="koboSpan" id="kobo.785.1">https://docs.nose2.io/en/l</span><span id="_idTextAnchor581"/><span class="koboSpan" id="kobo.786.1">atest/index.html</span></a><span class="koboSpan" id="kobo.787.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">more details.</span></span></p>
<h1 id="_idParaDest-306"><a id="_idTextAnchor582"/><span class="koboSpan" id="kobo.789.1">Using mocking to avoid external API access</span></h1>
<p><span class="koboSpan" id="kobo.790.1">We are aware</span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.791.1"> of how testing works, but now, let’s</span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.792.1"> imagine we have a third-party application/service integrated via API calls with our application. </span><span class="koboSpan" id="kobo.792.2">It would not be a great idea to make calls to this application/service every time tests are run. </span><span class="koboSpan" id="kobo.792.3">Sometimes, these can be paid, too, and making calls during tests can not only be expensive but also affect the statistics of that service. </span><strong class="bold"><span class="koboSpan" id="kobo.793.1">Mocking</span></strong><span class="koboSpan" id="kobo.794.1"> plays a very important role in such scenarios. </span><span class="koboSpan" id="kobo.794.2">The simplest example of this can be mocking SMTP for emails. </span><span class="koboSpan" id="kobo.794.3">In this recipe, we will integrate our application with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">geoip2</span></strong><span class="koboSpan" id="kobo.796.1"> l</span><a id="_idTextAnchor583"/><span class="koboSpan" id="kobo.797.1">ibrary and then test it </span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">via mocking.</span></span></p>
<h2 id="_idParaDest-307"><a id="_idTextAnchor584"/><span class="koboSpan" id="kobo.799.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.800.1">In Python 3, </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">mock</span></strong><span class="koboSpan" id="kobo.802.1"> has been included as a standard package in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">unittest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.804.1"> library.</span></span></p>
<p><span class="koboSpan" id="kobo.805.1">For the purpose of this recipe, we first need to install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">geoip2</span></strong><span class="koboSpan" id="kobo.807.1"> library and the </span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">corresponding database:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.809.1">
$ pip install geoip2</span></pre>
<p><span class="koboSpan" id="kobo.810.1">You also need to download the free </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">geoip</span></strong><span class="koboSpan" id="kobo.812.1"> database from the MaxMind (</span><a href="https://dev.maxmind.com/geoip/geolite2-free-geolocation-data"><span class="koboSpan" id="kobo.813.1">https://dev.maxmind.com/geoip/geolite2-free-geolocation-data</span></a><span class="koboSpan" id="kobo.814.1">) website to a location of your preference, and then unzip the file. </span><span class="koboSpan" id="kobo.814.2">For the sake of simplicity, I have downloaded it to the project folder itself. </span><span class="koboSpan" id="kobo.814.3">You will need to create a free account before you can download the </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">geoip</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.816.1">city database.</span></span></p>
<p><span class="koboSpan" id="kobo.817.1">After downloading the city database, you should have a folder with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">Geolite2- City-</span></strong><span class="koboSpan" id="kobo.819.1"> prefix. </span><span class="koboSpan" id="kobo.819.2">This folder contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">geoip</span></strong><span class="koboSpan" id="kobo.821.1"> database with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">.mmdb</span></strong><span class="koboSpan" id="kobo.823.1"> extension that we will use in </span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">this recipe.</span></span></p>
<p><span class="koboSpan" id="kobo.825.1">Now, let’s say we want to store the location of a user who creates a product (imagine a scenario where </span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.826.1">the</span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.827.1"> application is administered at multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">global locations).</span></span></p>
<p><span class="koboSpan" id="kobo.829.1">We need to make some small changes to </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">my_app/catalog/models.py</span></strong><span class="koboSpan" id="kobo.831.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">my_app/catalog/views.py</span></strong><span class="koboSpan" id="kobo.833.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">templates/product.html</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.836.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.837.1">For </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">my_app/catalog/models.py</span></strong><span class="koboSpan" id="kobo.839.1">, we will add a new field </span><span class="No-Break"><span class="koboSpan" id="kobo.840.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">user_timezone</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.843.1">
class Product(db.Model):
    # ... </span><span class="koboSpan" id="kobo.843.2">Other fields ...
</span><span class="koboSpan" id="kobo.843.3">    user_timezone = db.Column(db.String(255))
    def __init__(self, name, price, category, image_path,
      user_timezone=''):
        # ... </span><span class="koboSpan" id="kobo.843.4">Other fields initialization ...
</span><span class="koboSpan" id="kobo.843.5">        self.user_timezone = user_timezone</span></pre>
<p><span class="koboSpan" id="kobo.844.1">For </span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">my_app/catalog/views.py</span></strong><span class="koboSpan" id="kobo.846.1">, we will modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">create_product()</span></strong><span class="koboSpan" id="kobo.848.1"> method to include the </span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">time zone:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.850.1">
import geoip2.database, geoip2.errors
@catalog.route('/&lt;lang&gt;/product-create', methods=['GET',
  'POST'])
def create_product():
    form = ProductForm()
    if form.validate_on_submit():
        # ... </span><span class="koboSpan" id="kobo.850.2">Non changed code ...
</span><span class="koboSpan" id="kobo.850.3">        reader = geoip2.database.Reader(
            'GeoLite2-City_20230113/GeoLite2-City.mmdb'
        )
        try:
            match = reader.city(request.remote_addr)
        except geoip2.errors.AddressNotFoundError:
            match = None
        product = Product(
            name, price, category, filename,
            match and match.location.time_zone or
              'Localhost'
        )
        # ... </span><span class="koboSpan" id="kobo.850.4">Non changed code ...</span></pre>
<p><span class="koboSpan" id="kobo.851.1">Here, we fetched</span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.852.1"> the</span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.853.1"> geolocation data using an IP lookup and passed this during product creation. </span><span class="koboSpan" id="kobo.853.2">If no match is found, then the call is made from </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">localhost</span></strong><span class="koboSpan" id="kobo.855.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">127.0.0.1</span></strong><span class="koboSpan" id="kobo.857.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.858.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">0.0.0.0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.860.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.861.1">Also, we will add this new field in our product template so that it becomes easy to verify in the test. </span><span class="koboSpan" id="kobo.861.2">For this, just add </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">{{ product.user_timezone }}</span><a id="_idTextAnchor585"/></strong><span class="koboSpan" id="kobo.863.1"> somewhere in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">product.html</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.865.1"> template.</span></span></p>
<h2 id="_idParaDest-308"><a id="_idTextAnchor586"/><span class="koboSpan" id="kobo.866.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.867.1">Start by modifying </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">test_app.py</span></strong><span class="koboSpan" id="kobo.869.1"> to accommodate the mocking of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">geoip</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.871.1"> lookup:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.872.1">First, configure </span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.873.1">the mocking of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">geoip</span></strong><span class="koboSpan" id="kobo.875.1"> lookup </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.876.1">by </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">creating patchers:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.878.1">
from unittest import mock</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.879.1">
import geoip2.records</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.880.1">
class CatalogTestCase(unittest.TestCase):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.881.1">
    def setUp(self):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.882.1">
        # ... </span><span class="koboSpan" id="kobo.882.2">Non changed code ...</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.883.1">
        self.geoip_city_patcher =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.884.1">
          mock.patch('geoip2.models.City',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.885.1">
            location=geoip2.records.Location(time_zone</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.886.1">
              = 'America/Los_Angeles')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.887.1">
        )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.888.1">
        PatchedGeoipCity =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.889.1">
          self.geoip_city_patcher.start()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.890.1">
        self.geoip_reader_patcher =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.891.1">
          mock.patch('geoip2.database.Reader')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.892.1">
        PatchedGeoipReader =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.893.1">
          self.geoip_reader_patcher.start()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.894.1">
        PatchedGeoipReader().city.return_value =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.895.1">
          PatchedGeoipCity</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.896.1">
        with self.app.app_context():</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.897.1">
            db.create_all()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.898.1">
        from my_app.catalog.views import catalog</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.899.1">
        self.app.register_blueprint(catalog)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.900.1">
        self.client = self.app.test_client()</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.901.1">First, we imported </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">records</span></strong><span class="koboSpan" id="kobo.903.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">geoip2</span></strong><span class="koboSpan" id="kobo.905.1">, which we will use to create the mocked return value that we need to use for testing. </span><span class="koboSpan" id="kobo.905.2">Then, we patched </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">geoip2.models.City</span></strong><span class="koboSpan" id="kobo.907.1"> with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">location</span></strong><span class="koboSpan" id="kobo.909.1"> attribute on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">City</span></strong><span class="koboSpan" id="kobo.911.1"> model preset to </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">geoip2.records.Location(time_zone = 'America/Los_Angeles')</span></strong><span class="koboSpan" id="kobo.913.1"> and started the patcher. </span><span class="koboSpan" id="kobo.913.2">This means that whenever an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">geoip2.models.City</span></strong><span class="koboSpan" id="kobo.915.1"> is created, it will be patched with the time zone on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.916.1">location</span></strong><span class="koboSpan" id="kobo.917.1"> attribute set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.918.1">'America/Los_Angeles'</span></strong><span class="koboSpan" id="kobo.919.1">.</span></p>
<p><span class="koboSpan" id="kobo.920.1">This is</span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.921.1"> followed </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.922.1">by the patching of </span><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">geoip2.database.Reader</span></strong><span class="koboSpan" id="kobo.924.1">, where we mock the return value of its </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">city()</span></strong><span class="koboSpan" id="kobo.926.1"> method to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.927.1">PatchedGeoipCity</span></strong><span class="koboSpan" id="kobo.928.1"> class that we created previously.</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.929.1">Stop the patchers that were started in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">setUp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.931.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.932.1">
    def tearDown(self):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.933.1">
        self.geoip_city_patcher.stop()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.934.1">
        self.geoip_reader_patcher.stop()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.935.1">
        os.remove(self.test_db_file)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.936.1">We stopped the mock patchers in </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">tearDown</span></strong><span class="koboSpan" id="kobo.938.1"> so that the actual calls are not affected.</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.939.1">Finally, modify </span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.940.1">the product test case created </span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.941.1">to assert </span><span class="No-Break"><span class="koboSpan" id="kobo.942.1">the location:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.943.1">
    def test_create_product(self):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.944.1">
        "Test creation of new product"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.945.1">
        # ... </span><span class="koboSpan" id="kobo.945.2">Non changed code ...</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.946.1">
        rv = self.client.post('/en/product-create',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.947.1">
          data={</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.948.1">
            'name': 'iPhone 5',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.949.1">
            'price': 549.49,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.950.1">
            'company': 'Apple',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.951.1">
            'category': 1,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.952.1">
            'image': tempfile.NamedTemporaryFile()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.953.1">
        })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.954.1">
        self.assertEqual(rv.status_code, 302)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.955.1">
        rv = self.client.get('/en/product/1')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.956.1">
        self.assertEqual(rv.status_code, 200)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.957.1">
        self.assertTrue('iPhone 5' in</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.958.1">
          rv.data.decode("utf-8"))</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.959.1">
        self.assertTrue('America/Los_Angeles' in</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.960.1">
          rv.data.decode("utf-8"))</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.961.1">Here, after the creation of the product, we asserted that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">America/Los_Angeles</span></strong><span class="koboSpan" id="kobo.963.1"> value is present somew</span><a id="_idTextAnchor587"/><span class="koboSpan" id="kobo.964.1">here in the product template that is rendered.</span></p>
<h2 id="_idParaDest-309"><a id="_idTextAnchor588"/><span class="koboSpan" id="kobo.965.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.966.1">Run the </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.967.1">test</span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.968.1"> and see whether </span><span class="No-Break"><span class="koboSpan" id="kobo.969.1">it passes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.970.1">
$ nose2 test_app.CatalogTestCase.test_create_product -v
test_create_product (test_app.CatalogTestCase)
Test creation of new product ... </span><span class="koboSpan" id="kobo.970.2">ok
-----------------------------------------</span><a id="_idTextAnchor589"/><span class="koboSpan" id="kobo.971.1">-----------------------
Ran 1 test in 0.079s
OK</span></pre>
<h2 id="_idParaDest-310"><a id="_idTextAnchor590"/><span class="koboSpan" id="kobo.972.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.973.1">There are multiple ways in which mocking can be done. </span><span class="koboSpan" id="kobo.973.2">I demonstrated just one of them. </span><span class="koboSpan" id="kobo.973.3">You can choose any method from the ones available. </span><span class="koboSpan" id="kobo.973.4">Refer to the documentation available </span><span class="No-Break"><span class="koboSpan" id="kobo.974.1">at</span></span><span class="No-Break"> </span><a href="https://docs.python.org/3/library/unittest.mock.html"><span class="No-Break"><span class="koboSpan" id="kobo.975.1">https</span><span id="_idTextAnchor591"/><span class="koboSpan" id="kobo.976.1">://docs.python.org/3/library/unittest.mock.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.977.1">.</span></span></p>
<h1 id="_idParaDest-311"><a id="_idTextAnchor592"/><span class="koboSpan" id="kobo.978.1">Determining test coverage</span></h1>
<p><span class="koboSpan" id="kobo.979.1">In the previous </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.980.1">recipes, test case writing was covered, but there is an important aspect to measure the extent of testing, called coverage. </span><span class="koboSpan" id="kobo.980.2">Coverage refers to how much of our code has been covered by the tests. </span><span class="koboSpan" id="kobo.980.3">The higher the percentage of coverage, the better the testing (although high coverage is not the only criterion for good tests). </span><span class="koboSpan" id="kobo.980.4">In this recipe, we will check the code coverage of </span><span class="No-Break"><span class="koboSpan" id="kobo.981.1">our application.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.982.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.983.1">Remember that 100% test coverage does not mean that code is flawless. </span><span class="koboSpan" id="kobo.983.2">However, in any case, it is better than having no tests or lower coverage.</span><a id="_idTextAnchor593"/><span class="koboSpan" id="kobo.984.1"> Remember that “</span><em class="italic"><span class="koboSpan" id="kobo.985.1">if it’s not tested, </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.986.1">it’s broken.</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.987.1">”</span></span></p>
<h2 id="_idParaDest-312"><a id="_idTextAnchor594"/><span class="koboSpan" id="kobo.988.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.989.1">We will use a library called </span><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">coverage</span></strong><span class="koboSpan" id="kobo.991.1"> for this recipe. </span><span class="koboSpan" id="kobo.991.2">The following is</span><a id="_idTextAnchor595"/><span class="koboSpan" id="kobo.992.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.993.1">installation command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.994.1">
$ pip install coverage</span></pre>
<h2 id="_idParaDest-313"><a id="_idTextAnchor596"/><span class="koboSpan" id="kobo.995.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.996.1">The simplest way of measuring code coverage is to use the </span><span class="No-Break"><span class="koboSpan" id="kobo.997.1">command line:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.998.1">Simply run the </span><span class="No-Break"><span class="koboSpan" id="kobo.999.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1000.1">$ coverage run --source=&lt;Folder name of the application&gt; --omit=test_app.py,run.py test_app.py</span></strong></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1001.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1002.1">--source</span></strong><span class="koboSpan" id="kobo.1003.1"> indicates</span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.1004.1"> the directories that are to be considered in coverage, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1005.1">--omit</span></strong><span class="koboSpan" id="kobo.1006.1"> indicates the files that need to be omitted in the process.</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.1007.1">Now, to print the report on the terminal itself, run the </span><span class="No-Break"><span class="koboSpan" id="kobo.1008.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1009.1">$ coverage report</span></strong></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1010.1">The following screenshot shows the output:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer076">
<span class="koboSpan" id="kobo.1011.1"><img alt="Figure 10.5 – The test coverage report" src="image/B19111_10_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1012.1">Figure 10.5 – The test coverage report</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.1013.1">To get a nice HTML output of the coverage report, run the </span><span class="No-Break"><span class="koboSpan" id="kobo.1014.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1015.1">$ coverage html</span></strong></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1016.1">This will create a new folder named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1017.1">htmlcov</span></strong><span class="koboSpan" id="kobo.1018.1"> in your current working directory. </span><span class="koboSpan" id="kobo.1018.2">Inside </span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.1019.1">this, just open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.1020.1">index.html</span></strong><span class="koboSpan" id="kobo.1021.1"> in a browser, and the full detailed view will be available.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer077">
<span class="koboSpan" id="kobo.1022.1"><img alt="Figure 10.6 – The test coverage report web view" src="image/B19111_10_6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1023.1">Figure 10.6 – The test coverage report web view</span></p>
<p><span class="koboSpan" id="kobo.1024.1">Alternatively, we can include a piece of code in our test file and get the coverage report every time the tests are run. </span><span class="koboSpan" id="kobo.1024.2">We just add the following code snippets </span><span class="No-Break"><span class="koboSpan" id="kobo.1025.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1026.1">test_app.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1028.1">Before anything else, add the following code to start the coverage </span><span class="No-Break"><span class="koboSpan" id="kobo.1029.1">assessment process:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1030.1">
import coverage</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1031.1">
cov = coverage.coverage(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1032.1">
    omit = [</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1033.1">
        '/Users/apple/workspace/flask-cookbook-3/</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1034.1">
          Chapter-10/lib/python3.10/site-packages/*',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1035.1">
        'test_app.py'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1036.1">
    ]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1037.1">
)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1038.1">
cov.start()</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1039.1">Here, we</span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.1040.1"> imported the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1041.1">coverage</span></strong><span class="koboSpan" id="kobo.1042.1"> library and created an object for it. </span><span class="koboSpan" id="kobo.1042.2">This tells the library to omit all </span><strong class="source-inline"><span class="koboSpan" id="kobo.1043.1">site-packages</span></strong><span class="koboSpan" id="kobo.1044.1"> instances (because we do not want to evaluate the code that we did not write) and the test file itself. </span><span class="koboSpan" id="kobo.1044.2">Then, we started the process to determine the coverage.</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.1045.1">At the end of the code, modify the last block to </span><span class="No-Break"><span class="koboSpan" id="kobo.1046.1">the following:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1047.1">
if __name__ == '__main__':</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1048.1">
    try:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1049.1">
        unittest.main()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1050.1">
    finally:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1051.1">
        cov.stop()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1052.1">
        cov.save()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1053.1">
        cov.report()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1054.1">
        cov.html_report(directory = 'coverage')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1055.1">
        cov.erase()</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1056.1">In the preceding code, we first put </span><strong class="source-inline"><span class="koboSpan" id="kobo.1057.1">unittest.main()</span></strong><span class="koboSpan" id="kobo.1058.1"> inside a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1059.1">try..finally</span></strong><span class="koboSpan" id="kobo.1060.1"> block. </span><span class="koboSpan" id="kobo.1060.2">This is because </span><strong class="source-inline"><span class="koboSpan" id="kobo.1061.1">unittest.main()</span></strong><span class="koboSpan" id="kobo.1062.1"> exits after all the tests are executed. </span><span class="koboSpan" id="kobo.1062.2">Now, the coverage-specific code is forced to run after this method completes. </span><span class="koboSpan" id="kobo.1062.3">We stopped the coverage report, saved it, printed the report on the console, and then generated the HTML version of it before deleting the temporary </span><strong class="source-inline"><span class="koboSpan" id="kobo.1063.1">.coverage</span></strong><span class="koboSpan" id="kobo.1064.1"> file (this</span><a id="_idTextAnchor597"/><span class="koboSpan" id="kobo.1065.1"> is created automatically as part of the process).</span></p>
<h2 id="_idParaDest-314"><a id="_idTextAnchor598"/><span class="koboSpan" id="kobo.1066.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.1067.1">If we run our tests after including the coverage-specific code, then we can run the </span><span class="No-Break"><span class="koboSpan" id="kobo.1068.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1069.1">
$ python test_app.py</span></pre>
<p><span class="koboSpan" id="kobo.1070.1">The output </span><a id="_idTextAnchor599"/><span class="koboSpan" id="kobo.1071.1">will </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.1072.1">be very similar to the one in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1073.1">Figure 10</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1074.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1075.1">.</span></span></p>
<h2 id="_idParaDest-315"><a id="_idTextAnchor600"/><span class="koboSpan" id="kobo.1076.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.1077.1">It is also possible to determine coverage using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1078.1">nose2</span></strong><span class="koboSpan" id="kobo.1079.1"> library, which we discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.1080.1">Integrating the nose2 library</span></em><span class="koboSpan" id="kobo.1081.1"> recipe. </span><span class="koboSpan" id="kobo.1081.2">I will leave it to you to explore this by yourself. </span><span class="koboSpan" id="kobo.1081.3">Refer to </span><a href="https://docs.nose2.io/en/latest/plugins/coverage.html"><span class="koboSpan" id="kobo.1082.1">https://docs.nose2.i</span><span id="_idTextAnchor601"/><span class="koboSpan" id="kobo.1083.1">o/en/latest/plugins/coverage.html</span></a><span class="koboSpan" id="kobo.1084.1"> fo</span><a id="_idTextAnchor602"/><span class="koboSpan" id="kobo.1085.1">r a </span><span class="No-Break"><span class="koboSpan" id="kobo.1086.1">head start.</span></span></p>
<h1 id="_idParaDest-316"><a id="_idTextAnchor603"/><span class="koboSpan" id="kobo.1087.1">Using profiling to find bottlenecks</span></h1>
<p><span class="koboSpan" id="kobo.1088.1">Profiling is an</span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.1089.1"> important and handy tool to measure</span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.1090.1"> performance when we decide to scale an application. </span><span class="koboSpan" id="kobo.1090.2">Before scaling, we want to know whether any process is a bottleneck and affects the overall performance. </span><span class="koboSpan" id="kobo.1090.3">Python has a built-in profiler, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1091.1">cProfile</span></strong><span class="koboSpan" id="kobo.1092.1">, that can do the job for us, but to make life easier, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1093.1">werkzeug</span></strong><span class="koboSpan" id="kobo.1094.1"> has </span><strong class="source-inline"><span class="koboSpan" id="kobo.1095.1">ProfilerMiddleware</span></strong><span class="koboSpan" id="kobo.1096.1">, which is written over </span><strong class="source-inline"><span class="koboSpan" id="kobo.1097.1">cProfile</span></strong><span class="koboSpan" id="kobo.1098.1">. </span><span class="koboSpan" id="kobo.1098.2">In this recipe, we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1099.1">ProfilerMiddleware</span></strong><span class="koboSpan" id="kobo.1100.1"> to determin</span><a id="_idTextAnchor604"/><span class="koboSpan" id="kobo.1101.1">e whether there is anything that </span><span class="No-Break"><span class="koboSpan" id="kobo.1102.1">affects performance.</span></span></p>
<h2 id="_idParaDest-317"><a id="_idTextAnchor605"/><span class="koboSpan" id="kobo.1103.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.1104.1">We will use the application from the previous recipe and add </span><strong class="source-inline"><span class="koboSpan" id="kobo.1105.1">Profil</span><a id="_idTextAnchor606"/><span class="koboSpan" id="kobo.1106.1">erMiddleware</span></strong><span class="koboSpan" id="kobo.1107.1"> to a new file </span><span class="No-Break"><span class="koboSpan" id="kobo.1108.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1109.1">generate_profile.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1110.1">.</span></span></p>
<h2 id="_idParaDest-318"><a id="_idTextAnchor607"/><span class="koboSpan" id="kobo.1111.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.1112.1">Create a new file, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1113.1">generate_profile.py</span></strong><span class="koboSpan" id="kobo.1114.1">, alongside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">run.py</span></strong><span class="koboSpan" id="kobo.1116.1">, which works like </span><strong class="source-inline"><span class="koboSpan" id="kobo.1117.1">run.py</span></strong><span class="koboSpan" id="kobo.1118.1"> itself </span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.1119.1">but </span><a id="_idIndexMarker459"/><span class="No-Break"><span class="koboSpan" id="kobo.1120.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1121.1">ProfilerMiddleware</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1122.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1123.1">
from werkzeug.middleware.profiler import ProfilerMiddleware
from my_app import app
app.wsgi_app = ProfilerMiddleware(app.wsgi_app,
  restrictions = [10])
app.run(debug=True)</span></pre>
<p><span class="koboSpan" id="kobo.1124.1">Here, we imported </span><strong class="source-inline"><span class="koboSpan" id="kobo.1125.1">ProfilerMiddleware</span></strong><span class="koboSpan" id="kobo.1126.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1127.1">werkzeug</span></strong><span class="koboSpan" id="kobo.1128.1"> and then modified </span><strong class="source-inline"><span class="koboSpan" id="kobo.1129.1">wsgi_app</span></strong><span class="koboSpan" id="kobo.1130.1"> on our Flask app to use it, with a restr</span><a id="_idTextAnchor608"/><span class="koboSpan" id="kobo.1131.1">iction of the top 10 calls to be printed in </span><span class="No-Break"><span class="koboSpan" id="kobo.1132.1">the output.</span></span></p>
<h2 id="_idParaDest-319"><a id="_idTextAnchor609"/><span class="koboSpan" id="kobo.1133.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.1134.1">Now, we can run our application </span><span class="No-Break"><span class="koboSpan" id="kobo.1135.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1136.1">generate_profile.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1137.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1138.1">
$ python generate_profile.py</span></pre>
<p><span class="koboSpan" id="kobo.1139.1">We can then create a new product. </span><span class="koboSpan" id="kobo.1139.2">Then, the output for that specific call will be like the </span><span class="No-Break"><span class="koboSpan" id="kobo.1140.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer078">
<span class="koboSpan" id="kobo.1141.1"><img alt="Figure 10.7 – The profiler output" src="image/B19111_10_7.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1142.1">Figure 10.7 – The profiler output</span></p>
<p><span class="koboSpan" id="kobo.1143.1">It is evident </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.1144.1">from </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.1145.1">the preceding screenshot that the most intensive call in this process is the call made to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1146.1">geoip</span></strong><span class="koboSpan" id="kobo.1147.1"> database. </span><span class="koboSpan" id="kobo.1147.2">Even though it is a single call, it takes the most amount of time. </span><span class="koboSpan" id="kobo.1147.3">So, if we decide to improve performance sometime down the line, this is something that needs to be looked </span><span class="No-Break"><span class="koboSpan" id="kobo.1148.1">at first.</span></span></p>
</div>
</body></html>