- en: Chapter 9. Making a Shoot-Em-Up Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。制作射击游戏
- en: Welcome to the final chapter of Kivy Blueprints. In this tutorial, we're going
    to build a shoot-em-up game (or *shmup* for short)—a fast-paced action game about
    shooting things indefinitely.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到Kivy蓝图的最后一章。在本教程中，我们将构建一个射击游戏（或简称为*shmup*）——一个关于无限射击的快节奏动作游戏。
- en: 'This is a small preview to pique your interest:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小预览，以激发你的兴趣：
- en: '![Making a Shoot-Em-Up Game](img/B01620_09_03.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![制作射击游戏](img/B01620_09_03.jpg)'
- en: 'The game: player (on the left-hand side) seeks to destroy the defenseless alien
    saucer (on the right-hand side)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中：玩家（在左侧）试图摧毁无防御能力的飞碟（在右侧）
- en: Building an app with lots of moving parts simultaneously presented on screen,
    especially a mobile (or multi-platform) game, depends heavily on a capable renderer.
    This is what we'll attempt to develop by the end of the book, partially based
    on the source code from the starfield screensaver discussed in [Chapter 8](ch08.html
    "Chapter 8. Introducing Shaders"), *Introducing Shaders*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 同时在屏幕上展示具有许多动态部分的应用程序，尤其是移动（或多平台）游戏，很大程度上依赖于一个强大的渲染器。这是我们将在本书末尾尝试开发的，部分基于第8章中讨论的星系屏幕保存在源代码，*介绍着色器*。
- en: 'This chapter will also cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还将涵盖以下主题：
- en: Working with texture atlases in Kivy, complete with manual unpacking of texture
    coordinates for use in low-level code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kivy中使用纹理图集，包括手动解包纹理坐标以用于底层代码
- en: Further development of a GLSL-based particle system and usage of particle systems
    to create different in-game entities
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于GLSL的粒子系统的进一步开发以及使用粒子系统创建不同的游戏内实体
- en: Implementing the game mechanics for a two-dimensional shooter—a control scheme
    suitable for mouse and touch screen, basic collision detection for bullets, and
    so on
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现二维射击游戏的机制——一个适合鼠标和触摸屏的控制方案，基本的子弹碰撞检测，等等
- en: As with all other code for this book, you can find the most up-to-date version
    of all source code on GitHub, at [https://github.com/mvasilkov/kb](https://github.com/mvasilkov/kb).
    Consult the full source code of the application periodically when following along,
    because this puts things in context and makes the program flow more understandable.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中的所有其他代码一样，你可以在GitHub上找到所有源代码的最新版本，在[https://github.com/mvasilkov/kb](https://github.com/mvasilkov/kb)。在跟随教程时定期查阅应用程序的完整源代码，因为这有助于理解上下文，并使程序流程更加易于理解。
- en: Limitations of the project
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目的局限性
- en: 'The shoot-em-up game we''re writing is going to be very minimal, feature-wise.
    In particular, here are the constraints:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在编写的射击游戏在功能上将会非常简约。特别是，以下是一些限制条件：
- en: The whole motivational part (winning and game over conditions) is omitted for
    the sake of clarity. It should be easy to implement once you're happy with the
    gameplay.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了清晰起见，省略了整个激励部分（胜利和游戏结束条件）。一旦你对游戏玩法满意，它应该很容易实现。
- en: There's just one enemy type in our version of the game, and one simple movement
    pattern.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的游戏版本中，只有一个敌人类型，并且有一个简单的移动模式。
- en: Many opportunities for optimization were purposefully missed to make the code
    more concise and readable.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故意错过了许多优化机会，以使代码更加简洁和易于阅读。
- en: These are left as an exercise for the reader, if you're willing to do a bit
    more work. But first, let's review how texture maps work in Kivy—we'll rely on
    them later in the particle system code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些留作读者的练习，如果你愿意做更多的工作。但首先，让我们回顾一下Kivy中纹理图是如何工作的——我们将在粒子系统代码中稍后依赖它们。
- en: Texture atlases at a glance
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一瞥纹理图集
- en: 'Texture atlases (also known as sprite sheets) are a method of combining images
    used in the application into a larger composite texture. There are several advantages
    of doing so, compared to just loading a bunch of individual images like we did
    in previous projects:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理图集（也称为精灵图集）是将应用程序中使用的图像组合成更大的复合纹理的方法。与我们在以前的项目中那样加载大量单个图像相比，这样做有几个优点：
- en: 'The application should open faster; it''s usually cheaper to read one large
    file than several smaller ones. This may sound negligible until you have hundreds
    of textures, and then it becomes pretty noticeable—even more so over the network:
    HTTP requests add sizable overhead, which may become a deal breaker on mobile
    devices with constrained connectivity.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应该打开得更快；通常情况下，读取一个大型文件比读取几个较小的文件要便宜。这听起来可能微不足道，直到你拥有数百个纹理，那时它就会变得相当明显——尤其是在网络上：HTTP请求增加了相当大的开销，这可能会在连接受限的移动设备上成为一项交易破坏者。
- en: Rendering is also subtly quicker when there's no need to rebind textures. Using
    a texture map effectively means that only the texture coordinates are affected
    by any change that would otherwise lead to switching textures.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当不需要重新绑定纹理时，渲染也会变得稍微快一些。有效地使用纹理图意味着只有纹理坐标会受到任何可能导致切换纹理的变化的影响。
- en: The previous point also makes atlases more suitable for use in situations when
    there's a single large model, such as our GLSL-based renderer. Again, texture
    coordinates are cheap and rebinding textures isn't.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前一点也使得纹理图更适合在只有一个大型模型的情况下使用，例如我们的基于 GLSL 的渲染器。再次强调，纹理坐标成本低，重新绑定纹理并不昂贵。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're coming from an HTML and CSS background, then you probably have heard
    about a very similar approach used in web development, called CSS sprites. The
    rationale is basically the same, sans the GLSL part. Since web apps are mostly
    delivered over the network, the gain from using CSS sprites is substantial even
    for a small number of images—every eliminated HTTP request counts.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自 HTML 和 CSS 背景，那么你可能已经听说过在网页开发中使用的非常类似的方法，称为 CSS 图标。其基本原理相同，只是没有 GLSL 部分。由于网络应用主要是通过网络交付的，因此即使是少量图像，使用
    CSS 图标也能带来显著的收益——每个消除的 HTTP 请求都很重要。
- en: 'In this section of the chapter, we''ll review the following topics:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，我们将回顾以下主题：
- en: Creating texture maps using Kivy's built-in CLI utility
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kivy 内置的 CLI 工具创建纹理图
- en: File format and structure of an `.atlas` file
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.atlas` 文件格式和结构'
- en: The usage of texture atlases in Kivy-based apps
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基于 Kivy 的应用程序中使用纹理图
- en: If you're already familiar with Kivy atlases, feel free to skip straight to
    the *Ad hoc usage of atlases with GLSL* section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉 Kivy 纹理图，可以直接跳到 *使用 GLSL 的纹理图即席使用* 部分。
- en: Creating an atlas
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建纹理图
- en: 'Unlike in web development, where no standard tool has emerged for this particular
    task, Kivy framework comes with a useful command-line utility for texture maps.
    Its invocation looks like the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与网络开发不同，网络开发中尚未出现用于此特定任务的标准工具，Kivy 框架附带了一个有用的命令行工具用于纹理图。其调用方式如下：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: On a Mac, replace `python` with `kivy`—that's the conventional command provided
    by `Kivy.app` for invoking a Kivy-aware Python interpreter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac 上，将 `python` 替换为 `kivy`——这是 `Kivy.app` 提供的用于调用 Kivy 感知 Python 解释器的传统命令。
- en: This creates two or more files, depending on whether all images fit into a single
    composite texture of requested size. For the purpose of this tutorial, we assume
    that the value of `texture_size` is large enough to include every last image.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建两个或更多文件，具体取决于所有图像是否都适合单个请求大小的复合纹理。在本教程中，我们假设 `texture_size` 的值足够大，可以包含每张最后的图像。
- en: 'All output files are named after the `atlas_name` argument that you provide
    on the command line:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所有输出文件都将以你在命令行上提供的 `atlas_name` 参数命名：
- en: The atlas index will be called `<atlas_name>.atlas`
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理图索引将被命名为 `<atlas_name>.atlas`
- en: Textures have an additional ordinal suffix—`<atlas_name>-0.png` (this one is
    always created), `<atlas_name>-1.png`, and so on
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理有一个额外的序号后缀——`<atlas_name>-0.png`（这个总是创建的），`<atlas_name>-1.png`，依此类推
- en: Atlas structure
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纹理图结构
- en: 'An index of any given atlas, `.atlas`, is basically a **JavaScript Object Notation**
    (**JSON**) file describing the positioning of individual textures on the map.
    Its contents look like the following (formatted for readability):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 任何给定纹理图的索引，`.atlas`，基本上是一个 **JavaScript 对象表示法**（**JSON**）文件，描述了单个纹理在图上的位置。其内容看起来如下（格式化以提高可读性）：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Textures are named after their corresponding source images, without an extension:
    a file `foo.png` becomes just `foo`. The numbers in each record describe a region
    of the large texture: `[x, y, width, height]`, where all values are in pixels.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理将以其对应的源图像命名，不带扩展名：一个 `foo.png` 文件将变成 `foo`。每个记录中的数字描述了大型纹理中的一个区域：`[x, y, width,
    height]`，其中所有值都是以像素为单位。
- en: A composite texture is about what you'd expect from a concatenation of images,
    as shown in the next figure. Usually, it will be tightly packed to efficiently
    utilize most of its area.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 合成纹理大致相当于从图像拼接中预期的效果，如下一图所示。通常，它会被紧密地打包以有效地利用大部分面积。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When creating an atlas, Kivy handles individual sprites' edges with precaution,
    accounting for possible rendering artifacts related to rounding. This is why one
    may notice extra pixels on the edges of a sprite. This effect isn't always visible,
    but when it is, don't worry—it's by design and serves a good cause.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建图集时，Kivy 会小心处理单个精灵的边缘，考虑到与舍入相关的可能渲染伪影。这就是为什么可能会注意到精灵边缘有额外的像素。这种效果并不总是可见的，但当它出现时，请不要担心——这是设计的一部分，并且有很好的原因。
- en: '![Atlas structure](img/B01620_09_09.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图集结构](img/B01620_09_09.jpg)'
- en: A texture atlas is merely a concatenation of smaller images
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理图集仅仅是较小图像的拼接
- en: 'Using atlases in regular Kivy-based code is as simple as replacing file paths
    with a special protocol, `atlas:` (conceptually similar to `http:`). As you''re
    already aware, the usual file reference in Kivy language looks similar to the
    next code snippet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规基于 Kivy 的代码中使用图集，就像用特殊协议 `atlas:`（在概念上类似于 `http:`）替换文件路径一样简单。正如你已经知道的，Kivy
    语言中的常规文件引用看起来类似于下面的代码片段：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'An atlas reference, however, will use the following notation:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，图集引用将使用以下标记：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Continue reading for a complete (albeit very simple) example of creating and
    using an atlas in a conventional Kivy app, a "hello world" of sorts.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 继续阅读以获取创建和使用传统 Kivy 应用中图集的完整（尽管非常简单）示例，这有点像“hello world”。
- en: Using Kivy atlases in an easy way
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以简单的方式使用 Kivy 图集
- en: 'For the purpose of this example, let''s borrow two icons from our previous
    projects and name them `icon_clock.png` and `icon_paint.png`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本例的目的，让我们从我们之前的两个项目中借用两个图标，并将它们命名为 `icon_clock.png` 和 `icon_paint.png`：
- en: '![Using Kivy atlases in an easy way](img/B01620_09_10.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![以简单的方式使用 Kivy 图集](img/B01620_09_10.jpg)'
- en: Individual icons used to craft a sample atlas
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 用于制作示例图集的单独图标
- en: 'To create an atlas, we crank open a terminal and issue the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建图集，我们打开终端并输入以下命令：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Remember to substitute the `kivy` command with `python` when not on a Mac. The
    `kivy.atlas` part, however, stays the same on all systems.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当不在 Mac 上时，将 `kivy` 命令替换为 `python`。然而，`kivy.atlas` 部分在所有系统上保持不变。
- en: 'The atlas utility should reply with something along the lines of the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图集实用工具应该会返回类似以下内容：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After a successful completion of the aforementioned command, a couple of new
    files—`icons.atlas` and `icons-0.png`—should have appeared in the same folder.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功完成上述命令后，应在同一文件夹中出现几个新文件——`icons.atlas` 和 `icons-0.png`。
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: At this point, it is safe to remove source images. It's advised that you still
    keep them around for the likely event that you'll need to rebuild the atlas later,
    for example, when adding new images or replacing existing ones.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，可以安全地删除源图像。建议你仍然保留它们，以防将来需要重建图集，例如，在添加新图像或替换现有图像时。
- en: The atlas is ready. As for the usage, we can create a simple demo app in a few
    lines of Python and the Kivy language.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图集已准备就绪。至于使用，我们可以在几行 Python 和 Kivy 语言中创建一个简单的演示应用。
- en: 'The Python source, `basic.py`, contains a barebones Kivy app:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Python 源文件 `basic.py` 包含一个基本的 Kivy 应用：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is very simple and exists for the sole purpose of (automatically) loading
    the layout, defined in the `basic.kv` file. The accompanying Kivy language file
    reads as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单，仅用于（自动）加载在 `basic.kv` 文件中定义的布局。伴随的 Kivy 语言文件内容如下：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This simple usage of an atlas results in the following layout, and it is pretty
    much what you''d expect from looking at the source code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的图集使用会产生以下布局，这基本上是你从源代码中看到的内容：
- en: '![Using Kivy atlases in an easy way](img/B01620_09_01.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![以简单的方式使用 Kivy 图集](img/B01620_09_01.jpg)'
- en: Basic usage of a Kivy atlas
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy 图集的基本用法
- en: As you can see, apart from the `atlas:` protocol described earlier, there is
    nothing new or intriguing in this example. So, let's move on to parsing texture
    atlases and their more advanced usage.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，除了前面描述的 `atlas:` 协议之外，这个例子中没有什么新或引人入胜的内容。所以，让我们继续解析纹理图集及其更高级的使用。
- en: Ad hoc usage of atlases with GLSL
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 GLSL 中使用图集的临时用法
- en: The built-in support for atlases in Kivy works just fine for simple cases, but
    not so much for our custom GLSL-based application, which manages all rendering,
    textures and whatnot, on its own.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy 内置对图集的支持对于简单情况来说效果很好，但对我们基于 GLSL 的自定义应用程序来说就不那么好了，该应用程序自行管理所有渲染、纹理等。
- en: Thankfully, the `.atlas` file format is JSON, which means we can easily parse
    it utilizing the `json` module from the Python standard library. Afterwards, we
    should be able to translate pixel coordinates given in the file to UV coordinates
    for use with OpenGL routines.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`.atlas` 文件格式是 JSON，这意味着我们可以轻松地使用 Python 标准库中的 `json` 模块来解析它。之后，我们应该能够将文件中给出的像素坐标转换为
    UV 坐标，以便用于 OpenGL 程序。
- en: Since we know the absolute size of each texture, we can also effortlessly compute
    the vertices' positions relative to center of each sprite. This facilitates easy
    rendering of sprites in their "original form", keeping both the size and the aspect
    ratio intact.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道每个纹理的绝对大小，我们也可以轻松地计算每个精灵相对于中心的顶点位置。这有助于轻松渲染精灵的“原始形式”，保持大小和宽高比不变。
- en: Data structure for UV mapping
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UV 映射的数据结构
- en: 'Put together, there are a lot of values per sprite. In order to keep things
    maintainable we can define a lightweight record type (a named tuple) to hold these
    together:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，每个精灵有很多值。为了保持可维护性，我们可以定义一个轻量级的记录类型（一个命名元组）来将这些值组合在一起：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you''re not familiar with named tuples in Python, from the user''s perspective
    this amounts to basically the following logic-less type, similar in concept to
    a `struct` compositional type in C:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉 Python 中的命名元组，从用户的角度来看，这基本上等同于以下无逻辑类型，在概念上类似于 C 中的 `struct` 组合类型：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that this code is purely illustrative, and the preceding `namedtuple()`
    definition does not actually expand to this—the user-facing interface, however,
    is similar.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这段代码纯粹是说明性的，前面的 `namedtuple()` 定义实际上并没有扩展到这一点——然而，用户界面与此相似。
- en: 'The meaning of each field is given in the following table:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字段的含义在以下表中给出：
- en: '| Field(s) | Description |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 描述 |'
- en: '| --- | --- |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `u0, v0` | UV coordinates of the sprite''s top-left corner |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `u0, v0` | 精灵左上角 UV 坐标 |'
- en: '| `u1, v1` | UV coordinates of the sprite''s bottom-right corner |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `u1, v1` | 精灵右下角 UV 坐标 |'
- en: '| `su` | Sprite width divided by 2; this value is useful when building an array
    of vertices |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `su` | 精灵宽度除以 2；这个值在构建顶点数组时很有用 |'
- en: '| `sv` | Sprite height divided by 2; this is similar to the previous field
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `sv` | 精灵高度除以 2；这与前面的字段类似 |'
- en: 'Named fields provide direct access to different values inside the record, which
    dramatically improves readability: `tup.v1` reads much better than `tup[3]`. At
    the same time, `UVMapping` is essentially a tuple, an immutable and memory-efficient
    data structure with all fields still accessible by index, should the need arise.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 命名字段提供了对记录内不同值的直接访问，这大大提高了可读性：`tup.v1` 比起 `tup[3]` 来说读起来要好得多。同时，`UVMapping`
    实质上是一个元组，一个不可变且内存高效的具有所有字段的数据结构，如果需要，可以通过索引访问。
- en: Writing an atlas loader
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写图集加载器
- en: 'Now, let''s write a function that makes happen everything that was discussed
    so far: JSON parsing, coordinates fixup, and so on. This function will also be
    used in the final program:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个函数来实现到目前为止所讨论的所有内容：JSON 解析、坐标修正等等。这个函数也将用于最终的程序：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Keep in mind that we''re supporting only the simplest case: an atlas with just
    one composite texture. This is probably the most useful configuration anyway,
    so this limitation shouldn''t affect our code in the slightest, especially since
    the atlas generation is completely under our control.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们只支持最简单的情况：只有一个复合纹理的图集。这可能是最有用的配置，所以这种限制对我们的代码几乎没有任何影响，尤其是考虑到图集生成完全在我们控制之下。
- en: We're reversing the ordinate axis since the coordinates are initially given
    in Kivy's coordinate system, and we're better off using the OpenGL's coordinate
    system with the origin at the top-left. Otherwise, sprites will be flipped upside
    down (which, by the way, isn't a problem for most sprites in our little game.
    This means that such bugs could have lived in the codebase for a long time—unnoticed
    and practically harmless).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在反转纵轴，因为坐标最初是在 Kivy 的坐标系中给出的，而使用以左上角为原点的 OpenGL 坐标系会更好。否则，精灵将会颠倒过来（顺便说一句，这对我们这个小游戏中的大多数精灵来说不是问题。这意味着这样的错误可能已经在代码库中存在很长时间了——未被发现且实际上无害）。
- en: 'The call to `load_atlas(''icons.atlas'')` returns both the composite texture
    loaded from `icons-0.png`, and the description of each texture included in the
    atlas:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`load_atlas(''icons.atlas'')` 调用返回从 `icons-0.png` 加载的复合纹理以及图集中包含的每个纹理的描述：'
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: (Numbers obviously may differ in your case.)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: (数字在你这里可能显然会有所不同。)
- en: This data format is sufficient to pick out individual sprites from the texture
    and render them on screen—and that's exactly what we'll do next.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数据格式足以从纹理中挑选出单个精灵并在屏幕上渲染——这正是我们接下来要做的。
- en: Rendering sprites from atlas
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从图集中渲染精灵
- en: Armed with the above function, let's hack together a variation of the previous
    demo that uses the same texture map with GLSL.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 带着上述函数，让我们修改之前的演示，使用相同的纹理图和 GLSL。
- en: 'The source code, `tex_atlas.py`, is conceptually similar to simple GLSL examples
    from [Chapter 8](ch08.html "Chapter 8. Introducing Shaders"), *Introducing Shaders*.
    It makes use of the `load_atlas()` function to populate the array of vertices:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码 `tex_atlas.py` 在概念上与第8章中的简单 GLSL 示例相似，*着色器介绍*。它使用 `load_atlas()` 函数来填充顶点数组：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The code essentially just copies the output data from `load_atlas()` to the
    `vertices` array, besides the usual GLSL initialization sequence. We pick two
    different records: `icon_clock` (stored as an `a` variable for brevity) and `icon_paint`
    (named `b`, similar to `a`), and then shove them into the array of vertices.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 代码本质上只是将 `load_atlas()` 函数的输出数据复制到 `vertices` 数组中，除了常规的 GLSL 初始化序列。我们选择了两个不同的记录：`icon_clock`（为了简洁存储为
    `a` 变量）和 `icon_paint`（命名为 `b`，与 `a` 类似），然后将它们推入顶点数组中。
- en: 'Our vertex format for this example is very minimal:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的顶点格式非常简单：
- en: '**vCenter**: This is the location of the sprite on the screen. It should be
    the same value for all vertices of a given sprite'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vCenter**：这是精灵在屏幕上的位置。对于给定精灵的所有顶点，这个值应该是相同的'
- en: '**vPosition**: This is the vertex position relative to the center of the sprite,
    unaffected by the previous value'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vPosition**：这是相对于精灵中心的顶点位置，不受之前值的影响'
- en: '**vTexCoords0**: This is the texture coordinates (UV) for each vertex. It determines
    which part of the large texture will be rendered.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vTexCoords0**：这是每个顶点的纹理坐标（UV）。它决定了将渲染大纹理的哪个部分。'
- en: From these, only the sprite location (first two columns of raw numbers in the
    listing) cannot be derived from the UV mapping; everything else comes from the
    `load_atlas()` call.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些中，只有精灵位置（列表中的前两列原始数字）不能从 UV 映射中推导出来；其他所有内容都来自 `load_atlas()` 调用。
- en: 'Here is the corresponding shader code, `tex_atlas.glsl`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相应的着色器代码，`tex_atlas.glsl`：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This has only the minimal capabilities—positioning and texturing—baked in. A
    similar shader will be used in the final game, with an addition of the relative
    sizing attribute, `vScale`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这只有最小的功能——定位和纹理——内置。最终游戏中将使用类似的着色器，并添加相对尺寸属性 `vScale`。
- en: Tip
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you don't understand what's going on in the shader code, go back to [Chapter
    8](ch08.html "Chapter 8. Introducing Shaders"), *Introducing Shaders:* it holds
    a number of examples that you may find relevant to the discussion at hand.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不懂着色器代码中的内容，请回到[第8章](ch08.html "第8章。着色器介绍")，*着色器介绍*：它包含了一些你可能认为与当前讨论相关的示例。
- en: 'The end result, however uninteresting it may look, is depicted here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的结果，尽管可能看起来不太有趣，在这里展示：
- en: '![Rendering sprites from atlas](img/B01620_09_02.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![从图集中渲染精灵](img/B01620_09_02.jpg)'
- en: Rendering sprites from the atlas using GLSL
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GLSL 从图集中渲染精灵
- en: With this, we can move on to the development of a generic sprite-based particle
    system that will, in its turn, serve as a foundation for all in-game objects.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以继续开发一个通用的基于精灵的粒子系统，它将反过来成为所有游戏对象的基础。
- en: Designing a reusable particle system
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计一个可重用的粒子系统
- en: In this section, we're going to write a particle system that will be later used
    to create pretty much everything in the game—spaceships, bullets, and so on. This
    is the generic approach used in situations where you have many similar objects
    on the screen with very little logic for movement and interaction.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个粒子系统，稍后它将被用来创建游戏中的几乎所有东西——宇宙飞船、子弹等等。这是在屏幕上有许多类似对象且运动和交互逻辑非常简单的情况下使用的通用方法。
- en: This topic will capitalize on the previous chapter's code. In fact, the starfield
    screensaver from the previous chapter as a whole is a fine example of a particle
    system; however, it lacks the necessary configurability and cannot be easily repurposed.
    We're going to change that without significantly altering the GLSL and related
    code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主题将利用前一章的代码。实际上，前一章的整体星系屏幕保护程序是一个很好的粒子系统示例；然而，它缺乏必要的可配置性，并且不能轻易地重新使用。我们将在不显著更改
    GLSL 和相关代码的情况下改变这一点。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's worth mentioning that the chosen approach—rendering textured quads for
    each particle—isn't the most optimal in terms of low-level rendering. On the plus
    side, it's very straightforward, easy to reason about, and compatible with any
    implementation of OpenGL that supports GLSL at all.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，所选的方法——为每个粒子渲染纹理四边形——在低级渲染方面并不是最优的。优点在于，它非常直接，易于推理，并且与任何支持GLSL的OpenGL实现兼容。
- en: If you choose to learn OpenGL more systematically, you will probably want to
    replace quads with point sprites or do something similar in concept; these enhancements
    are out of the scope of this book.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择更系统地学习OpenGL，你可能想用点精灵或类似的概念来替换四边形；这些增强功能超出了本书的范围。
- en: Class hierarchy
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类层次结构
- en: 'The API of our particle system will consist of two classes: `PSWidget`, which
    does all rendering, and a lightweight `Particle` class to represent individual
    particles.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的粒子系统API将包括两个类：`PSWidget`，负责所有渲染，以及一个轻量级的`Particle`类来表示单个粒子。
- en: 'These will be tightly coupled by design, which is usually frowned upon in terms
    of classical OOP, but improves performance considerably in our case: particles
    will access the vertices array in the renderer directly in order to alter the
    mesh—less copying in this case, taking into account that many particles will be
    active at the same time, can be a huge win.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类将按设计紧密耦合，这在经典面向对象编程中通常是不受欢迎的，但在此情况下可以显著提高性能：粒子将直接访问渲染器中的顶点数组以修改网格——考虑到许多粒子同时处于活动状态，减少复制可以带来巨大的优势。
- en: The implementation of the particle system widget isn't substantially different
    from other GLSL-based widgets we've seen so far, except for the fact that now
    it's meant to be subclassed for actual use. Both `PSWidget` and `Particle` are
    abstract base classes, that is, they cannot be instantiated directly by calling,
    for example, `PSWidget()`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统小部件的实现与其他我们迄今为止看到的基于GLSL的小部件没有实质性区别，除了现在它旨在被继承以供实际使用。`PSWidget`和`Particle`都是抽象基类，也就是说，不能通过调用例如`PSWidget()`等方式直接实例化。
- en: There are different ways to enforce this restriction. We could have used the
    `abc` module from the Python standard library in order to create *true* abstract
    base classes (`abc` actually stands for just that). While this may be deemed useful
    by Java programmers and the like, it's not the approach routinely taken by Python
    developers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方法来强制这种限制。我们可以使用Python标准库中的`abc`模块来创建真正的抽象基类（`abc`实际上就是指这个）。虽然这可能被认为对Java程序员等有用，但这并不是Python开发者通常采取的方法。
- en: For the sake of simplicity, we're going to write appropriate placeholders (stubs)
    raising `NotImplementedError` for all methods that require overriding. This will
    make the base class technically unusable without the use of metaclasses and complex
    inheritance, as the `abc` module suggests.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将编写适当的占位符（存根），对于所有需要重写的方法抛出`NotImplementedError`异常。这将使基类在未使用元类和复杂继承的情况下在技术上不可用，正如`abc`模块所建议的。
- en: The PSWidget renderer class
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PSWidget渲染器类
- en: 'Without further introduction, let''s take a look at the creation of `PSWidget`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 不再赘述，让我们看看`PSWidget`的创建：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is essentially the same familiar initialization we've seen in all GLSL
    examples, with some fields left undefined (they are borrowed from the subclass,
    which has to set these). The `self.glsl` property will hold the filename of the
    shader, and `self.atlas` is the filename of the texture map that will serve as
    the only source of textures for this renderer instance.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是我们已经在所有GLSL示例中看到的基本相同的初始化过程，只是有些字段留空（它们是从子类借用的，子类必须设置这些）。`self.glsl`属性将保存着色器的文件名，而`self.atlas`是纹理图的文件名，它将作为此渲染器实例的唯一纹理来源。
- en: 'Note how we don''t populate the vertices array here: this work is left for
    the subclass to do. We should, however, provide an easy way for descendant classes
    to work with our internal data structures. Hence, the following `PSWidget` method
    that makes it easy to add a large number of similar particles is used:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在这里没有填充顶点数组：这项工作留给子类来完成。然而，我们应该提供一个简单的方法，让子类能够与我们的内部数据结构一起工作。因此，以下`PSWidget`方法被用来轻松添加大量类似的粒子：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This instantiates the requested number of particles (`num`) of class `Cls`,
    adding them to the widget's `self.particles` list and populating `self.vertices`
    at the same time. Each particle type should expose a `tex_name` property that
    is used to look up the correct sprite in the UV mapping, the data structure derived
    earlier from the atlas (`PSWidget.uvmap`).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将实例化请求的`Cls`类粒子数量（`num`），将它们添加到部件的`self.particles`列表中，并同时在`self.vertices`中填充。每种粒子类型都应该公开一个`tex_name`属性，用于在UV映射中查找正确的精灵，该映射是从早期从图集（`PSWidget.uvmap`）派生出来的。
- en: Strictly speaking, this helper function is optional, but very useful. Calls
    to this method will be included in the initialization of the widget's concrete
    class before rendering.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，这个辅助函数是可选的，但非常有用。对这个方法的调用将在渲染之前包含在部件的具体类的初始化过程中。
- en: 'The last part of the widget base class is the rendering:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 部件基类的最后一部分是渲染：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Starting from the `canvas.clear()` call, this is just about the same code used
    in all GLSL-based examples. The beginning of the function is more interesting.
    We iterate through all particles and call two methods on each: the `advance()`
    method computes new state of the particle (it''s up to the particle to decide
    what this does, not necessarily resembling any visible change), and `update()`
    keeps the necessary data in the array of vertices in sync with the internal state,
    if any.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从`canvas.clear()`调用开始，这几乎与所有基于GLSL的示例中使用的代码相同。函数的开始部分更有趣。我们遍历所有粒子，并对每个粒子调用两个方法：`advance()`方法计算粒子的新状态（由粒子自己决定这样做，不一定类似于任何可见的变化），而`update()`方法则将必要的数据与顶点数组中的内部状态保持同步，如果有的话。
- en: Tip
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Such separation of concerns, while not ideal for performance, helps readability
    somewhat. When (if) optimizing, first consider the following points:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关注点的分离，虽然对性能不是最佳，但有助于提高可读性。当（如果）优化时，首先考虑以下要点：
- en: This loop can and should be parallelized, in full or partially
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个循环可以并且应该被并行化，全部或部分并行化。
- en: This code can also run on another thread completely, and not update every frame
    (again, this optimization may apply to selected classes of particles, for example,
    stuff in background that doesn't affect main program flow)
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码也可以在另一个线程中运行，并且不是每帧都更新（同样，这种优化可能适用于选定的粒子类，例如不影响主程序流程的背景内容）。
- en: These methods, along with other implementation details of particles, are described
    in the forthcoming sections.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法，以及粒子的其他实现细节，将在接下来的章节中描述。
- en: The Particle class
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粒子类
- en: 'In the following code we review yet another base class, `Particle`, that represents
    individual sprites. It resembles the `Star` class from the starfield project,
    sans the logic for movement (this will be implemented later by subclasses):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们回顾了另一个基类，`Particle`，它代表单个精灵。它类似于星系项目中的`Star`类，但没有运动逻辑（这将在后续的子类中实现）：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Storing a reference to the *parent* `PSWidget` in the constructor allows us
    to interface with it later on. This primarily happens in the `update()` method,
    also shown in the previous listing—it makes changes to all four vertices of a
    polygon to keep those in sync with the particle's desired location and scale (`x`,
    `y`, and `size` properties).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中存储对`*parent*` `PSWidget`的引用，允许我们在以后与之交互。这主要发生在`update()`方法中，如前一个列表所示——它改变多边形的四个顶点，以保持它们与粒子期望的位置和缩放（`x`、`y`和`size`属性）同步。
- en: There is at least one method in this new class that wasn't present in the `Star`
    class, namely, `advance()`. This one has to be overridden, since there's no default
    behavior for advancing the scene. It's up to a particle to decide how it should
    change with time. As you will see shortly, particle systems can be used to create
    substantially different effects.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新类中至少有一个方法在`Star`类中不存在，即`advance()`方法。由于没有默认的推进场景行为，这个方法必须被重写。粒子决定如何随时间变化。正如你很快就会看到的，粒子系统可以用来创建显著不同的效果。
- en: The `reset()` method is called to reinitialize a particle that ended its life
    cycle (for example, has left the screen or exhausted its TTL). It's highly particle
    system-specific, but generally any such system has some notion of a particle being
    restored to a blank or randomized initial state. Again, there is no clever default
    behavior we could invoke here, so there's only a stub in place.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`reset()`方法重新初始化结束其生命周期（例如，已离开屏幕或耗尽其TTL）的粒子。这非常特定于粒子系统，但通常任何这样的系统都有一种将粒子恢复到空白或随机初始状态的概念。再次强调，这里没有我们可以调用的任何巧妙默认行为，所以这里只有一个占位符。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Raising `NotImplementedError` from a virtual method is a way to inform the developer
    that it would be nice to define this method on a derived class. We could have
    omitted the last two methods altogether, but that would lead to a less relevant
    error, `AttributeError`. Preserving method signatures, even in the absence of
    a default implementation, is also nice and reduces guesswork for your peers (or
    your future self, should you revisit the same code after a long delay).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从虚拟方法中引发`NotImplementedError`是一种通知开发者最好在派生类中定义此方法的方式。我们本可以完全省略最后两个方法，但这会导致一个不那么相关的错误，`AttributeError`。即使在没有默认实现的情况下，保留方法签名也是很好的，并且可以减少你的同伴（或者你未来的自己，如果你在长时间之后重新访问相同的代码）的猜测工作。
- en: The idea behind the new keyword argument, `created`, which is passed to `reset()`,
    is simple. Some particle systems may need an additional (or merely different)
    initialization routine when particles first spawn. A good example of such behavior
    is the new starfield (we will get to it shortly), where stars spawn on the right-hand
    side of the screen. If we don't account for the *just created* state, then all
    stars will indeed appear on the rightmost edge of the screen with the same `x`
    coordinate and thus form a straight line. This graphical glitch is clearly undesirable,
    so we fully randomize the location of stars if `created` is set to `True`, which
    gives us nice initial distribution.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 新关键字参数`created`背后的想法，它传递给`reset()`，很简单。一些粒子系统在粒子首次生成时可能需要额外的（或仅仅是不同的）初始化程序。这种行为的良好例子是新的星系（我们很快就会介绍），星星在屏幕的右侧生成。如果我们不考虑*刚刚创建*的状态，那么所有的星星确实会出现在屏幕的最右侧，具有相同的`x`坐标，从而形成一条直线。这种图形错误显然是不希望的，因此如果将`created`设置为`True`，我们将完全随机化星星的位置，从而得到良好的初始分布。
- en: Calls to `reset()` will clearly mean subsequent respawning of particles much
    more often than the first-time initialization, so the `created` flag defaults
    to `False`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`reset()`将明确表示粒子的后续重生比首次初始化更为频繁，因此`created`标志默认为`False`。
- en: We're pretty much done with the base classes at this point. As you will see
    shortly, the implementation of the game itself becomes very straightforward as
    soon as *hard* technical details are abstracted out. For the rest of the chapter,
    we'll employ particle system basics outlined here in creative ways to build various
    stuff, from background to interactive in-game objects such as bullets.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了基本类的设计。正如你很快就会看到的，一旦将*技术细节*抽象出来，游戏本身的实现就变得非常直接。在接下来的章节中，我们将以这里概述的粒子系统基础知识为基础，以创新的方式构建各种东西，从背景到交互式游戏对象，如子弹。
- en: Writing the game
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写游戏
- en: 'Our application is structured around building blocks described earlier: our
    root widget is a `PSWidget` subclass called `Game` and all in-game entities will
    derive from the `Particle` class.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序结构围绕前面描述的构建块：我们的根小部件是一个名为`Game`的`PSWidget`子类，所有游戏中的实体都将从`Particle`类派生。
- en: 'Here is the short and sweet base application:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是简洁的基础应用程序：
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following are the details about external files referenced here:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这里引用的外部文件的详细信息：
- en: The `game.glsl` shader file is the same as `starfield.glsl` from the previous
    chapter
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`game.glsl`着色器文件与上一章中的`starfield.glsl`相同'
- en: 'The `game.atlas` texture map hosts the following textures:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`game.atlas`纹理图包含以下纹理：'
- en: '`star`: This texture resembles a star, similar to the one we''ve used in the
    previous project'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`star`：这种纹理类似于我们之前项目中使用的星星'
- en: '`player`: This is a spaceship facing to the right (in the general direction
    of movement)'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`player`：这是一个面向右侧（即运动的一般方向）的宇宙飞船'
- en: '`trail`: This is a *fireball* (a single particle of flame) emitted from ship''s
    rocket engine'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trail`：这是从飞船火箭发动机发射出的*火球*（单个火焰粒子）'
- en: '`bullet`: This is a projectile spawned by ship''s imaginary frontal cannon'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bullet`：这是由飞船想象中的前方加农炮发射出的投射物'
- en: '`ufo`: This is an alien saucer, facing to the left (and moving against the
    current)'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ufo`：这是一个面向左侧（并且逆流而行）的外星飞碟'
- en: The previous code renders nothing on screen yet, since we haven't populated
    the vertices array. Let's start from the background and implement the stars first.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码在屏幕上还没有渲染任何内容，因为我们还没有填充顶点数组。让我们从背景开始，首先实现星星。
- en: Implementing stars
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现星星
- en: Once again we build a simple star-field. This time it scrolls right-to-left
    to imitate movement, similar in concept to the Kivy Bird game that we built earlier.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次构建一个简单的星系。这次它从右向左滚动以模仿运动，在概念上类似于我们之前构建的Kivy Bird游戏。
- en: To create a simple parallax effect (just like in Kivy Bird), we assign stars
    to three planes and then set their size and speed to match. Stars on a plane with
    a greater number are bigger and move faster than those from a lesser plane. The
    moment a star goes off the screen, it's reborn at random position on a random
    plane.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个简单的视差效果（就像在Kivy Bird中一样），我们将星星分配到三个平面上，然后设置它们的大小和速度以匹配。位于更高编号平面的星星比位于较低平面的星星更大，移动速度也更快。当一颗星星离开屏幕时，它会在随机位置和随机平面上重生。
- en: 'Let''s review the particle system code implementing the new and improved starfield:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下实现新改进星域的粒子系统代码：
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `tex_name` property is required and refers to a texture inside `game.atlas`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`tex_name`属性是必需的，它指的是`game.atlas`内部的纹理。'
- en: Resetting randomizes a star's plane and position, depending on whether the method
    was called during the initialization (`created=True`) or not; the rationale for
    this was described earlier.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 重置会随机化一颗星球的平面和位置，这取决于该方法是否在初始化（`created=True`）期间被调用；这一做法的合理性已在之前描述。
- en: 'The last method, `advance()`, is simple: move the sprite to the left until
    it''s out of screen, and then reset it.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方法`advance()`很简单：将精灵向左移动，直到它离开屏幕，然后重置它。
- en: 'In order to put our new particle system to use, we need to add a number of
    stars using the `make_particles()` helper from `PSWidget`. This happens in `Game.initialize()`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用我们新的粒子系统，我们需要使用来自`PSWidget`的`make_particles()`辅助函数添加一些星星。这发生在`Game.initialize()`中：
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, some visible fruits of our labor:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们劳动的一些可见成果：
- en: '![Implementing stars](img/B01620_09_04.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![实现星星](img/B01620_09_04.jpg)'
- en: The starfield, revisited
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 再次审视星域
- en: Making a spaceship
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作宇宙飞船
- en: We need exactly one spaceship at all times (since we're building a single-player
    game), which means that the implementation will be a degenerate case of a particle
    system having just one particle. This is done for the sake of unification with
    the rest of the code. There is nothing we could gain by architecting this particular
    object differently.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们始终需要一艘宇宙飞船（因为我们正在构建单人游戏），这意味着实现将是一个退化情况，即粒子系统只有一个粒子。这样做是为了与代码的其他部分统一。我们无法通过以不同的方式设计这个特定的对象来获得任何好处。
- en: 'The player''s spacecraft will be glued to the pointer location at all times.
    To achieve this effect, we store the position of the pointer in a pair of `Game`
    properties, namely `player_x` and `player_y`, and then put the spaceship sprite
    at those coordinates when updating the scene. To save the pointer location, we
    can use the following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家的宇宙飞船将始终固定在指针位置。为了实现这种效果，我们存储指针的位置在一个名为`Game`属性的`player_x`和`player_y`对中，然后在更新场景时将宇宙飞船精灵放置在这些坐标上。为了保存指针位置，我们可以使用以下代码：
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since the spaceship is under player''s complete control, there is no other
    logic that we could implement in the particle class—apart from just moving the
    sprite to the last pointer position accordingly:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于宇宙飞船完全在玩家的控制之下，我们无法在粒子类中实现其他逻辑——除了将精灵移动到最后的指针位置：
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, `reset()` and `advance()` methods are the same. There is just
    about nothing else we can do.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`reset()`和`advance()`方法是一样的。我们几乎没有什么其他可以做的事情。
- en: 'Don''t forget to actually spawn a particle of this type:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记实际产生这种类型的粒子：
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The end result so far resembles a lone spacecraft in the middle of an endless
    void:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，最终结果类似于无尽空虚中孤独的宇宙飞船：
- en: '![Making a spaceship](img/B01620_09_05.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![制作宇宙飞船](img/B01620_09_05.jpg)'
- en: The spaceship follows the mouse, putting the user in direct control
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 宇宙飞船跟随鼠标，使用户直接控制
- en: Creating a trail of fire
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建火焰尾迹
- en: 'Every respectable spacecraft in a sci-fi setting is followed by a flaming trail.
    Particles composing such a trail use the following algorithm:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在科幻设定中，每一艘值得尊敬的宇宙飞船后面都会有一道火焰尾迹。构成这种尾迹的粒子使用以下算法：
- en: A particle spawns near the engine, its size randomized. The size of the particle
    is also its **time to live** (**TTL**).
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在发动机附近产生一个粒子，其大小是随机的。粒子的尺寸也是其**存活时间**（**TTL**）。
- en: It then travels away from the spacecraft at a constant speed, shrinking in size
    while doing so.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它以恒定的速度从宇宙飞船上远离，在移动的过程中尺寸缩小。
- en: Particles that have shrunk to about 10 percent of the normal size are reset
    and begin their journey anew.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当粒子缩小到正常大小的约10%时，它们会被重置并重新开始它们的旅程。
- en: Given many particles, this effect may look nice in motion. Sadly, screenshots
    cannot convey the dynamics, so be sure to run the example code to get a better
    impression.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 给定许多粒子，这种效果在运动中可能看起来很漂亮。遗憾的是，截图无法传达动态效果，所以请确保运行示例代码以获得更好的印象。
- en: 'Long story short, the particle system implementation is given as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，粒子系统的实现如下：
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This implements the aforementioned algorithm quite literally, while relying
    on the same `player_x` and `player_y` properties to determine the current position
    of the ship.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这直接实现了之前提到的算法，同时依赖于相同的`player_x`和`player_y`属性来确定飞船的当前位置。
- en: 'As mentioned earlier, we should assign many particles to the effect so that
    it looks good:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们应该为效果分配许多粒子，以便看起来更好：
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is the screenshot of the result:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果的截图：
- en: '![Creating a trail of fire](img/B01620_09_06.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![创建火焰轨迹](img/B01620_09_06.jpg)'
- en: 'Fire burning in vacuum: looks neat while not making a case for realism'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 真空中燃烧的火焰：看起来很整洁，但并不支持现实主义
- en: The last two particle systems that remain unimplemented, namely enemies and
    bullets, are different. Unlike other classes of particles we've seen previously,
    where all instances are being displayed simultaneously at any given time, neither
    bullets nor enemies spawn all at once; both wait for a special event to occur
    and then increase the *population* of objects by one, firing a bullet or spawning
    a single enemy.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个尚未实现的粒子系统，即敌人和子弹，是不同的。与之前我们看到的其他粒子类别不同，其中所有实例在任何给定时间都会同时显示，子弹和敌人不会一次性全部生成；两者都等待一个特殊事件发生，然后通过发射一颗子弹或生成一个单个敌人来增加对象的数量。
- en: Nevertheless, we want to allocate a fixed number of such particles in advance,
    because growing and shrinking the array of vertices unnecessarily complicates
    the code and is not desirable.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们希望在事先分配一定数量的此类粒子，因为无谓地增长和缩小顶点数组会使代码变得复杂，并且不可取。
- en: The catch is to add a new Boolean field to a particle to signify whether it's
    active (shown on screen) or not, and then *activate* such particles on demand.
    This approach will be demonstrated shortly.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是要给粒子添加一个新的布尔字段，以表示它是否处于活动状态（显示在屏幕上）或不是，然后根据需要激活这样的粒子。这种方法将很快演示。
- en: Making bullets
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作子弹
- en: 'We want our ship''s cannon to fire while we''re holding a mouse button or touching
    the screen continuously. This setup is easy to implement using the newly added
    `firing` property to denote that the trigger is being pulled:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在我们持续按住鼠标按钮或触摸屏幕时，我们的船的炮塔能够开火。使用新添加的`firing`属性来表示触发器被拉动，这种设置很容易实现：
- en: '[PRE26]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To add a brief delay between shots, we introduce yet another property, `fire_delay`.
    This variable decreases each frame until it reaches zero, then a new bullet spawns
    and `fire_delay` is incremented. The cycle continues while `firing` is `True`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在射击之间添加短暂的延迟，我们引入了另一个属性，`fire_delay`。这个变量每帧都会减少，直到达到零，然后生成一颗新的子弹，并将`fire_delay`增加。当`firing`为`True`时，这个循环会继续：
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let''s see the aforementioned active state of a particle. Initially, all
    bullets are inactive (that is, `active=False`) and removed from the screen (the
    coordinates `x=-100`, `y=-100` are set for the bullets, which effectively prevents
    them from rendering). The code is as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看之前提到的粒子的活动状态。最初，所有子弹都是非活动的（即`active=False`），并且从屏幕上移除（子弹的坐标设置为`x=-100`，`y=-100`，这实际上阻止了它们渲染）。代码如下：
- en: '[PRE28]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When looping over bullets, we skip those that are inactive, unless `firing_delay`
    has reached zero. In this case, we activate one bullet and put it in front of
    the player, bumping the `firing_delay` variable to reset the countdown.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当遍历子弹时，我们会跳过那些非活动的子弹，除非`fire_delay`达到零。在这种情况下，我们会激活一颗子弹，并将其放在玩家前面，将`fire_delay`变量重置以重置倒计时。
- en: 'Active bullets move just like stars, albeit in the opposite direction. Unlike
    stars, bullets that go off screen don''t auto-respawn. They return to the inactive
    pool instead, vanishing from view. The code is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 活跃的子弹移动方式就像星星一样，尽管方向相反。与星星不同，离屏的子弹不会自动重生。它们会回到非活动池中，从视野中消失。代码如下：
- en: '[PRE29]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `fire_delay` property set to one-third of a second, which obviously leads
    to an average rate of automatic fire of three **rounds per second** (**RPS**).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`fire_delay`属性设置为三分之一秒，这显然会导致平均自动射击速率为每秒三**发**（**RPS**）。'
- en: '![Making bullets](img/B01620_09_07.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![制作子弹](img/B01620_09_07.jpg)'
- en: A spacecraft with guns blazing
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 火力全开的宇宙飞船
- en: Implementing enemies
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现敌人
- en: 'Enemies are conceptually similar to bullets, but since they spawn continuously,
    we don''t need a flag such as `firing`—a `spawn_delay` property is sufficient.
    This is, by the way, the final evolution of the `update_glsl()` method:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人在概念上与子弹相似，但由于它们会持续生成，我们不需要像`firing`这样的标志——一个`spawn_delay`属性就足够了。顺便说一句，这是`update_glsl()`方法的最终演变：
- en: '[PRE30]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'During the initialization, we create a predefined number of enemies, initially
    inactive. In order to implement collision detection with bullets later on, we
    also store a list of bullets (a slice of the `Game.particles` list) separately:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化过程中，我们创建了一个预定义数量的敌人，最初是处于非活动状态的。为了稍后实现与子弹的碰撞检测，我们还单独存储了一个子弹列表（`Game.particles`列表的切片）：
- en: '[PRE31]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The corresponding particle class will be the most complex so far, mainly because
    of the more involved movement pattern. In addition to a constant movement speed
    along the `x` axis, each enemy also features randomized vertical movement vector,
    `v`. When a particle of this type is about to leave the screen from the top or
    bottom edge, the particle's `v` property changes its sign accordingly, reflecting
    the enemy back into the visible screen space.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的粒子类将是迄今为止最复杂的，主要是因为更复杂的移动模式。除了沿`x`轴的恒定移动速度外，每个敌人还有一个随机的垂直移动向量`v`。当一个此类粒子即将从顶部或底部边缘离开屏幕时，粒子的`v`属性会相应地改变符号，将敌人反射回可见屏幕空间。
- en: 'Other rules are similar to how bullets work: when an enemy reaches the opposite
    edge of the screen, it resets and effectively disappears until spawned again.
    The code is as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 其他规则与子弹的工作方式相似：当敌人到达屏幕的对面边缘时，它会重置并实际上消失，直到再次生成。代码如下：
- en: '[PRE32]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This listing may appear relatively long but the algorithm is actually pretty
    simple to grasp:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表可能看起来相对较长，但实际上算法非常简单易懂：
- en: Check whether we're hit by a bullet and reset (see the next section).
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查我们是否被子弹击中并重置（见下一节）。
- en: Move horizontally, check whether we have left the view, and reset.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 水平移动，检查我们是否离开了视图，并重置。
- en: Move vertically, check whether we're leaving the view, and change the vector
    sign.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垂直移动，检查我们是否要离开视图，并改变向量符号。
- en: Spawn another enemy if `spawn_delay` has ended and bump `spawn_delay`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`spawn_delay`结束，则生成另一个敌人并增加`spawn_delay`。
- en: Collision detection
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: 'Another interesting aspect of the `Enemy` class that we haven''t seen before
    is the `check_hit()` method. There are two things enemies can collide with: the
    player''s spaceship and bullets. For the sake of simplicity, let''s say that the
    protagonist is invincible and the collision simply destroys the enemy; a colliding
    bullet, however, also despawns. The code is as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enemy`类另一个我们之前没有见过的有趣方面是`check_hit()`方法。敌人可以与两种东西发生碰撞：玩家的宇宙飞船和子弹。为了简单起见，让我们说主角是无敌的，碰撞只会摧毁敌人；然而，一个碰撞的子弹也会消失。代码如下：'
- en: '[PRE33]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This collision detection routine is as simple as possible: `math.hypot()` merely
    computes distance between center points, so we assume that all objects are approximately
    round for the purpose of this check. We also don''t try to collide with inactive
    bullets for obvious reasons—logically inactive entities don''t exist and physically
    they are located outside the visible screen space anyway. So, they probably don''t
    collide with objects on screen.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这个碰撞检测例程尽可能简单：`math.hypot()`仅计算中心点之间的距离，因此我们假设所有对象在这个检查中都是近似圆形的。我们也尝试不与非活动子弹发生碰撞，这是显而易见的——逻辑上非活动实体不存在，而且它们在物理上位于可见屏幕空间之外。所以，它们可能不会与屏幕上的对象发生碰撞。
- en: This concludes the first (barely) playable version of the game.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着游戏的第一个（勉强）可玩版本。
- en: '![Collision detection](img/B01620_09_08.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞检测](img/B01620_09_08.jpg)'
- en: Enemies sighted
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 发现敌人
- en: Finishing touches
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完善细节
- en: There are many areas where this game can and should be improved, particularly
    in terms of gameplay. It goes without saying that this prototype, as it stands,
    isn't marketable.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏可以在很多方面进行改进，尤其是在游戏玩法方面。不言而喻，这个原型目前不具备市场价值。
- en: 'Some suggestions for *homework*, should you be interested in working on this
    project further, are listed here:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对进一步开发这个项目感兴趣，以下是一些*家庭作业*的建议：
- en: First of all, the game needs a "game over" state, badly. Winning is optional,
    but losing is a must; otherwise, it's just not competitive at all, like an interactive
    screensaver.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，这个游戏迫切需要一个“游戏结束”状态。胜利是可选的，但失败是必须的；否则，它根本不具备竞争性，就像一个互动式屏保。
- en: 'Another obvious improvement is adding content—diversity is king. More enemies,
    more attack patterns, and probably the ability for selected enemies to shoot back
    at player. A progressive increase in difficulty level goes in the same bucket:
    later stages of the game should bring bigger waves of enemies, faster spawn times,
    and so on.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个明显的改进是添加内容——多样性是王道。更多的敌人，更多的攻击模式，以及可能让选定的敌人能够向玩家射击的能力。难度级别的逐步提高也属于同一范畴：游戏的后期阶段应该带来更大的敌人浪潮，更快的生成时间等等。
- en: Adding sound effects is probably the simplest enhancement. Refer to [Chapter
    7](ch07.html "Chapter 7. Writing a Flappy Bird Clone"), *Writing a Flappy Bird
    Clone*, for details. The same `MultiAudio` class can be trivially reused in this
    project too. Alternatively, take a look at the sample code accompanying this chapter.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加音效可能是最简单的增强。有关详细信息，请参阅[第7章](ch07.html "第7章。编写Flappy Bird克隆")，*编写Flappy Bird克隆*。相同的`MultiAudio`类也可以在这个项目中轻松重用。或者，您可以查看本章附带的示例代码。
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The main point of this chapter is that a particle system can be used for vastly
    different things. Perhaps this is not the most stunningly clever idea you've heard
    today, so let's instead summarize the main points of the whole book, regardless
    of small implementation details.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要观点是粒子系统可以用于非常不同的用途。也许这并不是你今天听到的最令人惊叹的聪明想法，所以我们还是来总结一下整本书的主要观点，不管是一些小的实现细节。
- en: 'In this lengthy write-up, we barely scratched the surface of what can be easily
    done with Python and Kivy. The realm of possibilities is vast and diverse:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇冗长的文章中，我们仅仅触及了使用Python和Kivy可以轻松完成的表面功夫。可能性的领域是广阔且多样化的：
- en: Utility apps for desktop and mobile
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桌面和移动端的实用应用程序
- en: Applications for content creation, be it a graphical or text editor, possibly
    even a sound synthesizer
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容创建的应用，无论是图形或文本编辑器，甚至可能是声音合成器
- en: Networked apps used for chatting, other ways of social networking, and remote
    control programs
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于聊天的网络应用程序，其他社交网络方式，以及远程控制程序
- en: Video games
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频游戏
- en: 'Over the course of this book, we also highlighted some useful principles of
    working with any new technology efficiently:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的过程中，我们也强调了与任何新技术高效合作的一些有用原则：
- en: Apply your experience from other problem domains, such as web development. Kivy
    is different, but it's not that much different; many approaches are actually reusable
    between substantially different environments.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您在其他问题领域（如Web开发）的经验应用到Kivy中。Kivy是不同的，但也不是那么不同；许多方法实际上可以在很大程度上不同的环境中重用。
- en: Attempt to understand what's happening behind the scenes. Understanding the
    inner workings of the framework will help immensely when debugging.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试理解幕后发生的事情。理解框架的内部工作原理将有助于调试。
- en: Related to the previous point, if docs are missing or unclear, read the source
    code. It's Python after all, so naturally it's very readable.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与前一点相关，如果文档缺失或不清楚，请阅读源代码。毕竟，它是Python，所以自然是非常易读的。
- en: Don't hesitate to search the Web for solutions to problems and topics of interest.
    More often than not, someone already had this problem and found a workaround.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要犹豫，在网络上搜索解决问题的方案和对感兴趣的主题进行搜索。很多时候，别人已经遇到过这个问题并找到了解决方案。
- en: All in all, I sincerely hope you enjoyed the ride. If you have any questions
    or want to discuss something, by all means contact me at `<[mvasilkov@gmail.com](mailto:mvasilkov@gmail.com)>`
    (and expect excruciatingly slow replies!).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我真诚地希望您享受了这次旅程。如果您有任何问题或想要讨论某些事情，请随时通过以下邮箱联系我 `<[mvasilkov@gmail.com](mailto:mvasilkov@gmail.com)>`（并期待极其缓慢的回复！）。
