<html><head></head><body>
  <div class="Basic-Text-Frame" id="_idContainer166">
   <h1 class="chapterNumber">
    <span class="koboSpan" id="kobo.1.1">
     10
    </span>
   </h1>
   <h1 class="chapterTitle" id="_idParaDest-268">
    <span class="koboSpan" id="kobo.2.1">
     Testing
    </span>
   </h1>
   <blockquote class="packt_quote">
    <p class="quote">
     <span class="koboSpan" id="kobo.3.1">
      ”Just as the wise accepts gold after testing it by heating, cutting, and rubbing it, so are my words to be accepted after examining them, but not out of respect for me.”
     </span>
    </p>
    <p class="cite">
     <span class="koboSpan" id="kobo.4.1">
      – Buddha
     </span>
    </p>
   </blockquote>
   <p class="normal">
    <span class="koboSpan" id="kobo.5.1">
     We love this quote by the Buddha.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     Within the software world, it translates perfectly into the healthy habit of never trusting code just because someone smart wrote it or because it has been working fine for a long time.
    </span>
    <span class="koboSpan" id="kobo.5.3">
     If it has not been tested, the code is not to be trusted.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.6.1">
     Why are tests so important?
    </span>
    <span class="koboSpan" id="kobo.6.2">
     Well, for one, they give you predictability.
    </span>
    <span class="koboSpan" id="kobo.6.3">
     Or, at least, they help you achieve high predictability.
    </span>
    <span class="koboSpan" id="kobo.6.4">
     Unfortunately, there is always some bug that sneaks into the code.
    </span>
    <span class="koboSpan" id="kobo.6.5">
     But we want our code to be as predictable as possible.
    </span>
    <span class="koboSpan" id="kobo.6.6">
     What we do not want is to have a surprise; in other words, our code behaving in an unpredictable way.
    </span>
    <span class="koboSpan" id="kobo.6.7">
     Unpredictability in software that checks the sensors of a plane, a train, or a nuclear power plant can lead to disastrous situations.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.7.1">
     We need to test our code; we need to check that its behavior is correct, that it works as expected when it deals with edge cases, that it does not hang when the components it is talking to are broken or unreachable, that the performance is well within the acceptable range, and so on.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.8.1">
     This chapter is all about that—making sure that your code is prepared to face the scary outside world, that it is fast enough, and that it can deal with unexpected or exceptional conditions.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.9.1">
     In this chapter, we are going to explore the following topics:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.10.1">
      General testing guidelines
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.11.1">
      Unit testing
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.12.1">
      A brief mention of
     </span>
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.13.1">
       test-driven development
      </span>
     </strong>
     <span class="koboSpan" id="kobo.14.1">
      (
     </span>
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.15.1">
       TDD
      </span>
     </strong>
     <span class="koboSpan" id="kobo.16.1">
      )
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.17.1">
     Let us start by understanding what testing is.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-269">
    <span class="koboSpan" id="kobo.18.1">
     Testing your application
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.19.1">
     There are many kinds of tests; so many, in
    </span>
    <a id="_idIndexMarker900">
    </a>
    <span class="koboSpan" id="kobo.20.1">
     fact, that companies often have a dedicated department, called
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.21.1">
      quality assurance
     </span>
    </strong>
    <span class="koboSpan" id="kobo.22.1">
     (
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.23.1">
      QA
     </span>
    </strong>
    <span class="koboSpan" id="kobo.24.1">
     ), made up of individuals whose job is to test the software the
    </span>
    <a id="_idIndexMarker901">
    </a>
    <span class="koboSpan" id="kobo.25.1">
     company developers produce.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.26.1">
     To start making an
    </span>
    <a id="_idIndexMarker902">
    </a>
    <span class="koboSpan" id="kobo.27.1">
     initial classification, we
    </span>
    <a id="_idIndexMarker903">
    </a>
    <span class="koboSpan" id="kobo.28.1">
     can divide tests into two broad
    </span>
    <a id="_idIndexMarker904">
    </a>
    <span class="koboSpan" id="kobo.29.1">
     categories:
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.30.1">
      white-box
     </span>
    </strong>
    <span class="koboSpan" id="kobo.31.1">
     and
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.32.1">
      black-box
     </span>
    </strong>
    <span class="koboSpan" id="kobo.33.1">
     tests.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.34.1">
     White-box tests
    </span>
    <a id="_idIndexMarker905">
    </a>
    <span class="koboSpan" id="kobo.35.1">
     are those that exercise the internals of the code; they inspect it down to a fine level of detail.
    </span>
    <span class="koboSpan" id="kobo.35.2">
     On the other hand, black-box tests are those that consider the software under test as if within a box, the internals of which are ignored.
    </span>
    <span class="koboSpan" id="kobo.35.3">
     Even the technology, or the language used inside the box, is not important for black-box tests.
    </span>
    <span class="koboSpan" id="kobo.35.4">
     What they do is plug some input into one end of the box and verify the output at the other end—that’s it.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.36.1">
      There is also an in-between
     </span>
     <a id="_idIndexMarker906">
     </a>
     <span class="koboSpan" id="kobo.37.1">
      category called
     </span>
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.38.1">
       gray-box
      </span>
     </strong>
     <span class="koboSpan" id="kobo.39.1">
      testing, which involves
     </span>
     <a id="_idIndexMarker907">
     </a>
     <span class="koboSpan" id="kobo.40.1">
      testing a system in the same way we do with the black-box approach, but having some knowledge about the algorithms and data structures used to write the software and only partial access to its source code.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.41.1">
     There are many kinds of tests in these categories, each of which serves a different purpose.
    </span>
    <span class="koboSpan" id="kobo.41.2">
     To give you an idea, here are a few:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.42.1">
       Frontend tests
      </span>
     </strong>
     <span class="koboSpan" id="kobo.43.1">
      : They make
     </span>
     <a id="_idIndexMarker908">
     </a>
     <span class="koboSpan" id="kobo.44.1">
      sure that the client side of your application is exposing
     </span>
     <a id="_idIndexMarker909">
     </a>
     <span class="koboSpan" id="kobo.45.1">
      the information that it should, all the links, the buttons, the advertising, and everything that needs to be shown to the client.
     </span>
     <span class="koboSpan" id="kobo.45.2">
      They may also verify that it is possible to walk a certain path through the
     </span>
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.46.1">
       user interface
      </span>
     </strong>
     <span class="koboSpan" id="kobo.47.1">
      (
     </span>
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.48.1">
       UI
      </span>
     </strong>
     <span class="koboSpan" id="kobo.49.1">
      ).
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.50.1">
       Scenario tests
      </span>
     </strong>
     <span class="koboSpan" id="kobo.51.1">
      : They make use
     </span>
     <a id="_idIndexMarker910">
     </a>
     <span class="koboSpan" id="kobo.52.1">
      of stories (or scenarios) that help the tester work through
     </span>
     <a id="_idIndexMarker911">
     </a>
     <span class="koboSpan" id="kobo.53.1">
      a complex problem or test a part of the system.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.54.1">
       Integration tests
      </span>
     </strong>
     <span class="koboSpan" id="kobo.55.1">
      : They verify
     </span>
     <a id="_idIndexMarker912">
     </a>
     <span class="koboSpan" id="kobo.56.1">
      the behavior of the various components of
     </span>
     <a id="_idIndexMarker913">
     </a>
     <span class="koboSpan" id="kobo.57.1">
      your application when they are working together and sending messages through interfaces.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.58.1">
       Smoke tests
      </span>
     </strong>
     <span class="koboSpan" id="kobo.59.1">
      : Particularly
     </span>
     <a id="_idIndexMarker914">
     </a>
     <span class="koboSpan" id="kobo.60.1">
      useful when you deploy a new update on your
     </span>
     <a id="_idIndexMarker915">
     </a>
     <span class="koboSpan" id="kobo.61.1">
      application, they check whether the most essential, vital parts of your application are still working as they should and that they are not
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.62.1">
       on fire
      </span>
     </em>
     <span class="koboSpan" id="kobo.63.1">
      .
     </span>
     <span class="koboSpan" id="kobo.63.2">
      This term comes from when engineers tested circuits by making sure nothing was smoking.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.64.1">
       Acceptance tests
      </span>
     </strong>
     <span class="koboSpan" id="kobo.65.1">
      , or
     </span>
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.66.1">
       user acceptance testing
      </span>
     </strong>
     <span class="koboSpan" id="kobo.67.1">
      (
     </span>
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.68.1">
       UAT
      </span>
     </strong>
     <span class="koboSpan" id="kobo.69.1">
      ): What a developer does with a product
     </span>
     <a id="_idIndexMarker916">
     </a>
     <span class="koboSpan" id="kobo.70.1">
      owner (for example, in a SCRUM environment) to
     </span>
     <a id="_idIndexMarker917">
     </a>
     <span class="koboSpan" id="kobo.71.1">
      determine whether the work that was
     </span>
     <a id="_idIndexMarker918">
     </a>
     <span class="koboSpan" id="kobo.72.1">
      commissioned was
     </span>
     <a id="_idIndexMarker919">
     </a>
     <span class="koboSpan" id="kobo.73.1">
      carried out correctly.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.74.1">
       Functional tests
      </span>
     </strong>
     <span class="koboSpan" id="kobo.75.1">
      : They verify the
     </span>
     <a id="_idIndexMarker920">
     </a>
     <span class="koboSpan" id="kobo.76.1">
      features or functionalities of your
     </span>
     <a id="_idIndexMarker921">
     </a>
     <span class="koboSpan" id="kobo.77.1">
      software.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.78.1">
       Destructive tests
      </span>
     </strong>
     <span class="koboSpan" id="kobo.79.1">
      : They take
     </span>
     <a id="_idIndexMarker922">
     </a>
     <span class="koboSpan" id="kobo.80.1">
      down parts of your system, simulating a failure, to
     </span>
     <a id="_idIndexMarker923">
     </a>
     <span class="koboSpan" id="kobo.81.1">
      establish how well the remaining parts of the system perform.
     </span>
     <span class="koboSpan" id="kobo.81.2">
      This kind of test is performed extensively by companies that need to provide a highly reliable service.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.82.1">
       Performance tests
      </span>
     </strong>
     <span class="koboSpan" id="kobo.83.1">
      : They aim to
     </span>
     <a id="_idIndexMarker924">
     </a>
     <span class="koboSpan" id="kobo.84.1">
      verify how well the system performs under a specific load of data or traffic so that, for example, engineers can get a better
     </span>
     <a id="_idIndexMarker925">
     </a>
     <span class="koboSpan" id="kobo.85.1">
      understanding of the bottlenecks in the system that could bring it to its knees in a heavy-load situation, or those that prevent scalability.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.86.1">
       Usability tests
      </span>
     </strong>
     <span class="koboSpan" id="kobo.87.1">
      , and the
     </span>
     <a id="_idIndexMarker926">
     </a>
     <span class="koboSpan" id="kobo.88.1">
      closely related
     </span>
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.89.1">
       user experience
      </span>
     </strong>
     <span class="koboSpan" id="kobo.90.1">
      (
     </span>
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.91.1">
       UX
      </span>
     </strong>
     <span class="koboSpan" id="kobo.92.1">
      )
     </span>
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.93.1">
       tests
      </span>
     </strong>
     <span class="koboSpan" id="kobo.94.1">
      : They aim to check
     </span>
     <a id="_idIndexMarker927">
     </a>
     <span class="koboSpan" id="kobo.95.1">
      whether the UI is simple and easy to
     </span>
     <a id="_idIndexMarker928">
     </a>
     <span class="koboSpan" id="kobo.96.1">
      understand and use.
     </span>
     <span class="koboSpan" id="kobo.96.2">
      They also
     </span>
     <a id="_idIndexMarker929">
     </a>
     <span class="koboSpan" id="kobo.97.1">
      aim to provide input to the designers so that the UX is improved.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.98.1">
       Security and penetration tests
      </span>
     </strong>
     <span class="koboSpan" id="kobo.99.1">
      : They aim to
     </span>
     <a id="_idIndexMarker930">
     </a>
     <span class="koboSpan" id="kobo.100.1">
      verify how well the system is protected against
     </span>
     <a id="_idIndexMarker931">
     </a>
     <span class="koboSpan" id="kobo.101.1">
      attacks and intrusions.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.102.1">
       Unit tests
      </span>
     </strong>
     <span class="koboSpan" id="kobo.103.1">
      : They help the
     </span>
     <a id="_idIndexMarker932">
     </a>
     <span class="koboSpan" id="kobo.104.1">
      developer write the code in a robust and consistent way, providing
     </span>
     <a id="_idIndexMarker933">
     </a>
     <span class="koboSpan" id="kobo.105.1">
      the first line of feedback and defense against coding mistakes, refactoring mistakes, and so on.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.106.1">
       Regression tests
      </span>
     </strong>
     <span class="koboSpan" id="kobo.107.1">
      : They provide the
     </span>
     <a id="_idIndexMarker934">
     </a>
     <span class="koboSpan" id="kobo.108.1">
      developer with useful information about a
     </span>
     <a id="_idIndexMarker935">
     </a>
     <span class="koboSpan" id="kobo.109.1">
      feature being compromised in the system after an update.
     </span>
     <span class="koboSpan" id="kobo.109.2">
      Some of the causes for a system being said to have a regression are an old bug resurfacing, an existing feature being compromised, or a new issue being introduced.
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.110.1">
     Many books and articles have been written about testing, and we have to point you to those resources if you are interested in finding out more about all the different kinds of tests.
    </span>
    <span class="koboSpan" id="kobo.110.2">
     In this chapter, we will concentrate on unit tests, since they are the backbone of software crafting and form the vast majority of tests that are written by a developer.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.111.1">
     Testing is an
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.112.1">
      art
     </span>
    </em>
    <span class="koboSpan" id="kobo.113.1">
     , an art that you do not learn from books, unfortunately.
    </span>
    <span class="koboSpan" id="kobo.113.2">
     You can learn all the definitions (and you should) and try to collect as much knowledge about testing as you can, but you will likely be able to test your software properly only when you have accumulated enough experience.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.114.1">
     When you are having trouble refactoring a bit of code because every little thing you touch makes a test blow up, you learn how to write less rigid and limiting tests that still verify the correctness of your code but, at the same time, allow you the freedom and joy to play with it, to shape it as you want.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.115.1">
     When you are being called too often to fix unexpected bugs in your code, you learn how to write tests more thoroughly, how to come up with a more comprehensive list of edge cases, and strategies to cope with them before they turn into bugs.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.116.1">
     When you are spending too much time reading tests and trying to refactor them to change a small feature in the code, you learn to write simpler, shorter, and better-focused tests.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.117.1">
     We could go on with this
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.118.1">
      when you...
     </span>
     <span class="koboSpan" id="kobo.118.2">
      you learn...
     </span>
    </em>
    <span class="koboSpan" id="kobo.119.1">
     , but we guess you get the picture.
    </span>
    <span class="koboSpan" id="kobo.119.2">
     You need to apply yourself and build experience.
    </span>
    <span class="koboSpan" id="kobo.119.3">
     Our suggestion?
    </span>
    <span class="koboSpan" id="kobo.119.4">
     Study the theory as much as you can, and then experiment using different approaches.
    </span>
    <span class="koboSpan" id="kobo.119.5">
     Also, try to learn from experienced coders; it is very effective.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.120.1">
     Ideally, the more experienced you become, the more you should feel that source code and unit tests are not two separate things.
    </span>
    <span class="koboSpan" id="kobo.120.2">
     Tests are not optional.
    </span>
    <span class="koboSpan" id="kobo.120.3">
     They are intimately connected to the code.
    </span>
    <span class="koboSpan" id="kobo.120.4">
     Source code and unit tests mutually influence each other.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-270">
    <span class="koboSpan" id="kobo.121.1">
     The anatomy of a test
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.122.1">
     Before we concentrate on unit tests, let us see what a test is, and what its purpose is.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.123.1">
     A
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.124.1">
      test
     </span>
    </strong>
    <span class="koboSpan" id="kobo.125.1">
     is a piece of
    </span>
    <a id="_idIndexMarker936">
    </a>
    <span class="koboSpan" id="kobo.126.1">
     code whose purpose is to verify something in our system.
    </span>
    <span class="koboSpan" id="kobo.126.2">
     It may be that we are calling a function passing two integers, that an object has a property called
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.127.1">
      donald_duck
     </span>
    </code>
    <span class="koboSpan" id="kobo.128.1">
     , or that when you place an order on some
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.129.1">
      application programming interface
     </span>
    </strong>
    <span class="koboSpan" id="kobo.130.1">
     (
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.131.1">
      API
     </span>
    </strong>
    <span class="koboSpan" id="kobo.132.1">
     ), after a
    </span>
    <a id="_idIndexMarker937">
    </a>
    <span class="koboSpan" id="kobo.133.1">
     minute you can see it dissected into its basic elements in the database.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.134.1">
     A test is typically composed of three sections:
    </span>
   </p>
   <ol>
    <li class="numberedList" value="1">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.135.1">
       Preparation
      </span>
     </strong>
     <span class="koboSpan" id="kobo.136.1">
      : This
     </span>
     <a id="_idIndexMarker938">
     </a>
     <span class="koboSpan" id="kobo.137.1">
      is where we set up the scene.
     </span>
     <span class="koboSpan" id="kobo.137.2">
      We prepare all the data, the objects, and the services we need in the places we need them so that they are ready to be used.
     </span>
    </li>
    <li class="numberedList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.138.1">
       Execution
      </span>
     </strong>
     <span class="koboSpan" id="kobo.139.1">
      : This is
     </span>
     <a id="_idIndexMarker939">
     </a>
     <span class="koboSpan" id="kobo.140.1">
      where we execute the bit of logic that is under testing.
     </span>
     <span class="koboSpan" id="kobo.140.2">
      We perform an action using the data and the interfaces we set up in the preparation phase.
     </span>
    </li>
    <li class="numberedList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.141.1">
       Verification
      </span>
     </strong>
     <span class="koboSpan" id="kobo.142.1">
      : This is
     </span>
     <a id="_idIndexMarker940">
     </a>
     <span class="koboSpan" id="kobo.143.1">
      where we verify the results and make sure they are according to our expectations.
     </span>
     <span class="koboSpan" id="kobo.143.2">
      We check the returned value of a function, or that some data is in the database, some is not, some has changed, an HTTP request has been made, something has happened, a method has been called, and so on.
     </span>
    </li>
   </ol>
   <p class="normal">
    <span class="koboSpan" id="kobo.144.1">
     While tests usually follow this structure, in a test suite, you will typically find some other constructs that take part in the testing process:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.145.1">
       Setup
      </span>
     </strong>
     <span class="koboSpan" id="kobo.146.1">
      : This is
     </span>
     <a id="_idIndexMarker941">
     </a>
     <span class="koboSpan" id="kobo.147.1">
      something quite commonly found in several tests.
     </span>
     <span class="koboSpan" id="kobo.147.2">
      It is logic that can be customized to run for every test, class, module, or even for a whole session.
     </span>
     <span class="koboSpan" id="kobo.147.3">
      In this phase, developers usually set up connections to databases, populate them with data that will be needed there for the test to make sense, and so on.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.148.1">
       Teardown
      </span>
     </strong>
     <span class="koboSpan" id="kobo.149.1">
      : This is the
     </span>
     <a id="_idIndexMarker942">
     </a>
     <span class="koboSpan" id="kobo.150.1">
      opposite of the setup; the teardown phase takes place after the tests have run.
     </span>
     <span class="koboSpan" id="kobo.150.2">
      Like the setup, it can be customized to run for every test, class, module, or session.
     </span>
     <span class="koboSpan" id="kobo.150.3">
      Typically, in this phase, we destroy any artifacts that were created for the test suite and clean up after ourselves.
     </span>
     <span class="koboSpan" id="kobo.150.4">
      This is important because we do not want to have any lingering objects around and because it helps to make sure that each test starts from a clean slate.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.151.1">
       Fixtures
      </span>
     </strong>
     <span class="koboSpan" id="kobo.152.1">
      : These are
     </span>
     <a id="_idIndexMarker943">
     </a>
     <span class="koboSpan" id="kobo.153.1">
      pieces of data used in the tests.
     </span>
     <span class="koboSpan" id="kobo.153.2">
      By using a specific set of fixtures, outcomes are predictable and therefore tests can perform verifications against them.
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.154.1">
     In this chapter, we will use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.155.1">
      pytest
     </span>
    </code>
    <span class="koboSpan" id="kobo.156.1">
     Python library.
    </span>
    <span class="koboSpan" id="kobo.156.2">
     It is a powerful tool that makes testing easier than it would be if
    </span>
    <a id="_idIndexMarker944">
    </a>
    <span class="koboSpan" id="kobo.157.1">
     we only used standard library tools.
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.158.1">
      pytest
     </span>
    </code>
    <span class="koboSpan" id="kobo.159.1">
     provides plenty of helpers so that the test logic can focus more on the actual testing than the wiring and boilerplate around it.
    </span>
    <span class="koboSpan" id="kobo.159.2">
     You will see, when we get to the code, that one of the characteristics of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.160.1">
      pytest
     </span>
    </code>
    <span class="koboSpan" id="kobo.161.1">
     is that fixtures, setup, and teardown often blend into one.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-271">
    <span class="koboSpan" id="kobo.162.1">
     Testing guidelines
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.163.1">
     Like software, tests can be good or bad, with a
    </span>
    <a id="_idIndexMarker945">
    </a>
    <span class="koboSpan" id="kobo.164.1">
     whole range of shades in the middle.
    </span>
    <span class="koboSpan" id="kobo.164.2">
     To write good tests, here are some guidelines:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.165.1">
       Keep them as simple as possible
      </span>
     </strong>
     <span class="koboSpan" id="kobo.166.1">
      : It is okay to violate some good coding rules, such as hardcoding values or duplicating code.
     </span>
     <span class="koboSpan" id="kobo.166.2">
      Tests need, first and foremost, to be as readable as possible and easy to understand.
     </span>
     <span class="koboSpan" id="kobo.166.3">
      When tests are hard to read or understand, we can never be confident they are actually making sure our code is performing correctly.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.167.1">
       Tests should verify one thing and one thing only
      </span>
     </strong>
     <span class="koboSpan" id="kobo.168.1">
      : It is important that we keep them short and contained.
     </span>
     <span class="koboSpan" id="kobo.168.2">
      It is perfectly fine to write multiple tests to exercise a single object or function.
     </span>
     <span class="koboSpan" id="kobo.168.3">
      We just need to make sure that each test has one and only one purpose.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.169.1">
       Tests should not make any unnecessary assumptions
      </span>
     </strong>
     <span class="koboSpan" id="kobo.170.1">
      : This may be tricky to understand at first, but it is important.
     </span>
     <span class="koboSpan" id="kobo.170.2">
      Verifying that the result of a function call is
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.171.1">
       [1, 2, 3]
      </span>
     </code>
     <span class="koboSpan" id="kobo.172.1">
      is not the same as saying the output is a list that contains the numbers 1, 2, and 3.
     </span>
     <span class="koboSpan" id="kobo.172.2">
      In the former, we are also assuming the ordering; in the latter, we are only assuming which items are in the list.
     </span>
     <span class="koboSpan" id="kobo.172.3">
      The differences sometimes are quite subtle, but they are still important.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.173.1">
       Tests should exercise the “what,” rather than the “how”
      </span>
     </strong>
     <span class="koboSpan" id="kobo.174.1">
      : Tests should focus on checking
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.175.1">
       what
      </span>
     </em>
     <span class="koboSpan" id="kobo.176.1">
      a function is supposed to do, rather than
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.177.1">
       how
      </span>
     </em>
     <span class="koboSpan" id="kobo.178.1">
      it is doing it.
     </span>
     <span class="koboSpan" id="kobo.178.2">
      For example, focus on the fact that a function is calculating the square root of a number (the
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.179.1">
       what
      </span>
     </em>
     <span class="koboSpan" id="kobo.180.1">
      ), instead of the fact that it is calling
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.181.1">
       math.sqrt()
      </span>
     </code>
     <span class="koboSpan" id="kobo.182.1">
      to do it (the
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.183.1">
       how
      </span>
     </em>
     <span class="koboSpan" id="kobo.184.1">
      ).
     </span>
     <span class="koboSpan" id="kobo.184.2">
      Unless we are writing performance tests or we have a particular need to verify how a certain action is performed, we ought to try to avoid this type of testing and focus on the
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.185.1">
       what
      </span>
     </em>
     <span class="koboSpan" id="kobo.186.1">
      .
     </span>
     <span class="koboSpan" id="kobo.186.2">
      Testing the
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.187.1">
       how
      </span>
     </em>
     <span class="koboSpan" id="kobo.188.1">
      leads to restrictive tests and makes refactoring hard.
     </span>
     <span class="koboSpan" id="kobo.188.2">
      Moreover, the type of test we have to write when we concentrate on the
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.189.1">
       how
      </span>
     </em>
     <span class="koboSpan" id="kobo.190.1">
      is more likely to degrade the quality of our testing codebase when we amend the software frequently.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.191.1">
       Tests should use the minimal set of fixtures needed to do the job
      </span>
     </strong>
     <span class="koboSpan" id="kobo.192.1">
      : This is another crucial point.
     </span>
     <span class="koboSpan" id="kobo.192.2">
      Fixtures tend to grow over time.
     </span>
     <span class="koboSpan" id="kobo.192.3">
      They also tend to change every now and then.
     </span>
     <span class="koboSpan" id="kobo.192.4">
      If we use many fixtures and ignore redundancies in the tests, refactoring will take longer.
     </span>
     <span class="koboSpan" id="kobo.192.5">
      Spotting bugs will be harder.
     </span>
     <span class="koboSpan" id="kobo.192.6">
      We ought to try to use a set of fixtures that is big enough for the test to perform correctly, but not any bigger.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.193.1">
       Tests should use as few resources as possible
      </span>
     </strong>
     <span class="koboSpan" id="kobo.194.1">
      : The reason for this is that every developer who checks out our code should be able to run the tests, no matter how powerful their machine is.
     </span>
     <span class="koboSpan" id="kobo.194.2">
      It could be a skinny virtual machine or a CircleCI setup; tests should run without chewing up too many resources.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.195.1">
       Tests should run as fast as possible
      </span>
     </strong>
     <span class="koboSpan" id="kobo.196.1">
      : A good test codebase could end up being much longer than the code being tested itself.
     </span>
     <span class="koboSpan" id="kobo.196.2">
      It varies according to the situation and the developer, but, whatever the length, we will end up having hundreds, if not thousands, of tests to run, which means the faster they run, the faster we can get back to writing code.
     </span>
     <span class="koboSpan" id="kobo.196.3">
      When using
     </span>
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.197.1">
       TDD
      </span>
     </strong>
     <span class="koboSpan" id="kobo.198.1">
      , for example, we run
     </span>
     <a id="_idIndexMarker946">
     </a>
     <span class="koboSpan" id="kobo.199.1">
      tests very often, so speed is essential.
     </span>
     <div class="note">
      <p class="normal">
       <strong class="keyWord">
        <span class="koboSpan" id="kobo.200.1">
         CircleCI
        </span>
       </strong>
       <span class="koboSpan" id="kobo.201.1">
        is
       </span>
       <a id="_idIndexMarker947">
       </a>
       <span class="koboSpan" id="kobo.202.1">
        one of the largest
       </span>
       <strong class="keyWord">
        <span class="koboSpan" id="kobo.203.1">
         continuous integration/continuous delivery
        </span>
       </strong>
       <span class="koboSpan" id="kobo.204.1">
        (
       </span>
       <strong class="keyWord">
        <span class="koboSpan" id="kobo.205.1">
         CI/CD)
        </span>
       </strong>
       <span class="koboSpan" id="kobo.206.1">
        platforms available
       </span>
       <a id="_idIndexMarker948">
       </a>
       <span class="koboSpan" id="kobo.207.1">
        today.
       </span>
       <span class="koboSpan" id="kobo.207.2">
        It is easy to integrate with services like GitHub, for example.
       </span>
       <span class="koboSpan" id="kobo.207.3">
        You just need to add some configuration (typically in the form of a file) in the source code, and CircleCI will run tests when the new code is prepared to be merged into the current codebase.
       </span>
      </p>
     </div>
    </li>
   </ul>
   <h2 class="heading-2" id="_idParaDest-272">
    <span class="koboSpan" id="kobo.208.1">
     Unit testing
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.209.1">
     Now that we have an idea about what testing is and why we need it, let us introduce the developer’s best
    </span>
    <a id="_idIndexMarker949">
    </a>
    <span class="koboSpan" id="kobo.210.1">
     friend: the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.211.1">
      unit test
     </span>
    </strong>
    <span class="koboSpan" id="kobo.212.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.213.1">
     Before we proceed with the examples, allow us to share some words of caution: we will try to give you the fundamentals about unit testing, but we do not follow any particular school of thought or methodology to the letter.
    </span>
    <span class="koboSpan" id="kobo.213.2">
     Over the years, we have tried many different testing approaches, eventually coming up with our own way of doing things, which is constantly
    </span>
    <a id="_idIndexMarker950">
    </a>
    <span class="koboSpan" id="kobo.214.1">
     evolving.
    </span>
    <span class="koboSpan" id="kobo.214.2">
     To put it as Bruce Lee would have:
    </span>
   </p>
   <p class="quote">
    <span class="koboSpan" id="kobo.215.1">
     Absorb what is useful, discard what is useless, and add what is specifically your own.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-273">
    <span class="koboSpan" id="kobo.216.1">
     Writing a unit test
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.217.1">
     Unit tests take
    </span>
    <a id="_idIndexMarker951">
    </a>
    <span class="koboSpan" id="kobo.218.1">
     their name from the fact that they are used to test small units of code.
    </span>
    <span class="koboSpan" id="kobo.218.2">
     To explain how to write a unit test, let us look at a simple snippet:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.219.1"># data.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.220.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.221.1">get_clean_data</span></span><span class="koboSpan" id="kobo.222.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.223.1">source</span></span><span class="koboSpan" id="kobo.224.1">):
    data = load_data(source)
    cleaned_data = clean_data(data)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.225.1">return</span></span><span class="koboSpan" id="kobo.226.1"> cleaned_data
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.227.1">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.228.1">
      get_clean_data()
     </span>
    </code>
    <span class="koboSpan" id="kobo.229.1">
     function is responsible for getting data from
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.230.1">
      source
     </span>
    </code>
    <span class="koboSpan" id="kobo.231.1">
     , cleaning it, and returning it to the caller.
    </span>
    <span class="koboSpan" id="kobo.231.2">
     How do we test this function?
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.232.1">
     One way of doing this is to call it and then make sure that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.233.1">
      load_data()
     </span>
    </code>
    <span class="koboSpan" id="kobo.234.1">
     was called once with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.235.1">
      source
     </span>
    </code>
    <span class="koboSpan" id="kobo.236.1">
     as its only argument.
    </span>
    <span class="koboSpan" id="kobo.236.2">
     Then, we need to verify that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.237.1">
      clean_data()
     </span>
    </code>
    <span class="koboSpan" id="kobo.238.1">
     was called once, with the return value of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.239.1">
      load_data()
     </span>
    </code>
    <span class="koboSpan" id="kobo.240.1">
     .
    </span>
    <span class="koboSpan" id="kobo.240.2">
     Finally, we would need to make sure that the return value of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.241.1">
      clean_data()
     </span>
    </code>
    <span class="koboSpan" id="kobo.242.1">
     is what is returned by the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.243.1">
      get_clean_data()
     </span>
    </code>
    <span class="koboSpan" id="kobo.244.1">
     function as well.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.245.1">
     To do this, we need to set up the source and run this code, and this may be a problem.
    </span>
    <span class="koboSpan" id="kobo.245.2">
     One of the golden rules of unit testing is that
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.246.1">
      anything that crosses the boundaries of your application needs to be simulated
     </span>
    </em>
    <span class="koboSpan" id="kobo.247.1">
     .
    </span>
    <span class="koboSpan" id="kobo.247.2">
     We do not want to talk to a real data source, and we do not want to actually run real functions if they are communicating with anything that is not contained in our application.
    </span>
    <span class="koboSpan" id="kobo.247.3">
     A few examples would be a database, a search service, an external API, or the filesystem.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.248.1">
     We need these restrictions to act as a shield so that we can always run our tests safely without the fear of destroying something in a real data source.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.249.1">
     Another reason is that it may be quite difficult for a developer to reproduce the whole architecture on their machine.
    </span>
    <span class="koboSpan" id="kobo.249.2">
     It may require the setting up of databases, APIs, services, files and folders, and so on, and this can be difficult, time-consuming, or sometimes not even possible.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.250.1">
      Very simply put, an
     </span>
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.251.1">
       API
      </span>
     </strong>
     <span class="koboSpan" id="kobo.252.1">
      is a
     </span>
     <a id="_idIndexMarker952">
     </a>
     <span class="koboSpan" id="kobo.253.1">
      set of tools for building software applications.
     </span>
     <span class="koboSpan" id="kobo.253.2">
      An API expresses a software component in terms of its operations, input and output, and underlying types.
     </span>
     <span class="koboSpan" id="kobo.253.3">
      For example, if you create software that needs to interface with a data provider service, it is likely that you will have to go through their API in order to gain access to the data.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.254.1">
     Therefore, in our
    </span>
    <a id="_idIndexMarker953">
    </a>
    <span class="koboSpan" id="kobo.255.1">
     unit tests, we need to simulate all those things in some way.
    </span>
    <span class="koboSpan" id="kobo.255.2">
     Unit tests need to be run by any developer without the need for the entire system to be set up on their machine.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.256.1">
     A different approach, which we favor when it is possible to do so, is to simulate entities not by using fake objects but by using special-purpose test objects instead.
    </span>
    <span class="koboSpan" id="kobo.256.2">
     For example, if our code talks to a database, instead of faking all the functions and methods that talk to the database and programming the fake objects so that they return what the real ones would, we would rather spawn a test database, set up the tables and data we need, and then patch the connection settings so that our tests are running real code against the test database.
    </span>
    <span class="koboSpan" id="kobo.256.3">
     This is advantageous because if the underlying libraries change in a way that introduces an issue in our code, this setup will catch this issue.
    </span>
    <span class="koboSpan" id="kobo.256.4">
     A test will break.
    </span>
    <span class="koboSpan" id="kobo.256.5">
     A test with mocks, on the other hand, will blissfully continue to run successfully, because the mocked interface would have no idea about the change in the underlying library.
    </span>
    <span class="koboSpan" id="kobo.256.6">
     In-memory databases are excellent options for these cases.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.257.1">
      One of the applications that allows you to spawn a database for testing is Django.
     </span>
     <span class="koboSpan" id="kobo.257.2">
      Within the
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.258.1">
       django.test
      </span>
     </code>
     <span class="koboSpan" id="kobo.259.1">
      package, you can find several tools that help you write tests so that you won’t have to simulate the dialog with a database.
     </span>
     <span class="koboSpan" id="kobo.259.2">
      By writing tests this way, you will also be able to check on transactions, encodings, and all other database-related aspects of programming.
     </span>
     <span class="koboSpan" id="kobo.259.3">
      Another advantage of this approach consists of the ability to check against details that can change from one database to another.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.260.1">
     Sometimes, though, it is still not possible.
    </span>
    <span class="koboSpan" id="kobo.260.2">
     For example, when the software interfaces with an API, and there is no test version of that API, we would need to simulate that API using fakes.
    </span>
    <span class="koboSpan" id="kobo.260.3">
     In reality, most of the time we end up having to use a hybrid approach, where we use a test version of those technologies that allow this approach, and we use fakes for everything else.
    </span>
    <span class="koboSpan" id="kobo.260.4">
     Let us now talk about fakes.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-274">
    <span class="koboSpan" id="kobo.261.1">
     Mock objects and patching
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.262.1">
     First of all, in Python, these fake objects are
    </span>
    <a id="_idIndexMarker954">
    </a>
    <span class="koboSpan" id="kobo.263.1">
     called
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.264.1">
      mocks
     </span>
    </strong>
    <span class="koboSpan" id="kobo.265.1">
     .
    </span>
    <span class="koboSpan" id="kobo.265.2">
     Up to version 3.3, the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.266.1">
      mock
     </span>
    </code>
    <span class="koboSpan" id="kobo.267.1">
     library
    </span>
    <a id="_idIndexMarker955">
    </a>
    <span class="koboSpan" id="kobo.268.1">
     was a third-party library that basically every project would install via pip but, from version 3.3, it has been included in the standard library under the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.269.1">
      unittest
     </span>
    </code>
    <span class="koboSpan" id="kobo.270.1">
     module, and rightfully so, given its importance and how widespread it is.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.271.1">
     The act of replacing a
    </span>
    <a id="_idIndexMarker956">
    </a>
    <span class="koboSpan" id="kobo.272.1">
     real object or function (or in general, any piece of data structure) with a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.273.1">
      mock
     </span>
    </code>
    <span class="koboSpan" id="kobo.274.1">
     is called
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.275.1">
      patching
     </span>
    </strong>
    <span class="koboSpan" id="kobo.276.1">
     .
    </span>
    <span class="koboSpan" id="kobo.276.2">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.277.1">
      mock
     </span>
    </code>
    <span class="koboSpan" id="kobo.278.1">
     library provides the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.279.1">
      patch
     </span>
    </code>
    <span class="koboSpan" id="kobo.280.1">
     tool, which can act as a function or class decorator, and even as a context manager that you can use to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.281.1">
      mock
     </span>
    </code>
    <span class="koboSpan" id="kobo.282.1">
     things out.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-275">
    <span class="koboSpan" id="kobo.283.1">
     Assertions
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.284.1">
     The verification phase is done through the use
    </span>
    <a id="_idIndexMarker957">
    </a>
    <span class="koboSpan" id="kobo.285.1">
     of assertions.
    </span>
    <span class="koboSpan" id="kobo.285.2">
     In most cases, an
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.286.1">
      assertion
     </span>
    </strong>
    <span class="koboSpan" id="kobo.287.1">
     is a function or method that you can use to verify equality between objects, as well as other conditions.
    </span>
    <span class="koboSpan" id="kobo.287.2">
     When a condition is not met, the assertion will raise an exception that will cause the test to fail.
    </span>
    <span class="koboSpan" id="kobo.287.3">
     You can find a list of assertions in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.288.1">
      unittest
     </span>
    </code>
    <span class="koboSpan" id="kobo.289.1">
     module documentation; however, when using
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.290.1">
      pytest
     </span>
    </code>
    <span class="koboSpan" id="kobo.291.1">
     , you will typically use the generic
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.292.1">
      assert
     </span>
    </code>
    <span class="koboSpan" id="kobo.293.1">
     statement, which makes things even simpler.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-276">
    <span class="koboSpan" id="kobo.294.1">
     Testing a CSV generator
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.295.1">
     Let us now adopt a practical
    </span>
    <a id="_idIndexMarker958">
    </a>
    <span class="koboSpan" id="kobo.296.1">
     approach.
    </span>
    <span class="koboSpan" id="kobo.296.2">
     We will show you how to test a small piece of code, and we will touch on the rest of the important concepts around unit testing within the context of this example.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.297.1">
     We want to write an
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.298.1">
      export()
     </span>
    </code>
    <span class="koboSpan" id="kobo.299.1">
     function that does the following: it takes a list of dictionaries, each of which represents a user.
    </span>
    <span class="koboSpan" id="kobo.299.2">
     It creates a
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.300.1">
      comma-separated values
     </span>
    </strong>
    <span class="koboSpan" id="kobo.301.1">
     (
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.302.1">
      CSV
     </span>
    </strong>
    <span class="koboSpan" id="kobo.303.1">
     ) file, puts a header
    </span>
    <a id="_idIndexMarker959">
    </a>
    <span class="koboSpan" id="kobo.304.1">
     in it, and then proceeds to add all the users who are deemed valid according to some rules.
    </span>
    <span class="koboSpan" id="kobo.304.2">
     The function will take three parameters: the list of user dictionaries, the name of the CSV file to create, and an indication of whether an existing file with the same name should be overwritten.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.305.1">
     To be considered
    </span>
    <a id="_idIndexMarker960">
    </a>
    <span class="koboSpan" id="kobo.306.1">
     valid, and added to the output file, a user dictionary must satisfy the following requirements: each user must have at least an email, a name, and an age.
    </span>
    <span class="koboSpan" id="kobo.306.2">
     There can also be a fourth field representing the role, but it is optional.
    </span>
    <span class="koboSpan" id="kobo.306.3">
     The user’s email address needs to be valid, the name needs to be non-empty, and the age must be an integer between 18 and 65.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.307.1">
     This is our task; so, now we are going to show you the code, and then we are going to analyze the tests we wrote for it.
    </span>
    <span class="koboSpan" id="kobo.307.2">
     But, first things first, in the following code snippets, we will be using two third-party libraries:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.308.1">
      marshmallow
     </span>
    </code>
    <span class="koboSpan" id="kobo.309.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.310.1">
      pytest
     </span>
    </code>
    <span class="koboSpan" id="kobo.311.1">
     .
    </span>
    <span class="koboSpan" id="kobo.311.2">
     They are both in the requirements of the chapter’s source code, so please make sure you have installed them with pip.
    </span>
   </p>
   <p class="normal">
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.312.1">
      marshmallow
     </span>
    </code>
    <span class="koboSpan" id="kobo.313.1">
     (
    </span>
    <a href="https://marshmallow.readthedocs.io/">
     <span class="url">
      <span class="koboSpan" id="kobo.314.1">
       https://marshmallow.readthedocs.io/
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.315.1">
     ) is a library that provides us with the ability to
    </span>
    <a id="_idIndexMarker961">
    </a>
    <span class="koboSpan" id="kobo.316.1">
     serialize (or
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.317.1">
      dump
     </span>
    </em>
    <span class="koboSpan" id="kobo.318.1">
     , in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.319.1">
      marshmallow
     </span>
    </code>
    <span class="koboSpan" id="kobo.320.1">
     terminology) and deserialize (or
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.321.1">
      load
     </span>
    </em>
    <span class="koboSpan" id="kobo.322.1">
     , in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.323.1">
      marshmallow
     </span>
    </code>
    <span class="koboSpan" id="kobo.324.1">
     terminology) objects and, most importantly, gives us the ability to define a schema that we can use to validate a user dictionary.
    </span>
    <span class="koboSpan" id="kobo.324.2">
     We will see another library that is used to create schemas,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.325.1">
      pydantic
     </span>
    </code>
    <span class="koboSpan" id="kobo.326.1">
     , in
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.327.1">
      Chapter 14
     </span>
    </em>
    <span class="koboSpan" id="kobo.328.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.329.1">
      Introduction to API Development
     </span>
    </em>
    <span class="koboSpan" id="kobo.330.1">
     .
    </span>
   </p>
   <p class="normal">
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.331.1">
      pytest
     </span>
    </code>
    <span class="koboSpan" id="kobo.332.1">
     (
    </span>
    <a href="https://docs.pytest.org/">
     <span class="url">
      <span class="koboSpan" id="kobo.333.1">
       https://docs.pytest.org/
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.334.1">
     ) is one of the
    </span>
    <a id="_idIndexMarker962">
    </a>
    <span class="koboSpan" id="kobo.335.1">
     best pieces of software we have ever seen.
    </span>
    <span class="koboSpan" id="kobo.335.2">
     It is used almost everywhere and has replaced other libraries, such as
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.336.1">
      nose
     </span>
    </em>
    <span class="koboSpan" id="kobo.337.1">
     .
    </span>
    <span class="koboSpan" id="kobo.337.2">
     It provides us with useful tools to write tests quite efficiently.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.338.1">
     Let us get to the code.
    </span>
    <span class="koboSpan" id="kobo.338.2">
     We called it
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.339.1">
      api.py
     </span>
    </code>
    <span class="koboSpan" id="kobo.340.1">
     just because it exposes a function that we can use to export the CSV.
    </span>
    <span class="koboSpan" id="kobo.340.2">
     We will show it to you in chunks:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.341.1"># api.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.342.1">from</span></span><span class="koboSpan" id="kobo.343.1"> pathlib </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.344.1">import</span></span><span class="koboSpan" id="kobo.345.1"> Path
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.346.1">import</span></span><span class="koboSpan" id="kobo.347.1"> csv
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.348.1">from</span></span><span class="koboSpan" id="kobo.349.1"> copy </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.350.1">import</span></span><span class="koboSpan" id="kobo.351.1"> deepcopy
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.352.1">from</span></span><span class="koboSpan" id="kobo.353.1"> marshmallow </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.354.1">import</span></span><span class="koboSpan" id="kobo.355.1"> Schema, fields, pre_load
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.356.1">from</span></span><span class="koboSpan" id="kobo.357.1"> marshmallow.validate </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.358.1">import</span></span><span class="koboSpan" id="kobo.359.1"> Length, Range
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.360.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.361.1">UserSchema</span></span><span class="koboSpan" id="kobo.362.1">(</span><span class="hljs-title"><span class="koboSpan" id="kobo.363.1">Schema</span></span><span class="koboSpan" id="kobo.364.1">):
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.365.1">"""Represent a *valid* user."""</span></span><span class="koboSpan" id="kobo.366.1">
    email = fields.Email(required=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.367.1">True</span></span><span class="koboSpan" id="kobo.368.1">)
    name = fields.Str(required=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.369.1">True</span></span><span class="koboSpan" id="kobo.370.1">, validate=Length(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.371.1">min</span></span><span class="koboSpan" id="kobo.372.1">=</span><span class="hljs-number"><span class="koboSpan" id="kobo.373.1">1</span></span><span class="koboSpan" id="kobo.374.1">))
    age = fields.Int(
        required=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.375.1">True</span></span><span class="koboSpan" id="kobo.376.1">, validate=Range(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.377.1">min</span></span><span class="koboSpan" id="kobo.378.1">=</span><span class="hljs-number"><span class="koboSpan" id="kobo.379.1">18</span></span><span class="koboSpan" id="kobo.380.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.381.1">max</span></span><span class="koboSpan" id="kobo.382.1">=</span><span class="hljs-number"><span class="koboSpan" id="kobo.383.1">65</span></span><span class="koboSpan" id="kobo.384.1">)
    )
    role = fields.Str()
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.385.1">    @pre_load()</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.386.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.387.1">strip_name</span></span><span class="koboSpan" id="kobo.388.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.389.1">self, data, **kwargs</span></span><span class="koboSpan" id="kobo.390.1">):
        data_copy = deepcopy(data)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.391.1">try</span></span><span class="koboSpan" id="kobo.392.1">:
            data_copy[</span><span class="hljs-string"><span class="koboSpan" id="kobo.393.1">"name"</span></span><span class="koboSpan" id="kobo.394.1">] = data_copy[</span><span class="hljs-string"><span class="koboSpan" id="kobo.395.1">"name"</span></span><span class="koboSpan" id="kobo.396.1">].strip()
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.397.1">except</span></span><span class="koboSpan" id="kobo.398.1"> (AttributeError, KeyError, TypeError):
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.399.1">pass</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.400.1">return</span></span><span class="koboSpan" id="kobo.401.1"> data_copy
schema = UserSchema()
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.402.1">
     This first part is where we import all that we need (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.403.1">
      Path
     </span>
    </code>
    <span class="koboSpan" id="kobo.404.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.405.1">
      csv
     </span>
    </code>
    <span class="koboSpan" id="kobo.406.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.407.1">
      deepcopy
     </span>
    </code>
    <span class="koboSpan" id="kobo.408.1">
     , and some tools from
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.409.1">
      marshmallow)
     </span>
    </code>
    <span class="koboSpan" id="kobo.410.1">
     , and then we define the schema for the users.
    </span>
    <span class="koboSpan" id="kobo.410.2">
     As you can see, we inherit from
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.411.1">
      marshmallow.Schema
     </span>
    </code>
    <span class="koboSpan" id="kobo.412.1">
     , and then we set four fields.
    </span>
    <span class="koboSpan" id="kobo.412.2">
     Notice we are using two string fields (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.413.1">
      Str
     </span>
    </code>
    <span class="koboSpan" id="kobo.414.1">
     ), an
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.415.1">
      Email
     </span>
    </code>
    <span class="koboSpan" id="kobo.416.1">
     , and an integer (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.417.1">
      Int
     </span>
    </code>
    <span class="koboSpan" id="kobo.418.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.418.2">
     These will already provide us with some validation from
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.419.1">
      marshmallow
     </span>
    </code>
    <span class="koboSpan" id="kobo.420.1">
     .
    </span>
    <span class="koboSpan" id="kobo.420.2">
     Notice there is no
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.421.1">
      required=True
     </span>
    </code>
    <span class="koboSpan" id="kobo.422.1">
     in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.423.1">
      role
     </span>
    </code>
    <span class="koboSpan" id="kobo.424.1">
     field.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.425.1">
     We need to add a couple of
    </span>
    <a id="_idIndexMarker963">
    </a>
    <span class="koboSpan" id="kobo.426.1">
     custom bits of code, though.
    </span>
    <span class="koboSpan" id="kobo.426.2">
     We need to add validation on
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.427.1">
      age
     </span>
    </code>
    <span class="koboSpan" id="kobo.428.1">
     to make sure the value is within the range we want.
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.429.1">
      marshmallow
     </span>
    </code>
    <span class="koboSpan" id="kobo.430.1">
     will raise
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.431.1">
      ValidationError
     </span>
    </code>
    <span class="koboSpan" id="kobo.432.1">
     if it is not.
    </span>
    <span class="koboSpan" id="kobo.432.2">
     It will also take care of raising an error should we pass anything but an integer.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.433.1">
     We also add validation on
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.434.1">
      name
     </span>
    </code>
    <span class="koboSpan" id="kobo.435.1">
     , because the fact that there is a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.436.1">
      name
     </span>
    </code>
    <span class="koboSpan" id="kobo.437.1">
     key in a dictionary does not guarantee that the value of that name is non-empty.
    </span>
    <span class="koboSpan" id="kobo.437.2">
     We validate that the length of the field’s value is at least one.
    </span>
    <span class="koboSpan" id="kobo.437.3">
     Notice we do not need to add anything for the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.438.1">
      email
     </span>
    </code>
    <span class="koboSpan" id="kobo.439.1">
     field.
    </span>
    <span class="koboSpan" id="kobo.439.2">
     This is because
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.440.1">
      marshmallow
     </span>
    </code>
    <span class="koboSpan" id="kobo.441.1">
     will validate it for us.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.442.1">
     After the field declarations, we write another method,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.443.1">
      strip_name()
     </span>
    </code>
    <span class="koboSpan" id="kobo.444.1">
     , which is decorated with the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.445.1">
      pre_load()
     </span>
    </code>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.446.1">
      marshmallow
     </span>
    </code>
    <span class="koboSpan" id="kobo.447.1">
     helper.
    </span>
    <span class="koboSpan" id="kobo.447.2">
     This method will run before
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.448.1">
      marshmallow
     </span>
    </code>
    <span class="koboSpan" id="kobo.449.1">
     deserializes (loads) the data.
    </span>
    <span class="koboSpan" id="kobo.449.2">
     As you can see, we make a copy of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.450.1">
      data
     </span>
    </code>
    <span class="koboSpan" id="kobo.451.1">
     first, as in this context it is not a good idea to work directly on a mutable object, and then make sure we strip leading and trailing spaces away from
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.452.1">
      data['name']
     </span>
    </code>
    <span class="koboSpan" id="kobo.453.1">
     .
    </span>
    <span class="koboSpan" id="kobo.453.2">
     That key represents the name field we just declared above.
    </span>
    <span class="koboSpan" id="kobo.453.3">
     We make sure we do this within a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.454.1">
      try
     </span>
    </code>
    <span class="koboSpan" id="kobo.455.1">
     /
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.456.1">
      except
     </span>
    </code>
    <span class="koboSpan" id="kobo.457.1">
     block, so deserialization can run smoothly even in case of errors.
    </span>
    <span class="koboSpan" id="kobo.457.2">
     The method returns the modified copy of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.458.1">
      data
     </span>
    </code>
    <span class="koboSpan" id="kobo.459.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.460.1">
      marshmallow
     </span>
    </code>
    <span class="koboSpan" id="kobo.461.1">
     does the rest.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.462.1">
     We then instantiate
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.463.1">
      schema
     </span>
    </code>
    <span class="koboSpan" id="kobo.464.1">
     , so that we can use it to validate data.
    </span>
    <span class="koboSpan" id="kobo.464.2">
     So, let us write the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.465.1">
      export
     </span>
    </code>
    <span class="koboSpan" id="kobo.466.1">
     function:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.467.1"># api.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.468.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.469.1">export</span></span><span class="koboSpan" id="kobo.470.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.471.1">filename, users, overwrite=</span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.472.1">True</span></span><span class="koboSpan" id="kobo.473.1">):
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.474.1">"""</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.475.1">Export a CSV file.</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.476.1">    Create a CSV file and fill with valid users.  </span><span class="koboSpan" id="kobo.476.2">If `overwrite`</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.477.1">    is False and file already exists, raise IOError.</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.478.1">    """</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.479.1">if</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.480.1">not</span></span><span class="koboSpan" id="kobo.481.1"> overwrite </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.482.1">and</span></span><span class="koboSpan" id="kobo.483.1"> Path(filename).is_file():
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.484.1">raise</span></span><span class="koboSpan" id="kobo.485.1"> IOError(</span><span class="hljs-string"><span class="koboSpan" id="kobo.486.1">f"'</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.487.1">{filename}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.488.1">' already exists."</span></span><span class="koboSpan" id="kobo.489.1">)
    valid_users = get_valid_users(users)
    write_csv(filename, valid_users)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.490.1">
     As you see, its logic is
    </span>
    <a id="_idIndexMarker964">
    </a>
    <span class="koboSpan" id="kobo.491.1">
     straightforward.
    </span>
    <span class="koboSpan" id="kobo.491.2">
     If
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.492.1">
      overwrite
     </span>
    </code>
    <span class="koboSpan" id="kobo.493.1">
     is
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.494.1">
      False
     </span>
    </code>
    <span class="koboSpan" id="kobo.495.1">
     and the file already exists, we raise
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.496.1">
      IOError
     </span>
    </code>
    <span class="koboSpan" id="kobo.497.1">
     with a message saying the file already exists.
    </span>
    <span class="koboSpan" id="kobo.497.2">
     Otherwise, if we can proceed, we simply get the list of valid users and feed it to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.498.1">
      write_csv()
     </span>
    </code>
    <span class="koboSpan" id="kobo.499.1">
     , which is responsible for actually doing the job.
    </span>
    <span class="koboSpan" id="kobo.499.2">
     Let us see how all these functions are defined:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.500.1"># api.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.501.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.502.1">get_valid_users</span></span><span class="koboSpan" id="kobo.503.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.504.1">users</span></span><span class="koboSpan" id="kobo.505.1">):
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.506.1">"""Yield one valid user at a time from users."""</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.507.1">yield</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.508.1">from</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.509.1">filter</span></span><span class="koboSpan" id="kobo.510.1">(is_valid, users)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.511.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.512.1">is_valid</span></span><span class="koboSpan" id="kobo.513.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.514.1">user</span></span><span class="koboSpan" id="kobo.515.1">):
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.516.1">"""Tell if the user is valid."""</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.517.1">return</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.518.1">not</span></span><span class="koboSpan" id="kobo.519.1"> schema.validate(user)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.520.1">
     We coded
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.521.1">
      get_valid_users()
     </span>
    </code>
    <span class="koboSpan" id="kobo.522.1">
     as a generator, as there is no need to make a potentially big list before writing to a file.
    </span>
    <span class="koboSpan" id="kobo.522.2">
     We can validate and save them one by one.
    </span>
    <span class="koboSpan" id="kobo.522.3">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.523.1">
      is_valid()
     </span>
    </code>
    <span class="koboSpan" id="kobo.524.1">
     function simply delegates to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.525.1">
      marshmallow
     </span>
    </code>
    <span class="koboSpan" id="kobo.526.1">
     's
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.527.1">
      schema.validate()
     </span>
    </code>
    <span class="koboSpan" id="kobo.528.1">
     to validate the user.
    </span>
    <span class="koboSpan" id="kobo.528.2">
     This method returns a dictionary, which is empty if the data is valid according to the schema or else it will contain error information.
    </span>
    <span class="koboSpan" id="kobo.528.3">
     We do not need to collect the error information for this task, so we simply ignore it, and the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.529.1">
      is_valid()
     </span>
    </code>
    <span class="koboSpan" id="kobo.530.1">
     function simply returns
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.531.1">
      True
     </span>
    </code>
    <span class="koboSpan" id="kobo.532.1">
     if the return value from
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.533.1">
      schema.validate()
     </span>
    </code>
    <span class="koboSpan" id="kobo.534.1">
     is empty, or
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.535.1">
      False
     </span>
    </code>
    <span class="koboSpan" id="kobo.536.1">
     otherwise.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.537.1">
     The final piece of code in this module is:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.538.1"># api.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.539.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.540.1">write_csv</span></span><span class="koboSpan" id="kobo.541.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.542.1">filename, users</span></span><span class="koboSpan" id="kobo.543.1">):
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.544.1">"""Write a CSV given a filename and a list of users.</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.545.1">    The users are assumed to be valid for the given CSV structure.</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.546.1">    """</span></span><span class="koboSpan" id="kobo.547.1">
    fieldnames = [</span><span class="hljs-string"><span class="koboSpan" id="kobo.548.1">"email"</span></span><span class="koboSpan" id="kobo.549.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.550.1">"name"</span></span><span class="koboSpan" id="kobo.551.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.552.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.553.1">age"</span></span><span class="koboSpan" id="kobo.554.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.555.1">"role"</span></span><span class="koboSpan" id="kobo.556.1">]
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.557.1">with</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.558.1">open</span></span><span class="koboSpan" id="kobo.559.1">(filename, </span><span class="hljs-string"><span class="koboSpan" id="kobo.560.1">"w"</span></span><span class="koboSpan" id="kobo.561.1">, newline=</span><span class="hljs-string"><span class="koboSpan" id="kobo.562.1">""</span></span><span class="koboSpan" id="kobo.563.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.564.1">as</span></span><span class="koboSpan" id="kobo.565.1"> csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(users)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.566.1">
     Again, the logic is
    </span>
    <a id="_idIndexMarker965">
    </a>
    <span class="koboSpan" id="kobo.567.1">
     straightforward.
    </span>
    <span class="koboSpan" id="kobo.567.2">
     We define the header in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.568.1">
      fieldnames
     </span>
    </code>
    <span class="koboSpan" id="kobo.569.1">
     , then we open
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.570.1">
      filename
     </span>
    </code>
    <span class="koboSpan" id="kobo.571.1">
     for writing, and we specify
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.572.1">
      newline=""
     </span>
    </code>
    <span class="koboSpan" id="kobo.573.1">
     , which is recommended in the documentation for CSV files.
    </span>
    <span class="koboSpan" id="kobo.573.2">
     When the file has been created, we get a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.574.1">
      writer
     </span>
    </code>
    <span class="koboSpan" id="kobo.575.1">
     object by using the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.576.1">
      csv.DictWriter
     </span>
    </code>
    <span class="koboSpan" id="kobo.577.1">
     class.
    </span>
    <span class="koboSpan" id="kobo.577.2">
     This tool maps the user dictionaries to the field names, so we do not need to take care of the ordering.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.578.1">
     We write the header first, and then we loop over the users and add them one by one.
    </span>
    <span class="koboSpan" id="kobo.578.2">
     Notice that this function assumes it is fed a list of valid users, and it may break if that assumption is false (with the default values, it would break if any user dictionary had extra fields).
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.579.1">
     That’s the code you should try and keep in mind.
    </span>
    <span class="koboSpan" id="kobo.579.2">
     We suggest you spend a moment going through it again.
    </span>
    <span class="koboSpan" id="kobo.579.3">
     There is no need to memorize it, and the fact that we have used small helper functions with meaningful names will enable you to follow the testing more easily.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.580.1">
     Let us now get to the interesting part: testing the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.581.1">
      export()
     </span>
    </code>
    <span class="koboSpan" id="kobo.582.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.582.2">
     Once again, we will show you the code in chunks:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.583.1"># tests/test_api.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.584.1">import</span></span><span class="koboSpan" id="kobo.585.1"> re
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.586.1">from</span></span><span class="koboSpan" id="kobo.587.1"> unittest.mock </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.588.1">import</span></span><span class="koboSpan" id="kobo.589.1"> patch, mock_open, call
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.590.1">import</span></span><span class="koboSpan" id="kobo.591.1"> pytest
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.592.1">from</span></span><span class="koboSpan" id="kobo.593.1"> api </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.594.1">import</span></span><span class="koboSpan" id="kobo.595.1"> is_valid, export, write_csv
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.596.1">
     Let us start with the imports: first, we import the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.597.1">
      re
     </span>
    </code>
    <span class="koboSpan" id="kobo.598.1">
     module from the standard library, as it’s needed in one of the tests.
    </span>
    <span class="koboSpan" id="kobo.598.2">
     Then, we bring in some tools from
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.599.1">
      unittest.mock
     </span>
    </code>
    <span class="koboSpan" id="kobo.600.1">
     , then
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.601.1">
      pytest
     </span>
    </code>
    <span class="koboSpan" id="kobo.602.1">
     , and, finally, we fetch the three functions that we want to actually test:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.603.1">
      is_valid()
     </span>
    </code>
    <span class="koboSpan" id="kobo.604.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.605.1">
      export()
     </span>
    </code>
    <span class="koboSpan" id="kobo.606.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.607.1">
      write_csv()
     </span>
    </code>
    <span class="koboSpan" id="kobo.608.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.609.1">
     Before we can write tests, though, we need to make a few fixtures.
    </span>
    <span class="koboSpan" id="kobo.609.2">
     As you will see, a
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.610.1">
      fixture
     </span>
    </strong>
    <span class="koboSpan" id="kobo.611.1">
     in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.612.1">
      pytest
     </span>
    </code>
    <a id="_idIndexMarker966">
    </a>
    <span class="koboSpan" id="kobo.613.1">
     is a function decorated with the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.614.1">
      pytest.fixture
     </span>
    </code>
    <span class="koboSpan" id="kobo.615.1">
     decorator.
    </span>
    <span class="koboSpan" id="kobo.615.2">
     Fixtures
    </span>
    <a id="_idIndexMarker967">
    </a>
    <span class="koboSpan" id="kobo.616.1">
     are run before each test to which they are applied.
    </span>
    <span class="koboSpan" id="kobo.616.2">
     In most cases, we expect a fixture to return something so that we can use it in a test.
    </span>
    <span class="koboSpan" id="kobo.616.3">
     We have some requirements for a user dictionary, so let us write a couple of users: one with minimal requirements, and one with full
    </span>
    <a id="_idIndexMarker968">
    </a>
    <span class="koboSpan" id="kobo.617.1">
     requirements.
    </span>
    <span class="koboSpan" id="kobo.617.2">
     Both need to be valid.
    </span>
    <span class="koboSpan" id="kobo.617.3">
     Here is the code:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.618.1"># tests/test_api.py</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.619.1">@pytest.fixture</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.620.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.621.1">min_user</span></span><span class="koboSpan" id="kobo.622.1">():
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.623.1">"""Represent a valid user with minimal data."""</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.624.1">return</span></span><span class="koboSpan" id="kobo.625.1"> {
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.626.1">"email"</span></span><span class="koboSpan" id="kobo.627.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.628.1">"minimal@example.com"</span></span><span class="koboSpan" id="kobo.629.1">,
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.630.1">"name"</span></span><span class="koboSpan" id="kobo.631.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.632.1">"Primus Minimus"</span></span><span class="koboSpan" id="kobo.633.1">,
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.634.1">"age"</span></span><span class="koboSpan" id="kobo.635.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.636.1">18</span></span><span class="koboSpan" id="kobo.637.1">,
    }
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.638.1">@pytest.fixture</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.639.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.640.1">full_user</span></span><span class="koboSpan" id="kobo.641.1">():
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.642.1">"""Represent valid user with full data."""</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.643.1">return</span></span><span class="koboSpan" id="kobo.644.1"> {
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.645.1">"email"</span></span><span class="koboSpan" id="kobo.646.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.647.1">"full@example.com"</span></span><span class="koboSpan" id="kobo.648.1">,
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.649.1">"name"</span></span><span class="koboSpan" id="kobo.650.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.651.1">"Maximus Plenus"</span></span><span class="koboSpan" id="kobo.652.1">,
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.653.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.654.1">age"</span></span><span class="koboSpan" id="kobo.655.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.656.1">65</span></span><span class="koboSpan" id="kobo.657.1">,
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.658.1">"role"</span></span><span class="koboSpan" id="kobo.659.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.660.1">"emperor"</span></span><span class="koboSpan" id="kobo.661.1">,
    }
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.662.1">
     In this example, the only difference between the users is the presence of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.663.1">
      role
     </span>
    </code>
    <span class="koboSpan" id="kobo.664.1">
     key, but it should be enough to show you the point.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.665.1">
     Notice that instead of simply declaring dictionaries at a module level, we have actually written two functions that return a dictionary, and we have decorated them with the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.666.1">
      @pytest.fixture
     </span>
    </code>
    <span class="koboSpan" id="kobo.667.1">
     decorator.
    </span>
    <span class="koboSpan" id="kobo.667.2">
     This is because when you declare a dictionary that is supposed to be used in your tests at the module level, you need to make sure you copy it at the beginning of every test.
    </span>
    <span class="koboSpan" id="kobo.667.3">
     If you do not, and any of the tests (or the code being tested) modify it, all the following tests might be compromised, as the dictionary would not be in its original form.
    </span>
    <span class="koboSpan" id="kobo.667.4">
     By using these fixtures,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.668.1">
      pytest
     </span>
    </code>
    <span class="koboSpan" id="kobo.669.1">
     will give us a new dictionary for every test, so we do not need to go through that copy procedure.
    </span>
    <span class="koboSpan" id="kobo.669.2">
     This helps to respect the principle of independence, which says that each test should be self-contained and independent.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.670.1">
     Fixtures are also
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.671.1">
      composable
     </span>
    </em>
    <span class="koboSpan" id="kobo.672.1">
     , which means they can be used in one another, which is a useful feature of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.673.1">
      pytest
     </span>
    </code>
    <span class="koboSpan" id="kobo.674.1">
     .
    </span>
    <span class="koboSpan" id="kobo.674.2">
     To show you this, let us write a fixture for a list of users, in which we put the two we already have, plus one that would fail validation because it has no age.
    </span>
    <span class="koboSpan" id="kobo.674.3">
     Let us take a
    </span>
    <a id="_idIndexMarker969">
    </a>
    <span class="koboSpan" id="kobo.675.1">
     look at the following code:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.676.1"># tests/test_api.py</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.677.1">@pytest.fixture</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.678.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.679.1">users</span></span><span class="koboSpan" id="kobo.680.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.681.1">min_user, full_user</span></span><span class="koboSpan" id="kobo.682.1">):
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.683.1">"""List of users, two valid and one invalid."""</span></span><span class="koboSpan" id="kobo.684.1">
    bad_user = {
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.685.1">"email"</span></span><span class="koboSpan" id="kobo.686.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.687.1">"invalid@example.com"</span></span><span class="koboSpan" id="kobo.688.1">,
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.689.1">"name"</span></span><span class="koboSpan" id="kobo.690.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.691.1">"Horribilis"</span></span><span class="koboSpan" id="kobo.692.1">,
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.693.1">return</span></span><span class="koboSpan" id="kobo.694.1"> [min_user, bad_user, full_user]
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.695.1">
     We now have two users that we can use individually, and we also have a list of three users.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.696.1">
     The first few tests will test how we validate a user.
    </span>
    <span class="koboSpan" id="kobo.696.2">
     We will group all the tests for this task within a class.
    </span>
    <span class="koboSpan" id="kobo.696.3">
     This helps to give related tests a namespace, a place to be.
    </span>
    <span class="koboSpan" id="kobo.696.4">
     As we will see later, it also allows us to declare class-level fixtures, which are defined just for the tests belonging to the class.
    </span>
    <span class="koboSpan" id="kobo.696.5">
     One of the benefits of declaring a fixture at a class level is that you can easily override one with the same name that lives outside the scope of the class.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.697.1">
     Although, in this case, we found
    </span>
    <a id="_idIndexMarker970">
    </a>
    <span class="koboSpan" id="kobo.698.1">
     it convenient to organize our tests in classes, you can also just have tests defined at the module level.
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.699.1">
      pytest
     </span>
    </code>
    <span class="koboSpan" id="kobo.700.1">
     allows for great flexibility in the way tests are structured.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.701.1">
     Moreover, you will notice, as we walk you through the examples, that the name of each test function starts with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.702.1">
      test_
     </span>
    </code>
    <span class="koboSpan" id="kobo.703.1">
     and that of each test class starts with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.704.1">
      Test
     </span>
    </code>
    <span class="koboSpan" id="kobo.705.1">
     .
    </span>
    <span class="koboSpan" id="kobo.705.2">
     This is to allow
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.706.1">
      pytest
     </span>
    </code>
    <span class="koboSpan" id="kobo.707.1">
     to discover these functions and classes and consider them as tests.
    </span>
    <span class="koboSpan" id="kobo.707.2">
     Please refer to the pytest documentation to learn the full specifications.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.708.1">
     Let us come back to our code now.
    </span>
    <span class="koboSpan" id="kobo.708.2">
     Take a look at the following:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.709.1"># tests/test_api.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.710.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.711.1">TestIsValid</span></span><span class="koboSpan" id="kobo.712.1">:
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.713.1">"""Test how code verifies whether a user is valid or not."""</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.714.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.715.1">test_minimal</span></span><span class="koboSpan" id="kobo.716.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.717.1">self, min_user</span></span><span class="koboSpan" id="kobo.718.1">):
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.719.1">assert</span></span><span class="koboSpan" id="kobo.720.1"> is_valid(min_user)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.721.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.722.1">test_full</span></span><span class="koboSpan" id="kobo.723.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.724.1">self, full_user</span></span><span class="koboSpan" id="kobo.725.1">):
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.726.1">assert</span></span><span class="koboSpan" id="kobo.727.1"> is_valid(full_user)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.728.1">
     We start very simply by making sure our fixtures actually pass validation.
    </span>
    <span class="koboSpan" id="kobo.728.2">
     This helps ensure that our code will correctly validate users that we know to be valid, with minimal as well as full data.
    </span>
    <span class="koboSpan" id="kobo.728.3">
     Notice that we gave each test function a parameter matching the name of a fixture.
    </span>
    <span class="koboSpan" id="kobo.728.4">
     This has the effect of activating the fixture for that test.
    </span>
    <span class="koboSpan" id="kobo.728.5">
     When
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.729.1">
      pytest
     </span>
    </code>
    <span class="koboSpan" id="kobo.730.1">
     runs the tests, it will inspect the parameters of each test and pass the return values of the corresponding fixture functions as arguments to the test.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.731.1">
     Before we proceed, it would be
    </span>
    <a id="_idIndexMarker971">
    </a>
    <span class="koboSpan" id="kobo.732.1">
     good to run these two tests, just to make sure everything is wired up correctly.
    </span>
    <span class="koboSpan" id="kobo.732.2">
     To run the tests, we invoke the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.733.1">
      pytest
     </span>
    </code>
    <span class="koboSpan" id="kobo.734.1">
     command in the shell, from the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.735.1">
      ch10
     </span>
    </code>
    <span class="koboSpan" id="kobo.736.1">
     folder:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.737.1">$ pytest tests -vv
===================== test session starts =====================
platform darwin -- Python 3.12.2, pytest-8.1.1, pluggy-1.4.0 --
  /Users/fab/.virtualenvs/lpp4ed-ch10/bin/python
cachedir: .pytest_cache
rootdir: /Users/fab/code/lpp4ed
configfile: pyproject.toml
collected 2 items
tests/test_api.py::TestIsValid::test_minimal PASSED      [ 50%]
tests/test_api.py::TestIsValid::test_full PASSED         [100%]
====================== 2 passed in 0.03s ======================
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.738.1">
     We have instructed the command to search for tests in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.739.1">
      tests
     </span>
    </code>
    <span class="koboSpan" id="kobo.740.1">
     folder.
    </span>
    <span class="koboSpan" id="kobo.740.2">
     Moreover, to show you the full details, we have invoked it with the verbose flag (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.741.1">
      -vv
     </span>
    </code>
    <span class="koboSpan" id="kobo.742.1">
     ).
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.743.1">
     After a bit of boilerplate, we find two lines that we highlighted.
    </span>
    <span class="koboSpan" id="kobo.743.2">
     They represent the full path to each of the tests that ran.
    </span>
    <span class="koboSpan" id="kobo.743.3">
     First, the name of the module where the tests live, then in this case, the name of the class in which they are defined, and finally their names.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.744.1">
     On the right, you can see the progression, indicated as a percentage.
    </span>
    <span class="koboSpan" id="kobo.744.2">
     In this case, we only have two tests for now, so after running the first one, we have completed 50% of the test suite, and 100% after the second one.
    </span>
    <span class="koboSpan" id="kobo.744.3">
     They both passed.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.745.1">
     Should any of the tests fail,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.746.1">
      pytest
     </span>
    </code>
    <span class="koboSpan" id="kobo.747.1">
     would print an error and some debug information, so we can inspect what is wrong and fix it.
    </span>
    <span class="koboSpan" id="kobo.747.2">
     Let us simulate a failure by removing the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.748.1">
      name
     </span>
    </code>
    <span class="koboSpan" id="kobo.749.1">
     key from the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.750.1">
      min_user
     </span>
    </code>
    <span class="koboSpan" id="kobo.751.1">
     fixture and running the tests again:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.752.1">$ pytest tests -vv
===================== test session starts =====================
platform darwin -- Python 3.12.2, pytest-8.1.1, pluggy-1.4.0 --
/Users/fab/.virtualenvs/lpp4ed-ch10/bin/python
cachedir: .pytest_cache
rootdir: /Users/fab/code/lpp4ed
configfile: pyproject.toml
collected 2 items
tests/test_api.py::TestIsValid::test_minimal FAILED     [ 50%]
tests/test_api.py::TestIsValid::test_full PASSED        [100%]
=========================== FAILURES ==========================
___________________ TestIsValid.test_minimal __________________
self = &lt;ch10.tests.test_api.TestIsValid object at 0x103603920&gt;,
       min_user = {'age': 18, 'email': 'minimal@example.com'}
    def test_minimal(self, min_user):
&gt;       assert is_valid(min_user)
E       AssertionError: assert False
E        +  where False = is_valid(
                {'age': 18, 'email': 'minimal@example.com'}
            )
tests/test_api.py:45: AssertionError
=================== short test summary info ===================
FAILED tests/test_api.py::TestIsValid::test_minimal
       - AssertionError: assert False
================= 1 failed, 1 passed in 0.04s =================
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.753.1">
     As you can see in the
    </span>
    <a id="_idIndexMarker972">
    </a>
    <span class="koboSpan" id="kobo.754.1">
     highlighted sections,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.755.1">
      pytest
     </span>
    </code>
    <span class="koboSpan" id="kobo.756.1">
     reports which tests failed, and a snippet of the code where the failure happened, so we can inspect it and discover what the problem is.
    </span>
    <span class="koboSpan" id="kobo.756.2">
     On the left-hand side of the snippet, there is a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.757.1">
      &gt;
     </span>
    </code>
    <span class="koboSpan" id="kobo.758.1">
     sign, which indicates the line that threw the error, and underneath, two lines representing the error itself, which in this case is that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.759.1">
      {'age': 18, 'email': 'minimal@example.com'}
     </span>
    </code>
    <span class="koboSpan" id="kobo.760.1">
     is not a valid user.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.761.1">
     Now that we know how to run tests, please feel free to run them any time you want.
    </span>
    <span class="koboSpan" id="kobo.761.2">
     A good practice when we run tests is to make sure that they would fail if something was wrong, so feel free to play around with the fixtures and the assertions.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.762.1">
     Let us go back to the test suite now.
    </span>
    <span class="koboSpan" id="kobo.762.2">
     The next task is to test the age.
    </span>
    <span class="koboSpan" id="kobo.762.3">
     To do that, we are going to use parametrization.
    </span>
   </p>
   <p class="normal">
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.763.1">
      Parametrization
     </span>
    </strong>
    <span class="koboSpan" id="kobo.764.1">
     is a
    </span>
    <a id="_idIndexMarker973">
    </a>
    <span class="koboSpan" id="kobo.765.1">
     technique that enables us to run the same test multiple times but feed different data to it.
    </span>
    <span class="koboSpan" id="kobo.765.2">
     It is quite useful as it allows us to write the test only once with no repetition, and the result will be intelligently handled by
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.766.1">
      pytest
     </span>
    </code>
    <span class="koboSpan" id="kobo.767.1">
     , which will run all those tests as if they were actually separate, thus providing us with clear error messages when they fail.
    </span>
    <span class="koboSpan" id="kobo.767.2">
     Another solution would be to write one test with a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.768.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.769.1">
     loop inside that runs through all the pieces of data we want to test against.
    </span>
    <span class="koboSpan" id="kobo.769.2">
     The latter solution is of much lower quality though, as the framework won’t be able to give you specific information as if you were running separate tests.
    </span>
    <span class="koboSpan" id="kobo.769.3">
     Moreover, should any of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.770.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.771.1">
     loop iterations fail, there would be no information about what would have happened after that, as subsequent iterations will not happen.
    </span>
    <span class="koboSpan" id="kobo.771.2">
     Finally, the body of the test would get more difficult to understand, due to the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.772.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.773.1">
     loop extra logic.
    </span>
    <span class="koboSpan" id="kobo.773.2">
     Therefore, parametrization
    </span>
    <a id="_idIndexMarker974">
    </a>
    <span class="koboSpan" id="kobo.774.1">
     is a far superior choice for this use case.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.775.1">
     It also spares us from having to
    </span>
    <a id="_idIndexMarker975">
    </a>
    <span class="koboSpan" id="kobo.776.1">
     write a bunch of almost identical tests to exhaust all possible scenarios.
    </span>
    <span class="koboSpan" id="kobo.776.2">
     Let us see how we test the age (we are repeating the class signature for you, but omitting the tests that have already been presented):
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.777.1"># tests/test_api.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.778.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.779.1">TestIsValid</span></span><span class="koboSpan" id="kobo.780.1">:
    …
</span><span class="hljs-meta">    </span><span class="code-highlight"><strong class="hljs-meta-slc"><span class="koboSpan" id="kobo.781.1">@pytest.mark.parametrize(</span></strong><strong class="hljs-string-slc"><span class="koboSpan" id="kobo.782.1">"age"</span></strong><strong class="hljs-params-slc"><span class="koboSpan" id="kobo.783.1">, </span></strong><strong class="hljs-built_in-slc"><span class="koboSpan" id="kobo.784.1">range</span></strong><strong class="hljs-params-slc"><span class="koboSpan" id="kobo.785.1">(</span></strong><strong class="hljs-number-slc"><span class="koboSpan" id="kobo.786.1">18</span></strong><strong class="hljs-params-slc"><span class="koboSpan" id="kobo.787.1">)</span></strong><strong class="hljs-meta-slc"><span class="koboSpan" id="kobo.788.1">)</span></strong></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.789.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.790.1">test_invalid_age_too_young</span></span><span class="koboSpan" id="kobo.791.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.792.1">self, </span></span><span class="code-highlight"><strong class="hljs-params-slc"><span class="koboSpan" id="kobo.793.1">age</span></strong></span><span class="hljs-params"><span class="koboSpan" id="kobo.794.1">, min_user</span></span><span class="koboSpan" id="kobo.795.1">):
        min_user[</span><span class="hljs-string"><span class="koboSpan" id="kobo.796.1">"age"</span></span><span class="koboSpan" id="kobo.797.1">] = age
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.798.1">assert</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.799.1">not</span></span><span class="koboSpan" id="kobo.800.1"> is_valid(min_user)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.801.1">
     We start by writing a test to check that validation fails when the user is too young.
    </span>
    <span class="koboSpan" id="kobo.801.2">
     According to our rule, a user is too young when they are younger than 18.
    </span>
    <span class="koboSpan" id="kobo.801.3">
     We check for every age between 0 and 17 by using
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.802.1">
      range()
     </span>
    </code>
    <span class="koboSpan" id="kobo.803.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.804.1">
     If you look at how the parametrization works, you see that we declare the name of an object and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.805.1">
      age
     </span>
    </code>
    <span class="koboSpan" id="kobo.806.1">
     and then we specify which values this object will take.
    </span>
    <span class="koboSpan" id="kobo.806.2">
     The test will be run once for each of the specified values.
    </span>
    <span class="koboSpan" id="kobo.806.3">
     In the case of this first test, the values are all those returned by
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.807.1">
      range(18)
     </span>
    </code>
    <span class="koboSpan" id="kobo.808.1">
     , which means all integer numbers from 0 to 17 are included.
    </span>
    <span class="koboSpan" id="kobo.808.2">
     Note that we also add an
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.809.1">
      age
     </span>
    </code>
    <span class="koboSpan" id="kobo.810.1">
     parameter to the test.
    </span>
    <span class="koboSpan" id="kobo.810.2">
     The values specified in the parameterization will be passed as arguments to the test through this parameter.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.811.1">
     We also use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.812.1">
      min_user()
     </span>
    </code>
    <span class="koboSpan" id="kobo.813.1">
     fixture in this test.
    </span>
    <span class="koboSpan" id="kobo.813.2">
     In this case, we change the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.814.1">
      age
     </span>
    </code>
    <span class="koboSpan" id="kobo.815.1">
     within the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.816.1">
      min_user()
     </span>
    </code>
    <span class="koboSpan" id="kobo.817.1">
     dictionary, and then we verify that the result of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.818.1">
      is_valid(min_user)
     </span>
    </code>
    <span class="koboSpan" id="kobo.819.1">
     is
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.820.1">
      False
     </span>
    </code>
    <span class="koboSpan" id="kobo.821.1">
     .
    </span>
    <span class="koboSpan" id="kobo.821.2">
     We do this by asserting the fact that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.822.1">
      not False
     </span>
    </code>
    <span class="koboSpan" id="kobo.823.1">
     is
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.824.1">
      True
     </span>
    </code>
    <span class="koboSpan" id="kobo.825.1">
     .
    </span>
    <span class="koboSpan" id="kobo.825.2">
     In
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.826.1">
      pytest
     </span>
    </code>
    <span class="koboSpan" id="kobo.827.1">
     , this is how you check for something.
    </span>
    <span class="koboSpan" id="kobo.827.2">
     You simply assert that something is truthy.
    </span>
    <span class="koboSpan" id="kobo.827.3">
     If that is the case, the test has succeeded.
    </span>
    <span class="koboSpan" id="kobo.827.4">
     Should it instead be the opposite, the test will fail.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.828.1">
      Note that
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.829.1">
       pytest
      </span>
     </code>
     <span class="koboSpan" id="kobo.830.1">
      will re-evaluate the fixture function for each test run that uses it, so we are free to modify the fixture data within the test without affecting any other tests.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.831.1">
     Let us proceed and add all the
    </span>
    <a id="_idIndexMarker976">
    </a>
    <span class="koboSpan" id="kobo.832.1">
     tests needed to make validation fail on the age:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.833.1"># tests/test_api.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.834.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.835.1">TestIsValid</span></span><span class="koboSpan" id="kobo.836.1">:
    ...
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.837.1">    @pytest.mark.parametrize(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.838.1">"age"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.839.1">, </span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.840.1">range</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.841.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.842.1">66</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.843.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.844.1">100</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.845.1">)</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.846.1">)</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.847.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.848.1">test_invalid_age_too_old</span></span><span class="koboSpan" id="kobo.849.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.850.1">self, age, min_user</span></span><span class="koboSpan" id="kobo.851.1">):
        min_user[</span><span class="hljs-string"><span class="koboSpan" id="kobo.852.1">"age"</span></span><span class="koboSpan" id="kobo.853.1">] = age
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.854.1">assert</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.855.1">not</span></span><span class="koboSpan" id="kobo.856.1"> is_valid(min_user)
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.857.1">    @pytest.mark.parametrize(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.858.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.859.1">age"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.860.1">, [</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.861.1">"NaN"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.862.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.863.1">3.1415</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.864.1">, </span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.865.1">None</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.866.1">]</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.867.1">)</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.868.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.869.1">test_invalid_age_wrong_type</span></span><span class="koboSpan" id="kobo.870.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.871.1">self, age, min_user</span></span><span class="koboSpan" id="kobo.872.1">):
        min_user[</span><span class="hljs-string"><span class="koboSpan" id="kobo.873.1">"age"</span></span><span class="koboSpan" id="kobo.874.1">] = age
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.875.1">assert</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.876.1">not</span></span><span class="koboSpan" id="kobo.877.1"> is_valid(min_user)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.878.1">
     Another two tests.
    </span>
    <span class="koboSpan" id="kobo.878.2">
     One takes care of the other end of the spectrum, from 66 years of age to 99.
    </span>
    <span class="koboSpan" id="kobo.878.3">
     The second one instead makes sure that age is invalid when it is not an integer number, so we pass some values, such as a string, a float, and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.879.1">
      None
     </span>
    </code>
    <span class="koboSpan" id="kobo.880.1">
     , just to make sure.
    </span>
    <span class="koboSpan" id="kobo.880.2">
     Notice how the structure of these tests is all the same, but, thanks to the parametrization, we feed different input arguments to it.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.881.1">
     Now that we have the age-failing logic sorted out, let us add a test that checks when age is within the valid range:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.882.1"># tests/test_api.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.883.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.884.1">TestIsValid</span></span><span class="koboSpan" id="kobo.885.1">:
    ...
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.886.1">    @pytest.mark.parametrize(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.887.1">"age"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.888.1">, </span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.889.1">range</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.890.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.891.1">18</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.892.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.893.1">66</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.894.1">)</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.895.1">)</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.896.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.897.1">test_valid_age</span></span><span class="koboSpan" id="kobo.898.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.899.1">self, age, min_user</span></span><span class="koboSpan" id="kobo.900.1">):
        min_user[</span><span class="hljs-string"><span class="koboSpan" id="kobo.901.1">"age"</span></span><span class="koboSpan" id="kobo.902.1">] = age
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.903.1">assert</span></span><span class="koboSpan" id="kobo.904.1"> is_valid(min_user)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.905.1">
     It is as easy as that.
    </span>
    <span class="koboSpan" id="kobo.905.2">
     We pass the correct range, from 18 to 65, and remove the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.906.1">
      not
     </span>
    </code>
    <span class="koboSpan" id="kobo.907.1">
     in the assertion.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.908.1">
     We can consider the age as being taken care of.
    </span>
    <span class="koboSpan" id="kobo.908.2">
     Let us move on to write tests on mandatory fields:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.909.1"># tests/test_api.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.910.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.911.1">TestIsValid</span></span><span class="koboSpan" id="kobo.912.1">:
    ...
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.913.1">    @pytest.mark.parametrize(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.914.1">"field"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.915.1">, [</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.916.1">"email"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.917.1">, </span></span><span class="hljs-string"><span class="koboSpan" id="kobo.918.1">"name"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.919.1">, </span></span><span class="hljs-string"><span class="koboSpan" id="kobo.920.1">"age"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.921.1">]</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.922.1">)</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.923.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.924.1">test_mandatory_fields</span></span><span class="koboSpan" id="kobo.925.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.926.1">self, field, min_user</span></span><span class="koboSpan" id="kobo.927.1">):
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.928.1">del</span></span><span class="koboSpan" id="kobo.929.1"> min_user[field]
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.930.1">assert</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.931.1">not</span></span><span class="koboSpan" id="kobo.932.1"> is_valid(min_user)
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.933.1">    @pytest.mark.parametrize(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.934.1">"field"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.935.1">, [</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.936.1">"email"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.937.1">, </span></span><span class="hljs-string"><span class="koboSpan" id="kobo.938.1">"name"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.939.1">, </span></span><span class="hljs-string"><span class="koboSpan" id="kobo.940.1">"age"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.941.1">]</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.942.1">)</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.943.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.944.1">test_mandatory_fields_empty</span></span><span class="koboSpan" id="kobo.945.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.946.1">self, field, min_user</span></span><span class="koboSpan" id="kobo.947.1">):
        min_user[field] = </span><span class="hljs-string"><span class="koboSpan" id="kobo.948.1">""</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.949.1">assert</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.950.1">not</span></span><span class="koboSpan" id="kobo.951.1"> is_valid(min_user)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.952.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.953.1">test_name_whitespace_only</span></span><span class="koboSpan" id="kobo.954.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.955.1">self, min_user</span></span><span class="koboSpan" id="kobo.956.1">):
        min_user[</span><span class="hljs-string"><span class="koboSpan" id="kobo.957.1">"name"</span></span><span class="koboSpan" id="kobo.958.1">] = </span><span class="hljs-string"><span class="koboSpan" id="kobo.959.1">" \n\t"</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.960.1">assert</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.961.1">not</span></span><span class="koboSpan" id="kobo.962.1"> is_valid(min_user)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.963.1">
     These three tests still belong to the same class.
    </span>
    <span class="koboSpan" id="kobo.963.2">
     The first one tests whether a user is invalid when one of the mandatory fields is missing.
    </span>
    <span class="koboSpan" id="kobo.963.3">
     Remember that at every test run, the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.964.1">
      min_user
     </span>
    </code>
    <span class="koboSpan" id="kobo.965.1">
     fixture is restored, so we only have one missing field per test run, which is the appropriate way to check for mandatory fields.
    </span>
    <span class="koboSpan" id="kobo.965.2">
     We simply remove that one key from the dictionary.
    </span>
    <span class="koboSpan" id="kobo.965.3">
     This time, the
    </span>
    <a id="_idIndexMarker977">
    </a>
    <span class="koboSpan" id="kobo.966.1">
     parametrization object takes the name
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.967.1">
      field
     </span>
    </code>
    <span class="koboSpan" id="kobo.968.1">
     , and, by looking at the first test, you see all the mandatory fields in the parametrization decorator:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.969.1">
      email
     </span>
    </code>
    <span class="koboSpan" id="kobo.970.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.971.1">
      name
     </span>
    </code>
    <span class="koboSpan" id="kobo.972.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.973.1">
      age
     </span>
    </code>
    <span class="koboSpan" id="kobo.974.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.975.1">
     In the second one, things are a little different.
    </span>
    <span class="koboSpan" id="kobo.975.2">
     Instead of removing keys, we simply set them (one at a time) to the empty string.
    </span>
    <span class="koboSpan" id="kobo.975.3">
     Finally, in the third one, we check for the name to be made of whitespace only.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.976.1">
     The previous tests take care of mandatory fields being there and being non-empty, and of the formatting around the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.977.1">
      name
     </span>
    </code>
    <span class="koboSpan" id="kobo.978.1">
     key of a user.
    </span>
    <span class="koboSpan" id="kobo.978.2">
     Let us now write the last two tests for this class.
    </span>
    <span class="koboSpan" id="kobo.978.3">
     We want to check that email is valid, and in the second one, the type for email, name, and role:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.979.1"># tests/test_api.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.980.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.981.1">TestIsValid</span></span><span class="koboSpan" id="kobo.982.1">:
    ...
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.983.1">    @pytest.mark.parametrize(</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.984.1">        (</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.985.1">"email"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.986.1">, </span></span><span class="hljs-string"><span class="koboSpan" id="kobo.987.1">"outcome"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.988.1">),</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.989.1">        [</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.990.1">            (</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.991.1">"missing_at.com"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.992.1">, </span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.993.1">False</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.994.1">),</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.995.1">            (</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.996.1">"@missing_start.com"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.997.1">, </span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.998.1">False</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.999.1">),</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1000.1">            (</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1001.1">"missing_end@"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1002.1">, </span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.1003.1">False</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1004.1">),</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1005.1">            (</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1006.1">"missing_dot@example"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1007.1">, </span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.1008.1">False</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1009.1">),</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1010.1">            (</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1011.1">"good.one@example.com"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1012.1">, </span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.1013.1">True</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1014.1">),</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1015.1">            (</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1016.1">"δοκιμή@παράδειγμα.δοκιμή"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1017.1">, </span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.1018.1">True</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1019.1">),</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1020.1">            (</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1021.1">"аджай@экзампл.рус"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1022.1">, </span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.1023.1">True</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1024.1">),</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1025.1">        ],</span></span>
<span class="hljs-params">    </span><span class="hljs-meta"><span class="koboSpan" id="kobo.1026.1">)</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.1027.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1028.1">test_email</span></span><span class="koboSpan" id="kobo.1029.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1030.1">self, email, outcome, min_user</span></span><span class="koboSpan" id="kobo.1031.1">):
        min_user[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1032.1">"email"</span></span><span class="koboSpan" id="kobo.1033.1">] = email
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1034.1">assert</span></span><span class="koboSpan" id="kobo.1035.1"> is_valid(min_user) == outcome
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1036.1">
     This time, the parametrization is slightly more complex.
    </span>
    <span class="koboSpan" id="kobo.1036.2">
     We define two objects (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1037.1">
      email
     </span>
    </code>
    <span class="koboSpan" id="kobo.1038.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1039.1">
      outcome
     </span>
    </code>
    <span class="koboSpan" id="kobo.1040.1">
     ) and then we pass a list of tuples, instead of a simple list, to the decorator.
    </span>
    <span class="koboSpan" id="kobo.1040.2">
     Each time the test is run, one of those tuples will be unpacked to fill the values of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1041.1">
      email
     </span>
    </code>
    <span class="koboSpan" id="kobo.1042.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1043.1">
      outcome
     </span>
    </code>
    <span class="koboSpan" id="kobo.1044.1">
     , respectively.
    </span>
    <span class="koboSpan" id="kobo.1044.2">
     This allows us to write one test for both valid and invalid email addresses, instead of two separate ones.
    </span>
    <span class="koboSpan" id="kobo.1044.3">
     We define an email address, and we specify the outcome we expect from validation.
    </span>
    <span class="koboSpan" id="kobo.1044.4">
     The first four are invalid email addresses, and the last three are valid.
    </span>
    <span class="koboSpan" id="kobo.1044.5">
     We have used a couple of examples with non-ASCII characters, just to make sure we are not forgetting to include our friends from all over the world in the validation.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1045.1">
     Notice how the validation is done, asserting that the result of the call needs to match the outcome we have set.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1046.1">
     Let us now write a simple test to make sure validation fails when we feed the wrong type to the fields (again, the age has been taken care of separately before):
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1047.1"># tests/test_api.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1048.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1049.1">TestIsValid</span></span><span class="koboSpan" id="kobo.1050.1">:
    ...
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.1051.1">    @pytest.mark.parametrize(</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1052.1">        (</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1053.1">"field", "value"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1054.1">),</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1055.1">        [</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1056.1">            (</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1057.1">"email"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1058.1">, </span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.1059.1">None</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1060.1">),</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1061.1">            (</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1062.1">"email"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1063.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1064.1">3.1415</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1065.1">),</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1066.1">            (</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1067.1">"email"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1068.1">, {}),</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1069.1">            (</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1070.1">"name"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1071.1">, </span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.1072.1">None</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1073.1">),</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1074.1">            (</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1075.1">"name"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1076.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1077.1">3.1415</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1078.1">),</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1079.1">            (</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1080.1">"name"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1081.1">, {}),</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1082.1">            (</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1083.1">"role"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1084.1">, </span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.1085.1">None</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1086.1">),</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1087.1">            (</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1088.1">"role"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1089.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1090.1">3.1415</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1091.1">),</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1092.1">            (</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1093.1">"role"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1094.1">, {}),</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1095.1">        ],</span></span>
<span class="hljs-params">    </span><span class="hljs-meta"><span class="koboSpan" id="kobo.1096.1">)</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.1097.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1098.1">test_invalid_types</span></span><span class="koboSpan" id="kobo.1099.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1100.1">self, field, value, min_user</span></span><span class="koboSpan" id="kobo.1101.1">):
        min_user[field] = value
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1102.1">assert</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1103.1">not</span></span><span class="koboSpan" id="kobo.1104.1"> is_valid(min_user)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1105.1">
     As we did before, we pass
    </span>
    <a id="_idIndexMarker978">
    </a>
    <span class="koboSpan" id="kobo.1106.1">
     three different values, none of which is actually a string.
    </span>
    <span class="koboSpan" id="kobo.1106.2">
     This test could be expanded to include more values, but, honestly, we shouldn’t need to write tests such as this one.
    </span>
    <span class="koboSpan" id="kobo.1106.3">
     We have included it here just to show you what’s possible, but normally you would focus on making sure the code considers valid types, those that have to be considered valid, and that should be enough.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1107.1">
     Before we move to the next test class, let us take a moment to talk a bit more about something we briefly touched on when testing the age.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-277">
    <span class="koboSpan" id="kobo.1108.1">
     Boundaries and granularity
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.1109.1">
     While checking for the age, we wrote three tests to cover the three ranges: 0-17 (fail), 18-65 (success), and 66-99 (fail).
    </span>
    <span class="koboSpan" id="kobo.1109.2">
     Why did we do this?
    </span>
    <span class="koboSpan" id="kobo.1109.3">
     The answer lies in the fact that we are dealing with two boundaries: 18 and 65.
    </span>
    <span class="koboSpan" id="kobo.1109.4">
     So, our testing needs to focus on the three regions those two boundaries define: before 18, within 18 and 65, and after 65.
    </span>
    <span class="koboSpan" id="kobo.1109.5">
     How you do it is not important, as long as you make sure you test the boundaries correctly.
    </span>
    <span class="koboSpan" id="kobo.1109.6">
     This means if someone changes the validation in the schema from
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1110.1">
      18 &lt;= value &lt;= 65
     </span>
    </code>
    <span class="koboSpan" id="kobo.1111.1">
     to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1112.1">
      18 &lt;= value &lt; 65
     </span>
    </code>
    <span class="koboSpan" id="kobo.1113.1">
     (notice the second
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1114.1">
      &lt;=
     </span>
    </code>
    <span class="koboSpan" id="kobo.1115.1">
     is now
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1116.1">
      &lt;
     </span>
    </code>
    <span class="koboSpan" id="kobo.1117.1">
     ), there must be a test that fails on 65.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1118.1">
     This concept is known as a
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1119.1">
      boundary
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1120.1">
     , and it is
    </span>
    <a id="_idIndexMarker979">
    </a>
    <span class="koboSpan" id="kobo.1121.1">
     crucial that you recognize them in your code so that you can test against them.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1122.1">
     Another important thing is to understand how close to the boundaries to get.
    </span>
    <span class="koboSpan" id="kobo.1122.2">
     In other words, which unit should I use to approach them?
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1123.1">
     In the case of age, we are dealing with integers, so a unit of 1 will be the perfect choice (which is why we used 16, 17, 18, 19, 20, ...).
    </span>
    <span class="koboSpan" id="kobo.1123.2">
     But what if you were testing for a timestamp?
    </span>
    <span class="koboSpan" id="kobo.1123.3">
     Well, in that case, the correct granularity will likely be different.
    </span>
    <span class="koboSpan" id="kobo.1123.4">
     If the code has to act differently according to your timestamp and that timestamp represents seconds, then the granularity of your tests should zoom down to seconds.
    </span>
    <span class="koboSpan" id="kobo.1123.5">
     If the timestamp represents years, then years should be the unit you use.
    </span>
    <span class="koboSpan" id="kobo.1123.6">
     We hope you get the picture.
    </span>
    <span class="koboSpan" id="kobo.1123.7">
     This concept is known
    </span>
    <a id="_idIndexMarker980">
    </a>
    <span class="koboSpan" id="kobo.1124.1">
     as
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1125.1">
      granularity
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1126.1">
     and needs to be combined with that of boundaries so that by going around the boundaries with the correct granularity, you can make sure your tests are not leaving anything to chance.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1127.1">
     Let us now continue with our example and test the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1128.1">
      export
     </span>
    </code>
    <span class="koboSpan" id="kobo.1129.1">
     function.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-278">
    <span class="koboSpan" id="kobo.1130.1">
     Testing the export function
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.1131.1">
     In the same test module, we defined another
    </span>
    <a id="_idIndexMarker981">
    </a>
    <span class="koboSpan" id="kobo.1132.1">
     class that represents a test suite for the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1133.1">
      export()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1134.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.1134.2">
     Here it is:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1135.1"># tests/test_api.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1136.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1137.1">TestExport</span></span><span class="koboSpan" id="kobo.1138.1">:
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1139.1">"""Test behavior of `export` function."""</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.1140.1">    @pytest.fixture</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.1141.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1142.1">csv_file</span></span><span class="koboSpan" id="kobo.1143.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1144.1">self, tmp_path</span></span><span class="koboSpan" id="kobo.1145.1">):
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.1146.1">"""Yield a filename in a temporary folder.</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1147.1">        Due to how pytest `tmp_path` fixture works, the file does</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1148.1">        not exist yet.</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1149.1">        """</span></span><span class="koboSpan" id="kobo.1150.1">
        csv_path = tmp_path / </span><span class="hljs-string"><span class="koboSpan" id="kobo.1151.1">"out.csv"</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.1152.1">yield</span></span><span class="koboSpan" id="kobo.1153.1"> csv_path
        csv_path.unlink(missing_ok=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1154.1">True</span></span><span class="koboSpan" id="kobo.1155.1">)
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.1156.1">    @pytest.fixture</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.1157.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1158.1">existing_file</span></span><span class="koboSpan" id="kobo.1159.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1160.1">self, tmp_path</span></span><span class="koboSpan" id="kobo.1161.1">):
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.1162.1">"""</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1163.1">Create a temporary file and put some content in it."""</span></span><span class="koboSpan" id="kobo.1164.1">
        existing = tmp_path / </span><span class="hljs-string"><span class="koboSpan" id="kobo.1165.1">"existing.csv"</span></span><span class="koboSpan" id="kobo.1166.1">
        existing.write_text(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1167.1">"Please leave me alone..."</span></span><span class="koboSpan" id="kobo.1168.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1169.1">return</span></span><span class="koboSpan" id="kobo.1170.1"> existing
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1171.1">
     Let us start by analyzing the fixtures.
    </span>
    <span class="koboSpan" id="kobo.1171.2">
     We have defined them at the class level this time, which means they will be available for the tests in the same class.
    </span>
    <span class="koboSpan" id="kobo.1171.3">
     We do not need these fixtures outside of this class, so it does not make sense to declare them at a module level as we did with the user ones.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1172.1">
     We need two files.
    </span>
    <span class="koboSpan" id="kobo.1172.2">
     If you recall what we wrote at the beginning of this chapter, when it comes to interaction with databases, disks, networks, and so on, we should
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1173.1">
      mock
     </span>
    </code>
    <span class="koboSpan" id="kobo.1174.1">
     everything out.
    </span>
    <span class="koboSpan" id="kobo.1174.2">
     However, when possible, we prefer to use a different technique.
    </span>
    <span class="koboSpan" id="kobo.1174.3">
     In this case, we will employ temporary folders, which will be created and deleted within the fixture.
    </span>
    <span class="koboSpan" id="kobo.1174.4">
     We are much happier if we can avoid mocking.
    </span>
    <span class="koboSpan" id="kobo.1174.5">
     To create temporary folders, we employ the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1175.1">
      tmp_path
     </span>
    </code>
    <span class="koboSpan" id="kobo.1176.1">
     fixture, from
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1177.1">
      pytest
     </span>
    </code>
    <span class="koboSpan" id="kobo.1178.1">
     , which is a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1179.1">
      pathlib.Path
     </span>
    </code>
    <span class="koboSpan" id="kobo.1180.1">
     object.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1181.1">
     The first fixture,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1182.1">
      csv_file()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1183.1">
     , provides a reference to a temporary folder.
    </span>
    <span class="koboSpan" id="kobo.1183.2">
     We can consider the logic up to and including the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1184.1">
      yield
     </span>
    </code>
    <span class="koboSpan" id="kobo.1185.1">
     as the setup phase.
    </span>
    <span class="koboSpan" id="kobo.1185.2">
     The fixture itself, in terms of data, is represented by the temporary filename.
    </span>
    <span class="koboSpan" id="kobo.1185.3">
     The file itself does not exist yet.
    </span>
    <span class="koboSpan" id="kobo.1185.4">
     When a test runs, the fixture is created, and at the end of the test, the rest of the fixture code (the part after
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1186.1">
      yield
     </span>
    </code>
    <span class="koboSpan" id="kobo.1187.1">
     , if any) is executed.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1188.1">
     That part can be considered the teardown phase.
    </span>
    <span class="koboSpan" id="kobo.1188.2">
     In the case of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1189.1">
      csv_file()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1190.1">
     fixture, it consists of calling
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1191.1">
      csv_path.unlink()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1192.1">
     to delete the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1193.1">
      .csv
     </span>
    </code>
    <span class="koboSpan" id="kobo.1194.1">
     file (if it exists).
    </span>
    <span class="koboSpan" id="kobo.1194.2">
     You can put much more in each phase of any fixture, and with experience, you will master the art of doing setup and teardown this way.
    </span>
    <span class="koboSpan" id="kobo.1194.3">
     It comes naturally quite quickly.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.1195.1">
      It is not strictly necessary to delete the
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1196.1">
       .csv
      </span>
     </code>
     <span class="koboSpan" id="kobo.1197.1">
      file after each test.
     </span>
     <span class="koboSpan" id="kobo.1197.2">
      The
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1198.1">
       tmp_path
      </span>
     </code>
     <span class="koboSpan" id="kobo.1199.1">
      fixture will create a new temporary directory for each test, so there is no risk of files created within this directory interfering with other tests.
     </span>
     <span class="koboSpan" id="kobo.1199.2">
      We chose to delete the file in this fixture only to demonstrate the use of
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1200.1">
       yield
      </span>
     </code>
     <span class="koboSpan" id="kobo.1201.1">
      in fixtures.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.1202.1">
     The second fixture,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1203.1">
      existing_file()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1204.1">
     , is quite similar to the first one, but we will use it to test that we can prevent overwriting when we call
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1205.1">
      export()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1206.1">
     with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1207.1">
      overwrite=False
     </span>
    </code>
    <span class="koboSpan" id="kobo.1208.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1208.2">
     So, we create a file in the temporary folder, and we put some content into it, just to have the means to verify it
    </span>
    <a id="_idIndexMarker982">
    </a>
    <span class="koboSpan" id="kobo.1209.1">
     hasn’t been touched.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1210.1">
     Let us now see the tests (as we did before, we include the class declaration but omit tests which we already presented):
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1211.1"># tests/test_api.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1212.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1213.1">TestExport</span></span><span class="koboSpan" id="kobo.1214.1">:
    ...
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1215.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1216.1">test_export</span></span><span class="koboSpan" id="kobo.1217.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1218.1">self, users, csv_file</span></span><span class="koboSpan" id="kobo.1219.1">):
        export(csv_file, users)
        text = csv_file.read_text()
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1220.1">assert</span></span><span class="koboSpan" id="kobo.1221.1"> (
            </span><span class="hljs-string"><span class="koboSpan" id="kobo.1222.1">"email,name,age,role\n"</span></span>
            <span class="hljs-string"><span class="koboSpan" id="kobo.1223.1">"minimal@example.com,Primus Minimus,18,\n"</span></span>
            <span class="hljs-string"><span class="koboSpan" id="kobo.1224.1">"full@example.com,Maximus Plenus,65,emperor\n"</span></span><span class="koboSpan" id="kobo.1225.1">
        ) == text
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1226.1">
     This test employs the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1227.1">
      users()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1228.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1229.1">
      csv_file()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1230.1">
     fixtures, and immediately calls
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1231.1">
      export()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1232.1">
     with them.
    </span>
    <span class="koboSpan" id="kobo.1232.2">
     We expect that a file has been created, and populated with the two valid users we have (remember the list contains three users, but one is invalid).
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1233.1">
     To verify that, we open the temporary file and collect all its text into a string.
    </span>
    <span class="koboSpan" id="kobo.1233.2">
     We then compare the content of the file with what we expect to be in it.
    </span>
    <span class="koboSpan" id="kobo.1233.3">
     Notice we only put the header, and the two valid users, in the correct order.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1234.1">
     Now we need another test to make sure that if there is a comma in one of the values, our CSV is still generated correctly.
    </span>
    <span class="koboSpan" id="kobo.1234.2">
     Being a
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1235.1">
      CSV
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1236.1">
     file, we need to make sure that a comma in the data does not
    </span>
    <a id="_idIndexMarker983">
    </a>
    <span class="koboSpan" id="kobo.1237.1">
     break things up:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1238.1"># tests/test_api.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1239.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1240.1">TestExport</span></span><span class="koboSpan" id="kobo.1241.1">:
    ...
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1242.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1243.1">test_export_quoting</span></span><span class="koboSpan" id="kobo.1244.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1245.1">self, min_user, csv_file</span></span><span class="koboSpan" id="kobo.1246.1">):
        min_user[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1247.1">"name"</span></span><span class="koboSpan" id="kobo.1248.1">] = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1249.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1250.1">A name, with a comma"</span></span><span class="koboSpan" id="kobo.1251.1">
        export(csv_file, [min_user])
        text = csv_file.read_text()
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1252.1">assert</span></span><span class="koboSpan" id="kobo.1253.1"> (
            </span><span class="hljs-string"><span class="koboSpan" id="kobo.1254.1">"email,name,age,role\n"</span></span>
            <span class="hljs-string"><span class="koboSpan" id="kobo.1255.1">'minimal@example.com,"A name, with a comma",18,\n'</span></span><span class="koboSpan" id="kobo.1256.1">
        ) == text
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1257.1">
     This time, we do not need the whole users list; we just need one, as we are testing a specific thing and we have the previous test to make sure we are generating the file correctly with all the users.
    </span>
    <span class="koboSpan" id="kobo.1257.2">
     Remember, always try to minimize the work you do within a test.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1258.1">
     So, we use
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1259.1">
      min_user()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1260.1">
     and put a comma in its name.
    </span>
    <span class="koboSpan" id="kobo.1260.2">
     We then repeat the procedure, which is similar to that of the previous test, and finally, we make sure that the name is put in the CSV file surrounded by double quotes.
    </span>
    <span class="koboSpan" id="kobo.1260.3">
     This is enough for any good CSV parser to understand that they should not break the comma inside the double quotes.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1261.1">
     Now, we want one more test, to check that when the file already exists and we do not want to override it, our code won’t do that:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1262.1"># tests/test_api.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1263.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1264.1">TestExport</span></span><span class="koboSpan" id="kobo.1265.1">:
    ...
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1266.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1267.1">test_does_not_overwrite</span></span><span class="koboSpan" id="kobo.1268.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1269.1">self, users, existing_file</span></span><span class="koboSpan" id="kobo.1270.1">):
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1271.1">with</span></span><span class="koboSpan" id="kobo.1272.1"> pytest.raises(IOError) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1273.1">as</span></span><span class="koboSpan" id="kobo.1274.1"> err:
            export(existing_file, users, overwrite=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1275.1">False</span></span><span class="koboSpan" id="kobo.1276.1">)
        err.</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1277.1">match</span></span><span class="koboSpan" id="kobo.1278.1">(
            </span><span class="hljs-string"><span class="koboSpan" id="kobo.1279.1">r"'{}' already exists\."</span></span><span class="koboSpan" id="kobo.1280.1">.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1281.1">format</span></span><span class="koboSpan" id="kobo.1282.1">(
                re.escape(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1283.1">str</span></span><span class="koboSpan" id="kobo.1284.1">(existing_file))
            )
        )
        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1285.1"># let us also verify the file is still intact</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.1286.1">assert</span></span><span class="koboSpan" id="kobo.1287.1"> existing_file.read_text() == (
            </span><span class="hljs-string"><span class="koboSpan" id="kobo.1288.1">"Please leave me alone..."</span></span><span class="koboSpan" id="kobo.1289.1">
        )
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1290.1">
     This is an interesting test because it allows us to show you how you can tell
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1291.1">
      pytest
     </span>
    </code>
    <span class="koboSpan" id="kobo.1292.1">
     that you expect a function call to raise an exception.
    </span>
    <span class="koboSpan" id="kobo.1292.2">
     We do it in the context manager given to us by
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1293.1">
      pytest.raises()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1294.1">
     , to which we feed the exception we expect from the call we make inside the body of that context manager.
    </span>
    <span class="koboSpan" id="kobo.1294.2">
     If the exception is not raised, the test will fail.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1295.1">
     We like to be thorough in our tests, so we do not want to stop there.
    </span>
    <span class="koboSpan" id="kobo.1295.2">
     We also assert on the message, by using the convenient
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1296.1">
      err.match()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1297.1">
     helper.
    </span>
    <span class="koboSpan" id="kobo.1297.2">
     Notice that we do not need to use an
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1298.1">
      assert
     </span>
    </code>
    <span class="koboSpan" id="kobo.1299.1">
     statement when calling
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1300.1">
      err.match()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1301.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1301.2">
     If the argument does not match, the call will raise an
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1302.1">
      AssertionError
     </span>
    </code>
    <span class="koboSpan" id="kobo.1303.1">
     , causing the test to fail.
    </span>
    <span class="koboSpan" id="kobo.1303.2">
     We also need to escape the string version of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1304.1">
      existing_file
     </span>
    </code>
    <span class="koboSpan" id="kobo.1305.1">
     because on Windows, paths have backslashes, which would confuse the
    </span>
    <a id="_idIndexMarker984">
    </a>
    <span class="koboSpan" id="kobo.1306.1">
     regular expression we feed to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1307.1">
      err.match()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1308.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1309.1">
     Finally, we make sure that the file still contains its original content (which is why we created the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1310.1">
      existing_file()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1311.1">
     fixture) by reading it and comparing its content to the string we originally wrote to the file.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-279">
    <span class="koboSpan" id="kobo.1312.1">
     Final considerations
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.1313.1">
     Before we move on to the next topic, let
    </span>
    <a id="_idIndexMarker985">
    </a>
    <span class="koboSpan" id="kobo.1314.1">
     us wrap up with some considerations.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1315.1">
     First, we hope you have noticed that we haven’t tested all the functions we wrote.
    </span>
    <span class="koboSpan" id="kobo.1315.2">
     Specifically, we didn’t test
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1316.1">
      get_valid_users()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1317.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1318.1">
      validate()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1319.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1320.1">
      write_csv()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1321.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1321.2">
     The reason is that these functions are already implicitly tested by our test suite.
    </span>
    <span class="koboSpan" id="kobo.1321.3">
     We have tested
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1322.1">
      is_valid()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1323.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1324.1">
      export()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1325.1">
     , which is more than enough to make sure the schema is validating users correctly, and that the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1326.1">
      export()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1327.1">
     function is filtering out invalid users, respecting existing files when needed, and writing a proper CSV.
    </span>
    <span class="koboSpan" id="kobo.1327.2">
     The functions we haven’t tested are the internals; they provide logic that participates in doing something that we have thoroughly tested anyway.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1328.1">
     Would adding extra tests for those functions be good or bad?
    </span>
    <span class="koboSpan" id="kobo.1328.2">
     The answer is actually difficult.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1329.1">
     The more we test, the less easily we can refactor that code.
    </span>
    <span class="koboSpan" id="kobo.1329.2">
     As it is now, we could easily decide to rename
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1330.1">
      validate()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1331.1">
     , and we wouldn’t have to change any of the tests we wrote.
    </span>
    <span class="koboSpan" id="kobo.1331.2">
     If you think about it, it makes sense, because as long as
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1332.1">
      validate()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1333.1">
     provides correct validation to the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1334.1">
      get_valid_users()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1335.1">
     function, we do not really need to know about it.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1336.1">
     If, instead, we had written tests for the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1337.1">
      validate()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1338.1">
     function, then we would have to change them, had we decided to rename it (or to change its signature, for example).
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1339.1">
     So, what is the right thing to do?
    </span>
    <span class="koboSpan" id="kobo.1339.2">
     Tests or no tests?
    </span>
    <span class="koboSpan" id="kobo.1339.3">
     It will be up to you.
    </span>
    <span class="koboSpan" id="kobo.1339.4">
     You have to find the right balance.
    </span>
    <span class="koboSpan" id="kobo.1339.5">
     Our personal take on this matter is that everything needs to be thoroughly tested, either directly or indirectly.
    </span>
    <span class="koboSpan" id="kobo.1339.6">
     We try to write the smallest possible test suite that guarantees that.
    </span>
    <span class="koboSpan" id="kobo.1339.7">
     This way, we will have a complete test suite in terms of coverage, but not any bigger than necessary.
    </span>
    <span class="koboSpan" id="kobo.1339.8">
     We need to maintain those tests.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1340.1">
     We hope this example made sense to you; we think it has allowed us to touch on the important topics.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1341.1">
     If you check out the source
    </span>
    <a id="_idIndexMarker986">
    </a>
    <span class="koboSpan" id="kobo.1342.1">
     code for the book, in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1343.1">
      test_api.py
     </span>
    </code>
    <span class="koboSpan" id="kobo.1344.1">
     module, you will find a couple of extra test classes that will show you how different testing would have been had we decided to go all the way with the mocks.
    </span>
    <span class="koboSpan" id="kobo.1344.2">
     Make sure you read that code and understand it well.
    </span>
    <span class="koboSpan" id="kobo.1344.3">
     It is quite straightforward and will offer you a good comparison with the approach we have shown you here.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1345.1">
     Let us now run the full test suite:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1346.1">$ pytest tests
====================== test session starts ======================
platform darwin -- Python 3.12.2, pytest-8.1.1, pluggy-1.4.0
rootdir: /Users/fab/code/lpp4ed
configfile: pyproject.toml
collected 132 items
tests/test_api.py ..............................................
</span><span class="koboSpan" id="kobo.1346.2">................................................................
</span><span class="koboSpan" id="kobo.1346.3">......................                                    </span><span class="koboSpan" id="kobo.1346.4">[100%]
====================== 132 passed in 0.14s ======================
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1347.1">
     As mentioned before, make sure you run
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1348.1">
      $ pytest test
     </span>
    </code>
    <span class="koboSpan" id="kobo.1349.1">
     from within the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1350.1">
      ch10
     </span>
    </code>
    <span class="koboSpan" id="kobo.1351.1">
     folder (add the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1352.1">
      -vv
     </span>
    </code>
    <span class="koboSpan" id="kobo.1353.1">
     flag for a verbose output that will show you how parametrization modifies the names of your tests).
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1354.1">
      pytest
     </span>
    </code>
    <span class="koboSpan" id="kobo.1355.1">
     scans your files and folders, searching for modules that start or end with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1356.1">
      test_
     </span>
    </code>
    <span class="koboSpan" id="kobo.1357.1">
     , like
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1358.1">
      test_*.py
     </span>
    </code>
    <span class="koboSpan" id="kobo.1359.1">
     or
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1360.1">
      *_test.py
     </span>
    </code>
    <span class="koboSpan" id="kobo.1361.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1361.2">
     Within those modules, it grabs
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1362.1">
      test
     </span>
    </code>
    <span class="koboSpan" id="kobo.1363.1">
     -prefixed functions or
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1364.1">
      test
     </span>
    </code>
    <span class="koboSpan" id="kobo.1365.1">
     -prefixed methods inside
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1366.1">
      Test
     </span>
    </code>
    <span class="koboSpan" id="kobo.1367.1">
     -prefixed classes (you can read the full specification in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1368.1">
      pytest
     </span>
    </code>
    <span class="koboSpan" id="kobo.1369.1">
     documentation).
    </span>
    <span class="koboSpan" id="kobo.1369.2">
     As you can see, 132 tests were run in 140 milliseconds, and they all succeeded.
    </span>
    <span class="koboSpan" id="kobo.1369.3">
     We strongly suggest you check out this code and experiment with it.
    </span>
    <span class="koboSpan" id="kobo.1369.4">
     Change something in the code and see whether any test fails.
    </span>
    <span class="koboSpan" id="kobo.1369.5">
     Understand why it fails (or does not).
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1370.1">
     Did the tests pass even though the code is no longer correct?
    </span>
    <span class="koboSpan" id="kobo.1370.2">
     Are the tests too rigid and failing even when you make a change that does not affect the correctness of the output?
    </span>
    <span class="koboSpan" id="kobo.1370.3">
     Thinking about these questions will help you gain a deeper insight into the art of testing.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1371.1">
     We also suggest you
    </span>
    <a id="_idIndexMarker987">
    </a>
    <span class="koboSpan" id="kobo.1372.1">
     study the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1373.1">
      unittest
     </span>
    </code>
    <span class="koboSpan" id="kobo.1374.1">
     module, and the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1375.1">
      pytest
     </span>
    </code>
    <span class="koboSpan" id="kobo.1376.1">
     library too.
    </span>
    <span class="koboSpan" id="kobo.1376.2">
     These are tools you will use all the time, so you need to be familiar with them.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1377.1">
     Let us now discuss TDD.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-280">
    <span class="koboSpan" id="kobo.1378.1">
     Test-driven development
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.1379.1">
     Let
    </span>
    <a id="_idIndexMarker988">
    </a>
    <span class="koboSpan" id="kobo.1380.1">
     us talk briefly about
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1381.1">
      TDD
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1382.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1382.2">
     It is a methodology that was rediscovered by Kent Beck, who wrote
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1383.1">
      Test-Driven Development by Example, Addison Wesley, 2002
     </span>
    </em>
    <span class="koboSpan" id="kobo.1384.1">
     , which we encourage you to read if you want to learn about the fundamentals of this subject.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1385.1">
     TDD is a software development methodology that is based on the continuous repetition of a very short development cycle.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1386.1">
     First, the developer writes a test and makes it run.
    </span>
    <span class="koboSpan" id="kobo.1386.2">
     The test is supposed to check a feature that is not yet part of the code.
    </span>
    <span class="koboSpan" id="kobo.1386.3">
     Maybe it is a new feature to be added or something to be removed or amended.
    </span>
    <span class="koboSpan" id="kobo.1386.4">
     Running the test will make it fail and, because of this, this phase is called
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1387.1">
      Red
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1388.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1389.1">
     The developer then writes the minimal amount of code to make the test pass.
    </span>
    <span class="koboSpan" id="kobo.1389.2">
     When the test run succeeds, we have the so-called
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1390.1">
      Green
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1391.1">
     phase.
    </span>
    <span class="koboSpan" id="kobo.1391.2">
     In this phase, it is okay to write code that cheats, just to make the test pass.
    </span>
    <span class="koboSpan" id="kobo.1391.3">
     This technique is called
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1392.1">
      fake it ‘til you make it
     </span>
    </em>
    <span class="koboSpan" id="kobo.1393.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1393.2">
     In a second iteration of the TDD cycle, tests are enriched with different edge cases, and if there is any cheating code, it will not be able to satisfy all the tests simultaneously, therefore the developer will have to write the actual logic that satisfies the tests.
    </span>
    <span class="koboSpan" id="kobo.1393.3">
     Adding other test cases is sometimes
    </span>
    <a id="_idIndexMarker989">
    </a>
    <span class="koboSpan" id="kobo.1394.1">
     called
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1395.1">
      triangulation
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1396.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1397.1">
     The last piece of the cycle is where the developer takes care of refactoring code and tests until they are in the desired state.
    </span>
    <span class="koboSpan" id="kobo.1397.2">
     This last phase is called
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1398.1">
      Refactor
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1399.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1400.1">
     The TDD mantra
    </span>
    <a id="_idIndexMarker990">
    </a>
    <span class="koboSpan" id="kobo.1401.1">
     therefore is
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1402.1">
      Red-Green-Refactor
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1403.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1404.1">
     At first, it might feel weird to write tests before the code, and we must confess it took us a while to get used to it.
    </span>
    <span class="koboSpan" id="kobo.1404.2">
     If you stick to it, though, and force yourself to learn this slightly counterintuitive method, at some point, something almost magical happens, and you will see the quality of your code increase in a way that would not have been possible otherwise.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1405.1">
     When we write our code before the tests, we must take care of
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1406.1">
      what
     </span>
    </em>
    <span class="koboSpan" id="kobo.1407.1">
     the code has to do and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1408.1">
      how
     </span>
    </em>
    <span class="koboSpan" id="kobo.1409.1">
     it has to do it, both at the same time.
    </span>
    <span class="koboSpan" id="kobo.1409.2">
     On the other hand, when we write tests before the code, we can concentrate on the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1410.1">
      what
     </span>
    </em>
    <span class="koboSpan" id="kobo.1411.1">
     part almost exclusively.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1412.1">
     Afterward, when we write the code, we will mostly have to take care of
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1413.1">
      how
     </span>
    </em>
    <span class="koboSpan" id="kobo.1414.1">
     the code has to implement
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1415.1">
      what
     </span>
    </em>
    <span class="koboSpan" id="kobo.1416.1">
     is required by the tests.
    </span>
    <span class="koboSpan" id="kobo.1416.2">
     This shift in focus allows our minds to concentrate on the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1417.1">
      what
     </span>
    </em>
    <span class="koboSpan" id="kobo.1418.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1419.1">
      how
     </span>
    </em>
    <span class="koboSpan" id="kobo.1420.1">
     parts separately, yielding a brainpower boost that can feel quite surprising.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1421.1">
     There are several other benefits
    </span>
    <a id="_idIndexMarker991">
    </a>
    <span class="koboSpan" id="kobo.1422.1">
     that come from the adoption of this technique:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1423.1">
       Improved code quality
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1424.1">
      : Writing tests first ensures that the codebase is thoroughly tested and can lead to fewer bugs and errors in the production code.
     </span>
     <span class="koboSpan" id="kobo.1424.2">
      It encourages developers to write only the code necessary to pass tests, which can result in cleaner, simpler code.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1425.1">
       Better design decisions
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1426.1">
      : TDD encourages developers to think about the design and structure of the code from the beginning.
     </span>
     <span class="koboSpan" id="kobo.1426.2">
      This early consideration can lead to better software design and architecture.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1427.1">
       Facilitates refactoring
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1428.1">
      : With a comprehensive suite of tests in place, developers can confidently refactor and improve the code, knowing that the tests will catch any regressions or issues introduced by changes.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1429.1">
       Documentation
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1430.1">
      : The tests themselves serve as documentation for the codebase.
     </span>
     <span class="koboSpan" id="kobo.1430.2">
      They describe what the code is supposed to do, which can be helpful for new team members or when revisiting old code.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1431.1">
       Reduces time spent on debugging
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1432.1">
      : By catching errors early in the development process, TDD can reduce the amount of time developers spend debugging code.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1433.1">
       Better understanding of business requirements
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1434.1">
      : Having a suite of tests that pass gives developers confidence that their code meets the required specifications and behaves
     </span>
     <a id="_idIndexMarker992">
     </a>
     <span class="koboSpan" id="kobo.1435.1">
      as expected.
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.1436.1">
     On the other hand, there are some shortcomings
    </span>
    <a id="_idIndexMarker993">
    </a>
    <span class="koboSpan" id="kobo.1437.1">
     of this technique:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1438.1">
       Initial slowdown
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1439.1">
      : Writing tests before writing functional code can slow down the initial development process.
     </span>
     <span class="koboSpan" id="kobo.1439.2">
      This can be particularly challenging in fast-paced development environments or for tight deadlines.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1440.1">
       Learning curve
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1441.1">
      : TDD requires a different mindset and approach to coding than what many developers are accustomed to.
     </span>
     <span class="koboSpan" id="kobo.1441.2">
      There can be a significant learning curve, and developers may initially find it difficult to write effective tests.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1442.1">
       Overhead for simple changes
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1443.1">
      : For very simple changes or fixes, the overhead of writing a test first can seem unnecessary and time-consuming.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1444.1">
       Difficulty with complex UI or external systems
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1445.1">
      : Testing can become challenging when dealing with complex UIs or interactions with external systems, databases, or APIs.
     </span>
     <span class="koboSpan" id="kobo.1445.2">
      Mocking and stubbing can help, but they also add complexity and
     </span>
     <a id="_idIndexMarker994">
     </a>
     <span class="koboSpan" id="kobo.1446.1">
      maintenance overhead.
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.1447.1">
     We are quite passionate about TDD.
    </span>
    <span class="koboSpan" id="kobo.1447.2">
     However, through years of application, we have encountered scenarios where TDD proves to be less feasible.
    </span>
    <span class="koboSpan" id="kobo.1447.3">
     A prime example is when faced with test suites comprising hundreds or even thousands of tests.
    </span>
    <span class="koboSpan" id="kobo.1447.4">
     In such instances, predetermining the specific tests to alter for a desired change in the source code becomes an almost insurmountable task.
    </span>
    <span class="koboSpan" id="kobo.1447.5">
     It may, at times, be more pragmatic to directly modify the code and observe which tests fail as a result.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1448.1">
     Nonetheless, we maintain a firm belief in the value of mastering TDD.
    </span>
    <span class="koboSpan" id="kobo.1448.2">
     While the most significant advantages of TDD may lie in its educational merits rather than its practical application, the knowledge and mindset it instills are invaluable.
    </span>
    <span class="koboSpan" id="kobo.1448.3">
     Mastering TDD to the extent that it can be applied efficiently leaves an indelible mark on our coding practices, influencing our approach even in projects where TDD is not utilized.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1449.1">
     It is essential, therefore, to bear in mind the following principle: always rigorously test your code.
    </span>
    <span class="koboSpan" id="kobo.1449.2">
     This practice is fundamental to ensuring the reliability and integrity of software, regardless of the development methodology employed.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-281">
    <span class="koboSpan" id="kobo.1450.1">
     Summary
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.1451.1">
     In this chapter, we explored the world of testing.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1452.1">
     We tried to give you a fairly comprehensive overview of testing, especially unit testing, which is the most common type of testing a developer does.
    </span>
    <span class="koboSpan" id="kobo.1452.2">
     We hope we have succeeded in conveying the message that testing is not something that is perfectly defined and that you can learn from a book.
    </span>
    <span class="koboSpan" id="kobo.1452.3">
     You need to experiment with it for a significant amount of time before you get comfortable.
    </span>
    <span class="koboSpan" id="kobo.1452.4">
     Of all the efforts a coder must make in terms of study and experimentation, we would say testing is amongst the most important.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1453.1">
     In the next chapter, we are going to explore debugging and profiling, which are techniques that go hand in hand with testing.
    </span>
    <span class="koboSpan" id="kobo.1453.2">
     You should make sure you learn them well.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-282">
    <span class="koboSpan" id="kobo.1454.1">
     Join our community on Discord
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.1455.1">
     Join our community’s Discord space for discussions with the authors and other readers:
    </span>
   </p>
   <p class="normal">
    <a href="Chapter_10.xhtml">
     <span class="url">
      <span class="koboSpan" id="kobo.1456.1">
       https://discord.com/invite/uaKmaz7FEC
      </span>
     </span>
    </a>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1457.1">
     <img alt="img" src="../Images/QR_Code119001106417026468.png"/>
    </span>
   </p>
  </div>
 </body></html>