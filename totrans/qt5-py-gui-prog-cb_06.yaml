- en: Chapter 6. Threads and Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 线程和网络
- en: In this chapter, we will create threads, queues, and TCP/IP sockets using Python
    3.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Python 3 创建线程、队列和 TCP/IP 套接字。
- en: How to create multiple threads
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建多个线程
- en: Starting a thread
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始一个线程
- en: Stopping a thread
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止一个线程
- en: How to use queues
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用队列
- en: Passing queues among different modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同模块之间传递队列
- en: Using dialog widgets to copy files to your network
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对话框小部件将文件复制到您的网络
- en: Using TCP/IP to communicate via networks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TCP/IP通过网络进行通信
- en: Using URLOpen to read data from websites
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 URLOpen 从网站读取数据
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will extend the functionality of our Python GUI using threads,
    queues, and network connections.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过使用线程、队列和网络连接来扩展我们Python GUI的功能。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: A tkinter GUI is single-threaded. Every function that involves sleep or wait
    time has to be called in a separate thread, otherwise the tkinter GUI freezes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter图形用户界面是单线程的。涉及睡眠或等待时间的任何函数都必须在单独的线程中调用，否则Tkinter GUI会冻结。
- en: When we run our Python GUI in Windows Task Manager, we can see that a new `python.exe`
    process has been launched.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 Windows 任务管理器中运行我们的 Python GUI 时，我们可以看到一个新的 `python.exe` 进程已经被启动。
- en: When we give our Python GUI a `.pyw` extension, then the process created will
    be `python.pyw`, as can be seen in Task Manager.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们给我们的 Python GUI 添加 `.pyw` 扩展名时，创建的进程将是 `python.pyw`，如任务管理器中所示。
- en: When a process is created, the process automatically creates a main thread to
    run our application. This is called a single-threaded application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个进程时，进程会自动创建一个主线程来运行我们的应用程序。这被称为单线程应用程序。
- en: For our Python GUI, a single-threaded application will lead to our GUI becoming
    frozen as soon as we call a longer-running task such as clicking a button that
    has a sleep of a few seconds.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的Python GUI，如果是一个单线程应用程序，那么一旦我们调用一个运行时间较长的任务，比如点击一个有几秒休眠的按钮，我们的GUI就会立即冻结。
- en: In order to keep our GUI responsive we have to use multi-threading, and this
    is what we will study in this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持我们的图形用户界面（GUI）响应，我们必须使用多线程，这正是本章将要探讨的内容。
- en: We can also create multiple processes by creating multiple instances of our
    Python GUI, as can be seen in Task Manager.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过创建多个Python GUI实例来创建多个进程，这在任务管理器中可以看得到。
- en: Processes are isolated by design from each other and do not share common data.
    In order to communicate between separate processes we would have to use **Inter-Process-Communication**
    (**IPC**), which is an advanced technique.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 设计上，进程彼此隔离且不共享公共数据。为了在分离的进程之间进行通信，我们不得不使用**进程间通信**（**IPC**），这是一种高级技术。
- en: Threads, on the other hand, do share common data, code, and files, which makes
    communication between threads within the same process much easier than when using
    IPC.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，线程确实共享相同的数据、代码和文件，这使得在同一进程内线程之间的通信比使用进程间通信（IPC）要容易得多。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: 'A great explanation of threads can be found at: [https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一份关于线程的精彩解释可以在以下链接找到：[https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html)
- en: In this chapter, we will learn how to keep our Python GUI responsive and not
    to freeze.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何保持我们的 Python 图形用户界面（GUI）响应，并防止其冻结。
- en: How to create multiple threads
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何创建多个线程
- en: We will create multiple threads using Python. This is necessary in order to
    keep our GUI responsive.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Python 创建多个线程。这是为了保持我们的 GUI 响应性所必需的。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: A thread is like weaving a fabric made out of yarn and is nothing to be afraid
    of.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 线程就像是用线织成的布料，没有什么可怕的。
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Multiple threads run within the same computer process memory space. There is
    no need for Inter-Process-Communication (aka IPC), which would complicate our
    code. In this recipe, we will avoid IPC by using threads.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 多个线程在同一个计算机进程的内存空间中运行。无需进行进程间通信（简称IPC），这会使得我们的代码变得复杂。在本食谱中，我们将通过使用线程来避免IPC。
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: First we will increase the size of our `ScrolledText` widget, making it larger.
    Let's increase `scrolW` to 40 and `scrolH` to 10.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将增加我们的`ScrolledText`小部件的大小，使其更大。让我们将`scrolW`增加到40，将`scrolH`增加到10。
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When we now run the resulting GUI, the `Spinbox` widget is center-aligned in
    relation to the `Entry` widget above it, which does not look good. We'll change
    this by left-aligning the widget.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在运行生成的GUI时，相对于其上方的`Entry`小部件，`Spinbox`小部件是居中对齐的，这看起来不太好。我们将通过左对齐小部件来改变这一点。
- en: Add `sticky='W'` to the `grid` control to left-align the `Spinbox` widget.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `sticky='W'` 添加到 `grid` 控制中，以左对齐 `Spinbox` 小部件。
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The GUI could still look better, so next, we will increase the size of the `Entry`
    widget to get a more balanced GUI layout.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 界面看起来还可以更好，所以接下来，我们将增加`Entry`小部件的大小，以获得更平衡的GUI布局。
- en: 'Increase the width to 24, as shown in the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将宽度增加到24，如下所示：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let us also slightly increase the width of the `Combobox` to 14.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也将`Combobox`的宽度略微增加到14。
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Running the modified and improved code results in a larger GUI, which we will
    use for this and the following recipes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 运行修改和改进后的代码将产生一个更大的GUI，我们将使用这个GUI以及接下来的食谱。
- en: '![How to do it...](img/B04829_06_01.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_01.jpg)'
- en: In order to create and use threads in Python, we have to import the `Thread`
    class from the threading module.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Python中创建和使用线程，我们必须从threading模块导入`Thread`类。
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's add a method to be created in a thread to our `OOP` class.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`OOP`类中添加一个在线程中创建的方法。
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can now call our threaded method in the code, saving the instance in a variable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在代码中调用我们的线程方法，并将实例保存在一个变量中。
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now we have a method that is threaded, but when we run the code, nothing gets
    printed to the console!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个线程化的方法，但当我们运行代码时，控制台没有任何输出！
- en: We have to start the `Thread` first before it can run and the next recipe will
    show us how to do this.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须首先启动`线程`，然后它才能运行，下一道菜谱将展示如何进行这一操作。
- en: However, setting a breakpoint after the GUI main event loop proves that we did
    indeed create a `Thread` object, as can been seen in the Eclipse IDE Debugger.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在GUI主事件循环之后设置断点证明我们确实创建了一个`Thread`对象，正如可以在Eclipse IDE调试器中看到的那样。
- en: '![How to do it...](img/B04829_06_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_02.jpg)'
- en: How it works...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we prepared our GUI to use threads by first increasing the GUI
    size, so we could better see the results printed to the `ScrolledText` widget.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们首先通过增加GUI的大小来准备使用线程，这样我们就能更好地看到打印到`ScrolledText`小部件的结果。
- en: We then imported the `Thread` class from the Python `threading` module.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后从 Python 的 `threading` 模块中导入了 `Thread` 类。
- en: After that, we created a method that we call in a thread from within our GUI.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们在GUI内部创建了一个我们称之为线程的方法。
- en: Starting a thread
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始一个线程
- en: This recipe will show us how to start a thread. It will also demonstrate why
    threads are necessary to keep our GUI responsive during long-running tasks.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将向我们展示如何启动一个线程。它还将演示为什么在长时间运行的任务中，线程对于保持我们的GUI响应性是必要的。
- en: Getting ready
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Let's first see what happens when we call a function or method of our GUI that
    has some sleep associated with it without using threads.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看当我们调用我们的GUI中与睡眠相关联的函数或方法，但没有使用线程时会发生什么。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: We are using a sleep here to simulate a real-world application that might have
    to wait for a web server or database to respond or a large file transfer or complex
    computation to complete its task.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用睡眠来模拟一个可能需要等待网络服务器或数据库响应、大文件传输或复杂计算完成任务的真实世界应用。
- en: The sleep is a very realistic place-holder and shows the principle involved.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 睡眠是一个非常实际的占位符，并展示了其中涉及的原则。
- en: Adding a loop into our button callback method with some sleep time results in
    our GUI becoming unresponsive and, when we try to close the GUI, things get even
    worse.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的按钮回调方法中添加一个循环并设置一些休眠时间会导致我们的GUI变得无响应，当我们尝试关闭GUI时，情况变得更糟。
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Getting ready](img/B04829_06_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/B04829_06_03.jpg)'
- en: If we wait long enough, the method will eventually complete but during this
    time none of our GUI widgets respond to click events. We solve this problem by
    using threads.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们等待足够长的时间，该方法最终会完成，但在这一过程中，我们所有的GUI小部件都不会对点击事件做出响应。我们通过使用线程来解决这个问题。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: In the previous recipe, we created a method to be run in a thread, but so far,
    the thread has not run!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，我们创建了一个在线程中运行的方法，但到目前为止，该线程还没有运行！
- en: Unlike regular Python functions and methods, we have to `start` a method that
    is going to be run in its own thread!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规的 Python 函数和方法不同，我们必须在它自己的线程中`启动`一个将要运行的方法！
- en: This is what we will do next.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们接下来要做的。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何去做……
- en: First, let's move the creation of the thread into its own method and then call
    this method from the button callback method.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将创建线程的操作移入一个独立的方法中，然后从按钮回调方法中调用这个方法。
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Clicking the button now results in the `createThread` method being called which,
    in turn, calls the `methodInAThread` method.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮现在会导致调用`createThread`方法，该方法反过来又调用`methodInAThread`方法。
- en: First, we create a thread and target it at a method. Next, we start the thread
    that will run the targeted method in a new thread.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个线程并将其指向一个方法。接下来，我们启动一个新线程来运行目标方法。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The GUI itself runs in its own thread, which is the main thread of the application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: GUI 本身在其自己的线程中运行，这是应用程序的主线程。
- en: '![How to do it...](img/B04829_06_04.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_04.jpg)'
- en: We can print out the instance of the thread.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打印出线程的实例。
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Clicking the button now creates the following printout:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮现在将生成以下打印输出：
- en: '![How to do it...](img/B04829_06_05.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_05.jpg)'
- en: When we click the button several times, we can see that each thread gets assigned
    a unique name and ID.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们多次点击按钮时，我们可以看到每个线程都被分配了一个唯一的名称和ID。
- en: '![How to do it...](img/B04829_06_06.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_06.jpg)'
- en: Let's now move our code with the `sleep` in a loop into the `methodInAThread`
    method to verify that threads really do solve our problem.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将带有`sleep`的代码放入`methodInAThread`方法中，以验证线程确实解决了我们的问题。
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When clicking the button, while the numbers are being printed into the `ScrolledText`
    widget with a five second delay, we can click around anywhere in our GUI, switch
    tabs, and so on. Our GUI has become responsive again because we are using threads!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击按钮时，在数字以五秒延迟打印到`ScrolledText`小部件的过程中，我们可以在我们的GUI中任意点击，切换标签页等等。由于我们使用了线程，我们的GUI再次变得响应了！
- en: '![How to do it...](img/B04829_06_07.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_07.jpg)'
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we called methods of our GUI class in their own threads and
    learned that we have to start the threads. Otherwise, the thread gets created
    but just sits there waiting for us to run its target method.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们在自己的线程中调用了GUI类的函数，并了解到我们必须启动线程。否则，线程会被创建，但只是在那里等待我们运行其目标方法。
- en: We noticed that each thread gets assigned a unique name and ID.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到每个线程都被分配了一个唯一的名称和ID。
- en: We simulated long-running tasks by inserting a `sleep` statement into our code,
    which showed us that threads can indeed solve our problem.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在代码中插入`sleep`语句来模拟长时间运行的任务，这表明线程确实可以解决我们的问题。
- en: Stopping a thread
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停止一个线程
- en: We have to start a thread to actually make it do something by calling the `start()`
    method, so, intuitively, we would expect there to be a matching `stop()` method,
    but there is no such thing. In this recipe, we will learn how to run a thread
    as a background task, which is called a daemon. When closing the main thread,
    which is our GUI, all daemons will automatically be stopped as well.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须启动一个线程，通过调用`start()`方法来让它执行某些操作，所以直观上，我们可能会期望存在一个对应的`stop()`方法，但实际上并没有这样的方法。在本教程中，我们将学习如何将线程作为一个后台任务运行，这被称为守护线程。当关闭主线程，也就是我们的GUI时，所有守护线程也会自动停止。
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: When we call methods in a thread, we can also pass arguments and keyword arguments
    to the method. We start this recipe by doing exactly that.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在线程中调用方法时，我们也可以向方法传递参数和关键字参数。我们通过做这件事来开始这个步骤。
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: By adding `args=[8]` to the thread constructor and modifying the targeted method
    to expect arguments, we can pass arguments to threaded methods. The parameter
    to `args` has to be a sequence, so we will wrap our number in a Python list.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在线程构造函数中添加`args=[8]`并将目标方法修改为期望参数，我们可以向线程方法传递参数。`args`参数必须是一个序列，因此我们将我们的数字包裹在一个Python列表中。
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the following code, `runT` is a local variable which we only access within
    the scope of the method inside of which we created `runT`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，`runT` 是一个局部变量，我们只在该方法的作用域内访问我们创建的 `runT`。
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By turning the local variable into a member, we can then check if the thread
    is still running by calling `isAlive` on it from another method.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将局部变量转换为成员，我们就可以通过在另一个方法中调用其`isAlive`方法来检查线程是否仍在运行。
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, we have elevated our local `runT` variable to a member
    of our class. What this does is enable us to assess the `self.runT` variable from
    any method in our class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将本地`runT`变量提升为我们的类成员。这样做的作用是使我们能够从我们的类中的任何方法访问`self.runT`变量。
- en: 'This is achieved like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这样实现的：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When we click the button and then exit the GUI, we can see that the print statement
    in the `createThread` method was printed, but we do not see the second print statement
    from `methodInAThread`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击按钮然后退出GUI时，我们可以看到`createThread`方法中的打印语句被打印出来，但我们看不到来自`methodInAThread`的第二个打印语句。
- en: Instead, we get a RuntimeError.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们得到一个 RuntimeError。
- en: '![How to do it...](img/B04829_06_08.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_08.jpg)'
- en: Threads are expected to finish their assigned task so when we close the GUI
    while the thread has not completed, Python tells us that the thread we started
    is not in the main event loop.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 线程预计将完成其分配的任务，因此当我们关闭GUI而线程尚未完成时，Python会告诉我们我们启动的线程不在主事件循环中。
- en: We can solve this by turning the thread into a daemon, which will then execute
    as a background task.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将线程转换为守护进程来解决此问题，然后它将作为一个后台任务执行。
- en: What this gives us is that, as soon as we close our GUI, which is our main thread
    starting other threads, the daemon threads will cleanly exit.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来的结果是，当我们关闭我们的GUI（图形用户界面），也就是我们的主线程启动其他线程时，守护线程将干净地退出。
- en: We can do this by calling the `setDaemon(True)` method on the thread before
    we start the thread.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在启动线程之前，通过调用线程的`setDaemon(True)`方法来实现这一点。
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When we now click the button and exit our GUI while the thread has not yet completed
    its assigned task, we no longer get any errors.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在点击按钮并退出我们的GUI，而线程尚未完成其分配的任务时，我们不再收到任何错误。
- en: '![How to do it...](img/B04829_06_09.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_09.jpg)'
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: While there is a start method to make threads run, surprisingly there is not
    really an equivalent stop method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有启动方法可以让线程运行，但令人惊讶的是，并没有真正等效的停止方法。
- en: In this recipe, we are running a method in a thread, which prints numbers to
    our `ScrolledText` widget.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们正在一个线程中运行一个方法，该方法将数字打印到我们的`ScrolledText`小部件中。
- en: When we exit our GUI, we are no longer interested in the thread that used to
    print to our widget, so, by turning the thread into a background daemon, we can
    exit our GUI cleanly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们退出我们的图形用户界面时，我们就不再对曾经用于向我们的小部件打印的线程感兴趣了，因此，通过将线程转换为后台守护进程，我们可以干净地退出我们的GUI。
- en: How to use queues
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用队列
- en: A Python queue is a data structure that implements the first-in-first-out paradigm,
    basically working like a pipe. You shovel something into the pipe on one side
    and it falls out on the other side of the pipe.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Python队列是一种实现先进先出（FIFO）范式的数据结构，基本上就像一个管道。你在一侧把东西铲进管道，它就会从管道的另一侧掉出来。
- en: The main difference between this queue shoveling, and shoveling mud into physical
    pipes is that, in Python queues, things do not get mixed up. You put one unit
    in, and that unit comes back out on the other side. Next, you place another unit
    in (say, for example, an instance of a class), and this entire unit will come
    back out on the other end as one integral piece.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与将泥土铲入物理管道相比，这种队列铲雪的主要区别在于，在Python队列中，事物不会混淆。你放入一个单元，这个单元就会从另一端出来。接下来，你放入另一个单元（比如，一个类的实例），这个整个单元将作为一个整体从另一端出来。
- en: It comes back out at the other end in the exact order we inserted code into
    the queue.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 它以我们插入队列中代码的精确顺序从另一端返回。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: A queue is not a stack where we push and pop data. A stack is a last-in-first-out
    (LIFO) data structure.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 队列并非是我们可以进行入栈和出栈操作的栈。栈是一种后进先出（LIFO）的数据结构。
- en: Queues are containers that hold data being fed into the queue from potentially
    different data sources. We can have different clients providing data to the queue
    whenever those clients have data available. Whichever client is ready to send
    data to our queue sends it, and we can then display this data in a widget or send
    it forward to other modules.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是用于存储从可能不同的数据源中输入的数据的容器。当客户端有可用数据时，我们可以让不同的客户端向队列提供数据。无论哪个客户端准备好向我们的队列发送数据，它就会发送，然后我们可以将此数据显示在小部件中或将其转发到其他模块。
- en: Using multiple threads to complete assigned tasks in a queue is very useful
    when receiving the final results of the processing and displaying them. The data
    is inserted at one end of the queue and then comes out of the other end in an
    ordered fashion, First-In-First-Out (FIFO).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个线程在队列中完成分配的任务，在接收处理结果的最终结果并显示它们时非常有用。数据被插入到队列的一端，然后以有序的方式从另一端出来，即先进先出（FIFO）。
- en: Our GUI might have five different button widgets that each kick off different
    tasks that we want to display in our GUI in a widget (for example, a ScrolledText
    widget).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图形用户界面可能有五个不同的按钮小部件，每个小部件都会启动不同的任务，我们希望在GUI中的小部件（例如，滚动文本小部件）中显示这些任务。
- en: These five different tasks take a different amount of time to complete.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这五项不同的任务需要不同时间来完成。
- en: Whenever a task has completed, we immediately need to know this and display
    this information in our GUI.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一项任务完成时，我们立即需要知道这一点，并在我们的图形用户界面中显示此信息。
- en: By creating a shared Python queue and having the five tasks write their results
    to this queue, we can display the result of whatever task has been completed immediately
    using a FIFO approach.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个共享的 Python 队列，并让五个任务将它们的结果写入这个队列，我们可以使用先进先出（FIFO）的方法立即显示已完成任务的任何结果。
- en: Getting ready
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: As our GUI is ever increasing in its functionality and usefulness, it starts
    to talk to networks, processes, and websites, and will eventually have to wait
    for data to be made available for the GUI to represent.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的图形用户界面（GUI）在功能和实用性上不断增长，它开始与网络、进程和网站进行交互，并且最终必须等待数据变得可用，以便图形用户界面能够展示。
- en: Creating queues in Python solves the problem of waiting for data to be displayed
    inside our GUI.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中创建队列可以解决在GUI中等待数据显示的问题。
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In order to create queues in Python, we have to import the `Queue` class from
    the `queue` module. Add the following statement towards the top of our GUI module:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Python中创建队列，我们必须从`queue`模块中导入`Queue`类。将以下语句添加到我们的GUI模块顶部：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That gets us started.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这就让我们开始了。
- en: Next, we create a queue instance.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个队列实例。
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the preceding code we create a local `Queue` instance that is only accessible
    within this method. If we wish to access this queue from other places, we have
    to turn it into a member of our class by using the `self` keyword which binds
    the local variable to the entire class, making it available from any other method
    within our class. In Python, we often create class instance variables in the `__init__(self)`
    method but Python is very pragmatic and enables us to create those member variables
    anywhere in the code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Now we have an instance of a queue. We can prove that this works by printing
    it out.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个队列的实例。我们可以通过打印它来证明这是有效的。
- en: '![How to do it...](img/B04829_06_10.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_10.jpg)'
- en: In order to put data into the queue, we use the `put` command. In order to get
    data out of the queue, we use the `get` command.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据放入队列，我们使用`put`命令。为了从队列中获取数据，我们使用`get`命令。
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Running the modified code results in the message first being placed in the `Queue`,
    and then being taken out of the `Queue`, and then printed to the console.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 运行修改后的代码会导致消息首先被放入`队列`中，然后从`队列`中取出，接着打印到控制台。
- en: '![How to do it...](img/B04829_06_11.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: We can place many messages into the queue.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将许多消息放入队列中。
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have placed 10 messages into the `Queue`, but we are only getting the first
    one out. The other messages are still inside of the `Queue`, waiting to be taken
    out in a FIFO fashion.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_06_12.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_06_12.jpg)'
- en: In order to get all messages that have been placed into a `Queue` out, we can
    create an endless loop.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取所有已放入`队列`的消息，我们可以创建一个无限循环。
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![How to do it...](img/B04829_06_13.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: While this code works, unfortunately it freezes our GUI. In order to fix this,
    we have to call the method in its own thread, as we did in previous recipes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run our method in a thread and tie it to the button event:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When we now click the action `Button`, we no longer get an extraneous pop-up
    window and the code works.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_06_14.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have created a `Queue`, placed messages into one side of the `Queue` in a
    first-in-first-out (aka FIFO) fashion. We got the messages out of the `Queue`
    and then printed them to the console (stdout).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: We realized that we have to call the method in its own `Thread`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Passing queues among different modules
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will pass `Queues` around different modules. As our GUI code
    increases in complexity, we want to separate the GUI components from the business
    logic, separating them out into different modules.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Modularization gives us code reuse and also makes the code more readable.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Once the data to be displayed in our GUI comes from different data sources,
    we will face latency issues, which is what `Queues` solve. By passing instances
    of `Queues` among different Python modules, we are separating the different concerns
    of the modules' functionalities.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The GUI code ideally would only be concerned with creating and displaying widgets.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: The business logic modules' job is to only do the business logic.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: We have to combine the two elements, ideally using as few relations among the
    different modules, reducing code interdependence.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The coding principle of avoiding unnecessary dependencies is usually called
    "loose coupling".
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand the significance of loose coupling, we can draw some
    boxes on a whiteboard or a piece of paper. One box represents our GUI class and
    code, while the other boxes represent business logic, databases, and so on.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Next, we draw lines between the boxes, graphing out the interdependencies between
    those boxes which are our Python modules.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fewer lines we have between our Python boxes, the more loosely-coupled our
    design is.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous recipe, we have started to use `Queues`. In this recipe we will
    pass instances of a `Queue` from our main GUI thread to other Python modules,
    which will enable us to write to the `ScrolledText` widget from another module
    while keeping our GUI responsive.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we create a new Python module in our project. Let's call it `Queues.py`.
    We'll place a function into it (no OOP necessary yet) and pass it an instance
    of the queue.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: We also pass a self-reference of the class that creates the GUI form and widgets,
    which enables us to use all of the GUI methods from another Python module.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: We do this in the button callback.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the magic of OOP. In the middle of a class, we pass ourselves into a
    function we are calling from within the class, using the `self` keyword.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The code now looks like this.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The imported module contains the function we are calling,
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have commented out the call to `createThread` in the button callback because
    we are now calling it from our new module.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: By passing in a self-reference from the class instance to the function the class
    is calling in another module, we now have access to all of our GUI elements from
    other Python modules.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Running the code creates the following result.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_06_15.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: Next, we will create the `Queue` as a member of our class, placing a reference
    to it in the `__init__` method of the class.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now we can put messages into the queue from our new module by simply using the
    passed-in class reference to our GUI.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `createThread` method in our GUI code now only reads from the queue, which
    got filled in by the business logic residing in our new module, which has separated
    the logic from our GUI module.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Running our modified code creates the same results. We have not broken anything
    (yet)!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to separate the GUI widgets from the functionality that expresses the
    business logic, we created a class, made a queue a member of this class and, by
    passing an instance of the class into a function residing in a different Python
    module, we now have access to all of the GUI widgets as well as the `Queue`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: This recipe is an example of when it makes sense to program in OOP.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Using dialog widgets to copy files to your network
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows us how to copy files from your local hard drive to a network
    location.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: We will do this by using one of Python's tkinter built-in dialogs, which enables
    us to browse our hard drive. We can then select a file to be copied.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: This recipe also shows us how to make `Entry` widgets read-only and to default
    our `Entry` to a specified location, which speeds up the browsing of our hard
    drive.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will extend **Tab 2** of the GUI we have been building in previous recipes.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add the following code to our GUI in the `def createWidgets(self)` method towards
    the bottom where we created Tab Control 2.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: The parent of the new widget frame is `tab2`, which we have created at the very
    beginning of the `createWidgets()` method. As long as you place the code shown
    as follows physically below the creation of `tab2`, it will work.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will add two buttons and two entries to **Tab 2** of our GUI.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: We are not yet implementing the functionality of our button callback function.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the code creates the following GUI:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_06_16.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
- en: Clicking the **Browse to File…** button currently prints to the console.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_06_17.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: We can use tkinter's built-in file dialogs so let's add the following `import`
    statements to the top of our Python GUI module.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We can now use the dialogs in our code. Instead of hard-coding a path, we can
    use Python's os module to find the full path to where our GUI module resides.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Clicking the browse button now opens up the `askopenfilename` dialog.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_06_18.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: We can now open a file in this directory or browse to a different directory.
    After selecting a file and clicking the **Open** button in the dialog, we will
    save the full path to the file in the `fName` local variable.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: It would be nice if, when we opened our Python `askopenfilename` dialog widget,
    we would automatically default to a directory so that we would not have to browse
    all the way to where we were looking for a particular file to be opened.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: It is best to demonstrate how to do this by going back to our GUI **Tab 1**,
    which is what we will do next.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: We can default values into Entry widgets. Back on our **Tab 1**, this is very
    easy. All we have to do is add the following two lines of code to the creation
    of the `Entry` widget.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When we now run the GUI, the `nameEntered` Entry has a default value.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_06_19.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
- en: We can get the full path to the module we are using with the following Python
    syntax and then we can create a new subfolder just below it. We can do this as
    a module level global, or we can create the subfolder within a method.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We are setting defaults for both entry widgets and, after setting them, we make
    the local file entry widget read-only.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This order is important. We have to first populate the entry before we make
    it read-only.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: We are also selecting **Tab 2** before calling the main event loop and no longer
    set the focus into the `Entry` of **Tab 1**. Calling `select` on our tkinter `notebook`
    is zero-based so by passing in the value of 1 we select **Tab 2**…
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![How to do it...](img/B04829_06_20.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: As we are not all on the same network, this recipe will use the local hard drive
    as an example for a network.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: A UNC path is a Universal Naming Convention and what this means is that we can
    access a server on our network by using double backslashes to access a network
    server instead of the typical `C:\` when we access our local hard drive on a Windows
    PC.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just have to use the UNC and replace `C:\` with `\\<server name> \<folder>\`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: This example can be used to back up our code to a backup directory, which we
    can create if it does not exist by using `os.makedirs`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After selecting a file to copy to somewhere else, we import the Python `shutil`
    module. We need the full path to the source of the file to be copied, a network
    or local directory path, and then we append the file name to the path where we
    are going to copy it, using `shutil.copy`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Shutil is short-hand notation for shell utility.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: We also give feedback to the user via a message box to indicate whether the
    copying succeeded or failed. In order to do this, import `messagebox` and rename
    it `mBox`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: In the following code, we will mix two different approaches of where to place
    our import statements. In Python, we have some flexibility that other languages
    do not provide.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: We typically place all of the import statements towards the very top of each
    of our Python modules so that it is clear which modules we are importing.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, a modern coding approach is to place the creation of variables
    close to the function or method where they are first being used.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: In the following code, we import the message box at the top of our Python module,
    but then we also import the shutil Python module in a function.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Why would we wish to do this?
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Does this even work?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: The answer is, yes, it does work, and we are placing this import statement into
    a function because this is the only place in our code where we actually do need
    this module.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: If we never call this method, then we will never import the module this method
    requires.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: In a sense, you can view this technique as the lazy initialization design pattern.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: If we don't need it, we don't import it until we really do require it in our
    Python code.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: The idea here is that our entire code might require, let's say, twenty different
    modules. At runtime, which modules are really needed depends upon the user interaction.
    If we never call the `copyFile()` function then there is no need to import `shutil`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Once we click the button that invokes the `copyFile()` function in this function,
    we import the required module.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When we now run our GUI and browse to a file and click copy, the file is copied
    to the location we specified in our `Entry` widget.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_06_21.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
- en: If the file does not exist or we forgot to browse to a file and are trying to
    copy the entire parent folder, the code will let us know this as well because
    we are using Python's built-in exception handling capabilities.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_06_22.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are copying files from our local hard drive to a network by using the Python
    shell utility. As most of us are not connected to the same local area network,
    we simulate the copying by backing up our code to a different local folder.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: We are using one of tkinter's dialog controls and, by defaulting directory paths,
    we can increase our efficiency in copying files.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Using TCP/IP to communicate via networks
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to use sockets to communicate via TCP/IP. In order
    to achieve this, we need both an IP address and a port number.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: In order to keep things simple and independent of the ever-changing internet
    IP addresses, we will create our own local TCP/IP server and, as a client, learn
    how to connect to it and read data from a TCP/IP connection.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: We will integrate this networking capability into our GUI by using the queues
    we created in previous recipes.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a new Python module, which will be the TCP server.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way to implement a TCP server in Python is to inherit from the `socketserver`
    module. We subclass `BaseRequestHandler` and then override the inherited `handle`
    method. In very few lines of Python code, we can implement a TCP server module.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We are passing in our `RequestHandler` class into a `TCPServer` initializer.
    The empty single quotes are a short cut for passing in localhost, which is our
    own PC. This is the IP address of 127.0.0.1\. The second item in the tuple is
    the port number. We can choose any port number that is not in use on our local
    PC.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: We just have to make sure that we are using the same port on the client side
    of the TCP connection, otherwise we would not be able to connect to the server.
    Of course, we have to start the server first before clients can connect to it.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: We will modify our `Queues.py` module to become the TCP client.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is all the code we need to talk to the TCP server. In this example, we
    are simply sending some bytes to the server and the server sends them back, prepending
    some strings before returning the response.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This shows the principle of how TCP communications via networks work.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Once we know how to connect to a remote server via TCP/IP, we will use whatever
    commands are designed by the protocol of the program we are interested in communicating
    with. The first step is to connect before we can send commands to specific applications
    residing on a server.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: In the `writeToScrol` function, we will use the same loop as before but now
    we will send the messages to the TCP server. The server modifies the received
    message and then sends it back to us. Next, we place it into the GUI member queue
    which, as in previous recipes, runs in its own `Thread`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Python 3, we have to send strings over sockets in binary format. Adding the
    integer index now becomes a little bit convoluted as we have to cast it to a string,
    encode it, and then cast the encoded string into bytes!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note the `b` before the string and then, well, all the rest of the required
    casting…
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: We are starting the TCP server in its own thread in the initializer of the OOP
    class.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Clicking the **Click Me!** button on **Tab 1** now creates the following output
    in our `ScrolledText` widget, as well as on the console, and the response, due
    to using `Threads`, is very fast.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_06_23.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a TCP server to simulate connecting to a server in our local area
    network or on the Internet. We turned our queues module into a TCP client. We
    are running both the queue and the server in their own background thread, which
    keeps our GUI very responsive.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Using URLOpen to read data from websites
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows how we can easily read entire webpages by using Python's built-in
    modules. We will display the webpage data first in its raw format and then decode
    it, and then we will display it in our GUI.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will read the data from a webpage and then display it in the `ScrolledText`
    widget of our GUI.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we create a new Python module and name it `URL.py`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: We then import the required functionality to read webpages using Python.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: We can do this in very few lines of code.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: We are wrapping our code in a `try…except` block similar to Java and C#. This
    is a modern approach to coding which Python supports.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we have code that might not complete we can experiment with this code
    and, if it works, all is fine.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: If the block of code in the `try…except` block does not work, the Python interpreter
    will throw one of several possible exceptions, which we then can catch. Once we
    have caught the exception we can decide what to do next.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: There is a hierarchy of exceptions in Python and we can also create our own
    classes that inherit from and extend the Python exception classes.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: In the code shown as follows, we are mainly concerned that the URL we are trying
    to open might not be available and so we wrap our code within a `try…except` code
    block.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: If the code succeeds in opening the requested URL, all is fine.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: If it fails, maybe because our internet connection is down, we fall into the
    exception part of the code and print out that an exception has occurred.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more about Python exception handling at [https://docs.python.org/3.4/library/exceptions.html](https://docs.python.org/3.4/library/exceptions.html).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: By calling `urlopen` on the official Python website, we get the entire data
    as one long string.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: The first print statement prints this long string out to the console.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: We then call `decode` on the result and this time we get a little over 1,000
    lines of web data, including some whitespace.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: We are also printing out the type of calling `urlopen`, which is an `http.client.HTTPResponse`
    object. Actually, we are printing it out first.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_06_24.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
- en: Here is the official Python webpage we just read. If you are a web developer,
    you probably have some good ideas what to do with the parsed data.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_06_25.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
- en: We next display this data in our GUI inside the `ScrolledText` widget. In order
    to do so, we have to connect our new module to read the data from the webpage
    to our GUI.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: In order to do this, we need a reference to our GUI, and one way to do this
    is by tying our new module to the **Tab 1** button callback.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: We can return the decoded HTML data from the Python webpage to the `Button`
    widget, which we can then place in the `ScrolledText` control.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: So, let's turn our code into a function and return the data to the calling code.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We can now write the data in our `button` callback method to the `ScrolledText`
    control by first importing the new module and then inserting the data into the
    widget. We also give it some sleep after the call to `writeToScrol`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The HTML data is now displayed in our GUI widget.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_06_26.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We create a new module to separate the code that gets the data from a webpage
    from our GUI code. This is always a good thing to do. We read in the webpage data
    and then return it to the calling code after decoding it. We then use the button
    callback function to place the returned data in the `ScrolledText` control.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduced us to some advanced Python programming concepts, which
    we combined to produce a functional GUI program.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
