<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer156">
<h1 id="_idParaDest-190"><em class="italic"><a id="_idTextAnchor192"/>Chapter 16</em>: Following Best Practices</h1>
<p>In this chapter, we will learn some of the best practices from Python programming that we can follow and apply to metaprogramming too. The practices suggested in Python Enhancement Proposal 8 (PEP 8), the style guide for Python code, also apply to metaprogramming. </p>
<p>The concepts behind PEP 8 originated and are explained in detail in the documentation by Guido van Rossum, Barry Warsaw, and Nick Coghlan at <a href="https://peps.python.org/pep-0008/">https://peps.python.org/pep-0008/</a>. This chapter will cover some of the important concepts from PEP 8 with examples using <em class="italic">ABC Megamart</em> of how they can be implemented in metaprogramming as well as general Python programming.</p>
<p>In this chapter, we will be looking at the following main topics:</p>
<ul>
<li>Following PEP 8 standards</li>
<li>Writing clear comments for debugging and reusability</li>
<li>Adding documentation strings</li>
<li>Naming conventions </li>
<li>Avoiding the reuse of names</li>
<li>Avoiding metaprogramming where not required</li>
</ul>
<p>By the end of this chapter, you will know the best practices for performing Python metaprogramming.</p>
<h1 id="_idParaDest-191"><a id="_idTextAnchor193"/>Technical requirements</h1>
<p>The code examples shared in this chapter are available on GitHub under the code for this chapter at <a href="https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter16">https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter16</a>.</p>
<h1 id="_idParaDest-192"><a id="_idTextAnchor194"/>Following PEP 8 standards</h1>
<p>In this section, we will<a id="_idIndexMarker728"/> be looking at the PEP 8 standards that we should follow while coding applications with Python metaprogramming. We will apply these standards from the PEP 8 documentation using our example of <em class="italic">ABC Megamart</em>. </p>
<p>In this section, rather than looking at whether the coding standards we follow are right, we will consider the difference between coding standards that are easy to maintain in comparison to those that are not.</p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor195"/>Indentation</h2>
<p>Python is a<a id="_idIndexMarker729"/> language that is very sensitive to indentation and can throw many errors when this is not done correctly. Having discipline with the overall indentation of your code helps to avoid errors and also makes the code more readable. In this example, let’s look at how we can keep the indentation correct. </p>
<p>To start looking at <a id="_idIndexMarker730"/>the indentation, let’s begin with an example of a greater-than-10-items counter. We first define a class named <strong class="source-inline">GreaterThan10Counter</strong> with a <strong class="source-inline">return_cart</strong> method to return the cart items:</p>
<pre class="source-code">class GreaterThan10Counter():</pre>
<pre class="source-code">    def return_cart(self, *items):</pre>
<pre class="source-code">        cart_items = []</pre>
<pre class="source-code">        for I in items:</pre>
<pre class="source-code">            cart_items.append(i)</pre>
<pre class="source-code">        return cart_items</pre>
<p>Let’s also create an object instance for the class:</p>
<pre class="source-code">greater = GreaterThan10Counter()</pre>
<p>Next, we create a variable named <strong class="source-inline">cart</strong>, which will store the values returned by the <strong class="source-inline">return_cart</strong> method. Given that the class is for the greater-than-10-items counter, the number of items returned by the cart will be more than 10, hence the code will not be readable.</p>
<p>The following screenshot shows how the code would look in a code editor:</p>
<div>
<div class="IMG---Figure" id="_idContainer150">
<img alt="Figure 16.1 – The cart variable assignment " height="22" src="image/Figure_16.1_B13426.jpg" width="992"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.1 – The cart variable assignment</p>
<h3>Hard to maintain</h3>
<p>The <a id="_idIndexMarker731"/>code of the <strong class="source-inline">cart</strong> variable in <em class="italic">Figure 16.1</em> will look as follows if we move the invisible part of the code onto the next line: </p>
<div>
<div class="IMG---Figure" id="_idContainer151">
<img alt="Figure 16.2 – The cart variable adjusted without alignment " height="48" src="image/Figure_16.2_B13426.jpg" width="904"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.2 – The cart variable adjusted without alignment</p>
<p>The preceding code is not incorrect since it will still execute without errors if we run it. The only problem is that it will be difficult to maintain.</p>
<h3>Easy to maintain</h3>
<p>Let’s now change the indentation by aligning the code with symbols to make it readable and easily maintained if another developer needs to take it over for editing. The realigned code looks as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer152">
<img alt="Figure 16.3 – The cart variable adjusted with alignment " height="48" src="image/Figure_16.3_B13426.jpg" width="904"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.3 – The cart variable adjusted with alignment</p>
<p>Now that we understand this, let’s look at the next best practice, which is to present code in a neat fashion.</p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor196"/>Neat representation</h2>
<p>Let’s now <a id="_idIndexMarker732"/>look at how<a id="_idIndexMarker733"/> and where to add white spaces while writing code. </p>
<h3>Hard to maintain</h3>
<p>Let’s look at the following example where we will define a <strong class="source-inline">decorator</strong> function named <strong class="source-inline">signature</strong> with no <a id="_idIndexMarker734"/>white spaces between operators and their corresponding variables:</p>
<pre class="source-code">def signature(branch):</pre>
<pre class="source-code">    def footnote(*args):</pre>
<pre class="source-code">        LOGO='\33[43m'</pre>
<pre class="source-code">        print(LOGO+'ABC Mega Mart')</pre>
<pre class="source-code">        return branch(*args)</pre>
<pre class="source-code">    return footnote</pre>
<p>Let’s further call the <strong class="source-inline">decorator</strong> on another function named <strong class="source-inline">manager_manhattan</strong> without spaces between operators and variables:</p>
<pre class="source-code">@signature</pre>
<pre class="source-code">def manager_manhattan(*args):</pre>
<pre class="source-code">    GREEN='\033[92m'</pre>
<pre class="source-code">    SELECT='\33[7m'</pre>
<pre class="source-code">    for arg in args:</pre>
<pre class="source-code">        print(SELECT+GREEN+str(arg))</pre>
<p>Next, let’s call the function as follows:</p>
<pre class="source-code">manager_manhattan('John M','john.m@abcmegamart.com','40097 5th Main Street','Manhattan','New York City','New York',11007)</pre>
<p>The preceding code will still run without errors but the code is not presented neatly nor is it easy to maintain since it is not easy to differentiate between a variable and its operator:</p>
<pre class="source-code"><strong class="bold">ABC Mega Mart</strong></pre>
<pre class="source-code"><strong class="bold">John M</strong></pre>
<pre class="source-code"><strong class="bold">john.m@abcmegamart.com</strong></pre>
<pre class="source-code"><strong class="bold">40097 5th Main Street</strong></pre>
<pre class="source-code"><strong class="bold">Manhattan</strong></pre>
<pre class="source-code"><strong class="bold">New York City</strong></pre>
<pre class="source-code"><strong class="bold">New York</strong></pre>
<pre class="source-code"><strong class="bold">11007</strong></pre>
<p>Let’s add<a id="_idIndexMarker735"/> white spaces to this code.</p>
<h3>Easy to maintain</h3>
<p>Let’s add spaces to the <strong class="source-inline">signature</strong> function:</p>
<pre class="source-code">def signature(branch):</pre>
<pre class="source-code">    def footnote(*args):</pre>
<pre class="source-code">        LOGO = '\33[43m'</pre>
<pre class="source-code">        print(LOGO + 'ABC Mega Mart')</pre>
<pre class="source-code">        return branch(*args)</pre>
<pre class="source-code">    return footnote</pre>
<p>Similarly, let’s also add white spaces in the <strong class="source-inline">manager_manhattan</strong> function:</p>
<pre class="source-code">@signature</pre>
<pre class="source-code">def manager_manhattan(*args):</pre>
<pre class="source-code">    GREEN = '\033[92m'</pre>
<pre class="source-code">    SELECT = '\33[7m'</pre>
<pre class="source-code">    for arg in args:</pre>
<pre class="source-code">        print(SELECT + GREEN + str(arg))</pre>
<p>Let’s call the function now:</p>
<pre class="source-code">manager_manhattan('John M', 'john.m@abcmegamart.com', </pre>
<pre class="source-code">                  '40097 5th Main Street', 'Manhattan', 'New York City', 'New York',11007)</pre>
<p>Running the preceding code produces the following output:</p>
<pre class="source-code"><strong class="bold">ABC Mega Mart</strong></pre>
<pre class="source-code"><strong class="bold">John M</strong></pre>
<pre class="source-code"><strong class="bold">john.m@abcmegamart.com</strong></pre>
<pre class="source-code"><strong class="bold">40097 5th Main Street</strong></pre>
<pre class="source-code"><strong class="bold">Manhattan</strong></pre>
<pre class="source-code"><strong class="bold">New York City</strong></pre>
<pre class="source-code"><strong class="bold">New York</strong></pre>
<pre class="source-code"><strong class="bold">11007</strong></pre>
<p>The preceding code<a id="_idIndexMarker736"/> makes it easier to differentiate between variables and their corresponding operators due to the addition of white space.</p>
<p>With this understanding, let’s look at the next best practice, which is to add comments in the code.</p>
<h1 id="_idParaDest-195"><a id="_idTextAnchor197"/>Writing clear comments for debugging and reusability</h1>
<p>Writing inline comments <a id="_idIndexMarker737"/>helps us understand why a specific code block is written and we can keep the comments updated as the code changes. We recommend writing comments to make the code easy to debug in the future. However, keep the comments relevant to the code. Let’s look at a few examples of inline comments.</p>
<h3>Redundant comments</h3>
<p>Let’s look<a id="_idIndexMarker738"/> at the following example where we are creating a meta class and calling the meta class from another class:</p>
<pre class="source-code">class ExampleMetaClass1(type):</pre>
<pre class="source-code">    def __new__(classitself, *args):</pre>
<pre class="source-code">        print("class itself: ", classitself)</pre>
<pre class="source-code">        print("Others: ", args)</pre>
<pre class="source-code">        return type.__new__(classitself, *args)</pre>
<pre class="source-code">class ExampleClass1(metaclass = ExampleMetaClass1):    </pre>
<pre class="source-code">    int1 = 123             # int1 is assigned a value of 123</pre>
<pre class="source-code">    str1 = 'test'</pre>
<pre class="source-code">    def test():</pre>
<pre class="source-code">        print('test')</pre>
<p>In the<a id="_idIndexMarker739"/> preceding code, the comment explains exactly the same thing that is done by the code, which can be easily understood simply by looking at the code. This will not be helpful when we want to debug or modify the code in the future.</p>
<h3>Relevant comment</h3>
<p>Let’s look at the<a id="_idIndexMarker740"/> Singleton design pattern and add a relevant comment:</p>
<pre class="source-code">class SingletonBilling:         # This code covers an example of Singleton design pattern</pre>
<pre class="source-code">    billing_instance = None</pre>
<pre class="source-code">    product_name = 'Dark Chocolate'</pre>
<pre class="source-code">    unit_price = 6</pre>
<pre class="source-code">    quantity = 4</pre>
<pre class="source-code">    tax = 0.054    </pre>
<pre class="source-code">    def __init__(self):</pre>
<pre class="source-code">        if SingletonBilling.billing_instance == None:</pre>
<pre class="source-code">            SingletonBilling.billing_instance = self</pre>
<pre class="source-code">        else:</pre>
<pre class="source-code">            print("Billing can have only one instance")</pre>
<pre class="source-code">    </pre>
<pre class="source-code">    def generate_bill(self):</pre>
<pre class="source-code">        total = self.unit_price * self.quantity </pre>
<pre class="source-code">        final_total = total + total*self.tax</pre>
<pre class="source-code">        print('***********------------------**************')</pre>
<pre class="source-code">        print('Product:', self.product_name)</pre>
<pre class="source-code">        print('Total:',final_total)</pre>
<pre class="source-code">        print('***********------------------**************')</pre>
<p>In the <a id="_idIndexMarker741"/>preceding code, the comment specifies the purpose of <strong class="source-inline">SingletonBilling</strong> rather than mentioning the obvious task performed by the code.</p>
<p>With this understanding, let’s look at the next best practice, which is to add documentation strings.</p>
<h1 id="_idParaDest-196"><a id="_idTextAnchor198"/>Adding documentation strings</h1>
<p>Documentation strings are<a id="_idIndexMarker742"/> added to provide more information on code that is intended to be imported and used in some other program or application. Documentation strings<a id="_idIndexMarker743"/> will provide the end user with information on the code that they are going to call from their programs. This is especially helpful as the end user of the code is not the developer of the library, but a user. Let’s look at an<a id="_idIndexMarker744"/> example of where to use documentation strings.</p>
<p>Let’s start by creating a Python file named <strong class="source-inline">vegcounter.py</strong> and adding the following code:</p>
<pre class="source-code">def return_cart(*items):</pre>
<pre class="source-code">    '''</pre>
<pre class="source-code">    This function returns the list of items added to the cart.    </pre>
<pre class="source-code">    items: input the cart items. Eg: 'pens', 'pencils'</pre>
<pre class="source-code">    '''</pre>
<pre class="source-code">    cart_items = []</pre>
<pre class="source-code">    for i in items:</pre>
<pre class="source-code">        cart_items.append(i)</pre>
<pre class="source-code">    return cart_items</pre>
<p>In the<a id="_idIndexMarker745"/> preceding code, we defined the docstring by providing a description of the function and its arguments.</p>
<p>The Python file looks as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer153">
<img alt="Figure 16.4 – Documentation string added to vegcounter.py " height="205" src="image/Figure_16.4_B13426.jpg" width="639"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.4 – Documentation string added to vegcounter.py</p>
<p>Let’s further import <strong class="source-inline">vegcounter.py</strong> into another program as follows:</p>
<pre class="source-code">import vegcounter as vc</pre>
<p>Note that in this program, the code for the functions inside <strong class="source-inline">vegcounter</strong> is not accessible to the end user, but the functions in <strong class="source-inline">vegcounter</strong> can be called by the end user's program. </p>
<p>The following screenshot demonstrates how docstrings provide the information required in this example:</p>
<div>
<div class="IMG---Figure" id="_idContainer154">
<img alt="Figure 16.5 – Documentation string example " height="216" src="image/Figure_16.5_B13426.jpg" width="575"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.5 – Documentation string example</p>
<p>In this example, the<a id="_idIndexMarker746"/> documentation string we added in the Python file provides the end user with information on the function and its corresponding arguments along with an example.</p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor199"/>Documentation string for metaprogramming</h2>
<p>In this <a id="_idIndexMarker747"/>example, let’s define a metaclass named <strong class="source-inline">BranchMetaClass</strong> and add a docstring that states that this is a meta class and is not meant to be inherited as a super class or parent class. Save this code into <strong class="source-inline">branch.py</strong>:</p>
<pre class="source-code">class BranchMetaclass(type):</pre>
<pre class="source-code">    '''</pre>
<pre class="source-code">    This is a meta class for ABC Megamart branch that adds an additional </pre>
<pre class="source-code">    quality to the attributes of branch classes. </pre>
<pre class="source-code">    Add this as only a meta class.</pre>
<pre class="source-code">    There are no methods to inherit this class as a parent class or super class.    </pre>
<pre class="source-code">    '''</pre>
<pre class="source-code">    def __new__(classitself, classname, baseclasses, attributes):</pre>
<pre class="source-code">        import inspect</pre>
<pre class="source-code">        newattributes = {}</pre>
<pre class="source-code">        for attribute, value in attributes.items():</pre>
<pre class="source-code">            if attribute.startswith("__"):</pre>
<pre class="source-code">                newattributes[attribute] = value</pre>
<pre class="source-code">            elif inspect.isfunction(value):</pre>
<pre class="source-code">                newattributes['branch' + attribute.title()] = value</pre>
<pre class="source-code">            else:</pre>
<pre class="source-code">                newattributes[attribute] = value</pre>
<pre class="source-code">        return type.__new__(classitself, classname, baseclasses, newattributes)</pre>
<p>Let’s <a id="_idIndexMarker748"/>now import the branch and its corresponding meta class as follows:</p>
<pre class="source-code">from branch import BranchMetaclass</pre>
<p>Let’s now call <strong class="source-inline">BranchMetaclass</strong> to check the docstring:</p>
<pre class="source-code">BranchMetaclass</pre>
<p>The docstring is displayed in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer155">
<img alt="Figure 16.6 – Documentation string for BranchMetaclass " height="210" src="image/Figure_16.6_B13426.jpg" width="714"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.6 – Documentation string for BranchMetaclass</p>
<p>This is an example of how documentation strings should be included as a best practice. Adding documentation strings in the class definition provides end users with the information <a id="_idIndexMarker749"/>required to correctly apply a method or a class in their application.  </p>
<p>With this understanding, let’s further look at the naming conventions to be followed in Python code.</p>
<h1 id="_idParaDest-198"><a id="_idTextAnchor200"/>Naming conventions </h1>
<p>Naming conventions in<a id="_idIndexMarker750"/> Python are recommendations of how various elements in a Python program need to be named to ensure ease of navigation and consistency. Navigating through code, connecting the dots, and understanding the flow are all made easier by following consistent naming conventions throughout the code. This is another important standard that helps in developing maintainable applications. </p>
<p>In this section, we will see how you should ideally name classes, variables, functions, and methods.</p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor201"/>Class names</h2>
<p>While creating a <a id="_idIndexMarker751"/>new class, it is recommended to start the class name with an uppercase letter followed by lowercase letters and capitalize whenever there are words that need differentiation within the class name. </p>
<p>For example, let’s define a class for the billing counter. </p>
<p>The following style is not the preferred naming convention:</p>
<pre class="source-code">class billing_counter:</pre>
<pre class="source-code">    def __init__(self, productname, unitprice, quantity, tax):</pre>
<pre class="source-code">        self.productname = productname</pre>
<pre class="source-code">        self.unitprice = unitprice</pre>
<pre class="source-code">        self.quantity = quantity</pre>
<pre class="source-code">        self.tax = tax</pre>
<p>With the preceding naming convention, we will still be able to execute the code and it will work as expected. But maintaining the class names with one well-defined naming style will make<a id="_idIndexMarker752"/> future management of the libraries easier. The preferred class naming style is as follows:</p>
<pre class="source-code">class BillingCounter:</pre>
<pre class="source-code">    def __init__(self, productname, unitprice, quantity, tax):</pre>
<pre class="source-code">        self.productname = productname</pre>
<pre class="source-code">        self.unitprice = unitprice</pre>
<pre class="source-code">        self.quantity = quantity</pre>
<pre class="source-code">        self.tax = tax</pre>
<p>Camel case is <a id="_idIndexMarker753"/>used to name classes so that they can be differentiated from variables, methods, and functions. The naming conventions for variables are explained next, followed by methods and functions.</p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor202"/>Variables</h2>
<p>While <a id="_idIndexMarker754"/>creating new variables, it is preferred to use all lowercase letters for variable names followed by numbers, if relevant. When there is more than one word in a variable name, it is a good practice to separate them using an underscore operator. This also helps us to differentiate variables from classes since they follow camel case conventions.</p>
<p>Let’s look at an example of how variables should not be named:</p>
<pre class="source-code">class BillingCounter:</pre>
<pre class="source-code">    def __init__(self, PRODUCTNAME, UnitPrice, Quantity, TaX):</pre>
<pre class="source-code">        self.PRODUCTNAME = PRODUCTNAME</pre>
<pre class="source-code">        self.UnitPrice = UnitPrice</pre>
<pre class="source-code">        self.Quantity = Quantity</pre>
<pre class="source-code">        self.TaX = TaX</pre>
<p>Let’s now look at an example of one preferred method of naming variables:</p>
<pre class="source-code">class BillingCounter:</pre>
<pre class="source-code">    def __init__(self, product, price, quantity, tax):</pre>
<pre class="source-code">        self.product = product</pre>
<pre class="source-code">        self.price = price</pre>
<pre class="source-code">        self.quantity = quantity</pre>
<pre class="source-code">        self.tax = tax</pre>
<p>Let’s further<a id="_idIndexMarker755"/> look at another preferred method for naming variables:</p>
<pre class="source-code">class BillingCounter:</pre>
<pre class="source-code">    def __init__(self, product_name, unit_price, quantity, tax):</pre>
<pre class="source-code">        self.product_name = product_name</pre>
<pre class="source-code">        self.unit_price = unit_price</pre>
<pre class="source-code">        self.quantity = quantity</pre>
<pre class="source-code">        self.tax = tax</pre>
<h2 id="_idParaDest-201"><a id="_idTextAnchor203"/>Functions and methods</h2>
<p>Similar to variables, using<a id="_idIndexMarker756"/> lowercase for function and method names is the best-practice preference. When there is more than one word in a variable name, it <a id="_idIndexMarker757"/>is a good practice to separate them using an underscore operator.</p>
<p>Let’s look at an example of how a function or method should not be named:</p>
<pre class="source-code">class TypeCheck:</pre>
<pre class="source-code">    def Intcheck(self,inputvalue):</pre>
<pre class="source-code">        if (type(inputvalue) != int) or (len(str(inputvalue)) &gt; 2):</pre>
<pre class="source-code">            return False</pre>
<pre class="source-code">        else:</pre>
<pre class="source-code">            return True</pre>
<pre class="source-code">    </pre>
<pre class="source-code">    def STRINGCHECK(self,inputvalue):</pre>
<pre class="source-code">        if (type(inputvalue) != str) or (len(str(inputvalue)) &gt; 10):</pre>
<pre class="source-code">            return False</pre>
<pre class="source-code">        else:</pre>
<pre class="source-code">            return True</pre>
<p>Let’s now<a id="_idIndexMarker758"/> look at an example of the preferred method for naming <a id="_idIndexMarker759"/>methods or functions:</p>
<pre class="source-code">class TypeCheck:</pre>
<pre class="source-code">    def int_check(self,input_value):</pre>
<pre class="source-code">        if (type(input_value) != int) or (len(str(input_value)) &gt; 2):</pre>
<pre class="source-code">            return False</pre>
<pre class="source-code">        else:</pre>
<pre class="source-code">            return True</pre>
<pre class="source-code">    </pre>
<pre class="source-code">    def string_check(self,input_value):</pre>
<pre class="source-code">        if (type(input_value) != str) or (len(str(input_value)) &gt; 10):</pre>
<pre class="source-code">            return False</pre>
<pre class="source-code">        else:</pre>
<pre class="source-code">            return True</pre>
<p>These naming conventions are recommendations that can be followed while developing new code or a library from scratch. However, if the code has already been developed and is being actively maintained, it is recommended to follow the naming conventions used throughout the code.</p>
<h1 id="_idParaDest-202"><a id="_idTextAnchor204"/>Avoiding the reuse of names</h1>
<p>In this example, let’s look<a id="_idIndexMarker760"/> at another best practice of how to use variable or class names such that the reusability aspect of your code is preserved. Sometimes it might seem easy to reuse the same class or variable names while <a id="_idIndexMarker761"/>writing code in a sequence. Reusing names will make it difficult to reuse the classes, variables, methods, or functions in your code as calling them in multiple scenarios will be impacted since the same names are reused for different elements.</p>
<p>Let’s look at an example to understand the method that is not preferred. Let’s define two classes for <strong class="source-inline">Branch</strong> with a method named <strong class="source-inline">maintenance_cost</strong> with different definitions. </p>
<p>The first <strong class="source-inline">Branch</strong> class is defined as follows:</p>
<pre class="source-code">class Branch:</pre>
<pre class="source-code">    def maintenance_cost(self, product_type, quantity):</pre>
<pre class="source-code">        self.product_type = product_type</pre>
<pre class="source-code">        self.quantity = quantity</pre>
<pre class="source-code">        cold_storage_cost = 100</pre>
<pre class="source-code">        if (product_type == 'FMCG'):</pre>
<pre class="source-code">            maintenance_cost = self.quantity * 0.25 + cold_storage_cost    </pre>
<pre class="source-code">            return maintenance_cost</pre>
<pre class="source-code">        else:</pre>
<pre class="source-code">            return "We don't stock this product"</pre>
<p>The second <strong class="source-inline">Branch</strong> class is defined as follows:</p>
<pre class="source-code">class Branch:</pre>
<pre class="source-code">    def maintenance_cost(self, product_type, quantity):</pre>
<pre class="source-code">        self.product_type = product_type</pre>
<pre class="source-code">        self.quantity = quantity</pre>
<pre class="source-code">        if (product_type == 'Electronics'):</pre>
<pre class="source-code">            maintenance_cost = self.quantity * 0.05</pre>
<pre class="source-code">            return maintenance_cost</pre>
<pre class="source-code">        else:</pre>
<pre class="source-code">            return "We don't stock this product"</pre>
<p>In the <a id="_idIndexMarker762"/>preceding code, we have two <strong class="source-inline">Branch</strong> classes doing <a id="_idIndexMarker763"/>different tasks. Let’s now instantiate the <strong class="source-inline">Branch</strong> class, assuming the first <strong class="source-inline">Branch</strong> class needs to be executed at a later point in the code:</p>
<pre class="source-code">branch = Branch()</pre>
<pre class="source-code">branch.maintenance_cost('FMCG', 1)</pre>
<p>The preceding code calls the <strong class="source-inline">Branch</strong> class defined last, and thus ends up losing the definition of the first <strong class="source-inline">Branch</strong> class:</p>
<pre class="source-code"><strong class="bold">"We don't stock this product"</strong></pre>
<p>To avoid such confusion, it is always preferred to provide different names for different elements in code.</p>
<p>Let’s look at the preferred method now. We will define a class named <strong class="source-inline">Brooklyn</strong> where FMCG products are stocked as follows:</p>
<pre class="source-code">class Brooklyn:</pre>
<pre class="source-code">    def maintenance_cost(self, product_type, quantity):</pre>
<pre class="source-code">        self.product_type = product_type</pre>
<pre class="source-code">        self.quantity = quantity</pre>
<pre class="source-code">        cold_storage_cost = 100</pre>
<pre class="source-code">        if (product_type == 'FMCG'):</pre>
<pre class="source-code">            maintenance_cost = self.quantity * 0.25 + cold_storage_cost    </pre>
<pre class="source-code">            return maintenance_cost</pre>
<pre class="source-code">        else:</pre>
<pre class="source-code">            return "We don't stock this product"</pre>
<p>We will <a id="_idIndexMarker764"/>define another class named <strong class="source-inline">Queens</strong> where <a id="_idIndexMarker765"/>electronic products are stocked as follows:</p>
<pre class="source-code">class Queens:</pre>
<pre class="source-code">    def maintenance_cost(self, product_type, quantity):</pre>
<pre class="source-code">        self.product_type = product_type</pre>
<pre class="source-code">        self.quantity = quantity</pre>
<pre class="source-code">        if (product_type == 'Electronics'):</pre>
<pre class="source-code">            maintenance_cost = self.quantity * 0.05</pre>
<pre class="source-code">            return maintenance_cost</pre>
<pre class="source-code">        else:</pre>
<pre class="source-code">            return "We don't stock this product"</pre>
<p>We can now call both the classes and their methods without any issues:</p>
<pre class="source-code">brooklyn = Brooklyn()</pre>
<pre class="source-code">brooklyn.maintenance_cost('FMCG', 1)</pre>
<p>The output for <strong class="source-inline">Brooklyn</strong> is as follows:</p>
<pre class="source-code"><strong class="bold">100.25</strong></pre>
<p>Similarly, we can instantiate the <strong class="source-inline">Queens</strong> class separately:</p>
<pre class="source-code">queens = Queens()</pre>
<pre class="source-code">queens.maintenance_cost('Electronics', 1)</pre>
<p>The output for <strong class="source-inline">Queens</strong> is as follows:</p>
<pre class="source-code"><strong class="bold">0.05</strong></pre>
<p>Having looked at why we should avoid reusing names, we can further look at where to avoid metaprogramming.</p>
<h1 id="_idParaDest-203"><a id="_idTextAnchor205"/>Avoiding metaprogramming where not required</h1>
<p>Writing too much <a id="_idIndexMarker766"/>metaprogramming just because the feature is available in Python also makes the overall code very complex and hard to handle. The following aspects should be kept in mind while choosing to write a metaprogram for your application:</p>
<ul>
<li>Identify your use case and determine the need for metaprogramming based on how frequently you need to modify the code.</li>
<li>Understand how frequently you need to manipulate your code outside of its core elements such as classes, methods, and variables.</li>
<li>Check whether your solution can be developed with object-oriented programming alone or whether it depends on elements such as metaclasses, decorators, and code generation.</li>
<li>Check whether your team has the relevant skills to maintain the metaprogramming features after development.</li>
<li>Check that you don’t have a dependency on earlier versions of Python that do not support some of the metaprogramming features.</li>
</ul>
<p>These are some of the points to consider when planning to apply metaprogramming techniques during the application design phase.</p>
<h1 id="_idParaDest-204"><a id="_idTextAnchor206"/>Summary</h1>
<p>In this chapter, we covered various examples to understand the best practices recommended in the PEP 8 standards for Python. We looked at the preferred methods for indentation and the correct use of white spaces. We also looked at how to write useful comments and where to include documentation strings. </p>
<p>We learned the recommended naming conventions through some examples. We also looked at why we need to avoid reusing names and where to avoid metaprogramming.</p>
<p>While the concepts of metaprogramming are advanced and complex, we have tried to explain them with simple, straightforward examples throughout this book to keep it interesting and engaging. Learning Python and its features is a continuous journey. Keep following the future versions of Python and explore the new capabilities it provides for metaprogramming. </p>
</div>
<div>
<div id="_idContainer157">
</div>
</div>
</div></body></html>