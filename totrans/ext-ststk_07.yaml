- en: Chapter 7. Scripting with Runners
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。使用运行器进行脚本编写
- en: One of the design principles behind Unix is that programs should be small, doing
    only one thing, but doing it well. Execution modules follow this pattern, using
    functions that normally do only one thing, grouped with related functions into
    modules. When a function is executed, it performs that job, and then returns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Unix背后的设计原则之一是程序应该小巧，只做一件事，但要做好。执行模块遵循这一模式，使用通常只做一件事的函数，并将相关函数组合到模块中。当函数被执行时，它执行那个任务，然后返回。
- en: 'In Unix, these small programs can be combined together using a shell script,
    which ties them into a more powerful tool. Salt''s runner system brings that element
    of scripting to Salt, using the same language that Salt itself is written in:
    Python. In this chapter, we will discuss:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix中，这些小程序可以通过shell脚本组合在一起，将它们连接成一个更强大的工具。Salt的运行器系统将脚本元素引入Salt，使用与Salt本身编写相同的语言：Python。在本章中，我们将讨论：
- en: Connecting to Salt's local client
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到Salt的本地客户端
- en: Adding extra logic to execution modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向执行模块添加额外逻辑
- en: Troubleshooting runners
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行器的故障排除
- en: Using Salt's local client
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Salt的本地客户端
- en: 'Runners were originally designed to run on the Master, to combine multiple
    jobs across Minions into one complete task. In order to communicate with those
    Minions, a runner needs to use `local_client`. Unlike other components, this is
    not built directly into runners; you need to initialize the client yourself. Let''s
    set up a quick example:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 运行器最初被设计在主节点上运行，以将多个作业在Minions之间合并成一个完整任务。为了与这些Minions通信，运行器需要使用`local_client`。与其他组件不同，这并不是直接集成到运行器中的；你需要自己初始化客户端。让我们快速设置一个示例：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These three lines form the basis of setting up and using the local client. First,
    we import the `salt.client` library. Then, we instantiate a client object, which
    is used to communicate to Salt. When creating that client object, you do need
    to tell it where to find Salt's configuration file. Luckily, this is something
    we get for free in the `__opts__` dictionary, and we're unlikely to need to change
    it, so that line in your code will probably always look exactly like what we've
    done here.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这三条线构成了设置和使用本地客户端的基础。首先，我们导入`salt.client`库。然后，我们实例化一个客户端对象，用于与Salt通信。在创建那个客户端对象时，你需要告诉它在哪里可以找到Salt的配置文件。幸运的是，这是我们在`__opts__`字典中免费获得的东西，我们不太可能需要更改它，所以你代码中的那一行可能总是看起来与我们在这里做的一模一样。
- en: 'The last line uses the `client` object to issue a command to a target. What
    is returned from that is a list of the Minions that responded, within the specified
    timeout. Let''s go ahead and break out that last line into components, and discuss
    each one:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行使用`client`对象向目标发出命令。从那返回的是在指定超时内响应的Minions列表。让我们继续将最后一行分解成组件，并讨论每一个：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By now, you should be used to using `'*'` as a target, and know that it refers
    to all of the Minions. And you should know that `test.ping` is a standard command,
    often used to check and see which Minions are responding. The timeout is also
    required, but there's rarely a need to use anything but the configured timeout,
    so `__opts__['timeout']` will almost always be sufficient.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经习惯了使用`'*'`作为目标，并且知道它指的是所有的Minions。你也应该知道`test.ping`是一个标准命令，常用于检查并查看哪些Minions正在响应。超时也是必需的，但很少需要使用除配置的超时之外的其他超时，所以`__opts__['timeout']`几乎总是足够的。
- en: Scripting with the local client
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用本地客户端进行脚本编写
- en: 'Runners, like other Salt modules, are based around functions inside of modules.
    The preceding code is technically correct, but it''s not where it needs to be
    in order to be used as a runner. Let''s go ahead and create a runner module called
    `scan`, which we''ll use to collect various pieces of information about all of
    our Minions:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 运行器，就像其他Salt模块一样，是基于模块内部的函数。前面的代码在技术上是对的，但它不是用作运行器的地方。让我们继续创建一个名为`scan`的运行器模块，我们将使用它来收集有关所有Minions的各种信息：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At the moment, we don't have much, but it is functional as a runner. Our first
    function is called `up`, but since it's considered bad form to use function names
    shorter than three characters, we've defined it as `up_(),` and used `__func_alias__`
    to make it callable as `up`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们没有什么，但它作为一个运行器是功能性的。我们的第一个函数叫做`up`，但由于使用少于三个字符的函数名被认为是不好的做法，所以我们将其定义为`up_()`，并使用`__func_alias__`使其可调用为`up`。
- en: This function will connect to the local client, issue a `test.ping` to all Minions,
    and then return a list of which Minions responded. If we were to return `minions`
    instead of `minions.keys()`, then we would get a list of all of the Minions that
    responded, and what they responded with. Since we know that `test.ping` will always
    return `True` (assuming that it returns in the first place), we can skip returning
    that data. We also sorted the list of Minions, to make it easier to read.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将连接到本地客户端，对所有Minions发出`test.ping`测试，然后返回一个列表，显示哪些Minions响应了。如果我们返回`minions`而不是`minions.keys()`，那么我们会得到一个所有响应的Minions及其响应内容的列表。由于我们知道`test.ping`总是会返回`True`（假设它首先返回），我们可以跳过返回这些数据。我们还对Minions列表进行了排序，以便于阅读。
- en: 'To execute this function, use the `salt-run` command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此函数，请使用`salt-run`命令：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Why not create the client connection at the top of the module, so that every
    function can have access to it? Due to the way the loader presents modules to
    Salt, the `__opts__` dictionary is only available inside functions, so we can't
    use it at the top of the module. You could hardcode the correct path, but as we
    all know, hardcoded data is also poor form, and to be avoided.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不在模块顶部创建客户端连接，以便每个函数都可以访问它？由于加载器以这种方式向Salt展示模块，`__opts__`字典仅在函数内部可用，因此我们无法在模块顶部使用它。你可以硬编码正确的路径，但我们都知道，硬编码的数据也是不好的做法，应该避免。
- en: If you only want to define the client once, then consider using a private function
    called `_get_conn()`, which returns the connection object. However, since it would
    only contain one line of code, and that line is unlikely to ever change, it's
    probably not worth it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想定义一次客户端，那么考虑使用一个名为`_get_conn()`的私有函数，它返回连接对象。然而，由于它只包含一行代码，而这行代码不太可能改变，所以可能不值得这么做。
- en: 'The `scan.up` function that we''ve created tells us which Minions are responding,
    but you may be more interested in which ones aren''t responding. Those are more
    likely to tell you when Minions are having connection issues. Let''s go ahead
    and add a function called `down()`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的`scan.up`函数告诉我们哪些Minions正在响应，但你可能更感兴趣的是哪些没有响应。这些更有可能告诉你Minions何时出现连接问题。让我们继续添加一个名为`down()`的函数：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First, we need to know which Minions have responded, but we already have a function
    that reports that to us, so we just use the response from that.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要知道哪些Minions已经响应，但我们已经有一个函数可以报告这一点，所以我们只需使用那个函数的响应。
- en: We also need a list of the Minions that are expected to return. We can get this
    by creating a `salt.key` object, and asking it for a list of Minions whose keys
    have been accepted by the Master.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个预期返回的Minions列表。我们可以通过创建一个`salt.key`对象，并请求它提供一个列表，其中包含其密钥已被Master接受的Minions。
- en: 'Now that we have a list of which Minions should respond, we remove the Minions
    that did respond from that list, and if any Minions are left in the list, then
    they are the ones that we can assume are down. As before, we''ve sorted the list
    of Minions as we return them, to make it easy to read:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了应该响应的Minions列表，我们就从列表中移除已经响应的Minions，如果列表中还有剩余的Minions，那么它们就是我们可以假设已经宕机的Minions。和之前一样，我们在返回Minions列表时已经对它们进行了排序，以便于阅读：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using different targets
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用不同的目标
- en: One major difference that separates the `salt-run` command from the `salt` command
    is the inability to specify a target on the command line. This is because runners
    are designed to be able to determine their targets on their own.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 将`salt-run`命令与`salt`命令区分开来的一个主要不同之处在于无法在命令行上指定目标。这是因为运行者被设计成能够自己确定自己的目标。
- en: 'Let''s go ahead and update the `up_()` and `down()` functions to allow the
    user not only to specify their own target but also a target type:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续更新`up_()`和`down()`函数，以便用户不仅可以指定自己的目标，还可以指定目标类型：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In our function, the `tgt` argument refers to the target. The local client requires
    a target to be specified anyway, so we just replace `'*'` in our function with
    `tgt`. The `tgt_type` is the type of target to be used. By default, Salt uses
    a target type of `glob` anyway, but users can specify something else (`pcre`,
    `list`, and so on) if they need to. The name of this argument in the local client
    is `expr_form`. Check the "Target Selection Options" in the output of `salt --help`
    to see which options are supported in your version of Salt.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的函数中，`tgt`参数指的是目标。本地客户端无论如何都需要指定一个目标，所以我们只需在我们的函数中将`'*'`替换为`tgt`。`tgt_type`是要使用的目标类型。默认情况下，Salt使用目标类型为`glob`，但用户可以根据需要指定其他类型（`pcre`、`list`等）。在本地客户端中，此参数的名称为`expr_form`。检查`salt
    --help`命令的输出中的“目标选择选项”，以查看您的Salt版本支持哪些选项。
- en: Combining jobs to add more logic
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合作业以添加更多逻辑
- en: 'One of the most powerful things about runners is the ability to take the output
    from one job, and use it to start another job. First, let''s define a few things
    about our infrastructure:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 运行器最强大的功能之一是能够从一个作业的输出中获取信息，并使用它来启动另一个作业。首先，让我们定义一些关于我们基础设施的内容：
- en: We're using Salt Virt to manage some VMs.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用Salt Virt来管理一些虚拟机。
- en: Some Minions run hypervisors; others are VMs that run inside those hypervisors.
    Some do not run a hypervisor, but are also not a VM.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些Minions运行虚拟机管理程序；其他是运行在那些虚拟机管理程序内部的虚拟机。还有一些既不运行虚拟机管理程序，也不是虚拟机。
- en: A number of different operating systems are being used, such as Suse, CentOS,
    and Ubuntu.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在使用多种不同的操作系统，例如Suse、CentOS和Ubuntu。
- en: With that in mind, we need to run a report of which hypervisors are running
    on which operating systems.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们需要运行一个报告，以确定哪些虚拟机管理程序运行在哪些操作系统上。
- en: 'We could use this Salt command to discover which Minions are running which
    operating systems:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个Salt命令来发现哪些Minions正在运行哪些操作系统：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And we could run this command to find out which Minions are virtualized:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行以下命令来找出哪些Minions是虚拟化的：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'But just because a Minion''s `virtual` grain is set to `physical` doesn''t
    mean it''s a hypervisor. We could run this command to find out which Minions are
    running hypervisors:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，仅仅因为Minion的`virtual`grain设置为`physical`并不意味着它是一个虚拟机管理程序。我们可以运行以下命令来找出哪些Minions正在运行虚拟机管理程序：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'However, there''s nothing that can aggregate those data together and tell us
    which hypervisors are running which operating systems; so let''s put together
    a function that can do that:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有东西可以聚合这些数据并告诉我们哪些虚拟机管理程序正在运行哪些操作系统；因此，让我们编写一个可以做到这一点的函数：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After we create our `client` object, our first job is to see which Minions actually
    have a hypervisor running. Then we loop through that list and save the ones that
    are in another list called `hypers`. Because we're storing that in list form,
    we can pass it to the client again with an `expr_form` of `list`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建`client`对象之后，我们的第一个任务是查看哪些Minions实际上正在运行虚拟机管理程序。然后我们遍历该列表，并将它们保存在另一个名为`hypers`的列表中。因为我们以列表形式存储它，所以我们可以再次将`expr_form`为`list`的它传递给客户端。
- en: 'We''ve also added something new. The `grains.item` function expects a single
    argument that tells it which grain to look up. When you need to pass a list of
    unnamed arguments to a function, pass it in as `arg`. When we run this runner,
    our output will look something like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还增加了一些新内容。`grains.item`函数期望一个单一参数，告诉它要查找哪个grain。当你需要将一系列未命名的参数传递给一个函数时，请将其作为`arg`传递。当我们运行这个运行器时，我们的输出将类似于以下内容：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s say we want to be able to run an arbitrary Salt command on any machine
    that shows up in that hypervisor list. We''re going to do two things in our next
    bit of code. We''re going to break `hyper_os()` into two functions, called `hypers()`
    and `hyper_os()`, and then add a new function called `hyper_cmd()`, which will
    make use of the `hypers()` function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要能够在显示在虚拟机管理程序列表中的任何机器上运行任意的Salt命令。在我们的下一部分代码中，我们将做两件事。我们将把`hyper_os()`拆分成两个函数，分别称为`hypers()`和`hyper_os()`，然后添加一个名为`hyper_cmd()`的新函数，该函数将使用`hypers()`函数：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You may notice that each function is able to create its own `client` object,
    including `hypers()`. This allows us to use `scan.hypers` on its own. However,
    it also allows us to pass in a `client` object from other functions. This can
    save a lot of time over creating one `client` object per Salt command.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到每个函数都能够创建自己的`client`对象，包括`hypers()`。这允许我们单独使用`scan.hypers`。然而，它还允许我们从其他函数中传递一个`client`对象。这可以在创建每个Salt命令的单独`client`对象上节省大量时间。
- en: 'The `hyper_cmd()` function allows us to pass in arguments in a number of different
    ways, or none at all if necessary. Using it without any arguments would look like
    this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`hyper_cmd()` 函数允许我们以多种方式传递参数，或者如果不需要，则不传递任何参数。不传递任何参数使用它将看起来像这样：'
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Using it with an unnamed argument would look like:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用未命名的参数时，它看起来像这样：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It starts to get tricky when you pass in a list of arguments. By default, Salt
    is able to convert YAML that is passed in on the command line into data structures
    that can be used inside of Salt. This means that you can run this command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你传递一个参数列表时，事情开始变得复杂。默认情况下，Salt 能够将命令行中传递的 YAML 转换为 Salt 内部可以使用的数据结构。这意味着你可以运行这个命令：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And Salt will automatically translate `[one,two]` into a list containing a
    string of `one` followed by a string of `two`. However, that is not what will
    happen if you run this command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Salt 将自动将 `[one,two]` 翻译成一个包含 `one` 字符串后跟 `two` 字符串的列表。然而，如果你运行这个命令，情况并非如此：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, Salt will think that you have passed in a string whose value is
    `one,two`. If you wanted to allow users to enter lists like that, you would need
    to detect and parse them out manually.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Salt 会认为你传递了一个值为 `one,two` 的字符串。如果你想要允许用户输入这样的列表，你需要手动检测和解析它们。
- en: 'It gets even trickier if you want to pass in named arguments. The following
    is valid:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要传递命名参数，事情会变得更加复杂。以下是一个有效的例子：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'But it''s pretty horrible to ask users to type that in. Let''s go ahead and
    shrink our function down by using Python''s own `*` and `**` tools, which allow
    us to accept arbitrary lists and dictionaries from the command line:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但要求用户输入这些内容是非常糟糕的。让我们使用 Python 自身的 `*` 和 `**` 工具来缩小我们的函数，这些工具允许我们从命令行接受任意列表和字典：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we can run the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行以下命令：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The final module
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终模块
- en: 'With all of our code in place, the final module will look like:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码就绪后，最终的模块将看起来像这样：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Troubleshooting runners
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行者的故障排除
- en: In a way, runners are a little easier to troubleshoot than other types of modules.
    For instance, even though they run on the Master, they don't need the `salt-master`
    service to be restarted to pick up new changes. In fact, unless you're using the
    local client, you don't actually have to have the `salt-master` service running.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，运行者比其他类型的模块更容易进行故障排除。例如，尽管它们在主服务器上运行，但它们不需要重启 `salt-master` 服务来获取新的更改。实际上，除非你使用本地客户端，否则你实际上不需要
    `salt-master` 服务在运行。
- en: Working with the salt-master service
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 salt-master 服务一起工作
- en: 'If you are using the local client, and you try to issue a command without the
    `salt-master` service running, you will get an error that looks like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是本地客户端，并且尝试在没有 `salt-master` 服务运行的情况下发出命令，你会得到一个看起来像这样的错误：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is because, although runners themselves don't rely on the `salt-master`
    service, Minions do rely on it to receive commands, and send responses back to
    the Master.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，尽管运行者本身不依赖于 `salt-master` 服务，但 Minion 依赖于它来接收命令，并将响应发送回主服务器。
- en: Timeout issues
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超时问题
- en: If the Master is running properly and you're not receiving the responses that
    you expect, think about the targets that you're hitting. It is very common for
    a runner to issue commands to all Minions, but if you're testing in a large infrastructure,
    or you have keys on your Master that belong to Minions which are inaccessible
    or no longer exist, then runner commands can take a long time to return.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主服务器运行正常，但你没有收到预期的响应，考虑一下你正在触发的目标。对于运行者向所有 Minion 发出命令来说，这是非常常见的，但在大型基础设施中进行测试，或者你的主服务器上有属于无法访问或不再存在的
    Minion 的密钥时，运行者命令可能需要很长时间才能返回。
- en: While writing your modules, you may want to consider changing the target from
    `'*'` to one specific Minion, or perhaps to a specific list of Minions (with the
    `expr_form` set to `'list'`, as we did in our `hyper_os()` and `hyper_cmd()` functions).
    Just make sure you set it back before you push it into production.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写你的模块时，你可能想要考虑将目标从 `'*'` 改为特定的 Minion，或者可能是一个特定的 Minion 列表（`expr_form` 设置为
    `'list'`，就像我们在 `hyper_os()` 和 `hyper_cmd()` 函数中所做的那样）。只是确保在生产前将其设置回原样。
- en: Summary
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Runners add a scripting element to Salt, using Python. They are designed to
    run on the Master, but do not require the `salt-master` service to be running,
    unless they are using the local client to issue commands to Minions. Runners are
    designed to manage targeting on their own, but you can add elements to allow users
    to specify targets anyway. They are especially useful for using the output from
    one job as input for another job, which allows you to wrap your own logic around
    execution modules.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 运行者向Salt添加了一个脚本元素，使用Python。它们设计在Master上运行，但不需要`salt-master`服务正在运行，除非它们正在使用本地客户端向仆从发布命令。运行者设计为能够独立管理目标，但你可以添加元素以允许用户指定目标。它们特别适用于使用一个作业的输出作为另一个作业的输入，这允许你在执行模块周围包装自己的逻辑。
- en: 'In the next chapter, we will allow the Master to use external sources to store
    the files that it serves to its Minions. Next up: adding external file servers.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将允许大师使用外部资源来存储它为它的仆从（Minions）提供的服务文件。接下来：添加外部文件服务器。
