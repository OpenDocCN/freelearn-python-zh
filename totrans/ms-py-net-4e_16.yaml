- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test-Driven Development for Networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we used Python to communicate with network devices,
    monitor and secure a network, automate processes, and extend an on-premises network
    to public cloud providers. We have come a long way from having to exclusively
    use a terminal window and manage the network with a CLI. When working together,
    the services we have built function like a well-oiled machine that gives us a
    beautiful, automated, programmable network. However, the network is never static
    and is constantly changing to meet the demands of the business. What happens when
    the services we build are not working optimally? As we have done with monitoring
    and source control systems, we are actively trying to detect faults.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are extending the active detection concept with **test-driven
    development** (**TDD**). We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of TDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Topology as code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests for networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pyATS and Genie
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll begin this chapter with an overview of TDD before diving into its applications
    within networks. We will look at examples of using Python with TDD and gradually
    move from specific tests to larger network-based tests.
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven development overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of TDD has been around for a while. American software engineer Kent
    Beck, among others, is credited with leading the TDD movement, along with agile
    software development. Agile software development requires very short build-test-deploy
    development cycles; all software requirements are turned into test cases. These
    test cases are usually written before the code is written, and the software code
    is only accepted when the test passes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same idea can be drawn in parallel with network engineering. For example,
    when we face the challenge of designing a modern network, we can break the process
    down into the following steps, from high-level design requirements to the network
    tests that we can deploy:'
  prefs: []
  type: TYPE_NORMAL
- en: We start with the overall requirement for the new network. Why do we need to
    design a new network or part of a new network? Maybe it is for new server hardware,
    a new storage network, or new microservice software architecture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new requirements are broken down into smaller, more specific requirements.
    This could be evaluating a new switch platform, testing a possibly more efficient
    routing protocol, or a new network topology (for example, fat-tree). Each of the
    smaller requirements can be broken down into the categories of **required** or
    **optional**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We draw out the test plan and evaluate it against the potential candidates for
    solutions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The test plan will work in reverse order; we will start by testing the features,
    then integrate the new feature into a bigger topology. Finally, we will try to
    run our test close to a production environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What I am trying to get at is that, even without realizing it, we might already
    be adopting some of the TDD methodologies in the normal network engineering process.
    This was part of my revelation when I was studying the TDD mindset. We are already
    implicitly following this best practice without formalizing the method.
  prefs: []
  type: TYPE_NORMAL
- en: By gradually moving parts of the network to code, we can use TDD for the network
    even more. If our network topology is described in a hierarchical format in XML
    or JSON, each component can be correctly mapped and expressed in the desired state,
    which some might call “the source of truth.” This is the desired state that we
    can write test cases against to test production deviation from this state. For
    example, if our desired state calls for a full mesh of iBGP neighbors, we can
    always write a test case to check against our production devices for the number
    of iBGP neighbors it has.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sequence of TDD is loosely based on the following six steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a test with the result in mind
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run all tests and see whether the new test fails
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the test again
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the necessary changes if the test fails
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As with any process, how closely we follow the guideline is a judgment call.
    I prefer to treat these guidelines as goals and follow them somewhat loosely.
    For example, the TDD process calls for writing test cases before writing any code
    or, in our instance, before any network components are built. As a personal preference,
    I always like to see a working version of the network or code before writing test
    cases. It gives me a higher level of confidence, so if anybody is judging my TDD
    process, I might just get a big fat “F.” I also like to jump around between different
    levels of testing; sometimes, I test a small portion of the network, Other times,
    I conduct a system-level end-to-end test, such as a ping or traceroute test.
  prefs: []
  type: TYPE_NORMAL
- en: The point is I do not believe there is a one-size-fits-all approach to testing.
    It depends on personal preference and the scope of the project. This is true for
    most of the engineers I have worked with. It is a good idea to keep the framework
    in mind so we have a working blueprint to follow, but you are the best judge of
    your problem-solving style.
  prefs: []
  type: TYPE_NORMAL
- en: Before we delve further into TDD, let’s cover some of the most common terminologies
    in the following section so that we have a good conceptual grounding before getting
    into more details.
  prefs: []
  type: TYPE_NORMAL
- en: Test definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at some of the terms commonly used in TDD:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit test**: Checks a small piece of code. This is a test that is run against
    a single function or class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration test**: Checks multiple components of a code base; multiple units
    are combined and tested as a group. This can be a test that checks against a Python
    module or multiple modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System test**: Checks from end to end. This is a test that runs as close
    to what an end user would see as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional test**: Checks against a single function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test coverage**: A term defined as the determination of whether our test
    cases cover the application code. This is typically done by examining how much
    code is exercised when we run the test cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test fixtures**: A fixed state that forms a baseline for running our tests.
    The purpose of a test fixture is to ensure there is a well-known and fixed environment
    in which tests are run so they are repeatable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Setup and teardown**: All the prerequisite steps are added in the setup and
    cleaned up in the teardown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The terms might seem very software development-centric, and some might not be
    relevant to network engineering. Remember that the terms are a way for us to communicate
    a concept or step. We will be using these terms in the rest of this chapter. As
    we use the terms more in the network engineering context, they might become clearer.
    With that covered, let’s dive into treating network topology as code.
  prefs: []
  type: TYPE_NORMAL
- en: Topology as code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we discuss topology as code, an engineer might jump up and declare: “The
    network is too complex. It is impossible to summarize it into code!” From personal
    experience, this has happened in some of the meetings I have been in. In the meeting,
    we would have a group of software engineers who want to treat infrastructure as
    code, but the traditional network engineers in the room would declare that it
    was impossible. Before you do the same and yell at me across the pages of this
    book, let’s keep an open mind. Would it help if I told you we have been using
    code to describe our topology in this book already?'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take a look at any of the lab topology files that we have been using
    in this book, they are simply YAML files that include a description of the relationship
    between nodes. For example, in this chapter, we will use same topology we have
    been using for the last few chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18403_16_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.1: Lab Topology'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open up the topology file, `chapter16_topology.yaml`, with a text editor,
    we will see that the file is a YAML file describing the node and the links between
    the nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The node section include each of the node’s id, label, definition, and configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we open up the previous chapter’s lab topology file, which contain Linux
    nodes, we can see the Linux host nodes can be described the same way as the network
    nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: By expressing the network as code, we can declare a source of truth for our
    network. We can write test code to compare the actual production value against
    this blueprint. We will use this topology file as the base and compare the production
    network value against it.
  prefs: []
  type: TYPE_NORMAL
- en: XML parsing example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides YAML, another popular way to express topology as code is XML. In fact,
    that was the format that the predecessor of CML 2, Cisco VIRL used. From previous
    editions of the book, I have provided an example of a two-host, two-network node
    example file named `chapter15_topology.virl` for our parsing example.
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with XML files, we can use Python to extract the element from this
    topology file and store it as a Python data type so we can work with it. In `chapter16_1_xml.py`,
    we will use `ElementTree` to parse the `virl` topology file and construct a dictionary
    consisting of the information of our devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The result is a Python dictionary that consists of the devices according to
    our topology file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also add customary items to the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If we want to compare this “source of truth” to the production device version,
    we can use our script from *Chapter 3*, *APIs and Intent-Driven Networking*, `cisco_nxapi_2.py`,
    to retrieve the production NX-OSv device’s software version. We can then compare
    the value we received from our topology file with the production device’s information.
    Later, we can use Python’s built-in `unittest` module to write test cases.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the `unittest` module in just a bit. Feel free to skip ahead
    and come back to this example if you’d like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the relevant `unittest` code in `chapter16_2_validation.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the validation test, we can see that the test passes because the
    software version in production matches what we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we manually change the expected NX-OSv version value to introduce a failure
    case, we will see the following failed output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the test case result returned as failed; the reason for the
    failure was the version mismatch between the two values. As we saw in the last
    example, the Python `unittest` module is a great way to test our existing code
    based on our expected results. Let’s take a deeper look at the module.
  prefs: []
  type: TYPE_NORMAL
- en: Python’s unittest module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Python standard library includes a module named `unittest`, which handles
    test cases where we can compare two values to determine whether a test passes.
    In the previous example, we saw how to use the `assertEqual()` method to compare
    two values to return either `True` or `False`. Here is an example, `chapter16_4_unittest.py`,
    that uses the built-in `unittest` module to compare two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `python3` command-line interface, the `unittest` module can automatically
    discover the test cases in the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides comparing two values, here are more examples of testing whether the
    expected value is `True` or `False`. We can also generate custom failure messages
    when a failure occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `-v` for the option to display a more detailed output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Starting from Python 3.3, the `unittest` module includes the `mock` object library
    by default ([https://docs.python.org/3/library/unittest.mock.html](https://docs.python.org/3/library/unittest.mock.html)).
    This is a very useful module that you can use to make a fake HTTP API call to
    a remote resource without actually making the call. For example, we have seen
    using NX-API to retrieve the NX-OS version number. What if we want to run our
    test, but we do not have an NX-OS device available? We can use the `unittest`
    mock object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `chapter16_5_more_unittest_mocks.py`, we created a class with a method to
    make HTTP API calls and expect a JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We also created a function that mocks two URL calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we make the API call to the two URLs in our test case. However, we
    are using the `mock.patch` decorator to intercept the API calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When we run the test, we will see that the test passes without needing to make
    an actual API call to the remote endpoint. Neat, huh?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For more information on the `unittest` module, Doug Hellmann’s Python module
    of the week ([https://pymotw.com/3/unittest/index.html#module-unittest](https://pymotw.com/3/unittest/index.html#module-unittest))
    is an excellent source of short and precise examples on the `unittest` module.
    As always, the Python documentation is a good source of information as well: [https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html).'
  prefs: []
  type: TYPE_NORMAL
- en: More on Python testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the built-in `unittest` library, there are lots of other testing
    frameworks from the Python community. `pytest` is one of the most robust, intuitive
    Python testing frameworks and is worth a look. `pytest` can be used for all types
    and levels of software testing. It can be used by developers, QA engineers, individuals
    practicing TDD, and open source projects.
  prefs: []
  type: TYPE_NORMAL
- en: Many large-scale open source projects have switched from `unittest` or `nose`
    (another Python test framework) to `pytest`, including Mozilla and Dropbox. The
    attractive features of `pytest` include the third-party plugin model, a simple
    fixture model, and assert rewriting.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to learn more about the `pytest` framework, I highly recommend
    *Python Testing with pytest* by Brian Okken (ISBN 978-1-68050-240-4). Another
    great source is the pytest documentation: [https://docs.pytest.org/en/latest/](https://docs.pytest.org/en/latest/).'
  prefs: []
  type: TYPE_NORMAL
- en: '`pytest` is command line-driven; it can find the tests we have written automatically
    and run them by appending the `test` prefix in our function. We will need to install
    `pytest` before we can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look at some examples using `pytest`.
  prefs: []
  type: TYPE_NORMAL
- en: pytest examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first `pytest` example, `chapter16_6_pytest_1.py`, will be a simple assert
    for two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run `pytest` with the `-v` option, `pytest` will give us a pretty robust
    answer for a reason for the failure. The verbose output is one of the reasons
    people like `pytest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second `pytest` example, `chapter16_7_pytest_2.py`, we will create a
    `router` object. The `router` object will be initiated with some values of `None`
    and some with default values. We will use `pytest` to test one instance with the
    default and one instance without:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the test, we will see whether the instance was accurately applied
    with the default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to replace the previous `unittest` example with `pytest`, in `chapter16_8_pytest_3.py`,
    we can see the syntax with `pytest` is simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we run the test with the `pytest` command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Between `unittest` and `pytest`, I find `pytest` more intuitive to use. However,
    since `unittest` is included in the standard library, many teams might prefer
    using the `unittest` module for their testing.
  prefs: []
  type: TYPE_NORMAL
- en: Besides doing tests on code, we can also write tests to test our network as
    a whole. After all, users care more about their services and applications functioning
    properly and less about individual pieces. We will look at writing tests for the
    network in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests for networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been mostly writing tests for our Python code. We have used
    both the `unittest` and `pytest` libraries to assert `True`/`False` and `equal/non-equal`
    values. We were also able to write mocks to intercept our API calls when we do
    not have an actual API-capable device but still want to run our tests.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, let’s look at how we can write tests relevant to the networking
    world. There is no shortage of commercial products regarding network monitoring
    and testing. Over the years, I have come across many of them. However, in this
    section, I prefer to use simple, open source tools for my tests.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for reachability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often, the first step of troubleshooting is to conduct a small reachability
    test. For network engineers, `ping` is our best friend when it comes to network
    reachability tests. It is a way to test the reachability of a host on an IP network
    by sending a small package across the network to the destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can automate the `ping` test via the `OS` module or the `subprocess` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `subprocess` module offers the additional benefit of catching the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: These two modules prove to be very useful in many situations. Any command we
    can execute in the Linux and Unix environments can be executed via the `OS` or
    `subprocess` module.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for network latency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The topic of network latency can sometimes be subjective. Working as network
    engineers, we are often faced with the user saying that the network is slow. However,
    “slow” is a very subjective term.
  prefs: []
  type: TYPE_NORMAL
- en: If we could construct tests that turn subjective terms into objective values,
    it would be very helpful. We should do this consistently to compare the values
    over a time series of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can sometimes be difficult since the network is stateless by design. Just
    because one packet is successful does not guarantee success for the next packet.
    The best approach I have seen over the years is to use `ping` across many hosts
    frequently and log the data, conducting a ping-mesh graph. We can leverage the
    same tools we used in the previous example, catch the return-result time, and
    keep a record. We do this in `chapter16_10_ping.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the result is kept in a `tuple` and put into a `list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is not perfect and is merely a starting point for monitoring and troubleshooting.
    However, in the absence of other tools, this offers some baseline of objective
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw one of the best tools for security testing in *Chapter 6*, *Network Security
    with Python*, which was Scapy. There are lots of open source tools for security,
    but none offer the flexibility that comes with constructing our packets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another great tool for network security testing is `hping3` ([https://docs.python-cerberus.org/en/stable/](https://docs.python-cerberus.org/en/stable/)).
    It offers a simple way to generate a lot of packets at once. For example, you
    can use the following one-liner to generate a TCP SYN flood:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Again, since this is a command-line tool, we can use the `subprocess` module
    to automate any `hping3` tests that we want.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The network is a crucial part of the infrastructure, but it is only a part of
    it. What the users care about is often the service that runs on top of the network.
    If the user is trying to watch a YouTube video or listen to a podcast but cannot,
    in their opinion, the service is broken. We might know that the network transport
    is not at fault, but that doesn’t comfort the user.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, we should implement tests that are as similar to the user’s
    experience as possible. In the example of a YouTube video, we might not be able
    to duplicate the YouTube experience 100% (unless you work for Google).
  prefs: []
  type: TYPE_NORMAL
- en: Still, we can implement a layer-7 service as close to the network edge as possible.
    We can then simulate the transaction from a client at a regular interval as a
    transactional test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python `HTTP` standard library module is a module that I often use when
    I need to test layer-7 reachability on a web service quickly. We already saw how
    to use it when we were performing network monitoring in *Chapter 4*, *The Python
    Automation Framework – Ansible*, but it’s worth seeing again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If we can simulate a full transaction for the expected service, that is even
    better. But Python’s simple `HTTP` server module in the standard library is always
    a great one for running some ad hoc web service tests.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for network configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In my opinion, the best test for network configuration is using standardized
    templates to generate the configuration and back up the production configuration
    often. We have seen how we can use the Jinja2 template to standardize our configuration
    per device type or role. This will eliminate many of the mistakes caused by human
    error, such as copy and paste.
  prefs: []
  type: TYPE_NORMAL
- en: Once the configuration is generated, we can write tests against the configuration
    for known characteristics that we would expect before we push the configuration
    to production devices. For example, there should be no overlap of IP addresses
    in all of the network when it comes to loopback IP, so we can write a test to
    see whether the new configuration contains a loopback IP that is unique across
    our devices.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for Ansible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the time I have been using Ansible, I cannot recall using a `unittest`-like
    tool to test a playbook. For the most part, the playbooks use modules that were
    tested by module developers.
  prefs: []
  type: TYPE_NORMAL
- en: If you want a lightweight data validation tool, please check out Cerberus ([https://docs.python-cerberus.org/en/stable/](https://docs.python-cerberus.org/en/stable/)).
  prefs: []
  type: TYPE_NORMAL
- en: Ansible provides unit tests for their library of modules. Unit tests in Ansible
    are currently the only way to drive tests from Python within Ansible’s continuous-integration
    process. The unit tests that are run today can be found under `/test/units` ([https://github.com/ansible/ansible/tree/devel/test/units](https://github.com/ansible/ansible/tree/devel/test/units)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ansible testing strategy can be found in the following documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing Ansible**: [https://docs.ansible.com/ansible/latest/dev_guide/testing.html](https://docs.ansible.com/ansible/latest/dev_guide/testing.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit tests**: [https://docs.ansible.com/ansible/latest/dev_guide/testing_units.html](https://docs.ansible.com/ansible/latest/dev_guide/testing_units.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit testing Ansible modules**: [https://docs.ansible.com/ansible/latest/dev_guide/testing_units_modules.html](https://docs.ansible.com/ansible/latest/dev_guide/testing_units_modules.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the interesting Ansible testing frameworks is Molecule ([https://pypi.org/project/molecule/](https://pypi.org/project/molecule/)).
    It intends to aid in the development and testing of Ansible roles. Molecule supports
    testing with multiple instances, operating systems, and distributions. I have
    not used this tool, but it is where I would start if I wanted to perform more
    testing on my Ansible roles.
  prefs: []
  type: TYPE_NORMAL
- en: We should now know how to write tests for our network, whether testing for reachability,
    latency, security, transaction, or network configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will take a look at an extensive testing framework developed
    by Cisco (and recently released as open source) called `pyATS`. Much to their
    credit, releasing such an extensive framework as open source for the benefit of
    the community was a great gesture by Cisco.
  prefs: []
  type: TYPE_NORMAL
- en: pyATS and Genie
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pyATS ([https://developer.cisco.com/pyats/](https://developer.cisco.com/pyats/))
    is an end-to-end testing ecosystem originally developed by Cisco and made available
    to the public in late 2017\. The pyATS library was formerly known as Genie; they
    will often be referred to in the same context. Because of its roots, the framework
    is very focused on network testing.
  prefs: []
  type: TYPE_NORMAL
- en: pyATS, and the pyATS library (also known as Genie), was the winner of the 2018
    Cisco Pioneer Award. We should all applaud Cisco for making the framework open
    source and available to the public. Good job, Cisco DevNet!
  prefs: []
  type: TYPE_NORMAL
- en: 'The framework is available on PyPI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To get started, we can look at some of the example scripts on the GitHub repository,
    [https://github.com/CiscoDevNet/pyats-sample-scripts](https://github.com/CiscoDevNet/pyats-sample-scripts).
    The tests start with creating a testbed file in YAML format. We will create a
    simple `chapter16_pyats_testbed_1.yml` testbed file for our `lax-edge-r1-edg-r1`
    device. The file should look similar to the Ansible inventory file that we have
    seen before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In our first script, `chapter16_11_pyats_1.py`, we will load the testbed file,
    connect to the device, issue a `show version` command, then disconnect from the
    device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute the command, we can see the output is a mixture of the `pyATS`
    setup as well as the actual output of the device. This is similar to the Paramiko
    scripts we have seen before but note that `pyATS` took care of the underlying
    connection for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second example, we will see a full example of connection setup, test
    cases, then connection teardown. First, we will add the `lax-cor-r1` device to
    our testbed in `chapter16_pyats_testbed_2.yml`. The additional device is needed
    as the connected device to `iosv-1` for our ping test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In `chapter16_12_pyats_2.py`, we will use the `aest` module from `pyATS` with
    various decorators. Besides setup and cleanup, the `ping` test is in the `PingTestCase`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It is best practice to reference the testbed file at the command line during
    runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The output is similar to our first example, with the additions of `STEPS Report`
    and `Detailed Results` with each test case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output also indicates the log filename that is written to the `/tmp` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The pyATS framework is a great framework for automated testing. However, because
    of its origin, the support for vendors outside of Cisco is a bit lacking.
  prefs: []
  type: TYPE_NORMAL
- en: One open source tool for network validation to take note of is Batfish, [https://github.com/batfish/batfish](https://github.com/batfish/batfish),
    from the folks at Intentionet. A primary use case for Batfish is to validate configuration
    changes before deployment. Another open source project is Suzieq ([https://suzieq.readthedocs.io/en/latest/](https://suzieq.readthedocs.io/en/latest/)).
    Suzieq is the first open source, multi-vendor network observability platform application.
  prefs: []
  type: TYPE_NORMAL
- en: There is a bit of a learning curve involved with `pyATS`; it basically has its
    own way of performing tests that takes some getting used to. Understandably, it
    is also heavily focused on Cisco platforms in its current iteration. The `pyATS`
    core is closed sourced and released in a binary form. The packages that are developed
    to be used with `pyATS`, such as the parser libraries, YANG connectors, and various
    plugins are open sourced. For the open source portion, we are all encouraged to
    make contributions if we would like to add additional vendor support or make syntax
    or process changes.
  prefs: []
  type: TYPE_NORMAL
- en: We are near the end of the chapter, so let’s go over what we have done in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at TDD and how it can be applied to network engineering.
    We started with an overview of TDD; then, we looked at examples using the `unittest`
    and `pytest` Python modules. Python and simple Linux command-line tools can be
    used to construct tests for network reachability, configuration, and security.
  prefs: []
  type: TYPE_NORMAL
- en: pyATS is a tool that Cisco released. It is a network-centric automated testing
    framework that we can leverage.
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, if it is not tested, it is not trusted. Everything in our network
    should be programmatically tested as much as possible. As with many software concepts,
    TDD is a never-ending service wheel. We strive to have as much test coverage as
    possible, but even at 100% test coverage, we can always find new ways and test
    cases to implement. This is especially true in networking, where the network is
    often the internet, and 100% test coverage of the internet is impossible.
  prefs: []
  type: TYPE_NORMAL
- en: We are at the end of the book. I hope you have found the book as much a joy
    to read as it was a joy for me to write. I want to say a sincere “thank you” for
    taking the time to read this book. I wish you success and happiness on your Python
    network journey!
  prefs: []
  type: TYPE_NORMAL
- en: Join our book community
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join our community for this book – where you can share feedback, ask questions
    to the author, and learn about new releases – follow the QR code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2903617220506617062.png)'
  prefs: []
  type: TYPE_IMG
