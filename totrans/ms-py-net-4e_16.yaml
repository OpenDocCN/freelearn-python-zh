- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Test-Driven Development for Networks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络的测试驱动开发
- en: In the previous chapters, we used Python to communicate with network devices,
    monitor and secure a network, automate processes, and extend an on-premises network
    to public cloud providers. We have come a long way from having to exclusively
    use a terminal window and manage the network with a CLI. When working together,
    the services we have built function like a well-oiled machine that gives us a
    beautiful, automated, programmable network. However, the network is never static
    and is constantly changing to meet the demands of the business. What happens when
    the services we build are not working optimally? As we have done with monitoring
    and source control systems, we are actively trying to detect faults.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用Python与网络设备通信，监控和保障网络，自动化流程，并将本地网络扩展到公有云提供商。我们已经从必须仅使用终端窗口并使用CLI管理网络的情况中走了很长的路。当我们共同工作时，我们所构建的服务就像一台运转良好的机器，为我们提供了一个美丽、自动化、可编程的网络。然而，网络永远不会静止，它不断变化以满足业务需求。当我们构建的服务没有最佳运行时会发生什么？正如我们在监控和源代码控制系统中所做的那样，我们正在积极尝试检测故障。
- en: 'In this chapter, we are extending the active detection concept with **test-driven
    development** (**TDD**). We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过**测试驱动开发**（TDD）扩展了主动检测的概念。我们将涵盖以下主题：
- en: An overview of TDD
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD概述
- en: Topology as code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拓扑作为代码
- en: Writing tests for networking
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写网络测试
- en: pyATS and Genie
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pyATS和Genie
- en: We’ll begin this chapter with an overview of TDD before diving into its applications
    within networks. We will look at examples of using Python with TDD and gradually
    move from specific tests to larger network-based tests.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始，先概述TDD，然后再深入探讨其在网络中的应用。我们将查看使用Python进行TDD的示例，并逐步从特定的测试过渡到基于网络的更大测试。
- en: Test-driven development overview
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发概述
- en: The idea of TDD has been around for a while. American software engineer Kent
    Beck, among others, is credited with leading the TDD movement, along with agile
    software development. Agile software development requires very short build-test-deploy
    development cycles; all software requirements are turned into test cases. These
    test cases are usually written before the code is written, and the software code
    is only accepted when the test passes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: TDD（测试驱动开发）的概念已经存在了一段时间。美国软件工程师肯特·贝克（Kent Beck）等人被公认为领导了TDD运动，并与敏捷软件开发一起发展。敏捷软件开发需要非常短的构建-测试-部署开发周期；所有软件需求都被转化为测试用例。这些测试用例通常在编写代码之前就写好了，只有当测试通过时，软件代码才被接受。
- en: 'The same idea can be drawn in parallel with network engineering. For example,
    when we face the challenge of designing a modern network, we can break the process
    down into the following steps, from high-level design requirements to the network
    tests that we can deploy:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的想法可以与网络工程平行。例如，当我们面临设计现代网络的挑战时，我们可以将这个过程分解为以下步骤，从高级设计要求到我们可以部署的网络测试：
- en: We start with the overall requirement for the new network. Why do we need to
    design a new network or part of a new network? Maybe it is for new server hardware,
    a new storage network, or new microservice software architecture.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从新网络的整体需求开始。为什么我们需要设计一个新的网络或新网络的一部分？可能是因为新的服务器硬件、新的存储网络或新的微服务软件架构。
- en: The new requirements are broken down into smaller, more specific requirements.
    This could be evaluating a new switch platform, testing a possibly more efficient
    routing protocol, or a new network topology (for example, fat-tree). Each of the
    smaller requirements can be broken down into the categories of **required** or
    **optional**.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的要求被分解为更小、更具体的要求。这可能包括评估新的交换平台，测试可能更有效的路由协议，或新的网络拓扑（例如，胖树拓扑）。每个更小的要求都可以分为**必需**或**可选**的类别。
- en: We draw out the test plan and evaluate it against the potential candidates for
    solutions.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们制定测试计划，并对其与潜在解决方案候选者的潜在性进行评估。
- en: The test plan will work in reverse order; we will start by testing the features,
    then integrate the new feature into a bigger topology. Finally, we will try to
    run our test close to a production environment.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试计划将按相反的顺序进行；我们将从测试功能开始，然后将新功能集成到一个更大的拓扑中。最后，我们将尝试在接近生产环境的情况下运行我们的测试。
- en: What I am trying to get at is that, even without realizing it, we might already
    be adopting some of the TDD methodologies in the normal network engineering process.
    This was part of my revelation when I was studying the TDD mindset. We are already
    implicitly following this best practice without formalizing the method.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我试图说明的是，即使我们没有意识到，我们可能已经在正常的网络工程过程中采用了某些TDD方法。这是我研究TDD心态时的一个启示。我们已经在隐式地遵循这一最佳实践，而没有正式化该方法。
- en: By gradually moving parts of the network to code, we can use TDD for the network
    even more. If our network topology is described in a hierarchical format in XML
    or JSON, each component can be correctly mapped and expressed in the desired state,
    which some might call “the source of truth.” This is the desired state that we
    can write test cases against to test production deviation from this state. For
    example, if our desired state calls for a full mesh of iBGP neighbors, we can
    always write a test case to check against our production devices for the number
    of iBGP neighbors it has.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过逐渐将网络的部分移动到代码中，我们可以将TDD应用于网络。如果我们的网络拓扑以XML或JSON的分层格式描述，每个组件都可以正确映射并表达在期望的状态，这有些人可能称之为“真相之源”。这是我们针对生产偏离此状态的测试用例所期望的状态。例如，如果我们的期望状态要求iBGP邻居的全网状，我们可以始终编写一个测试用例来检查我们的生产设备上的iBGP邻居数量。
- en: 'The sequence of TDD is loosely based on the following six steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的顺序大致基于以下六个步骤：
- en: Write a test with the result in mind
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个考虑结果的测试
- en: Run all tests and see whether the new test fails
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行所有测试并查看新测试是否失败
- en: Write the code
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码
- en: Run the test again
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试
- en: Make the necessary changes if the test fails
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果测试失败，进行必要的更改
- en: Repeat
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复
- en: As with any process, how closely we follow the guideline is a judgment call.
    I prefer to treat these guidelines as goals and follow them somewhat loosely.
    For example, the TDD process calls for writing test cases before writing any code
    or, in our instance, before any network components are built. As a personal preference,
    I always like to see a working version of the network or code before writing test
    cases. It gives me a higher level of confidence, so if anybody is judging my TDD
    process, I might just get a big fat “F.” I also like to jump around between different
    levels of testing; sometimes, I test a small portion of the network, Other times,
    I conduct a system-level end-to-end test, such as a ping or traceroute test.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何流程一样，我们遵循指南的紧密程度是一个判断。我更喜欢将这些指南视为目标，并相对宽松地遵循它们。例如，TDD流程要求在编写任何代码之前编写测试用例，或者在我们的例子中，在构建任何网络组件之前。作为一个个人偏好，我总是喜欢在编写测试用例之前看到网络或代码的工作版本。这给了我更高的信心，所以如果有人评判我的TDD过程，我可能会得到一个巨大的“F”。我还喜欢在不同的测试级别之间跳转；有时，我测试网络的一小部分，其他时候，我进行系统级的端到端测试，如ping或traceroute测试。
- en: The point is I do not believe there is a one-size-fits-all approach to testing.
    It depends on personal preference and the scope of the project. This is true for
    most of the engineers I have worked with. It is a good idea to keep the framework
    in mind so we have a working blueprint to follow, but you are the best judge of
    your problem-solving style.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是我不相信存在一种适合所有情况的测试方法。这取决于个人偏好和项目的范围。这对于我合作过的多数工程师来说都是正确的。记住框架是一个好主意，这样我们就有了一个可以遵循的工作蓝图，但你是你解决问题的最佳评判者。
- en: Before we delve further into TDD, let’s cover some of the most common terminologies
    in the following section so that we have a good conceptual grounding before getting
    into more details.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步探讨TDD之前，让我们在下一节中介绍一些最常见的术语，以便我们在深入了解细节之前有一个良好的概念基础。
- en: Test definitions
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试定义
- en: 'Let’s look at some of the terms commonly used in TDD:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看TDD中常用的一些术语：
- en: '**Unit test**: Checks a small piece of code. This is a test that is run against
    a single function or class.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：检查一小段代码。这是一个针对单个函数或类的测试。'
- en: '**Integration test**: Checks multiple components of a code base; multiple units
    are combined and tested as a group. This can be a test that checks against a Python
    module or multiple modules.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：检查代码库的多个组件；多个单元组合并作为一个组进行测试。这可能是一个针对Python模块或多个模块的测试。'
- en: '**System test**: Checks from end to end. This is a test that runs as close
    to what an end user would see as possible.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统测试**：从端到端进行检查。这是一个尽可能接近最终用户所看到内容的测试。'
- en: '**Functional test**: Checks against a single function.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能测试**：针对单个函数进行检查。'
- en: '**Test coverage**: A term defined as the determination of whether our test
    cases cover the application code. This is typically done by examining how much
    code is exercised when we run the test cases.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试覆盖率**：一个术语，指的是确定我们的测试用例是否覆盖了应用程序代码。这通常是通过检查运行测试用例时执行了多少代码来完成的。'
- en: '**Test fixtures**: A fixed state that forms a baseline for running our tests.
    The purpose of a test fixture is to ensure there is a well-known and fixed environment
    in which tests are run so they are repeatable.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试固定装置**：形成一个基准状态，用于运行我们的测试。测试固定装置的目的是确保有一个已知且固定的环境，以便测试可以重复进行。'
- en: '**Setup and teardown**: All the prerequisite steps are added in the setup and
    cleaned up in the teardown.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置和拆除**：所有先决步骤都添加到设置中，并在拆除时清理。'
- en: The terms might seem very software development-centric, and some might not be
    relevant to network engineering. Remember that the terms are a way for us to communicate
    a concept or step. We will be using these terms in the rest of this chapter. As
    we use the terms more in the network engineering context, they might become clearer.
    With that covered, let’s dive into treating network topology as code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '这些术语可能看起来非常侧重于软件开发，有些人可能对网络工程不相关。记住，这些术语是我们用来传达一个概念或步骤的方式。我们将在本章的其余部分使用这些术语。随着我们在网络工程环境中更多地使用这些术语，它们可能会变得更加清晰。在这一点上，让我们深入探讨将网络拓扑视为代码。 '
- en: Topology as code
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将拓扑表示为代码
- en: 'When we discuss topology as code, an engineer might jump up and declare: “The
    network is too complex. It is impossible to summarize it into code!” From personal
    experience, this has happened in some of the meetings I have been in. In the meeting,
    we would have a group of software engineers who want to treat infrastructure as
    code, but the traditional network engineers in the room would declare that it
    was impossible. Before you do the same and yell at me across the pages of this
    book, let’s keep an open mind. Would it help if I told you we have been using
    code to describe our topology in this book already?'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论将拓扑表示为代码时，一个工程师可能会跳起来宣称：“网络太复杂了，不可能将其总结成代码！”从个人经验来看，这在我参加的一些会议中发生过。在会议中，我们会有一群希望将基础设施视为代码的软件工程师，但房间里的传统网络工程师会宣称这是不可能的。在你效仿并在这本书的页面上对我大喊大叫之前，让我们保持开放的心态。如果我告诉你，我们已经在本书中使用代码来描述我们的拓扑，这会有帮助吗？
- en: 'If you take a look at any of the lab topology files that we have been using
    in this book, they are simply YAML files that include a description of the relationship
    between nodes. For example, in this chapter, we will use same topology we have
    been using for the last few chapters:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看本书中我们一直在使用的任何实验室拓扑文件，它们只是包含节点之间关系描述的YAML文件。例如，在本章中，我们将使用我们在上一章中使用的相同拓扑：
- en: '![](img/B18403_16_01.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18403_16_01.png)'
- en: 'Figure 16.1: Lab Topology'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1：实验室拓扑
- en: 'If we open up the topology file, `chapter16_topology.yaml`, with a text editor,
    we will see that the file is a YAML file describing the node and the links between
    the nodes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用文本编辑器打开拓扑文件，`chapter16_topology.yaml`，我们会看到该文件是一个描述节点及其之间链接的YAML文件：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The node section include each of the node’s id, label, definition, and configurations:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 节点部分包括每个节点的id、标签、定义和配置：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we open up the previous chapter’s lab topology file, which contain Linux
    nodes, we can see the Linux host nodes can be described the same way as the network
    nodes:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开上一章的实验室拓扑文件，其中包含Linux节点，我们可以看到Linux主机节点可以用与网络节点相同的方式描述：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By expressing the network as code, we can declare a source of truth for our
    network. We can write test code to compare the actual production value against
    this blueprint. We will use this topology file as the base and compare the production
    network value against it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将网络表示为代码，我们可以为我们的网络声明一个真相来源。我们可以编写测试代码来比较实际的生产值与这个蓝图。我们将使用这个拓扑文件作为基础，并将生产网络值与之比较。
- en: XML parsing example
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML解析示例
- en: Besides YAML, another popular way to express topology as code is XML. In fact,
    that was the format that the predecessor of CML 2, Cisco VIRL used. From previous
    editions of the book, I have provided an example of a two-host, two-network node
    example file named `chapter15_topology.virl` for our parsing example.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了YAML之外，另一种流行的将拓扑表示为代码的方式是XML。事实上，这是CML 2的前身Cisco VIRL使用的格式。在本书的前几版中，我已经提供了一个名为`chapter15_topology.virl`的两个主机、两个网络节点示例文件，用于我们的解析示例。
- en: 'To work with XML files, we can use Python to extract the element from this
    topology file and store it as a Python data type so we can work with it. In `chapter16_1_xml.py`,
    we will use `ElementTree` to parse the `virl` topology file and construct a dictionary
    consisting of the information of our devices:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要与XML文件一起工作，我们可以使用Python从该拓扑文件中提取元素，并将其存储为Python数据类型，这样我们就可以处理它了。在`chapter16_1_xml.py`中，我们将使用`ElementTree`解析`virl`拓扑文件，并构建一个包含我们设备信息的字典：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The result is a Python dictionary that consists of the devices according to
    our topology file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个Python字典，它根据我们的拓扑文件包含设备信息。
- en: 'We can also add customary items to the dictionary:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将习惯性项目添加到字典中：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If we want to compare this “source of truth” to the production device version,
    we can use our script from *Chapter 3*, *APIs and Intent-Driven Networking*, `cisco_nxapi_2.py`,
    to retrieve the production NX-OSv device’s software version. We can then compare
    the value we received from our topology file with the production device’s information.
    Later, we can use Python’s built-in `unittest` module to write test cases.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将这个“真相之源”与生产设备版本进行比较，我们可以使用*第3章*，*APIs和Intent-Driven Networking*中的脚本`cisco_nxapi_2.py`来检索生产NX-OSv设备的软件版本。然后我们可以将我们从拓扑文件中收到的值与生产设备的信息进行比较。稍后，我们可以使用Python的内置`unittest`模块来编写测试用例。
- en: We will discuss the `unittest` module in just a bit. Feel free to skip ahead
    and come back to this example if you’d like.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后讨论`unittest`模块。如果您愿意，可以跳过前面的内容，稍后再回到这个例子。
- en: 'Here is the relevant `unittest` code in `chapter16_2_validation.py`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`chapter16_2_validation.py`中的相关`unittest`代码：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we run the validation test, we can see that the test passes because the
    software version in production matches what we expected:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行验证测试时，我们可以看到测试通过，因为生产环境中的软件版本与我们预期的相匹配：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we manually change the expected NX-OSv version value to introduce a failure
    case, we will see the following failed output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们手动更改预期的NX-OSv版本值以引入一个失败案例，我们将看到以下失败输出：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can see that the test case result returned as failed; the reason for the
    failure was the version mismatch between the two values. As we saw in the last
    example, the Python `unittest` module is a great way to test our existing code
    based on our expected results. Let’s take a deeper look at the module.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到测试用例结果返回为失败；失败的原因是两个值之间的版本不匹配。正如我们在上一个例子中看到的，Python的`unittest`模块是一种根据我们的预期结果测试现有代码的绝佳方式。让我们更深入地了解一下这个模块。
- en: Python’s unittest module
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python的`unittest`模块
- en: 'The Python standard library includes a module named `unittest`, which handles
    test cases where we can compare two values to determine whether a test passes.
    In the previous example, we saw how to use the `assertEqual()` method to compare
    two values to return either `True` or `False`. Here is an example, `chapter16_4_unittest.py`,
    that uses the built-in `unittest` module to compare two values:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库中包含一个名为`unittest`的模块，它处理我们可以比较两个值以确定测试是否通过的情况。在先前的例子中，我们看到了如何使用`assertEqual()`方法比较两个值以返回`True`或`False`。以下是一个使用内置`unittest`模块比较两个值的例子，`chapter16_4_unittest.py`：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Using the `python3` command-line interface, the `unittest` module can automatically
    discover the test cases in the script:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`python3`命令行界面，`unittest`模块可以自动在脚本中查找测试用例：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Besides comparing two values, here are more examples of testing whether the
    expected value is `True` or `False`. We can also generate custom failure messages
    when a failure occurs:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 除了比较两个值之外，这里还有一些测试预期值是`True`或`False`的例子。当发生失败时，我们还可以生成自定义的错误消息：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can use `-v` for the option to display a more detailed output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`-v`选项来显示更详细的信息输出：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Starting from Python 3.3, the `unittest` module includes the `mock` object library
    by default ([https://docs.python.org/3/library/unittest.mock.html](https://docs.python.org/3/library/unittest.mock.html)).
    This is a very useful module that you can use to make a fake HTTP API call to
    a remote resource without actually making the call. For example, we have seen
    using NX-API to retrieve the NX-OS version number. What if we want to run our
    test, but we do not have an NX-OS device available? We can use the `unittest`
    mock object.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 3.3开始，`unittest`模块默认包含`mock`对象库（[https://docs.python.org/3/library/unittest.mock.html](https://docs.python.org/3/library/unittest.mock.html)）。这是一个非常有用的模块，您可以使用它来模拟对远程资源的HTTP
    API调用，而不实际进行调用。例如，我们看到了使用NX-API检索NX-OS版本号。如果我们想运行测试，但没有NX-OS设备可用怎么办？我们可以使用`unittest`模拟对象。
- en: 'In `chapter16_5_more_unittest_mocks.py`, we created a class with a method to
    make HTTP API calls and expect a JSON response:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `chapter16_5_more_unittest_mocks.py` 中，我们创建了一个具有执行 HTTP API 调用并期望 JSON 响应的方法的类：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We also created a function that mocks two URL calls:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个模拟两个URL调用的函数：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we make the API call to the two URLs in our test case. However, we
    are using the `mock.patch` decorator to intercept the API calls:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在测试用例中对两个 URL 进行 API 调用。然而，我们正在使用 `mock.patch` 装饰器来拦截 API 调用：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When we run the test, we will see that the test passes without needing to make
    an actual API call to the remote endpoint. Neat, huh?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行测试时，我们将看到测试通过，而无需对远程端点进行实际的 API 调用。不错，对吧？
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For more information on the `unittest` module, Doug Hellmann’s Python module
    of the week ([https://pymotw.com/3/unittest/index.html#module-unittest](https://pymotw.com/3/unittest/index.html#module-unittest))
    is an excellent source of short and precise examples on the `unittest` module.
    As always, the Python documentation is a good source of information as well: [https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `unittest` 模块的更多信息，Doug Hellmann 的 Python 模块每周一讲（[https://pymotw.com/3/unittest/index.html#module-unittest](https://pymotw.com/3/unittest/index.html#module-unittest)）是关于
    `unittest` 模块的短小精悍的示例的极好来源。像往常一样，Python 文档也是一个很好的信息来源：[https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html)。
- en: More on Python testing
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多关于 Python 测试的内容
- en: In addition to the built-in `unittest` library, there are lots of other testing
    frameworks from the Python community. `pytest` is one of the most robust, intuitive
    Python testing frameworks and is worth a look. `pytest` can be used for all types
    and levels of software testing. It can be used by developers, QA engineers, individuals
    practicing TDD, and open source projects.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内置的 `unittest` 库之外，还有来自 Python 社区的许多其他测试框架。`pytest` 是最稳健、最直观的 Python 测试框架之一，值得一看。`pytest`
    可以用于所有类型和级别的软件测试。它可以由开发者、QA 工程师、实践 TDD 的个人和开源项目使用。
- en: Many large-scale open source projects have switched from `unittest` or `nose`
    (another Python test framework) to `pytest`, including Mozilla and Dropbox. The
    attractive features of `pytest` include the third-party plugin model, a simple
    fixture model, and assert rewriting.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 许多大型开源项目已经从`unittest`或`nose`（另一个Python测试框架）切换到`pytest`，包括Mozilla和Dropbox。`pytest`的吸引人之处包括第三方插件模型、简单的
    fixture 模型和断言重写。
- en: 'If you want to learn more about the `pytest` framework, I highly recommend
    *Python Testing with pytest* by Brian Okken (ISBN 978-1-68050-240-4). Another
    great source is the pytest documentation: [https://docs.pytest.org/en/latest/](https://docs.pytest.org/en/latest/).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 `pytest` 框架的信息，我强烈推荐 Brian Okken 的《Python Testing with pytest》（ISBN
    978-1-68050-240-4）。另一个很好的来源是 `pytest` 文档：[https://docs.pytest.org/en/latest/](https://docs.pytest.org/en/latest/)。
- en: '`pytest` is command line-driven; it can find the tests we have written automatically
    and run them by appending the `test` prefix in our function. We will need to install
    `pytest` before we can use it:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest` 是命令行驱动的；它可以自动找到我们编写的测试并运行它们，只需在我们的函数中添加 `test` 前缀即可。在我们能够使用它之前，我们需要安装
    `pytest`：'
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let’s look at some examples using `pytest`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些使用 `pytest` 的示例。
- en: pytest examples
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`pytest` 示例'
- en: 'The first `pytest` example, `chapter16_6_pytest_1.py`, will be a simple assert
    for two values:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `pytest` 示例，`chapter16_6_pytest_1.py`，将是对两个值的简单断言：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we run `pytest` with the `-v` option, `pytest` will give us a pretty robust
    answer for a reason for the failure. The verbose output is one of the reasons
    people like `pytest`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `-v` 选项运行 `pytest` 时，`pytest` 将为我们提供一个关于失败原因的相当健壮的答案。详细的输出是人们喜欢 `pytest`
    的原因之一：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the second `pytest` example, `chapter16_7_pytest_2.py`, we will create a
    `router` object. The `router` object will be initiated with some values of `None`
    and some with default values. We will use `pytest` to test one instance with the
    default and one instance without:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个 `pytest` 示例中，`chapter16_7_pytest_2.py`，我们将创建一个 `router` 对象。`router` 对象将使用一些
    `None` 值和一些默认值进行初始化。我们将使用 `pytest` 测试一个使用默认值和一个未使用默认值的实例：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we run the test, we will see whether the instance was accurately applied
    with the default values:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行测试时，我们将看到实例是否准确应用了默认值：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we were to replace the previous `unittest` example with `pytest`, in `chapter16_8_pytest_3.py`,
    we can see the syntax with `pytest` is simpler:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要用 `pytest` 替换之前的 `unittest` 示例，在 `chapter16_8_pytest_3.py` 中，我们可以看到 `pytest`
    的语法更简单：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then we run the test with the `pytest` command line:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用 `pytest` 命令行运行测试：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Between `unittest` and `pytest`, I find `pytest` more intuitive to use. However,
    since `unittest` is included in the standard library, many teams might prefer
    using the `unittest` module for their testing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `unittest` 和 `pytest` 之间，我发现 `pytest` 更直观易用。然而，由于 `unittest` 包含在标准库中，许多团队可能更倾向于使用
    `unittest` 模块进行测试。
- en: Besides doing tests on code, we can also write tests to test our network as
    a whole. After all, users care more about their services and applications functioning
    properly and less about individual pieces. We will look at writing tests for the
    network in the next section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对代码进行测试外，我们还可以编写测试来测试整个网络。毕竟，用户更关心他们的服务和应用程序能否正常工作，而不是单个组件。我们将在下一节中探讨如何编写针对网络的测试。
- en: Writing tests for networking
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写网络测试
- en: So far, we have been mostly writing tests for our Python code. We have used
    both the `unittest` and `pytest` libraries to assert `True`/`False` and `equal/non-equal`
    values. We were also able to write mocks to intercept our API calls when we do
    not have an actual API-capable device but still want to run our tests.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要编写的是针对我们 Python 代码的测试。我们使用了 `unittest` 和 `pytest` 库来断言 `True`/`False`
    和 `equal/non-equal` 值。我们还能编写模拟来拦截我们的 API 调用，当我们没有实际的 API 兼容设备但仍想运行测试时。
- en: In this section, let’s look at how we can write tests relevant to the networking
    world. There is no shortage of commercial products regarding network monitoring
    and testing. Over the years, I have come across many of them. However, in this
    section, I prefer to use simple, open source tools for my tests.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们看看如何编写与网络世界相关的测试。关于网络监控和测试的商业产品并不缺乏。多年来，我遇到了许多这样的产品。然而，在本节中，我更倾向于使用简单、开源的工具来进行测试。
- en: Testing for reachability
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试可达性
- en: Often, the first step of troubleshooting is to conduct a small reachability
    test. For network engineers, `ping` is our best friend when it comes to network
    reachability tests. It is a way to test the reachability of a host on an IP network
    by sending a small package across the network to the destination.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 故障排除的第一步通常是进行一个小范围的可达性测试。对于网络工程师来说，`ping` 是我们在进行网络可达性测试时的最佳伙伴。通过在网络中发送一个小数据包到目标，这是一种测试
    IP 网络上主机可达性的方法。
- en: 'We can automate the `ping` test via the `OS` module or the `subprocess` module:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `OS` 模块或 `subprocess` 模块自动化 `ping` 测试：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `subprocess` module offers the additional benefit of catching the output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`subprocess` 模块提供了额外的优势，可以捕获输出：'
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: These two modules prove to be very useful in many situations. Any command we
    can execute in the Linux and Unix environments can be executed via the `OS` or
    `subprocess` module.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个模块在许多情况下都证明是非常有用的。我们可以在 Linux 和 Unix 环境中执行的任何命令都可以通过 `OS` 或 `subprocess`
    模块来执行。
- en: Testing for network latency
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试网络延迟
- en: The topic of network latency can sometimes be subjective. Working as network
    engineers, we are often faced with the user saying that the network is slow. However,
    “slow” is a very subjective term.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 网络延迟的话题有时可能是主观的。作为网络工程师，我们经常面临用户说网络慢的情况。然而，“慢”是一个非常主观的术语。
- en: If we could construct tests that turn subjective terms into objective values,
    it would be very helpful. We should do this consistently to compare the values
    over a time series of data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能构建将主观术语转化为客观值的测试，这将非常有帮助。我们应该持续这样做，以便在数据的时间序列中比较值。
- en: 'This can sometimes be difficult since the network is stateless by design. Just
    because one packet is successful does not guarantee success for the next packet.
    The best approach I have seen over the years is to use `ping` across many hosts
    frequently and log the data, conducting a ping-mesh graph. We can leverage the
    same tools we used in the previous example, catch the return-result time, and
    keep a record. We do this in `chapter16_10_ping.py`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这有时可能很困难，因为网络设计上是无状态的。仅仅因为一个数据包成功，并不能保证下一个数据包也会成功。多年来，我看到的最有效的方法是频繁地对多个主机使用
    `ping` 并记录数据，进行 ping-mesh 图。我们可以利用之前示例中使用的相同工具，捕获返回结果的时间，并保存记录。我们在 `chapter16_10_ping.py`
    中这样做：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this case, the result is kept in a `tuple` and put into a `list`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，结果被保存在一个 `tuple` 中，并放入一个 `list` 中：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is not perfect and is merely a starting point for monitoring and troubleshooting.
    However, in the absence of other tools, this offers some baseline of objective
    values.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不完美，这只是监控和故障排除的起点。然而，在没有其他工具的情况下，这提供了一些基准的客观值。
- en: Testing for security
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试安全性
- en: We saw one of the best tools for security testing in *Chapter 6*, *Network Security
    with Python*, which was Scapy. There are lots of open source tools for security,
    but none offer the flexibility that comes with constructing our packets.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第6章*，*Python网络安全*中看到了最好的安全测试工具之一，那就是Scapy。有很多开源的安全工具，但没有一个提供我们构建数据包时的灵活性。
- en: 'Another great tool for network security testing is `hping3` ([https://docs.python-cerberus.org/en/stable/](https://docs.python-cerberus.org/en/stable/)).
    It offers a simple way to generate a lot of packets at once. For example, you
    can use the following one-liner to generate a TCP SYN flood:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于网络安全测试的出色工具是`hping3`([https://docs.python-cerberus.org/en/stable/](https://docs.python-cerberus.org/en/stable/))。它提供了一种简单的方法一次性生成大量数据包。例如，你可以使用以下单行命令生成TCP
    SYN洪水：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Again, since this is a command-line tool, we can use the `subprocess` module
    to automate any `hping3` tests that we want.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，由于这是一个命令行工具，我们可以使用`subprocess`模块来自动化我们想要的任何`hping3`测试。
- en: Testing for transactions
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交易测试
- en: The network is a crucial part of the infrastructure, but it is only a part of
    it. What the users care about is often the service that runs on top of the network.
    If the user is trying to watch a YouTube video or listen to a podcast but cannot,
    in their opinion, the service is broken. We might know that the network transport
    is not at fault, but that doesn’t comfort the user.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是基础设施的重要组成部分，但它只是其中的一部分。用户关心的是运行在网络上方的服务。如果用户试图观看YouTube视频或收听播客，但按他们的观点无法做到，那么他们认为服务是出了问题。我们可能知道网络传输没有问题，但这并不能安慰用户。
- en: For this reason, we should implement tests that are as similar to the user’s
    experience as possible. In the example of a YouTube video, we might not be able
    to duplicate the YouTube experience 100% (unless you work for Google).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该实现尽可能接近用户体验的测试。在YouTube视频的例子中，我们可能无法100%地复制YouTube体验（除非你在Google工作）。
- en: Still, we can implement a layer-7 service as close to the network edge as possible.
    We can then simulate the transaction from a client at a regular interval as a
    transactional test.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们可以在尽可能接近网络边缘的地方实现第7层服务。然后我们可以定期模拟客户端的交易作为交易测试。
- en: 'The Python `HTTP` standard library module is a module that I often use when
    I need to test layer-7 reachability on a web service quickly. We already saw how
    to use it when we were performing network monitoring in *Chapter 4*, *The Python
    Automation Framework – Ansible*, but it’s worth seeing again:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要快速测试网络服务的第7层可达性时，Python的`HTTP`标准库模块是我经常使用的一个模块。我们在*第4章*，*Python自动化框架 –
    Ansible*中已经看到了如何使用它来进行网络监控，但再次看看也是值得的：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If we can simulate a full transaction for the expected service, that is even
    better. But Python’s simple `HTTP` server module in the standard library is always
    a great one for running some ad hoc web service tests.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以模拟预期服务的完整交易，那就更好了。但Python标准库中的简单`HTTP`服务器模块始终是运行一些临时网络服务测试的一个很好的选择。
- en: Testing for network configuration
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络配置测试
- en: In my opinion, the best test for network configuration is using standardized
    templates to generate the configuration and back up the production configuration
    often. We have seen how we can use the Jinja2 template to standardize our configuration
    per device type or role. This will eliminate many of the mistakes caused by human
    error, such as copy and paste.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，网络配置的最佳测试方法是使用标准化模板生成配置，并经常备份生产配置。我们已经看到了如何使用Jinja2模板来根据设备类型或角色标准化我们的配置。这将消除许多由人为错误引起的错误，例如复制粘贴。
- en: Once the configuration is generated, we can write tests against the configuration
    for known characteristics that we would expect before we push the configuration
    to production devices. For example, there should be no overlap of IP addresses
    in all of the network when it comes to loopback IP, so we can write a test to
    see whether the new configuration contains a loopback IP that is unique across
    our devices.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成了配置，我们就可以针对配置编写测试，以验证在将配置推送到生产设备之前我们期望的已知特性。例如，当涉及到回环IP时，所有网络中的IP地址都不应该有重叠，因此我们可以编写一个测试来查看新配置是否包含一个在我们设备中独一无二的回环IP。
- en: Testing for Ansible
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible测试
- en: For the time I have been using Ansible, I cannot recall using a `unittest`-like
    tool to test a playbook. For the most part, the playbooks use modules that were
    tested by module developers.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我使用Ansible的时间里，我不记得使用过类似`unittest`的工具来测试playbook。大部分情况下，playbooks使用的是模块开发者已经测试过的模块。
- en: If you want a lightweight data validation tool, please check out Cerberus ([https://docs.python-cerberus.org/en/stable/](https://docs.python-cerberus.org/en/stable/)).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要一个轻量级的数据验证工具，请查看Cerberus ([https://docs.python-cerberus.org/en/stable/](https://docs.python-cerberus.org/en/stable/))。
- en: Ansible provides unit tests for their library of modules. Unit tests in Ansible
    are currently the only way to drive tests from Python within Ansible’s continuous-integration
    process. The unit tests that are run today can be found under `/test/units` ([https://github.com/ansible/ansible/tree/devel/test/units](https://github.com/ansible/ansible/tree/devel/test/units)).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible为其模块库提供单元测试。Ansible中的单元测试目前是唯一一种在Ansible的持续集成过程中从Python驱动测试的方式。今天运行的单元测试可以在`/test/units`下找到
    ([https://github.com/ansible/ansible/tree/devel/test/units](https://github.com/ansible/ansible/tree/devel/test/units))。
- en: 'The Ansible testing strategy can be found in the following documents:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible测试策略可以在以下文档中找到：
- en: '**Testing Ansible**: [https://docs.ansible.com/ansible/latest/dev_guide/testing.html](https://docs.ansible.com/ansible/latest/dev_guide/testing.html)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试Ansible**: [https://docs.ansible.com/ansible/latest/dev_guide/testing.html](https://docs.ansible.com/ansible/latest/dev_guide/testing.html)'
- en: '**Unit tests**: [https://docs.ansible.com/ansible/latest/dev_guide/testing_units.html](https://docs.ansible.com/ansible/latest/dev_guide/testing_units.html)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**: [https://docs.ansible.com/ansible/latest/dev_guide/testing_units.html](https://docs.ansible.com/ansible/latest/dev_guide/testing_units.html)'
- en: '**Unit testing Ansible modules**: [https://docs.ansible.com/ansible/latest/dev_guide/testing_units_modules.html](https://docs.ansible.com/ansible/latest/dev_guide/testing_units_modules.html)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试Ansible模块**: [https://docs.ansible.com/ansible/latest/dev_guide/testing_units_modules.html](https://docs.ansible.com/ansible/latest/dev_guide/testing_units_modules.html)'
- en: One of the interesting Ansible testing frameworks is Molecule ([https://pypi.org/project/molecule/](https://pypi.org/project/molecule/)).
    It intends to aid in the development and testing of Ansible roles. Molecule supports
    testing with multiple instances, operating systems, and distributions. I have
    not used this tool, but it is where I would start if I wanted to perform more
    testing on my Ansible roles.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的Ansible测试框架之一是Molecule ([https://pypi.org/project/molecule/](https://pypi.org/project/molecule/))。它旨在帮助开发Ansible角色并进行测试。Molecule支持使用多个实例、操作系统和发行版进行测试。我尚未使用此工具，但如果我想对我的Ansible角色进行更多测试，我会从这里开始。
- en: We should now know how to write tests for our network, whether testing for reachability,
    latency, security, transaction, or network configuration.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该知道如何为我们的网络编写测试，无论是测试可达性、延迟、安全性、事务还是网络配置。
- en: In the next section, we will take a look at an extensive testing framework developed
    by Cisco (and recently released as open source) called `pyATS`. Much to their
    credit, releasing such an extensive framework as open source for the benefit of
    the community was a great gesture by Cisco.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨由Cisco（最近作为开源发布）开发的一个广泛的测试框架，称为`pyATS`。Cisco将这样一个广泛的框架作为开源提供给社区，这是一个值得称赞的举动。
- en: pyATS and Genie
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pyATS和Genie
- en: pyATS ([https://developer.cisco.com/pyats/](https://developer.cisco.com/pyats/))
    is an end-to-end testing ecosystem originally developed by Cisco and made available
    to the public in late 2017\. The pyATS library was formerly known as Genie; they
    will often be referred to in the same context. Because of its roots, the framework
    is very focused on network testing.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: pyATS ([https://developer.cisco.com/pyats/](https://developer.cisco.com/pyats/))
    是由Cisco最初开发的一个端到端测试生态系统，并于2017年底向公众开放。pyATS库以前被称为Genie；它们通常在相同的情况下被提及。由于其根源，该框架非常专注于网络测试。
- en: pyATS, and the pyATS library (also known as Genie), was the winner of the 2018
    Cisco Pioneer Award. We should all applaud Cisco for making the framework open
    source and available to the public. Good job, Cisco DevNet!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: pyATS，以及pyATS库（也称为Genie），是2018年Cisco先锋奖的获得者。我们应该为Cisco将框架开源并公开提供而鼓掌。干得好，Cisco
    DevNet！
- en: 'The framework is available on PyPI:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架可在PyPI上找到：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To get started, we can look at some of the example scripts on the GitHub repository,
    [https://github.com/CiscoDevNet/pyats-sample-scripts](https://github.com/CiscoDevNet/pyats-sample-scripts).
    The tests start with creating a testbed file in YAML format. We will create a
    simple `chapter16_pyats_testbed_1.yml` testbed file for our `lax-edge-r1-edg-r1`
    device. The file should look similar to the Ansible inventory file that we have
    seen before:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们可以查看GitHub仓库中的一些示例脚本，[https://github.com/CiscoDevNet/pyats-sample-scripts](https://github.com/CiscoDevNet/pyats-sample-scripts)。测试从创建YAML格式的测试平台文件开始。我们将为我们的`lax-edge-r1-edg-r1`设备创建一个简单的`chapter16_pyats_testbed_1.yml`测试平台文件。文件应类似于我们之前见过的Ansible清单文件：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In our first script, `chapter16_11_pyats_1.py`, we will load the testbed file,
    connect to the device, issue a `show version` command, then disconnect from the
    device:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个脚本`chapter16_11_pyats_1.py`中，我们将加载测试平台文件，连接到设备，发出`show version`命令，然后从设备断开连接：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When we execute the command, we can see the output is a mixture of the `pyATS`
    setup as well as the actual output of the device. This is similar to the Paramiko
    scripts we have seen before but note that `pyATS` took care of the underlying
    connection for us:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行命令时，我们可以看到输出是`pyATS`设置以及设备实际输出的混合。这与我们之前看到的Paramiko脚本类似，但请注意`pyATS`已经为我们处理了底层连接：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the second example, we will see a full example of connection setup, test
    cases, then connection teardown. First, we will add the `lax-cor-r1` device to
    our testbed in `chapter16_pyats_testbed_2.yml`. The additional device is needed
    as the connected device to `iosv-1` for our ping test:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，我们将看到一个完整的连接设置、测试用例然后连接拆除的示例。首先，我们将`lax-cor-r1`设备添加到我们的测试平台`chapter16_pyats_testbed_2.yml`中。由于需要作为ping测试的连接设备，所以需要额外的设备：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In `chapter16_12_pyats_2.py`, we will use the `aest` module from `pyATS` with
    various decorators. Besides setup and cleanup, the `ping` test is in the `PingTestCase`
    class:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chapter16_12_pyats_2.py`中，我们将使用来自`pyATS`的`aest`模块和各种装饰器。除了设置和清理，`ping`测试位于`PingTestCase`类中：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It is best practice to reference the testbed file at the command line during
    runtime:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，最好在命令行中引用测试平台文件：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The output is similar to our first example, with the additions of `STEPS Report`
    and `Detailed Results` with each test case.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与我们的第一个示例类似，增加了每个测试用例的`STEPS Report`和`Detailed Results`。
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output also indicates the log filename that is written to the `/tmp` directory:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 输出还指示了写入`/tmp`目录的日志文件名：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The pyATS framework is a great framework for automated testing. However, because
    of its origin, the support for vendors outside of Cisco is a bit lacking.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: pyATS框架是一个优秀的自动化测试框架。然而，由于其起源，对思科以外的供应商的支持略显不足。
- en: One open source tool for network validation to take note of is Batfish, [https://github.com/batfish/batfish](https://github.com/batfish/batfish),
    from the folks at Intentionet. A primary use case for Batfish is to validate configuration
    changes before deployment. Another open source project is Suzieq ([https://suzieq.readthedocs.io/en/latest/](https://suzieq.readthedocs.io/en/latest/)).
    Suzieq is the first open source, multi-vendor network observability platform application.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值得注意的开源网络验证工具是来自Intentionet团队的Batfish，[https://github.com/batfish/batfish](https://github.com/batfish/batfish)，其主要用途是在部署前验证配置更改。另一个开源项目是Suzieq
    ([https://suzieq.readthedocs.io/en/latest/](https://suzieq.readthedocs.io/en/latest/))。Suzieq是第一个开源的多供应商网络可观察性平台应用程序。
- en: There is a bit of a learning curve involved with `pyATS`; it basically has its
    own way of performing tests that takes some getting used to. Understandably, it
    is also heavily focused on Cisco platforms in its current iteration. The `pyATS`
    core is closed sourced and released in a binary form. The packages that are developed
    to be used with `pyATS`, such as the parser libraries, YANG connectors, and various
    plugins are open sourced. For the open source portion, we are all encouraged to
    make contributions if we would like to add additional vendor support or make syntax
    or process changes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyATS`的学习曲线有点陡峭；它基本上有自己的测试执行方式，需要一些时间来适应。可以理解的是，它在其当前版本中也高度关注思科平台。`pyATS`的核心是闭源的，并以二进制形式发布。为与`pyATS`一起使用而开发的包，如解析库、YANG连接器和各种插件是开源的。对于开源部分，我们都被鼓励做出贡献，如果我们想添加额外的供应商支持或进行语法或流程更改的话。'
- en: We are near the end of the chapter, so let’s go over what we have done in this
    chapter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接近本章的结尾，让我们回顾一下本章我们做了什么。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at TDD and how it can be applied to network engineering.
    We started with an overview of TDD; then, we looked at examples using the `unittest`
    and `pytest` Python modules. Python and simple Linux command-line tools can be
    used to construct tests for network reachability, configuration, and security.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了测试驱动开发（TDD）及其在网络工程中的应用。我们首先对TDD进行了概述；然后，我们通过使用`unittest`和`pytest`Python模块的示例进行了说明。Python和简单的Linux命令行工具可以用来构建网络可达性、配置和安全性的测试。
- en: pyATS is a tool that Cisco released. It is a network-centric automated testing
    framework that we can leverage.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: pyATS是思科发布的一个工具。它是一个以网络为中心的自动化测试框架，我们可以利用它。
- en: Simply put, if it is not tested, it is not trusted. Everything in our network
    should be programmatically tested as much as possible. As with many software concepts,
    TDD is a never-ending service wheel. We strive to have as much test coverage as
    possible, but even at 100% test coverage, we can always find new ways and test
    cases to implement. This is especially true in networking, where the network is
    often the internet, and 100% test coverage of the internet is impossible.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果没有经过测试，我们就无法信任它。我们网络中的每一件事都应尽可能地进行程序化测试。与许多软件概念一样，TDD是一个永无止境的服务轮。我们努力实现尽可能多的测试覆盖率，但即使在100%的测试覆盖率下，我们总能找到新的方法和测试案例来实施。这在网络领域尤其如此，因为网络通常是互联网，而互联网的100%测试覆盖率是不可能的。
- en: We are at the end of the book. I hope you have found the book as much a joy
    to read as it was a joy for me to write. I want to say a sincere “thank you” for
    taking the time to read this book. I wish you success and happiness on your Python
    network journey!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经接近本书的结尾。我希望您发现这本书的阅读乐趣与我写作时的乐趣一样。我想真诚地说一声“谢谢”，感谢您抽出时间阅读这本书。祝您在Python网络之旅中取得成功和幸福！
- en: Join our book community
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的书籍社区
- en: 'To join our community for this book – where you can share feedback, ask questions
    to the author, and learn about new releases – follow the QR code below:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的社区——在那里您可以分享反馈、向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
- en: '![](img/QR_Code2903617220506617062.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2903617220506617062.png)'
