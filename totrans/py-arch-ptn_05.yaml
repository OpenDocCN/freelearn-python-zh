- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: The Data Layer
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据层
- en: The modeling of data when interacting with the application code is as important
    as how that data is stored in storage. The data layer is the layer that developers
    will interact with most often, so creating a good interface is critical to create
    a productive environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与应用程序代码交互时的数据建模与数据在存储中的存储方式一样重要。数据层是开发者将与之交互最多的层，因此创建一个良好的接口对于创建一个高效的环境至关重要。
- en: In this chapter, we will describe how to create a software data layer that interacts
    with storage to abstract the specifics of storing data. We will see what Domain-Driven
    Design is, how to use an Object-Relational Mapping framework, and more advanced
    patterns, like Command Query Responsibility Segregation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将描述如何创建一个与存储交互的软件数据层，以抽象存储数据的细节。我们将了解领域驱动设计是什么，如何使用对象关系映射（Object-Relational
    Mapping，ORM）框架，以及更高级的模式，如命令查询责任分离（Command Query Responsibility Segregation，CQRS）。
- en: We will also talk about how to make changes to the database as the application
    evolves and, finally, techniques to deal with legacy databases when the structure
    has already been defined before our involvement.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论如何随着应用程序的发展对数据库进行更改，最后，我们将介绍在结构在我们介入之前已经定义的情况下处理遗留数据库的技术。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: The Model layer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型层
- en: Database migrations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库迁移
- en: Dealing with legacy databases
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理遗留数据库
- en: Let's start by giving the context of the data design as part of the Model part
    of the **Model-View-Controller** (**MVC**) pattern.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从**模型-视图-控制器**（Model-View-Controller，MVC）模式中的模型部分的数据设计背景开始。
- en: The Model layer
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型层
- en: As we saw when we presented the Model-View-Controller architecture in *Chapter
    2*, *API Design*, the Model layer is the part that's intimately related with the
    data and storing and retrieving it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第二章*中介绍的模型-视图-控制器架构和*API设计*时所见，模型层是与数据紧密相关，负责存储和检索数据的部分。
- en: 'The Model abstracts all the data handling. This not only includes database
    access but also the related business logic. This creates a two-layer structure:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 模型抽象了所有数据处理。这不仅包括数据库访问，还包括相关的业务逻辑。这创建了一个双层结构：
- en: The internal data modeling layer, handling the storage and retrieval of data
    from the database. This layer needs to understand the way the data is stored in
    the database and handles it accordingly.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部数据建模层，负责从数据库中存储和检索数据。这一层需要了解数据在数据库中的存储方式，并相应地处理它。
- en: The next layer creates business logic and uses the internal data modeling layer
    to support it. This layer is in charge of ensuring that the data to be stored
    is consistent and enforces any relationships or constraints.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一层创建业务逻辑，并使用内部数据建模层来支持它。这一层负责确保要存储的数据是一致的，并强制执行任何关系或约束。
- en: It's very common to deal with the data layer as a pure extension of the database
    design, removing the business level or storing it as code in the Controller part.
    While this is doable, it's better to think about whether it's good to explicitly
    add the business layer on top and ensure there's separation between the entity
    models, which makes good business sense, and the database models, which contain
    the details on how to access the database.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据层视为数据库设计的纯粹扩展，移除业务层或将它作为代码存储在控制器部分是很常见的。虽然这样做是可行的，但最好考虑是否明确添加业务层，并确保实体模型与数据库模型之间有明确的分离，这符合良好的业务逻辑，并且数据库模型包含如何访问数据库的详细信息。
- en: Domain-Driven Design
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 领域驱动设计
- en: This way of operating has become common as part of Domain-Driven Design. When
    DDD was first introduced, it was aimed mainly at bridging the gap between the
    specific application and the technology implementing it to try to use proper nomenclature
    and ensure that the code was in sync with the real operations that the users of
    the code would use. For example, banking software will use methods for *lodging*
    and *withdrawing* funds, instead of *adding* and *subtracting* from an account.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操作方式已成为领域驱动设计（Domain-Driven Design，DDD）的一部分。当DDD首次引入时，其主要目标是弥合特定应用与其实现技术之间的差距，试图使用适当的命名法并确保代码与用户将使用的实际操作保持同步。例如，银行软件将使用*存入*和*取出*资金的函数，而不是从账户中*增加*或*减少*。
- en: DDD is not only naming methods and attributes in a way that's consistent with
    the proper jargon of the domain, but also replicating the uses and flows.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: DDD不仅要求命名方法和属性与领域专业术语保持一致，还要求复制其用途和流程。
- en: When paired with **Object-Oriented Programming** (**OOP**), DDD techniques will
    replicate the concepts required by the specific domain as objects. In our previous
    example, we would have an `Account` object that accepts the methods `lodge()`
    and `withdraw()`. These would probably accept a `Transfer` object that would keep
    the proper balance in the source of the funds.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当与面向对象编程（**OOP**）结合时，DDD 技术将复制特定领域所需的概念为对象。在我们的上一个例子中，我们会有一个 `Account` 对象，它接受
    `lodge()` 和 `withdraw()` 方法。这些方法可能接受一个 `Transfer` 对象，以保持资金的来源账户的正确余额。
- en: These days, DDD is understood as the creation of this business-oriented interface
    in the Model layer, so we can abstract the internals on how that's being mapped
    into accesses to the database and present a consistent interface that replicates
    the business flows.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天，DDD 被理解为在模型层创建面向业务接口的过程，这样我们就可以抽象出如何将其映射到数据库访问的内部细节，并呈现一个复制业务流程的一致接口。
- en: DDD requires an intimate knowledge of the specific domain at hand to create
    an interface that makes sense and properly models the business actions. It requires
    close communication and collaboration with business experts to be sure that all
    possible gaps are covered.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: DDD 需要深入了解特定领域，以创建一个有意义的接口并正确地模拟业务操作。它需要与业务专家进行密切的沟通和协作，以确保覆盖所有可能的差距。
- en: For a lot of different concepts, the Model works purely as a replication of
    the schema of the database. This way, if there's a table, it gets translated into
    a Model that accesses that table, replicates the fields, etc. An example of this
    is storing the user in a table with username, full name, subscription, and password
    fields.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多不同的概念，模型纯粹是作为数据库模式的复制来工作的。这样，如果有表，它会被翻译成一个访问该表的模型，复制字段等。一个例子是将用户存储在具有用户名、全名、订阅和密码字段的表中。
- en: But remember that it is not a hard requirement. A Model can use multiple tables
    or combine multiple fields in a way that makes more business sense, even not exposing
    some fields as they should remain internal.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，这并不是一个硬性要求。模型可以使用多个表或以更有业务意义的方式组合多个字段，甚至不暴露某些字段，因为它们应该保持内部。
- en: We will use a relational database using SQL as our default example, as it is
    the most common kind of database. But everything that we are discussing is highly
    applicable to other kinds of databases, especially to document-based databases.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 SQL 作为我们的默认示例，因为我们默认使用的关系数据库是最常见的一种数据库。但我们讨论的一切都高度适用于其他类型的数据库，特别是文档型数据库。
- en: 'For example, the example of the user above has the following fields in the
    database as columns in a SQL table:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，上述用户的示例在数据库中作为 SQL 表的列具有以下字段：
- en: '| Field | Type | Description |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 类型 | 描述 |'
- en: '| `Username` | `String` | Unique username |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `用户名` | `String` | 唯一用户名 |'
- en: '| `Password` | `String` | String describing the hashed password |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `密码` | `String` | 描述散列密码的字符串 |'
- en: '| `Full name` | `String` | Name of the user |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `全名` | `String` | 用户姓名 |'
- en: '| `Subscription end` | `Datetime` | Time when the subscription ends |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `订阅结束` | `Datetime` | 订阅结束的时间 |'
- en: '| `Subscription type` | `Enum (Normal`, `Premium`, `NotSubscribed`) | Kind
    of subscription |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `订阅类型` | `Enum (Normal`, `Premium`, `NotSubscribed`) | 订阅类型 |'
- en: 'But the Model may expose the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但模型可能暴露以下内容：
- en: '| Attribute/Method | Type | Description |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 属性/方法 | 类型 | 描述 |'
- en: '| `username` | String attribute | Directly translates the username column |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `username` | 字符串属性 | 直接翻译用户名列 |'
- en: '| `full_name` | String attribute | Directly translates the full_name column
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `全名` | 字符串属性 | 直接翻译全名列 |'
- en: '| `subscription` | Read-only property | Returns the subscription type column.
    If the subscription has ended (as indicated in the subscription end column), it
    returns `NotSubscribed` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `subscription` | 只读属性 | 返回订阅类型列。如果订阅已结束（如订阅结束列所示），则返回 `NotSubscribed` |'
- en: '| `check_password(password)` | Method | Internally checks whether the `password`
    input is valid by comparing it with the hash password column and returns whether
    it is correct or not |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `check_password(password)` | 方法 | 内部检查输入的 `password` 是否有效，通过与散列密码列进行比较，并返回是否正确
    |'
- en: Note that this hides the password itself, as its internal details are not relevant
    outside the database. It also hides the internal subscription fields, presenting
    instead a single attribute that performs all the relevant checks.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这隐藏了密码本身，因为其内部细节对数据库外部不相关。它还隐藏了内部订阅字段，而是呈现一个执行所有相关检查的单个属性。
- en: This Model transforms the actions from the raw database access to a fully defined
    object that abstracts the access to the database. This way of operating, when
    mapping an object to a table or collection, is called **Object-Relational Mapping**
    (**ORM**).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此模型将原始数据库访问的操作转换为完全定义的对象，该对象抽象了数据库的访问。将对象映射到表或集合的操作方式被称为**对象关系映射**（**ORM**）。
- en: Using ORM
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ORM
- en: As we've seen above, in essence, ORM is performing mapping between the collections
    or tables in a database, and generating objects in an OOP environment.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，本质上，ORM是在数据库中的集合或表之间执行映射，并在面向对象环境中生成对象。
- en: While ORM itself refers to the technique, the way it is usually understood is
    *as a tool*. There are multiple ORM tools available that do the conversion from
    SQL tables to Python objects. This means that, instead of composing SQL statements,
    we will set up properties defined in classes and objects that will then be translated
    automatically by the ORM tool and will connect to the database.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然ORM本身指的是技术，但通常理解的是*作为一个工具*。有多种ORM工具可供选择，可以将SQL表转换为Python对象。这意味着，我们不会编写SQL语句，而是设置在类和对象中定义的属性，然后由ORM工具自动转换，并连接到数据库。
- en: 'For example, a low-level access for a query in the "pens" table could look
    like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对“pens”表中的查询的低级访问可能看起来像这样：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that we are using the DB-API 2.0 standard Python interface, which abstracts
    away the differences between different databases, and allows us to retrieve the
    information using the standard `fetchall()` method.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用DB-API 2.0标准的Python接口，它抽象了不同数据库之间的差异，并允许我们使用标准的`fetchall()`方法检索信息。
- en: To connect Python and an SQL database, the most common ORMs are the ones included
    in the Django framework ([https://www.djangoproject.com/](https://www.djangoproject.com/))
    and SQLAlchemy ([https://www.sqlalchemy.org/](https://www.sqlalchemy.org/)). There
    are other less-used options, such as Pony ([https://ponyorm.org/](https://ponyorm.org/))
    or Peewee ([https://github.com/coleifer/peewee](https://github.com/coleifer/peewee)),
    that aim to have a simpler approach.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接Python和SQL数据库，最常用的ORM是Django框架中包含的ORM（[https://www.djangoproject.com/](https://www.djangoproject.com/)）和SQLAlchemy（[https://www.sqlalchemy.org/](https://www.sqlalchemy.org/)）。还有其他较少使用的选项，如Pony（[https://ponyorm.org/](https://ponyorm.org/)）或Peewee（[https://github.com/coleifer/peewee](https://github.com/coleifer/peewee)），它们旨在采用更简单的方法。
- en: 'Using an ORM, like the one available in the Django framework, instead of creating
    a `CREATE TABLE` statement, we describe the table in code as a class:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ORM，例如Django框架中可用的ORM，而不是创建`CREATE TABLE`语句，我们在代码中将表描述为一个类：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This class allows us to retrieve and add elements using the class.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此类允许我们使用类检索和添加元素。
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The operation that in raw SQL is an `INSERT` is to create a new object and
    then use the .`save()` method to persist the data into the database. In the same
    way, instead of composing a `SELECT` query, the search API can be called. For
    example, this code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始SQL中是`INSERT`操作的操作是创建一个新的对象，然后使用`.save()`方法将数据持久化到数据库中。同样，而不是编写一个`SELECT`查询，可以调用搜索API。例如，以下代码：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Is equivalent to this code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于以下代码：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Using an ORM, compared with composing SQL directly, has some advantages:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接编写SQL相比，使用ORM有一些优势：
- en: Using an ORM detaches the database from the code
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ORM将数据库从代码中分离
- en: It removes the need for using SQL (or learning it)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它消除了使用SQL（或学习它）的需要
- en: It removes some problems with composing SQL queries, like security issues
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它消除了编写SQL查询时的一些问题，如安全问题
- en: Let's take a closer look at these advantages and see their limits.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些优势及其局限性。
- en: Independence from the database
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 独立于数据库
- en: First of all, using an ORM detaches the database usage from the code. This means
    that a specific database can be changed, and the code will run unchanged. This
    can be useful sometimes to run code in different environments or to quickly change
    to use a different database.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用ORM将数据库的使用与代码分离。这意味着可以更改特定的数据库，而代码保持不变。有时这可以在不同的环境中运行代码或快速切换到使用不同的数据库很有用。
- en: A very common use case for this is to run tests in SQLite and use another database
    like MySQL or PostgreSQL once the code is deployed in production.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种非常常见的用例是在SQLite中运行测试，一旦代码在生产环境中部署，就使用MySQL或PostgreSQL等其他数据库。
- en: This approach is not problem-free, as some options may be available in one database
    and not in another. It may be a viable tactic for new projects, but the best approach
    is to run tests and production in the same technologies to avoid unexpected compatibility
    problems.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法并非没有问题，因为某些选项可能在一种数据库中可用，而在另一种数据库中不可用。这可能是一种适用于新项目的可行策略，但最好的方法是使用相同的技术进行测试和生产，以避免意外的兼容性问题。
- en: Independence from SQL and the Repository pattern
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 独立于 SQL 和仓储模式
- en: Another advantage is that you don't need to learn SQL (or whatever language
    is used in the database backend) to work with the data. Instead, the ORM uses
    its own API, which can be intuitive and closer to OOP. This can reduce the barrier
    to entry to work with the code, as developers that are not familiar with SQL can
    understand the ORM code faster.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优势是，你不需要学习 SQL（或数据库后端使用的任何语言）来处理数据。相反，ORM 使用自己的 API，这可能很直观，更接近面向对象。这可以降低使用代码的门槛，因为不熟悉
    SQL 的开发者可以更快地理解 ORM 代码。
- en: Using classes to abstract the access to the persistent layer from the database
    usage is called the **Repository pattern**. Using an ORM will make use of this
    pattern automatically, as it will use programmatic actions without requiring any
    internal knowledge of the database.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类来抽象对持久层的访问，从数据库使用中分离出来，称为 **仓储模式**。使用 ORM 将自动利用此模式，因为它将使用程序性操作，而不需要了解数据库的任何内部知识。
- en: This advantage also has the counterpart that the translation of some actions
    can be clunky and produce highly inefficient SQL statements. This is especially
    true for complicated queries that require you to `JOIN` multiple tables.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个优势也有其对立面，即某些操作的转换可能会很笨拙，并生成效率非常低的 SQL 语句。这尤其适用于需要 `JOIN` 多个表的复杂查询。
- en: A typical example of this is the following example code. The `Books` objects
    have a reference to their author that's stored in a different table and stored
    as a foreign key reference.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这的典型例子是以下示例代码。`Books` 对象有一个指向其作者的不同表的引用，该引用存储为外键引用。
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code is interpreted in the following way:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码被解释如下：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When the number of books is high, all those extra queries can be very costly.
    What we really want to do is
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当书籍数量很多时，所有这些额外的查询可能会非常昂贵。我们真正想要做的是
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This way, only a single query is generated, which is much more efficient than
    the first case.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，只生成一个查询，这比第一种情况要高效得多。
- en: This join has to be manually indicated to the API, in the following way.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个连接必须手动指示给 API，方式如下。
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The need to require the addition of extra information is actually a good example
    of leaking abstractions, as discussed in *Chapter 2*. You are still required to
    understand the details of the database to be able to create efficient code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 需要添加额外信息的必要性实际上是抽象泄露的一个好例子，正如在 *第二章* 中讨论的那样。你仍然需要了解数据库的细节，才能编写高效的代码。
- en: This balance for ORM frameworks, between being intuitive to work with and sometimes
    requiring an understanding of the underlying implementation details, is a balance
    that needs to be defined. The framework itself will take a more or less flexible
    approach depending on how the specific SQL statements used are abstracted over
    a convenient API.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 ORM 框架来说，在易于使用和有时需要了解底层实现细节之间取得平衡，这是一个需要定义的平衡。框架本身将根据所使用的特定 SQL 语句如何通过方便的
    API 抽象来采取或多或少灵活的方法。
- en: No problems related to composing SQL
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与编写 SQL 相关的没有问题
- en: Even if the developer knows how to deal with SQL, there's a lot of gotchas when
    working with it. A pretty important advantage is that using an ORM avoids some
    of the problems of dealing with the direct manipulation of SQL statements. When
    directly composing SQL, it ends up becoming a pure string manipulation to generate
    the desired query. This can create a lot of problems.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 即使开发者知道如何处理 SQL，但在使用它时仍然存在许多陷阱。一个相当重要的优势是使用 ORM 可以避免直接操作 SQL 语句时的一些问题。当直接编写
    SQL 时，最终会变成纯字符串操作来生成所需的查询。这可能会产生很多问题。
- en: 'The most obvious ones are the requirement to compose the proper SQL statement,
    and not to generate a syntactically invalid SQL statement. For example, consider
    the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的是需要正确编写 SQL 语句，而不是生成语法上无效的 SQL 语句。例如，考虑以下代码：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code works for values of `colors` that contain values but will produce
    an error if `colors` is empty.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码适用于包含值的 `colors` 值，但如果 `colors` 为空则会出错。
- en: Even worse, if the query is composed using input parameters directly, it can
    produce security problems. There's a kind of attack called an **SQL injection
    attack** that is aimed at precisely this kind of behavior.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，如果查询是直接使用输入参数组成的，它可能会产生安全问题。有一种叫做**SQL注入攻击**的攻击，正是针对这种行为。
- en: For example, let's say that the query presented above is produced when the user
    is calling a search that can be filtered by different colors. The user is directly
    asked for the colors. A malicious user may ask for the color `'red'; DROP TABLE
    users;`. This will take advantage of the fact that the query is composed as a
    pure string to generate a malicious string that contains a hidden, non-expected
    operation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设上述查询是在用户调用一个可以通过不同颜色进行筛选的搜索时产生的。用户直接被要求提供颜色。一个恶意用户可能会请求颜色 `'red'; DROP
    TABLE users;`。这将利用查询被作为纯字符串组成的事实，生成一个包含隐藏的、非预期的操作的恶意字符串。
- en: To avoid this problem, any input that may be used as part of a SQL query (or
    any other language) needs to be *sanitized*. This means removing or escaping characters
    that may affect the behavior of the expected query.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，任何可能用作SQL查询（或任何其他语言）一部分的输入都需要被*清理*。这意味着删除或转义可能影响预期查询行为的字符。
- en: Escaping characters means that they are properly encoded to be understood as
    a regular string, and not part of the syntax. For example, in Python, to escape
    the character `"` to be included in a string instead of ending the string definition,
    it needs to be preceded by the `\` character. Of course, the `\` character needs
    to be escaped if it needs to be used in a string, in this case doubling it, using
    `\\`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 转义字符意味着它们被正确编码，以便被理解为一个普通字符串，而不是语法的一部分。例如，在Python中，要将字符 `"` 转义以包含在字符串中而不是结束字符串定义，它需要前面有一个
    `\` 字符。当然，如果需要在字符串中使用 `\` 字符，它也需要被转义，在这种情况下需要将其加倍，使用 `\\`。
- en: 'For example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '`"This string contains the double quote character \" and the backslash character
    \\."`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '"这个字符串包含双引号字符 \" 和反斜杠字符 \\。"'
- en: While there are specific techniques to manually compose SQL statements and sanitize
    the inputs, any ORM will sanitize them automatically, greatly reducing the risk
    of SQL injection by default. This is a great win in terms of security and it's
    probably the biggest advantage for ORM frameworks. Manually composing SQL statements
    is generally understood as a bad idea, relying instead on an indirect way that
    guarantees that any input is safe.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有特定的技术可以手动编写SQL语句和清理输入，但任何ORM都会自动清理它们，从而大大降低SQL注入的风险。这在安全性方面是一个巨大的胜利，可能是ORM框架最大的优势。手动编写SQL语句通常被认为是一个坏主意，而是依赖于间接的方式，这样可以保证任何输入都是安全的。
- en: The counterpart is that, even when having a good understanding of the ORM API,
    there are limits to the way elements are read for certain queries or results,
    which may lead to operations that are much more complicated or inefficient using
    an ORM framework than creating a bespoke SQL query.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，即使对ORM API有很好的理解，对于某些查询或结果，元素读取的方式也有其局限性，这可能会导致使用ORM框架的操作比创建定制的SQL查询要复杂得多或效率低下。
- en: This typically happens when creating complex joins. The queries created from
    the ORM are good for straightforward queries but can struggle to create queries
    when there are too many relationships, as it will overcomplicate them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况通常发生在创建复杂的连接时。从ORM生成的查询对于简单的查询来说很好，但当存在太多关系时，它可能会使查询过于复杂，从而难以创建查询。
- en: ORM frameworks will also have an impact in terms of performance, as they require
    time to compose the proper SQL query, encode and decode data, and do other checkups.
    While for most queries this time will be negligible, for specific ones perhaps
    this will greatly increase the time taken to retrieve the data. Unfortunately,
    there's a good chance that, at some point, a specific, tailored SQL query will
    need to be created for some action. When dealing with ORM frameworks, there's
    always a balance between convenience and being able to create exactly the right
    query for the task at hand.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ORM框架也会在性能方面产生影响，因为它们需要时间来编写正确的SQL查询，编码和解码数据，以及进行其他检查。虽然对于大多数查询来说，这段时间可以忽略不计，但对于特定的查询，可能会大大增加检索数据所需的时间。不幸的是，有很大可能性，在某个时候，需要为某些操作创建特定的、定制的SQL查询。在处理ORM框架时，总是在便利性和能够为手头的任务创建正确的查询之间保持平衡。
- en: Another limit of ORM frameworks is that SQL access may allow operations that
    are not possible in the ORM interface. This may be a product of specific plugins
    or capabilities that are unique to the database in use.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ORM框架的另一个限制是，SQL访问可能允许ORM界面中不可能的操作。这可能是特定插件或特定于所使用数据库的独特功能的结果。
- en: If using SQL is the way to go, a common approach is to use prepared statements,
    which are immutable queries with parameters, so they are replaced as part of the
    execution in the DB API. For example, the following code will work in a similar
    way to a `print` statement.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用SQL是可行的方式，一个常见的方法是使用预处理语句，这些语句是不可变的查询，带有参数，因此它们是作为DB API执行的一部分被替换的。例如，以下代码将以类似`print`语句的方式工作。
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code will safely replace the color with the proper input, encoded in a
    safe way. If there''s a list of elements that need to be replaced, that could
    be done in two steps: first, preparing the proper template, with one parameter
    per input, and second, making the replacement. For example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将安全地用正确的输入替换颜色，以安全的方式编码。如果有一个需要替换的元素列表，这可以在两个步骤中完成：首先，准备适当的模板，每个输入一个参数，然后进行替换。例如：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In our examples, we are using a `SELECT *` statement that will return all the
    columns in the table for simplicity, but this is not the correct way of addressing
    them and should be avoided. The problem is that returning all columns may not
    be stable.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用了一个`SELECT *`语句，为了简单起见，它将返回表中的所有列，但这不是正确处理它们的方式，应该避免使用。问题是返回所有列可能不稳定。
- en: 'New columns can be added to a table, so retrieving all columns may change the
    retrieved data, increasing the chance of producing a formatting error. For example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 可以向表中添加新列，因此检索所有列可能会改变检索到的数据，增加产生格式错误的机会。例如：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: An ORM will handle this case automatically, but using raw SQL requires you to
    take this effect into account and always include explicitly the columns to retrieve
    to avoid problems when making changes in the schema later on.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ORM会自动处理这种情况，但使用原始SQL需要你考虑到这种效果，并在更改模式时始终明确包含要检索的列，以避免问题。
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Backward compatibility is critical when dealing with stored data. We will talk
    more about that later in the chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 处理存储数据时，向后兼容性至关重要。我们将在本章后面更多地讨论这一点。
- en: Queries generated programmatically by composing them are called **dynamic queries**.
    While the default strategy should be to avoid them, preferring prepared statements,
    in certain cases dynamic queries are still very useful. There's a level of customization
    that can be impossible to produce unless there's a dynamic query involved.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组合生成的程序化查询被称为**动态查询**。虽然默认策略应该是避免使用它们，而偏好使用预处理语句，但在某些情况下，动态查询仍然非常有用。除非涉及动态查询，否则可能无法产生某种程度的定制。
- en: Exactly what is considered a dynamic query may depend on the environment. In
    some cases, any query that's not a stored query (a query stored in the database
    itself beforehand and called with some parameters) may be considered dynamic.
    From our point of view, we will consider dynamic queries any queries that require
    string manipulation to produce the query.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 动态查询的具体定义可能取决于环境。在某些情况下，任何不是存储查询（事先存储在数据库中并通过某些参数调用的查询）的查询都可能被认为是动态的。从我们的角度来看，我们将把需要字符串操作来生成查询的任何查询视为动态查询。
- en: Even if the selected way to access the database is raw SQL statements, it's
    good to create an abstraction layer that deals with all the specific details of
    the access. This layer should be responsible for storing data, in the proper format
    in the database, without business logic on that.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 即使选择的数据库访问方式是原始SQL语句，创建一个处理所有访问特定细节的抽象层也是好的。这个层应该负责以适当格式在数据库中存储数据，而不涉及业务逻辑。
- en: ORM frameworks will typically work a bit against this, as they are capable of
    handling a lot of complexity and will invite you to overload each of the defined
    objects with business logic. When the translation between the business concept
    and the database table is direct, for example, a user object, this is fine. But
    it's definitely possible to create an extra intermediate layer between the storage
    and the meaningful business object.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ORM框架通常会对此有所抵触，因为它们能够处理大量的复杂性，并会邀请你为每个定义的对象添加业务逻辑。当业务概念与数据库表之间的转换是直接的时候，例如用户对象，这是可以的。但确实可以在存储和有意义的业务对象之间创建一个额外的中间层。
- en: The Unit of Work pattern and encapsulating the data
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作单元模式和数据封装
- en: As we've seen before, ORM frameworks directly translate between tables in the
    database and objects. This creates a representation of the data itself, in the
    way it's stored in the database.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，ORM 框架直接在数据库表和对象之间进行转换。这以数据库中存储的方式创建了对数据的表示。
- en: In most situations, the design of the database will be tightly related to the
    business entities that we've introduced in the DDD philosophy. But that design
    may require an extra step, as some entities may be detached from the internal
    representation of the data, as it's stored inside the database.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，数据库的设计将与我们在 DDD 哲学中引入的业务实体紧密相关。但这个设计可能需要额外的一步，因为某些实体可能与其在数据库内部的数据表示分离。
- en: The creation of methods representing actions that are unique entities is called
    the **Unit of Work pattern**. This means that everything that happens in this
    high-level action is performed as a single unit, even if internally it is implemented
    with multiple database operations. The operation acts atomically for the caller.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将表示独特实体的动作的方法创建称为 **工作单元模式（Unit of Work pattern）**。这意味着在这个高级动作中发生的所有事情都作为一个单一单元执行，即使内部实现可能涉及多个数据库操作。对于调用者来说，操作是原子性的。
- en: If the database allows for it, all the operations in a unit of work should be
    produced inside a transaction to ensure that the whole operation is done in one
    go. The name Unit of Work is very tightly associated with transactions and relational
    databases and normally is not used in databases that are not capable of creating
    transactions, though the pattern can still be used conceptually.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库允许，一个工作单元中的所有操作都应该在一个事务中完成，以确保整个操作一次性完成。工作单元（Unit of Work）这个名称与事务和关系数据库紧密相关，通常不用于无法创建事务的数据库，尽管从概念上讲，这种模式仍然可以使用。
- en: For example, we saw earlier the example of an `Account` class that accepts `.lodge()`
    and `.withdraw()` methods. While it is possible to directly implement an `Account`
    table that contains an integer representing the funds, we can also automatically
    create with any change a double-entry accountability system that keeps track of
    the system.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们之前看到了一个接受 `.lodge()` 和 `.withdraw()` 方法的 `Account` 类的例子。虽然我们可以直接实现一个包含表示资金的整数的
    `Account` 表，但我们也可以自动创建一个双入账责任系统，该系统会跟踪系统中的任何变动。
- en: '`Account` can be called **a Domain Model** to indicate that it''s independent
    of the database representation.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Account` 可以被称为 **领域模型（Domain Model）**，以表明它与数据库表示独立。'
- en: To do so, each `Account` should have `debit` and `credit` internal values that
    change accordingly. If we also add an extra `Log` entry, in a different table,
    for keeping track of movements, it may be implemented as three different classes.
    The `Account` class will be the one to be used to encapsulate the log, while `InternalAccount`
    and `Log` will correspond to tables in the database. Note that a single `.lodge()`
    or `.withdraw()` call will generate multiple accesses to the database, as we'll
    see later.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，每个 `Account` 应该有相应的 `debit` 和 `credit` 内部值。如果我们还在不同的表中添加一个额外的 `Log` 记录，以跟踪变动，它可能被实现为三个不同的类。`Account`
    类将用于封装日志，而 `InternalAccount` 和 `Log` 将对应于数据库中的表。请注意，单个 `.lodge()` 或 `.withdraw()`
    调用将生成对数据库的多次访问，正如我们稍后将会看到的。
- en: '![Shape, arrow'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![形状，箭头'
- en: Description automatically generated](img/B17580_04_01.png)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_04_01.png)
- en: 'Figure 4.1: Design of the Account class'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：`Account` 类的设计
- en: 'The code could be something like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能如下所示：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Account` class is the expected interface. It is not related directly to
    anything in the database but keeps a relation to the `InternalAccount` using the
    unique reference of the `account_number`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Account` 类是预期的接口。它不直接与数据库中的任何内容相关，但通过 `account_number` 的唯一引用与 `InternalAccount`
    保持关系。'
- en: The logic to store the different elements is presented in a different class
    than the ORM models. This can be understood in the way that the ORM model classes
    are the **Repositories** classes and the `Account` model is the **Unit of Work**
    class.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 存储不同元素的逻辑在不同于 ORM 模型的不同类中呈现。这可以通过 ORM 模型类是 **仓库（Repositories）** 类，而 `Account`
    模型是 **工作单元（Unit of Work）** 类来理解。
- en: In some manuals, they use Unit of Work classes, leaving them without much context,
    just as a container to perform the action to store the multiple elements. Nevertheless,
    it's more useful to assign a clear concept behind the `Account` class to give
    context and meaning. And there could be several actions that are appropriate for
    the business entity.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些手册中，他们使用工作单元类，但缺乏上下文，仅仅作为一个执行存储多个元素的容器。然而，给`Account`类赋予一个清晰的概念以提供上下文和意义更有用。并且可能存在几个适合业务实体的适当操作。
- en: Whenever there's an operation, it requires another account, and then a new `Log`
    is created. The `Log` references the source, destination, and amount of the funds,
    and, in a single transaction, performs the operation. This is done in the `commit`
    method.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每当有操作时，都需要另一个账户，然后创建一个新的`Log`。`Log`引用了资金来源、目的地和金额，并在单个事务中执行操作。这是在`commit`方法中完成的。
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In a single transaction, indicated by the usage of the `with transaction.atomic()`
    context manager, it adds and subtracts funds from the accounts, and then saves
    the three related rows, the source, the destination, and the log itself.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个事务中，通过使用`with transaction.atomic()`上下文管理器，它从账户中增加和减少资金，然后保存三个相关行，即源账户、目标账户和日志本身。
- en: The Django ORM requires you to set this atomic decorator, but other ORMs can
    work differently. For example, SQLAlchemy tends to work more by adding operations
    to a queue and requiring you to explicitly apply all of them in a batch operation.
    Please check the documentation of the specific software you are using for each
    case.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Django ORM要求你设置这个原子装饰器，但其他ORM可能工作方式不同。例如，SQLAlchemy倾向于通过向队列中添加操作来工作，并要求你显式地在批量操作中应用所有这些操作。请检查你使用的特定软件的文档以了解每种情况。
- en: A missing detail due to simplicity is the validation that there are enough funds
    to perform the operation. In cases where there aren't enough funds, an exception
    should be produced that will abort the transaction.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于简单性而遗漏的细节是验证是否有足够的资金执行操作。在资金不足的情况下，应产生一个异常来终止事务。
- en: Note how this format allows for each `InternalAccount` to retrieve every `Log`
    associated to the transactions, both debits and credits. That means it can be
    checked that the current amount is correct. This code will calculate the amount
    in an account, based on the logs, and that can be used to check the amount is
    correct.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这种格式如何允许每个`InternalAccount`检索与交易相关的所有`Log`，包括借方和贷方。这意味着可以检查当前金额是否正确。此代码将根据日志计算账户中的金额，这可以用来检查金额是否正确。
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The initial amount is required. The `debit` and `credit` fields are back-references
    to the `Log`, as defined in the `Log` class.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 需要初始金额。`debit`和`credit`字段是`Log`类的反向引用，正如在`Log`类中定义的那样。
- en: From the point of view of a user only interested in operating with `Account`
    objects, all these details are irrelevant. This extra layer allows us to cleanly
    abstract from the database implementation and store any relevant business logic
    there. This can be the exposed business Model layer (of the Domain Model) that
    handles relevant business operations with the proper logic and nomenclature.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从仅对操作`Account`对象感兴趣的用户的角度来看，所有这些细节都是无关紧要的。这一额外的层允许我们干净地抽象数据库实现，并将任何相关的业务逻辑存储在那里。这可以是公开的业务模型层（领域模型的一部分），它使用适当的逻辑和命名法处理相关的业务操作。
- en: CQRS, using different models for read and write
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CQRS，使用不同的模型进行读取和写入
- en: Sometimes a simple CRUD model for the database is not descriptive of how the
    data flows in the system. In some complex settings, it may be necessary to use
    different ways to read the data and to write or interact with the data.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，数据库的简单CRUD模型并不能描述系统中的数据流。在某些复杂设置中，可能需要使用不同的方式来读取数据，以及写入或与数据交互。
- en: A possibility is that sending data and reading it happen at different ends of
    a pipeline. For example, this is something that happens in event-driven systems,
    where the data is recorded in a queue, and then later processed. In most cases,
    this data is processed or aggregated in a different database.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能性是发送数据和读取数据发生在管道的不同端。例如，这在事件驱动系统中发生，其中数据记录在队列中，然后稍后处理。在大多数情况下，这些数据在不同的数据库中处理或汇总。
- en: Let's see a more specific example. We store sales for different products. These
    sales contain the SKU (a unique identifier of the product sold) and the price.
    But we don't know, at the time of the sale, what the profit from the sale is,
    as the buying of the product depends on fluctuations of the market. The storing
    of a sale goes to a queue to start the process to reconcile it with the price
    paid. Finally, a relational database stores the final sale entry, which includes
    the purchase price and profit.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个更具体的例子。我们存储不同产品的销售额。这些销售额包含SKU（销售产品的唯一标识符）和价格。但在销售时，我们不知道销售利润是多少，因为产品的购买取决于市场的波动。销售存储到队列中，以启动与支付价格进行对账的过程。最后，关系数据库存储最终的销售额条目，包括购买价格和利润。
- en: The flow of information goes from the Domain Model to the queue, then by some
    external process to the relational database, where it is then represented with
    a relational model in an ORM way, and then back to the Domain Model.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 信息流从领域模型到队列，然后通过某些外部过程到关系数据库，在那里它以ORM方式表示为关系模型，然后返回到领域模型。
- en: This structure is called **Command Query Responsibility Segregation** (**CQRS**),
    meaning that the Command (write operations) and Query (read operations) are separated.
    The pattern is not unique to event-driven structures; they are typically seen
    in these systems because their nature is to detach the input data from the output
    data.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构被称为**命令查询责任分离**（**CQRS**），意味着命令（写操作）和查询（读操作）是分离的。这种模式并非仅限于事件驱动结构；它们通常出现在这些系统中，因为它们的本质是使输入数据与输出数据分离。
- en: The Domain Model may require different methods to deal with the information.
    The input and output data has a different internal representation, and sometimes
    it may be easier to clearly distinguish them. It's anyway a good idea to use an
    explicit Domain Model layer for CQRS to group the functionality and treat it as
    a whole. In certain cases, the models and data may be quite different for read
    and write. For example, if there's a step where aggregated results are generated,
    that may create extra data in the read part that's never written.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型可能需要不同的方法来处理信息。输入和输出数据有不同的内部表示，有时可能更容易清楚地区分它们。无论如何，使用显式的领域模型层来对CQRS进行分组并将它作为一个整体处理都是一个好主意。在某些情况下，读和写模型和数据可能相当不同。例如，如果有一个生成聚合结果的步骤，那么它可能会在读取部分创建额外的数据，而这些数据永远不会被写入。
- en: A description of the process of how the read and write parts connect is out
    of scope in our examples. In our example, that process would be how the data is
    stored in the database, including the amount paid.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，读取和写入部分连接的过程超出了范围。在我们的示例中，这个过程将是数据如何在数据库中存储，包括支付的金额。
- en: 'The following diagram depicts the flow of information in a CQRS structure:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了CQRS结构中的信息流：
- en: '![Diagram'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图表'
- en: Description automatically generated](img/B17580_04_02.png)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_04_02.png)
- en: 'Figure 4.2: The flow of information in a CQRS structure'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：CQRS结构中的信息流
- en: 'Our model''s definition could be like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模型定义可能如下所示：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note how the flow is different for save and retrieve:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意保存和检索时的流程是不同的：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: CQRS systems are complex, as the data in and the data out is different. They
    also normally incur some delay in being able to retrieve the information back,
    which can be inconvenient.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS系统是复杂的，因为输入数据和输出数据是不同的。它们通常在检索信息时会有一些延迟，这可能会不方便。
- en: Another important problem in CQRS systems is the fact that the different pieces
    need to be in sync. This includes both the read and write models, but also any
    transformation that happens within the pipeline. Over time, this creates a maintenance
    requirement, especially when backward compatibility needs to be maintained.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS系统中的另一个重要问题是不同部分需要保持同步。这包括读模型和写模型，以及管道中发生的任何转换。随着时间的推移，这会创建维护需求，尤其是在需要保持向后兼容性时。
- en: All these problems make CQRS systems complicated. They should be used with care
    only when strictly necessary.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题都使得CQRS系统变得复杂。只有在绝对必要时才应谨慎使用。
- en: Database migrations
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库迁移
- en: An unavoidable fact of development is that software systems are always changing.
    While the pace of changes in the database is typically not as fast as other areas,
    there are still changes and they need to be treated carefully.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 开发中不可避免的事实是软件系统总是在变化。虽然数据库变化的步伐通常不如其他领域快，但仍然有变化，并且需要谨慎处理。
- en: 'Data changes are roughly categorized into two different kinds:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 数据更改大致分为两种不同类型：
- en: '**Format or schema changes**: New elements, like fields or tables, to be added
    or removed; or changes in the format of some fields.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**格式或模式更改**：需要添加或删除的新元素，如字段或表格；或者某些字段格式的更改。'
- en: '**Data changes**: Requiring changing the data itself, without modifying the
    format. For example, normalizing an address field including the zip code, or making
    a string field uppercase.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据更改**：需要更改数据本身，而不修改格式。例如，将包括邮政编码的地址字段进行规范化，或将字符串字段转换为大写。'
- en: Backward compatibility
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向后兼容性
- en: The basic principle related to changes in the database is backward compatibility.
    This means that any single change in the database needs to work **without** any
    change in the code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库更改相关的基本原则是向后兼容性。这意味着数据库中的任何单个更改都需要在没有代码更改的情况下工作**而不**需要任何更改。
- en: This allows you to make changes without interrupting the service. If the changes
    in the database require a change in the code to understand it, the service will
    have to be interrupted. This is because you can't apply both changes at the same
    time, and if there is more than one server executing the code, it can't be applied
    simultaneously.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你在不中断服务的情况下进行更改。如果数据库中的更改需要更改代码来理解它，则必须中断服务。这是因为你不能同时应用这两个更改，如果有多个服务器正在执行代码，则不能同时应用。
- en: Of course, there's another option, which is to stop the service, perform all
    the changes, and restart again. While this is not great, it could be an option
    for small services or if scheduled downtime is acceptable.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有一个选项，即停止服务，执行所有更改，然后重新启动。虽然这不是最佳选择，但对于小型服务或如果可以接受计划内的停机时间，这可能是一个选择。
- en: Depending on the database, there are different approaches to data changes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数据库的不同，数据更改有不同的方法。
- en: For relational databases, given that they require a fixed structure to be defined,
    any change in the schema needs to be applied to the whole database as a single
    operation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于关系型数据库，由于它们需要定义固定的结构，任何模式更改都需要作为一个单一操作应用到整个数据库。
- en: For other databases that don't force defining a schema, there are ways of updating
    the database in a more iterative way.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不强制定义模式的数据库，有方法以更迭代的方式更新数据库。
- en: Let's take a look at the different approaches.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看不同的方法。
- en: Relational schema changes
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系型模式更改
- en: In relational databases, each individual schema change is applied as a SQL statement
    that operates like a transaction. The schema change, called a **migration**, can
    happen at the same time that some transformation of the data (for example, transforming
    integers to strings) takes place.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系型数据库中，每个单独的模式更改都作为一个操作类似事务的 SQL 语句来应用。模式更改，称为**迁移**，可以在某些数据转换（例如，将整数转换为字符串）发生的同时发生。
- en: Migrations are SQL commands that perform changes in an atomic way. They can
    involve changing the format of tables in the database, but also more operations
    like changing the data or multiple changes in one go. This can be achieved by
    creating a single transaction that groups these changes. Most ORM frameworks include
    support to create migrations and perform these operations natively.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移是执行更改的原子性 SQL 命令。它们可以涉及更改数据库中表格式，也可以涉及更多操作，如更改数据或一次进行多个更改。这可以通过创建一个将所有这些更改组合在一起的单一事务来实现。大多数
    ORM 框架都包括创建迁移和执行这些操作的原生支持。
- en: For example, Django will automatically create a migration file by running the
    command `makemigrations`. This command needs to be run manually, but it will detect
    any change in the models and make the proper changes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Django 将通过运行命令 `makemigrations` 自动创建迁移文件。这个命令需要手动运行，但它将检测模型中的任何更改并做出适当的更改。
- en: For example, if we add an extra value `branch_id` in the class introduced before
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们向之前引入的类中添加一个额外的值 `branch_id`
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Running the command `makemigrations` will generate the proper file that describes
    the migration.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令 `makemigrations` 将生成描述迁移的适当文件。
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that Django keeps track of the state in the models and automatically adjusts
    the changes creating the proper migration files. The pending migrations can be
    applied automatically with the command `migrate`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Django 会跟踪模型中的状态，并自动调整更改以创建适当的迁移文件。可以通过命令 `migrate` 自动应用挂起的迁移。
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Django will store in the database the status of the applied migrations, to be
    sure that each one is applied exactly once.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Django 将存储已应用迁移的状态，以确保每个迁移都恰好应用一次。
- en: Keep in mind that, to properly use migrations through Django no alterations
    outside of this method should be made, as this can confuse and create conflicts.
    If you need to apply changes that can't be replicated automatically with a change
    in the model, like a data migration, you can create an empty migration and fill
    it with your custom SQL statements. This can create complex, custom migrations,
    but that will be applied and kept in track with the rest of the automatically
    created Django migrations. Models can also be explicitly marked as not-handled
    by Django to manage them manually.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，为了通过Django正确使用迁移，不应在此方法之外进行任何更改，因为这可能会造成混淆并产生冲突。如果您需要应用无法通过模型更改自动复制的更改，如数据迁移，您可以创建一个空迁移，并用您的自定义SQL语句填充它。这可以创建复杂、定制的迁移，但它们将与自动创建的其余Django迁移一起应用并保持跟踪。模型也可以明确标记为Django不处理，以便手动管理。
- en: For more details about Django migrations, check the documentation at [https://docs.djangoproject.com/en/3.2/topics/migrations/](https://docs.djangoproject.com/en/3.2/topics/migrations/).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Django迁移的更多详细信息，请查看[https://docs.djangoproject.com/en/3.2/topics/migrations/](https://docs.djangoproject.com/en/3.2/topics/migrations/)文档。
- en: Changing the database without interruption
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无中断更改数据库
- en: 'The process to migrate the data, then, needs to happen in the following order:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移数据的流程需要按照以下顺序进行：
- en: The old code and the old database schema are in place. This is the starting
    point.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旧代码和旧数据库架构已经就绪。这是起点。
- en: The database applies a migration that's backward compatible with the old code.
    As the database can apply this change while in operation, the service is not interrupted.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库应用了一个与旧代码向后兼容的迁移。由于数据库可以在运行时应用此更改，因此服务不会被中断。
- en: The new code taking advantage of the new schema is deployed. This deployment
    won't require any special downtime and can be performed without interrupting the
    process.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用新架构的新代码已部署。这次部署不会需要任何特殊的停机时间，并且可以在不中断进程的情况下执行。
- en: The critical element of this process is step 2, to ensure that the migration
    is backward compatible with the previous code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个流程的关键步骤是第2步，以确保迁移与之前的代码向后兼容。
- en: Most of the usual changes are relatively simple, like adding a new table or
    column to a table, and you'll have no problem with that. The old code won't make
    use of the column or table, and that will be totally fine. But other migrations
    can be more complex.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数常规更改相对简单，比如向表中添加一个新的表格或列，你不会遇到任何问题。旧代码不会使用该列或表格，这完全没问题。但其他迁移可能更复杂。
- en: For example, let's imagine that a field `Field1` that has so far been an integer
    needs to be translated into a string. There'll be numbers stored, but also some
    special values like `NaN` or `Inf` that are not supported by the database. The
    new code will decode them and deal with them correctly.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们假设一个字段`Field1`之前一直是整数，现在需要将其转换为字符串。将存储数字，但也有一些数据库不支持的特殊值，如`NaN`或`Inf`。新代码将解码它们并正确处理。
- en: But obviously, a change that migrates the code from an integer to a string is
    going to produce an error if this is not taken into account in the old code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 但显然，如果旧代码没有考虑到这一点，将代码从整数迁移到字符串的更改将产生错误。
- en: 'To solve this problem, it needs to be approached as a series of steps instead:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，需要将其视为一系列步骤：
- en: The old code and the old database schema are in place. This is the starting
    point.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旧代码和旧数据库架构已经就绪。这是起点。
- en: The database applies a migration adding a new column, `Field2`. In this migration,
    the value from `Field1` is translated into a string and copied.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库应用了一个添加新列`Field2`的迁移。在这个迁移中，`Field1`的值被转换为字符串并复制。
- en: A new version of the code, intermediate code, is deployed. This version understands
    there may be one (`Field2`) or two columns (`Field1` and `Field2`). It uses the
    value in `Field2`, not the one in `Field1`, but if there's a write, it should
    overwrite both.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署了一个新版本的代码，中间代码。这个版本理解可能有一个（`Field2`）或两个列（`Field1`和`Field2`）。它使用`Field2`中的值，而不是`Field1`中的值，但如果进行写入，则应覆盖两者。
- en: To avoid having a problem with possible updates between the application of the
    migration and the new code, the code will need to check if the column `Field1`
    exists, and if it does and has a different value than `Field2`, update the latter
    before performing any operation.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了避免在迁移应用和新代码之间可能出现的更新问题，代码需要检查列`Field1`是否存在，如果存在并且其值与`Field2`不同，则在执行任何操作之前更新后者。
- en: A new migration removing `Field1`, now unused, can be applied.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以应用一个新的迁移来删除现在不再使用的`Field1`。
- en: In the same migration, the same caveat as above should be applied – if the value
    in `Field1` is different from the one in `Field2`, overwrite it with `Field1`.
    Note how the only case where this may happen is if it has been updated with the
    old code.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在相同的迁移中，应应用上述相同的注意事项——如果`Field1`中的值与`Field2`中的值不同，则用`Field1`覆盖它。注意，这种情况可能发生的唯一情况是如果它已经被旧代码更新过。
- en: The new code that is only aware of `Field2` can now be deployed safely.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的代码，仅对`Field2`有意识，现在可以安全部署。
- en: Depending on whether `Field2` is an acceptable name or not, it may be possible
    that a further migration is deployed changing the name from `Field2` to `Field1`.
    In that case, the new code needs to be prepared in advance to use `Field2` or,
    if not present, `Field1`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 根据是否`Field2`是一个可接受的名字，可能还需要部署进一步的迁移，将名字从`Field2`更改为`Field1`。在这种情况下，需要提前准备新代码以使用`Field2`，如果不存在，则使用`Field1`。
- en: 'A new deployment could be done after that to use only `Field1` again:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 之后可以执行新的部署，再次仅使用`Field1`：
- en: '![Graphical user interface'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面'
- en: Description automatically generated](img/B17580_04_03.png)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_04_03.png)
- en: 'Figure 4.3: Migrating from Field1 to Field2'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：从Field1迁移到Field2
- en: If this seems like a lot of work, well, it is. All these steps are required
    to enforce smooth operation and achieve no downtime. The alternative is to stop
    the old code, perform the migration with the format change in `Field1`, and then
    start the new code. But this can cause several problems.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来像是一项大量工作，那么确实如此。所有这些步骤都是必需的，以确保平稳运行并实现零停机。另一种选择是停止旧代码，执行在`Field1`中格式更改的迁移，然后启动新代码。但这可能会引起几个问题。
- en: The most obvious is the downtime. While the impact can be minimized by trying
    to set up a proper maintenance window, most modern applications are expected to
    work 24x7 and any downtime is considered a problem. If the application has a global
    audience, it may be difficult to justify a stop just for avoidable maintenance.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的是停机时间。虽然可以通过尝试设置适当的维护窗口来最小化影响，但大多数现代应用程序都期望24x7工作，任何停机都被视为问题。如果应用程序有全球受众，可能很难证明仅仅为了避免可避免的维护而停止是合理的。
- en: The downtime also may last a while, depending on the migration side. A common
    problem is testing the migration in a database much smaller than the production
    one. This can create an unexpected problem when running in production, taking
    much longer than anticipated. Depending on the size of the data, a complex migration
    may take hours to complete. And, given that it will run as part of a transaction,
    it needs to be totally completed before proceeding or it will be rolled back.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 停机时间也可能持续一段时间，这取决于迁移的一侧。一个常见的问题是，在比生产数据库小得多的数据库中测试迁移。这可能在生产中运行时产生意外问题，所需时间比预期的要长。根据数据的大小，复杂的迁移可能需要数小时才能完成。而且，由于它将作为事务的一部分运行，必须在继续之前完全完成，否则将回滚。
- en: If possible, try to test the migrations of the system with a big enough test
    database that's representative. Some operations can be quite costly. It's possible
    that some migrations may need to be tweaked to run faster or even divided into
    smaller steps so each one can run in its own transaction to run in a reasonable
    time. It's even possible in some cases that the database will require more memory
    to allow the migration to run in a reasonable amount of time.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能，尝试使用足够大的、具有代表性的测试数据库来测试系统的迁移。一些操作可能相当昂贵。可能有些迁移可能需要调整以加快运行速度，甚至可以分成更小的步骤，以便每个步骤都可以在自己的事务中运行，以在合理的时间内完成。在某些情况下，数据库可能需要更多的内存来允许在合理的时间内运行迁移。
- en: But another problem is the risk of introducing a step, at the start of the new
    code, that can have problems and bugs, either related to the migration, or unrelated.
    With this process, after the migration is applied, there's no possibility of using
    the old code. If there's a bug in the new code, it needs to be fixed and a newer
    version deployed. This can create big trouble.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 但另一个问题是引入一个步骤的风险，这个步骤在新代码的开始处可能会出现问题，无论是与迁移相关还是无关。使用这个过程，在迁移应用后，就没有使用旧代码的可能性了。如果新代码中存在错误，需要修复并部署更新的版本。这可能会造成大麻烦。
- en: While it's true that, as migrations are not reversible, applying a migration
    is always a risk, the fact that the code stays stable helps mitigate problems.
    Changing a single piece of code is less risky than changing two without being
    able to revert either of them.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然确实，由于迁移不可逆，应用迁移始终存在风险，但代码的稳定性有助于减轻问题。更改单个代码片段的风险低于更改两个而无法撤销任何一个的风险。
- en: Migrations may be reversible, as there could be steps that perform the reverse
    operation. While this is theoretically true, it is extremely difficult to enforce
    in real operations. It's possible that a migration like removing a column is effectively
    not reversible, as data gets lost.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移可能是可逆的，因为可能存在执行反向操作的步骤。虽然这在理论上是正确的，但在实际操作中强制执行却极为困难。可能存在一种迁移，如删除列，实际上是不可逆的，因为数据会丢失。
- en: This way migrations need to be applied very carefully and by ensuring that each
    step is small and deliberate.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，迁移需要非常小心地应用，并确保每一步都小而谨慎。
- en: Keep in mind how migrations inter-operate with the techniques that we talked
    about related to distributed databases. For example, a sharded database will need
    to apply each migration independently to each of the shards, which may be a time-consuming
    operation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，迁移如何与我们在分布式数据库相关技术中讨论的技术交互。例如，分片数据库需要独立地对每个分片应用每个迁移，这可能是一项耗时的操作。
- en: Data migrations
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据迁移
- en: Data migrations are changes in the database that don't change the format but
    change the values of some fields.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 数据迁移是数据库中的更改，不会改变格式，但会改变某些字段的值。
- en: These migrations are produced normally either to correct some error in the data,
    like a bug that stores a value with some encoding error, or to move old records
    to a more up-to-date format. For example, including zip codes in all addresses,
    if not already present, or to change the scale of a measurement from inches to
    centimeters.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这些迁移通常是为了纠正数据中的某些错误，例如存储有编码错误的值的错误，或者将旧记录移动到更现代的格式。例如，如果地址中尚未包含，则包括邮政编码，或将测量的刻度从英寸更改为厘米。
- en: In either case, these actions may need to be performed for all rows or only
    for a selection of them. Applying them only to the relevant subset, if possible,
    can greatly speed up the process, especially for big databases.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，这些操作可能需要针对所有行或仅针对其中的一部分执行。如果可能的话，仅对相关子集应用这些操作可以大大加快处理速度，尤其是在处理大型数据库时。
- en: 'In cases like the scale change described above, the process may require more
    steps to ensure that the code can handle both scales and differentiate between
    them. For example, with an extra field describing the scale. In this case, the
    process will be as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在如上所述的刻度更改等情况下，可能需要更多步骤来确保代码可以处理两种刻度并区分它们。例如，通过一个额外字段来描述刻度。在这种情况下，过程将如下所示：
- en: Create a migration to set a new column, `scale`, to all rows, with a default
    value of `inches`. Any new row introduced by the old code will automatically set
    up the values correctly, by using a default value.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个迁移来为所有行设置一个新的列，`scale`，默认值为`英寸`。任何由旧代码引入的新行将自动使用默认值设置正确的值。
- en: Deploy a new version of the code able to work with both inches and centimeters
    reading the value in `scale`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署一个新版本的代码，能够处理英寸和厘米，读取`scale`中的值。
- en: Set up another migration to change the value of measurement. Each row will change
    both the `scale` and the `measurement` accordingly. Set the default value for
    `scale` to `centimeters`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置另一个迁移来更改测量值。每一行将相应地更改`scale`和`measurement`的值。将`scale`的默认值设置为`厘米`。
- en: Now all the values in the database are in centimeters.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在数据库中的所有值都在厘米。
- en: Optionally, clean up by deploying a new version of the code that doesn't access
    the `scale` field and understands only centimeters, as both scales are not used.
    After that, a new migration removing the column can also be run.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，通过部署一个不访问`scale`字段且只理解厘米的新版本代码来清理，因为这两个刻度都不使用。之后，还可以运行一个新的迁移来删除该列。
- en: Step 5 is optional and normally there's not a great appetite for this kind of
    cleanup, as it's not strictly necessary and the versatility of having the extra
    column may be worth keeping for future usage.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 第5步是可选的，通常没有强烈的清理需求，因为这并不是严格必要的，而保留额外列的灵活性可能值得保留以供未来使用。
- en: As we discussed before, the key element is to deploy code that's able to work
    with both database values, the old and the new, and understand them. This allows
    for a smooth transition between the values.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，关键要素是部署能够同时处理旧的和新的数据库值，并理解它们的代码。这允许在值之间实现平稳过渡。
- en: Changes without enforcing a schema
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不强制执行模式的变化
- en: One of the flexible aspects of non-relational databases is the fact that there's
    typically not an enforced schema. Instead, the stored documents accept different
    formats.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 非关系型数据库的一个灵活方面是通常没有强制执行的架构。相反，存储的文档接受不同的格式。
- en: This means that, instead of an all-or-nothing change as for relational databases,
    a more continuous change and dealing with multiple formats is preferred.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，与关系型数据库的全有或全无更改不同，更连续的更改和处理多个格式更受欢迎。
- en: 'Instead of the application of migrations, which is a concept not really applicable
    here, the code will have to perform the changes over time. In this case, the steps
    are like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于应用迁移的概念，这里并不适用，代码将不得不随着时间的推移进行更改。在这种情况下，步骤如下：
- en: The old code and the old database schema are in place. This is the starting
    point.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旧代码和旧数据库架构已经就绪。这是起点。
- en: Each of the documents in the database has a `version` field.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库中的每个文档都有一个`version`字段。
- en: The new code contains a Model layer with the migration instructions from the
    previous version to the new one – in our example above, to translate `Field1`
    from integer to string.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的代码包含一个模型层，其中包含从旧版本到新版本的迁移指令 - 在我们上面的例子中，将`Field1`从整数转换为字符串。
- en: Every time that a particular document is accessed, the `version` is checked.
    If it's not the latest, `Field1` is transformed into a string, and the version
    is updated. This action happens before performing any operation. After the update,
    the operation is performed normally.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次访问特定文档时，都会检查`version`。如果不是最新的，`Field1`将转换为字符串，并更新版本。此操作在执行任何操作之前发生。更新后，正常执行操作。
- en: This operation runs alongside the normal operation of the system. Given enough
    time, it will migrate, document by document, the whole database.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此操作与系统的正常操作并行运行。给定足够的时间，它将逐个文档地迁移整个数据库。
- en: The `version` field may not be strictly necessary, as the type of `Field1` may
    be easy to infer and change. But it presents the advantage that it makes the process
    explicit, and can be concatenated, migrating an old document from different versions
    in a single access.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`version`字段可能不是绝对必要的，因为`Field1`的类型可能很容易推断和更改。但它提供了使过程明确化的优势，并且可以在单个访问中连接，将旧文档从不同版本迁移。'
- en: If the `version` field is not present, it may be understood as `version 0` and
    be migrated to `version 1`, now including the field.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果没有`version`字段，它可能被视为`version 0`，并迁移到`version 1`，现在包括该字段。
- en: '![Table'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![表'
- en: Description automatically generated](img/B17580_04_04.png)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_04_04.png)
- en: 'Figure 4.4: Changes over time'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：随时间的变化
- en: This process is very clean, but sometimes leaving data in the old format for
    a long time, even if it's not accessed, may not be advisable. It may cause that
    code to migrate from `version` 1 to 2, `version` 2 to 3, etc, if still present
    in the code. If this is the case, an extra process running alongside may be covering
    every document, updating and saving it until the whole database is migrated.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程非常干净，但有时即使数据未被访问，长时间保留旧格式可能也不可取。如果代码中仍然存在，它可能会导致代码从`version` 1迁移到2，从`version`
    2迁移到3等。在这种情况下，可能需要并行运行一个额外的过程，覆盖每个文档，更新并保存它，直到整个数据库迁移完成。
- en: This process is similar to the one described for data migration, though databases
    enforcing schemas need to perform migrations to change the format. In a schema-less
    database, the format can be changed at the same time as the value.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程与描述的数据迁移类似，尽管强制执行模式的数据库需要执行迁移以更改格式。在无模式数据库中，格式可以在更改值的同时更改。
- en: In the same way, a pure data change, like the example seen before where it was
    changing the scale, can be performed without the need for a migration, slowly
    changing the database as we described here. Doing it with a migration ensures
    a cleaner change, though, and may allow a simultaneous change in format.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，纯数据更改，如之前看到的示例中更改比例的情况，可以在不需要迁移的情况下执行，缓慢地更改数据库，正如我们在这里所描述的。使用迁移确保更改更干净，并且可能允许同时更改格式。
- en: Also note that, if this functionality is encapsulated in the internal database
    access layer, the logic above this one may use the newer functionality without
    caring about old formats, as they'll be translated on the fly.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，如果此功能封装在内部数据库访问层中，上面的逻辑可以使用较新的功能，而无需关心旧格式，因为它们将在运行时自动转换。
- en: While there's still data in the database with the old `version`, the code needs
    to be able to interpret it. This can cause some accumulation of old tech, so it's
    also possible to migrate all the data in the background, as it can be done document
    to document, filtering by the old version, while everything is in operation. Once
    this background migration is done, the code can be refactored and cleaned to remove
    the handling of obsolete versions.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据库中仍有旧`版本`的数据时，代码需要能够解释它。这可能会导致一些旧技术的积累，因此也可以在后台迁移所有数据，因为它可以逐文档进行，通过旧版本进行过滤，同时一切都在运行。一旦完成后台迁移，代码就可以重构和清理，以删除对过时版本的处理。
- en: Dealing with legacy databases
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理遗留数据库
- en: ORM frameworks can generate the proper SQL commands to create the database schema.
    When designing and implementing a database from scratch, that means that we can
    create the ORM Model in code and the ORM framework will make the proper adjustments.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ORM框架可以生成创建数据库模式的正确SQL命令。当从头开始设计和实现数据库时，这意味着我们可以在代码中创建ORM模型，ORM框架将进行适当的调整。
- en: This way of describing the schema in code is called **declarative**.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在代码中描述模式的方式被称为**声明式**。
- en: 'But sometimes, we need to work with an existing database that was created previously
    by manually running SQL commands. There are two possible use cases:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时，我们需要处理之前手动运行SQL命令创建的现有数据库。有两种可能的使用场景：
- en: '**The schema will never be under the control of the ORM framework**. In this case,
    we need a way to detect the existing schema and use it.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式将永远不受ORM框架的控制**。在这种情况下，我们需要一种方法来检测现有模式并使用它。'
- en: '**We want to use the ORM framework from this situation to control the fields
    and any new changes**. In this scenario, we need to create a Model that reflects
    the current situation and move from there to a *declarative* situation.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们希望从这种情况使用ORM框架来控制字段和任何新的更改**。在这种情况下，我们需要创建一个反映当前情况的模型，并从那里过渡到一个*声明式*的情况。'
- en: Let's take a look at how to approach these situations.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何处理这些情况。
- en: Detecting a schema from a database
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从数据库检测模式
- en: For certain applications, if the database is stable or it's simple enough, it
    can be used as-is, and you can try to minimize the code to deal with it. SQLAlchemy
    allows you to automatically detect the schema of the database and work with it.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些应用程序，如果数据库稳定或足够简单，可以直接使用，并尝试最小化处理它的代码。SQLAlchemy允许您自动检测数据库的模式并与之工作。
- en: SQLAlchemy is a very powerful ORM-capable library and arguably the best solution
    to perform complex and tailored accesses to a relational database. It allows complex
    definitions on how exactly tables relate to each other and allows you to tweak
    queries and create precise mappings. It's also more complex and potentially more
    difficult to use than other ORM frameworks such as the Django ORM.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy是一个非常强大的ORM功能库，可以说是执行复杂和定制访问关系型数据库的最佳解决方案。它允许对表之间如何相互关联进行复杂的定义，并允许您调整查询和创建精确的映射。与Django
    ORM等其他ORM框架相比，它可能更复杂，也更难以使用。
- en: 'To automatically detect a database, you can automatically detect the tables
    and columns:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要自动检测数据库，可以自动检测表和列：
- en: '[PRE22]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note how the described names for the table `pens` and columns `id`, `name`,
    and `color` are detected automatically. The format of the query is also very similar
    to what a SQL construction will be.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意描述`pens`表和`id`、`name`、`color`列的名称是如何自动检测到的。查询的格式也非常类似于SQL构造。
- en: 'SQLAlchemy allows more complex usages and the creation of classes. For more
    information, refer to its documentation: [https://docs.sqlalchemy.org/](https://docs.sqlalchemy.org/).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy允许更复杂的用法和类的创建。更多信息，请参阅其文档：[https://docs.sqlalchemy.org/](https://docs.sqlalchemy.org/)。
- en: The Django ORM also has a command that allows you to dump a definition of the
    defined tables and relationships, using `inspectdb`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Django ORM也有一个命令，允许您使用`inspectdb`导出定义的表和关系的定义。
- en: '[PRE23]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This creates a `models.py` file that contains the interpretation of the database
    based on the discovery that Django can do. This file may require adjustments.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个`models.py`文件，该文件包含基于Django可以做的数据库解释。此文件可能需要调整。
- en: These methods of operation work perfectly for simple situations, where the most
    important part is to not spend too much effort having to replicate a schema in
    code. Other situations, where the schema gets mutated and requires better handling
    and control over the code, require a different approach.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作方法对于简单情况工作得很好，其中最重要的部分是不必花费太多精力在代码中复制模式。在其他情况下，模式会发生变化，需要更好的代码处理和控制，这就需要不同的方法。
- en: 'Check the Django documentation for more information: [https://docs.djangoproject.com/en/3.2/howto/legacy-databases/](https://docs.djangoproject.com/en/3.2/howto/legacy-databases/).'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 Django 文档以获取更多信息：[https://docs.djangoproject.com/en/3.2/howto/legacy-databases/](https://docs.djangoproject.com/en/3.2/howto/legacy-databases/).
- en: Syncing the existing schema to the ORM definition
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将现有模式同步到ORM定义
- en: In other situations, there's a legacy database that was created by a method
    that cannot be replicated. Perhaps it was done through manual commands. The current
    code may use the database, but we want to migrate the code so we are up-to-date
    with it so we can, on one hand, understand exactly what the different relations
    and formats are, and on another, allow the ORM to make controlled changes to the
    schema in a compatible way. We will see the latter as migrations.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，有一个由无法复制的方法定义的遗留数据库。可能它是通过手动命令完成的。当前代码可能使用该数据库，但我们希望迁移代码，以便我们能够跟上它，这样我们一方面可以确切地了解不同的关系和格式，另一方面允许
    ORM 以兼容的方式对模式进行控制性更改。我们将后者视为迁移。
- en: 'The challenge in this case is to create a bunch of Models in the ORM framework
    that are up-to-date with the definition of the database. This is easier said than
    done, for several reasons:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，挑战在于在ORM框架中创建一系列与数据库定义保持一致的模型。这比说起来要难得多，有以下几个原因：
- en: There can be database features that are not exactly translated by the ORM. For
    example, ORM frameworks don't deal with stored procedures natively. If the database
    has stored procedures, they need to be either removed or replicated as part of
    the software operation.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能存在ORM无法精确翻译的数据库功能。例如，ORM框架不原生处理存储过程。如果数据库有存储过程，它们需要作为软件操作的一部分被移除或复制。
- en: Stored procedures are code functions inside the database that modify it. They
    can be manually called by using a SQL query, but normally they are triggered by
    certain operations, like inserting a new row or changing a column. Stored procedures
    are not very common these days, as they can be confusing to operate, and instead,
    in most cases, system designs tend to see databases as storage-only facilities,
    without the capacity to change the data that is stored. Managing stored procedures
    is complicated, as they can be difficult to debug and keep in sync with external
    code.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存储过程是数据库内部的代码函数，可以修改它。它们可以通过使用SQL查询手动调用，但通常它们是由某些操作触发的，如插入新行或更改列。存储过程现在并不常见，因为它们操作起来可能会令人困惑，而且大多数情况下，系统设计倾向于将数据库视为仅存储的设施，没有改变存储数据的容量。管理存储过程很复杂，因为它们可能难以调试，并且难以与外部代码保持同步。
- en: Stored procedures can be replicated by code that handles that complexity as
    part of a single Unit of Work action when the action will be triggered. This is
    the most common approach these days. But, of course, migrating already-existing
    stored procedures into external code is a process that may not be easy and requires
    care and planning.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存储过程可以通过处理该复杂性的代码在单个工作单元操作中复制。这是目前最常见的方法。但是，当然，将现有的存储过程迁移到外部代码是一个可能不容易且需要谨慎规划和准备的过程。
- en: ORM frameworks can have their quirks in how to set up certain elements, which
    may not be compatible with the already-existing database. For example, how certain
    elements are named. The Django ORM doesn't allow you to set custom names for the
    indices and constraints. For a while, the constraint can remain only in the database,
    but "hidden" in the ORM, but in the long run that can create problems. This means
    that at some point, the index name needs to be changed externally to the compatible
    name.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ORM 框架在设置某些元素方面可能有它们的怪癖，这可能与现有的数据库不兼容。例如，某些元素的命名方式。Django ORM 不允许你为索引和约束设置自定义名称。一段时间内，约束可能只存在于数据库中，但在
    ORM 中是“隐藏”的，但从长远来看可能会产生问题。这意味着在某个时候，需要在外部将索引名称更改为兼容的名称。
- en: Another example of this is the lack of support for composite primary keys in
    the Django ORM, which may require you to create a new numeric column to create
    a surrogate key.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里的另一个例子是 Django ORM 对复合主键的支持不足，这可能需要你创建一个新的数字列来创建一个代理键。
- en: These limitations require that the creation of Models is done carefully and
    there are checks needed to ensure that they work as expected with the current
    schema. The created schema based on the code Models in the ORM framework can be
    produced and compared with the actual schema until there's parity or they are
    close enough.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制要求创建模型时必须谨慎，并且需要检查以确保它们与当前模式一起按预期工作。基于 ORM 框架中的代码模型创建的创建的方案可以生成并与实际方案进行比较，直到它们达到一致性或足够接近。
- en: 'For example, for Django, the following general procedure can be used:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于 Django，可以使用以下一般步骤：
- en: Create a dump of the database schema. This will be used as a reference.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建数据库模式的备份。这将用作参考。
- en: Create the proper Model files. The starting point could be the output from the
    `inspectdb` command described above.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建适当的模型文件。起点可以是上面描述的 `inspectdb` 命令的输出。
- en: Note that the `inspectdb` creates the Models with their metadata set to not
    track changes in the database. That means that Django labels the Models as not
    tracked for changes as migrations. Once verified, this will need to be changed.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`inspectdb` 创建的模型将它们的元数据设置为不跟踪数据库中的更改。这意味着 Django 将模型标记为不跟踪更改的迁移。一旦验证，这将需要更改。
- en: Create a single migration with all the required changes for the database. This migration
    is created normally, with `makemigrations`.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含数据库所需所有更改的单个迁移。这个迁移是通过 `makemigrations` 正常创建的。
- en: Use the command `sqlmigrate` to produce a SQL dump of the SQL statements that
    will be applied by the migration. This generates a database schema that can be
    compared with the reference.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令 `sqlmigrate` 生成将要由迁移应用的所有 SQL 语句的 SQL 备份。这将生成一个可以与参考进行比较的数据库模式。
- en: Adjust the differences and repeat from step 2 onward. Remember to delete the
    migration file each time to generate it from scratch.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整差异并从步骤 2 开始重复。记住每次都要删除迁移文件，以便从头开始生成。
- en: Once the migration is tweaked to produce exactly the results that are currently
    applied, this migration can be applied using the parameter `--fake` or `–fake-initial`,
    meaning that it will be registered as applied, but the SQL won't run.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦迁移调整到产生当前应用的确切结果，可以使用参数 `--fake` 或 `–fake-initial` 应用此迁移，这意味着它将被注册为已应用，但 SQL
    不会运行。
- en: This is a very simplified method. As we discussed above, there are some elements
    that can be difficult to replicate. Changes to the external database to solve
    incompatibility problems may be required.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简化的方法。如我们上面讨论的，有一些元素可能难以复制。为了解决不兼容性问题，可能需要对外部数据库进行更改。
- en: On the other hand, sometimes it can be okay to live with small differences that
    are not creating any problems. For example, a different name in the primary key
    index may be something that can be acceptable and fixed later. Normally, these
    kinds of operations require a long time to be totally completed from a complex
    schema. Plan accordingly and do it in small increments.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有时可以容忍一些不会造成任何问题的微小差异。例如，主键索引中的不同名称可能是可以接受的，稍后可以修复。通常，这类操作需要很长时间才能从复杂的模式中完全完成。相应地规划，并分小步骤进行。
- en: After that, changes can be applied normally by changing the Models and then
    autogenerating migrations.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，可以通过更改模型然后自动生成迁移来正常应用更改。
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we described what the principles behind Domain-Driven Design
    are, to orient the abstraction of storing data and use rich objects that follow
    business principles. We also described ORM frameworks and how they can be useful
    to remove the need to deal with low-level interaction with specific libraries
    to work with the storage layer. We described different useful techniques for the
    code to interact with the database, like the Unit of Work pattern, which is related
    to the concept of a transaction, and CQRS for advanced cases where the write and
    read are addressed to different backends.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了领域驱动设计的原则，以指导数据的存储抽象和使用遵循业务原则的丰富对象。我们还描述了ORM框架以及它们如何有助于消除与特定库的低级交互，以便与存储层工作。我们描述了代码与数据库交互的不同有用技术，如与事务概念相关的工作单元模式，以及针对读写操作针对不同后端的高级情况下的CQRS。
- en: We also discussed how to deal with database changes, both with explicit migrations
    that change the schema and with more soft changes that migrate the data as the
    application is running.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了如何处理数据库变更，包括显式的迁移，这些迁移会改变数据库模式，以及更柔和的变更，这些变更在应用程序运行时迁移数据。
- en: Finally, we described different methods to deal with legacy databases, and how
    to create models to create a proper software abstraction when there's no control
    over the current schema of the data.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们描述了处理遗留数据库的不同方法，以及在没有控制当前数据模式的情况下如何创建模型以创建适当的软件抽象。
