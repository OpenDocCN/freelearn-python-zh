- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structural Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered creational patterns and object-oriented
    programming patterns that help us with object-creation procedures. The next category
    of pattern we want to present is *structural design patterns*. A structural design
    pattern proposes a way of composing objects to provide new functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The adapter pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The decorator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bridge pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The facade pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The flyweight pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The proxy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of this chapter, you will be equipped with the skills to structure
    your code efficiently and elegantly using structural design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: See the requirements presented in [*Chapter 1*](B21896_01.xhtml#_idTextAnchor017).
  prefs: []
  type: TYPE_NORMAL
- en: The adapter pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **adapter** pattern is a structural design pattern that helps us make two
    incompatible interfaces compatible. What does that really mean? If we have an
    old component and we want to use it in a new system, or a new component that we
    want to use in an old system, the two can rarely communicate without requiring
    any code changes. But changing the code is not always possible, either because
    we don’t have access to it, or because it is impractical. In such cases, we can
    write an extra layer that makes all the required modifications for enabling communication
    between the two interfaces. This layer is called an **adapter**.
  prefs: []
  type: TYPE_NORMAL
- en: In general, if you want to use an interface that expects `function_a()`, but
    you only have `function_b()`, you can use an adapter to convert (adapt) `function_b()`
    to `function_a()`.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you are traveling from most European countries to the UK or the USA, or
    the other way around, you need to use a plug adapter for charging your laptop.
    The same kind of adapter is needed for connecting some devices to your computer:
    the USB adapter.'
  prefs: []
  type: TYPE_NORMAL
- en: In the software category, the `zope.interface` package ([https://pypi.org/project/zope.interface/](https://pypi.org/project/zope.interface/)),
    part of the **Zope Toolkit** (**ZTK**), provides tools that help define interfaces
    and perform interface adaptation. These tools are used in the core of several
    Python web framework projects (including Pyramid and Plone).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`zope.interface` was the solution for working with interfaces in Python, proposed
    by the team ([https://zope.dev/](https://zope.dev/)) behind the Zope application
    server and the ZTK before Python introduced built-in mechanisms, with **abstract
    base classes** (also called **ABCs**) first and protocols later.'
  prefs: []
  type: TYPE_NORMAL
- en: Use cases for the adapter pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usually, one of the two incompatible interfaces is either foreign or old/legacy.
    If the interface is foreign, it means that we have no access to the source code.
    If it is old, it is usually impractical to refactor it.
  prefs: []
  type: TYPE_NORMAL
- en: Using an adapter to make things work after they have been implemented is a good
    approach because it does not require access to the source code of the foreign
    interface. It is also often a pragmatic solution if we have to reuse some legacy
    code. That being said, be aware that it can introduce side effects that are hard
    to debug. So, use it with caution.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the adapter pattern – adapt a legacy class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s consider an example where we have a legacy payment system and a new payment
    gateway. The adapter pattern can make them work together without changing the
    existing code, as we are going to see.
  prefs: []
  type: TYPE_NORMAL
- en: 'The legacy payment system is implemented using a class, with a `make_payment()`
    method doing the core of the payment job, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The new payment system is implemented using the following class, providing
    an `execute_payment()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are going to add a class that will provide the `make_payment()` method,
    where we call the `execute_payment()` method on the adaptee object to get the
    payment done. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is how the `PaymentAdapter` class adapts the interface of `NewPaymentGateway`
    to match that of `OldPaymentSystem`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see the result of this adaptation by adding a `main()` function with
    testing code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s recapitulate the complete code (see the `ch04``/adapter/adapt_legacy.py`
    file) of the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: We have some code for the legacy payment system, represented by the `OldPaymentSystem`
    class, providing a `make_payment()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We introduce the new payment system, with the `NewPaymentGateway` class, providing
    an `execute_payment()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add a class for the adapter, `PaymentAdapter`, which has an attribute to
    store the payment system object and a `make_payment()` method; in that method,
    we call the `execute_payment()` method on the payment system object (via `self.system.execute_payment(amount)`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add code for testing our interface adaptation design (and call it within
    the usual `if __name__ == "``__main__"` block).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Executing the code, using `python ch04/adapter/adapt_legacy.py`, should give
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You now get the idea. This adaptation technique allows us to use the new payment
    gateway with existing code that expects the old interface.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the adapter pattern – adapt several classes into a unified interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at another application to illustrate adaptation: a club’s activities.
    Our club has two main activities:'
  prefs: []
  type: TYPE_NORMAL
- en: Hire talented artists to perform in the club
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organize performances and events to entertain its clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the core, we have a `Club` class that represents the club where hired artists
    perform some evenings. The `organize_performance()` method is the main action
    that the club can perform. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the time, our club hires a DJ to perform, but our application should
    make it possible to organize a diversity of performances: by a musician or music
    band, by a dancer, a one-man or one-woman show, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Via our research to try and reuse existing code, we find an open source contributed
    library that brings us two interesting classes: `Musician` and `Dancer`. In the
    `Musician` class, the main action is performed by the `play()` method. In the
    `Dancer` class, it is performed by the `dance()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, to indicate that these two classes are external, we place them
    in a separate module (in the `ch04/adapter/external.py` file). The code includes
    two classes, `Musician` and `Dancer`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The code we are writing, to use these two classes from the external library,
    only knows how to call the `organize_performance()` method (on the `Club` class);
    it has no idea about the `play()` or `dance()` methods (on the respective classes).
  prefs: []
  type: TYPE_NORMAL
- en: How can we make the code work without changing the `Musician` and `Dancer` classes?
  prefs: []
  type: TYPE_NORMAL
- en: 'Adapters to the rescue! We create a generic `Adapter` class that allows us
    to adapt a number of objects with different interfaces into one unified interface.
    The `obj` argument of the `__init__()` method is the object that we want to adapt,
    and `adapted_methods` is a dictionary containing key/value pairs matching the
    method the client calls and the method that should be called. The code for that
    class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When dealing with the instances of the different classes, we have two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: The compatible object that belongs to the `Club` class needs no adaptation.
    We can treat it as is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The incompatible objects need to be adapted first, using the `Adapter` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The result is that the client code can continue using the known `organize_performance()`
    method on all objects without the need to be aware of any interface differences.
    Consider the following `main()` function code to prove that the design works as
    expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s recapitulate the complete code of our adapter pattern implementation
    (in the `ch04/adapter/adapt_to_unified_interface.py` file):'
  prefs: []
  type: TYPE_NORMAL
- en: We import the `Musician` and `Dancer` classes from the `external` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have the `Club` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the `Adapter` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add the `main()` function, which we call within the usual `if __name__ ==
    "``__main__"` block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the output when executing the `python` `ch04/adapter/adapt_to_unified_interface.py`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we managed to make the `Musician` and `Dancer` classes compatible
    with the interface expected by the client code without changing the source code
    of these external classes.
  prefs: []
  type: TYPE_NORMAL
- en: The decorator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A second interesting structural pattern to learn about is the **decorator**
    pattern, which allows a programmer to add responsibilities to an object dynamically,
    and in a transparent manner (without affecting other objects).
  prefs: []
  type: TYPE_NORMAL
- en: There is another reason why this pattern is interesting to us, as you will see
    in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: As Python developers, we can write decorators in a **Pythonic** way (meaning
    using the language’s features), thanks to the built-in decorator feature.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A Python decorator is a callable (function, method, or class) that gets a `func_in`
    function object as input and returns another function object, `func_out`. It is
    a commonly used technique for extending the behavior of a function, method, or
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more details on Python’s decorator feature, see the official documentation:
    [https://docs.python.org/3/reference/compound_stmts.html#function](https://docs.python.org/3/reference/compound_stmts.html#function)'
  prefs: []
  type: TYPE_NORMAL
- en: But this feature should not be completely new to you. We have already encountered
    commonly used decorators in previous chapters (`@abstractmethod`, `@property`)
    and there are several other useful built-in decorators in Python. Now, we are
    going to learn how to implement and use our own decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is no one-to-one relationship between the decorator pattern
    and Python’s decorator feature. Python decorators can actually do much more than
    the decorator pattern. One of the things they can be used for is to implement
    the decorator pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The decorator pattern is generally used for extending the functionality of an
    object. In everyday life, examples of such extensions are adding a silencer to
    a gun, using different camera lenses, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In web frameworks such as Django, which uses decorators a lot, we have decorators
    that can be used for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Restricting access to views (or HTTP-request-handling functions) based on the
    request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the caching behavior on specific views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling compression on a per-view basis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling caching based on specific HTTP request headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering a function as an event subscriber
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting a function with a specific permission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases for the decorator pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The decorator pattern shines when used for implementing cross-cutting concerns,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Data validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, all parts of an application that are generic and can be applied
    to many other parts of it are considered to be cross-cutting concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Another popular example of using the decorator pattern is in **graphical user
    interface** (**GUI**) toolkits. In a GUI toolkit, we want to be able to add features
    such as borders, shadows, colors, and scrolling to individual components/widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the decorator pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python decorators are generic and very powerful. In this section, we will see
    how we can implement a `number_sum()` function that returns the sum of the first
    *n* numbers. Note that this function is already available in the `math` module
    as `fsum()`, but let’s pretend it is not.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s look at the naive implementation (in the `ch04/decorator/number_sum_naive.py`
    file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample execution of this example shows how slow this implementation is. On
    my computer, it takes more than *7* seconds to calculate the sum of the first
    50 numbers. We get the following output when executing the `python` `ch04/decorator/number_sum_naive.py`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'sum_cache = {0: 0}'
  prefs: []
  type: TYPE_NORMAL
- en: 'def number_sum(n):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if n in sum_cache:'
  prefs: []
  type: TYPE_NORMAL
- en: return sum_cache[n]
  prefs: []
  type: TYPE_NORMAL
- en: res = n + number_sum(n - 1)
  prefs: []
  type: TYPE_NORMAL
- en: '# Add the value to the cache'
  prefs: []
  type: TYPE_NORMAL
- en: sum_cache[n] = res
  prefs: []
  type: TYPE_NORMAL
- en: return res
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: from timeit import Timer
  prefs: []
  type: TYPE_NORMAL
- en: t = Timer(
  prefs: []
  type: TYPE_NORMAL
- en: '"number_sum(300)",'
  prefs: []
  type: TYPE_NORMAL
- en: '"from __main__ import number_sum",'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Time: ", t.timeit())'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Time:  0.1288748119986849
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'fib_cache = {0: 0, 1: 1}'
  prefs: []
  type: TYPE_NORMAL
- en: 'def fibonacci(n):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if n in fib_cache:'
  prefs: []
  type: TYPE_NORMAL
- en: return fib_cache[n]
  prefs: []
  type: TYPE_NORMAL
- en: res = fibonacci(n - 1) + fibonacci(n - 2)
  prefs: []
  type: TYPE_NORMAL
- en: fib_cache[n] = res
  prefs: []
  type: TYPE_NORMAL
- en: return res
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: import functools
  prefs: []
  type: TYPE_NORMAL
- en: 'def memoize(func):'
  prefs: []
  type: TYPE_NORMAL
- en: cache = {}
  prefs: []
  type: TYPE_NORMAL
- en: '@functools.wraps(func)'
  prefs: []
  type: TYPE_NORMAL
- en: 'def memoizer(*args):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if args not in cache:'
  prefs: []
  type: TYPE_NORMAL
- en: cache[args] = func(*args)
  prefs: []
  type: TYPE_NORMAL
- en: return cache[args]
  prefs: []
  type: TYPE_NORMAL
- en: return memoizer
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '@memoize'
  prefs: []
  type: TYPE_NORMAL
- en: 'def number_sum(n):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if n == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: return 0
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: return n + number_sum(n - 1)
  prefs: []
  type: TYPE_NORMAL
- en: '@memoize'
  prefs: []
  type: TYPE_NORMAL
- en: 'def fibonacci(n):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if n in (0, 1):'
  prefs: []
  type: TYPE_NORMAL
- en: return n
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: return fibonacci(n - 1) + fibonacci(n - 2)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'def main():'
  prefs: []
  type: TYPE_NORMAL
- en: from timeit import Timer
  prefs: []
  type: TYPE_NORMAL
- en: to_execute = [
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: number_sum,
  prefs: []
  type: TYPE_NORMAL
- en: Timer(
  prefs: []
  type: TYPE_NORMAL
- en: '"number_sum(300)",'
  prefs: []
  type: TYPE_NORMAL
- en: '"from __main__ import number_sum",'
  prefs: []
  type: TYPE_NORMAL
- en: ),
  prefs: []
  type: TYPE_NORMAL
- en: ),
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: fibonacci,
  prefs: []
  type: TYPE_NORMAL
- en: Timer(
  prefs: []
  type: TYPE_NORMAL
- en: '"fibonacci(100)",'
  prefs: []
  type: TYPE_NORMAL
- en: '"from __main__ import fibonacci",'
  prefs: []
  type: TYPE_NORMAL
- en: ),
  prefs: []
  type: TYPE_NORMAL
- en: ),
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in to_execute:'
  prefs: []
  type: TYPE_NORMAL
- en: func = item[0]
  prefs: []
  type: TYPE_NORMAL
- en: print(
  prefs: []
  type: TYPE_NORMAL
- en: 'f''Function "{func.__name__}": {func.__doc__}'''
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: t = item[1]
  prefs: []
  type: TYPE_NORMAL
- en: 'print(f"Time: {t.timeit()}")'
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Function "number_sum": Returns the sum of the first n numbers'
  prefs: []
  type: TYPE_NORMAL
- en: 'Time: 0.2148694'
  prefs: []
  type: TYPE_NORMAL
- en: 'Function "fibonacci": Returns the suite of Fibonacci numbers'
  prefs: []
  type: TYPE_NORMAL
- en: 'Time: 0.202763251'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'class ResourceContentFetcher(Protocol):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def fetch(self, path: str) -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'class ResourceContent:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, imp: ResourceContentFetcher):'
  prefs: []
  type: TYPE_NORMAL
- en: self._imp = imp
  prefs: []
  type: TYPE_NORMAL
- en: 'def get_content(self, path):'
  prefs: []
  type: TYPE_NORMAL
- en: return self._imp.fetch(path)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'class URLFetcher:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def fetch(self, path):'
  prefs: []
  type: TYPE_NORMAL
- en: res = ""
  prefs: []
  type: TYPE_NORMAL
- en: req = urllib.request.Request(path)
  prefs: []
  type: TYPE_NORMAL
- en: with urllib.request.urlopen(
  prefs: []
  type: TYPE_NORMAL
- en: req
  prefs: []
  type: TYPE_NORMAL
- en: ') as response:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if response.code == 200:'
  prefs: []
  type: TYPE_NORMAL
- en: res = response.read()
  prefs: []
  type: TYPE_NORMAL
- en: return res
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'class LocalFileFetcher:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def fetch(self, path):'
  prefs: []
  type: TYPE_NORMAL
- en: 'with open(path) as f:'
  prefs: []
  type: TYPE_NORMAL
- en: res = f.read()
  prefs: []
  type: TYPE_NORMAL
- en: return res
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'def main():'
  prefs: []
  type: TYPE_NORMAL
- en: url_fetcher = URLFetcher()
  prefs: []
  type: TYPE_NORMAL
- en: rc = ResourceContent(url_fetcher)
  prefs: []
  type: TYPE_NORMAL
- en: res = rc.get_content("http://python.org")
  prefs: []
  type: TYPE_NORMAL
- en: print(
  prefs: []
  type: TYPE_NORMAL
- en: f"Fetched content with {len(res)} characters"
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: localfs_fetcher = LocalFileFetcher()
  prefs: []
  type: TYPE_NORMAL
- en: rc = ResourceContent(localfs_fetcher)
  prefs: []
  type: TYPE_NORMAL
- en: pathname = os.path.abspath(__file__)
  prefs: []
  type: TYPE_NORMAL
- en: dir_path = os.path.split(pathname)[0]
  prefs: []
  type: TYPE_NORMAL
- en: path = os.path.join(dir_path, "file.txt")
  prefs: []
  type: TYPE_NORMAL
- en: res = rc.get_content(path)
  prefs: []
  type: TYPE_NORMAL
- en: print(
  prefs: []
  type: TYPE_NORMAL
- en: f"Fetched content with {len(res)} characters"
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Fetched content with 51265 characters
  prefs: []
  type: TYPE_NORMAL
- en: Fetched content with 1327 characters
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: State = Enum(
  prefs: []
  type: TYPE_NORMAL
- en: '"State",'
  prefs: []
  type: TYPE_NORMAL
- en: '"NEW RUNNING SLEEPING RESTART ZOMBIE",'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class Server(ABC):'
  prefs: []
  type: TYPE_NORMAL
- en: '@abstractmethod'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: 'def __str__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return self.name
  prefs: []
  type: TYPE_NORMAL
- en: '@abstractmethod'
  prefs: []
  type: TYPE_NORMAL
- en: 'def boot(self):'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: '@abstractmethod'
  prefs: []
  type: TYPE_NORMAL
- en: 'def kill(self, restart=True):'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'class FileServer(Server):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: self.name = "FileServer"
  prefs: []
  type: TYPE_NORMAL
- en: self.state = State.NEW
  prefs: []
  type: TYPE_NORMAL
- en: 'def boot(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print(f"booting the {self}")
  prefs: []
  type: TYPE_NORMAL
- en: self.state = State.RUNNING
  prefs: []
  type: TYPE_NORMAL
- en: 'def kill(self, restart=True):'
  prefs: []
  type: TYPE_NORMAL
- en: print(f"Killing {self}")
  prefs: []
  type: TYPE_NORMAL
- en: self.state = (
  prefs: []
  type: TYPE_NORMAL
- en: State.RESTART if restart else State.ZOMBIE
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_file(self, user, name, perms):'
  prefs: []
  type: TYPE_NORMAL
- en: msg = (
  prefs: []
  type: TYPE_NORMAL
- en: f"trying to create file '{name}' "
  prefs: []
  type: TYPE_NORMAL
- en: f"for user '{user}' "
  prefs: []
  type: TYPE_NORMAL
- en: f"with permissions {perms}"
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: print(msg)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'class ProcessServer(Server):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: self.name = "ProcessServer"
  prefs: []
  type: TYPE_NORMAL
- en: self.state = State.NEW
  prefs: []
  type: TYPE_NORMAL
- en: 'def boot(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print(f"booting the {self}")
  prefs: []
  type: TYPE_NORMAL
- en: self.state = State.RUNNING
  prefs: []
  type: TYPE_NORMAL
- en: 'def kill(self, restart=True):'
  prefs: []
  type: TYPE_NORMAL
- en: print(f"Killing {self}")
  prefs: []
  type: TYPE_NORMAL
- en: self.state = (
  prefs: []
  type: TYPE_NORMAL
- en: State.RESTART if restart else State.ZOMBIE
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_process(self, user, name):'
  prefs: []
  type: TYPE_NORMAL
- en: msg = (
  prefs: []
  type: TYPE_NORMAL
- en: f"trying to create process '{name}' "
  prefs: []
  type: TYPE_NORMAL
- en: f"for user '{user}'"
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: print(msg)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'class OperatingSystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '"""The Facade"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: self.fs = FileServer()
  prefs: []
  type: TYPE_NORMAL
- en: self.ps = ProcessServer()
  prefs: []
  type: TYPE_NORMAL
- en: 'def start(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '[i.boot() for i in (self.fs, self.ps)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_file(self, user, name, perms):'
  prefs: []
  type: TYPE_NORMAL
- en: return self.fs.create_file(user, name, perms)
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_process(self, user, name):'
  prefs: []
  type: TYPE_NORMAL
- en: return self.ps.create_process(user, name)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'def main():'
  prefs: []
  type: TYPE_NORMAL
- en: os = OperatingSystem()
  prefs: []
  type: TYPE_NORMAL
- en: os.start()
  prefs: []
  type: TYPE_NORMAL
- en: os.create_file("foo", "hello.txt", "-rw-r-r")
  prefs: []
  type: TYPE_NORMAL
- en: os.create_process("bar", "ls /tmp")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: booting the FileServer
  prefs: []
  type: TYPE_NORMAL
- en: booting the ProcessServer
  prefs: []
  type: TYPE_NORMAL
- en: trying to create file 'hello.txt' for user 'foo' with permissions -rw-r-r
  prefs: []
  type: TYPE_NORMAL
- en: OperatingSystem class does a good job. The client code can create files and
    processes without needing to know internal details about the operating system,
    such as the existence of multiple servers. To be precise, the client code can
    call the methods for creating files and processes, but they are currently dummy.
    As an interesting exercise, you can implement one of the two methods, or even
    both.
  prefs: []
  type: TYPE_NORMAL
- en: The flyweight pattern
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Whenever we create a new object, extra memory needs to be allocated. Although
    virtual memory provides us, theoretically, with unlimited memory, the reality
    is different. If all the physical memory of a system gets exhausted, it will start
    swapping pages with the secondary storage, usually a **hard disk drive** (**HDD**),
    which, in most cases, is unacceptable due to the performance differences between
    the main memory and HDD. **Solid-state drives** (**SSDs**) generally have better
    performance than HDDs, but not everybody is expected to use SSDs. So, SSDs are
    not going to totally replace HDDs anytime soon.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Apart from memory usage, performance is also a consideration. Graphics software,
    including computer games, should be able to render 3-D information (for example,
    a forest with thousands of trees, a village full of soldiers, or an urban area
    with a lot of cars) extremely quickly. If each object in a 3-D terrain is created
    individually and no data sharing is used, the performance will be prohibitive.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: As software engineers, we should solve software problems by writing better software,
    instead of forcing the customer to buy extra or better hardware. The **flyweight**
    design pattern is a technique used to minimize memory usage and improve performance
    by introducing data sharing between similar objects. A flyweight is a shared object
    that contains state-independent, immutable (also known as **intrinsic**) data.
    The state-dependent, mutable (also known as **extrinsic**) data should not be
    part of flyweight because this is information that cannot be shared, since it
    differs per object. If flyweight needs extrinsic data, it should be provided explicitly
    by the client code.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: An example might help to clarify how the flyweight pattern can be used practically.
    Let’s assume that we are creating a performance-critical game – for example, a
    **first-person shooter** (**FPS**). In FPS games, the players (soldiers) share
    some states, such as representation and behavior. In *Counter-Strike*, for instance,
    all soldiers on the same team (counter-terrorists versus terrorists) look the
    same (representation). In the same game, all soldiers (on both teams) have some
    common actions, such as jump, duck, and so forth (behavior). This means that we
    can create a flyweight that will contain all of the common data. Of course, the
    soldiers also have a lot of data that is different per soldier and will not be
    a part of the flyweight, such as weapons, health, location, and so on.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Flyweight is an optimization design pattern; therefore, it is not easy to find
    a good non-computing example of it. We can think of flyweight as caching in real
    life. For example, many bookstores have dedicated shelves with the newest and
    most popular publications. This is a cache. First, you can take a look at the
    dedicated shelves for the book you are looking for, and if you cannot find it,
    you can ask the bookseller to assist you.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The Exaile music player uses flyweight to reuse objects (in this case, music
    tracks) that are identified by the same URL. There’s no point in creating a new
    object if it has the same URL as an existing object, so the same object is reused
    to save resources.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Use cases for the flyweight pattern
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Flyweight is all about improving performance and memory usage. All embedded
    systems (phones, tablets, games consoles, microcontrollers, and so forth) and
    performance-critical applications (games, 3-D graphics processing, real-time systems,
    and so forth) can benefit from it.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The *Gang of Four* (*GoF*) book lists the following requirements that need
    to be satisfied to effectively use the flyweight pattern:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The application needs to use a large number of objects.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are so many objects that it’s too expensive to store/render them. Once
    the mutable state is removed (because if it is required, it should be passed explicitly
    to flyweight by the client code), many groups of distinct objects can be replaced
    by relatively few shared objects.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Object identity is not important for the application. We cannot rely on object
    identity because object sharing causes identity comparisons to fail (objects that
    appear different to the client code end up having the same identity).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the flyweight pattern
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s see how we can implement an example featuring cars in an area. We will
    create a small car park to illustrate the idea, making sure that the whole output
    is readable in a single terminal page. However, no matter how large you make the
    car park, the memory allocation stays the same.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Memoization versus the flyweight pattern
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Memoization is an optimization technique that uses a cache to avoid recomputing
    results that were already computed in an earlier execution step. Memoization does
    not focus on a specific programming paradigm such as **object-oriented programming**
    (**OOP**). In Python, memoization can be applied to both class methods and simple
    functions.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Flyweight is an OOP-specific optimization design pattern that focuses on sharing
    object data.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s get started with the code for this example.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, we need an `Enum` parameter that describes the three different types
    of car that are in the car park:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will define the class at the core of our implementation: `Car`. The
    `pool` variable is the object pool (in other words, our cache). Notice that `pool`
    is a class attribute (a variable shared by all instances).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using the `__new__()` special method, which is called before `__init__()`,
    we are converting the `Car` class to a metaclass that supports self-references.
    This means that `cls` references the `Car` class. When the client code creates
    an instance of `Car`, they pass the type of the car as `car_type`. The type of
    the car is used to check whether a car of the same type has already been created.
    If that’s the case, the previously created object is returned; otherwise, the
    new car type is added to the pool and returned:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `render()` method is what will be used to render a car on the screen. Notice
    how all the mutable information not known by flyweight needs to be explicitly
    passed by the client code. In this case, random `color` and the coordinates of
    a location (of form `x`, `y`) are used for each car.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Also, note that to make `render()` more useful, it is necessary to ensure that
    no cars are rendered on top of each other. Consider this as an exercise. If you
    want to make rendering more fun, you can use a graphics toolkit such as Tkinter,
    Pygame, or Kivy.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `render()` method is defined as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `main()` function shows how we can use the flyweight pattern. The color
    of a car is a random value from a predefined list of colors. The coordinates use
    random values between 1 and 100\. Although 18 cars are rendered, memory is allocated
    only for 3\. The last line of the output proves that when using flyweight, we
    cannot rely on object identity. The `id()` function returns the memory address
    of an object. This is not the default behavior in Python because, by default,
    `id()` returns a unique ID (actually the memory address of an object as an integer)
    for each object. In our case, even if two objects appear to be different, they
    actually have the same identity if they belong to the same `car_type`). Of course,
    different identity comparisons can still be used for objects of different families,
    but that is possible only if the client knows the implementation details.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our example `main()` function’s code is as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the recapitulation of the full code listing (the `ch04/flyweight.py`
    file) to show you how the flyweight pattern is implemented and used:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We need a couple of imports: `random` and `Enum` (from the `enum` module).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We define `Enum` for the types of cars.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we have the `Car` class, with its `pool` attribute and the `__new__()`
    and `render()` methods.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the first part of the `main` function, we define some variables and render
    a set of subcompact cars.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The second part of the `main` function.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The third part of the `main` function.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we add the fourth part of the `main` function.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The execution of the `python ch04/flyweight.py` command shows the type, random
    color, and coordinates of the rendered objects, as well as the identity comparison
    results between flyweight objects of the same/different families:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Do not expect to see the same output since the colors and coordinates are random,
    and the object identities depend on the memory map.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The proxy pattern
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The **proxy** design pattern gets its name from the *proxy* (also known as
    **surrogate**) object used to perform an important action before accessing the
    actual object. There are four well-known types of proxy. They are as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: A **virtual proxy**, which uses **lazy initialization** to defer the creation
    of a computationally expensive object until the moment it is actually needed.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A **protection/protective proxy**, which controls access to a sensitive object.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A **remote proxy**, which acts as the local representation of an object that
    really exists in a different address space (for example, a network server).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A **smart (reference) proxy**, which performs extra actions when an object is
    accessed. Examples of such actions are reference counting and thread-safety checks.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Chip** cards offer a good example of how a protective proxy is used in real
    life. The debit/credit card contains a chip that first needs to be read by the
    ATM or card reader. After the chip is verified, a password (PIN) is required to
    complete the transaction. This means that you cannot make any transactions without
    physically presenting the card and knowing the PIN.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: A bank check that is used instead of cash to make purchases and deals is an
    example of a remote proxy. The check gives access to a bank account.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In software, the `weakref` module of Python contains a `proxy()` method that
    accepts an input object and returns a smart proxy to it. Weak references are the
    recommended way to add reference-counting support to an object.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Use cases for the proxy pattern
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Since there are at least four common proxy types, the proxy design pattern has
    many use cases.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: This pattern is used when creating a distributed system using either a private
    network or the cloud. In a distributed system, some objects exist in the local
    memory and some objects exist in the memory of remote computers. If we don’t want
    the client code to be aware of such differences, we can create a remote proxy
    that hides/encapsulates them, making the distributed nature of the application
    transparent.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The proxy pattern is also handy when our application is suffering from performance
    issues due to the early creation of expensive objects. Introducing lazy initialization
    using a virtual proxy to create the objects only when they are required can give
    us significant performance improvements.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: As a third case, this pattern is used to check whether a user has sufficient
    privileges to access a piece of information. If our application handles sensitive
    information (for example, medical data), we want to ensure that the user trying
    to access/modify it can do so. A protection/protective proxy can handle all security-related
    actions.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: This pattern is used when our application (or library, toolkit, framework, and
    so forth) uses multiple threads and we want to move the burden of thread safety
    from the client code to the application. In this case, we can create a smart proxy
    to hide the thread-safety complexities from the client.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: An **object-relational mapping** (**ORM**) API is also an example of how to
    use a remote proxy. Many popular web frameworks (Django, Flask, FastAPI...) use
    an ORM to provide OOP-like access to a relational database. An ORM acts as a proxy
    to a relational database that can be located anywhere, either at a local or remote
    server.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Implementing the proxy pattern – a virtual proxy
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: There are many ways to create a virtual proxy in Python, but I always like focusing
    on the idiomatic/Pythonic implementations. The code shown here is based on the
    great answer by Cyclone, a user of the [stackoverflow.com](http://stackoverflow.com)
    site, to the question about "Python memoising/deferred lookup property decorator."
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In this section, the terms *property*, *variable*, and *attribute* are used
    interchangeably.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, we create a `LazyProperty` class that can be used as a decorator. When
    it decorates a property, `LazyProperty` loads the property lazily (on the first
    use) instead of instantly. The `__init__()` method creates two variables that
    are used as aliases to the method that initializes a property: `method` is an
    alias to the actual method, and `method_name` is an alias to the method’s name.
    To get a better understanding of how the two aliases are used, print their value
    to the output (uncomment the two commented lines in that part of the code):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LazyProperty` class is actually a descriptor. Descriptors are the recommended
    mechanisms to use in Python to override the default behavior of its attribute
    access methods: `__get__()`, `__set__()`, and `__delete__()`. The `LazyProperty`
    class overrides only `__set__()` because that is the only access method it needs
    to override. In other words, we don’t have to override all access methods. The
    `__get__()` method accesses the value of the property the underlying method wants
    to assign, and uses `setattr()` to do the assignment manually. What `__get()__`
    actually does is very neat: it replaces the method with the value! This means
    that not only is the property lazily loaded, but it can also be set only once.
    We will see what this means in a moment.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Again, uncomment the commented line in that part of the code to get some extra
    information.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, the `Test` class shows how we can use the `LazyProperty` class. There
    are three attributes: `x`, `y`, and `_resource`. We want the `_resource` variable
    to be loaded lazily; thus, we initialize it to `None` as shown in the following
    code:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `resource()` method is decorated with the `LazyProperty` class. For demonstration
    purposes, the `LazyProperty` class initializes the `_resource` attribute as a
    tuple, as shown in the following code. Normally, this would be a slow/expensive
    initialization (database, graphics, and so on):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main()` function, as follows, shows how lazy initialization behaves:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Notice how overriding the `__get()__` access method makes it possible to treat
    the `resource()` method as a simple attribute (we can use `t.resource` instead
    of `t.resource()`).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s recapitulate the example code (in `ch04/proxy/proxy_lazy.py`):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We define the `LazyProperty` class.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the `Test` class with a `resource()` method that we decorate using
    `LazyProperty`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We add the main function for testing our design example.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you can execute the example in its original version (where the added lines
    for better understanding are kept commented), using the `python ch04/proxy/proxy_lazy.py`
    command, you will get the following output:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on this output, we can see the following:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The `_resource` variable is indeed initialized not by the time the `t` instance
    is created, but the first time that we use `t.resource`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second time `t.resource` is used, the variable is not initialized again.
    That’s why the initialization string initializing `self._resource` is shown only
    once.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional information
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There are two basic kinds of lazy initialization in OOP. They are as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **At the instance level**: This means that an object’s property is initialized
    lazily, but the property has an object scope. Each instance (object) of the same
    class has its own (different) copy of the property.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **At the class or module level**: In this case, we do not want a different
    copy per instance, but all the instances share the same property, which is lazily
    initialized. This case is not covered in this chapter. If you find it interesting,
    consider it as an exercise.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Since there are so many possible cases for using the proxy pattern, let’s see
    another example.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Implementing the proxy pattern – a protection proxy
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As a second example, let’s implement a simple protection proxy to view and
    add users. The service provides two options:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Viewing the list of users**: This operation does not require special privileges'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adding a new user**: This operation requires the client to provide a special
    secret message'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `SensitiveInfo` class contains the information that we want to protect.
    The `users` variable is the list of existing users. The `read()` method prints
    the list of the users. The `add()` method adds a new user to the list. The code
    for that class is as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `Info` class is a protection proxy of `SensitiveInfo`. The secret variable
    is the message required to be known/provided by the client code to add a new user.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that this is just an example. In reality, you should never do the following:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Store passwords in the source code
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Store passwords in clear-text form
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a weak (for example, MD5) or custom form of encryption
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `Info` class, as we can see next, the `read()` method is a wrapper to
    `SensitiveInfo.read()` and the `add()` method ensures that a new user can be added
    only if the client code knows the secret message:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main()` function shows how the proxy pattern can be used by the client
    code. The client code creates an instance of the `Info` class and uses the displayed
    menu to read the list, add a new user, or exit the application. Let’s consider
    the following code:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s recapitulate the full code (`ch04/proxy/proxy_protection.py`):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: First, we define the `SensitiveInfo` class.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we have the code for the `Info` class.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we add the main function with our testing code.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can see in the following a sample output of the program when executing the
    `python` `ch04/proxy/proxy_protection.py` command:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Have you already spotted flaws or missing features that can be addressed to
    improve our protection proxy example? Here are a few suggestions:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: This example has a very big security flaw. Nothing prevents the client code
    from bypassing the security of the application by creating an instance of `SensitiveInfo`
    directly. Improve the example to prevent this situation. One way is to use the
    `abc` module to forbid direct instantiation of `SensitiveInfo`. What other code
    changes are required in this case?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic security rule is that we should never store clear-text passwords. Storing
    a password safely is not very hard as long as we know which libraries to use.
    If you have an interest in security, try to implement a secure way to store the
    secret message externally (for example, in a file or database).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The application only supports adding new users, but what about removing an existing
    user? Add a `remove()` method.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the proxy pattern – a remote proxy
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Imagine we are building a file management system where clients can perform operations
    on files stored on a remote server. The operations might include reading a file,
    writing to a file, and deleting a file. The remote proxy hides the complexity
    of network requests from the client.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We start by creating an interface that defines the operations that can be performed
    on the remote server, `RemoteServiceInterface`, and the class that implements
    it to provide the actual service, `RemoteService`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The interface is defined as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RemoteService` class is defined as follows (the methods just return a
    string, for the sake of simplicity, but normally, you would have specific code
    for the file handling on the remote service):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define `ProxyService` for the proxy. It implements the `RemoteServiceInterface`
    interface and acts as a surrogate for `RemoteService`, which handles communication
    with the latter:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Clients interact with the `ProxyService` component as if it were the `RemoteService`
    one, unaware of the remote nature of the actual service. The proxy handles the
    communication with the remote service, potentially adding logging, access control,
    or caching. To test things, we can add the following code, based on creating an
    instance of `ProxyService`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s recapitulate the implementation (the full code is in `ch04/proxy/proxy_remote.py`):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We start by defining the interface, `RemoteServiceInterface`, and a class that
    implements it, `RemoteService`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we define the `ProxyService` class, which also implements the `RemoteService``Interface`
    interface.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we add some code for testing the proxy object.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s see the result of the example by running `python ch04/proxy/proxy_remote.py`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: It worked. This lightweight example was effective in showing how to implement
    the remote proxy use case.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Implementing the proxy pattern – a smart proxy
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s consider a scenario where you have a shared resource in your application,
    such as a database connection. Every time an object accesses this resource, you
    want to keep track of how many references to the resource exist. Once there are
    no more references, the resource can be safely released or closed. A smart proxy
    will help manage the reference counting for this database connection, ensuring
    it’s only closed once all references to it are released.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: As in the previous example, we will need an interface, `DBConnectionInterface`,
    defining operations for accessing the database, and a class that represents the
    actual database connection, `DBConnection`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For the interface, let’s use `Protocol` (to change from the `ABC` way):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The class for the database connection is as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define the `SmartProxy` class; it also implements the `DBConnectionInterface`
    interface (see the `exec_query()` method). We use this class to manage reference
    counting and access to the `DBConnection` object. It ensures that the `DBConnection`
    object is created on demand when the first query is executed and is only closed
    when there are no more references to it. The code is as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add some code to test the implementation:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s recapitulate the implementation (the full code is in `ch04/proxy/proxy_smart.py`):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We start by defining the interface, `DBConnectionInterface`, and a class that
    implements it and represents the database connection, `DBConnection`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we define the `SmartProxy` class, which also implements `DBConnectionInterface`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we add some code for testing the proxy object.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s see the result of the example by running `python ch04/proxy/proxy_smart.py`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This was another demonstration of the proxy pattern. Here, it helped us implement
    an improved solution for scenarios where database connections are shared across
    different parts of an application and need to be managed carefully to avoid exhausting
    database resources or leaking connections.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Structural patterns are invaluable for creating clean, maintainable, and scalable
    code. They provide solutions for many of the challenges you’ll face in daily coding.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: First, the adapter pattern serves as a flexible solution for harmonizing mismatched
    interfaces. We can use this pattern to bridge the gap between outdated legacy
    systems and modern interfaces, thus promoting more cohesive and manageable software
    systems.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, we discussed the decorator pattern that we use as a convenient way of
    extending the behavior of an object without using inheritance. Python, with its
    built-in decorator feature, extends the decorator concept even more by allowing
    us to extend the behavior of any callable without using inheritance or composition.
    The decorator pattern is a great solution for implementing cross-cutting concerns
    because they are generic and do not fit well into the OOP paradigm. We mentioned
    several categories of cross-cutting concerns in the *Use cases for the decorator
    pattern* section. We saw how decorators can help us to keep our functions clean
    without sacrificing performance.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Sharing similarities with the adapter pattern, the bridge pattern is different
    from it in the sense that it is used up-front to define an abstraction and its
    implementation in a decoupled way so that both can vary independently. The bridge
    pattern is useful when writing software for problem domains such as operation
    systems and device drivers, GUIs, and website builders where we have multiple
    themes and we need to change the theme of a website based on certain properties.
    We discussed an example in the domain of content extraction and management, where
    we defined an interface for the abstraction, an interface for the implementor,
    and two implementations.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The facade pattern is ideal for providing a simple interface to client code
    that wants to use a complex system but does not need to be aware of the system’s
    complexity. A computer is a facade, since all we need to do to use it is press
    a single button to turn it on. All the rest of the hardware complexity is handled
    transparently by the BIOS, the boot loader, and the other components of the system
    software. There are more real-life examples of facade, such as when we are connected
    to the customer service department of a bank or a company, and the keys that we
    use to turn a vehicle on. We covered an implementation of the interface used by
    a multi-server operating system.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In general, we use the flyweight pattern when an application needs to create
    a large number of computationally expensive objects that share many properties.
    The important point is to separate the immutable (shared) properties from the
    mutable ones. We saw how to implement a car renderer that supports three different
    car families. By providing the mutable color and x, y properties explicitly to
    the `render()` method, we managed to create only 3 different objects instead of
    18\. Although that might not seem like a big win, imagine if the cars were 2,000
    instead of 18.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We ended with the proxy pattern. We discussed several use cases of the proxy
    pattern, including performance, security, and how to offer simple APIs to users.
    We saw an implementation example for each of the four types of proxy you generally
    need: virtual proxy, protective proxy, proxy to a remote service, and smart proxy.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In the next chapter, we will explore behavioral design patterns, patterns that
    deal with object interconnection and algorithms.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
