- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structural Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered creational patterns and object-oriented
    programming patterns that help us with object-creation procedures. The next category
    of pattern we want to present is *structural design patterns*. A structural design
    pattern proposes a way of composing objects to provide new functionality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The adapter pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The decorator pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bridge pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The facade pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The flyweight pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The proxy pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of this chapter, you will be equipped with the skills to structure
    your code efficiently and elegantly using structural design patterns.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: See the requirements presented in [*Chapter 1*](B21896_01.xhtml#_idTextAnchor017).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The adapter pattern
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **adapter** pattern is a structural design pattern that helps us make two
    incompatible interfaces compatible. What does that really mean? If we have an
    old component and we want to use it in a new system, or a new component that we
    want to use in an old system, the two can rarely communicate without requiring
    any code changes. But changing the code is not always possible, either because
    we don’t have access to it, or because it is impractical. In such cases, we can
    write an extra layer that makes all the required modifications for enabling communication
    between the two interfaces. This layer is called an **adapter**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: In general, if you want to use an interface that expects `function_a()`, but
    you only have `function_b()`, you can use an adapter to convert (adapt) `function_b()`
    to `function_a()`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you are traveling from most European countries to the UK or the USA, or
    the other way around, you need to use a plug adapter for charging your laptop.
    The same kind of adapter is needed for connecting some devices to your computer:
    the USB adapter.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: In the software category, the `zope.interface` package ([https://pypi.org/project/zope.interface/](https://pypi.org/project/zope.interface/)),
    part of the **Zope Toolkit** (**ZTK**), provides tools that help define interfaces
    and perform interface adaptation. These tools are used in the core of several
    Python web framework projects (including Pyramid and Plone).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '`zope.interface` was the solution for working with interfaces in Python, proposed
    by the team ([https://zope.dev/](https://zope.dev/)) behind the Zope application
    server and the ZTK before Python introduced built-in mechanisms, with **abstract
    base classes** (also called **ABCs**) first and protocols later.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Use cases for the adapter pattern
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usually, one of the two incompatible interfaces is either foreign or old/legacy.
    If the interface is foreign, it means that we have no access to the source code.
    If it is old, it is usually impractical to refactor it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Using an adapter to make things work after they have been implemented is a good
    approach because it does not require access to the source code of the foreign
    interface. It is also often a pragmatic solution if we have to reuse some legacy
    code. That being said, be aware that it can introduce side effects that are hard
    to debug. So, use it with caution.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the adapter pattern – adapt a legacy class
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s consider an example where we have a legacy payment system and a new payment
    gateway. The adapter pattern can make them work together without changing the
    existing code, as we are going to see.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'The legacy payment system is implemented using a class, with a `make_payment()`
    method doing the core of the payment job, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The new payment system is implemented using the following class, providing
    an `execute_payment()` method:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we are going to add a class that will provide the `make_payment()` method,
    where we call the `execute_payment()` method on the adaptee object to get the
    payment done. The code is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is how the `PaymentAdapter` class adapts the interface of `NewPaymentGateway`
    to match that of `OldPaymentSystem`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see the result of this adaptation by adding a `main()` function with
    testing code, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s recapitulate the complete code (see the `ch04``/adapter/adapt_legacy.py`
    file) of the implementation:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: We have some code for the legacy payment system, represented by the `OldPaymentSystem`
    class, providing a `make_payment()` method.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We introduce the new payment system, with the `NewPaymentGateway` class, providing
    an `execute_payment()` method.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add a class for the adapter, `PaymentAdapter`, which has an attribute to
    store the payment system object and a `make_payment()` method; in that method,
    we call the `execute_payment()` method on the payment system object (via `self.system.execute_payment(amount)`).
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add code for testing our interface adaptation design (and call it within
    the usual `if __name__ == "``__main__"` block).
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Executing the code, using `python ch04/adapter/adapt_legacy.py`, should give
    the following output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You now get the idea. This adaptation technique allows us to use the new payment
    gateway with existing code that expects the old interface.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the adapter pattern – adapt several classes into a unified interface
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at another application to illustrate adaptation: a club’s activities.
    Our club has two main activities:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Hire talented artists to perform in the club
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organize performances and events to entertain its clients
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the core, we have a `Club` class that represents the club where hired artists
    perform some evenings. The `organize_performance()` method is the main action
    that the club can perform. The code is as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Most of the time, our club hires a DJ to perform, but our application should
    make it possible to organize a diversity of performances: by a musician or music
    band, by a dancer, a one-man or one-woman show, and so on.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Via our research to try and reuse existing code, we find an open source contributed
    library that brings us two interesting classes: `Musician` and `Dancer`. In the
    `Musician` class, the main action is performed by the `play()` method. In the
    `Dancer` class, it is performed by the `dance()` method.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, to indicate that these two classes are external, we place them
    in a separate module (in the `ch04/adapter/external.py` file). The code includes
    two classes, `Musician` and `Dancer`, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code we are writing, to use these two classes from the external library,
    only knows how to call the `organize_performance()` method (on the `Club` class);
    it has no idea about the `play()` or `dance()` methods (on the respective classes).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: How can we make the code work without changing the `Musician` and `Dancer` classes?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Adapters to the rescue! We create a generic `Adapter` class that allows us
    to adapt a number of objects with different interfaces into one unified interface.
    The `obj` argument of the `__init__()` method is the object that we want to adapt,
    and `adapted_methods` is a dictionary containing key/value pairs matching the
    method the client calls and the method that should be called. The code for that
    class is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When dealing with the instances of the different classes, we have two cases:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The compatible object that belongs to the `Club` class needs no adaptation.
    We can treat it as is.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The incompatible objects need to be adapted first, using the `Adapter` class.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The result is that the client code can continue using the known `organize_performance()`
    method on all objects without the need to be aware of any interface differences.
    Consider the following `main()` function code to prove that the design works as
    expected:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s recapitulate the complete code of our adapter pattern implementation
    (in the `ch04/adapter/adapt_to_unified_interface.py` file):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: We import the `Musician` and `Dancer` classes from the `external` module.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have the `Club` class.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the `Adapter` class.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add the `main()` function, which we call within the usual `if __name__ ==
    "``__main__"` block.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the output when executing the `python` `ch04/adapter/adapt_to_unified_interface.py`
    command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, we managed to make the `Musician` and `Dancer` classes compatible
    with the interface expected by the client code without changing the source code
    of these external classes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: The decorator pattern
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A second interesting structural pattern to learn about is the **decorator**
    pattern, which allows a programmer to add responsibilities to an object dynamically,
    and in a transparent manner (without affecting other objects).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: There is another reason why this pattern is interesting to us, as you will see
    in a minute.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: As Python developers, we can write decorators in a **Pythonic** way (meaning
    using the language’s features), thanks to the built-in decorator feature.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: A Python decorator is a callable (function, method, or class) that gets a `func_in`
    function object as input and returns another function object, `func_out`. It is
    a commonly used technique for extending the behavior of a function, method, or
    class.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'For more details on Python’s decorator feature, see the official documentation:
    [https://docs.python.org/3/reference/compound_stmts.html#function](https://docs.python.org/3/reference/compound_stmts.html#function)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: But this feature should not be completely new to you. We have already encountered
    commonly used decorators in previous chapters (`@abstractmethod`, `@property`)
    and there are several other useful built-in decorators in Python. Now, we are
    going to learn how to implement and use our own decorators.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is no one-to-one relationship between the decorator pattern
    and Python’s decorator feature. Python decorators can actually do much more than
    the decorator pattern. One of the things they can be used for is to implement
    the decorator pattern.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The decorator pattern is generally used for extending the functionality of an
    object. In everyday life, examples of such extensions are adding a silencer to
    a gun, using different camera lenses, and so on.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'In web frameworks such as Django, which uses decorators a lot, we have decorators
    that can be used for the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Restricting access to views (or HTTP-request-handling functions) based on the
    request
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the caching behavior on specific views
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling compression on a per-view basis
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling caching based on specific HTTP request headers
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering a function as an event subscriber
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting a function with a specific permission
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases for the decorator pattern
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The decorator pattern shines when used for implementing cross-cutting concerns,
    such as the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Data validation
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business rules
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encryption
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, all parts of an application that are generic and can be applied
    to many other parts of it are considered to be cross-cutting concerns.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Another popular example of using the decorator pattern is in **graphical user
    interface** (**GUI**) toolkits. In a GUI toolkit, we want to be able to add features
    such as borders, shadows, colors, and scrolling to individual components/widgets.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the decorator pattern
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python decorators are generic and very powerful. In this section, we will see
    how we can implement a `number_sum()` function that returns the sum of the first
    *n* numbers. Note that this function is already available in the `math` module
    as `fsum()`, but let’s pretend it is not.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s look at the naive implementation (in the `ch04/decorator/number_sum_naive.py`
    file):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A sample execution of this example shows how slow this implementation is. On
    my computer, it takes more than *7* seconds to calculate the sum of the first
    50 numbers. We get the following output when executing the `python` `ch04/decorator/number_sum_naive.py`
    command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'sum_cache = {0: 0}'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'def number_sum(n):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'if n in sum_cache:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: return sum_cache[n]
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: res = n + number_sum(n - 1)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '# Add the value to the cache'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: sum_cache[n] = res
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: return res
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == "__main__":'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: from timeit import Timer
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: t = Timer(
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '"number_sum(300)",'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '"from __main__ import number_sum",'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Time: ", t.timeit())'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Time:  0.1288748119986849
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'fib_cache = {0: 0, 1: 1}'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'def fibonacci(n):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'if n in fib_cache:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: return fib_cache[n]
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: res = fibonacci(n - 1) + fibonacci(n - 2)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: fib_cache[n] = res
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: return res
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: import functools
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'def memoize(func):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: cache = {}
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '@functools.wraps(func)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'def memoizer(*args):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'if args not in cache:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: cache[args] = func(*args)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: return cache[args]
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: return memoizer
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '@memoize'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'def number_sum(n):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'if n == 0:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: return 0
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: return n + number_sum(n - 1)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '@memoize'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'def fibonacci(n):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'if n in (0, 1):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: return n
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: return fibonacci(n - 1) + fibonacci(n - 2)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'def main():'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: from timeit import Timer
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: to_execute = [
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: number_sum,
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Timer(
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '"number_sum(300)",'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '"from __main__ import number_sum",'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: ),
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: ),
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: fibonacci,
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Timer(
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '"fibonacci(100)",'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '"from __main__ import fibonacci",'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: ),
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: ),
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in to_execute:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: func = item[0]
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: print(
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'f''Function "{func.__name__}": {func.__doc__}'''
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: t = item[1]
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'print(f"Time: {t.timeit()}")'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: print()
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Function "number_sum": Returns the sum of the first n numbers'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Time: 0.2148694'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Function "fibonacci": Returns the suite of Fibonacci numbers'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Time: 0.202763251'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'class ResourceContentFetcher(Protocol):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'def fetch(self, path: str) -> str:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'class ResourceContent:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, imp: ResourceContentFetcher):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: self._imp = imp
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'def get_content(self, path):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: return self._imp.fetch(path)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'class URLFetcher:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'def fetch(self, path):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: res = ""
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: req = urllib.request.Request(path)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: with urllib.request.urlopen(
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: req
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: ') as response:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'if response.code == 200:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: res = response.read()
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: return res
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'class LocalFileFetcher:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'def fetch(self, path):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'with open(path) as f:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: res = f.read()
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: return res
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'def main():'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: url_fetcher = URLFetcher()
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: rc = ResourceContent(url_fetcher)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: res = rc.get_content("http://python.org")
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: print(
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: f"Fetched content with {len(res)} characters"
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: localfs_fetcher = LocalFileFetcher()
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: rc = ResourceContent(localfs_fetcher)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: pathname = os.path.abspath(__file__)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: dir_path = os.path.split(pathname)[0]
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: path = os.path.join(dir_path, "file.txt")
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: res = rc.get_content(path)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: print(
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: f"Fetched content with {len(res)} characters"
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Fetched content with 51265 characters
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Fetched content with 1327 characters
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: State = Enum(
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '"State",'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '"NEW RUNNING SLEEPING RESTART ZOMBIE",'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class Server(ABC):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '@abstractmethod'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: pass
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'def __str__(self):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: return self.name
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '@abstractmethod'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'def boot(self):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: pass
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '@abstractmethod'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'def kill(self, restart=True):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: pass
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'class FileServer(Server):'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: self.name = "FileServer"
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: self.state = State.NEW
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'def boot(self):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: print(f"booting the {self}")
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: self.state = State.RUNNING
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'def kill(self, restart=True):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: print(f"Killing {self}")
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: self.state = (
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: State.RESTART if restart else State.ZOMBIE
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_file(self, user, name, perms):'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: msg = (
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: f"trying to create file '{name}' "
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: f"for user '{user}' "
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: f"with permissions {perms}"
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: print(msg)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'class ProcessServer(Server):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: self.name = "ProcessServer"
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: self.state = State.NEW
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'def boot(self):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: print(f"booting the {self}")
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: self.state = State.RUNNING
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'def kill(self, restart=True):'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: print(f"Killing {self}")
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: self.state = (
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: State.RESTART if restart else State.ZOMBIE
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_process(self, user, name):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: msg = (
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: f"trying to create process '{name}' "
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: f"for user '{user}'"
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: print(msg)
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'class OperatingSystem:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '"""The Facade"""'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: self.fs = FileServer()
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: self.ps = ProcessServer()
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'def start(self):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[i.boot() for i in (self.fs, self.ps)]'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_file(self, user, name, perms):'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: return self.fs.create_file(user, name, perms)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_process(self, user, name):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: return self.ps.create_process(user, name)
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'def main():'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: os = OperatingSystem()
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: os.start()
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: os.create_file("foo", "hello.txt", "-rw-r-r")
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: os.create_process("bar", "ls /tmp")
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: booting the FileServer
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: booting the ProcessServer
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: trying to create file 'hello.txt' for user 'foo' with permissions -rw-r-r
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: OperatingSystem class does a good job. The client code can create files and
    processes without needing to know internal details about the operating system,
    such as the existence of multiple servers. To be precise, the client code can
    call the methods for creating files and processes, but they are currently dummy.
    As an interesting exercise, you can implement one of the two methods, or even
    both.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: The flyweight pattern
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Whenever we create a new object, extra memory needs to be allocated. Although
    virtual memory provides us, theoretically, with unlimited memory, the reality
    is different. If all the physical memory of a system gets exhausted, it will start
    swapping pages with the secondary storage, usually a **hard disk drive** (**HDD**),
    which, in most cases, is unacceptable due to the performance differences between
    the main memory and HDD. **Solid-state drives** (**SSDs**) generally have better
    performance than HDDs, but not everybody is expected to use SSDs. So, SSDs are
    not going to totally replace HDDs anytime soon.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Apart from memory usage, performance is also a consideration. Graphics software,
    including computer games, should be able to render 3-D information (for example,
    a forest with thousands of trees, a village full of soldiers, or an urban area
    with a lot of cars) extremely quickly. If each object in a 3-D terrain is created
    individually and no data sharing is used, the performance will be prohibitive.
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: As software engineers, we should solve software problems by writing better software,
    instead of forcing the customer to buy extra or better hardware. The **flyweight**
    design pattern is a technique used to minimize memory usage and improve performance
    by introducing data sharing between similar objects. A flyweight is a shared object
    that contains state-independent, immutable (also known as **intrinsic**) data.
    The state-dependent, mutable (also known as **extrinsic**) data should not be
    part of flyweight because this is information that cannot be shared, since it
    differs per object. If flyweight needs extrinsic data, it should be provided explicitly
    by the client code.
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: An example might help to clarify how the flyweight pattern can be used practically.
    Let’s assume that we are creating a performance-critical game – for example, a
    **first-person shooter** (**FPS**). In FPS games, the players (soldiers) share
    some states, such as representation and behavior. In *Counter-Strike*, for instance,
    all soldiers on the same team (counter-terrorists versus terrorists) look the
    same (representation). In the same game, all soldiers (on both teams) have some
    common actions, such as jump, duck, and so forth (behavior). This means that we
    can create a flyweight that will contain all of the common data. Of course, the
    soldiers also have a lot of data that is different per soldier and will not be
    a part of the flyweight, such as weapons, health, location, and so on.
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Real-world examples
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Flyweight is an optimization design pattern; therefore, it is not easy to find
    a good non-computing example of it. We can think of flyweight as caching in real
    life. For example, many bookstores have dedicated shelves with the newest and
    most popular publications. This is a cache. First, you can take a look at the
    dedicated shelves for the book you are looking for, and if you cannot find it,
    you can ask the bookseller to assist you.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The Exaile music player uses flyweight to reuse objects (in this case, music
    tracks) that are identified by the same URL. There’s no point in creating a new
    object if it has the same URL as an existing object, so the same object is reused
    to save resources.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Use cases for the flyweight pattern
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Flyweight is all about improving performance and memory usage. All embedded
    systems (phones, tablets, games consoles, microcontrollers, and so forth) and
    performance-critical applications (games, 3-D graphics processing, real-time systems,
    and so forth) can benefit from it.
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The *Gang of Four* (*GoF*) book lists the following requirements that need
    to be satisfied to effectively use the flyweight pattern:'
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The application needs to use a large number of objects.
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are so many objects that it’s too expensive to store/render them. Once
    the mutable state is removed (because if it is required, it should be passed explicitly
    to flyweight by the client code), many groups of distinct objects can be replaced
    by relatively few shared objects.
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Object identity is not important for the application. We cannot rely on object
    identity because object sharing causes identity comparisons to fail (objects that
    appear different to the client code end up having the same identity).
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象标识对于应用来说并不重要。我们不能依赖于对象标识，因为对象共享会导致标识比较失败（对客户端代码看起来不同的对象最终会有相同的标识）。
- en: Implementing the flyweight pattern
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现享元模式
- en: Let’s see how we can implement an example featuring cars in an area. We will
    create a small car park to illustrate the idea, making sure that the whole output
    is readable in a single terminal page. However, no matter how large you make the
    car park, the memory allocation stays the same.
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看我们如何实现一个包含区域的汽车示例。我们将创建一个小型停车场来展示这个想法，确保整个输出在单个终端页面上可读。然而，无论停车场有多大，内存分配保持不变。
- en: Memoization versus the flyweight pattern
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 缓存与享元模式的比较
- en: Memoization is an optimization technique that uses a cache to avoid recomputing
    results that were already computed in an earlier execution step. Memoization does
    not focus on a specific programming paradigm such as **object-oriented programming**
    (**OOP**). In Python, memoization can be applied to both class methods and simple
    functions.
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 缓存是一种优化技术，它使用缓存来避免重新计算在早期执行步骤中已经计算过的结果。缓存并不专注于特定的编程范式，如**面向对象编程**（**OOP**）。在Python中，缓存可以应用于类方法和简单函数。
- en: Flyweight is an OOP-specific optimization design pattern that focuses on sharing
    object data.
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 享元是一种特定于面向对象编程的优化设计模式，它专注于共享对象数据。
- en: Let’s get started with the code for this example.
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们开始编写这个示例的代码。
- en: 'First, we need an `Enum` parameter that describes the three different types
    of car that are in the car park:'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们需要一个`Enum`参数来描述停车场中存在的三种不同类型的汽车：
- en: '[PRE30]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we will define the class at the core of our implementation: `Car`. The
    `pool` variable is the object pool (in other words, our cache). Notice that `pool`
    is a class attribute (a variable shared by all instances).'
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们将定义我们实现的核心类：`Car`。`pool`变量是对象池（换句话说，我们的缓存）。请注意，`pool`是一个类属性（一个所有实例共享的变量）。
- en: 'Using the `__new__()` special method, which is called before `__init__()`,
    we are converting the `Car` class to a metaclass that supports self-references.
    This means that `cls` references the `Car` class. When the client code creates
    an instance of `Car`, they pass the type of the car as `car_type`. The type of
    the car is used to check whether a car of the same type has already been created.
    If that’s the case, the previously created object is returned; otherwise, the
    new car type is added to the pool and returned:'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用在`__init__()`之前被调用的特殊方法`__new__()`，我们将`Car`类转换为一个支持自引用的元类。这意味着`cls`引用了`Car`类。当客户端代码创建`Car`实例时，它们会传递汽车的类型作为`car_type`。汽车的类型用于检查是否已经创建了相同类型的汽车。如果是这样，则返回先前创建的对象；否则，将新的汽车类型添加到池中并返回：
- en: '[PRE31]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `render()` method is what will be used to render a car on the screen. Notice
    how all the mutable information not known by flyweight needs to be explicitly
    passed by the client code. In this case, random `color` and the coordinates of
    a location (of form `x`, `y`) are used for each car.
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`render()`方法将用于在屏幕上渲染汽车。注意，所有未知于享元的信息都需要客户端代码显式传递。在这种情况下，每个汽车使用随机的`color`和位置的坐标（形式为`x`，`y`）。'
- en: Also, note that to make `render()` more useful, it is necessary to ensure that
    no cars are rendered on top of each other. Consider this as an exercise. If you
    want to make rendering more fun, you can use a graphics toolkit such as Tkinter,
    Pygame, or Kivy.
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，请注意，为了使`render()`更有用，必须确保没有汽车渲染在彼此之上。把这当作一个练习。如果你想使渲染更有趣，可以使用图形工具包，如Tkinter、Pygame或Kivy。
- en: 'The `render()` method is defined as follows:'
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`render()`方法定义如下：'
- en: '[PRE32]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `main()` function shows how we can use the flyweight pattern. The color
    of a car is a random value from a predefined list of colors. The coordinates use
    random values between 1 and 100\. Although 18 cars are rendered, memory is allocated
    only for 3\. The last line of the output proves that when using flyweight, we
    cannot rely on object identity. The `id()` function returns the memory address
    of an object. This is not the default behavior in Python because, by default,
    `id()` returns a unique ID (actually the memory address of an object as an integer)
    for each object. In our case, even if two objects appear to be different, they
    actually have the same identity if they belong to the same `car_type`). Of course,
    different identity comparisons can still be used for objects of different families,
    but that is possible only if the client knows the implementation details.
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our example `main()` function’s code is as follows:'
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here is the recapitulation of the full code listing (the `ch04/flyweight.py`
    file) to show you how the flyweight pattern is implemented and used:'
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We need a couple of imports: `random` and `Enum` (from the `enum` module).'
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We define `Enum` for the types of cars.
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we have the `Car` class, with its `pool` attribute and the `__new__()`
    and `render()` methods.
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the first part of the `main` function, we define some variables and render
    a set of subcompact cars.
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The second part of the `main` function.
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The third part of the `main` function.
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we add the fourth part of the `main` function.
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The execution of the `python ch04/flyweight.py` command shows the type, random
    color, and coordinates of the rendered objects, as well as the identity comparison
    results between flyweight objects of the same/different families:'
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Do not expect to see the same output since the colors and coordinates are random,
    and the object identities depend on the memory map.
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The proxy pattern
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The **proxy** design pattern gets its name from the *proxy* (also known as
    **surrogate**) object used to perform an important action before accessing the
    actual object. There are four well-known types of proxy. They are as follows:'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: A **virtual proxy**, which uses **lazy initialization** to defer the creation
    of a computationally expensive object until the moment it is actually needed.
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A **protection/protective proxy**, which controls access to a sensitive object.
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A **remote proxy**, which acts as the local representation of an object that
    really exists in a different address space (for example, a network server).
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A **smart (reference) proxy**, which performs extra actions when an object is
    accessed. Examples of such actions are reference counting and thread-safety checks.
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Real-world examples
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Chip** cards offer a good example of how a protective proxy is used in real
    life. The debit/credit card contains a chip that first needs to be read by the
    ATM or card reader. After the chip is verified, a password (PIN) is required to
    complete the transaction. This means that you cannot make any transactions without
    physically presenting the card and knowing the PIN.'
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: A bank check that is used instead of cash to make purchases and deals is an
    example of a remote proxy. The check gives access to a bank account.
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In software, the `weakref` module of Python contains a `proxy()` method that
    accepts an input object and returns a smart proxy to it. Weak references are the
    recommended way to add reference-counting support to an object.
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Use cases for the proxy pattern
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Since there are at least four common proxy types, the proxy design pattern has
    many use cases.
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: This pattern is used when creating a distributed system using either a private
    network or the cloud. In a distributed system, some objects exist in the local
    memory and some objects exist in the memory of remote computers. If we don’t want
    the client code to be aware of such differences, we can create a remote proxy
    that hides/encapsulates them, making the distributed nature of the application
    transparent.
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The proxy pattern is also handy when our application is suffering from performance
    issues due to the early creation of expensive objects. Introducing lazy initialization
    using a virtual proxy to create the objects only when they are required can give
    us significant performance improvements.
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: As a third case, this pattern is used to check whether a user has sufficient
    privileges to access a piece of information. If our application handles sensitive
    information (for example, medical data), we want to ensure that the user trying
    to access/modify it can do so. A protection/protective proxy can handle all security-related
    actions.
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: This pattern is used when our application (or library, toolkit, framework, and
    so forth) uses multiple threads and we want to move the burden of thread safety
    from the client code to the application. In this case, we can create a smart proxy
    to hide the thread-safety complexities from the client.
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: An **object-relational mapping** (**ORM**) API is also an example of how to
    use a remote proxy. Many popular web frameworks (Django, Flask, FastAPI...) use
    an ORM to provide OOP-like access to a relational database. An ORM acts as a proxy
    to a relational database that can be located anywhere, either at a local or remote
    server.
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Implementing the proxy pattern – a virtual proxy
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: There are many ways to create a virtual proxy in Python, but I always like focusing
    on the idiomatic/Pythonic implementations. The code shown here is based on the
    great answer by Cyclone, a user of the [stackoverflow.com](http://stackoverflow.com)
    site, to the question about "Python memoising/deferred lookup property decorator."
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In this section, the terms *property*, *variable*, and *attribute* are used
    interchangeably.
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, we create a `LazyProperty` class that can be used as a decorator. When
    it decorates a property, `LazyProperty` loads the property lazily (on the first
    use) instead of instantly. The `__init__()` method creates two variables that
    are used as aliases to the method that initializes a property: `method` is an
    alias to the actual method, and `method_name` is an alias to the method’s name.
    To get a better understanding of how the two aliases are used, print their value
    to the output (uncomment the two commented lines in that part of the code):'
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `LazyProperty` class is actually a descriptor. Descriptors are the recommended
    mechanisms to use in Python to override the default behavior of its attribute
    access methods: `__get__()`, `__set__()`, and `__delete__()`. The `LazyProperty`
    class overrides only `__set__()` because that is the only access method it needs
    to override. In other words, we don’t have to override all access methods. The
    `__get__()` method accesses the value of the property the underlying method wants
    to assign, and uses `setattr()` to do the assignment manually. What `__get()__`
    actually does is very neat: it replaces the method with the value! This means
    that not only is the property lazily loaded, but it can also be set only once.
    We will see what this means in a moment.'
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Again, uncomment the commented line in that part of the code to get some extra
    information.
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, the `Test` class shows how we can use the `LazyProperty` class. There
    are three attributes: `x`, `y`, and `_resource`. We want the `_resource` variable
    to be loaded lazily; thus, we initialize it to `None` as shown in the following
    code:'
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `resource()` method is decorated with the `LazyProperty` class. For demonstration
    purposes, the `LazyProperty` class initializes the `_resource` attribute as a
    tuple, as shown in the following code. Normally, this would be a slow/expensive
    initialization (database, graphics, and so on):'
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `main()` function, as follows, shows how lazy initialization behaves:'
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Notice how overriding the `__get()__` access method makes it possible to treat
    the `resource()` method as a simple attribute (we can use `t.resource` instead
    of `t.resource()`).
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s recapitulate the example code (in `ch04/proxy/proxy_lazy.py`):'
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We define the `LazyProperty` class.
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the `Test` class with a `resource()` method that we decorate using
    `LazyProperty`.
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We add the main function for testing our design example.
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you can execute the example in its original version (where the added lines
    for better understanding are kept commented), using the `python ch04/proxy/proxy_lazy.py`
    command, you will get the following output:'
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Based on this output, we can see the following:'
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The `_resource` variable is indeed initialized not by the time the `t` instance
    is created, but the first time that we use `t.resource`.
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second time `t.resource` is used, the variable is not initialized again.
    That’s why the initialization string initializing `self._resource` is shown only
    once.
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional information
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There are two basic kinds of lazy initialization in OOP. They are as follows:'
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **At the instance level**: This means that an object’s property is initialized
    lazily, but the property has an object scope. Each instance (object) of the same
    class has its own (different) copy of the property.'
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **At the class or module level**: In this case, we do not want a different
    copy per instance, but all the instances share the same property, which is lazily
    initialized. This case is not covered in this chapter. If you find it interesting,
    consider it as an exercise.'
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Since there are so many possible cases for using the proxy pattern, let’s see
    another example.
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Implementing the proxy pattern – a protection proxy
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As a second example, let’s implement a simple protection proxy to view and
    add users. The service provides two options:'
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Viewing the list of users**: This operation does not require special privileges'
  id: totrans-404
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adding a new user**: This operation requires the client to provide a special
    secret message'
  id: totrans-405
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `SensitiveInfo` class contains the information that we want to protect.
    The `users` variable is the list of existing users. The `read()` method prints
    the list of the users. The `add()` method adds a new user to the list. The code
    for that class is as follows:'
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `Info` class is a protection proxy of `SensitiveInfo`. The secret variable
    is the message required to be known/provided by the client code to add a new user.
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that this is just an example. In reality, you should never do the following:'
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Store passwords in the source code
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Store passwords in clear-text form
  id: totrans-411
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a weak (for example, MD5) or custom form of encryption
  id: totrans-412
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `Info` class, as we can see next, the `read()` method is a wrapper to
    `SensitiveInfo.read()` and the `add()` method ensures that a new user can be added
    only if the client code knows the secret message:'
  id: totrans-413
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `main()` function shows how the proxy pattern can be used by the client
    code. The client code creates an instance of the `Info` class and uses the displayed
    menu to read the list, add a new user, or exit the application. Let’s consider
    the following code:'
  id: totrans-415
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let’s recapitulate the full code (`ch04/proxy/proxy_protection.py`):'
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: First, we define the `SensitiveInfo` class.
  id: totrans-418
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we have the code for the `Info` class.
  id: totrans-419
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we add the main function with our testing code.
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can see in the following a sample output of the program when executing the
    `python` `ch04/proxy/proxy_protection.py` command:'
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Have you already spotted flaws or missing features that can be addressed to
    improve our protection proxy example? Here are a few suggestions:'
  id: totrans-423
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: This example has a very big security flaw. Nothing prevents the client code
    from bypassing the security of the application by creating an instance of `SensitiveInfo`
    directly. Improve the example to prevent this situation. One way is to use the
    `abc` module to forbid direct instantiation of `SensitiveInfo`. What other code
    changes are required in this case?
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic security rule is that we should never store clear-text passwords. Storing
    a password safely is not very hard as long as we know which libraries to use.
    If you have an interest in security, try to implement a secure way to store the
    secret message externally (for example, in a file or database).
  id: totrans-425
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The application only supports adding new users, but what about removing an existing
    user? Add a `remove()` method.
  id: totrans-426
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the proxy pattern – a remote proxy
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Imagine we are building a file management system where clients can perform operations
    on files stored on a remote server. The operations might include reading a file,
    writing to a file, and deleting a file. The remote proxy hides the complexity
    of network requests from the client.
  id: totrans-428
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We start by creating an interface that defines the operations that can be performed
    on the remote server, `RemoteServiceInterface`, and the class that implements
    it to provide the actual service, `RemoteService`.
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The interface is defined as follows:'
  id: totrans-430
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `RemoteService` class is defined as follows (the methods just return a
    string, for the sake of simplicity, but normally, you would have specific code
    for the file handling on the remote service):'
  id: totrans-432
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, we define `ProxyService` for the proxy. It implements the `RemoteServiceInterface`
    interface and acts as a surrogate for `RemoteService`, which handles communication
    with the latter:'
  id: totrans-434
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Clients interact with the `ProxyService` component as if it were the `RemoteService`
    one, unaware of the remote nature of the actual service. The proxy handles the
    communication with the remote service, potentially adding logging, access control,
    or caching. To test things, we can add the following code, based on creating an
    instance of `ProxyService`:'
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let’s recapitulate the implementation (the full code is in `ch04/proxy/proxy_remote.py`):'
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We start by defining the interface, `RemoteServiceInterface`, and a class that
    implements it, `RemoteService`.
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we define the `ProxyService` class, which also implements the `RemoteService``Interface`
    interface.
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we add some code for testing the proxy object.
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s see the result of the example by running `python ch04/proxy/proxy_remote.py`:'
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It worked. This lightweight example was effective in showing how to implement
    the remote proxy use case.
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Implementing the proxy pattern – a smart proxy
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s consider a scenario where you have a shared resource in your application,
    such as a database connection. Every time an object accesses this resource, you
    want to keep track of how many references to the resource exist. Once there are
    no more references, the resource can be safely released or closed. A smart proxy
    will help manage the reference counting for this database connection, ensuring
    it’s only closed once all references to it are released.
  id: totrans-446
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: As in the previous example, we will need an interface, `DBConnectionInterface`,
    defining operations for accessing the database, and a class that represents the
    actual database connection, `DBConnection`.
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For the interface, let’s use `Protocol` (to change from the `ABC` way):'
  id: totrans-448
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The class for the database connection is as follows:'
  id: totrans-450
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, we define the `SmartProxy` class; it also implements the `DBConnectionInterface`
    interface (see the `exec_query()` method). We use this class to manage reference
    counting and access to the `DBConnection` object. It ensures that the `DBConnection`
    object is created on demand when the first query is executed and is only closed
    when there are no more references to it. The code is as follows:'
  id: totrans-452
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, we can add some code to test the implementation:'
  id: totrans-454
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let’s recapitulate the implementation (the full code is in `ch04/proxy/proxy_smart.py`):'
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We start by defining the interface, `DBConnectionInterface`, and a class that
    implements it and represents the database connection, `DBConnection`.
  id: totrans-457
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we define the `SmartProxy` class, which also implements `DBConnectionInterface`.
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we add some code for testing the proxy object.
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s see the result of the example by running `python ch04/proxy/proxy_smart.py`:'
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This was another demonstration of the proxy pattern. Here, it helped us implement
    an improved solution for scenarios where database connections are shared across
    different parts of an application and need to be managed carefully to avoid exhausting
    database resources or leaking connections.
  id: totrans-462
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  id: totrans-463
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Structural patterns are invaluable for creating clean, maintainable, and scalable
    code. They provide solutions for many of the challenges you’ll face in daily coding.
  id: totrans-464
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: First, the adapter pattern serves as a flexible solution for harmonizing mismatched
    interfaces. We can use this pattern to bridge the gap between outdated legacy
    systems and modern interfaces, thus promoting more cohesive and manageable software
    systems.
  id: totrans-465
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, we discussed the decorator pattern that we use as a convenient way of
    extending the behavior of an object without using inheritance. Python, with its
    built-in decorator feature, extends the decorator concept even more by allowing
    us to extend the behavior of any callable without using inheritance or composition.
    The decorator pattern is a great solution for implementing cross-cutting concerns
    because they are generic and do not fit well into the OOP paradigm. We mentioned
    several categories of cross-cutting concerns in the *Use cases for the decorator
    pattern* section. We saw how decorators can help us to keep our functions clean
    without sacrificing performance.
  id: totrans-466
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Sharing similarities with the adapter pattern, the bridge pattern is different
    from it in the sense that it is used up-front to define an abstraction and its
    implementation in a decoupled way so that both can vary independently. The bridge
    pattern is useful when writing software for problem domains such as operation
    systems and device drivers, GUIs, and website builders where we have multiple
    themes and we need to change the theme of a website based on certain properties.
    We discussed an example in the domain of content extraction and management, where
    we defined an interface for the abstraction, an interface for the implementor,
    and two implementations.
  id: totrans-467
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The facade pattern is ideal for providing a simple interface to client code
    that wants to use a complex system but does not need to be aware of the system’s
    complexity. A computer is a facade, since all we need to do to use it is press
    a single button to turn it on. All the rest of the hardware complexity is handled
    transparently by the BIOS, the boot loader, and the other components of the system
    software. There are more real-life examples of facade, such as when we are connected
    to the customer service department of a bank or a company, and the keys that we
    use to turn a vehicle on. We covered an implementation of the interface used by
    a multi-server operating system.
  id: totrans-468
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In general, we use the flyweight pattern when an application needs to create
    a large number of computationally expensive objects that share many properties.
    The important point is to separate the immutable (shared) properties from the
    mutable ones. We saw how to implement a car renderer that supports three different
    car families. By providing the mutable color and x, y properties explicitly to
    the `render()` method, we managed to create only 3 different objects instead of
    18\. Although that might not seem like a big win, imagine if the cars were 2,000
    instead of 18.
  id: totrans-469
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We ended with the proxy pattern. We discussed several use cases of the proxy
    pattern, including performance, security, and how to offer simple APIs to users.
    We saw an implementation example for each of the four types of proxy you generally
    need: virtual proxy, protective proxy, proxy to a remote service, and smart proxy.'
  id: totrans-470
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In the next chapter, we will explore behavioral design patterns, patterns that
    deal with object interconnection and algorithms.
  id: totrans-471
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
