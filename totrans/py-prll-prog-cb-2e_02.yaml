- en: Thread-Based Parallelism
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于线程的并行
- en: Currently, the most widely used programming paradigm for the management of concurrency
    in software applications is based on multithreading. Generally, an application
    is made by a single processthat is divided into multiple independent threads,
    which represent activities of different types that run in paralleland compete
    with each other.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在软件应用程序中管理并发最广泛使用的编程范式是基于多线程的。通常，一个应用程序由一个单一进程组成，该进程被划分为多个独立的线程，这些线程代表不同类型的活动，它们并行运行并相互竞争。
- en: Nowadays, modern applications that use multithreading have been adopted on a
    massive scale. In fact, all current processors are multicore, just so they can
    perform parallel operations and exploit the computer's computational resources.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用多线程的现代应用程序已经被大规模采用。事实上，所有当前的处理器都是多核的，这样它们就可以执行并行操作并利用计算机的计算资源。
- en: Hence, *multithreaded programming*is definitely a good way to achieve concurrent
    applications. However, multithreaded programming often hides some non-trivial
    difficulties, which must be managed appropriately to avoid errors such as deadlocksor synchronization
    issues.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*多线程编程*无疑是实现并发应用的好方法。然而，多线程编程往往隐藏一些非平凡的困难，这些困难必须得到适当的处理，以避免死锁或同步问题等错误。
- en: We will first define the concepts of thread-based and multithreaded programming
    and then introduce the `multithreading` library. We will learn about the main
    directives for thread definition, management, and communication.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义基于线程和多线程编程的概念，然后介绍`multithreading`库。我们将学习线程定义、管理和通信的主要指令。
- en: Through the `multithreading` library, we will see how to solve problems through
    different techniques, such as *lock*, *RLock*, *semaphores*, *condition*, *event*, *barrier, *and
    *queue*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`multithreading`库，我们将看到如何通过不同的技术解决问题，例如*锁*、*RLock*、*信号量*、*条件*、*事件*、*屏障*和*队列*。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: What is a thread?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是线程？
- en: How to define a thread
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何定义线程
- en: How to determine the current thread
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确定当前线程
- en: How to use a thread in a subclass
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在子类中使用线程
- en: Thread synchronization with a lock
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用锁进行线程同步
- en: Thread synchronization with an RLock
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RLock进行线程同步
- en: Thread synchronization with semaphores
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用信号量进行线程同步
- en: Thread synchronization with a condition
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用条件进行线程同步
- en: Thread synchronization with an event
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件进行线程同步
- en: Thread synchronization with a barrier
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用屏障进行线程同步
- en: Thread communication using a queue
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用队列进行线程通信
- en: We will also explore the main options offered by Python to program with threads.
    To do this, we will focus on using the `threading` module.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨Python提供的用于线程编程的主要选项。为此，我们将专注于使用`threading`模块。
- en: What is a thread?
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是线程？
- en: A *thread* is an independent execution flow that can be executed in parallel
    and concurrently with other threads in the system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*线程*是一个可以与其他系统中的线程并行和并发执行的独立执行流程。'
- en: Multiple threads can share data and resources, taking advantage of the so-called
    space of shared information. The specific implementation of threads and processes
    depends on the OS on which you plan to run the application, but, in general, it
    can be stated that a thread is contained inside a process and that different threads
    in the same process conditions share some resources. In contrast to this, different
    processes do not share their own resources with other processes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 多个线程可以共享数据和资源，利用所谓的共享信息空间。线程和进程的具体实现取决于你计划在哪个操作系统上运行应用程序，但一般来说，可以这样说，线程包含在进程内部，并且同一进程中的不同线程条件共享一些资源。相比之下，不同的进程不会与其他进程共享它们自己的资源。
- en: 'A thread is composed of three elements: program counters, registers, and stack.
    Shared resources with other threads of the same process essentially include *data*
    and *OS resources*. Moreover, threads have their own state of execution, namely,
    *thread state*, and can be *synchronized* with other threads.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 线程由三个元素组成：程序计数器、寄存器和栈。与同一进程中的其他线程共享的资源基本上包括*数据*和*操作系统资源*。此外，线程有自己的执行状态，即*线程状态*，并且可以与其他线程*同步*。
- en: 'A thread state can be ready, running, or blocked:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 线程状态可以是就绪、运行或阻塞：
- en: When a thread is created, it enters the **Ready **state.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当线程被创建时，它进入**就绪**状态。
- en: A thread is scheduled for execution by the OS (or by the runtime support system)
    and, when its turn arrives, it begins execution by going into the **Running **state.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程由操作系统（或运行时支持系统）调度执行，当轮到它时，它进入**运行**状态开始执行。
- en: 'The thread can wait for a condition to occur, passing from the **Running **state
    to the **Blocked **state. Once the locked condition is terminated, the **Blocked **thread
    returns to the **Ready **state:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程可以等待一个条件发生，从**运行**状态转换为**阻塞**状态。一旦锁定条件终止，**阻塞**线程将返回到**就绪**状态：
- en: '![](img/1c9d8391-719e-4277-a1ae-dd4155345659.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1c9d8391-719e-4277-a1ae-dd4155345659.png)'
- en: Thread life cycle
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 线程生命周期
- en: The main advantage of multithreading programming lies in performances, as the
    context switch between processes turns out to be much heavier than the switch
    context between threads that belong to the same process.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程编程的主要优势在于性能，因为进程之间的上下文切换比同一进程内的线程之间的上下文切换要重得多。
- en: In the next recipes, until the end of the chapter, we will examine the Python
    `threading` module, introducing its main functions through programming examples.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，直到本章结束，我们将检查Python的`threading`模块，通过编程示例介绍其主要功能。
- en: Python threading module
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python线程模块
- en: Python manages threads with the `threading` module provided by the Python standard
    library. This module provides some very interesting features that make the threading-based
    approach a whole lot easier; in fact, the `threading` module provides several
    synchronization mechanisms that are very simple to implement.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Python使用Python标准库提供的`threading`模块来管理线程。此模块提供了一些非常有趣的功能，使得基于线程的方法变得非常简单；实际上，`threading`模块提供了几个非常简单的同步机制。
- en: 'The major components of the threading module are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 线程模块的主要组件如下：
- en: The `thread` object
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thread`对象'
- en: The `lock` object
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lock`对象'
- en: The `RLock` object
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RLock`对象'
- en: The `semaphore` object
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`semaphore`对象'
- en: The `condition` object
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`condition`对象'
- en: The `event` object
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event`对象'
- en: In the following recipes, we examine the features offered by the `threading`
    library with different application examples. For the examples that follow, we
    will refer to the Python 3.5.0 distribution ([https://www.python.org/downloads/release/python-350/](https://www.python.org/downloads/release/python-350/)).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的菜谱中，我们通过不同的应用示例检查`threading`库提供的功能。对于下面的示例，我们将参考Python 3.5.0发行版（[https://www.python.org/downloads/release/python-350/](https://www.python.org/downloads/release/python-350/))。
- en: Defining a thread
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义线程
- en: The simplest way to use a thread is to instantiate it with a target function
    and then call the start method to let it begin the job.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线程的最简单方法是使用目标函数实例化它，然后调用start方法让它开始工作。
- en: Getting ready
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The Python `threading` module provides a `Thread` class that is used to run
    processes and functions in a different thread:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`threading`模块提供了一个`Thread`类，用于在不同的线程中运行进程和函数：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here are the parameters of the `Thread` class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Thread`类的参数：
- en: '`group`: This is the `group` value, which should be `None`; this is reserved
    for future implementations.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group`：这是`group`值，应该是`None`；这是为未来的实现保留的。'
- en: '`target`: This is the function that is to be executed when you start a thread
    activity.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target`：这是启动线程活动时要执行的功能。'
- en: '`name`: This is the name of the thread; by default, a unique name of the form
    of `Thread-N` is assigned to it.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这是线程的名称；默认情况下，分配给它一个唯一的名称，形式为`Thread-N`。'
- en: '`args`: This is the tuple of arguments that are to be passed to a target.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`args`：这是要传递给目标函数的参数元组。'
- en: '`kwargs`: This is the dictionary of keyword arguments that are to be used for
    the `target` function.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kwargs`：这是用于`target`函数的关键字参数字典。'
- en: In the next section, let's learn about how to define a thread.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何定义线程。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We''ll define a thread by passing it a number, which represents the thread
    number, and finally, the result will be printed out:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过传递一个数字来定义线程，这个数字代表线程号，最后将打印出结果：
- en: 'Import the `threading` module by using the following Python command:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下Python命令导入`threading`模块：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `main` program, a `Thread` object is instantiated with a `target` function
    called `my_func`. Then, an argument to the function that will be included in the
    output message is passed:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`程序中，使用名为`my_func`的目标函数实例化一个`Thread`对象。然后，将包含在输出消息中的函数参数传递：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The thread does not start running until the start method is called, and the
    `join` method makes the calling thread and waits until the thread has finished
    the execution, as follows:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程只有在调用`start`方法后才开始运行，`join`方法使调用线程等待，直到线程完成执行，如下所示：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the `main` program, we initialize the thread''s list, to which we add the
    instance of each thread that is created. The total number of threads created is
    10, while the **i**-index for the i^(th) thread is passed as an argument to the
    i^(th) thread:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`程序中，我们初始化线程列表，并将创建的每个线程的实例添加到该列表中。创建的线程总数为10，而i^(th)线程的**i**-索引作为参数传递给i^(th)线程：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There's more...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: All current processors are multicore, thus offering the possibility of performing
    multiple parallel operations and making the most of the computer's computational
    resources. Although this is true, multithread programming hides a number of non-trivial
    difficulties, which must be managed appropriately to avoid errors such as deadlocks
    or synchronization problems.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所有当前处理器都是多核的，因此提供了执行多个并行操作的可能性，并充分利用计算机的计算资源。尽管这是真的，但多线程编程隐藏了许多非平凡困难，这些困难必须得到适当的处理，以避免死锁或同步问题等错误。
- en: Determining the current thread
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定当前线程
- en: Using arguments to identify or name the thread is cumbersome and unnecessary.
    Each `Thread` instance has a *name* with a default value that can be changed as
    the thread is created.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数来识别或命名线程是繁琐且不必要的。每个`Thread`实例都有一个*name*，具有默认值，可以在创建线程时更改。
- en: Naming threads is useful in server proc*esses* with multiple service threads
    that handle different operations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有多个服务线程处理不同操作的服务器进程中，命名线程是有用的。
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This `threading` module provides the `currentThread().getName()` method, which
    returns the name of the current thread.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`threading`模块提供了`currentThread().getName()`方法，它返回当前线程的名称。
- en: The following section shows us how to use this function to determine which thread
    is running.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分展示了我们如何使用此功能来确定哪个线程正在运行。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s have a look at the following steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤：
- en: 'To determine which thread is running, we create three `target` functions and
    import the `time` module to introduce a suspended execution of two seconds:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要确定哪个线程正在运行，我们创建了三个`target`函数，并导入`time`模块以引入两秒的暂停执行：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Three threads are instantiated with a `target` function. Then, we pass the
    name that is to be printed and, if it is not defined, then the default name will
    be used. Then, the `start()` and `join()` methods are called for each thread:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`target`函数创建了三个线程。然后，我们传递要打印的名称，如果没有定义，则使用默认名称。然后，对每个线程调用`start()`和`join()`方法：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We are going to set up three threads, each of which is assigned a `target` function.
    When the `target` function is executed and terminated, the function name is appropriately
    printed out.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置三个线程，每个线程都分配了一个`target`函数。当`target`函数执行并终止时，将适当地打印出函数名称。
- en: 'For this example, the output should look like this (even if the order shown
    cannot be the same):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，输出应该看起来像这样（即使显示的顺序可能不同）：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Defining a thread subclass
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义线程子类
- en: Creating a thread can require the definition of a subclass, which inherits from
    the `Thread` class. The latter, as explained in *Defining a thread* section, is
    included in the `threading` module, which must then be imported.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个线程可能需要定义一个子类，该子类从`Thread`类继承。正如在*定义线程*部分中解释的那样，后者包含在`threading`模块中，然后必须导入该模块。
- en: Getting ready
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The class that we will define in the next section, which represents our thread,
    respects a precise structure: we will first have to define the **`__init__`**
    method, but, above all, we will have to override the `run` method.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节定义的类，它代表我们的线程，遵循一个精确的结构：我们首先必须定义**`__init__`**方法，但最重要的是，我们必须重写`run`方法。
- en: How to do it...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The steps involved are as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及的步骤如下：
- en: 'We defined the `MyThreadClass` class, which we can use to create all the threads
    we want. Each thread of this type will be characterized by the operations defined
    in the `run` method, which, in this simple example, limits itself to printing
    a string at the beginning and at the end of its execution:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了`MyThreadClass`类，我们可以使用它来创建我们想要的任何线程。这种类型的每个线程都将由`run`方法中定义的操作所特征化，在这个简单的例子中，它限制自己在执行开始和结束时打印一个字符串：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Furthermore, in the `__init__` method, we have specified two initialization
    parameters, respectively, `name` and `duration`, that will be used in the `run`
    method:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在`__init__`方法中，我们指定了两个初始化参数，分别是`name`和`duration`，它们将在`run`方法中使用：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These parameters will then be set during the creation of the thread. In particular,
    the `duration` parameter is computed using the `randint` function that outputs
    a random integer between `1` and `10`. Starting from the definition of `MyThreadClass`,
    let''s see how to instantiate more threads, as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些参数将在创建线程时设置。特别是，`duration`参数使用`randint`函数计算，该函数输出一个介于`1`和`10`之间的随机整数。从`MyThreadClass`的定义开始，让我们看看如何实例化更多线程，如下所示：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, we created nine threads, each with their own `name` and `duration`
    property, according to the definition of the `__init__` method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了九个线程，每个线程都有自己的`name`和`duration`属性，这些属性根据`__init__`方法的定义。
- en: We then run them using the `start` method, which is limited to executing the
    contents of the previously defined `run` method. Note that the process ID for
    each thread is the same, meaning that we are in a multithreaded process.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后使用`start`方法运行它们，该方法仅限于执行先前定义的`run`方法的内容。请注意，每个线程的进程ID是相同的，这意味着我们处于一个多线程进程。
- en: 'Also, note that the start method *is not blocking*: when it is executed, the
    control immediately goes to the next line, while the thread is started in the
    background. In fact, as you can see, the creation of threads *does not take place*
    in the order specified by the code. Likewise, thread termination is constrained
    to the value of the `duration` parameter, evaluated using the `randint` function,
    and passed by the parameter for each thread creation instance. To wait for a thread
    to finish, a `join` operation must be performed.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，`start`方法*不是阻塞的*：当它执行时，控制权立即转到下一行，而线程则在后台启动。实际上，正如您所看到的，线程的创建*并不按照代码指定的顺序进行*。同样，线程的终止受`duration`参数值的约束，该参数使用`randint`函数评估，并通过每个线程创建实例的参数传递。要等待线程完成，必须执行`join`操作。
- en: 'The output looks like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像这样：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There's more...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The feature that is most frequently associated with OOP is *inheritance*, which
    is the ability to define a new class as a modified version of an already existing
    class. The main advantage of inheritance is that you can add new methods to a
    class without having to change the original definition.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与面向对象编程（OOP）最常相关联的特性是*继承*，这是将一个新类定义为已存在类的修改版本的能力。继承的主要优势是您可以在不修改原始定义的情况下向类中添加新方法。
- en: The original class is often referred to as the parent class and the derived
    class, subclass. Inheritance is a powerful feature, and some programs can be written
    much more easily and concisely, providing the possibility to customize the behavior
    of a class without modifying the original class. The very fact that the inheritance
    structure can reflect that of the problem can, in some cases, make the program
    easier to understand.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类通常被称为父类，而派生类被称为子类。继承是一个强大的特性，某些程序可以编写得更加容易和简洁，提供了在不修改原始类的情况下自定义类行为的可能性。实际上，继承结构能够反映问题的结构，在某些情况下，可以使程序更容易理解。
- en: However (to put the user on guard!), inheritance can make it more difficult
    to read the program. This is because, when invoking a method, it is not always
    clear where this has been defined within the code that must be traced within multiple
    modules, instead of being in a single well-defined place.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而（为了提醒用户注意！），继承可能会使程序更难阅读。这是因为，在调用方法时，并不总是清楚这个方法是在代码的哪个地方定义的，而这个代码需要在多个模块中追踪，而不是在一个定义良好的地方。
- en: Many of the things that can be done with inheritance can usually be managed
    elegantly even without it, so it is appropriate to only use inheritance if the
    structure of the problem requires it. If used at the wrong time, then the harm
    inheritance can cause can outweigh the benefits of using it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，可以使用继承完成的事情，即使没有它也可以优雅地管理，因此只有在问题的结构需要时才应该使用继承。如果使用不当，那么继承可能造成的危害可能会超过使用它的好处。
- en: Thread synchronization with a lock
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用锁进行线程同步
- en: The `threading` module also includes a simple lock mechanism, which allows us
    to implement synchronization between threads.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`threading`模块还包括一个简单的锁机制，这允许我们在线程之间实现同步。'
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: A *lock* is nothing more than an object that is typically accessible by multiple
    threads, which a thread must possess before it can proceed to the execution of
    a protected section of a program. These locks are created by executing the `Lock()`
    method, which is defined in the `threading` module.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*锁*不过是一个通常可以被多个线程访问的对象，线程在进入程序受保护部分的执行之前必须拥有它。这些锁是通过执行`Lock()`方法创建的，该方法定义在`threading`模块中。'
- en: 'Once the lock has been created, we can use two methods that allow us to synchronize
    the execution of two (or more) threads: the `acquire()` method to acquire the
    lock control, and the `release()` method to release it.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了锁，我们可以使用两种方法来同步两个（或更多）线程的执行：`acquire()`方法用于获取锁控制，`release()`方法用于释放它。
- en: The `acquire()` method accepts an optional parameter that, if not specified
    or set to `True`, forces the thread to suspend its execution until the lock is
    released and can then be acquired. If, on the other hand, the `acquire()` method
    is executed with an argument equal to `False`, then it immediately returns a Boolean
    result, which is `True` if the lock has been acquired, or `False` otherwise.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`acquire()`方法接受一个可选参数，如果未指定或设置为`True`，将强制线程暂停其执行，直到锁被释放并可以获取。另一方面，如果`acquire()`方法以等于`False`的参数执行，则它立即返回一个布尔结果，如果锁已被获取，则为`True`，否则为`False`。'
- en: In the following example, we show the lock mechanism by modifying the code introduced
    in the previous recipe, *Defining a thread subclass*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们通过修改上一节中引入的代码，*定义线程子类*，来展示锁机制。
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'The steps involved are as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及的步骤如下：
- en: 'As shown in the following code block, the `MyThreadClass` class has been modified,
    introducing the `acquire()` and `release()` methods within the **`run`** method,
    while the `Lock()` definition is outside the definition of the class itself:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下代码块所示，`MyThreadClass`类已被修改，在**`run`**方法中引入了`acquire()`和`release()`方法，而`Lock()`的定义则位于类定义之外：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `main()` function has not changed with respect to the previous code sample:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前的代码示例相比，`main()`函数没有发生变化：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have modified the code of the previous section by using a lock so that the
    threads will be executed in sequence.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用锁修改了上一节的代码，以便线程将按顺序执行。
- en: The first thread acquires the lock and performs its task while the other eight
    remain *on hold.* At the end of the execution of the first thread, that is, when
    the `release()` method is executed, the second one will get the lock and the threads
    from three to eight will still be waiting until the end of the execution (that
    is, once again, only after running the `release()` method).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个线程获取锁并执行其任务，而其他八个线程则保持*等待状态*。在第一个线程执行结束后，即执行`release()`方法后，第二个线程将获取锁，而三到八个线程将继续等待，直到执行结束（即再次，只有在运行`release()`方法之后）。
- en: 'The *lock-acquire* and *lock-release* execution are repeated until the ninth
    thread, with the final result that as a result of the lock mechanism, this execution
    takes place in a sequential mode, as can be seen in the following output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*锁获取*和*锁释放*的执行会重复进行，直到第九个线程，最终结果是，由于锁机制，此执行以顺序模式进行，如下面的输出所示：'
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There's more...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The insertion points of the `acquire()` and `release()` methods determine the
    entire execution of the code. For this reason, it is very important that you take
    the time to analyze what threads you want to use and how you want to synchronize
    them.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`acquire()`和`release()`方法的插入点决定了整个代码的执行。因此，您花时间分析您想要使用的线程以及您想要如何同步它们非常重要。'
- en: 'For example, we can change the insertion point of the `release()` method in
    the `MyThreadClass` class like so:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将`MyThreadClass`类中`release()`方法的插入点更改如下：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this case, the output changes quite significantly:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输出发生了相当显著的变化：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, only the thread creation happens in sequential mode. Once thread
    creation is complete, the new thread acquires the lock, while the previous one
    continues the computation in the background.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，只有线程创建是以顺序模式发生的。一旦线程创建完成，新线程获取锁，而前一个线程则在后台继续计算。
- en: Thread synchronization with RLock
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RLock进行线程同步
- en: A reentrant lock, or simply an RLock, is a synchronization primitive that can
    be acquired multiple times by the same thread.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可重入锁，或简称RLock，是一种可以被同一线程多次获取的同步原语。
- en: It uses the concept of the proprietary thread. This means that in the *locked
    state*, some threads own the lock, while in the *unlocked state*, the lock is
    not owned by any thread.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用了专有线程的概念。这意味着在**锁定状态**下，一些线程拥有锁，而在**未锁定状态**下，锁不被任何线程拥有。
- en: The next example demonstrates how to manage threads through the `RLock()` mechanism.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例演示了如何通过`RLock()`机制管理线程。
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: An RLock is implemented through the `threading.RLock()` class. It provides the
    `acquire()` and `release()` methods that have the same syntax as the `threading.Lock()`
    class.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`RLock`是通过`threading.RLock()`类实现的。它提供了与`threading.Lock()`类语法相同的`acquire()`和`release()`方法。'
- en: An `RLock` block can be acquired multiple times by the same thread. Other threads
    will not be able to acquire the `RLock` block until the thread that owns it has
    made a `release()` call for every previous `acquire()` call. Indeed, the `RLock`
    block must be released, but only by the thread that acquired it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`RLock`块可以被同一线程多次获取。其他线程将无法获取`RLock`块，直到拥有它的线程为每个之前的`acquire()`调用执行了`release()`调用。实际上，`RLock`块必须被释放，但只能由获取它的线程释放。'
- en: How to do it...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The steps involved are as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及的步骤如下：
- en: 'We introduced the `Box` class, which provides the `add()` and `remove()` methods
    that access the `execute()` method in order to perform the action to add or delete
    an item, respectively. Access to the `execute()` method is regulated by `RLock()`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们引入了`Box`类，它提供了`add()`和`remove()`方法，这些方法通过访问`execute()`方法来执行添加或删除项目的操作。对`execute()`方法的访问由`RLock()`调节：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following functions are called by the two threads. They have the `box` class and
    the total number of `items` to add or to remove as parameters:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数由两个线程调用。它们有`box`类和要添加或删除的总`items`数量作为参数：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, the total number of items to add or to remove from the box is set. As
    you can see, these two numbers will be different. The execution ends when both
    the `adder` and `remover` methods accomplish their tasks:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，设置要添加到或从盒子中移除的项目总数。如您所见，这两个数字将不同。当`adder`和`remover`方法完成其任务时，执行结束：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the `main` program, the two threads of `t1` and `t2` have been associated
    with the `adder()` and `remover()` functions. The functions are active if the
    number of items is greater than zero.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`程序中，`t1`和`t2`两个线程已经与`adder()`和`remover()`函数相关联。如果项目的数量大于零，则函数是活跃的。
- en: 'The call to `RLock()` is carried out inside the `__init__` method of the **`Box`**
    class:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`RLock()`的调用是在**`Box`**类的`__init__`方法中进行的：'
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The two `adder()` and `remover()` functions interact with the items of the `Box`
    class, respectively, and call the `Box` class methods of `add()` and `remove()`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`adder()`和`remover()`函数分别与`Box`类的项目交互，并调用`Box`类的`add()`和`remove()`方法。
- en: In each method call, a resource is captured and then released using the `lock`
    parameter that is set in the `_init_` method.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次方法调用中，通过在`_init_`方法中设置的`lock`参数捕获资源，然后释放资源。
- en: 'Here is the output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There's more...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The differences between *lock* and *RLock* are as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`lock`和`RLock`之间的区别如下：'
- en: A *lock* can only be acquired once before it must be released. However, `RLock`
    can be acquired multiple times from the same thread; it must be released the same
    number of times in order to be released.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**锁**在必须释放之前只能被获取一次。然而，`RLock`可以从同一线程多次获取；必须以相同的方式释放相同次数，才能释放。
- en: Another difference is that an acquired lock can be released by any thread, whereas
    an acquired `RLock` can only be released by the thread that acquired it.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个区别是，获取的锁可以被任何线程释放，而获取的`RLock`只能由获取它的线程释放。
- en: Thread synchronization with semaphores
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用信号量进行线程同步
- en: A **semaphore** is an abstract data type managed by the OS to synchronize access
    by multiple threads to shared resources and data. It consists of an internal variable
    that identifies the amount of concurrent access to a resource with which it is
    associated.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**信号量**是一种由操作系统管理的高级数据类型，用于同步多个线程对共享资源和数据的访问。它包含一个内部变量，用于标识与它关联的资源并发访问的数量。'
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The operation of a semaphore is based on two functions: `acquire()` and `release()`,
    as explained here:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量的操作基于两个函数：`acquire()`和`release()`，如这里所述：
- en: Whenever a thread wants to access a given or a resource that is associated with
    a semaphore, it must invoke the `acquire()` operation, which *decreases the internal
    variable of the semaphore* and allows access to the resource if the value of this
    variable appears to be non-negative. If the value is negative, then the thread
    will be suspended and the release of the resource by another thread will be placed
    on hold.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个线程想要访问与信号量关联的给定资源时，它必须调用 `acquire()` 操作，这将*减少信号量的内部变量*，如果这个变量的值看起来是非负的，则允许访问资源。如果值是负的，则线程将被挂起，并且另一个线程释放资源的操作将被暂停。
- en: Having finished using shared resources, the thread frees resources through the
    `release()` instruction. In this way, the internal variable of the semaphore is
    increased, allowing, for a *waiting* thread (if any), the opportunity to access
    the newly freed resource.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用完共享资源后，线程通过 `release()` 指令释放资源。这样，信号量的内部变量就会增加，为*等待*的线程（如果有的话）提供了访问新释放资源的机遇。
- en: The semaphore is one of the oldest synchronization primitives in the history
    of computer science, invented by the early Dutch computer scientist Edsger W.
    Dijkstra.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量是计算机科学历史上最古老的同步原语之一，由早期荷兰计算机科学家Edsger W. Dijkstra发明。
- en: The following example shows how to synchronize threads through a semaphore.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何通过信号量同步线程。
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: The following code describes a problem where we have two threads, `producer()`
    and `consumer()`, that share a common resource, which is the item. The task of
    `producer()` is to generate the item while the `consumer()` thread's task is to
    use the item that has been produced.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码描述了一个问题，其中我们有两个线程，`producer()` 和 `consumer()`，它们共享一个公共资源，即项目。`producer()`
    的任务是生成项目，而 `consumer()` 线程的任务是使用已经被生产的项目。
- en: 'If the item has not yet produced the `consumer()` thread, then it has to wait.
    As soon as the item is produced, the `producer()` thread notifies the consumer
    that the resource should be used:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目尚未由 `consumer()` 线程生产，那么它必须等待。一旦项目被生产，`producer()` 线程通知消费者资源应该被使用：
- en: 'By initializing a semaphore to `0`, we obtain a so-called semaphore event whose
    sole purpose is to synchronize the computation of two or more threads. Here, a
    thread must make use of data or common resources simultaneously:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将信号量初始化为 `0`，我们获得了一个所谓的信号量事件，其唯一目的是同步两个或更多线程的计算。在这里，一个线程必须同时使用数据或共享资源：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This operation is very similar to that described in the lock mechanism of the
    lock. The `producer()` thread creates the item and, after that, it frees the resource
    by calling the `release()` method:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个操作与锁机制的描述非常相似。`producer()` 线程创建项目，然后通过调用 `release()` 方法释放资源：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Similarly, the `consumer()` thread acquires the data by the `acquire()` method.
    If the semaphore''s counter is equal to `0`, then it blocks the condition''s `acquire()`
    method until it gets notified by a different thread. If the semaphore''s counter
    is greater than `0`, then it decrements the value. When the producer creates an
    item, it releases the semaphore, and then the consumer acquires it and consumes
    the shared resource:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，`consumer()` 线程通过 `acquire()` 方法获取数据。如果信号量的计数器等于 `0`，则它将阻塞条件的 `acquire()`
    方法，直到它被另一个线程通知。如果信号量的计数器大于 `0`，则它将减少该值。当生产者创建一个项目时，它释放信号量，然后消费者获取它并消费共享资源：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The synchronization process that is done via the semaphores is shown in the
    following code block:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过信号量完成的同步过程在以下代码块中展示：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The data acquired is then printed on the standard output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将在标准输出上打印获取的数据：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is the result that we get after 10 runs:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在10次运行后得到的结果：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There's more...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: A particular use of semaphores is the *mutex*. A mutex is nothing but a semaphore
    with an internal variable initialized to the value of `1`, which allows the realization
    of mutual exclusion in access to data and resources.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量的一个特定用途是*互斥锁*。互斥锁不过是一个内部变量初始化为 `1` 的信号量，它允许实现对数据和资源的互斥访问。
- en: 'Semaphores are still commonly used in programming languages that are multithreaded;
    however, they have two major problems, which we have discussed, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量在多线程编程语言中仍然被广泛使用；然而，它们有两个主要问题，我们已经在以下内容中讨论过：
- en: They do not prevent the possibility of a thread performing more wait operations
    on the same semaphore. It is very easy to forget to do all the necessary signals
    in relation to the number of waits performed.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们并不能阻止线程在同一个信号量上执行更多等待操作的可能性。很容易忘记与执行等待操作的数量相关的所有必要的信号。
- en: You can run into situations of deadlock. For example, a deadlock situation is
    created when the `t1` thread executes a wait on the `s1` semaphore, while the
    **`t2`** thread executes a wait on the thread `t1`, executes a wait on `s2` and
    `t2`, and then executes a wait on `s1`.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能会遇到死锁的情况。例如，当 `t1` 线程在 `s1` 信号量上执行等待操作，而 **`t2`** 线程在 `t1` 线程上执行等待操作，然后等待
    `s2` 和 `t2`，最后等待 `s1` 时，就会创建一个死锁情况。
- en: Thread synchronization with a condition
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用条件进行线程同步
- en: A *condition* identifies a change of state in the application. It is a synchronization
    mechanism where a thread waits for a specific condition and another thread notifies
    that this *condition has taken place*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*条件* 识别应用程序中的状态变化。它是一种同步机制，其中线程等待特定条件，而另一个线程通知该 *条件已经发生*。'
- en: Once the condition takes place, the thread *acquires* the lock in order to get
    *exclusive access* to the shared resource.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦条件成立，线程 *获取* 锁以获得对共享资源的 *独占访问*。
- en: Getting ready
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: A good way to illustrate this mechanism is by looking again at a producer/consumer
    problem. The class producer writes to a buffer if it is not full, and the class
    consumer takes the data from the buffer (eliminating them from the latter) if
    the buffer is full. The class producer will notify the consumer that the buffer
    is not empty, while the consumer will report to the producer that the buffer is
    not full.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过再次查看生产者/消费者问题，可以很好地说明这种机制。如果缓冲区不满，`producer` 类将写入缓冲区，如果缓冲区已满，`consumer` 类将从缓冲区中取出数据（从后者中删除）。`producer`
    类将通知消费者缓冲区不为空，而消费者将向生产者报告缓冲区不为空。
- en: How to do it...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The steps involved are as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及的步骤如下：
- en: 'The class consumer acquires the shared resource that is modelled through the **`items[]`** list:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`consumer` 类通过 **`items[]`** 列表获取共享资源：'
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the length of the list is equal to `0`, then the consumer is placed in a
    waiting state:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果列表长度等于 `0`，则消费者将处于等待状态：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then it makes a **`pop`** operation from the items list:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后它从项目列表中执行一个 **`pop`** 操作：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So, the consumer''s state is notified to the producer and the shared resource
    is released:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，将消费者状态通知给生产者，并释放共享资源：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The class producer acquires the shared resource and then it verifies that the
    list is completely full (in our example, we place the maximum number of items,
    `10`, that can be contained in the items list). If the list is full, then the
    producer is placed in the wait state until the list is consumed:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`producer` 类获取共享资源，然后它验证列表是否完全填满（在我们的例子中，我们放置了项目列表中可以包含的最大项目数，`10`）。如果列表已满，则生产者将处于等待状态，直到列表被消耗：'
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If the list is not full, then a single item is added. The state is notified
    and the resource is released:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果列表未满，则添加一个单独的项目。状态被通知，资源被释放：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To show you the condition mechanism, we will use the *consumer/producer* model again:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了向您展示条件机制，我们将再次使用 *消费者/生产者* 模型：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`producer` generates the item and stores it in the buffer continuously. At
    the same time, `consumer` uses the data produced, removing it from the buffer
    from time to time.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`producer` 持续生成项目并将其存储在缓冲区中。同时，`consumer` 使用生产出的数据，并时不时地从缓冲区中移除它。'
- en: As soon as `consumer` has picked up an object from the buffer, it will wake
    up `producer`, who will start to fill the buffer again.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `consumer` 从缓冲区中取走一个对象，它将唤醒 `producer`，然后 `producer` 将开始再次填充缓冲区。
- en: Similarly, `consumer` will suspend if the buffer is empty. As soon as `producer`
    has downloaded the data into the buffer, `consumer` will wake up.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果缓冲区为空，`consumer` 将会挂起。一旦 `producer` 将数据下载到缓冲区，`consumer` 将会唤醒。
- en: As you can see, even in this case, the use of the `condition` directive allows
    the threads to be properly synchronized.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，即使在在这种情况下，使用 `condition` 指令也能使线程得到适当的同步。
- en: 'The result that we get after a single run is as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 单次运行后得到的结果如下：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There's more...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'It''s interesting to see the Python internals for the condition synchronization
    mechanism. The internal `class _Condition` creates an `RLock()` object if no existing
    lock has been passed to the class''s constructor. Also, the lock will be managed
    when `acquire()` and `released()` are called:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 看到Python内部的条件同步机制非常有趣。内部`class _Condition`在类构造函数未传递现有锁时创建一个`RLock()`对象。此外，当调用`acquire()`和`released()`时，将管理锁：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Thread synchronization with an event
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件进行线程同步
- en: An event is an object that is used for communication between threads. A thread
    waits for a signal while another thread outputs it. Basically, an `event` object
    manages an internal flag that can be set to `false` with `clear()`, set to `true`
    with `set()`, and tested with `is_set()`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是一个用于线程间通信的对象。一个线程等待信号，而另一个线程输出它。基本上，一个`event`对象管理一个内部标志，可以通过`clear()`将其设置为`false`，通过`set()`将其设置为`true`，并通过`is_set()`进行测试。
- en: A thread can hold a signal by means of the `wait()` method, which sends the
    call with the `set()` method.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一个线程可以通过`wait()`方法持有信号，该方法通过`set()`方法发送调用。
- en: Getting ready
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To understand thread synchronization through the `event` object, let's take
    a look at the producer/consumer problem.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过事件对象理解线程同步，让我们看看生产者/消费者问题。
- en: How to do it...
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Again, to explain how to synchronize threads through events, we will refer to
    the *producer/consumer* problem. The problem describes two processes, a producer
    and a consumer, who share a common buffer of a fixed size. The producer's task
    is to generate items and deposit them in the continuous buffer. At the same time,
    the consumer will use the items produced, removing them from the buffer from time
    to time.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，为了解释如何通过事件同步线程，我们将参考*生产者/消费者*问题。该问题描述了两个进程，一个生产者和一个消费者，他们共享一个固定大小的公共缓冲区。生产者的任务是生成项并将它们存入连续的缓冲区。同时，消费者将使用生产的项，并时不时地从缓冲区中移除它们。
- en: The problem is to ensure that the producer does not process new data if the
    buffer is full and that the consumer does not look for data if the buffer is empty.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于确保生产者在缓冲区满时不处理新数据，而消费者在缓冲区空时不寻找数据。
- en: 'Now, let''s see how to implement the consumer/producer problem by using thread
    synchronization with an `event` statement:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何通过使用事件语句进行线程同步来实现消费者/生产者问题：
- en: 'Here, the relevant libraries are imported as follows:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，相关库按如下方式导入：
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, we define the log output format. It is useful to clearly visualize what''s
    happening:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义日志输出格式。这有助于清楚地可视化正在发生的事情：
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Set the `items` list. This parameter will be used by the `Consumer` and `Producer`
    classes:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`items`列表。此参数将由`Consumer`和`Producer`类使用：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `event` parameter is defined as follows. This parameter will be used to
    synchronize the communication between threads:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`event`参数定义如下。此参数将用于同步线程间的通信：'
- en: '[PRE40]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `Consumer` class is initialized with the list of items and the `Event()`
    function. In the `run` method, the consumer waits for a new item to consume. When
    the item arrives, it is popped from the `item` list:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Consumer`类使用项列表和`Event()`函数初始化。在`run`方法中，消费者等待要消费的新项。当项到达时，它从`item`列表中弹出：'
- en: '[PRE41]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `Producer` class is initialized with the list of items and the `Event()`
    function. Unlike the example with `condition` objects, the item list is not global,
    but it is passed as a parameter:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Producer`类使用项列表和`Event()`函数初始化。与使用`condition`对象的示例不同，项列表不是全局的，而是作为参数传递：'
- en: '[PRE42]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the `run` method for each item that is created, the `Producer` class appends
    it to the list of items and then notifies the event:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在为每个创建的项的`run`方法中，`Producer`类将其追加到项列表中，然后通知事件：
- en: '[PRE43]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'There are two steps that you need to take for this and the first step, which
    are as follows:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要采取两个步骤来完成此操作，第一步如下：
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `t1` thread appends a value to the list and then sets the event to notify
    the consumer. The consumer''s call to `wait()` stops blocking and the integer
    is retrieved from the list:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`t1`线程将值追加到列表中，然后设置事件以通知消费者。消费者的`wait()`调用停止阻塞，并从列表中检索整数：'
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'All the operations between the `Producer` and the `Consumer` classes can be
    easily resumed with the help of the following schema:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 所有在`Producer`和`Consumer`类之间的操作都可以通过以下方案轻松恢复：
- en: '![](img/915fcac0-899f-465a-9fd2-ce18a24bb0f0.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/915fcac0-899f-465a-9fd2-ce18a24bb0f0.png)'
- en: Thread synchronization with event objects
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件对象进行线程同步
- en: 'In particular, the `Producer` and the `Consumer` classes have the following
    behavior:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，`Producer`和`Consumer`类具有以下行为：
- en: '`Producer` acquires a lock, adds an item to the queue, and notifies this event
    to `Consumer` (`set event`). It then sleeps until it receives a new item to add.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Producer`获取一个锁，向队列中添加一个项目，并通过`set event`通知`Consumer`。然后它休眠，直到收到要添加的新项目。'
- en: '`Consumer` acquires a block and then begins to listen to the elements in a
    continuous cycle. The moment the event arrives, the consumer abandons the block,
    thus allowing other producers/consumers to enter and acquire the block. If `Consumer`
    is reactivated, then it reacquires the lock by safely processing new items from
    the queue:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Consumer`获取一个块并开始在一个连续循环中监听元素。当事件到达时，消费者放弃该块，从而允许其他生产者/消费者进入并获取该块。如果`Consumer`被重新激活，那么它将通过安全地处理队列中的新项目来重新获取锁：'
- en: '[PRE46]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Thread synchronization with a barrier
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用屏障进行线程同步
- en: 'Sometimes, an application can be divided into phases with the rule that no
    process can continue if first, all threads of the process have completed their
    own task. A **barrier** implements this concept: a thread that has finished its
    phase calls a primitive barrier and stops. When all the threads involved have
    finished their stage of execution and have also invoked the primitive barrier,
    the system unlocks them all, allowing threads to move to a later stage.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个应用程序可以被划分为阶段，规则是如果首先，该进程的所有线程都完成了它们自己的任务，则没有进程可以继续。一个**屏障**实现了这个概念：一个完成了其阶段的线程调用原始屏障并停止。当所有涉及的线程都完成了它们的执行阶段并也调用了原始屏障后，系统将解锁它们，允许线程移动到后续阶段。
- en: Getting ready
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Python's threading module implements barriers through the **`Barrier`** class. In
    the next section, let's learn about how to use this synchronization mechanism
    in a very simple example.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Python的threading模块通过`**`Barrier`**`类实现屏障。在下一节中，我们将学习如何在一个非常简单的示例中使用这种同步机制。
- en: How to do it...
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In this example, we simulate a run with three participants, `Huey`, `Dewey`,
    and `Louie`, in which a barrier is assimilated to that of a finish line.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们模拟了一场有三名参与者`Huey`、`Dewey`和`Louie`的跑步比赛，其中屏障被类比为终点线。
- en: Moreover, the race can end on its own when all three participants cross the
    finish line.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当所有三名参赛者都越过终点线时，比赛可以自行结束。
- en: 'The barrier is implemented through the `Barrier` class, in which the number
    of threads to be completed must be specified as an argument to move to the next
    stage:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 屏障是通过`Barrier`类实现的，其中必须指定要完成的线程数作为参数，以便移动到下一阶段：
- en: '[PRE47]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we set the number of runners to `num_runners = 3` in order to set the
    final goal on the next line through the `Barrier` directive. The runners are set
    in the runners' list; each of them will have an arrival time that is determined
    in the `runner` function, using the `randrange` directive.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将跑者的数量设置为`num_runners = 3`，以便通过`Barrier`指令在下一行设置最终目标。跑者被设置在跑者列表中；每个跑者的到达时间将在`runner`函数中使用`randrange`指令确定。
- en: 'When a runner arrives at the finish line, call the `wait` method, which will
    block all the runners (the threads) that have made that call. The output for this
    is as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当一名跑者到达终点线时，调用`wait`方法，这将阻塞所有已经调用该方法的跑者（线程）。输出如下：
- en: '[PRE48]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this case, `Dewey` won the race.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Dewey`赢得了比赛。
- en: Thread communication using a queue
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用队列进行线程通信
- en: Multithreading can be complicated when threads need to share data or resources.
    Luckily, the threading module provides many synchronization primitives, including
    semaphores, condition variables, events, and locks.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程需要共享数据或资源时，多线程可能会变得复杂。幸运的是，threading模块提供了许多同步原语，包括信号量、条件变量、事件和锁。
- en: However, it is considered a best practice to use the `queue` module. In fact,
    a queue is much easier to deal with and makes threaded programming considerably
    safer, as it effectively funnels all access to a resource of a single thread and
    allows for a cleaner and more readable design pattern.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`queue`模块被认为是一种最佳实践。实际上，队列更容易处理，并且使得线程编程更加安全，因为它有效地将所有对单个线程资源的访问引导到一个方向，并允许设计出更清晰、更易读的模式。
- en: Getting ready
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We will simply consider these queue methods:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简单地考虑这些队列方法：
- en: '`put()`: Puts an item in the queue'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put()`: 将一个项目放入队列'
- en: '`get()`: Removes and returns an item from the queue'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get()`: 从队列中移除并返回一个项目'
- en: '`task_done()`: Needs to be called each time an item has been processed'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`task_done()`: 需要在每次处理完一个项目时调用'
- en: '`join()`: Blocks until all items have been processed'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join()`: 阻塞直到所有项目都已被处理'
- en: How to do it...
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this example, we will see how to use the `threading` module with the `queue`
    module. Also, we have two entities here that try to share a common resource, a
    queue. The code is as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将看到如何使用`threading`模块与`queue`模块。此外，这里有两个实体试图共享一个公共资源，一个队列。代码如下：
- en: '[PRE49]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, with the `producer` class, we don't need to pass the integers list because
    we use the queue to store the integers that are generated.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用`producer`类，我们不需要传递整数列表，因为我们使用队列来存储生成的整数。
- en: The thread in the `producer` class generates integers and puts them in the queue
    in a `for` loop. The `producer` class uses `Queue.put(item[, block[, timeout]])`
    to insert data in the queue. It has the logic to acquire the lock before inserting
    data in a queue.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`producer`类中的线程生成整数，并在`for`循环中将它们放入队列中。`producer`类使用`Queue.put(item[, block[,
    timeout]])`在队列中插入数据。它具有在队列中插入数据之前获取锁的逻辑。'
- en: 'There are two possibilities:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种可能性：
- en: If the optional arguments `block` is `true` and `timeout` is `None` (this is
    the default case that we used in the example), then it is necessary for us to
    block until a free slot is available. If the timeout is a positive number, then
    it blocks at most timeout seconds and raises the full exception if no free slot
    is available within that time.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可选参数`block`是`true`且`timeout`是`None`（这是我们示例中使用的默认情况），那么我们需要阻塞，直到有空闲槽位可用。如果`timeout`是一个正数，那么它最多阻塞`timeout`秒，如果在那个时间内没有空闲槽位，则引发满异常。
- en: If the block is `false`, then put an item in the queue if a free slot is immediately
    available, otherwise, raise the full exception (timeout is ignored in this case).
    Here, `put` checks whether the queue is full and then calls `wait` internally,
    after which, the producer starts waiting.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`block`是`false`，那么如果立即有空闲槽位，则将项目放入队列中，否则引发满异常（在这种情况下忽略超时）。在这里，`put`检查队列是否已满，然后内部调用`wait`，之后生产者开始等待。
- en: Next is the `consumer` class. The thread gets the integer from the queue and
    indicates that it is done working on it by using `task_done`. The `consumer` class
    uses `Queue.get([block[, timeout]])` and acquires the lock before removing data
    from the queue. The consumer is placed in a waiting state, in case the queue is
    empty. Finally, in the `main` function, we create four threads, one for the `producer`
    class and three for the `consumer` class, respectively.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`consumer`类。线程从队列中获取整数，并通过使用`task_done`来指示它已完成对该整数的工作。`consumer`类使用`Queue.get([block[,
    timeout]])`并在从队列中移除数据之前获取锁。如果队列是空的，消费者将被置于等待状态。最后，在`main`函数中，我们创建了四个线程，一个用于`producer`类，三个用于`consumer`类。
- en: 'The output should be like this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该像这样：
- en: '[PRE50]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There's more...
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'All the operations between the `producer` class and the `consumer` class can
    easily be resumed with the following schema:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`producer`类和`consumer`类之间的所有操作都可以使用以下方案轻松恢复：'
- en: '![](img/cb11a94d-258a-485f-a1b4-8954a860b41a.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cb11a94d-258a-485f-a1b4-8954a860b41a.png)'
- en: Thread synchronization with the queue module
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用队列模块进行线程同步
- en: The `Producer` thread acquires the lock and then inserts data in the **QUEUE**
    data structure.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Producer`线程获取锁，然后在**队列**数据结构中插入数据。'
- en: The `Consumer` threads get the integers from the **QUEUE**. These threads acquire
    the lock before removing data from the **QUEUE**.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Consumer`线程从**队列**中获取整数。这些线程在从**队列**中移除数据之前获取锁。'
- en: If the **QUEUE** is empty, then the `consumer` threads get in a **waiting**
    state.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**队列**为空，那么`consumer`线程将进入**等待**状态。
- en: With this recipe, the chapter dedicated to thread-based parallelism comes to
    an end.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个配方，关于基于线程的并行主义的章节就此结束。
