- en: Thread-Based Parallelism
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于线程的并行
- en: Currently, the most widely used programming paradigm for the management of concurrency
    in software applications is based on multithreading. Generally, an application
    is made by a single processthat is divided into multiple independent threads,
    which represent activities of different types that run in paralleland compete
    with each other.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在软件应用程序中管理并发最广泛使用的编程范式是基于多线程的。通常，一个应用程序由一个单一进程组成，该进程被划分为多个独立的线程，这些线程代表不同类型的活动，它们并行运行并相互竞争。
- en: Nowadays, modern applications that use multithreading have been adopted on a
    massive scale. In fact, all current processors are multicore, just so they can
    perform parallel operations and exploit the computer's computational resources.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用多线程的现代应用程序已经被大规模采用。事实上，所有当前的处理器都是多核的，这样它们就可以执行并行操作并利用计算机的计算资源。
- en: Hence, *multithreaded programming*is definitely a good way to achieve concurrent
    applications. However, multithreaded programming often hides some non-trivial
    difficulties, which must be managed appropriately to avoid errors such as deadlocksor synchronization
    issues.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*多线程编程*无疑是实现并发应用的好方法。然而，多线程编程往往隐藏一些非平凡的困难，这些困难必须得到适当的处理，以避免死锁或同步问题等错误。
- en: We will first define the concepts of thread-based and multithreaded programming
    and then introduce the `multithreading` library. We will learn about the main
    directives for thread definition, management, and communication.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义基于线程和多线程编程的概念，然后介绍`multithreading`库。我们将学习线程定义、管理和通信的主要指令。
- en: Through the `multithreading` library, we will see how to solve problems through
    different techniques, such as *lock*, *RLock*, *semaphores*, *condition*, *event*, *barrier, *and
    *queue*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`multithreading`库，我们将看到如何通过不同的技术解决问题，例如*锁*、*RLock*、*信号量*、*条件*、*事件*、*屏障*和*队列*。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: What is a thread?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是线程？
- en: How to define a thread
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何定义线程
- en: How to determine the current thread
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确定当前线程
- en: How to use a thread in a subclass
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在子类中使用线程
- en: Thread synchronization with a lock
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用锁进行线程同步
- en: Thread synchronization with an RLock
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RLock进行线程同步
- en: Thread synchronization with semaphores
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用信号量进行线程同步
- en: Thread synchronization with a condition
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用条件进行线程同步
- en: Thread synchronization with an event
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件进行线程同步
- en: Thread synchronization with a barrier
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用屏障进行线程同步
- en: Thread communication using a queue
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用队列进行线程通信
- en: We will also explore the main options offered by Python to program with threads.
    To do this, we will focus on using the `threading` module.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨Python提供的用于线程编程的主要选项。为此，我们将专注于使用`threading`模块。
- en: What is a thread?
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是线程？
- en: A *thread* is an independent execution flow that can be executed in parallel
    and concurrently with other threads in the system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*线程*是一个可以与其他系统中的线程并行和并发执行的独立执行流程。'
- en: Multiple threads can share data and resources, taking advantage of the so-called
    space of shared information. The specific implementation of threads and processes
    depends on the OS on which you plan to run the application, but, in general, it
    can be stated that a thread is contained inside a process and that different threads
    in the same process conditions share some resources. In contrast to this, different
    processes do not share their own resources with other processes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 多个线程可以共享数据和资源，利用所谓的共享信息空间。线程和进程的具体实现取决于你计划在哪个操作系统上运行应用程序，但一般来说，可以这样说，线程包含在进程内部，并且同一进程中的不同线程条件共享一些资源。相比之下，不同的进程不会与其他进程共享它们自己的资源。
- en: 'A thread is composed of three elements: program counters, registers, and stack.
    Shared resources with other threads of the same process essentially include *data*
    and *OS resources*. Moreover, threads have their own state of execution, namely,
    *thread state*, and can be *synchronized* with other threads.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 线程由三个元素组成：程序计数器、寄存器和栈。与同一进程中的其他线程共享的资源基本上包括*数据*和*操作系统资源*。此外，线程有自己的执行状态，即*线程状态*，并且可以与其他线程*同步*。
- en: 'A thread state can be ready, running, or blocked:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 线程状态可以是就绪、运行或阻塞：
- en: When a thread is created, it enters the **Ready **state.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当线程被创建时，它进入**就绪**状态。
- en: A thread is scheduled for execution by the OS (or by the runtime support system)
    and, when its turn arrives, it begins execution by going into the **Running **state.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The thread can wait for a condition to occur, passing from the **Running **state
    to the **Blocked **state. Once the locked condition is terminated, the **Blocked **thread
    returns to the **Ready **state:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/1c9d8391-719e-4277-a1ae-dd4155345659.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: Thread life cycle
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of multithreading programming lies in performances, as the
    context switch between processes turns out to be much heavier than the switch
    context between threads that belong to the same process.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipes, until the end of the chapter, we will examine the Python
    `threading` module, introducing its main functions through programming examples.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Python threading module
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python manages threads with the `threading` module provided by the Python standard
    library. This module provides some very interesting features that make the threading-based
    approach a whole lot easier; in fact, the `threading` module provides several
    synchronization mechanisms that are very simple to implement.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'The major components of the threading module are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The `thread` object
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `lock` object
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `RLock` object
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `semaphore` object
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `condition` object
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `event` object
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following recipes, we examine the features offered by the `threading`
    library with different application examples. For the examples that follow, we
    will refer to the Python 3.5.0 distribution ([https://www.python.org/downloads/release/python-350/](https://www.python.org/downloads/release/python-350/)).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Defining a thread
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest way to use a thread is to instantiate it with a target function
    and then call the start method to let it begin the job.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Python `threading` module provides a `Thread` class that is used to run
    processes and functions in a different thread:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here are the parameters of the `Thread` class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '`group`: This is the `group` value, which should be `None`; this is reserved
    for future implementations.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`target`: This is the function that is to be executed when you start a thread
    activity.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: This is the name of the thread; by default, a unique name of the form
    of `Thread-N` is assigned to it.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`args`: This is the tuple of arguments that are to be passed to a target.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kwargs`: This is the dictionary of keyword arguments that are to be used for
    the `target` function.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, let's learn about how to define a thread.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll define a thread by passing it a number, which represents the thread
    number, and finally, the result will be printed out:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `threading` module by using the following Python command:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `main` program, a `Thread` object is instantiated with a `target` function
    called `my_func`. Then, an argument to the function that will be included in the
    output message is passed:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The thread does not start running until the start method is called, and the
    `join` method makes the calling thread and waits until the thread has finished
    the execution, as follows:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `main` program, we initialize the thread''s list, to which we add the
    instance of each thread that is created. The total number of threads created is
    10, while the **i**-index for the i^(th) thread is passed as an argument to the
    i^(th) thread:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There's more...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All current processors are multicore, thus offering the possibility of performing
    multiple parallel operations and making the most of the computer's computational
    resources. Although this is true, multithread programming hides a number of non-trivial
    difficulties, which must be managed appropriately to avoid errors such as deadlocks
    or synchronization problems.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Determining the current thread
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using arguments to identify or name the thread is cumbersome and unnecessary.
    Each `Thread` instance has a *name* with a default value that can be changed as
    the thread is created.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Naming threads is useful in server proc*esses* with multiple service threads
    that handle different operations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This `threading` module provides the `currentThread().getName()` method, which
    returns the name of the current thread.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The following section shows us how to use this function to determine which thread
    is running.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine which thread is running, we create three `target` functions and
    import the `time` module to introduce a suspended execution of two seconds:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Three threads are instantiated with a `target` function. Then, we pass the
    name that is to be printed and, if it is not defined, then the default name will
    be used. Then, the `start()` and `join()` methods are called for each thread:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to set up three threads, each of which is assigned a `target` function.
    When the `target` function is executed and terminated, the function name is appropriately
    printed out.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, the output should look like this (even if the order shown
    cannot be the same):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Defining a thread subclass
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a thread can require the definition of a subclass, which inherits from
    the `Thread` class. The latter, as explained in *Defining a thread* section, is
    included in the `threading` module, which must then be imported.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The class that we will define in the next section, which represents our thread,
    respects a precise structure: we will first have to define the **`__init__`**
    method, but, above all, we will have to override the `run` method.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps involved are as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'We defined the `MyThreadClass` class, which we can use to create all the threads
    we want. Each thread of this type will be characterized by the operations defined
    in the `run` method, which, in this simple example, limits itself to printing
    a string at the beginning and at the end of its execution:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Furthermore, in the `__init__` method, we have specified two initialization
    parameters, respectively, `name` and `duration`, that will be used in the `run`
    method:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在`__init__`方法中，我们指定了两个初始化参数，分别是`name`和`duration`，它们将在`run`方法中使用：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These parameters will then be set during the creation of the thread. In particular,
    the `duration` parameter is computed using the `randint` function that outputs
    a random integer between `1` and `10`. Starting from the definition of `MyThreadClass`,
    let''s see how to instantiate more threads, as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些参数将在创建线程时设置。特别是，`duration`参数使用`randint`函数计算，该函数输出一个介于`1`和`10`之间的随机整数。从`MyThreadClass`的定义开始，让我们看看如何实例化更多线程，如下所示：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, we created nine threads, each with their own `name` and `duration`
    property, according to the definition of the `__init__` method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了九个线程，每个线程都有自己的`name`和`duration`属性，这些属性根据`__init__`方法的定义。
- en: We then run them using the `start` method, which is limited to executing the
    contents of the previously defined `run` method. Note that the process ID for
    each thread is the same, meaning that we are in a multithreaded process.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后使用`start`方法运行它们，该方法仅限于执行先前定义的`run`方法的内容。请注意，每个线程的进程ID是相同的，这意味着我们处于一个多线程进程。
- en: 'Also, note that the start method *is not blocking*: when it is executed, the
    control immediately goes to the next line, while the thread is started in the
    background. In fact, as you can see, the creation of threads *does not take place*
    in the order specified by the code. Likewise, thread termination is constrained
    to the value of the `duration` parameter, evaluated using the `randint` function,
    and passed by the parameter for each thread creation instance. To wait for a thread
    to finish, a `join` operation must be performed.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，`start`方法*不是阻塞的*：当它执行时，控制权立即转到下一行，而线程则在后台启动。实际上，正如您所看到的，线程的创建*并不按照代码指定的顺序进行*。同样，线程的终止受`duration`参数值的约束，该参数使用`randint`函数评估，并通过每个线程创建实例的参数传递。要等待线程完成，必须执行`join`操作。
- en: 'The output looks like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像这样：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There's more...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The feature that is most frequently associated with OOP is *inheritance*, which
    is the ability to define a new class as a modified version of an already existing
    class. The main advantage of inheritance is that you can add new methods to a
    class without having to change the original definition.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与面向对象编程（OOP）最常相关联的特性是*继承*，这是将一个新类定义为已存在类的修改版本的能力。继承的主要优势是您可以在不修改原始定义的情况下向类中添加新方法。
- en: The original class is often referred to as the parent class and the derived
    class, subclass. Inheritance is a powerful feature, and some programs can be written
    much more easily and concisely, providing the possibility to customize the behavior
    of a class without modifying the original class. The very fact that the inheritance
    structure can reflect that of the problem can, in some cases, make the program
    easier to understand.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类通常被称为父类，而派生类被称为子类。继承是一个强大的特性，某些程序可以编写得更加容易和简洁，提供了在不修改原始类的情况下自定义类行为的可能性。实际上，继承结构能够反映问题的结构，在某些情况下，可以使程序更容易理解。
- en: However (to put the user on guard!), inheritance can make it more difficult
    to read the program. This is because, when invoking a method, it is not always
    clear where this has been defined within the code that must be traced within multiple
    modules, instead of being in a single well-defined place.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而（为了提醒用户注意！），继承可能会使程序更难阅读。这是因为，在调用方法时，并不总是清楚这个方法是在代码的哪个地方定义的，而这个代码需要在多个模块中追踪，而不是在一个定义良好的地方。
- en: Many of the things that can be done with inheritance can usually be managed
    elegantly even without it, so it is appropriate to only use inheritance if the
    structure of the problem requires it. If used at the wrong time, then the harm
    inheritance can cause can outweigh the benefits of using it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，可以使用继承完成的事情，即使没有它也可以优雅地管理，因此只有在问题的结构需要时才应该使用继承。如果使用不当，那么继承可能造成的危害可能会超过使用它的好处。
- en: Thread synchronization with a lock
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用锁进行线程同步
- en: The `threading` module also includes a simple lock mechanism, which allows us
    to implement synchronization between threads.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`threading`模块还包括一个简单的锁机制，这允许我们在线程之间实现同步。'
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: A *lock* is nothing more than an object that is typically accessible by multiple
    threads, which a thread must possess before it can proceed to the execution of
    a protected section of a program. These locks are created by executing the `Lock()`
    method, which is defined in the `threading` module.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the lock has been created, we can use two methods that allow us to synchronize
    the execution of two (or more) threads: the `acquire()` method to acquire the
    lock control, and the `release()` method to release it.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: The `acquire()` method accepts an optional parameter that, if not specified
    or set to `True`, forces the thread to suspend its execution until the lock is
    released and can then be acquired. If, on the other hand, the `acquire()` method
    is executed with an argument equal to `False`, then it immediately returns a Boolean
    result, which is `True` if the lock has been acquired, or `False` otherwise.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we show the lock mechanism by modifying the code introduced
    in the previous recipe, *Defining a thread subclass*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps involved are as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following code block, the `MyThreadClass` class has been modified,
    introducing the `acquire()` and `release()` methods within the **`run`** method,
    while the `Lock()` definition is outside the definition of the class itself:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `main()` function has not changed with respect to the previous code sample:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have modified the code of the previous section by using a lock so that the
    threads will be executed in sequence.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The first thread acquires the lock and performs its task while the other eight
    remain *on hold.* At the end of the execution of the first thread, that is, when
    the `release()` method is executed, the second one will get the lock and the threads
    from three to eight will still be waiting until the end of the execution (that
    is, once again, only after running the `release()` method).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'The *lock-acquire* and *lock-release* execution are repeated until the ninth
    thread, with the final result that as a result of the lock mechanism, this execution
    takes place in a sequential mode, as can be seen in the following output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There's more...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The insertion points of the `acquire()` and `release()` methods determine the
    entire execution of the code. For this reason, it is very important that you take
    the time to analyze what threads you want to use and how you want to synchronize
    them.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can change the insertion point of the `release()` method in
    the `MyThreadClass` class like so:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this case, the output changes quite significantly:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, only the thread creation happens in sequential mode. Once thread
    creation is complete, the new thread acquires the lock, while the previous one
    continues the computation in the background.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Thread synchronization with RLock
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A reentrant lock, or simply an RLock, is a synchronization primitive that can
    be acquired multiple times by the same thread.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: It uses the concept of the proprietary thread. This means that in the *locked
    state*, some threads own the lock, while in the *unlocked state*, the lock is
    not owned by any thread.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The next example demonstrates how to manage threads through the `RLock()` mechanism.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An RLock is implemented through the `threading.RLock()` class. It provides the
    `acquire()` and `release()` methods that have the same syntax as the `threading.Lock()`
    class.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: An `RLock` block can be acquired multiple times by the same thread. Other threads
    will not be able to acquire the `RLock` block until the thread that owns it has
    made a `release()` call for every previous `acquire()` call. Indeed, the `RLock`
    block must be released, but only by the thread that acquired it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps involved are as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'We introduced the `Box` class, which provides the `add()` and `remove()` methods
    that access the `execute()` method in order to perform the action to add or delete
    an item, respectively. Access to the `execute()` method is regulated by `RLock()`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following functions are called by the two threads. They have the `box` class and
    the total number of `items` to add or to remove as parameters:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, the total number of items to add or to remove from the box is set. As
    you can see, these two numbers will be different. The execution ends when both
    the `adder` and `remover` methods accomplish their tasks:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `main` program, the two threads of `t1` and `t2` have been associated
    with the `adder()` and `remover()` functions. The functions are active if the
    number of items is greater than zero.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'The call to `RLock()` is carried out inside the `__init__` method of the **`Box`**
    class:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The two `adder()` and `remover()` functions interact with the items of the `Box`
    class, respectively, and call the `Box` class methods of `add()` and `remove()`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: In each method call, a resource is captured and then released using the `lock`
    parameter that is set in the `_init_` method.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There's more...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The differences between *lock* and *RLock* are as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: A *lock* can only be acquired once before it must be released. However, `RLock`
    can be acquired multiple times from the same thread; it must be released the same
    number of times in order to be released.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another difference is that an acquired lock can be released by any thread, whereas
    an acquired `RLock` can only be released by the thread that acquired it.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread synchronization with semaphores
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **semaphore** is an abstract data type managed by the OS to synchronize access
    by multiple threads to shared resources and data. It consists of an internal variable
    that identifies the amount of concurrent access to a resource with which it is
    associated.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The operation of a semaphore is based on two functions: `acquire()` and `release()`,
    as explained here:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a thread wants to access a given or a resource that is associated with
    a semaphore, it must invoke the `acquire()` operation, which *decreases the internal
    variable of the semaphore* and allows access to the resource if the value of this
    variable appears to be non-negative. If the value is negative, then the thread
    will be suspended and the release of the resource by another thread will be placed
    on hold.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having finished using shared resources, the thread frees resources through the
    `release()` instruction. In this way, the internal variable of the semaphore is
    increased, allowing, for a *waiting* thread (if any), the opportunity to access
    the newly freed resource.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The semaphore is one of the oldest synchronization primitives in the history
    of computer science, invented by the early Dutch computer scientist Edsger W.
    Dijkstra.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The following example shows how to synchronize threads through a semaphore.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following code describes a problem where we have two threads, `producer()`
    and `consumer()`, that share a common resource, which is the item. The task of
    `producer()` is to generate the item while the `consumer()` thread's task is to
    use the item that has been produced.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'If the item has not yet produced the `consumer()` thread, then it has to wait.
    As soon as the item is produced, the `producer()` thread notifies the consumer
    that the resource should be used:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'By initializing a semaphore to `0`, we obtain a so-called semaphore event whose
    sole purpose is to synchronize the computation of two or more threads. Here, a
    thread must make use of data or common resources simultaneously:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This operation is very similar to that described in the lock mechanism of the
    lock. The `producer()` thread creates the item and, after that, it frees the resource
    by calling the `release()` method:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Similarly, the `consumer()` thread acquires the data by the `acquire()` method.
    If the semaphore''s counter is equal to `0`, then it blocks the condition''s `acquire()`
    method until it gets notified by a different thread. If the semaphore''s counter
    is greater than `0`, then it decrements the value. When the producer creates an
    item, it releases the semaphore, and then the consumer acquires it and consumes
    the shared resource:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The synchronization process that is done via the semaphores is shown in the
    following code block:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The data acquired is then printed on the standard output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is the result that we get after 10 runs:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There's more...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A particular use of semaphores is the *mutex*. A mutex is nothing but a semaphore
    with an internal variable initialized to the value of `1`, which allows the realization
    of mutual exclusion in access to data and resources.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Semaphores are still commonly used in programming languages that are multithreaded;
    however, they have two major problems, which we have discussed, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: They do not prevent the possibility of a thread performing more wait operations
    on the same semaphore. It is very easy to forget to do all the necessary signals
    in relation to the number of waits performed.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can run into situations of deadlock. For example, a deadlock situation is
    created when the `t1` thread executes a wait on the `s1` semaphore, while the
    **`t2`** thread executes a wait on the thread `t1`, executes a wait on `s2` and
    `t2`, and then executes a wait on `s1`.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread synchronization with a condition
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *condition* identifies a change of state in the application. It is a synchronization
    mechanism where a thread waits for a specific condition and another thread notifies
    that this *condition has taken place*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Once the condition takes place, the thread *acquires* the lock in order to get
    *exclusive access* to the shared resource.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good way to illustrate this mechanism is by looking again at a producer/consumer
    problem. The class producer writes to a buffer if it is not full, and the class
    consumer takes the data from the buffer (eliminating them from the latter) if
    the buffer is full. The class producer will notify the consumer that the buffer
    is not empty, while the consumer will report to the producer that the buffer is
    not full.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps involved are as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'The class consumer acquires the shared resource that is modelled through the **`items[]`** list:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the length of the list is equal to `0`, then the consumer is placed in a
    waiting state:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then it makes a **`pop`** operation from the items list:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So, the consumer''s state is notified to the producer and the shared resource
    is released:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The class producer acquires the shared resource and then it verifies that the
    list is completely full (in our example, we place the maximum number of items,
    `10`, that can be contained in the items list). If the list is full, then the
    producer is placed in the wait state until the list is consumed:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If the list is not full, then a single item is added. The state is notified
    and the resource is released:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To show you the condition mechanism, we will use the *consumer/producer* model again:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`producer` generates the item and stores it in the buffer continuously. At
    the same time, `consumer` uses the data produced, removing it from the buffer
    from time to time.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: As soon as `consumer` has picked up an object from the buffer, it will wake
    up `producer`, who will start to fill the buffer again.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, `consumer` will suspend if the buffer is empty. As soon as `producer`
    has downloaded the data into the buffer, `consumer` will wake up.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, even in this case, the use of the `condition` directive allows
    the threads to be properly synchronized.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'The result that we get after a single run is as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There's more...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s interesting to see the Python internals for the condition synchronization
    mechanism. The internal `class _Condition` creates an `RLock()` object if no existing
    lock has been passed to the class''s constructor. Also, the lock will be managed
    when `acquire()` and `released()` are called:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Thread synchronization with an event
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An event is an object that is used for communication between threads. A thread
    waits for a signal while another thread outputs it. Basically, an `event` object
    manages an internal flag that can be set to `false` with `clear()`, set to `true`
    with `set()`, and tested with `is_set()`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: A thread can hold a signal by means of the `wait()` method, which sends the
    call with the `set()` method.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand thread synchronization through the `event` object, let's take
    a look at the producer/consumer problem.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, to explain how to synchronize threads through events, we will refer to
    the *producer/consumer* problem. The problem describes two processes, a producer
    and a consumer, who share a common buffer of a fixed size. The producer's task
    is to generate items and deposit them in the continuous buffer. At the same time,
    the consumer will use the items produced, removing them from the buffer from time
    to time.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: The problem is to ensure that the producer does not process new data if the
    buffer is full and that the consumer does not look for data if the buffer is empty.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how to implement the consumer/producer problem by using thread
    synchronization with an `event` statement:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the relevant libraries are imported as follows:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, we define the log output format. It is useful to clearly visualize what''s
    happening:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Set the `items` list. This parameter will be used by the `Consumer` and `Producer`
    classes:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `event` parameter is defined as follows. This parameter will be used to
    synchronize the communication between threads:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `Consumer` class is initialized with the list of items and the `Event()`
    function. In the `run` method, the consumer waits for a new item to consume. When
    the item arrives, it is popped from the `item` list:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `Producer` class is initialized with the list of items and the `Event()`
    function. Unlike the example with `condition` objects, the item list is not global,
    but it is passed as a parameter:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the `run` method for each item that is created, the `Producer` class appends
    it to the list of items and then notifies the event:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'There are two steps that you need to take for this and the first step, which
    are as follows:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `t1` thread appends a value to the list and then sets the event to notify
    the consumer. The consumer''s call to `wait()` stops blocking and the integer
    is retrieved from the list:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the operations between the `Producer` and the `Consumer` classes can be
    easily resumed with the help of the following schema:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/915fcac0-899f-465a-9fd2-ce18a24bb0f0.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: Thread synchronization with event objects
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, the `Producer` and the `Consumer` classes have the following
    behavior:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '`Producer` acquires a lock, adds an item to the queue, and notifies this event
    to `Consumer` (`set event`). It then sleeps until it receives a new item to add.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Consumer` acquires a block and then begins to listen to the elements in a
    continuous cycle. The moment the event arrives, the consumer abandons the block,
    thus allowing other producers/consumers to enter and acquire the block. If `Consumer`
    is reactivated, then it reacquires the lock by safely processing new items from
    the queue:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Thread synchronization with a barrier
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, an application can be divided into phases with the rule that no
    process can continue if first, all threads of the process have completed their
    own task. A **barrier** implements this concept: a thread that has finished its
    phase calls a primitive barrier and stops. When all the threads involved have
    finished their stage of execution and have also invoked the primitive barrier,
    the system unlocks them all, allowing threads to move to a later stage.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python's threading module implements barriers through the **`Barrier`** class. In
    the next section, let's learn about how to use this synchronization mechanism
    in a very simple example.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we simulate a run with three participants, `Huey`, `Dewey`,
    and `Louie`, in which a barrier is assimilated to that of a finish line.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the race can end on its own when all three participants cross the
    finish line.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'The barrier is implemented through the `Barrier` class, in which the number
    of threads to be completed must be specified as an argument to move to the next
    stage:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we set the number of runners to `num_runners = 3` in order to set the
    final goal on the next line through the `Barrier` directive. The runners are set
    in the runners' list; each of them will have an arrival time that is determined
    in the `runner` function, using the `randrange` directive.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'When a runner arrives at the finish line, call the `wait` method, which will
    block all the runners (the threads) that have made that call. The output for this
    is as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this case, `Dewey` won the race.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Thread communication using a queue
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multithreading can be complicated when threads need to share data or resources.
    Luckily, the threading module provides many synchronization primitives, including
    semaphores, condition variables, events, and locks.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: However, it is considered a best practice to use the `queue` module. In fact,
    a queue is much easier to deal with and makes threaded programming considerably
    safer, as it effectively funnels all access to a resource of a single thread and
    allows for a cleaner and more readable design pattern.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will simply consider these queue methods:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '`put()`: Puts an item in the queue'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get()`: Removes and returns an item from the queue'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`task_done()`: Needs to be called each time an item has been processed'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`join()`: Blocks until all items have been processed'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we will see how to use the `threading` module with the `queue`
    module. Also, we have two entities here that try to share a common resource, a
    queue. The code is as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, with the `producer` class, we don't need to pass the integers list because
    we use the queue to store the integers that are generated.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: The thread in the `producer` class generates integers and puts them in the queue
    in a `for` loop. The `producer` class uses `Queue.put(item[, block[, timeout]])`
    to insert data in the queue. It has the logic to acquire the lock before inserting
    data in a queue.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two possibilities:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: If the optional arguments `block` is `true` and `timeout` is `None` (this is
    the default case that we used in the example), then it is necessary for us to
    block until a free slot is available. If the timeout is a positive number, then
    it blocks at most timeout seconds and raises the full exception if no free slot
    is available within that time.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the block is `false`, then put an item in the queue if a free slot is immediately
    available, otherwise, raise the full exception (timeout is ignored in this case).
    Here, `put` checks whether the queue is full and then calls `wait` internally,
    after which, the producer starts waiting.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next is the `consumer` class. The thread gets the integer from the queue and
    indicates that it is done working on it by using `task_done`. The `consumer` class
    uses `Queue.get([block[, timeout]])` and acquires the lock before removing data
    from the queue. The consumer is placed in a waiting state, in case the queue is
    empty. Finally, in the `main` function, we create four threads, one for the `producer`
    class and three for the `consumer` class, respectively.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'The output should be like this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There's more...
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the operations between the `producer` class and the `consumer` class can
    easily be resumed with the following schema:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb11a94d-258a-485f-a1b4-8954a860b41a.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
- en: Thread synchronization with the queue module
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: The `Producer` thread acquires the lock and then inserts data in the **QUEUE**
    data structure.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Consumer` threads get the integers from the **QUEUE**. These threads acquire
    the lock before removing data from the **QUEUE**.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the **QUEUE** is empty, then the `consumer` threads get in a **waiting**
    state.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: With this recipe, the chapter dedicated to thread-based parallelism comes to
    an end.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
