# 第十章：文件、数据库、网络和上下文

文件和文件系统是现代操作系统工作方式的核心。许多操作系统资源都作为文件系统的一部分可见。例如，Linux 的`/dev/mem`是处理器内存的视图，作为文件系统中可见的设备实现。Python 提供了映射到这些操作系统特性的文件对象。

在基本层面上，操作系统文件仅仅是字节集合。在实践中，我们经常处理的是由 Unicode 字符组成的文件集合。Python 提供了这两种文件视图。对于某些文件格式，我们需要处理字节。对于文本文件，我们期望 Python 能够正确地将 Unicode 字符从字节中解码出来。

Python 文件对象通常与操作系统资源纠缠在一起。为了确保应用程序不会泄露操作系统资源，我们经常使用上下文管理器。这允许我们确保在 Python 文件关闭时释放操作系统资源。`with`语句提供了一种整洁的方式来使用上下文管理器分配和释放资源。

除了普通文件外，我们还将探讨 TCP/IP 套接字。`urllib`模块允许我们打开一个远程主机的套接字。套接字被用作文件来从远程主机读取数据。

文件有一个物理格式；除了最简单的格式外，所有格式都需要一个`library`模块来正确地读写内容。此外，在物理格式的约束下，数据逻辑布局可能会有所不同。例如，**逗号分隔值**（**CSV**）文件可能使用文件的第一行中的字段名来描述列的逻辑布局。

SQLite 数据库或`shelve`数据库依赖于一个（或多个）文件来使数据持久化。我们将简要地探讨依赖于文件的高级结构。

# 文件的基本概念

现代操作系统依赖于文件和设备驱动程序来提供各种服务和功能。磁盘驱动器上的字节只是文件的一种类型。

### 注意

由于许多存储设备使用或包含**固态硬盘**（**SSD**），从技术上来说，“磁盘”这个术语是一个误称；我们将使用过时的术语。

网络适配器是另一种类型的文件；在这种文件中，字节是连续可用的，而不是静止出现。除了磁盘和网络文件外，Linux 文件系统还包括`/dev`目录，它描述了给定计算机上的所有设备。这些设备包括串行端口、内存引用，甚至一个累积熵池以提供随机字节的设备。

Python 文件对象封装了一个操作系统文件。`open()`函数将 Python 文件对象绑定到操作系统文件。除了名称外，该函数还期望一个用于访问的模式字符串。模式字符串结合了两个功能：

+   **字符与字节**：默认情况下，文件以文本模式打开；我们可以通过使用`t`来明确这一点。在读取时，操作系统字节被解码以创建 Unicode 字符。在写入时，Unicode 字符被编码成字节。要使用字节而不是文本，我们在模式中包含`b`；不会进行编码或解码。

+   **允许的操作**：默认情况下，文件以`r`模式打开，仅允许读取。我们可以以`w`模式打开文件，这将删除任何先前内容并仅允许写入。我们可以以`a`模式打开文件，这将搜索到先前内容的末尾，以便可以附加新内容。`+`修饰符允许读写；这意味着`w+`将删除任何先前内容并允许读写；`r+`将保留先前内容并允许读写。

当我们打开一个文本文件时，我们提供明确的编码。在某些情况下，需要明确编码，因为操作系统期望的编码不在文件中。

在某些情况下，我们可能还需要指定如何处理换行符。在输入时，我们很少需要指定行结束符：Python 通过将 Windows `\r\n`转换为`\n`来优雅地处理它们。然而，在输出时，我们可能需要明确提供行结束符。如果我们设置`newline=""`，则不会执行转换；我们需要这样做，以便可以创建具有`\r\n`行结束符的 CSV 文件。如果我们打开文件时设置`newline=None`，那么程序输出的`\n`将转换为`os.linesep`变量中的平台特定值。这是默认行为。`newline`的任何其他值都将替换输出中的`\n`字符。

我们可以指定缓冲区。我们还可以指定如何处理 Unicode 解码错误。有七个选项用于 Unicode 错误，包括`strict`、`ignore`、`replace`、`xmlcharrefreplace`、`backslashreplace`和`surrogateescape`。`strict`错误处理会引发异常。`ignore`错误处理会静默地丢弃非法字符。其他选项提供不同的替换策略。

## 打开文本文件

对于处理文本文件，以下是使用`open()`函数创建文件对象的方法：

```py
>>> my_file = open("Chapter_10/10letterwords.txt")
>>> text= my_file.read().splitlines()
>>> text[:5]
['consultive', 'syncopated', 'forestland', 'postmarked', 'configures']
```

我们已经使用所有默认设置打开了文件。模式将是只读。文件必须使用系统的默认编码（例如 Mac-Roman）。我们将依赖默认的缓冲区和默认的 Unicode 错误处理，即`strict`。

在这个例子中，我们将整个文件读入一个巨大的字符串，然后将该单个字符串拆分为一系列单独的行。我们将字符串列表分配给`text`变量。我们只显示了列表中的前五项。默认情况下，`split()`字符串方法不保留拆分字符。

## 过滤文本行

我们将在以下示例中查看两个关键概念。我们将首先打开一个使用`"utf-8"`编码的文件：

```py
>>> code_file = open("Chapter_1/ch01_ex1.py", "rt", encoding="utf-8", errors="replace")
>>> code_lines = list(code_file)
>>> code_lines[:5]
['#!/usr/bin/env python3\n', '"""Python Essentials\n', '\n',
'Chapter 1, Example Set 1\n', '\n']
```

我们以 `"rt"` 模式打开了一个文件，这意味着只读和文本模式。这是默认设置，所以可以省略。我们明确提供了 `"utf-8"` 编码，这并非操作系统默认编码。

我们使用 `list()` 函数将文件对象转换为行序列。当我们将文件对象用作可迭代对象时，我们会看到文件按行迭代。如果我们不更改文件的换行设置，则使用“通用换行”规则：`\n`、`\r` 或 `\r\n` 结束一行；它们被规范化为 `\n`。当我们按行处理文件时，行结束字符被保留。

我们通常希望从每行的末尾删除换行符。这是一种从原始行到去除尾随空白的行的映射。我们可以使用生成器表达式或 `map()` 函数以及 `str.rstrip()` 方法来实现。

在某些情况下，空行没有意义，可以删除。这也可以通过具有 `if` 子句以拒绝空行的生成器表达式来完成。我们还可以使用 `filter()` 函数来完成。如果我们将这些映射和过滤操作写成两行，会更简单，如下所示：

```py
>>> txt_stripped = (line.rstrip() for line in code_file)
>>> txt_non_empty= (line for line in txt_stripped if line)
>>> code_lines= list(txt_non_empty)
```

我们将输入清理分解为两个生成器表达式。第一个生成器表达式 `txt_stripped` 将原始行映射到去除尾随空白的行。第二个生成器表达式 `txt_non_empty` 是一个过滤器，它会拒绝空行。我们很容易在 `if` 子句中添加其他过滤条件。由于生成器表达式是惰性的，直到最终的 `list()` 函数消耗了所有生成器中的行，实际上并没有做什么。

以这种方式，我们可以设计相当复杂的文件解析，作为生成器表达式集合。我们可以应用一系列映射和过滤操作，使得主语句块中只有干净的数据。

## 处理原始字节

这是我们打开文件并查看原始字节的方法：

```py
>>> raw_bytes = open("Chapter_10/favicon.ico", "rb" )
>>> data = raw_bytes.read()
>>> len(data)
894
>>> data[:22]
b'\x00\x00\x01\x00\x01\x00\x10\x10\x00\x00\x00\x00\x18\x00h\x03\x00\x00\x16\x00\x00\x00'
```

我们以二进制模式打开了此文件。我们得到的输入将是 `bytes` 而不是 `str`。由于 `bytes` 对象具有许多与 `str` 对象相似的功能，我们可以对这些字节进行大量的字符串处理。我们已经从文件中导出了前 22 个字节。字节以十六进制值和 ASCII 字符的混合形式显示。

我们需要查看 ICO 文件格式的描述，以了解字节的意义。有关背景信息，请参阅[`en.wikipedia.org/wiki/ICO_(file_format)`](http://en.wikipedia.org/wiki/ICO_(file_format))。

解码此字节块的最简单方法是使用 `struct` 模块。我们可以执行以下操作来解析文件头和文件第一个图像的头。

```py
>>> import struct
>>> struct.unpack( "<hhhbbbbhhii", data[:22] )
(0, 1, 1, 16, 16, 0, 0, 0, 24, 872, 22)
```

`unpack()` 函数需要一个格式，该格式指定了对字节流执行的不同类型的转换。在这种情况下，格式包含三个用于字节组的代码：`h` 表示双字节半字，`b` 表示单字节，而 `i` 表示四字节整数。字节被组装成数值，结果结构是一个包含适当 Python `int` 值的元组。格式中的前导 `<` 指定整数转换使用 **小端字节序**。

## 使用文件类似对象

由于 Python 中对象的工作方式，任何提供类似 `file` 类接口的对象都可以用来代替文件。这导致了“文件类似对象”这个术语。我们可以使用文件对象，或者任何其他设计为像文件一样工作的对象。例如，`io` 模块有 `StringIO` 类，它允许我们像处理文件内容一样处理字符串。

我们经常使用它来创建测试数据。请注意，`io.StringIO` 对象与一个打开的文件非常相似。当我们考虑为可测试性进行设计——即 第十四章 的主题，“完善——单元测试、打包和文档”——我们需要设计函数以与文件对象一起工作，而不是与文件名一起工作。

这是一个将简单模式匹配应用于文件行以产生从复杂文本行中提取的数值的函数。有关正则表达式的更多信息，请参阅 第三章，“表达式和输出”。

此函数使用一个模式来过滤文件或文件类似对象的行：

```py
import re
def tests_run(log_file):
    data_pat = re.compile(r"\s*([\w ]+):\s+(\d+\.?\d*)\s*")
    for line in log_file:
        match= data_pat.findall(line)
        if match:
            yield match
```

我们定义了一个生成器函数，该函数将日志文件减少到与给定模式匹配的几行。我们使用了 `re` 模块来定义一个模式 `data_pat`，该模式查找一个单词字符串 (`[\w ]+`)，一个冒号字符，以及一个可能是整数或浮点数的数字 (`\d+\.?\d*`)。`data_pat.findall(line)` 表达式将在给定行中定位所有这些 *单词：数字* 对。对于每行匹配项，将生成一个匹配结果列表。

匹配结果是字符串。我们需要应用额外的函数来将结果中的数字组从字符串转换为正确的数字。

在定义我们的函数时使用文件名很重要；函数不会打开文件。打开文件的函数稍微难以测试。相反，我们定义了 `tests_run()` 函数以使用任何文件类似对象。这允许我们编写如下单元测试：

```py
>>> import io
>>> data = io.StringIO(
... '''
... Tests run: 1, Failures: 2, Errors: 0, Skipped: 1, Time elapsed: 0.547 sec
... Other data
... Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.018 sec
... ''')
>>> list( tests_run(data) )
[[('Tests run', '1'), ('Failures', '2'), ('Errors', '0'), ('Skipped', '1'), ('Time elapsed', '0.547')],
[('Tests run', '1'), ('Failures', '0'), ('Errors', '0'), ('Skipped', '0'), ('Time elapsed', '0.018')]]
```

我们已经导入了`io`模块，以便我们可以创建一个包含模拟输入的`io.StringIO`对象。我们可以将这个类似文件的对象提供给`tests_run()`函数。由于`StringIO`的行为类似于文件，我们可以用它来代替实际文件来测试我们的函数，以确保它正确地定位了`Tests run`行并忽略了其他行。我们将在第十四章中查看单元测试，*完善 - 单元测试、打包和文档*。

# 通过`with`语句使用上下文管理器

Python 的文件对象通常与操作系统资源纠缠在一起。当我们完成文件的使用时，我们需要确保文件被正确关闭，以便操作系统资源可以被释放。对于小型命令行应用程序，这个考虑并不是那么重要：当我们从 Python 退出时，并且所有对象的引用计数都减少到零，文件将在对象删除处理过程中关闭。

然而，对于大型、长时间运行的服务器，未正确关闭的文件将积累操作系统资源。由于操作系统资源的池是有限的，文件句柄泄露最终将导致问题。

作为一般实践，我们可以使用上下文管理器来确保在完成使用文件后文件被关闭。想法是将一个打开的文件约束在上下文管理器内的语句集中。一旦这个语句集完成，上下文管理器将确保文件被关闭。

我们使用`with`语句来指定上下文。文件对象是一个上下文管理器；`with`语句使用文件作为管理器。在`with`语句结束时，上下文管理器将退出，文件将被关闭。一些更复杂的文件结构也是上下文管理器。例如，`zipfile`模块中定义的`ZipFile`对象是一个合适的上下文管理器；当在`with`语句中使用时，文件将被整洁地关闭。

应该将所有文件输入输出处理都包裹在`with`语句中，以确保文件被正确关闭，这是一个最佳实践。以下是我们如何使用（前面展示的）`tests_run()`函数（作为一个上下文管理器的例子）的示例：

```py
file_in= "Chapter_10/log_example.txt"
file_out= "Chapter_10/summary.txt"
with open(file_in) as source, open(file_out, "w") as target:
    for stats in tests_run(source):
        print(stats, file=target)
```

我们已经打开了两个文件作为上下文管理器。用于读取的文件`"Chapter_10/log_example.txt"`被分配给`source`变量。用于写入的文件`"Chapter_10/summary.txt"`被分配给`target`变量。然后我们可以处理这些文件，知道它们将正确关闭。

如果发生异常，文件将被关闭。这非常重要。如果`with`语句内部的语句组中发生异常，每个上下文管理器都会收到通知。在这种情况下，这两个管理器都是文件对象。每个对象都会看到异常并关闭文件——释放所有操作系统资源——并允许异常处理继续。我们的应用程序将因异常而崩溃，但文件也将正确关闭。

### 小贴士

总是使用`with`语句包装文件处理。

## 使用 contextlib 关闭文件类似对象

在某些情况下，我们想确保我们的应用程序关闭一个没有实现上下文管理器方法的文件类似对象。例如，`http.client`模块将创建一个`HTTPConnection`对象，该对象可能与网络资源纠缠在一起。我们希望确保在完成使用连接对象后释放任何网络资源。然而，由于此对象不是合适的上下文管理器，当在`with`语句中使用时，它不会自动关闭。

事实上，尝试在`with`语句中使用`HTTPConnection`对象作为上下文管理器将引发`AttributeError`异常。这个错误将显示`HTTPConnection`对象没有实现作为上下文管理器所需的方法。

我们可以利用`contextlib`模块中的通用上下文管理器。`contextlib.closing()`函数将包装任何具有`close()`方法的对象，并添加所需的特殊方法，使包装的对象成为一个上下文管理器。

一个 RESTful 网络服务请求可能看起来像这样：

```py
import contextlib
import http.client
with contextlib.closing(
  http.client.HTTPConnection("www.example.com")) as host:
    host.request("GET", "/path/to/resources/12345/")
    response= host.getresponse()
    print(response.read())
```

我们对向网络服务发送 GET 请求感兴趣。`http.client.HTTPConnection`对象不是上下文管理器；如果没有异常发生，无法保证它会被关闭。通过使用`contextlib.closing()`函数包装它，我们使其成为一个合适的上下文管理器。我们可以发送请求并处理响应，同时知道`HTTPConnection`对象将正确调用其`close()`方法。

# 将 shelve 模块用作数据库

文件为我们提供了持久存储。文件简单使用的局限性在于数据必须按顺序访问。我们如何以任意顺序访问项目？

我们将使用“数据库”一词来指代一个文件（一组文件），我们将在其中以任意顺序对数据元素执行**创建、检索、更新和删除**（**CRUD**）操作。如果我们创建大小一致的对象，我们可以在`r+`模式下打开一个普通文本文件，并使用`seek()`方法定位到任何特定记录的开始。然而，这相当复杂，我们可以做得更好。

核心数据库概念——可读和可写存储——可以通过看似无穷无尽的辅助功能进行扩展。现在，我们将忽略锁定、日志记录、审计、日志记录、分布式事务管理以及许多其他功能，以专注于持久化的核心功能。

`shelve`模块为我们提供了一个非常灵活的数据库。书架对象的行为类似于一个普通的 Python 映射，并且具有内容持久化的附加功能。一个额外的约束是，用于书架的键必须是字符串。

通常，我们使用多部分字符串作为书架键，这样我们就可以包含一些类信息以及类的实例的唯一标识符。我们可以使用简单的`class:id`格式来包含类名和对象的标识值，作为书架的复合键。

下面是一个创建将键映射到值列表的书架的示例。在这个例子中，输入文件有一系列单词，还有一些空白行和一个我们想要忽略的尾随行。书架的键是单词的首字母。与每个键关联的值是与该共同首字母共享的单词列表。

下面是整个函数：

```py
import contextlib
import shelve
def populate():
    with contextlib.closing(
      shelve.open("Chapter_10/shelf","n")) as shelf:
        with open("Chapter_10/10letterwords.txt") as source:
            txt_stripped= (l.strip() for l in source)
            txt_non_empty= (l for l in txt_stripped
                            if l and not l.startswith("Tool") )
            for word in txt_non_empty:
                key = "word_list:{0}".format(word[0])
                try:
                    word_list= shelf[key]
                except KeyError:
                    word_list= []
                word_list.append(word)
                shelf[key]= word_list
```

我们使用`shelve.open()`打开了书架对象。`"n"`模式会在每次应用程序运行时创建一个新的、空的书架文件。由于书架不是一个合适的上下文管理器，我们需要用`contextlib.closing()`函数将其包装。

`shelve`模块依赖于特定平台的数据库模块。这可能会导致需要一个或多个底层文件来支持书架。我们提供了一个基本文件名为`"Chapter_10/shelf"`。根据我们使用的操作系统，可能会创建一个`.dat`或`.db`文件。

`for`循环遍历由`txt_non_empty`表达式生成的输入单词序列。套件首先构建一个两部分的键。第一部分是字符串`word_list`；这显然不是 Python 数据类，但它作为数据含义的总结。在冒号之后，我们放上了单词的第一个字符。

我们获取与该键关联的当前单词列表。如果没有这样的键在书架中，我们通过创建一个新的、空列表来处理`KeyError`异常。一旦我们有一个列表——无论是新的还是从书架中检索的——我们就可以通过追加我们的新单词来更新列表。然后我们将单词列表保存在书架中。

要查询以特定首字母开头的单词，我们可以使用`shelf["word_list:"+letter]`。我们需要创建一个完整的键字符串，包括一个分类器，这样我们就有了一个包含多个集合的书架。

为了检索和总结数据，我们使用基于这个生成器表达式的简单循环：

```py
sorted(k for k in shelf.keys() if k.startswith("word_list:"))
```

这将只选择来自书架数据库中的`word_list`集合的键。在一个更复杂的数据库中，可能有其他带有其他键前缀的集合。

## 使用 sqlite 数据库

`sqlite`模块为我们提供了一个基于 SQL 的数据库。利用 SQL 的应用程序在原则上是可以移植的。我们应该能够在不大幅修改我们的 Python 应用程序的情况下，使用 MySQL 或 PostgreSQL 作为我们的数据库而不是 SQLite。

虽然有几种适用于 SQL 的标准，但每个实现似乎都存在自己特有的问题。因此，基于 SQL 的应用程序很少能够在数据库平台之间完美移植。

SQL 数据库需要一个正式的模式定义。这意味着 SQL 应用程序必须始终包含创建或确认模式的一些规定。就像前面的例子一样，我们将与一个只有一个表且有两个列的数据库一起工作：一个非唯一键，它是单词的首字母，以及具有该首字母的单词。

这是 SQL 中的表定义：

```py
CREATE TABLE IF NOT EXISTS word(
    letter VARCHAR(1),
    word VARCHAR(10),
    PRIMARY KEY (letter))
```

这定义了一个有两个列的表，`letter`和`word`。要找到所有具有共同首字母的单词，我们需要从该表中检索多行。这是一种常见的 SQL 设计。它并不完全符合 Python 的面向对象设计，这是使用 SQL 时的一个常见限制。

我们需要执行 SQL `CREATE TABLE`语句来在 SQLite 数据库中创建（或确认）表。以下是一个将建立（或确认）模式的函数：

```py
def schema():
    with SQL.connect("Chapter_10/sqlite.sdb") as db:
        db.execute( """CREATE TABLE IF NOT EXISTS word(
                   letter VARCHAR(1),
                   word VARCHAR(10),
                   PRIMARY KEY (letter))
                   """)
```

重要的语句是 SQLite 连接对象的`execute()`方法。我们提供了一个三引号字符串的 SQL。如果出现问题，将引发异常。

这是一个函数，它将从文本文件加载数据到这个表中：

```py
def populate():
    with SQL.connect("Chapter_10/sqlite.sdb") as db:
        db.execute( """DELETE FROM word""" )
        with open("Chapter_10/10letterwords.txt") as source:
            txt_stripped= (l.strip() for l in source)
            txt_non_empty= (l for l in txt_stripped
                            if l and not l.startswith("Tool") )
            for word in txt_non_empty:
                db.execute( """INSERT INTO WORD(letter, word)
                           VALUES (:1, :2)""", (word[0], word) )
```

注意，我们首先从`word`表中删除所有行。这类似于我们之前的例子，通过创建一个全新的空`shelve`数据库来工作。创建空 SQL 数据库可能会有很高的开销；此示例期望有一个已建立的数据库，其中已经定义了表，并从定义的表中删除行。

与前面的例子一样，我们使用了两个生成器表达式来从输入文件中过滤掉这些垃圾行。循环遍历由`no_summary`表达式生成的单词。该代码块执行一个 SQL `INSERT`语句，为表中的`letter`和`word`列绑定两个值。这个语句在我们的数据库中为单词表创建了一个新行。

要查看以给定字母开头的单词计数，我们可以使用 SQL 聚合。我们将执行以下`SELECT`语句。

```py
SELECT letter, COUNT(*) FROM word GROUP BY letter
```

当我们执行这个操作时，我们得到一个 SQL 迭代器（称为“游标”），它根据`SELECT`子句产生一系列二元组。每个元组将包含字母和共享该字母的单词数量。我们可以使用这个来显示具有给定首字母的单词计数的摘要。

## 使用对象关系映射

许多流行的 SQL 数据库提供了 Python 驱动程序。有些比其他的有更好的支持级别。当与 SQL 数据库一起工作时，有时很难找到有效且可移植的 SQL 语法。一个数据库上的特性可能在另一个数据库上成为问题。

更重要的是，然而，SQL 表的完全扁平的列-行结构与面向对象语言如 Python 中更复杂的类定义的要求之间存在不匹配。这种阻抗不匹配通常通过**对象关系映射**（**ORM**）包来解决。两个流行的包是 SQLAlchemy 或 SQLObject。

这些包帮助将复杂对象映射到简单的 SQL 表。它还通过将特定 SQL 数据库的细节与应用程序编程分离来提供帮助。

不使用 SQL 的数据库，如`shelve`、MongoDB、CouchDB 和其他 NoSQL 数据库，没有 SQL 数据库所具有的相同的对象关系阻抗不匹配问题。我们在持久化技术方面有很多选择；Python 可以与各种数据库一起使用。

# 互联网服务和互联网协议

正如我们之前提到的，许多 TCP/IP 协议，如 HTTP，依赖于套接字抽象。套接字被设计成类似文件：我们可以使用普通的文件操作来读取或写入套接字。在非常低级的情况下，我们可以使用 Python 的`socket`模块。我们可以创建、读取和写入套接字来连接客户端和服务器程序。

然而，我们不会直接与套接字工作，而是会使用更高级的模块，例如`urllib`和`http.client`。这些模块为我们提供了 HTTP 协议的客户端操作，使我们能够连接到 Web 服务器，发出请求，并获取回复。我们在之前的*使用 contextlib 关闭文件类似对象*部分简要介绍了`http.client`模块。

要实现服务器，我们可以使用`http.server`。然而，在实践中，我们通常会利用前端应用程序，如 Apache HTTPD 或 NGINX，来提供网站的静态内容。对于动态内容，我们通常会使用 WSGI 网关将前端传递到 Python 框架的 Web 请求。有几个 Python 网络服务器框架，每个框架都有各种功能、优势和劣势。

# 物理格式考虑

Python 库为我们提供了许多模块来帮助处理常见的物理文件格式。《Python 标准库》的第十三章*文件格式*描述了文件压缩和归档；这包括处理使用 zip 或 BZip2 压缩的文件的模块。第十四章*加密服务*描述了处理 CSV、配置文件和 PLIST 文件等文件格式的模块。第十九章*结构化标记处理工具*描述了互联网数据处理，其中包括 JSON 文件格式。第二十章*互联网协议和支持*描述了处理 HTML 和 XML 等标记语言的模块。对于不是标准库一部分的模块，**Python 包索引**（**PyPI**）可能有处理文件格式的包。请参阅[`pypi.python.org`](http://pypi.python.org)。

我们将快速查看 CSV 模块，因为它在处理“大数据”问题时经常被使用。例如，Apache Hadoop 软件库——一个允许分布式处理大数据集的框架——利用简单的编程模型。我们可以使用 Python 与 Hadoop 流处理。

Hadoop 文件通常是 CSV 格式的文件。在某些情况下，它将使用 "`|`" 而不是逗号，并且不会使用引号或转义符。在其他情况下，可以使用 `\x01`（ASCII SOH）字符作为分隔符。这可以通过 Python CSV 模块相对简单地处理。

当我们从电子表格创建 CSV 文件时，第一行可能包含标题信息。这可能非常有帮助。`csv.DictReader()` 类使用 CSV 文件的第一个行作为标题。每一行剩余的内容将被转换为一个 `dict`。这个 `dict` 中的键将是第一行中的列名。

当与其他 CSV 文件一起工作时，可能不存在标题行。这意味着我们需要一个单独的模式定义来确定每个列的含义。在大多数情况下，我们可以简单地用一个列名列表或元组来表示模式。

我们可能有一行这样的内容来提供缺失的列名：

```py
TEST_LOG_SUMMARY = (
    "module", "datetime", "tests_run", "failures",
    "errors", "skipped", "time_elapsed",
)
```

这为我们提供了一个简单的元组，其中包含友好的 Python 列名。我们在元组项的末尾添加了一个多余的逗号，以便更容易添加新列而不会出现语法错误。一般来说，我们可以简单地将这个定义放入文件中并导入这个模式定义。

假设我们有一个名为 `log_parser()` 的函数，它可以解析一个复杂的日志文件以提取之前显示的字段。这个函数将使用正则表达式来定位日志中包含测试结果、模块名称和时间戳的行。日志数据将被用来构建一个简单的字典，其键由 `TEST_LOG_SUMMARY` 全局变量定义。解析器将返回一系列 `dict` 对象，其外观如下：

```py
{'module': 'com.mycompany.app.AppTest', 'errors': '0', 'time_elapsed': '0', 'failures': '0', 'datetime': 'Thu Oct 06 08:12:17 MDT 2005', 'tests_run': '1'}
```

我们可以使用这个 `log_parser()` 函数从日志中写入一个 CSV 摘要文件。我们将把这个函数称为 `mapper()`，因为它将文件名序列映射到数据行序列，同时保留相关细节：

```py
def mapper(name_iter, result):
    writer= csv.DictWriter(result, fieldnames=TEST_LOG_SUMMARY, delimiter='|')
    for name in name_iter:
        with open(name) as source:
            writer.writerow( log_parser(source) )
```

此函数期望两个参数：一个生成日志文件名的迭代器，以及一个打开的文件，结果将被写入其中。此函数将使用输出文件创建一个 CSV `DictWriter` 对象，包括每个将被写入的字典中的字段名集合，最后是一个分隔符。

对于每个名称，日志将被打开并解析。解析的结果 `dict` 将被写入 CSV 文件以总结处理过程。我们可能在类似这样的脚本中使用这个函数：

```py
mapper(glob.glob("Chapter_10/log_*.txt"), sys.stdout)
```

我们已经将输出写入到操作系统的标准输出。这允许我们将这些结果管道传输到另一个程序，该程序对日志摘要进行统计分析。我们可能会将统计摘要称为 reducer，因为它将大量值减少到单个结果。reducer 会共享`TEST_LOG_SUMMARY`变量，以确保两个程序对它们之间传递的文件内容达成一致。

# 摘要

在本章中，我们看到了如何使用 Python 异常来编写与各种文件类型一起工作的程序。我们专注于文本文件，因为它们易于处理。我们还研究了解析二进制文件，这通常需要`struct`模块的支持。

文件也是一个上下文管理器。最佳实践是使用`with`语句来使用文件，以确保文件被正确关闭，并且所有操作系统资源都被释放。在命令行程序中，这可能不是那么重要；在长时间运行的服务器中，确保资源不会因文件关闭不当而泄漏是绝对必要的。

我们还研究了更复杂的持久化机制，包括`shelve`模块和 SQLite 数据库。这些为我们提供了在文件中对数据对象执行 CRUD 操作的方法。SQLite 数据库要求我们使用 SQL 语言来描述数据访问：这可以使我们的程序更容易移植到其他数据库。同时使用 SQL 和 Python 可能会让人感到困惑。我们可以通过使用如 SQLAlchemy 这样的库来克服这个小问题，这样我们就可以完全在 Python 中工作，让 SQLAlchemy 来创建适合我们数据库的 SQL 语句。

标准库有多个包来处理不同的物理文件格式。其中之一可以帮助创建和检索 CSV 格式的数据。逗号分隔符的角色可以是任何字符序列，扩展了这个概念，使得许多类型的分隔文件都可以由这个模块读取或写入。

在第十一章，*类定义*中，我们将探讨如何在 Python 中定义我们自己的定制类。类定义是面向对象编程的核心。我们将简要介绍在 Python 编程中常见的几种类设计模式。
