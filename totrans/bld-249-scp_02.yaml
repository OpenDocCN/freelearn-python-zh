- en: Chapter 2. Creating and Editing Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a way, meshes are the most essential type of objects in a 3D application.
    They form the basis of most visible objects and are the raw material that might
    get rigged and animated further down the line. This chapter deals with the creation
    of meshes and with ways to manipulate a mesh object, both as a whole and as the
    individual entities it consists of—the vertices, edges, and faces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and Editing Objects](img/0400-02-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create configurable mesh objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to design a graphical user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make your script store user choices for later reuse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to select vertices and faces in a mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to parent an object to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to modify meshes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to run Blender from the command line and render in the background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to process command-line parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creepy crawlies—a GUI to configure objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instantiating a single copy of a one-off Blender object (like we did in the
    "hello world" example in [Chapter 1](ch01.html "Chapter 1. Extending Blender with
    Python"), *Extending Blender with Python*) might be a good programming exercise,
    but an object creation script really comes into its own when built-in methods
    such as copying objects, or modifiers such as the array modifier, are not sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: A good example is where we want to create one or many object variants and these
    variants need to be easy to configure for the end user. For example, nuts and
    bolts come in many shapes and sizes so Blender comes included with a script to
    create them. Many more scripts are available on the Web to create anything from
    mechanical gears to stairs, from trees to church domes.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we show how to build a small application that can create all
    sorts of bug-like creatures and comes with a simple but effective GUI to set the
    many configurable parameters. This application also stores the user preferences
    for later reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Building the user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Designing, building, and testing a graphical user interface can be a formidable
    task, but the Blender API provides us with tools to make this task a lot easier.
    The `Blender.Draw` module provides simple, but often used and easy to configure
    components to quickly put a user interface together. The `Blender.BGL` module
    gives access to all the nuts and bolts to design a graphical user interface from
    scratch. We will mostly use the former because it is almost everything we need
    but we give an example of the latter as well to design a simple error pop up.
    Our main user interface will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the user interface](img/0400-02-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When we invoke our script from the **Add** Menu (normally accessible from the
    menu bar at the top of the screen or by pressing the spacebar in the 3D view),
    the previous menu will pop up and the user can tweak the parameters to his or
    her liking. When the **OK** button is pressed the script generates an insect-like
    mesh. The pop up can also be exited by pressing *Esc,* in which case the script
    terminates without generating a mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Creating bugs—some assembly required
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our mission is to create simple creatures from a small sample of building blocks
    that may be chained together. The outline for our script is this:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the building blocks for our creatures.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw a user interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assemble the creature mesh from building blocks as defined by the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the mesh as an object into the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We go through the script step-by-step showing the relevant parts in detail.
    (The full script is available as `creepycrawlies.py`.) The first step involves
    creating body parts that are suitable for assembling together. This means we have
    to model these parts in Blender, defining suitable joints and marking those joints
    as vertex groups. Then we export these meshes as Python code by using a script
    that we encounter again in the next chapter as it deals with vertex groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we use this generated Python code simply as a module containing several
    lists of vertices defining each body part. We have to make sure that this module
    is somewhere in the Python path, for example, `.blender\scripts\bpymodules` would
    be a logical choice or alternatively the user `scriptdir`. The Python file with
    the mesh building blocks is called `mymesh.py` so the first part of our code contains
    the following `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Creating a user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drawing a simple user interface is a matter of using `Draw.Create()` to create
    the required buttons and assembling and initializing these buttons with `Draw.PupBlock()`
  prefs: []
  type: TYPE_NORMAL
- en: This is somewhat limited compared to full-fledged libraries available for some
    programming languages, but very easy to use. The basic idea is to create interactive
    objects, such as buttons, and then assemble them in a dialog box to display to
    the user. At the same time, the dialog box states some of the limitations on the
    values the button may produce. The dialog or pop up will be shown at the position
    of the cursor. Blender is capable of producing a more sophisticated user interface,
    but for now we stick to the basics.
  prefs: []
  type: TYPE_NORMAL
- en: Although `Draw.Create()` can produce toggle buttons and input buttons for strings
    as well, for our application we need input buttons only for integer values and
    floating point values. The type of the variable (for example a floating point
    value or an integer) is determined by the type of the default value given to `Draw.Create()`.
    The **OK** button is automatically displayed by `Draw.PupBlock()`. This function
    takes a list of tuples as an argument with each tuple defining a button to display.
    Each tuple consists of a text to display on the button, a button object created
    with `Draw.Create()`, minimum and maximum allowable values, and a tooltip text
    to show when hovering above the button.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we limit the possible values of our input buttons to a reasonable
    range (up to 50 for the thorax and tail segments) to prevent unwanted results
    (huge values might cripple your system if memory or processing power is scarce).
  prefs: []
  type: TYPE_NORMAL
- en: Remembering choices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It would be very convenient if we could remember the user's choices so that
    we could present the last settings when the script is run again, but in Blender
    each script is run in isolation and all information within the script is lost
    once the script ends. Therefore, we need some mechanism to store information in
    a persistent way. For this purpose, the Blender API has the `Registry` module
    that allows us to keep values in memory (and on disk as well) indexed by an arbitrary
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our GUI initialization code changes little in itself if we want to add this
    functionality, but is prepended by code retrieving remembered values (if they
    are present) and followed by code saving the user''s choices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The actual reading and writing of our registry entry is highlighted. The `True`
    argument indicates that we want to retrieve our data from disk if it is not available
    in memory, or write it to disk as well when saving so that our script can access
    this saved information even if we stop Blender and restart it later. The actual
    registry entry received or written is a dictionary that can hold whatever data
    we want. Of course, there might not yet be a registry entry present, in which
    case we get a `None` value—a situation taken care of by the `try` `…` `except`
    `…` statements.
  prefs: []
  type: TYPE_NORMAL
- en: The full power of Blender graphics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A pop-up dialog is sufficient for many applications but if it does not fit your
    requirements, Blender's `Draw` module has many more building blocks to create
    a user interface but these building blocks require a little bit more effort to
    glue them together in a working application.
  prefs: []
  type: TYPE_NORMAL
- en: We will use these building blocks to create an error pop up. This pop up merely
    shows a message on an alarmingly colored background but illustrates nicely how
    user actions (such as key presses or button clicks) are linked to the graphical
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `error()` function is where it all starts and ends for the user; it tells
    Blender what to draw, where to send events such as button clicks, where to send
    key presses, and starts the interaction. The `lambda` function is necessary as
    the function that we pass to `Draw.Register()` to draw things cannot take an argument,
    yet we want to pass a different text argument every time we call `error()`. The
    `lambda` function basically defines a new function without arguments but with
    the text enclosed.
  prefs: []
  type: TYPE_NORMAL
- en: The `msg()` function is responsible for drawing all of the elements on the screen.
    It draws a colored backdrop with the `BGL.glRecti()` function, a label with the
    text to display (with `Draw.Label()`), and an OK button that is assigned an event
    number of `1` (with `Draw.Button()`). When the user clicks the OK button, this
    event number is sent to the event handler—the `button_event()` function that we
    passed to `Draw.Register()`. All that the event handler does when it is called
    with this event number of `1` is to terminate the `Draw.Register()` function by
    calling `Draw.Exit()`, so our `error()` function may return.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new Mesh object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we have retrieved our lists of vertex co-ordinates and face indices from
    the `mymesh` module, we need some manner to create a new `Mesh` object in our
    scene and add `MVert` and `MFace` objects to this mesh. This might be implemented
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates a new `Mesh` object with the name `Bug`. It will contain
    no vertices, edges, or faces and will not be embedded in a Blender object nor
    connected to any `Scene` yet. If the name of the mesh already exists, it is appended
    with a unique numerical suffix (for example, `Bug.001`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next two lines actually create geometry inside the mesh. The `verts` attribute
    is where our list of `MVert` objects is referenced. It has a method `extend()`
    that will take a list of tuples, each containing the x, y, and z coordinates of
    the vertices to create. Likewise, the `extend()` method of the `faces` attribute
    will take a list of tuples, each containing three or more indices into the vertex
    list that together define a face. Order is important here: we need to add new
    vertices first; otherwise newly-created faces cannot refer to them. It is not
    necessary to define any edges, as adding faces will also create implied edges
    that are not already present.'
  prefs: []
  type: TYPE_NORMAL
- en: A mesh in itself is not yet an object that can be manipulated by the user, so
    in the next few lines (highlighted) we retrieve the current scene and add a new
    object to the scene. The arguments to `new()` are the `Mesh` object that we created
    earlier and the name we want to give to the object. The name given to the object
    might be the same as the one given to the mesh, as mesh names and object names
    live in different namespaces. As with meshes, an existing name will be made unique
    by adding a suffix. If the name is left out, the new object will have the type
    of its argument as a default name (`Mesh` in this case).
  prefs: []
  type: TYPE_NORMAL
- en: A newly-created object will be selected but not active so we correct that by
    assigning our object to `scene.objects.active` .
  prefs: []
  type: TYPE_NORMAL
- en: As we add together our mesh from various collections of vertices the result
    might not be as clean as we would like and therefore, the final two actions make
    sure we do not have any vertices that occupy almost the same location in space
    and that all face normals consistently point outward.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming mesh topology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating the creature from building blocks requires that we duplicate, scale,
    and mirror those building blocks before we stick them together. In Blender 2.49,
    this means we have to define some utility functions to perform those actions as
    they are not present in the API. We define these utility functions in the **Tools**
    module, but we highlight some of them here as they show some interesting methods.
  prefs: []
  type: TYPE_NORMAL
- en: Some actions such as scaling around a median point or translation of vertices
    are straightforward but connecting a group of vertices to another one is tricky,
    as we would like to prevent edges from crossing each other and keep faces flat
    and undistorted. We cannot simply connect two sets of vertices (or edge loops)
    together. But by trying different starting points on an edge loop and checking
    if such a choice minimizes the distance between all vertex pairs we insure that
    no edges cross and distortion is minimal (although we can't prevent faces to distort
    if the edge loops are very dissimilar in shape).
  prefs: []
  type: TYPE_NORMAL
- en: Code outline bridging edge loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the function that creates the new faces we have to perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Check that both edge loops are equally long and nonzero.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For every edge in loop 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the edge in loop 2 that is closest.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a face connecting these two edges.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The function that implements this outline looks fairly complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The function takes two lists of edges as an argument and a list of vertices.
    The edges are represented as tuples of two integers (indices into the `verts`
    list) and the vertices are tuples of x, y, and z co-ordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we do is make copies of the two edge lists because we do not
    want to mangle the lists in their original context. The list of faces that we
    will be constructing is initialized to an empty list and we do a sanity check
    on the length of both edge lists. If that checks out we proceed to the next bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We iterate over every edge in the first list, referring to this edge as `a`.
    The `distance` parameter will hold the distance to the closest edge in the second
    edge list and `best` will be a reference to that edge. `enot` is a list that will
    accumulate all edges from the second list that are at a greater distance than
    `best`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of each iteration, `enot` will hold all edges from the second list
    minus one—the one we consider the closest. We then reassign `enot` to the second
    list so the second list will shrink by one edge over each iteration. We are done
    once the second list of edges is exhausted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The current edge from the second list that we are considering is referred to
    as `b`. For our purposes, we define the distance between `a` and `b` as the sum
    of the distance between corresponding vertices in `a` and `b.`If that one is shorter,
    we define it as the sum of the distance to the flipped vertices of `b`. If the
    last situation applies, we swap the vertices in edge `b`. This may seem a complicated
    way to do things, but by summing the two distances we assure that edges which
    are relatively co-linear are favored thereby diminishing the number of non-flat
    faces that will be constructed. By checking whether flipping the second edge will
    result in a shorter distance, we prevent the formation of warped or bow-tie quads
    as illustrated in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code outline bridging edge loops](img/0400-02-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The implementation will look like the previous figure where the highlighted
    vec are aliases to `Mathutil.Vector`, converting our tuples of x, y, and z co-ordinates
    to proper vectors that we can subtract, add, and take the length of.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we calculate the distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we check whether flipping the b edge results in a shorter distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If the calculated distance is not the shortest, we set aside the edge for the
    next iteration, unless it is the first we encounter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we convert our list of faces, consisting of tuples of two edges, to
    a list of tuples of four indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There is much more to this script and we will revisit `creepycrawlies.py` in
    the following chapter as we add modifiers and vertex groups and rig our model.
    The illustration shows a sample of the bestiary that can be created by the script.
  prefs: []
  type: TYPE_NORMAL
- en: '![Code outline bridging edge loops](img/0400-02-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Dazzle your boss—bar charts in Blender style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To prove that Blender is adaptable to many tasks besides the interactive creation
    of 3D graphics, we will show you how to import external data (a spreadsheet in
    CSV format) and automate the task of creating and rendering the 3D representation
    of a bar chart.
  prefs: []
  type: TYPE_NORMAL
- en: '![Dazzle your boss—bar charts in Blender style](img/0400-02-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The idea is to run Blender with arguments directing it to run a script that
    reads a `.csv` file, renders an image, and saves that image when finished. For
    this to be possible we need a way to call Blender with the correct parameters.
    We get to that script shortly, but first let''s see how to pass parameters to
    Blender to make it run a Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to run a script from a text buffer inside a `.blend` file
    by naming that text buffer instead. Notice the order of the parameters in this
    case—the `.blend` file comes first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a way to specify arguments to pass to our script. In contrast
    to what is described in the API docs, we can just access the command-line arguments
    from Python like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This last snippet will print all arguments, including the name of the Blender
    executable as the first. Our script will have to skip any arguments intended for
    Blender itself when using this list. Any arguments intended only for our script
    that shouldn't be interpreted by Blender itself should come after an **end-of-options**
    **argument**, the double minus (`--`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we don''t want Blender to pop up and show an interactive GUI. Instead,
    we will instruct it to run in the background and exit when done. This is done
    by passing the `-b` option. Putting all this together, the command line will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If Blender is run in background mode you *must* specify a `.blend` file, otherwise
    Blender will crash. If we have to specify a `.blend` file we can use an internal
    text as our Python script just as well, otherwise we'd have to keep two files
    together instead of one.
  prefs: []
  type: TYPE_NORMAL
- en: The bar chart script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we show the relevant parts of the code in chunks (the complete file is
    available as `barchart.blend` that has `barchart.py` as an embedded text). We
    start by creating a new `World` object and set its zenith and horizon colors to
    a neutral all white (highlighted part of the following code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we retrieve the last argument passed to Blender and check whether the
    extension is that of a `.csv` file. Real world production code would have more
    sophisticated error checking of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If it has the correct extension we create a new `Scene` named `BarScene` and
    set its `world` attribute to our newly created world (This was inspired by a much
    more elaborate script by *jessethemid* on Blender Artists [http://blenderartists.org/forum/showthread.php?t=79285](http://blenderartists.org/forum/showthread.php?t=79285)).
    The background mode does not load any default `.blend` file so the default scene
    will not contain any objects. However, just to make sure, we create a new empty
    scene with a meaningful name that will hold our objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Then, we pass the filename to a function that adds the `barchart` objects to
    the current scene and returns the center of the chart so that our `addcamera()`
    function can use it to aim the camera. We also add a lamp to make rendering possible
    (otherwise our render would be all black).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The rendering itself is straightforward (we will encounter more elaborate examples
    in [Chapter 8](ch08.html "Chapter 8. Rendering and Image Manipulation"), *Rendering
    and Image Manipulation*). We retrieve the rendering context that holds all information
    about how to render, for example which frame, what output type, the size of the
    render, and so on. And, because most attributes have sensible defaults, we just
    set the format to PNG and render.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we set the output directory to an empty string to make our output go
    to the current working directory (the directory we were in when we called Blender)
    and save our rendered image. The image will have the same basename as the `.csv`
    file that we passed as the first argument but will have a `.png` extension. We
    checked that the filename ends in `.csv` so it's safe to bluntly strip the last
    four characters from the filename and add `.png`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding a lamp is not much different from adding any other object and is very
    similar to the "hello world" example. We create a new `Lamp` object, add it to
    the current scene, and set its location. A `Lamp` object has of course many configurable
    options but we settle for a default non-directional lamp in this example. The
    highlighted code shows some typical Python idiom: `loc` is a tuple of three values
    but `setLocation()` takes three separate arguments so we indicate we want to unpack
    the tuple as separate values with the `*` notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding a camera is a little more intricate as we have to point it to our bar
    chart and make sure that the view angle is wide enough to see everything. We define
    a perspective camera here and set a fairly wide angle. Because the default camera
    is already oriented along the z-axis we do not have to set any rotation, just
    set the location 12 units removed from the center along the z-axis as highlighted
    in the second last line of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `barchart` function itself is not much of a surprise. We open the passed-in
    filename and use the standard `csv` module from Python to read the data from the
    file. We store all column headers in `xlabel` and other data in `rows`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In order to scale our bar chart to reasonable values we have to determine the
    extremes of the data. The first column of each record holds the x-value (or label)
    so we exclude that from our calculation. As each value is stored as a string we
    have to convert it to a floating point value for comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: To create the actual bars we iterate over all rows. Because the x-value might
    be a textual label (such as the name of a month for example), we keep a separate
    numerical x-value in order to position the bars. The x-value itself is added to
    the scene as a `Text3d` object by the `label()` function, whereas the y-values
    are visualized by appropriately scaled `Cube` objects added by the `bar()` function.
    Neither the `label()` nor the `bar()` function are shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we label each column (that is, each set of data) with its own column
    header as a label. We stored the number of x-values so we can return the center
    of our bar chart by dividing it by two (the y component is set to 5.0 as we scaled
    all y-values to lie within the range 0-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**A Windows trick: SendTo**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have your `.blend` file containing a correct Python script and you
    have figured out the correct way to invoke it from the command line, you can integrate
    this more closely with Windows XP by creating a `SendTo` program. A `SendTo` program
    (a `.BAT` file in this case) is any program that will take a single filename as
    an argument and acts upon it. It has to reside in the `SendTo` directory—which
    may be located in different places depending on your system configuration. It
    is simple to find by clicking on the **Start** button, selecting **Run**, and
    typing **sendto** instead of a command. This will open the correct directory.
    In this directory you can place the `.BAT` file, in our case we call it `BarChart.BAT`,
    and it will contain a single command: `/full/path/to/blender.exe` `/path/to/barchart.blend`
    `-P` `barchart.py` `--` `%1` (note the percent sign). Now we can simply right-click
    any `.csv` file we encounter and we can then select `BarChart.BAT` from the `SendTo`
    menu and hey presto, a `.png` file will appear alongside our `.csv`.'
  prefs: []
  type: TYPE_NORMAL
- en: Weird faces—selecting and editing faces in meshes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blender already provides a host of options to select and manipulate the faces,
    edges, and vertices of a mesh, either via built-in methods or via Python extension
    scripts. But if you want to select some elements based on your unique requirements,
    this section shows how to implement that. We build a few small scripts that illustrate
    how to access faces, edges, and vertices and how to work with the various properties
    of these objects.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting warped (non-planar) quads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Warped** **quads**, also known as **bow-tie** **quads,** are sometimes formed
    when accidentally mixing up the vertex order during face creation. In a less extreme
    case they might be formed when moving a single vertex of a planar quad. This small
    illustration shows how these may look in the 3D-view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting warped (non-planar) quads](img/0400-02-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the 3D view, the warped face on the right didn''t seem out of the ordinary
    but when rendered it does not show uniform shading:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting warped (non-planar) quads](img/0400-02-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Both objects are planes and consist of a single face with four vertices. The
    one on the left is a bow-tie quad. Its right edge is rotated a full 180 degrees
    resulting in an ugly, black triangle where we see the back of the warped face.
    The plane on the right shows no noticeable distortion in the 3D view even though
    its upper-right vertex is moved a considerable distance along the z-axis (our
    line of sight). When rendered however, the distortion of the right plane is clearly
    visible. The visible distortion of slightly warped quads may be overcome by setting
    the `smooth` attribute of a face that will interpolate the vertex normals along
    the face resulting in a smooth appearance. Slightly warped quads are almost inevitable
    when modeling or deforming a mesh by an armature and whether they result in visible
    problems depends on the situation. Often it is helpful if you can identify and
    select them to make your own judgment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Warped quads can be identified by checking whether the normals of the triangles
    that form the quad are pointing in the same direction. A flat quad will have its
    triangle normals pointing in the same direction as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting warped (non-planar) quads](img/0400-02-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Whereas in a warped quad these normals are not parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting warped (non-planar) quads](img/0400-02-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'These triangle normals are not the same as vertex normals: those are defined
    as the average of all face normals of the faces sharing a vertex so we will have
    to calculate these triangle normals ourselves. This can be done by taking the
    cross product of the edge vectors, that is, the vectors defined by the two vertices
    at the end of each edge. In the examples shown we have the left triangle normal
    formed by taking the cross product of the edge vectors 1 → 0 and 1 → 2 and the
    right triangle by taking the cross product of the edge vectors 2 → 1 and 2 → 3.'
  prefs: []
  type: TYPE_NORMAL
- en: It does not matter whether we traverse our edges clockwise or counterclockwise
    but we have to be careful to be consistent in ordering edges when calculating
    the cross products because the sign will be reversed. Once we have our triangle
    normals we can check whether they point in exactly the same direction by verifying
    that all components (x, y, and z) of one vector are scaled by the same factor
    when compared to the corresponding components of the second vector. To give us
    somewhat more flexibility however, we would like to calculate the angle between
    the triangle normals and select a face only if that angle exceeds some minimum.
    We do not have to devise such a function ourselves because the `Blender.Mathutils`
    module provides the `AngleBetweenVecs()` function.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to construct four different triangles within a quad but is not
    necessary to compare all triangle normals—any two normals will suffice because
    moving a single vertex of a quad will alter three of the possible four triangle
    normals.
  prefs: []
  type: TYPE_NORMAL
- en: Code outline warp select
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Armed with all this information, the outline for our tool will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Show pop up for minimum angle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the active object is a mesh and in *edit* mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable *face select* mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For all faces, check if the face is a quad and if so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the triangle normal defined by vertex 0, 1, and 2
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate the triangle normal defined by vertex 1, 2, and 3
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate the angle between normals
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If angle > minimum angle, select the face
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This translates in the following code for the actual detection and selection
    (the full script is provided as `warpselect.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, our outline corresponds almost one-to-one to the code. Note
    that `AngleBetweenVecs()` returns the angle in degrees so we can directly compare
    it to `maxangle` which is also in degrees. Also, there is no need to implement
    the cross product of two vectors ourselves as Blender''s `Vector` class is well
    stocked with all sorts of operators. Before we can call this function we have
    to take care of an important detail: in order to select faces, *face selection*
    mode should be enabled. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To illustrate the less well-known fact that select modes are *not* mutually
    exclusive we set the *face* *select* mode in addition to any mode already selected
    by combining values with a binary or operator (`|`). At the end of the script
    we restore the mode that was active.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting ultra sharp faces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many tools exist to select faces that are in some sense unwieldy to work with.
    Blender has built-in tools to select faces that have an area that is too small
    or that have a perimeter that is too short. However, it lacks a tool to select
    faces with edges that form angles that are sharper than some limit. In some modeling
    tasks it would be very convenient if we could select such faces, as they are generally
    difficult to manipulate and may give rise to ugly artifacts when applying a subsurface
    modifier or deforming a mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that Blender's *select* *sharp* *edges* tool (*Ctrl + Alt + Shift + S*)
    does something different despite its name; it selects those edges that are shared
    by exactly two faces whose angle of contact is less than some minimum value or,
    to put it in another way, selects edges between faces that are relatively flat.
  prefs: []
  type: TYPE_NORMAL
- en: We already have seen that Blender's `Mathutils` module has a function to calculate
    the angle so our code is very brief as the real work is done by a single function
    shown below. (The full script is provided as `sharpfaces.py`.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note that we do not distinguish between tris or quads as both may have edges
    that are joined by a sharp angle. The highlighted part in the preceding code shows
    one subtle detail; each time we calculate the angle between our two edge vectors,
    we invert one of them because to calculate the correct angle, each of the vectors
    should originate in the same vertex whereas we calculated them all as pointing
    from one vertex to the next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The distinction is illustrated in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting ultra sharp faces](img/0400_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Selecting vertices with many edges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ideally, a mesh will contain faces that consist of only four vertices (these
    faces are generally referred to as **quads**) and are fairly even sized. Such
    a configuration is optimal when deforming the mesh, as is often necessary with
    animations. Of course, there is nothing intrinsically wrong with three-sided faces
    (**tris**) but in general it is better to avoid them because small triangular
    faces wreck havoc with subsurface modifiers, causing them to show unsightly ripples.
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting vertices with many edges](img/0400-02-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now even when you have a mesh that consists only of quads, some vertices are
    the center of more than four edges. These vertices are sometimes called **poles**,
    hence the name of the scripts in the following sections. If the number of edges
    is excessive, say six or more (as shown in the previous screenshot), such an area
    might become difficult to deform and difficult to manipulate for the modeler.
    In a large and complex mesh these vertices might be difficult to pinpoint and
    therefore we need a selection tool that selects those vertices.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting poles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to select vertices with a certain number of steps we may perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether the active object is a `Mesh.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether we are in *object* mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Show a pop-up menu to input the minimum number of edges.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For every vertex:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate over all edges, counting occurrences of the vertex
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If count is larger or equal to the minimum, select the vertex
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This approach is straightforward and simple. The function that is responsible
    for the actual work is shown below (the full script is called `poleselect1.py`).
    It follows our outline closely. The actual selection of a vertex is effected by
    assigning to the `sel` attribute of the vertex. Note also that the `v1` and `v2`
    attributes of an `edge` object are not indices into the `verts` attribute of our
    mesh but refer to `MVert` objects. That is why we need to retrieve the `index`
    attributes to compare.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Selecting poles, again
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You probably noticed that we iterated over the list of edges for each and every
    vertex (highlighted in the previous code). This might be costly in terms of performance
    and this cost is even compounded by the need to compare indices which have to
    be retrieved again and again. Is it possible to write more efficient code that
    stays readable nonetheless? It is if we follow this strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether the active object is a `Mesh`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether we are in *object* mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Show a pop-up menu to input the minimum number of edges.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize a dictionary, indexed by vertex index that will contain edge counts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate over all edges (update the count for both referred vertices).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate over the items in the dictionary (if count is larger or equal to the
    minimum, select the vertex).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using this strategy we perform just two possibly lengthy iterations at the
    cost of needing the memory to store the dictionary (nothing is free). The speed
    increase is negligible for small meshes but might be considerable (I clocked a
    1,000-fold speed boost on a smallish mesh of 3,000 vertices) for large meshes,
    and those are just the kind of meshes where someone might need a tool like this.
  prefs: []
  type: TYPE_NORMAL
- en: Our revised selection function is shown below (the full script is called `poleselect.py`).
    First note the `import` statement. The dictionary that we will be using is called
    a default dictionary and is provided by Python's collections module. A **default**
    **dictionary** is a dictionary that initializes missing items the first time they
    are referred to. As we want to increment the count for every vertex that is referred
    to by an edge, we should either initialize our dictionary with a zero value for
    every vertex in the mesh beforehand or check if a vertex is already indexed every
    time we want to increment the count and, if not, initialize it. A default dictionary
    does away with the need to initialize everything in advance and allows for a very
    readable idiom.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create our dictionary by calling the `defaultdictionary()` function (a function
    returning a new object whose behavior is configured by some argument to the function
    is called a factory in object-oriented circles) with an `int` argument. The argument
    should be a function taking no arguments. The built-in function `int()` that we
    use here will return an integer value of zero when called without arguments. Every
    time we access our dictionary with a non-existing key, a new item is created and
    its value will be the return value of our `int()` function, that is, zero. The
    essential lines are the two where we increment the `edgecount` (highlighted part
    of the following code). We could have written that expression in a slightly different
    way to illustrate why we need a default dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The dictionary item we refer to on the right-hand side of the expression might
    not yet exist every time we refer to a vertex index that we encounter for the
    first time. Of course, we could check beforehand but that would render the code
    a whole lot less readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Determining the volume of a mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Blender is not really a CAD program, many people use it for CAD-like
    issues such as architectural visualization. Blender is capable of importing many
    types of files including those of major CAD programs, so including technical models
    drawn to precise measurements is never a problem.
  prefs: []
  type: TYPE_NORMAL
- en: These CAD programs often offer all kinds of tools to measure the dimensions
    of (parts of) your model, yet Blender, by its nature, provides very few of those
    tools. It is possible to inspect the size and location of an object by pressing
    the *N* key in the 3D view window. In *edit* mode you may enable the display of
    edge lengths, edge angles, and face areas (see the panel **Mesh tools more** in
    the editing context (*F9*) of the Buttons window) but that is about as far as
    it gets.
  prefs: []
  type: TYPE_NORMAL
- en: Python may overcome those limitations in situations where we need some specific
    measurement and exporting our model to a CAD tool is not an option. A practical
    example is the calculation of the volume of a mesh. Nowadays, a number of companies
    offer possibilities to re-create your digital model as real world objects by way
    of 3D printing techniques. I have to say it is a rather special feeling to hold
    a plastic or even metal replica of your Blender model in your hands, it really
    adds a whole new dimension to 3D.
  prefs: []
  type: TYPE_NORMAL
- en: Now a major component of the price of 3D-printing a model is the amount of material
    that will be used. Often, it will be possible to design your model as a hollow
    object that takes less material to produce, but it is quite inconvenient to upload
    intermediate versions of your model again and again to let the manufacturer's
    software calculate the volume and give you a price quote. So what we would like
    to have is a script that can calculate the volume of a mesh in a fairly accurate
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: A common method to calculate the volume of a mesh is sometimes referred to as
    the **Surveyor's Formula** as it is related to the way surveyors may calculate
    the volume of a hill or mountain by triangulating its surface.
  prefs: []
  type: TYPE_NORMAL
- en: The central idea is to split a triangulated mesh into many columns that have
    their base on the xy-plane.
  prefs: []
  type: TYPE_NORMAL
- en: The surface area of the triangle projected onto the xy-plane times the average
    z-position of the three vertices then gives the volume of such a column. Summing
    these volumes finally gives the volume of the complete mesh (see the next figure).
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining the volume of a mesh](img/0400-02-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are a couple of things that have to be taken into account. First, a mesh
    may extend below the xy-plane. If we construct a column from a face that lies
    below the xy-plane, the product of the projected area and the average of the z-coordinates
    will be a negative number, so we have to negate its value to get a volume.
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining the volume of a mesh](img/0400-02-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Second, a mesh may lie completely or partially above the xy-plane. If we take
    a look at the example in the previous diagram we see that the object has two triangles
    that contribute to the volume of the object, the top and bottom ones (the vertical
    triangles have a projected area of zero, so will contribute nothing). As the top
    and bottom faces both lie above the xy-plane, we have to subtract the volume of
    the column constructed from the bottom face from the one constructed from the
    top face. If the object was completely below the xy-plane it would be the other
    way around, and we would have to subtract the volume of the top column from the
    volume of the bottom column.
  prefs: []
  type: TYPE_NORMAL
- en: How we can tell what to do is determined by the direction of the face normal
    of our triangles. If, for example, a triangle is above the xy-plane but its face
    normal is pointing downward (it has a negative z-component), then we have to subtract
    the calculated volume. It is therefore vital that all face normals point consistently
    outward (in *edit* mode, select all faces and press *Ctrl + N*).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take into account all four possibilities (face normal up or down, face
    above or below the xy-plane) we can write the following outline for our function:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure all face normals consistently point outward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For all faces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the z-component of face normal vector **Nz**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate the product **P** of the average z-coordinates and the projected surface
    area.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If Nz is positive: add P'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If Nz is negative: subtract P'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This nifty algorithm works for simple objects without holes and just as well
    for objects containing holes (such as a torus), or even hollow ones (that is,
    containing an object completely enclosed in another object) like the examples
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining the volume of a mesh](img/0400-02-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we allow the product of area and z-coordinates to be negative, we have
    to check only for the direction of the face normal to cover all situations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that it is necessary for the mesh to be closed and manifold: There shouldn''t
    be any missing faces nor should there be any edges that do not share exactly two
    faces, such as interior faces.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining the volume of a mesh](img/0400-02-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The important part of the code is shown here (the complete script is called
    `volume.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted code shows how we calculate the area of the triangle projected
    on the xy-plane. `TriangleArea()` will calculate the area of a two-dimensional
    triangle when given two dimensional points (points in the xy-plane). So we pass
    not the full coordinate vectors of the vertices, but truncate them (that is, we
    drop the z-coordinate) into two component vectors.
  prefs: []
  type: TYPE_NORMAL
- en: After running the script from the text editor, or from the **Scripts** menu
    when in *object* mode, a pop up is displayed showing the volume in Blender units.
    Before running the script make sure that all modifiers are applied, scale and
    rotation are applied (*Ctrl + A* in *object* mode), the mesh is fully triangulated
    (*Ctrl + T* in *edit* mode), and that the mesh is manifold (closed or water-tight)
    by checking for non-manifold edges (*Ctrl + Alt + Shift +M* in *edge selection*
    mode). **Manifold** **edges** are edges that are shared by exactly two faces.
    Also make sure that all normals are pointing in the right direction. The application
    of modifiers is necessary to make the mesh closed (if it is a mirror modifier)
    and to make the calculation of the volume accurate (if it is a subsurface modifier).
  prefs: []
  type: TYPE_NORMAL
- en: Determining the centre of mass of a mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When printing a three-dimensional object in plastic or metal, a seemingly innocent
    question might pop up once we create our first toy based on a mesh we created;
    what is its center of mass? If our model has legs but we don''t want it to keel
    over, its center of mass better be somewhere over its feet and, preferably, as
    low as possible to keep it stable. This figure shows this schematically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining the centre of mass of a mesh](img/0400-02-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we know how to determine the volume of a mesh we can reuse many of the
    concepts to devise a script to determine the center of mass. Two additional bits
    of knowledge are needed to compute the position of the center of mass:'
  prefs: []
  type: TYPE_NORMAL
- en: The centers of mass of the projected volumes we construct when calculating the
    volume of the mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add up the calculated centers of mass of all these individual volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of this assumes that solid sections of our mesh have a uniform density.
    A mesh may have any form or even be hollow but the solid parts are assumed to
    be of a uniform density. This is valid assumption for the materials deposited
    by 3D printers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first issue is a bit of geometry: the projected volume is essentially a
    triangular column (or triangular prism) capped by a possibly slanted triangular
    face. Calculating the center of mass might be done as follows: the x and y coordinates
    of the center of mass are the x and y coordinates of the center of the projected
    triangle on the xy-plane—those are simply the averages of the x and y coordinates
    respectively of the three points defining the triangular face. The z-coordinate
    of the center of mass is halfway along the average height of our projected column.
    This is the average of the z-coordinates of the three points of the triangular
    face divided by two.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second issue is mainly common sense: given two masses m1 and m2 with their
    centers of mass at v1 and v2 respectively, their combined center of mass is the
    weighted average. That is to say, the center of mass is proportionally closer
    to the center of the mass of the heaviest component.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course it is common sense to us now, but it took someone like Archimedes
    to see that it actually was common sense. After finding out about this 'law of
    levers' (as he called it), he didn't shout 'eureka' or went running around naked,
    so it took somewhat longer to attract attention.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put all this information into a recipe that we can follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure all face normals consistently point outward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For all faces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the z-component of face normal vector Nz
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate the product P of the average z-coordinates and the projected surface
    area
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate CM(x, y, z) with x, y the average of the projected x, y coordinates
    of the face and z (the average of the z-coordinates of the face)/2
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If Nz is positive: add P times CM'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If Nz is negative: subtract P times CM'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From the outline above, it is clear that calculating the center of mass goes
    hand in hand with the calculation of the partial volumes, so it makes sense to
    redefine the `meshvolume()` function to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The added or changed lines of code are highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: Some remarks about accuracy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although most of us are artists and not engineers, we still may ask how accurate
    the number is that we calculate for our mesh volume or center of mass. There are
    two things to consider—intrinsic accuracy and computational accuracy of our algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '**Intrinsic** **accuracy** is what we refer to when we consider the fact that
    our model is made out of small polygons that approximate some imagined shape.
    When doing organic modeling this hardly matters; if our model looks good, it is
    good. However, if we try to approximate some ideal form, for example a sphere,
    by a polygonal model (a uv-sphere say, or an icosphere) there will be a difference
    between the calculated volume and the known volume of the ideal sphere. We can
    improve this approximation by increasing the number of subdivisions (or equivalent
    the size of the polygons) but we will never be able to completely eliminate this
    difference and the algorithm used to calculate the volume cannot change that.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Computational** **accuracy** has several aspects. First, there is the precision
    of the numbers we calculate with. On most platforms that Blender runs on, calculations
    are performed using double precision floating point numbers. This amounts to about
    17 digits of precision and there is nothing we can do to improve that. Luckily,
    that is ample precision to work with.'
  prefs: []
  type: TYPE_NORMAL
- en: Then there is the accuracy of our algorithm. When you look at the code you will
    see that we are adding and multiplying a potentially huge amount of values, as
    a typical high-resolution model may well contain over a hundred thousand faces
    or even a million. For each face we calculate the volume of the projected column
    and all of these volumes are added (or subtracted) together. The problem is that
    these volumes may differ considerably in size, not only because the areas of the
    faces may differ but especially because the projected area of a near vertical
    face is very small compared to a near horizontal one.
  prefs: []
  type: TYPE_NORMAL
- en: Now if we add a very large and a very small number with limited precision calculations
    we will *lose* the small number. For example, if our precision would be limited
    to three significant digits, adding 0.001 and 0.0001 would end up as 0.001, losing
    the effect of the small number. Now our precision is a lot better (about 17 digits)
    but we add a lot more than two numbers. If we implement the `volume()` function
    by using one of the cited algorithms however, the difference never adds up to
    more than one in million, so as long as we don't aim to do nuclear science with
    Blender there is no need to bother. (For those who do, an alternative is provided
    in the script as the function `volume2()`. Still, be careful that you know what
    you are doing).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python is able to work with numbers of potentially infinite size and precision
    but this is much slower than doing normal floating point calculations. The functions
    and classes provided in `Mathutils` are primarily coded in C for speed and limited
    to double precision floats. See [http://code.activestate.com/recipes/393090/](http://code.activestate.com/recipes/393090/)
    [http://code.activestate.com/recipes/298339/](http://code.activestate.com/recipes/298339/)
    or Section 18.5 of Python Cookbook, 2nd edition, by O'Reilly for some other techniques
    and mathematical background.
  prefs: []
  type: TYPE_NORMAL
- en: Growing sunflowers—parenting and grouping objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating elaborate assemblies of objects is automated easily enough, but we
    would like to provide the end user with ways to select all of these related objects
    and to move them together. This section shows how we can achieve that by creating
    groups and by parenting objects to each other. You will end up with a bunch of
    nice sunflowers as a result.
  prefs: []
  type: TYPE_NORMAL
- en: '![Growing sunflowers—parenting and grouping objects](img/0400-02-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Groups are devised to make it easier to select, or manipulate, more than one
    object at the same time. Sometimes this behavior is part of a larger scheme. An
    armature for example, is a collection of bones, but then these collections have
    very specific relations (bones in an armature have precisely defined relations
    to each other).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many situations where we would like to identify a bunch of objects
    as belonging together without there being a specific relationship. Blender provides
    two kinds of groups to help us define their loose relations: **object** **groups**
    (or simply groups) for named collections of objects, and **vertex groups** for
    named collections of vertices within mesh objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Object groups allow us to select an otherwise unrelated set of objects we added
    to a group (we could group a mesh, an armature, and a bunch of empties together
    for example). A group relationship is different from a parent-child relationship.
    Groups merely allow us to select objects but parented objects move along when
    their parent is moved. The functionality to define and manipulate groups is provided
    in the `Group` module and its identically named class (a group is just like another
    Blender object, but one containing a list of references to other objects, but
    not to other groups unfortunately). You might, for example, append a group from
    an external `.blend` file just like you would a `Lamp` or a `Mesh`. The following
    table lists some often used group operations (see the `Blender.Group` module in
    the Blender API documentation for additional functionality):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `group=Group.New(name=''aGroupName'')` | Creates a new group |'
  prefs: []
  type: TYPE_TB
- en: '| `group=Group.Get(name=''aGroupName'')` | Gets a reference to a group by name
    |'
  prefs: []
  type: TYPE_TB
- en: Vertex groups are a convenient way to identify groups of related vertices (such
    as an ear or a leg in a model of a toy for example) but they have their uses beyond
    mere selecting. They can be used to determine the influence of bone deformations
    or to identify emitter regions of particle systems to name a few. Vertex groups
    will be our focus in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Parenting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Parenting** in real life might be difficult at times, but in Blender it is
    rather easy although there is a sometimes bewildering array of options to choose
    from. It is possible to parent an object to another object, to a single bone in
    an armature, or to one or three vertices in a `Mesh` object. The following table
    shows the relevant methods (Refer to `Blender.Object` in the Blender API for additional
    functionality):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| parent.makeParent([child1, child2, child3]) | parent-children to a parent
    object |'
  prefs: []
  type: TYPE_TB
- en: '| parentmesh.makeParentVertex([child1,child2,child3],vertexindex1) | parent-children
    to a vertex |'
  prefs: []
  type: TYPE_TB
- en: '| parentmesh.makeParentVertex([child1,child2,child3],vertexindex1,vertexindex2,vertexindex3)
    | parent-children to three vertices |'
  prefs: []
  type: TYPE_TB
- en: Growing a sunflower from a seed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can put all this information to good use when we write a script that will
    create a model of a sunflower (Van Gogh would probably have cut off his other
    ear as well if he saw this "sunflower" but then again, his was another way of
    looking altogether). The single sunflower that we will be creating consists of
    a stalk and a flower head. The head of a sunflower consists of tiny flowers that
    will become the seeds once fertilized and a rim of large petals. (I know, any
    botanist will cringe at my language. The tiny flowers are called "disc florets"—but
    floret is just a "little flower" right? And the ones on the edge are "ray florets".)
    Our head will have seeds and each seed is a separate `Mesh` object that will be
    vertex-parented to our head mesh.
  prefs: []
  type: TYPE_NORMAL
- en: We would like our seeds to not just move along with our seed head, but to follow
    any local curvature and orient themselves perpendicular to the head surface so
    we can, for example, distort the head mesh with proportional editing and all attached
    seeds will follow. To accomplish that we use the three vertex variant of vertex
    parenting.
  prefs: []
  type: TYPE_NORMAL
- en: 'By parenting an object to three different vertices of a mesh, that object will
    follow the position of those vertices and orient itself relative to the normal
    (see the following illustrations):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Growing a sunflower from a seed](img/0400-02-18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do not need to connect all those triplets of vertices as the head mesh itself
    will not be rendered (it will be fully covered by seeds). We do define a face
    between each triplet of vertices though; otherwise it would be difficult for a
    modeler to see the head mesh in *edit* mode.
  prefs: []
  type: TYPE_NORMAL
- en: '![Growing a sunflower from a seed](img/0400-02-19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The petals are separate objects parented in the normal way to the head mesh
    as they need not follow any curvature of the head mesh, just its location and
    rotation. The head in turn is parented to the stalk so we can move the whole assembly
    around by moving the stalk.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we assign all individual objects to a single group. That way it will
    be easy to select everything in one go and it enables us to link or append one
    or more sunflowers from an external file as a single entity.
  prefs: []
  type: TYPE_NORMAL
- en: Duplication versus instantiation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We said that all our seeds and petals are separate objects but it might make
    more sense to instantiate them instead (called **making a linked copy** in Blender).
    As all seeds and all petals as we have modeled them are identical, we can refer
    to the same mesh data and just change the location, rotation, or scale of the
    object as needed—saving possibly a fair amount of memory. When using Blender interactively
    we can instantiate an object by pressing *Alt + D* (instead of *Shift + D* for
    a regular copy). In our script, we simply define a new object and point it to
    the same `Mesh` object by passing a reference to the same mesh when calling `Object.New()`.
  prefs: []
  type: TYPE_NORMAL
- en: Growing a sunflower
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at the main part of the script that will create the sunflower (the
    full script is available as `sunflower.py`). The first step is to calculate the
    position of the seeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'From these positions we create the head, vertices, and faces that we can parent
    the kernels to and assemble these into the head mesh (highlighted part of the
    following code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create the base mesh for the kernel and create objects
    that reference this mesh (highlighted part of the following code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Each kernel is then assigned a suitable location and parented to the appropriate
    vertices in the flower head mesh (highlighted part of the following code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a petal mesh and arrange duplicates of this mesh along the
    rim of the flower head (highlighted part of the following code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Each petal is positioned and rotated along the rim and parented to the head
    (highlighted part of the following code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create a stalk mesh and object and parent the head to the stalk.
    This way the entire flower may be moved by moving the stalk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'All that is left to do is to group the kernels and petals in separate groups
    (highlighted) and then all parts in an overall sunflower group for easy reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addmeshduplicate()` function used in the code is implemented in the `Tools`
    module in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Given a scene, a mesh, and a name (optional) for the object, it adds a new object
    to the scene. The `Mesh` object passed as an argument might be used again and
    again to create new objects that refer to the same mesh.
  prefs: []
  type: TYPE_NORMAL
- en: 'Newly created objects will be selected automatically but not be made active,
    so the next step is to make the newly-created object active (highlighted in the
    preceding code). This is not necessary but might be convenient to the user as
    are the next two actions: ensuring that all face normals point consistently outward
    and removing any vertices that are very close together. These last two actions
    can only be performed on a mesh that is embedded in an object.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, as a convenience, we set the `smooth` attribute for all faces, to get
    smoother images when rendering. Finally, we update the display list for this mesh
    and notify all Blender windows that there has been a change.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**A slight digression, or why rabbits are related to sunflowers.**'
  prefs: []
  type: TYPE_NORMAL
- en: One of the things you may notice is that we have arranged the seeds in a peculiar
    spiral. This type of spiral, where subsequent positions along the spiral are spaced
    by following the so-called *Golden* *ratio* is called **Fermat's** **spiral**.
    Such a spiral results naturally in many seed heads when the florets or seeds are
    formed in the middle and pushed outward, resulting in a highly efficient packing.
  prefs: []
  type: TYPE_NORMAL
- en: 'When seen from above, the arrangement of seeds also seem to follow both left
    and right turning curves. The numbers of these curves usually are a pair from
    the *Fibonacci* *sequence* *[ 1 1 2 3 5 8 13 21 …]* and the ratio of such a pair
    of numbers tends to converge on the *Golden* *ratio* when they get bigger. (In
    the two illustrations of our seed head below we can discern 13 counterclockwise
    spirals and 21 clockwise spirals.) Fibonacci invented this series in an attempt
    to model the population growth of rabbits. More about sunflowers (and possibly
    rabbits) may be found here: [http://en.wikipedia.org/wiki/Sunflower](http://en.wikipedia.org/wiki/Sunflower).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Growing a sunflower](img/0400-02-20_NEW.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to create complex objects and how to make
    the task of configuring those objects on easy one for the end user by providing
    a graphical user interface that remembers previous choices. We saw that it was
    also possible to recruit Blender as a command-line tool to automate common tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also learned how to create a parent relation between objects and made a
    first step in editing meshes. Specifically, we saw how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create configurable mesh objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design a graphical user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make your script store user choices for later reuse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select vertices and faces in a mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parent an object to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify meshes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run Blender from the command line and render in the background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process command-line parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will see how we can assign vertex groups and materials
    to our meshes.
  prefs: []
  type: TYPE_NORMAL
