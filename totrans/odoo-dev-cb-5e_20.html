<html><head></head><body>
		<div><h1 id="_idParaDest-854" class="chapter-number"><a id="_idTextAnchor1065"/>20</h1>
			<h1 id="_idParaDest-855"><a id="_idTextAnchor1066"/>Remote Procedure Calls in Odoo</h1>
			<p>The Odoo server supports <strong class="bold">remote procedure calls</strong> (<strong class="bold">RPCs</strong>), which means that you can connect <a id="_idIndexMarker1357"/>Odoo instances from external applications. An example is if you want to show the status of a delivery order in Fan Android application that is written in Java Here, you can fetch the delivery status from Odoo via RPC. With the Odoo RPC API, you can perform any CRUD operations on a database. Odoo RPC is not limited to CRUD operations; you can also invoke public methods of any model. Of course, you will need to have proper access to rights to perform these operations because RPC respects all of the access rights and record rules you have defined in your database. Consequently, it is very safe to use because the RPC respects all access rights and record rules. Odoo RPC is not platform-dependent, so you can use it on any platform, including Odoo.sh, online, or self-hosted platforms. Odoo RPC can be used with any programming language, so you can integrate Odoo with any external application.</p>
			<p>Odoo provides two types of RPC API: XML-RPC and JSON-RPC. In this chapter, we will learn how to use these RPCs from an external program. Finally, you will learn how to use Odoo RPC through OCA’s <code>odoorpc</code> library.</p>
			<p>In this chapter, we will cover the following recipes:</p>
			<ul>
				<li>Logging in to/connecting Odoo with XML-RPC</li>
				<li>Searching/reading records using XML-RPC</li>
				<li>Creating/updating/deleting records using XML-RPC</li>
				<li>Calling methods using XML-RPC</li>
				<li>Logging in to/connecting Odoo with JSON-RPC</li>
				<li>Fetching/searching records using JSON-RPC</li>
				<li>Creating/updating/deleting records using JSON-RPC</li>
				<li>Calling methods using JSON-RPC</li>
				<li>The OCA odoorpc library</li>
				<li>Generating API keys</li>
			</ul>
			<h1 id="_idParaDest-856"><a id="_idTextAnchor1067"/>Technical requirements</h1>
			<p>In this chapter, we will be using the <code>my_hostel</code> module, which we created in <a href="B20997_19.xhtml#_idTextAnchor1030"><em class="italic">Chapter 19</em></a>, <em class="italic">Managing, Deploying, and Testing with Odoo.sh</em>. You can find the same initial <code>my_hostel</code> module in the GitHub repository: <a href="https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter20">https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter20</a>.</p>
			<p>Here, we will not Introduce a new language as you may not be familiar with it. We will continue using Python to access the RPC API. You can use another language if you want to, as the same procedure can be applied in any language to access the RPC.</p>
			<p>To connect Odoo through the RPC, you will need a running Odoo instance to connect with. Throughout this chapter, we will assume that you have the Odoo server running on <code>http://localhost:8017</code>, that you called the <code>cookbook_17e</code> database, and that you have installed the <code>my_hostel</code> module therein. Note that you can connect any valid IP or domain through the RPC.</p>
			<h1 id="_idParaDest-857"><a id="_idTextAnchor1068"/>Logging in to/connecting Odoo with XML-RPC</h1>
			<p>In this <a id="_idIndexMarker1358"/>recipe, we will carry out user authentication through <a id="_idIndexMarker1359"/>RPC to check whether the credentials (server_url, db_name, username, and password) supplied are valid.</p>
			<h2 id="_idParaDest-858"><a id="_idTextAnchor1069"/>Getting ready</h2>
			<p>To connect <a id="_idIndexMarker1360"/>an Odoo instance through RPC, you will <a id="_idIndexMarker1361"/>need a running Odoo instance to connect with. We will assume that you have the Odoo server running on <code>http://localhost:8017</code> and that you have installed the <code>my_hostel</code> module.</p>
			<h2 id="_idParaDest-859"><a id="_idTextAnchor1070"/>How to do it...</h2>
			<p>Perform <a id="_idIndexMarker1362"/>the following steps to carry out user authentication <a id="_idIndexMarker1363"/>through RPC:</p>
			<ol>
				<li>Add the <code>odoo_authenticate.py</code> file. You can place this file anywhere you want <a id="_idIndexMarker1364"/>because the RPC program will work independently.</li>
				<li>Add <a id="_idIndexMarker1365"/>the following code to the file:<pre class="source-code">
from xmlrpc import client
server_url = 'http://localhost:8017'
db_name = 'cookbook_17e'
username = 'admin'
password = 'admin'
common = client.ServerProxy('%s/xmlrpc/2/common' % server_url)
user_id = common.authenticate(db_name, username, password, {})
if user_id:
    print("Success: User id is", user_id)
else:
    print("Failed: wrong credentials")</pre></li>				<li>Run the following Python script from the Terminal with the following command:<pre class="source-code">
<strong class="bold">python3 odoo_authenticate.py</strong></pre></li>			</ol>
			<p>This will print a success message with the user ID if you have provided a valid login name and password.</p>
			<h2 id="_idParaDest-860"><a id="_idTextAnchor1071"/>How it works...</h2>
			<p>In this recipe, we used the Python <code>xmlrpc</code> library to access Odoo instances through XML-RPC. This is <a id="_idIndexMarker1366"/>a standard Python library, and you do <a id="_idIndexMarker1367"/>not have to install anything else to use it.</p>
			<p>For authentication, Odoo provides XML-RPC on the <code>/xmlrpc/2/common</code> endpoint. This endpoint <a id="_idIndexMarker1368"/>is used for meta methods, which do <a id="_idIndexMarker1369"/>not require authentication. The <code>authentication()</code> method itself is a public method, so it can be called publicly. The <code>authentication()</code> method accepts four arguments—database name, username, password, and user agent environment. The user agent environment is a compulsory argument, but if you do not want to pass the user agent parameter, at least pass the empty dictionary.</p>
			<p>When you execute the <code>authenticate()</code> method with all valid arguments, it will make a call to the Odoo server and perform authentication. It will then return the user ID, provided the given login ID and password are correct. It will return <code>False</code> if the user is not present or if the password is incorrect.</p>
			<p>You need to use the <code>authenticate()</code> method before accessing any data through RPC. This is because accessing data with the wrong credentials will generate an error.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Odoo’s online instances <code>(*.odoo.com</code>) use OAuth authentication, so the local password is not set on the instance. To use XML-RPC on these instances, you will need to set the user’s password manually from the <strong class="bold">Settings</strong> | <strong class="bold">Users</strong> | <strong class="bold">Users</strong> menu of your instance.</p>
			<p>Additionally, the methods used to access data require a user ID instead of a username, so the <code>authenticate()</code> method is needed to get the ID of the user.</p>
			<h2 id="_idParaDest-861"><a id="_idTextAnchor1072"/>There’s more...</h2>
			<p>The <code>/xmlrpc/2/common</code> endpoint provides one more method: <code>version()</code>. You can call this <a id="_idIndexMarker1370"/>method without credentials. It will return <a id="_idIndexMarker1371"/>the version information of the Odoo <a id="_idIndexMarker1372"/>instance. The following is an example of the <code>version()</code> method usage:</p>
			<pre class="source-code">
from xmlrpc import client
server_url = 'http://localhost:8017'
common = client.ServerProxy('%s/xmlrpc/2/common' % server_url)
version_info = common.version()
print(version_info)</pre>			<p>The <a id="_idIndexMarker1373"/>preceding program will generate the following output:</p>
			<pre class="console">
$ python3 version_info.py
{'server_version': '17.0+e', 'server_version_info': [17, 0, 0, 'final', 0, 'e'], 'server_serie': '17.0', 'protocol_version': 1}</pre>			<p>This program will print version information based on your server.</p>
			<h1 id="_idParaDest-862"><a id="_idTextAnchor1073"/>Searching/reading records using XML-RPC</h1>
			<p>In this recipe, we <a id="_idIndexMarker1374"/>will see how you can fetch the data <a id="_idIndexMarker1375"/>from an Odoo instance through RPC. The user can <a id="_idIndexMarker1376"/>access most data, except data that are <a id="_idIndexMarker1377"/>restricted by the security access control and record rules. RPC can be used in many situations, such as collecting data for analysis, manipulating a lot of data at once, or fetching data for display in another software/system. There are endless possibilities, and you can use RPCs whenever necessary.</p>
			<h2 id="_idParaDest-863"><a id="_idTextAnchor1074"/>Getting ready</h2>
			<p>We will create a Python program to fetch the room data from the <code>hostel.room</code> model. Make sure you have installed the <code>my_hostel</code> module and that the server is running on <code>http://localhost:8017</code>.</p>
			<h2 id="_idParaDest-864"><a id="_idTextAnchor1075"/>How to do it...</h2>
			<p>Perform <a id="_idIndexMarker1378"/>the following steps to fetch a room’s information <a id="_idIndexMarker1379"/>through RPC:</p>
			<ol>
				<li>Add the <code>rooms_data.py</code> file. You can place this file anywhere you want because <a id="_idIndexMarker1380"/>the RPC program will work independently.</li>
				<li>Add the <a id="_idIndexMarker1381"/>following code to the file:<pre class="source-code">
from xmlrpc import client
# room data with search method
server_url = 'http://localhost:8017'
db_name = 'cookbook_17e'
username = 'admin'
password = 'admin'
common = client.ServerProxy('%s/xmlrpc/2/common' % server_url)
user_id = common.authenticate(db_name, username, password, {})
models = client.ServerProxy('%s/xmlrpc/2/object' % server_url)
if user_id:
    search_domain = [['name', 'ilike', 'Standard']]
    rooms_ids = models.execute_kw(db_name, user_id, password,
        'hostel.room', 'search',
        [search_domain],
        {'limit': 5})
    print('Rooms ids found:', rooms_ids)
    rooms_data = models.execute_kw(db_name, user_id, password,
        'hostel.room', 'read',
        [rooms_ids, ['name', 'room_no']])
    print("Rooms data:", rooms_data)
else:
    print('Wrong credentials')</pre></li>				<li>Run the <a id="_idIndexMarker1382"/>Python script from the Terminal <a id="_idIndexMarker1383"/>with the following command:<pre class="source-code">
<strong class="bold">python3 rooms_data.py</strong></pre></li>			</ol>
			<p>The preceding <a id="_idIndexMarker1384"/>program will fetch the room data and <a id="_idIndexMarker1385"/>give you the following output:</p>
			<pre class="console">
$ python3 rooms_data.py
Rooms ids found: [1, 2, 3, 4, 5]
Rooms data: [{'id': 1, 'name': '8th Standard', 'room_no': '1'}, {'id': 2, 'name': '9th Standard', 'room_no': '2'}, {'id': 3, 'name': '10th Standard', 'room_no': '3'}, {'id': 4, 'name': '11th Standard', 'room_no': '4'}, {'id': 5, 'name': '12th Standard', 'room_no': '5'}]</pre>			<p>The output shown in the preceding screenshot is based on data in my database. The data in your Odoo instance may be different data, so the output will also be different.</p>
			<h2 id="_idParaDest-865"><a id="_idTextAnchor1076"/>How it works...</h2>
			<p>In order to <a id="_idIndexMarker1386"/>access the room data, you first have to authenticate. At <a id="_idIndexMarker1387"/>the beginning of the program, we did <a id="_idIndexMarker1388"/>authentication in the same way as we <a id="_idIndexMarker1389"/>did in the <em class="italic">Logging in to/connecting Odoo with XML-RPC</em> recipe earlier. If you provided valid credentials, the <code>authentication()</code> method will return the <code>id</code> of the user’s record. We will use this user ID to fetch the room data.</p>
			<p>The <code>/xmlrpc/2/object</code> endpoint is used for database operation. In our recipe, we used the <code>object</code> endpoint to fetch the room data. In contrast to the <code>/xmlrpc/2/common</code> endpoint, this endpoint does not work without credentials. With this endpoint, you can access the public method of any model through the <code>execute_kw()</code> method. <code>execute_kw()</code> takes the following arguments:</p>
			<ul>
				<li>Database name</li>
				<li>User ID (we get this from the <code>authenticate()</code> method)</li>
				<li>Password</li>
				<li>Model name, for example, <code>res.partner</code> or <code>hostel.room</code></li>
				<li>Method name, for example, <code>search</code>, <code>read</code>, or <code>create</code></li>
				<li>An array of positional arguments</li>
				<li>A dictionary for keyword arguments (optional)</li>
			</ul>
			<p>In our example, we want to fetch the room’s information. This can be done through a combination of <code>search()</code> and <code>read()</code>. Room information is stored in the <code>hostel.room</code> model, so in <code>execute_kw()</code>, we use <code>hostel.room</code> as the model name and <code>search</code> as the method name. This will call the ORM’s <code>search</code> method and return record IDs. The only difference here is that the ORM’s <code>search</code> method returns a record set, while this search method returns a list of IDs.</p>
			<p>In <code>execute_kw()</code>, you can pass arguments and keyword arguments for the method provided. The <code>search()</code> method accepts a domain as a positional argument, so we passed a domain to filter rooms. The <code>search</code> method has other optional keyword arguments, such as <code>limit</code>, <code>offset</code>, <code>count</code>, and <code>order</code>, from which we have used the <code>limit</code> parameter to fetch only five records. This will return the list of room IDs whose names contain the <code>Standard</code> strings.</p>
			<p>However, we <a id="_idIndexMarker1390"/>need to fetch room data from the database. We <a id="_idIndexMarker1391"/>will use the <code>read</code> method to do this. The <code>read</code> method accepts a list of IDs and fields to complete the task. At the end of <em class="italic">step 3</em>, we used <a id="_idIndexMarker1392"/>the list of room IDs that we received <a id="_idIndexMarker1393"/>from the <code>search</code> method and then used the room IDs to fetch the <code>name</code> and <code>room_no</code> of the rooms. This will return the list of the dictionary with the room’s information.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Note that the arguments and keyword arguments passed in <code>execute_kw()</code> are based on the passed method. You can use any public ORM method via <code>execute_kw()</code>. You just need to give the method a name, the valid arguments, and the keyword arguments. These arguments are going to be passed on in the method in the ORM.</p>
			<h2 id="_idParaDest-866"><a id="_idTextAnchor1077"/>There’s more...</h2>
			<p>The data fetched through a combination of the <code>search()</code> and <code>read()</code> methods is slightly time-consuming because it will make two calls. <code>search_read</code> is an alternative method for fetching data. You can search and fetch the data in a single call. Here is the alternative way to fetch a room’s data with <code>search_read()</code>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The <code>read</code> and <code>search_read</code> methods will return <code>id</code> fields even if the <code>id</code> field is not requested. Furthermore, for the <code>many2one</code> field, you will get an array made up of the <code>id</code> and display name. For example, the <code>create_uid</code> <code>many2one</code> field will return data like this: <code>[07, '</code><code>Deepak ahir']</code>.</p>
			<p>It will <a id="_idIndexMarker1394"/>return the <a id="_idIndexMarker1395"/>same output <a id="_idIndexMarker1396"/>as in the previous <a id="_idIndexMarker1397"/>example:</p>
			<pre class="source-code">
from xmlrpc import client
# room data with search_read method
server_url = 'http://localhost:8017'
db_name = 'cookbook_17e'
username = 'admin'
password = 'admin'
common = client.ServerProxy('%s/xmlrpc/2/common' % server_url)
user_id = common.authenticate(db_name, username, password, {})
models = client.ServerProxy('%s/xmlrpc/2/object' % server_url)
if user_id:
    search_domain = [['name', 'ilike', 'Standard']]
    rooms_ids = models.execute_kw(db_name, user_id, password,
        'hostel.room', 'search_read',
        [search_domain, ['name', 'room_no']],
        {'limit': 5})
    print('Rooms data:', rooms_ids)
else:
    print('Wrong credentials')</pre>			<p>The <code>search_read</code> methods improve <a id="_idIndexMarker1398"/>performance <a id="_idIndexMarker1399"/>significantly as you get your result <a id="_idIndexMarker1400"/>in one RPC call, so use the <code>search_read</code> method <a id="_idIndexMarker1401"/>instead of a combination of the <code>search</code> and <code>read</code> methods.</p>
			<h1 id="_idParaDest-867"><a id="_idTextAnchor1078"/>Creating/updating/deleting records using XML-RPC</h1>
			<p>In the <a id="_idIndexMarker1402"/>previous <a id="_idIndexMarker1403"/>recipe, we <a id="_idIndexMarker1404"/>saw how to search and read <a id="_idIndexMarker1405"/>data through RPC. In this recipe, we will perform <a id="_idIndexMarker1406"/>the remaining <strong class="bold">CRUD</strong> operations through <a id="_idIndexMarker1407"/>RPC, which are <strong class="bold">create</strong>, <strong class="bold">update</strong> (write), and <strong class="bold">delete</strong> (unlink).</p>
			<h2 id="_idParaDest-868"><a id="_idTextAnchor1079"/>Getting ready</h2>
			<p>We will create the Python program to <code>create</code>, <code>write</code>, and <code>unlink</code> data in the <code>hostel.room</code> model. Make sure you have installed the <code>my_hostel</code> module and that the server is running on <code>http://localhost:8017</code>.</p>
			<h2 id="_idParaDest-869"><a id="_idTextAnchor1080"/>How to do it...</h2>
			<p>Perform the following steps to create, write, and update a room’s information through RPC:</p>
			<ol>
				<li>Add the <code>rooms_operation.py</code> file. You <a id="_idIndexMarker1408"/>can place <a id="_idIndexMarker1409"/>this file anywhere you want <a id="_idIndexMarker1410"/>because the <a id="_idIndexMarker1411"/>RPC program will work <a id="_idIndexMarker1412"/>independently.</li>
				<li>Add the <a id="_idIndexMarker1413"/>following code to the <code>rooms_operation.py</code> file:<pre class="source-code">
from xmlrpc import client
server_url = 'http://localhost:8017'
db_name = 'cookbook_17e'
username = 'admin'
password = 'admin'
common = client.ServerProxy('%s/xmlrpc/2/common' % server_url)
user_id = common.authenticate(db_name, username, password, {})
models = client.ServerProxy('%s/xmlrpc/2/object' % server_url)
if user_id:
    # create new room records.
    create_data = [
        {'name': 'Room 1', 'room_no': '101'},
        {'name': 'Room 3', 'room_no': '102'},
        {'name': 'Room 5', 'room_no': '103'},
        {'name': 'Room 7', 'room_no': '104'}
    ]
    rooms_ids = models.execute_kw(db_name, user_id, password,
        'hostel.room', 'create',
        [create_data])
    print("Rooms created:", rooms_ids)
    # Write in existing room record
    room_to_write = rooms_ids[1]  # We will use ids of recently created rooms
    write_data = {'name': 'Room 2'}
    written = models.execute_kw(db_name, user_id, password,
        'hostel.room', 'write',
        [room_to_write, write_data])
    print("Rooms written", written)
    # Delete the room record
    rooms_to_delete = rooms_ids[2:]
    deleted = models.execute_kw(db_name, user_id, password,
        'hostel.room', 'unlink',
        [rooms_to_delete])
    print('Rooms unlinked:', deleted)
else:
    print('Wrong credentials')</pre></li>				<li>Run the <a id="_idIndexMarker1414"/>Python script from the Terminal <a id="_idIndexMarker1415"/>with the given command:<pre class="source-code">
<strong class="bold">python3 rooms_operation.py</strong></pre></li>			</ol>
			<p>The preceding <a id="_idIndexMarker1416"/>program will create four records <a id="_idIndexMarker1417"/>of the rooms. Updating the data in the room <a id="_idIndexMarker1418"/>records and later deleting two records gives you <a id="_idIndexMarker1419"/>the following output (the IDs created may be different depending on your database):</p>
			<pre class="console">
$ python3 rooms_operation.py
Rooms created: [6, 7, 8, 9]
Rooms written True
Rooms unlinked: True</pre>			<p>The <code>write</code> and <code>unlink</code> methods return <code>True</code> if the operation is successful. This means that if you get <code>True</code> in response, assume that a record has been updated or deleted successfully.</p>
			<h2 id="_idParaDest-870"><a id="_idTextAnchor1081"/>How it works...</h2>
			<p>In this recipe, we performed <code>create</code>, <code>write</code>, and <code>delete</code> operations through XML-RPC. This operation also uses the <code>/xmlrpc/2/</code> object endpoint and the <code>execute_kw()</code> method.</p>
			<p>The <code>create()</code> method supports the creation of multiple records in a single call. In <em class="italic">step 2</em>, we first created a dictionary with the room’s information. Then, we used the room’s dictionary to create new records of the rooms through XML-RPC. The XML-RPC call needs two parameters to create new records: the <code>create</code> method name and the room data. This will create the four room records in the <code>hostel.room</code> model. In ORM, when you create the record, it returns a record set of created records, but if you create the record’s RPC, this will return a list of IDs.</p>
			<p>The <code>write</code> method works in a similar way to the <code>create</code> method. In the <code>write</code> method, you will need to pass a list of record IDs and the field values to be written. In our example, we updated the name of the room created in the first section. This will update the name of the second room from <code>Room 3</code> to <code>Room 2</code>. Here, we passed only one <code>id</code> for a room, but you can pass a list of IDs if you want to update multiple records in a single call.</p>
			<p>In the <a id="_idIndexMarker1420"/>third section of the program, we deleted <a id="_idIndexMarker1421"/>two rooms that we created in the first <a id="_idIndexMarker1422"/>section. You can delete records using the <code>unlink</code> method and a list of record IDs.</p>
			<p>After the <a id="_idIndexMarker1423"/>program is executed successfully, you will find <a id="_idIndexMarker1424"/>two room records in the database, as indicated in <em class="italic">Figure 20</em><em class="italic">.3</em>. In the <a id="_idIndexMarker1425"/>program, we have created four records, but we have also deleted two of them, so you will only find two new records in the database.</p>
			<h2 id="_idParaDest-871"><a id="_idTextAnchor1082"/>There’s more...</h2>
			<p>When you are performing a CRUD operation through RPC, this may generate an error if you don’t have permission to do that operation. With the <code>check_access_rights</code> method, you can check whether the user has the proper access rights to perform a certain operation. The <code>check_access_rights</code> method returns <code>True</code> or <code>False</code> values based on the access rights of the user. Here is an example showing whether a user has the right to create a room record:</p>
			<pre class="source-code">
from xmlrpc import client
server_url = 'http://localhost:8017'
db_name = 'cookbook_17e'
username = 'admin'
password = 'admin'
common = client.ServerProxy('%s/xmlrpc/2/common' % server_url)
user_id = common.authenticate(db_name, username, password, {})
models = client.ServerProxy('%s/xmlrpc/2/object' % server_url)
if user_id:
    has_access = models.execute_kw(db_name, user_id, password,
        'hostel.room', 'check_access_rights',
        ['create'], {'raise_exception': False})
    print('Has create access on room:', has_access)
else:
    print('Wrong credentials')
# Output: Has create access on room: True</pre>			<p>When <a id="_idIndexMarker1426"/>you are <a id="_idIndexMarker1427"/>doing <a id="_idIndexMarker1428"/>complex operations via RPC, the <code>check_access_rights</code> method <a id="_idIndexMarker1429"/>can be used <a id="_idIndexMarker1430"/>prior to performing the operation to make sure <a id="_idIndexMarker1431"/>you have proper access rights.</p>
			<h1 id="_idParaDest-872"><a id="_idTextAnchor1083"/>Calling methods using XML-RPC</h1>
			<p>With Odoo, the RPC <a id="_idIndexMarker1432"/>API is not limited to CRUD operations; you <a id="_idIndexMarker1433"/>can also invoke business methods. In this recipe, we will call the <code>make_available</code> method to change the room’s state.</p>
			<h2 id="_idParaDest-873"><a id="_idTextAnchor1084"/>Getting ready</h2>
			<p>We will create the Python program to call <code>make_available</code> on the <code>hostel.room</code> model. Make sure that you have installed the <code>my_hostel</code> module and that the server is running on <code>http://localhost:8017</code>.</p>
			<h2 id="_idParaDest-874"><a id="_idTextAnchor1085"/>How to do it...</h2>
			<p>Perform the <a id="_idIndexMarker1434"/>following steps to create, write, and update <a id="_idIndexMarker1435"/>a room’s information through RPC:</p>
			<ol>
				<li>Add the <code>rooms_method.py</code> file. You can place this file anywhere you want because the RPC program will work independently.</li>
				<li>Add the following code to the file:<pre class="source-code">
from xmlrpc import client
server_url = 'http://localhost:8017'
db_name = 'cookbook_17e'
username = 'admin'
password = 'admin'
common = client.ServerProxy('%s/xmlrpc/2/common' % server_url)
user_id = common.authenticate(db_name, username, password, {})
models = client.ServerProxy('%s/xmlrpc/2/object' % server_url)
if user_id:
    # Create room with state draft
    room_id = models.execute_kw(db_name, user_id, password,
        'hostel.room', 'create',
        [{
            'name': 'New Room',
            'room_no': '35',
            'state': 'draft'
        }])
    # Call make_available method on new room
    models.execute_kw(db_name, user_id, password,
        'hostel.room', 'make_available',
        [[room_id]])
    # check room status after method call
    room_data = models.execute_kw(db_name, user_id, password,
        'hostel.room', 'read',
        [[room_id], ['name', 'state']])
    print('Room state after method call:', room_data[0]['state'])
else:
    print('Wrong credentials')</pre></li>				<li>Run the <a id="_idIndexMarker1436"/>Python script from the Terminal with the <a id="_idIndexMarker1437"/>following command:<pre class="source-code">
<strong class="bold">python3 rooms_method.py</strong></pre></li>			</ol>
			<p>The preceding program will create one room using <code>draft</code> and then we will change the room’s state by calling the <code>make_available</code> method. After that, we will fetch the room data to check the room’s status, which will generate the following output:</p>
			<pre class="console">
$ python3 rooms_method.py
Room state after method call: available</pre>			<p>The program of this recipe will create a new room record and change the state of the room by calling the <code>model</code> method. By the end of the program, we have read the room record and printed the updated state.</p>
			<h2 id="_idParaDest-875"><a id="_idTextAnchor1086"/>How it works...</h2>
			<p>You can call any modal method from RPC. This helps you to perform business logic without <a id="_idIndexMarker1438"/>encountering any side effects. For example, you created the sales order from RPC and then called the <code>action_confirm</code> method of the <code>sale.order</code> method. This is equivalent to clicking <a id="_idIndexMarker1439"/>on the <strong class="bold">Confirm</strong> button on a sales order form.</p>
			<p>You can call any public method of the model, but you cannot call a private method from RPC. A method name that starts with <code>_</code> is called a private method, such as <code>_get_share_url()</code> and <code>_get_data()</code>.</p>
			<p>It is safe to use these methods, as they go through the ORM and follow all security rules. If the method is accessing unauthorized records, it will generate errors.</p>
			<p>In our example, we created a room with a state of <code>draft</code>. Then, we made one more RPC call to invoke the <code>make_available</code> method, which will change the room’s state to <code>available</code>. Finally, we made one more RPC call to check the state of the room. This will show that the room’s state has changed to <strong class="bold">Available</strong>, as indicated in <em class="italic">Figure 20</em><em class="italic">.4</em>.</p>
			<p>Methods that do not return anything internally return <code>None</code> by default. Such methods cannot be used from RPC. Consequently, if you want to use your method from RPC, at least add the return <code>True</code> statement.</p>
			<h2 id="_idParaDest-876"><a id="_idTextAnchor1087"/>There’s more...</h2>
			<p>If an exception is generated from a method, all of the operations performed in the transaction will be automatically rolled back to the initial state. This is only applicable to a single transaction (a single RPC call). For example, imagine you are making two RPC calls to the server, and an exception is generated during the second call. This will roll back the operation that was carried out during the second RPC call. The operation performed through the first RPC call won’t be rolled back. Consequently, you want to perform a complex operation through RPC. It is recommended that this be performed in a single RPC call by creating a method in the model.</p>
			<h1 id="_idParaDest-877"><a id="_idTextAnchor1088"/>Logging in to/connecting Odoo with JSON-RPC</h1>
			<p>Odoo <a id="_idIndexMarker1440"/>provides one more type of RPC API: JSON-RPC. As <a id="_idIndexMarker1441"/>its name suggests, JSON-RPC works <a id="_idIndexMarker1442"/>in the JSON format and uses the <code>jsonrpc</code> 2.0 <a id="_idIndexMarker1443"/>specification. In this recipe, we will see how you can log in with JSON-RPC. The Odoo web client itself uses JSON-RPC to fetch data from the server.</p>
			<h2 id="_idParaDest-878"><a id="_idTextAnchor1089"/>Getting ready</h2>
			<p>In this recipe, we will perform user authentication through JSON-RPC to check whether the given credentials are valid. Make sure you have installed the <code>my_hostel</code> module and that the server is running on <code>http://localhost:8017</code>.</p>
			<h2 id="_idParaDest-879"><a id="_idTextAnchor1090"/>How to do it...</h2>
			<p>Perform the following steps to perform user authentication through RPC:</p>
			<ol>
				<li>Add the <code>jsonrpc_authenticate.py</code> file. You can place this file anywhere you want because the RPC program will work independently.</li>
				<li>Add the following code to the file:<pre class="source-code">
import json
import random
import requests
server_url = 'http://localhost:8017'
db_name = 'cookbook_17e'
username = 'admin'
password = 'admin'
json_endpoint = "%s/jsonrpc" % server_url
headers = {"Content-Type": "application/json"}
def get_json_payload(service, method, *args):
    return json.dumps({
        "jsonrpc": "2.0",
        "method": 'call',
        "params": {
            "service": service,
            "method": method,
            "args": args
        },
        "id": random.randint(0, 1000000000),
    })
payload = get_json_payload("common", "login", db_name, username, password)
response = requests.post(json_endpoint, data=payload, headers=headers)
user_id = response.json()['result']
if user_id:
    print("Success: User id is", user_id)
else:
    print("Failed: wrong credentials")</pre></li>				<li>Run the Python script from the Terminal with the following command:<pre class="source-code">
<strong class="bold">python3 jsonrpc_authenticate.py</strong></pre></li>			</ol>
			<p>When you <a id="_idIndexMarker1444"/>run the preceding program, and you have <a id="_idIndexMarker1445"/>passed a valid login name and password, the program <a id="_idIndexMarker1446"/>will print a success message with <a id="_idIndexMarker1447"/>the <code>id</code> of the user, as follows:</p>
			<pre class="console">
$ python3 jsonrpc_authentication.py
Success: User id is 2</pre>			<p>The JSON authentication works just like XML-RPC, but it returns a result in the JSON format.</p>
			<h2 id="_idParaDest-880"><a id="_idTextAnchor1091"/>How it works...</h2>
			<p>JSON-RPC uses the JSON format to communicate with the server using the <code>/jsonrpc</code> endpoint. In our example, we used the Python requests package to make <code>POST</code> requests, but if you want to, you can use other packages, such as <code>urllib</code>.</p>
			<p>JSON-RPC only accepts a payload formatted in the <code>get_json_payload()</code> method. This method will prepare the payload in the valid JSON-RPC 2.0 format. This method accepts the <code>service</code> name and the <code>method</code> to call, and the remaining arguments will be placed in <code>*args</code>. We will be using this method in all subsequent recipes. JSON-RPC accepts requests in JSON format, and these requests are only accepted if the request contains a <code>{"Content-Type": "application/json"}</code> header. The results of the requests will be in JSON format.</p>
			<p>Like XML-RPC, all public methods, including login, come under the common service. For this reason, we passed <code>common</code> as a service and <code>login</code> as a method to prepare the JSON payload. The login method required some extra arguments, so we passed the database name, username, and password. Then, we made the <code>POST</code> request to the JSON endpoint with the payload and headers. If you passed the correct username and password, the method returns the user ID. The response will be in JSON format, and you will get the result in the result key.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Note that the <code>get_json_payload()</code> method created in this recipe is used to remove <a id="_idIndexMarker1448"/>repetitive code from the example. It is not compulsory to use it, so feel free to apply your own adaptations.</p>
			<h2 id="_idParaDest-881"><a id="_idTextAnchor1092"/>There’s more...</h2>
			<p>Like XML-RPC, the version method is also available in JSON-RPC. This version of the method <a id="_idIndexMarker1449"/>comes under the common service and is accessible <a id="_idIndexMarker1450"/>publicly. You can get version information <a id="_idIndexMarker1451"/>without login information. See the following <a id="_idIndexMarker1452"/>example showing how to fetch the version info of the Odoo server:</p>
			<pre class="source-code">
import json
import random
import requests
server_url = 'http://localhost:8017'
db_name = 'cookbook_17e'
username = 'admin'
password = 'admin'
json_endpoint = "%s/jsonrpc" % server_url
headers = {"Content-Type": "application/json"}
def get_json_payload(service, method, *args):
    return json.dumps({
        "jsonrpc": "2.0",
        "method": 'call',
        "params": {
            "service": service,
            "method": method,
            "args": args
        },
        "id": random.randint(0, 1000000000),
    })
payload = get_json_payload("common", "version")
response = requests.post(json_endpoint, data=payload, headers=headers)
print(response.json())</pre>			<p>This <a id="_idIndexMarker1453"/>program <a id="_idIndexMarker1454"/>will <a id="_idIndexMarker1455"/>display <a id="_idIndexMarker1456"/>the following output:</p>
			<pre class="console">
$ python3 jsonrpc_version_info.py
{'jsonrpc': '2.0', 'id': 361274992, 'result': {'server_version': '17.0+e', 'server_version_info': [17, 0, 0, 'final', 0, 'e'], 'server_serie': '17.0', 'protocol_version': 1}}</pre>			<p>This program will print version information based on your server.</p>
			<h1 id="_idParaDest-882"><a id="_idTextAnchor1093"/>Fetching/searching records using JSON-RPC</h1>
			<p>In the previous <a id="_idIndexMarker1457"/>recipe, we saw how you can do authentication through <a id="_idIndexMarker1458"/>JSON-RPC. In this recipe, we <a id="_idIndexMarker1459"/>will see how you can fetch the data from <a id="_idIndexMarker1460"/>the Odoo instance with JSON-RPC.</p>
			<h2 id="_idParaDest-883"><a id="_idTextAnchor1094"/>Getting ready</h2>
			<p>In this recipe, we will fetch room information with JSON-RPC. Make sure you have installed the <code>my_hostel</code> module and that the server is running on <code>http://localhost:8017</code>.</p>
			<h2 id="_idParaDest-884"><a id="_idTextAnchor1095"/>How to do it...</h2>
			<p>Perform the following steps to fetch room data from the <code>hostel.room</code> model:</p>
			<ol>
				<li>Add the <code>jsonrpc_fetch_data.py</code> file. You can place this file anywhere you want because the RPC program will work independently.</li>
				<li>Add the following code to the file:<pre class="source-code">
# place authentication and get_json_payload methods (see first jsonrpc recipe)
if user_id:
    # search for the room's ids
    search_domain = [['name', 'ilike', 'Standard']]
    payload = get_json_payload("object", "execute_kw",
        db_name, user_id, password,
        'hostel.room', 'search', [search_domain], {'limit': 5})
    res = requests.post(json_endpoint, data=payload, headers=headers).json()
    print('Search Result:', res)  # ids will be in result keys
    # read data for rooms ids
    payload = get_json_payload("object", "execute_kw",
        db_name, user_id, password,
        'hostel.room', 'read', [res['result'], ['name', 'room_no']])
    res = requests.post(json_endpoint, data=payload, headers=headers).json()
    print('Rooms data:', res)
else:
    print("Failed: wrong credentials")</pre></li>				<li>Run the <a id="_idIndexMarker1461"/>Python script from the Terminal with <a id="_idIndexMarker1462"/>the following command:<pre class="source-code">
<strong class="bold">python3 json_fetch_data.py</strong></pre></li>			</ol>
			<p>The preceding <a id="_idIndexMarker1463"/>program will give you the following output. The <a id="_idIndexMarker1464"/>first RPC call will print the room’s ID, and the second one will print the information for the room’s ID:</p>
			<pre class="console">
$ python3 json_fetch_data.py
Search Result: {'jsonrpc': '2.0', 'id': 19247199, 'result': [1, 2, 3, 4, 5]}
Rooms data: {'jsonrpc': '2.0', 'id': 357582271, 'result': [{'id': 1, 'name': '8th Standard', 'room_no': '1'}, {'id': 2, 'name': '9th Standard', 'room_no': '2'}, {'id': 3, 'name': '10th Standard', 'room_no': '3'}, {'id': 4, 'name': '11th Standard', 'room_no': '4'}, {'id': 5, 'name': '12th Standard', 'room_no': '5'}]}</pre>			<p>The output shown in the preceding screenshot is based on data in my database. The data in your Odoo instance may be different data, so the output will also be different.</p>
			<h2 id="_idParaDest-885"><a id="_idTextAnchor1096"/>How it works...</h2>
			<p>In the <em class="italic">Logging in to/connecting Odoo with JSON-RPC</em> recipe, we saw that you can validate <code>username</code> and <code>password</code>. If the login details are correct, the RPC call will return <code>user_id</code>. You can then use this <code>user_id</code> to fetch the model’s data. Like XML-RPC, we need <a id="_idIndexMarker1465"/>to use the <code>search</code> and <code>read</code> combination to fetch the data from the model. To fetch the data, we <a id="_idIndexMarker1466"/>use <code>object</code> as a service and <code>execute_kw()</code> as the method. <code>execute_kw()</code> is the same method that we used in <a id="_idIndexMarker1467"/>XML-RPC for data, so it accepts the same <a id="_idIndexMarker1468"/>argument as follows:</p>
			<ul>
				<li>Database name</li>
				<li>User ID (we get this from the <code>authenticate()</code> method)</li>
				<li>Password</li>
				<li>Model name, for example, <code>res.partner</code> or <code>hostel.room</code></li>
				<li>Method name, for example, <code>search</code>, <code>read</code>, or <code>create</code></li>
				<li>An array of positional arguments (<code>args</code>)</li>
				<li>A dictionary for keyword arguments (<code>optional</code>) (<code>kwargs</code>)</li>
			</ul>
			<p>In our example, we called the <code>search</code> method first. The <code>execute_kw()</code> method usually takes mandatory arguments as positional arguments and optional arguments as keyword arguments. In the <code>search</code> method, <code>domain</code> is a mandatory argument, so we passed it in the list and passed the <code>optional</code> argument limit as the <code>keyword</code> argument (dictionary). You will get a response in JSON format, and in this recipe, the response of the <code>search()</code> method RPC will have the room’s IDs in the <code>result</code> key.</p>
			<p>In <em class="italic">step 2</em>, we made an RPC call using the <code>read</code> method. To read the room’s information, we <a id="_idIndexMarker1469"/>passed two positional arguments: the <a id="_idIndexMarker1470"/>list of room IDs and the list of fields <a id="_idIndexMarker1471"/>to fetch. This RPC call will return the room <a id="_idIndexMarker1472"/>information in JSON format, and you can access it in using the <code>result</code> key.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Instead of <code>execute_kw()</code>, you can use <code>execute</code> as the method. This does not support keyword arguments, so you need to pass all of the intermediate arguments if you want to pass some optional arguments.</p>
			<h2 id="_idParaDest-886"><a id="_idTextAnchor1097"/>There’s more...</h2>
			<p>Similar to XML-RPC, you <a id="_idIndexMarker1473"/>can use the <code>search_read()</code> method instead of the <code>search()</code> and <code>read()</code> method combination, as it is slightly time-consuming. Take a look at the following code:</p>
			<pre class="source-code">
# place authentication and get_json_payload methods (see first jsonrpc recipe)
if user_id:
    # search for the room's ids
    search_domain = [['name', 'ilike', 'Standard']]
    payload = get_json_payload("object", "execute_kw",
        db_name, user_id, password,
        'hostel.room', 'search_read', [search_domain, ['name', 'room_no']], {'limit': 5})
    res = requests.post(json_endpoint, data=payload, headers=headers).json()
    print('Rooms data:', res)
else:
    print("Failed: wrong credentials")</pre>			<p>The code <a id="_idIndexMarker1474"/>snippet is an alternative way of fetching room data with <code>search_read()</code>. It will return the same output as in the previous example.</p>
			<h1 id="_idParaDest-887"><a id="_idTextAnchor1098"/>Creating/updating/deleting records using JSON-RPC</h1>
			<p>In <a id="_idIndexMarker1475"/>the previous <a id="_idIndexMarker1476"/>recipe, we looked <a id="_idIndexMarker1477"/>at how to search and read <a id="_idIndexMarker1478"/>data through JSON-RPC. In this recipe, we <a id="_idIndexMarker1479"/>will perform the remaining <strong class="bold">CRUD</strong> operations <a id="_idIndexMarker1480"/>through RPC: <strong class="bold">create</strong>, <strong class="bold">update</strong> (write), and <strong class="bold">delete</strong> (unlink).</p>
			<h2 id="_idParaDest-888"><a id="_idTextAnchor1099"/>Getting ready</h2>
			<p>We will create a Python program to <code>create</code>, <code>write</code>, and <code>unlink</code> data in the <code>hostel.room</code> model. Make sure you have installed the <code>my_hostel</code> module and that the server is running on <code>http://localhost:8017</code>.</p>
			<h2 id="_idParaDest-889"><a id="_idTextAnchor1100"/>How to do it...</h2>
			<p>Perform the following steps to create, write, and unlink a room’s information through RPC:</p>
			<ol>
				<li>Add the <code>jsonrpc_operation.py</code> file. You can place this file anywhere you want because the RPC program will work independently.</li>
				<li>Add the following code to the file:<pre class="source-code">
# place authentication and get_json_payload method (see last recipe for more)
if user_id:
    # creates the room's records
    create_data = [
        {'name': 'Room 1', 'room_no': '201'},
        {'name': 'Room 3', 'room_no': '202'},
        {'name': 'Room 5', 'room_no': '205'},
        {'name': 'Room 7', 'room_no': '207'}
    ]
    payload = get_json_payload("object", "execute_kw", db_name, user_id, password, 'hostel.room', 'create', [create_data])
    res = requests.post(json_endpoint, data=payload, headers=headers).json()
    print("Rooms created:", res)
    rooms_ids = res['result']
    # Write in existing room record
    room_to_write = rooms_ids[1]  # We will use ids of recently created rooms
    write_data = {'name': 'Room 2'}
    payload = get_json_payload("object", "execute_kw", db_name, user_id, password, 'hostel.room', 'write', [room_to_write, write_data])
    res = requests.post(json_endpoint, data=payload, headers=headers).json()
    print("Rooms written:", res)
    # Delete in existing room record
    room_to_unlink = rooms_ids[2:]  # We will use ids of recently created rooms
    payload = get_json_payload("object", "execute_kw", db_name, user_id, password, 'hostel.room', 'unlink', [room_to_unlink])
    res = requests.post(json_endpoint, data=payload, headers=headers).json()
    print("Rooms deleted:", res)
else:
    print("Failed: wrong credentials")</pre></li>				<li>Run the <a id="_idIndexMarker1481"/>Python script from the Terminal with <a id="_idIndexMarker1482"/>the following command:<pre class="source-code">
<strong class="bold">python3 jsonrpc_operation.py</strong></pre></li>			</ol>
			<p>The <a id="_idIndexMarker1483"/>preceding program will create four rooms. Writing <a id="_idIndexMarker1484"/>one room and deleting two rooms gives you <a id="_idIndexMarker1485"/>the following output (the IDs created <a id="_idIndexMarker1486"/>may be different based on your database):</p>
			<pre class="console">
$ python3 jsonrpc_operation.py
Rooms created: {'jsonrpc': '2.0', 'id': 837186761, 'result': [43, 44, 45, 46]}
Rooms written: {'jsonrpc': '2.0', 'id': 317256710, 'result': True}
Rooms deleted: {'jsonrpc': '2.0', 'id': 978974378, 'result': True}</pre>			<p>The <code>write</code> and <code>unlink</code> methods return <code>True</code> if the operation is successful. This means that if you get <code>True</code> in response, assume that a record has been updated or deleted successfully.</p>
			<h2 id="_idParaDest-890"><a id="_idTextAnchor1101"/>How it works...</h2>
			<p><code>execute_kw()</code> is used for the <code>create</code>, <code>update</code>, and <code>delete</code> operations. From Odoo version 12, the <code>create</code> method supports the creation of multiple records. So, we prepared <a id="_idIndexMarker1487"/>the dictionary with information <a id="_idIndexMarker1488"/>from the four rooms. Then, we made the <a id="_idIndexMarker1489"/>JSON-RPC call with <code>hostel.room</code> as the model name and <code>create</code> as the method name. This will create <a id="_idIndexMarker1490"/>four room records in the database and return a JSON <a id="_idIndexMarker1491"/>response with the IDs of these newly <a id="_idIndexMarker1492"/>created rooms. In the next RPC calls, we want to use these IDs to make an RPC call for the <code>update</code> and <code>delete</code> operations, so we assign it to the <code>rooms_ids</code> variable.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Both JSON-RPC and XML-RPC generate an error when you try to create the record without providing values for the required field, so make sure you have added all the required fields to the <code>create</code> values.</p>
			<p>In the next RPC call, we used the <code>write</code> method to update the existing records. The <code>write</code> method accepts two positional arguments; the records to update and the values to write. In our example, we have updated the name of the room by using the ID of the second room from a created room’s IDs. This will change the name of the second room from <code>Room 3</code> to <code>Room 2</code>.</p>
			<p>Then, we made the last RPC call to delete two room records. To do so, we used the <code>unlink</code> method. The <code>unlink</code> method accepts only one argument, which is the ID of the records you want to delete. This RPC call will delete the last two rooms.</p>
			<h2 id="_idParaDest-891"><a id="_idTextAnchor1102"/>There’s more...</h2>
			<p>Like XML-RPC, you <a id="_idIndexMarker1493"/>can use the <code>check_access_rights</code> method in JSON-RPC to check whether you have access rights to perform the operation. This method requires two parameters: the model name and the operation name. In the following example, we check access rights for the <code>create</code> operation on the <code>hostel.room</code> model:</p>
			<pre class="source-code">
# place authentication and get_json_payload method (see last recipe for more)
if user_id:
    payload = get_json_payload("object", "execute_kw",
        db_name, user_id, password,
        'hostel.room', 'check_access_rights', ['create'])
    res = requests.post(json_endpoint, data=payload, headers=headers).json()
    print("Has create access:", res['result'])
else:
    print("Failed: wrong credentials")</pre>			<p>This program <a id="_idIndexMarker1494"/>will generate the following output:</p>
			<pre class="console">
$ python3 jsonrpc_access_rights.py
Has create access: True</pre>			<p>When you are performing complex operations via RPC, the use of the <code>check_access_rights</code> method can be used before performing an operation to make sure you have proper access rights.</p>
			<h1 id="_idParaDest-892"><a id="_idTextAnchor1103"/>Calling methods using JSON-RPC</h1>
			<p>In this recipe, we will <a id="_idIndexMarker1495"/>learn how to invoke a custom method <a id="_idIndexMarker1496"/>of the model through JSON-RPC. We will change the status of the room by calling the <code>make_available()</code> method.</p>
			<h2 id="_idParaDest-893"><a id="_idTextAnchor1104"/>Getting ready</h2>
			<p>We will create the Python program to call <code>make_available</code> on the <code>hostel.room</code> model. Make sure you have installed the <code>my_hostel</code> module and that the server is running on <code>http://localhost:8017</code>.</p>
			<h2 id="_idParaDest-894"><a id="_idTextAnchor1105"/>How to do it...</h2>
			<p>Perform the <a id="_idIndexMarker1497"/>following steps to create, write, and update a <a id="_idIndexMarker1498"/>room’s information through RPC:</p>
			<ol>
				<li>Add the <code>jsonrpc_method.py</code> file. You can place this file anywhere you want because the RPC program will work independently.</li>
				<li>Add the following code to the file:<pre class="source-code">
# place authentication and get_json_payload method (see last recipe for more)</pre></li>			</ol>
			<pre class="source-code">
if user_id:
    # Create the room record in draft state
    payload = get_json_payload("object", "execute_kw",
        db_name, user_id, password,
        'hostel.room', 'create', [{
            'name': 'Room 1',
            'room_no': '101',
            'state': 'draft'
        }])
    res = requests.post(json_endpoint, data=payload, headers=headers).json()
    print("Room created with id:", res['result'])
    room_id = res['result']
    # Change the room state by calling make_available method
    payload = get_json_payload("object", "execute_kw",
        db_name, user_id, password,
        'hostel.room', 'make_available', [room_id])
    res = requests.post(json_endpoint, data=payload, headers=headers).json()
    # Check the room status after method call
    payload = get_json_payload("object", "execute_kw",
        db_name, user_id, password,
        'hostel.room', 'read', [room_id, ['name', 'state']])
    res = requests.post(json_endpoint, data=payload, headers=headers).json()
    print("Room state after the method call:", res['result'])
else:
    print("Failed: wrong credentials")</pre>			<p>3.	Run the <a id="_idIndexMarker1499"/>Python script from the Terminal with the <a id="_idIndexMarker1500"/>following command:</p>
			<pre class="source-code">
<code>draft</code> and then we will change the room state by calling the <code>make_available</code> method. After that, we will fetch the room data to check the room’s status, which will generate the following output:</p>
			<pre class="console">
$ python3 jsonrpc_method.py
Room created with id: 53
Room state after the method call: [{'id': 53, 'name': 'Room 1', 'state': 'available'}]</pre>			<p>The program of this recipe will create a new room record and change the state of the room by calling the model method. By the end of the program, we will have read the room record and printed the updated state.</p>
			<h2 id="_idParaDest-895"><a id="_idTextAnchor1106"/>How it works...</h2>
			<p><code>execute_kw()</code> is capable of calling any public method of the model. As we saw in the <em class="italic">Calling methods through XML-RPC</em> recipe, public methods are those that have names that don’t start with <code>_</code> (underscore). Methods that start with <code>_</code> are private, and you cannot invoke them from JSON-RPC.</p>
			<p>In our example, we created a room with a state of <code>draft</code>. Then, we made one more RPC call to <a id="_idIndexMarker1501"/>invoke the <code>make_available</code> method, which will change the room’s state to <code>available</code>. Finally, we made <a id="_idIndexMarker1502"/>one more RPC call to check the state of the room. This will show that the room’s state has changed to <strong class="bold">Available</strong>, as seen in <em class="italic">Figure 20</em><em class="italic">.10</em>.</p>
			<p>Methods that do not return anything internally return <code>None</code> by default. Such methods cannot be used from RPC. Consequently, if you want to use your method from RPC, at least add the return <code>True</code> statement.</p>
			<h1 id="_idParaDest-896"><a id="_idTextAnchor1107"/>The OCA odoorpc library</h1>
			<p>The <code>odoorpc</code>. This <a id="_idIndexMarker1503"/>is available at <a href="https://github.com/OCA/odoorpc">https://github.com/OCA/odoorpc</a>. The <code>odoorpc</code> library provides a user-friendly syntax from <a id="_idIndexMarker1504"/>which to access Odoo data through RPC. It provides a similar a syntax similar to that of the server. In this recipe, we will see how you can use the <code>odoorpc</code> library to perform operations through RPC.</p>
			<h2 id="_idParaDest-897"><a id="_idTextAnchor1108"/>Getting ready</h2>
			<p>The <code>odoorpc</code> library is <a id="_idIndexMarker1505"/>registered on the Python package (<code>PyPI</code>) index. In order to use the library, you need to install it using the following command. You can use this in a separate virtual environment if you want:</p>
			<pre class="console">
pip install OdooRPC</pre>			<p>In this recipe, we will perform some basic operations using the <code>odoorpc</code> library. We will use the <code>hostel.room</code> model to perform these operations. Make sure you have installed the <code>my_hostel</code> module and that the server is running on <code>http://localhost:8017</code>.</p>
			<h2 id="_idParaDest-898"><a id="_idTextAnchor1109"/>How to do it...</h2>
			<p>Perform the following steps to create, write, and update a room’s information through RPC:</p>
			<ol>
				<li>Add the <code>odoorpc_hostel.py</code> file. You can place this file anywhere you want because the RPC program will work independently.</li>
				<li>Add the following code to the file:<pre class="source-code">
import odoorpc
db_name = 'cookbook_17e'
user_name = 'admin'
password = 'admin'
# Prepare the connection to the server
odoo = odoorpc.ODOO('localhost', port=8017)
odoo.login(db_name, user_name, password)  # login
# User information
user = odoo.env.user
print(user.name)             # name of the user connected
print(user.company_id.name)  # the name of user's company
print(user.email)            # the email of user
RoomModel = odoo.env['hostel.room']
search_domain = [['name', 'ilike', 'Standard']]
rooms_ids = RoomModel.search(search_domain, limit=5)
for room in RoomModel.browse(rooms_ids):
    print(room.name, room.room_no)
# create the room and update the state
room_id = RoomModel.create({
    'name': 'Test Room',
    'room_no': '103',
    'state': 'draft'
})
room = RoomModel.browse(room_id)
print("Room state before make_available:", room.state)
room.make_available()
room = RoomModel.browse(room_id)
print("Room state after make_available:", room.state)</pre></li>				<li>Run the <a id="_idIndexMarker1506"/>Python script from the Terminal with the following command:<pre class="source-code">
<strong class="bold">python3 odoorpc_hostel.py</strong></pre></li>			</ol>
			<p>The program will do the authentication, print user information, and perform an operation in the <code>hostel.room</code> model. It will generate the following output:</p>
			<pre class="console">
$ python3 odoorpc_hostel.py
Mitchell Admin
Packt publishing
admin@yourcompany.example.com
8th Standard 1
9th Standard 2
10th Standard 3
11th Standard 4
12th Standard 5
Room state before make_available: draft
Room state after make_available: available</pre>			<p>The preceding output is the result of several RPC calls. We have fetched user info, some room info, and we have changed the state of the room.</p>
			<h2 id="_idParaDest-899"><a id="_idTextAnchor1110"/>How it works...</h2>
			<p>After installing the <code>odoorpc</code> library, you can start using it straight away. To do so, you will need <a id="_idIndexMarker1507"/>to import the <code>odoorpc</code> package and then we will create the object of the <code>ODOO</code> class by passing the server URL and port. This will make the <code>/version_info</code> call to the server to check the connection. To log in, you need to use the <code>login()</code> method of the object. Here, you need to pass the <code>database </code><code>name</code>, <code>username</code>, and <code>password</code>.</p>
			<p>Upon successful login, you can access the user information at <code>odoo.env.user</code>. <code>odoorpc</code> provides a user-friendly version of RPC, so you can use this user object exactly like the record set in the server. In our example, we accessed the name, email, and company name from this user object.</p>
			<p>If you want to access the model registry, you can use the <code>odoo.env</code> object. You can call any model method on the model. Under the hood, the <code>odoorpc</code> library uses <code>jsonrpc</code>, so you can’t invoke any private model method name that starts with an <code>_</code>. In our example, we accessed the <code>hostel.room</code> model from the registry. After that, we called the <code>search</code> method with the <code>domain</code> and <code>limit</code> parameters. This will return the IDs of the rooms. By passing the room IDs to the <code>browse()</code> method, you can generate a record set for the <code>hostel.room</code> model.</p>
			<p>By the end of <a id="_idIndexMarker1508"/>the program, we will have created a new room and changed the room’s state by calling the <code>make_available()</code> method. If you look closely at the syntax of the program, you will see that it uses the same syntax as the server.</p>
			<h2 id="_idParaDest-900"><a id="_idTextAnchor1111"/>There’s more...</h2>
			<p>Although it provides a user-friendly syntax like the server, you can use the library just like the normal RPC syntax. To do so, you need to use the <code>odoo.execute</code> method with the model <a id="_idIndexMarker1509"/>name, method name, and arguments. Here is an example of reading some room information in the raw RPC syntax:</p>
			<pre class="source-code">
import odoorpc
db_name = 'cookbook_17e'
user_name = 'admin'
password = 'admin'
# Prepare the connection to the server
odoo = odoorpc.ODOO('localhost', port=8017)
odoo.login(db_name, user_name, password)  # login
rooms_info = odoo.execute('hostel.room', 'search_read',
    [['name', 'ilike', 'Standard']])
print(rooms_info)</pre>			<h2 id="_idParaDest-901"><a id="_idTextAnchor1112"/>See also</h2>
			<p>There are several other implementations of RPC libraries for Odoo, as follows:</p>
			<ul>
				<li><a href="https://github.com/akretion/ooor">https://github.com/akretion/ooor</a></li>
				<li><a href="https://github.com/OCA/odoorpc">https://github.com/OCA/odoorpc</a></li>
				<li><a href="https://github.com/odoo/openerp-client-lib">https://github.com/odoo/openerp-client-lib</a></li>
				<li><a href="http://pythonhosted.org/OdooRPC">http://pythonhosted.org/OdooRPC</a></li>
				<li><a href="https://github.com/abhishek-jaiswal/php-openerp-lib">https://github.com/abhishek-jaiswal/php-openerp-lib</a></li>
			</ul>
			<h1 id="_idParaDest-902"><a id="_idTextAnchor1113"/>Generating API keys</h1>
			<p>Odoo v17 has built-in <a id="_idIndexMarker1510"/>support for the <strong class="bold">two-factor authentication</strong> (<strong class="bold">2FA</strong>) feature. 2FA is an extra layer of security for user accounts and users need to enter a password and time-based code. If you have enabled 2FA, then you <a id="_idIndexMarker1511"/>won’t be able to use RPC by entering your user ID and password. To fix this, you will need to generate an API key for the user. In this recipe, we will see how you can generate API keys.</p>
			<h2 id="_idParaDest-903"><a id="_idTextAnchor1114"/>How to do it...</h2>
			<p>Perform the following steps to generate an API key for RPC:</p>
			<ol>
				<li>Open user preferences and open the <strong class="bold">Account </strong><strong class="bold">Security</strong> tab.</li>
				<li>Click on the <strong class="bold">New API </strong><strong class="bold">Key</strong> button:</li>
			</ol>
			<div><div><img src="img/B20997_20_01.jpg" alt="Figure 20.1 – Generating a new API key"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 20.1 – Generating a new API key</p>
			<ol>
				<li value="3">It will open <a id="_idIndexMarker1512"/>a popup, as in the following screenshot. Enter the API key name and click on the <strong class="bold">Generate </strong><strong class="bold">key</strong> button:</li>
			</ol>
			<div><div><img src="img/B20997_20_02.jpg" alt="Figure 20.2 – Naming your key"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 20.2 – Naming your key</p>
			<ol>
				<li value="4">This will generate the API key and show it in a new popup. Note down the API key because <a id="_idIndexMarker1513"/>you will need this again:</li>
			</ol>
			<div><div><img src="img/B20997_20_03.jpg" alt="Figure 20.3 – Noting the generated API key"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 20.3 – Noting the generated API key</p>
			<p>Once the API key is generated, you can start using the API key for RPC in the same way as the normal password.</p>
			<h2 id="_idParaDest-904"><a id="_idTextAnchor1115"/>How it works…</h2>
			<p>Using API keys is straightforward. However, there are a few things that you need to take care of. The API keys are generated per user, and if you want to utilize RPC for multiple users, you will need to generate an API key for each user. Additionally, the API key for a user will have the same access rights as the user would have, so if someone gains access to the key, they can perform all the operations that the user can. So, you need to keep the API key secret.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">When you <a id="_idIndexMarker1514"/>generate the API key, it is displayed only once. You need to note down the key. If you lose it, there is no way to get it back. In such cases, you would need to delete the API key and generate a new one.</p>
			<p>Using the API <a id="_idTextAnchor1116"/>key is very simple. During RPC calls, you just need to use the API key instead of the user password. You will be able to call RPC even if 2FA is activated.</p>
		</div>
	</body></html>