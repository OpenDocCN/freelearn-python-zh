<html><head></head><body>
		<div id="_idContainer195">
			<h1 id="_idParaDest-854" class="chapter-number"><a id="_idTextAnchor1065"/>20</h1>
			<h1 id="_idParaDest-855"><a id="_idTextAnchor1066"/>Remote Procedure Calls in Odoo</h1>
			<p>The Odoo server supports <strong class="bold">remote procedure calls</strong> (<strong class="bold">RPCs</strong>), which means that you can connect <a id="_idIndexMarker1357"/>Odoo instances from external applications. An example is if you want to show the status of a delivery order in Fan Android application that is written in Java Here, you can fetch the delivery status from Odoo via RPC. With the Odoo RPC API, you can perform any CRUD operations on a database. Odoo RPC is not limited to CRUD operations; you can also invoke public methods of any model. Of course, you will need to have proper access to rights to perform these operations because RPC respects all of the access rights and record rules you have defined in your database. Consequently, it is very safe to use because the RPC respects all access rights and record rules. Odoo RPC is not platform-dependent, so you can use it on any platform, including Odoo.sh, online, or self-hosted platforms. Odoo RPC can be used with any programming language, so you can integrate Odoo with any <span class="No-Break">external application.</span></p>
			<p>Odoo provides two types of RPC API: XML-RPC and JSON-RPC. In this chapter, we will learn how to use these RPCs from an external program. Finally, you will learn how to use Odoo RPC through OCA’s <span class="No-Break"><strong class="source-inline">odoorpc</strong></span><span class="No-Break"> library.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following recipes:</span></p>
			<ul>
				<li>Logging in to/connecting Odoo <span class="No-Break">with XML-RPC</span></li>
				<li>Searching/reading records <span class="No-Break">using XML-RPC</span></li>
				<li>Creating/updating/deleting records <span class="No-Break">using XML-RPC</span></li>
				<li>Calling methods <span class="No-Break">using XML-RPC</span></li>
				<li>Logging in to/connecting Odoo <span class="No-Break">with JSON-RPC</span></li>
				<li>Fetching/searching records <span class="No-Break">using JSON-RPC</span></li>
				<li>Creating/updating/deleting records <span class="No-Break">using JSON-RPC</span></li>
				<li>Calling methods <span class="No-Break">using JSON-RPC</span></li>
				<li>The OCA <span class="No-Break">odoorpc library</span></li>
				<li>Generating <span class="No-Break">API keys</span></li>
			</ul>
			<h1 id="_idParaDest-856"><a id="_idTextAnchor1067"/>Technical requirements</h1>
			<p>In this chapter, we will be using the <strong class="source-inline">my_hostel</strong> module, which we created in <a href="B20997_19.xhtml#_idTextAnchor1030"><span class="No-Break"><em class="italic">Chapter 19</em></span></a>, <em class="italic">Managing, Deploying, and Testing with Odoo.sh</em>. You can find the same initial <strong class="source-inline">my_hostel</strong> module in the GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter20"><span class="No-Break">https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter20</span></a><span class="No-Break">.</span></p>
			<p>Here, we will not Introduce a new language as you may not be familiar with it. We will continue using Python to access the RPC API. You can use another language if you want to, as the same procedure can be applied in any language to access <span class="No-Break">the RPC.</span></p>
			<p>To connect Odoo through the RPC, you will need a running Odoo instance to connect with. Throughout this chapter, we will assume that you have the Odoo server running on <strong class="source-inline">http://localhost:8017</strong>, that you called the <strong class="source-inline">cookbook_17e</strong> database, and that you have installed the <strong class="source-inline">my_hostel</strong> module therein. Note that you can connect any valid IP or domain through <span class="No-Break">the RPC.</span></p>
			<h1 id="_idParaDest-857"><a id="_idTextAnchor1068"/>Logging in to/connecting Odoo with XML-RPC</h1>
			<p>In this <a id="_idIndexMarker1358"/>recipe, we will carry out user authentication through <a id="_idIndexMarker1359"/>RPC to check whether the credentials (server_url, db_name, username, and password) supplied <span class="No-Break">are valid.</span></p>
			<h2 id="_idParaDest-858"><a id="_idTextAnchor1069"/>Getting ready</h2>
			<p>To connect <a id="_idIndexMarker1360"/>an Odoo instance through RPC, you will <a id="_idIndexMarker1361"/>need a running Odoo instance to connect with. We will assume that you have the Odoo server running on <strong class="source-inline">http://localhost:8017</strong> and that you have installed the <span class="No-Break"><strong class="source-inline">my_hostel</strong></span><span class="No-Break"> module.</span></p>
			<h2 id="_idParaDest-859"><a id="_idTextAnchor1070"/>How to do it...</h2>
			<p>Perform <a id="_idIndexMarker1362"/>the following steps to carry out user authentication <a id="_idIndexMarker1363"/><span class="No-Break">through RPC:</span></p>
			<ol>
				<li>Add the <strong class="source-inline">odoo_authenticate.py</strong> file. You can place this file anywhere you want <a id="_idIndexMarker1364"/>because the RPC program will <span class="No-Break">work independently.</span></li>
				<li>Add <a id="_idIndexMarker1365"/>the following code to <span class="No-Break">the file:</span><pre class="source-code">
from xmlrpc import client
server_url = 'http://localhost:8017'
db_name = 'cookbook_17e'
username = 'admin'
password = 'admin'
common = client.ServerProxy('%s/xmlrpc/2/common' % server_url)
user_id = common.authenticate(db_name, username, password, {})
if user_id:
    print("Success: User id is", user_id)
else:
    print("Failed: wrong credentials")</pre></li>				<li>Run the following Python script from the Terminal with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">python3 odoo_authenticate.py</strong></pre></li>			</ol>
			<p>This will print a success message with the user ID if you have provided a valid login name <span class="No-Break">and password.</span></p>
			<h2 id="_idParaDest-860"><a id="_idTextAnchor1071"/>How it works...</h2>
			<p>In this recipe, we used the Python <strong class="source-inline">xmlrpc</strong> library to access Odoo instances through XML-RPC. This is <a id="_idIndexMarker1366"/>a standard Python library, and you do <a id="_idIndexMarker1367"/>not have to install anything else to <span class="No-Break">use it.</span></p>
			<p>For authentication, Odoo provides XML-RPC on the <strong class="source-inline">/xmlrpc/2/common</strong> endpoint. This endpoint <a id="_idIndexMarker1368"/>is used for meta methods, which do <a id="_idIndexMarker1369"/>not require authentication. The <strong class="source-inline">authentication()</strong> method itself is a public method, so it can be called publicly. The <strong class="source-inline">authentication()</strong> method accepts four arguments—database name, username, password, and user agent environment. The user agent environment is a compulsory argument, but if you do not want to pass the user agent parameter, at least pass the <span class="No-Break">empty dictionary.</span></p>
			<p>When you execute the <strong class="source-inline">authenticate()</strong> method with all valid arguments, it will make a call to the Odoo server and perform authentication. It will then return the user ID, provided the given login ID and password are correct. It will return <strong class="source-inline">False</strong> if the user is not present or if the password <span class="No-Break">is incorrect.</span></p>
			<p>You need to use the <strong class="source-inline">authenticate()</strong> method before accessing any data through RPC. This is because accessing data with the wrong credentials will generate <span class="No-Break">an error.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Odoo’s online instances <strong class="source-inline">(*.odoo.com</strong>) use OAuth authentication, so the local password is not set on the instance. To use XML-RPC on these instances, you will need to set the user’s password manually from the <strong class="bold">Settings</strong> | <strong class="bold">Users</strong> | <strong class="bold">Users</strong> menu of <span class="No-Break">your instance.</span></p>
			<p>Additionally, the methods used to access data require a user ID instead of a username, so the <strong class="source-inline">authenticate()</strong> method is needed to get the ID of <span class="No-Break">the user.</span></p>
			<h2 id="_idParaDest-861"><a id="_idTextAnchor1072"/>There’s more...</h2>
			<p>The <strong class="source-inline">/xmlrpc/2/common</strong> endpoint provides one more method: <strong class="source-inline">version()</strong>. You can call this <a id="_idIndexMarker1370"/>method without credentials. It will return <a id="_idIndexMarker1371"/>the version information of the Odoo <a id="_idIndexMarker1372"/>instance. The following is an example of the <strong class="source-inline">version()</strong> <span class="No-Break">method usage:</span></p>
			<pre class="source-code">
from xmlrpc import client
server_url = 'http://localhost:8017'
common = client.ServerProxy('%s/xmlrpc/2/common' % server_url)
version_info = common.version()
print(version_info)</pre>			<p>The <a id="_idIndexMarker1373"/>preceding program will generate the <span class="No-Break">following output:</span></p>
			<pre class="console">
$ python3 version_info.py
{'server_version': '17.0+e', 'server_version_info': [17, 0, 0, 'final', 0, 'e'], 'server_serie': '17.0', 'protocol_version': 1}</pre>			<p>This program will print version information based on <span class="No-Break">your server.</span></p>
			<h1 id="_idParaDest-862"><a id="_idTextAnchor1073"/>Searching/reading records using XML-RPC</h1>
			<p>In this recipe, we <a id="_idIndexMarker1374"/>will see how you can fetch the data <a id="_idIndexMarker1375"/>from an Odoo instance through RPC. The user can <a id="_idIndexMarker1376"/>access most data, except data that are <a id="_idIndexMarker1377"/>restricted by the security access control and record rules. RPC can be used in many situations, such as collecting data for analysis, manipulating a lot of data at once, or fetching data for display in another software/system. There are endless possibilities, and you can use RPCs <span class="No-Break">whenever necessary.</span></p>
			<h2 id="_idParaDest-863"><a id="_idTextAnchor1074"/>Getting ready</h2>
			<p>We will create a Python program to fetch the room data from the <strong class="source-inline">hostel.room</strong> model. Make sure you have installed the <strong class="source-inline">my_hostel</strong> module and that the server is running <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">http://localhost:8017</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-864"><a id="_idTextAnchor1075"/>How to do it...</h2>
			<p>Perform <a id="_idIndexMarker1378"/>the following steps to fetch a room’s information <a id="_idIndexMarker1379"/><span class="No-Break">through RPC:</span></p>
			<ol>
				<li>Add the <strong class="source-inline">rooms_data.py</strong> file. You can place this file anywhere you want because <a id="_idIndexMarker1380"/>the RPC program will <span class="No-Break">work independently.</span></li>
				<li>Add the <a id="_idIndexMarker1381"/>following code to <span class="No-Break">the file:</span><pre class="source-code">
from xmlrpc import client
# room data with search method
server_url = 'http://localhost:8017'
db_name = 'cookbook_17e'
username = 'admin'
password = 'admin'
common = client.ServerProxy('%s/xmlrpc/2/common' % server_url)
user_id = common.authenticate(db_name, username, password, {})
models = client.ServerProxy('%s/xmlrpc/2/object' % server_url)
if user_id:
    search_domain = [['name', 'ilike', 'Standard']]
    rooms_ids = models.execute_kw(db_name, user_id, password,
        'hostel.room', 'search',
        [search_domain],
        {'limit': 5})
    print('Rooms ids found:', rooms_ids)
    rooms_data = models.execute_kw(db_name, user_id, password,
        'hostel.room', 'read',
        [rooms_ids, ['name', 'room_no']])
    print("Rooms data:", rooms_data)
else:
    print('Wrong credentials')</pre></li>				<li>Run the <a id="_idIndexMarker1382"/>Python script from the Terminal <a id="_idIndexMarker1383"/>with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">python3 rooms_data.py</strong></pre></li>			</ol>
			<p>The preceding <a id="_idIndexMarker1384"/>program will fetch the room data and <a id="_idIndexMarker1385"/>give you the <span class="No-Break">following output:</span></p>
			<pre class="console">
$ python3 rooms_data.py
Rooms ids found: [1, 2, 3, 4, 5]
Rooms data: [{'id': 1, 'name': '8th Standard', 'room_no': '1'}, {'id': 2, 'name': '9th Standard', 'room_no': '2'}, {'id': 3, 'name': '10th Standard', 'room_no': '3'}, {'id': 4, 'name': '11th Standard', 'room_no': '4'}, {'id': 5, 'name': '12th Standard', 'room_no': '5'}]</pre>			<p>The output shown in the preceding screenshot is based on data in my database. The data in your Odoo instance may be different data, so the output will also <span class="No-Break">be different.</span></p>
			<h2 id="_idParaDest-865"><a id="_idTextAnchor1076"/>How it works...</h2>
			<p>In order to <a id="_idIndexMarker1386"/>access the room data, you first have to authenticate. At <a id="_idIndexMarker1387"/>the beginning of the program, we did <a id="_idIndexMarker1388"/>authentication in the same way as we <a id="_idIndexMarker1389"/>did in the <em class="italic">Logging in to/connecting Odoo with XML-RPC</em> recipe earlier. If you provided valid credentials, the <strong class="source-inline">authentication()</strong> method will return the <strong class="source-inline">id</strong> of the user’s record. We will use this user ID to fetch the <span class="No-Break">room data.</span></p>
			<p>The <strong class="source-inline">/xmlrpc/2/object</strong> endpoint is used for database operation. In our recipe, we used the <strong class="source-inline">object</strong> endpoint to fetch the room data. In contrast to the <strong class="source-inline">/xmlrpc/2/common</strong> endpoint, this endpoint does not work without credentials. With this endpoint, you can access the public method of any model through the <strong class="source-inline">execute_kw()</strong> method. <strong class="source-inline">execute_kw()</strong> takes the <span class="No-Break">following arguments:</span></p>
			<ul>
				<li><span class="No-Break">Database name</span></li>
				<li>User ID (we get this from the <span class="No-Break"><strong class="source-inline">authenticate()</strong></span><span class="No-Break"> method)</span></li>
				<li><span class="No-Break">Password</span></li>
				<li>Model name, for example, <strong class="source-inline">res.partner</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">hostel.room</strong></span></li>
				<li>Method name, for example, <strong class="source-inline">search</strong>, <strong class="source-inline">read</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">create</strong></span></li>
				<li>An array of <span class="No-Break">positional arguments</span></li>
				<li>A dictionary for keyword <span class="No-Break">arguments (optional)</span></li>
			</ul>
			<p>In our example, we want to fetch the room’s information. This can be done through a combination of <strong class="source-inline">search()</strong> and <strong class="source-inline">read()</strong>. Room information is stored in the <strong class="source-inline">hostel.room</strong> model, so in <strong class="source-inline">execute_kw()</strong>, we use <strong class="source-inline">hostel.room</strong> as the model name and <strong class="source-inline">search</strong> as the method name. This will call the ORM’s <strong class="source-inline">search</strong> method and return record IDs. The only difference here is that the ORM’s <strong class="source-inline">search</strong> method returns a record set, while this search method returns a list <span class="No-Break">of IDs.</span></p>
			<p>In <strong class="source-inline">execute_kw()</strong>, you can pass arguments and keyword arguments for the method provided. The <strong class="source-inline">search()</strong> method accepts a domain as a positional argument, so we passed a domain to filter rooms. The <strong class="source-inline">search</strong> method has other optional keyword arguments, such as <strong class="source-inline">limit</strong>, <strong class="source-inline">offset</strong>, <strong class="source-inline">count</strong>, and <strong class="source-inline">order</strong>, from which we have used the <strong class="source-inline">limit</strong> parameter to fetch only five records. This will return the list of room IDs whose names contain the <span class="No-Break"><strong class="source-inline">Standard</strong></span><span class="No-Break"> strings.</span></p>
			<p>However, we <a id="_idIndexMarker1390"/>need to fetch room data from the database. We <a id="_idIndexMarker1391"/>will use the <strong class="source-inline">read</strong> method to do this. The <strong class="source-inline">read</strong> method accepts a list of IDs and fields to complete the task. At the end of <em class="italic">step 3</em>, we used <a id="_idIndexMarker1392"/>the list of room IDs that we received <a id="_idIndexMarker1393"/>from the <strong class="source-inline">search</strong> method and then used the room IDs to fetch the <strong class="source-inline">name</strong> and <strong class="source-inline">room_no</strong> of the rooms. This will return the list of the dictionary with the <span class="No-Break">room’s information.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Note that the arguments and keyword arguments passed in <strong class="source-inline">execute_kw()</strong> are based on the passed method. You can use any public ORM method via <strong class="source-inline">execute_kw()</strong>. You just need to give the method a name, the valid arguments, and the keyword arguments. These arguments are going to be passed on in the method in <span class="No-Break">the ORM.</span></p>
			<h2 id="_idParaDest-866"><a id="_idTextAnchor1077"/>There’s more...</h2>
			<p>The data fetched through a combination of the <strong class="source-inline">search()</strong> and <strong class="source-inline">read()</strong> methods is slightly time-consuming because it will make two calls. <strong class="source-inline">search_read</strong> is an alternative method for fetching data. You can search and fetch the data in a single call. Here is the alternative way to fetch a room’s data <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">search_read()</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The <strong class="source-inline">read</strong> and <strong class="source-inline">search_read</strong> methods will return <strong class="source-inline">id</strong> fields even if the <strong class="source-inline">id</strong> field is not requested. Furthermore, for the <strong class="source-inline">many2one</strong> field, you will get an array made up of the <strong class="source-inline">id</strong> and display name. For example, the <strong class="source-inline">create_uid</strong> <strong class="source-inline">many2one</strong> field will return data like this: <strong class="source-inline">[07, '</strong><span class="No-Break"><strong class="source-inline">Deepak ahir']</strong></span><span class="No-Break">.</span></p>
			<p>It will <a id="_idIndexMarker1394"/>return the <a id="_idIndexMarker1395"/>same output <a id="_idIndexMarker1396"/>as in the <span class="No-Break">previous </span><span class="No-Break"><a id="_idIndexMarker1397"/></span><span class="No-Break">example:</span></p>
			<pre class="source-code">
from xmlrpc import client
# room data with search_read method
server_url = 'http://localhost:8017'
db_name = 'cookbook_17e'
username = 'admin'
password = 'admin'
common = client.ServerProxy('%s/xmlrpc/2/common' % server_url)
user_id = common.authenticate(db_name, username, password, {})
models = client.ServerProxy('%s/xmlrpc/2/object' % server_url)
if user_id:
    search_domain = [['name', 'ilike', 'Standard']]
    rooms_ids = models.execute_kw(db_name, user_id, password,
        'hostel.room', 'search_read',
        [search_domain, ['name', 'room_no']],
        {'limit': 5})
    print('Rooms data:', rooms_ids)
else:
    print('Wrong credentials')</pre>			<p>The <strong class="source-inline">search_read</strong> methods improve <a id="_idIndexMarker1398"/>performance <a id="_idIndexMarker1399"/>significantly as you get your result <a id="_idIndexMarker1400"/>in one RPC call, so use the <strong class="source-inline">search_read</strong> method <a id="_idIndexMarker1401"/>instead of a combination of the <strong class="source-inline">search</strong> and <span class="No-Break"><strong class="source-inline">read</strong></span><span class="No-Break"> methods.</span></p>
			<h1 id="_idParaDest-867"><a id="_idTextAnchor1078"/>Creating/updating/deleting records using XML-RPC</h1>
			<p>In the <a id="_idIndexMarker1402"/>previous <a id="_idIndexMarker1403"/>recipe, we <a id="_idIndexMarker1404"/>saw how to search and read <a id="_idIndexMarker1405"/>data through RPC. In this recipe, we will perform <a id="_idIndexMarker1406"/>the remaining <strong class="bold">CRUD</strong> operations through <a id="_idIndexMarker1407"/>RPC, which are <strong class="bold">create</strong>, <strong class="bold">update</strong> (write), and <span class="No-Break"><strong class="bold">delete</strong></span><span class="No-Break"> (unlink).</span></p>
			<h2 id="_idParaDest-868"><a id="_idTextAnchor1079"/>Getting ready</h2>
			<p>We will create the Python program to <strong class="source-inline">create</strong>, <strong class="source-inline">write</strong>, and <strong class="source-inline">unlink</strong> data in the <strong class="source-inline">hostel.room</strong> model. Make sure you have installed the <strong class="source-inline">my_hostel</strong> module and that the server is running <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">http://localhost:8017</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-869"><a id="_idTextAnchor1080"/>How to do it...</h2>
			<p>Perform the following steps to create, write, and update a room’s information <span class="No-Break">through RPC:</span></p>
			<ol>
				<li>Add the <strong class="source-inline">rooms_operation.py</strong> file. You <a id="_idIndexMarker1408"/>can place <a id="_idIndexMarker1409"/>this file anywhere you want <a id="_idIndexMarker1410"/>because the <a id="_idIndexMarker1411"/>RPC program will <span class="No-Break">work </span><span class="No-Break"><a id="_idIndexMarker1412"/></span><span class="No-Break">independently.</span></li>
				<li>Add the <a id="_idIndexMarker1413"/>following code to the <span class="No-Break"><strong class="source-inline">rooms_operation.py</strong></span><span class="No-Break"> file:</span><pre class="source-code">
from xmlrpc import client
server_url = 'http://localhost:8017'
db_name = 'cookbook_17e'
username = 'admin'
password = 'admin'
common = client.ServerProxy('%s/xmlrpc/2/common' % server_url)
user_id = common.authenticate(db_name, username, password, {})
models = client.ServerProxy('%s/xmlrpc/2/object' % server_url)
if user_id:
    # create new room records.
    create_data = [
        {'name': 'Room 1', 'room_no': '101'},
        {'name': 'Room 3', 'room_no': '102'},
        {'name': 'Room 5', 'room_no': '103'},
        {'name': 'Room 7', 'room_no': '104'}
    ]
    rooms_ids = models.execute_kw(db_name, user_id, password,
        'hostel.room', 'create',
        [create_data])
    print("Rooms created:", rooms_ids)
    # Write in existing room record
    room_to_write = rooms_ids[1]  # We will use ids of recently created rooms
    write_data = {'name': 'Room 2'}
    written = models.execute_kw(db_name, user_id, password,
        'hostel.room', 'write',
        [room_to_write, write_data])
    print("Rooms written", written)
    # Delete the room record
    rooms_to_delete = rooms_ids[2:]
    deleted = models.execute_kw(db_name, user_id, password,
        'hostel.room', 'unlink',
        [rooms_to_delete])
    print('Rooms unlinked:', deleted)
else:
    print('Wrong credentials')</pre></li>				<li>Run the <a id="_idIndexMarker1414"/>Python script from the Terminal <a id="_idIndexMarker1415"/>with the <span class="No-Break">given command:</span><pre class="source-code">
<strong class="bold">python3 rooms_operation.py</strong></pre></li>			</ol>
			<p>The preceding <a id="_idIndexMarker1416"/>program will create four records <a id="_idIndexMarker1417"/>of the rooms. Updating the data in the room <a id="_idIndexMarker1418"/>records and later deleting two records gives you <a id="_idIndexMarker1419"/>the following output (the IDs created may be different depending on <span class="No-Break">your database):</span></p>
			<pre class="console">
$ python3 rooms_operation.py
Rooms created: [6, 7, 8, 9]
Rooms written True
Rooms unlinked: True</pre>			<p>The <strong class="source-inline">write</strong> and <strong class="source-inline">unlink</strong> methods return <strong class="source-inline">True</strong> if the operation is successful. This means that if you get <strong class="source-inline">True</strong> in response, assume that a record has been updated or <span class="No-Break">deleted successfully.</span></p>
			<h2 id="_idParaDest-870"><a id="_idTextAnchor1081"/>How it works...</h2>
			<p>In this recipe, we performed <strong class="source-inline">create</strong>, <strong class="source-inline">write</strong>, and <strong class="source-inline">delete</strong> operations through XML-RPC. This operation also uses the <strong class="source-inline">/xmlrpc/2/</strong> object endpoint and the <span class="No-Break"><strong class="source-inline">execute_kw()</strong></span><span class="No-Break"> method.</span></p>
			<p>The <strong class="source-inline">create()</strong> method supports the creation of multiple records in a single call. In <em class="italic">step 2</em>, we first created a dictionary with the room’s information. Then, we used the room’s dictionary to create new records of the rooms through XML-RPC. The XML-RPC call needs two parameters to create new records: the <strong class="source-inline">create</strong> method name and the room data. This will create the four room records in the <strong class="source-inline">hostel.room</strong> model. In ORM, when you create the record, it returns a record set of created records, but if you create the record’s RPC, this will return a list <span class="No-Break">of IDs.</span></p>
			<p>The <strong class="source-inline">write</strong> method works in a similar way to the <strong class="source-inline">create</strong> method. In the <strong class="source-inline">write</strong> method, you will need to pass a list of record IDs and the field values to be written. In our example, we updated the name of the room created in the first section. This will update the name of the second room from <strong class="source-inline">Room 3</strong> to <strong class="source-inline">Room 2</strong>. Here, we passed only one <strong class="source-inline">id</strong> for a room, but you can pass a list of IDs if you want to update multiple records in a <span class="No-Break">single call.</span></p>
			<p>In the <a id="_idIndexMarker1420"/>third section of the program, we deleted <a id="_idIndexMarker1421"/>two rooms that we created in the first <a id="_idIndexMarker1422"/>section. You can delete records using the <strong class="source-inline">unlink</strong> method and a list of <span class="No-Break">record IDs.</span></p>
			<p>After the <a id="_idIndexMarker1423"/>program is executed successfully, you will find <a id="_idIndexMarker1424"/>two room records in the database, as indicated in <span class="No-Break"><em class="italic">Figure 20</em></span><em class="italic">.3</em>. In the <a id="_idIndexMarker1425"/>program, we have created four records, but we have also deleted two of them, so you will only find two new records in <span class="No-Break">the database.</span></p>
			<h2 id="_idParaDest-871"><a id="_idTextAnchor1082"/>There’s more...</h2>
			<p>When you are performing a CRUD operation through RPC, this may generate an error if you don’t have permission to do that operation. With the <strong class="source-inline">check_access_rights</strong> method, you can check whether the user has the proper access rights to perform a certain operation. The <strong class="source-inline">check_access_rights</strong> method returns <strong class="source-inline">True</strong> or <strong class="source-inline">False</strong> values based on the access rights of the user. Here is an example showing whether a user has the right to create a <span class="No-Break">room record:</span></p>
			<pre class="source-code">
from xmlrpc import client
server_url = 'http://localhost:8017'
db_name = 'cookbook_17e'
username = 'admin'
password = 'admin'
common = client.ServerProxy('%s/xmlrpc/2/common' % server_url)
user_id = common.authenticate(db_name, username, password, {})
models = client.ServerProxy('%s/xmlrpc/2/object' % server_url)
if user_id:
    has_access = models.execute_kw(db_name, user_id, password,
        'hostel.room', 'check_access_rights',
        ['create'], {'raise_exception': False})
    print('Has create access on room:', has_access)
else:
    print('Wrong credentials')
# Output: Has create access on room: True</pre>			<p>When <a id="_idIndexMarker1426"/>you are <a id="_idIndexMarker1427"/>doing <a id="_idIndexMarker1428"/>complex operations via RPC, the <strong class="source-inline">check_access_rights</strong> method <a id="_idIndexMarker1429"/>can be used <a id="_idIndexMarker1430"/>prior to performing the operation to make sure <a id="_idIndexMarker1431"/>you have proper <span class="No-Break">access rights.</span></p>
			<h1 id="_idParaDest-872"><a id="_idTextAnchor1083"/>Calling methods using XML-RPC</h1>
			<p>With Odoo, the RPC <a id="_idIndexMarker1432"/>API is not limited to CRUD operations; you <a id="_idIndexMarker1433"/>can also invoke business methods. In this recipe, we will call the <strong class="source-inline">make_available</strong> method to change the <span class="No-Break">room’s state.</span></p>
			<h2 id="_idParaDest-873"><a id="_idTextAnchor1084"/>Getting ready</h2>
			<p>We will create the Python program to call <strong class="source-inline">make_available</strong> on the <strong class="source-inline">hostel.room</strong> model. Make sure that you have installed the <strong class="source-inline">my_hostel</strong> module and that the server is running <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">http://localhost:8017</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-874"><a id="_idTextAnchor1085"/>How to do it...</h2>
			<p>Perform the <a id="_idIndexMarker1434"/>following steps to create, write, and update <a id="_idIndexMarker1435"/>a room’s information <span class="No-Break">through RPC:</span></p>
			<ol>
				<li>Add the <strong class="source-inline">rooms_method.py</strong> file. You can place this file anywhere you want because the RPC program will <span class="No-Break">work independently.</span></li>
				<li>Add the following code to <span class="No-Break">the file:</span><pre class="source-code">
from xmlrpc import client
server_url = 'http://localhost:8017'
db_name = 'cookbook_17e'
username = 'admin'
password = 'admin'
common = client.ServerProxy('%s/xmlrpc/2/common' % server_url)
user_id = common.authenticate(db_name, username, password, {})
models = client.ServerProxy('%s/xmlrpc/2/object' % server_url)
if user_id:
    # Create room with state draft
    room_id = models.execute_kw(db_name, user_id, password,
        'hostel.room', 'create',
        [{
            'name': 'New Room',
            'room_no': '35',
            'state': 'draft'
        }])
    # Call make_available method on new room
    models.execute_kw(db_name, user_id, password,
        'hostel.room', 'make_available',
        [[room_id]])
    # check room status after method call
    room_data = models.execute_kw(db_name, user_id, password,
        'hostel.room', 'read',
        [[room_id], ['name', 'state']])
    print('Room state after method call:', room_data[0]['state'])
else:
    print('Wrong credentials')</pre></li>				<li>Run the <a id="_idIndexMarker1436"/>Python script from the Terminal with the <a id="_idIndexMarker1437"/><span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">python3 rooms_method.py</strong></pre></li>			</ol>
			<p>The preceding program will create one room using <strong class="source-inline">draft</strong> and then we will change the room’s state by calling the <strong class="source-inline">make_available</strong> method. After that, we will fetch the room data to check the room’s status, which will generate the <span class="No-Break">following output:</span></p>
			<pre class="console">
$ python3 rooms_method.py
Room state after method call: available</pre>			<p>The program of this recipe will create a new room record and change the state of the room by calling the <strong class="source-inline">model</strong> method. By the end of the program, we have read the room record and printed the <span class="No-Break">updated state.</span></p>
			<h2 id="_idParaDest-875"><a id="_idTextAnchor1086"/>How it works...</h2>
			<p>You can call any modal method from RPC. This helps you to perform business logic without <a id="_idIndexMarker1438"/>encountering any side effects. For example, you created the sales order from RPC and then called the <strong class="source-inline">action_confirm</strong> method of the <strong class="source-inline">sale.order</strong> method. This is equivalent to clicking <a id="_idIndexMarker1439"/>on the <strong class="bold">Confirm</strong> button on a sales <span class="No-Break">order form.</span></p>
			<p>You can call any public method of the model, but you cannot call a private method from RPC. A method name that starts with <strong class="source-inline">_</strong> is called a private method, such as <strong class="source-inline">_get_share_url()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">_get_data()</strong></span><span class="No-Break">.</span></p>
			<p>It is safe to use these methods, as they go through the ORM and follow all security rules. If the method is accessing unauthorized records, it will <span class="No-Break">generate errors.</span></p>
			<p>In our example, we created a room with a state of <strong class="source-inline">draft</strong>. Then, we made one more RPC call to invoke the <strong class="source-inline">make_available</strong> method, which will change the room’s state to <strong class="source-inline">available</strong>. Finally, we made one more RPC call to check the state of the room. This will show that the room’s state has changed to <strong class="bold">Available</strong>, as indicated in <span class="No-Break"><em class="italic">Figure 20</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">.</span></p>
			<p>Methods that do not return anything internally return <strong class="source-inline">None</strong> by default. Such methods cannot be used from RPC. Consequently, if you want to use your method from RPC, at least add the return <span class="No-Break"><strong class="source-inline">True</strong></span><span class="No-Break"> statement.</span></p>
			<h2 id="_idParaDest-876"><a id="_idTextAnchor1087"/>There’s more...</h2>
			<p>If an exception is generated from a method, all of the operations performed in the transaction will be automatically rolled back to the initial state. This is only applicable to a single transaction (a single RPC call). For example, imagine you are making two RPC calls to the server, and an exception is generated during the second call. This will roll back the operation that was carried out during the second RPC call. The operation performed through the first RPC call won’t be rolled back. Consequently, you want to perform a complex operation through RPC. It is recommended that this be performed in a single RPC call by creating a method in <span class="No-Break">the model.</span></p>
			<h1 id="_idParaDest-877"><a id="_idTextAnchor1088"/>Logging in to/connecting Odoo with JSON-RPC</h1>
			<p>Odoo <a id="_idIndexMarker1440"/>provides one more type of RPC API: JSON-RPC. As <a id="_idIndexMarker1441"/>its name suggests, JSON-RPC works <a id="_idIndexMarker1442"/>in the JSON format and uses the <strong class="source-inline">jsonrpc</strong> 2.0 <a id="_idIndexMarker1443"/>specification. In this recipe, we will see how you can log in with JSON-RPC. The Odoo web client itself uses JSON-RPC to fetch data from <span class="No-Break">the server.</span></p>
			<h2 id="_idParaDest-878"><a id="_idTextAnchor1089"/>Getting ready</h2>
			<p>In this recipe, we will perform user authentication through JSON-RPC to check whether the given credentials are valid. Make sure you have installed the <strong class="source-inline">my_hostel</strong> module and that the server is running <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">http://localhost:8017</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-879"><a id="_idTextAnchor1090"/>How to do it...</h2>
			<p>Perform the following steps to perform user authentication <span class="No-Break">through RPC:</span></p>
			<ol>
				<li>Add the <strong class="source-inline">jsonrpc_authenticate.py</strong> file. You can place this file anywhere you want because the RPC program will <span class="No-Break">work independently.</span></li>
				<li>Add the following code to <span class="No-Break">the file:</span><pre class="source-code">
import json
import random
import requests
server_url = 'http://localhost:8017'
db_name = 'cookbook_17e'
username = 'admin'
password = 'admin'
json_endpoint = "%s/jsonrpc" % server_url
headers = {"Content-Type": "application/json"}
def get_json_payload(service, method, *args):
    return json.dumps({
        "jsonrpc": "2.0",
        "method": 'call',
        "params": {
            "service": service,
            "method": method,
            "args": args
        },
        "id": random.randint(0, 1000000000),
    })
payload = get_json_payload("common", "login", db_name, username, password)
response = requests.post(json_endpoint, data=payload, headers=headers)
user_id = response.json()['result']
if user_id:
    print("Success: User id is", user_id)
else:
    print("Failed: wrong credentials")</pre></li>				<li>Run the Python script from the Terminal with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">python3 jsonrpc_authenticate.py</strong></pre></li>			</ol>
			<p>When you <a id="_idIndexMarker1444"/>run the preceding program, and you have <a id="_idIndexMarker1445"/>passed a valid login name and password, the program <a id="_idIndexMarker1446"/>will print a success message with <a id="_idIndexMarker1447"/>the <strong class="source-inline">id</strong> of the user, <span class="No-Break">as follows:</span></p>
			<pre class="console">
$ python3 jsonrpc_authentication.py
Success: User id is 2</pre>			<p>The JSON authentication works just like XML-RPC, but it returns a result in the <span class="No-Break">JSON format.</span></p>
			<h2 id="_idParaDest-880"><a id="_idTextAnchor1091"/>How it works...</h2>
			<p>JSON-RPC uses the JSON format to communicate with the server using the <strong class="source-inline">/jsonrpc</strong> endpoint. In our example, we used the Python requests package to make <strong class="source-inline">POST</strong> requests, but if you want to, you can use other packages, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">urllib</strong></span><span class="No-Break">.</span></p>
			<p>JSON-RPC only accepts a payload formatted in the <strong class="bold">JSON-RPC 2.0</strong> specification. You may refer to this link to learn more about the JSON-RPC format: <a href="https://www.jsonrpc.org/specification">https://www.jsonrpc.org/specification</a>. In our example, we created the <strong class="source-inline">get_json_payload()</strong> method. This method will prepare the payload in the valid JSON-RPC 2.0 format. This method accepts the <strong class="source-inline">service</strong> name and the <strong class="source-inline">method</strong> to call, and the remaining arguments will be placed in <strong class="source-inline">*args</strong>. We will be using this method in all subsequent recipes. JSON-RPC accepts requests in JSON format, and these requests are only accepted if the request contains a <strong class="source-inline">{"Content-Type": "application/json"}</strong> header. The results of the requests will be in <span class="No-Break">JSON format.</span></p>
			<p>Like XML-RPC, all public methods, including login, come under the common service. For this reason, we passed <strong class="source-inline">common</strong> as a service and <strong class="source-inline">login</strong> as a method to prepare the JSON payload. The login method required some extra arguments, so we passed the database name, username, and password. Then, we made the <strong class="source-inline">POST</strong> request to the JSON endpoint with the payload and headers. If you passed the correct username and password, the method returns the user ID. The response will be in JSON format, and you will get the result in the <span class="No-Break">result key.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Note that the <strong class="source-inline">get_json_payload()</strong> method created in this recipe is used to remove <a id="_idIndexMarker1448"/>repetitive code from the example. It is not compulsory to use it, so feel free to apply your <span class="No-Break">own adaptations.</span></p>
			<h2 id="_idParaDest-881"><a id="_idTextAnchor1092"/>There’s more...</h2>
			<p>Like XML-RPC, the version method is also available in JSON-RPC. This version of the method <a id="_idIndexMarker1449"/>comes under the common service and is accessible <a id="_idIndexMarker1450"/>publicly. You can get version information <a id="_idIndexMarker1451"/>without login information. See the following <a id="_idIndexMarker1452"/>example showing how to fetch the version info of the <span class="No-Break">Odoo server:</span></p>
			<pre class="source-code">
import json
import random
import requests
server_url = 'http://localhost:8017'
db_name = 'cookbook_17e'
username = 'admin'
password = 'admin'
json_endpoint = "%s/jsonrpc" % server_url
headers = {"Content-Type": "application/json"}
def get_json_payload(service, method, *args):
    return json.dumps({
        "jsonrpc": "2.0",
        "method": 'call',
        "params": {
            "service": service,
            "method": method,
            "args": args
        },
        "id": random.randint(0, 1000000000),
    })
payload = get_json_payload("common", "version")
response = requests.post(json_endpoint, data=payload, headers=headers)
print(response.json())</pre>			<p>This <a id="_idIndexMarker1453"/>program <a id="_idIndexMarker1454"/>will <a id="_idIndexMarker1455"/>display <a id="_idIndexMarker1456"/>the <span class="No-Break">following output:</span></p>
			<pre class="console">
$ python3 jsonrpc_version_info.py
{'jsonrpc': '2.0', 'id': 361274992, 'result': {'server_version': '17.0+e', 'server_version_info': [17, 0, 0, 'final', 0, 'e'], 'server_serie': '17.0', 'protocol_version': 1}}</pre>			<p>This program will print version information based on <span class="No-Break">your server.</span></p>
			<h1 id="_idParaDest-882"><a id="_idTextAnchor1093"/>Fetching/searching records using JSON-RPC</h1>
			<p>In the previous <a id="_idIndexMarker1457"/>recipe, we saw how you can do authentication through <a id="_idIndexMarker1458"/>JSON-RPC. In this recipe, we <a id="_idIndexMarker1459"/>will see how you can fetch the data from <a id="_idIndexMarker1460"/>the Odoo instance <span class="No-Break">with JSON-RPC.</span></p>
			<h2 id="_idParaDest-883"><a id="_idTextAnchor1094"/>Getting ready</h2>
			<p>In this recipe, we will fetch room information with JSON-RPC. Make sure you have installed the <strong class="source-inline">my_hostel</strong> module and that the server is running <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">http://localhost:8017</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-884"><a id="_idTextAnchor1095"/>How to do it...</h2>
			<p>Perform the following steps to fetch room data from the <span class="No-Break"><strong class="source-inline">hostel.room</strong></span><span class="No-Break"> model:</span></p>
			<ol>
				<li>Add the <strong class="source-inline">jsonrpc_fetch_data.py</strong> file. You can place this file anywhere you want because the RPC program will <span class="No-Break">work independently.</span></li>
				<li>Add the following code to <span class="No-Break">the file:</span><pre class="source-code">
# place authentication and get_json_payload methods (see first jsonrpc recipe)
if user_id:
    # search for the room's ids
    search_domain = [['name', 'ilike', 'Standard']]
    payload = get_json_payload("object", "execute_kw",
        db_name, user_id, password,
        'hostel.room', 'search', [search_domain], {'limit': 5})
    res = requests.post(json_endpoint, data=payload, headers=headers).json()
    print('Search Result:', res)  # ids will be in result keys
    # read data for rooms ids
    payload = get_json_payload("object", "execute_kw",
        db_name, user_id, password,
        'hostel.room', 'read', [res['result'], ['name', 'room_no']])
    res = requests.post(json_endpoint, data=payload, headers=headers).json()
    print('Rooms data:', res)
else:
    print("Failed: wrong credentials")</pre></li>				<li>Run the <a id="_idIndexMarker1461"/>Python script from the Terminal with <a id="_idIndexMarker1462"/>the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">python3 json_fetch_data.py</strong></pre></li>			</ol>
			<p>The preceding <a id="_idIndexMarker1463"/>program will give you the following output. The <a id="_idIndexMarker1464"/>first RPC call will print the room’s ID, and the second one will print the information for the <span class="No-Break">room’s ID:</span></p>
			<pre class="console">
$ python3 json_fetch_data.py
Search Result: {'jsonrpc': '2.0', 'id': 19247199, 'result': [1, 2, 3, 4, 5]}
Rooms data: {'jsonrpc': '2.0', 'id': 357582271, 'result': [{'id': 1, 'name': '8th Standard', 'room_no': '1'}, {'id': 2, 'name': '9th Standard', 'room_no': '2'}, {'id': 3, 'name': '10th Standard', 'room_no': '3'}, {'id': 4, 'name': '11th Standard', 'room_no': '4'}, {'id': 5, 'name': '12th Standard', 'room_no': '5'}]}</pre>			<p>The output shown in the preceding screenshot is based on data in my database. The data in your Odoo instance may be different data, so the output will also <span class="No-Break">be different.</span></p>
			<h2 id="_idParaDest-885"><a id="_idTextAnchor1096"/>How it works...</h2>
			<p>In the <em class="italic">Logging in to/connecting Odoo with JSON-RPC</em> recipe, we saw that you can validate <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong>. If the login details are correct, the RPC call will return <strong class="source-inline">user_id</strong>. You can then use this <strong class="source-inline">user_id</strong> to fetch the model’s data. Like XML-RPC, we need <a id="_idIndexMarker1465"/>to use the <strong class="source-inline">search</strong> and <strong class="source-inline">read</strong> combination to fetch the data from the model. To fetch the data, we <a id="_idIndexMarker1466"/>use <strong class="source-inline">object</strong> as a service and <strong class="source-inline">execute_kw()</strong> as the method. <strong class="source-inline">execute_kw()</strong> is the same method that we used in <a id="_idIndexMarker1467"/>XML-RPC for data, so it accepts the same <a id="_idIndexMarker1468"/>argument <span class="No-Break">as follows:</span></p>
			<ul>
				<li><span class="No-Break">Database name</span></li>
				<li>User ID (we get this from the <span class="No-Break"><strong class="source-inline">authenticate()</strong></span><span class="No-Break"> method)</span></li>
				<li><span class="No-Break">Password</span></li>
				<li>Model name, for example, <strong class="source-inline">res.partner</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">hostel.room</strong></span></li>
				<li>Method name, for example, <strong class="source-inline">search</strong>, <strong class="source-inline">read</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">create</strong></span></li>
				<li>An array of positional <span class="No-Break">arguments (</span><span class="No-Break"><strong class="source-inline">args</strong></span><span class="No-Break">)</span></li>
				<li>A dictionary for keyword arguments (<span class="No-Break"><strong class="source-inline">optional</strong></span><span class="No-Break">) (</span><span class="No-Break"><strong class="source-inline">kwargs</strong></span><span class="No-Break">)</span></li>
			</ul>
			<p>In our example, we called the <strong class="source-inline">search</strong> method first. The <strong class="source-inline">execute_kw()</strong> method usually takes mandatory arguments as positional arguments and optional arguments as keyword arguments. In the <strong class="source-inline">search</strong> method, <strong class="source-inline">domain</strong> is a mandatory argument, so we passed it in the list and passed the <strong class="source-inline">optional</strong> argument limit as the <strong class="source-inline">keyword</strong> argument (dictionary). You will get a response in JSON format, and in this recipe, the response of the <strong class="source-inline">search()</strong> method RPC will have the room’s IDs in the <span class="No-Break"><strong class="source-inline">result</strong></span><span class="No-Break"> key.</span></p>
			<p>In <em class="italic">step 2</em>, we made an RPC call using the <strong class="source-inline">read</strong> method. To read the room’s information, we <a id="_idIndexMarker1469"/>passed two positional arguments: the <a id="_idIndexMarker1470"/>list of room IDs and the list of fields <a id="_idIndexMarker1471"/>to fetch. This RPC call will return the room <a id="_idIndexMarker1472"/>information in JSON format, and you can access it in using the <span class="No-Break"><strong class="source-inline">result</strong></span><span class="No-Break"> key.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Instead of <strong class="source-inline">execute_kw()</strong>, you can use <strong class="source-inline">execute</strong> as the method. This does not support keyword arguments, so you need to pass all of the intermediate arguments if you want to pass some <span class="No-Break">optional arguments.</span></p>
			<h2 id="_idParaDest-886"><a id="_idTextAnchor1097"/>There’s more...</h2>
			<p>Similar to XML-RPC, you <a id="_idIndexMarker1473"/>can use the <strong class="source-inline">search_read()</strong> method instead of the <strong class="source-inline">search()</strong> and <strong class="source-inline">read()</strong> method combination, as it is slightly time-consuming. Take a look at the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
# place authentication and get_json_payload methods (see first jsonrpc recipe)
if user_id:
    # search for the room's ids
    search_domain = [['name', 'ilike', 'Standard']]
    payload = get_json_payload("object", "execute_kw",
        db_name, user_id, password,
        'hostel.room', 'search_read', [search_domain, ['name', 'room_no']], {'limit': 5})
    res = requests.post(json_endpoint, data=payload, headers=headers).json()
    print('Rooms data:', res)
else:
    print("Failed: wrong credentials")</pre>			<p>The code <a id="_idIndexMarker1474"/>snippet is an alternative way of fetching room data with <strong class="source-inline">search_read()</strong>. It will return the same output as in the <span class="No-Break">previous example.</span></p>
			<h1 id="_idParaDest-887"><a id="_idTextAnchor1098"/>Creating/updating/deleting records using JSON-RPC</h1>
			<p>In <a id="_idIndexMarker1475"/>the previous <a id="_idIndexMarker1476"/>recipe, we looked <a id="_idIndexMarker1477"/>at how to search and read <a id="_idIndexMarker1478"/>data through JSON-RPC. In this recipe, we <a id="_idIndexMarker1479"/>will perform the remaining <strong class="bold">CRUD</strong> operations <a id="_idIndexMarker1480"/>through RPC: <strong class="bold">create</strong>, <strong class="bold">update</strong> (write), and <span class="No-Break"><strong class="bold">delete</strong></span><span class="No-Break"> (unlink).</span></p>
			<h2 id="_idParaDest-888"><a id="_idTextAnchor1099"/>Getting ready</h2>
			<p>We will create a Python program to <strong class="source-inline">create</strong>, <strong class="source-inline">write</strong>, and <strong class="source-inline">unlink</strong> data in the <strong class="source-inline">hostel.room</strong> model. Make sure you have installed the <strong class="source-inline">my_hostel</strong> module and that the server is running <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">http://localhost:8017</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-889"><a id="_idTextAnchor1100"/>How to do it...</h2>
			<p>Perform the following steps to create, write, and unlink a room’s information <span class="No-Break">through RPC:</span></p>
			<ol>
				<li>Add the <strong class="source-inline">jsonrpc_operation.py</strong> file. You can place this file anywhere you want because the RPC program will <span class="No-Break">work independently.</span></li>
				<li>Add the following code to <span class="No-Break">the file:</span><pre class="source-code">
# place authentication and get_json_payload method (see last recipe for more)
if user_id:
    # creates the room's records
    create_data = [
        {'name': 'Room 1', 'room_no': '201'},
        {'name': 'Room 3', 'room_no': '202'},
        {'name': 'Room 5', 'room_no': '205'},
        {'name': 'Room 7', 'room_no': '207'}
    ]
    payload = get_json_payload("object", "execute_kw", db_name, user_id, password, 'hostel.room', 'create', [create_data])
    res = requests.post(json_endpoint, data=payload, headers=headers).json()
    print("Rooms created:", res)
    rooms_ids = res['result']
    # Write in existing room record
    room_to_write = rooms_ids[1]  # We will use ids of recently created rooms
    write_data = {'name': 'Room 2'}
    payload = get_json_payload("object", "execute_kw", db_name, user_id, password, 'hostel.room', 'write', [room_to_write, write_data])
    res = requests.post(json_endpoint, data=payload, headers=headers).json()
    print("Rooms written:", res)
    # Delete in existing room record
    room_to_unlink = rooms_ids[2:]  # We will use ids of recently created rooms
    payload = get_json_payload("object", "execute_kw", db_name, user_id, password, 'hostel.room', 'unlink', [room_to_unlink])
    res = requests.post(json_endpoint, data=payload, headers=headers).json()
    print("Rooms deleted:", res)
else:
    print("Failed: wrong credentials")</pre></li>				<li>Run the <a id="_idIndexMarker1481"/>Python script from the Terminal with <a id="_idIndexMarker1482"/>the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">python3 jsonrpc_operation.py</strong></pre></li>			</ol>
			<p>The <a id="_idIndexMarker1483"/>preceding program will create four rooms. Writing <a id="_idIndexMarker1484"/>one room and deleting two rooms gives you <a id="_idIndexMarker1485"/>the following output (the IDs created <a id="_idIndexMarker1486"/>may be different based on <span class="No-Break">your database):</span></p>
			<pre class="console">
$ python3 jsonrpc_operation.py
Rooms created: {'jsonrpc': '2.0', 'id': 837186761, 'result': [43, 44, 45, 46]}
Rooms written: {'jsonrpc': '2.0', 'id': 317256710, 'result': True}
Rooms deleted: {'jsonrpc': '2.0', 'id': 978974378, 'result': True}</pre>			<p>The <strong class="source-inline">write</strong> and <strong class="source-inline">unlink</strong> methods return <strong class="source-inline">True</strong> if the operation is successful. This means that if you get <strong class="source-inline">True</strong> in response, assume that a record has been updated or <span class="No-Break">deleted successfully.</span></p>
			<h2 id="_idParaDest-890"><a id="_idTextAnchor1101"/>How it works...</h2>
			<p><strong class="source-inline">execute_kw()</strong> is used for the <strong class="source-inline">create</strong>, <strong class="source-inline">update</strong>, and <strong class="source-inline">delete</strong> operations. From Odoo version 12, the <strong class="source-inline">create</strong> method supports the creation of multiple records. So, we prepared <a id="_idIndexMarker1487"/>the dictionary with information <a id="_idIndexMarker1488"/>from the four rooms. Then, we made the <a id="_idIndexMarker1489"/>JSON-RPC call with <strong class="source-inline">hostel.room</strong> as the model name and <strong class="source-inline">create</strong> as the method name. This will create <a id="_idIndexMarker1490"/>four room records in the database and return a JSON <a id="_idIndexMarker1491"/>response with the IDs of these newly <a id="_idIndexMarker1492"/>created rooms. In the next RPC calls, we want to use these IDs to make an RPC call for the <strong class="source-inline">update</strong> and <strong class="source-inline">delete</strong> operations, so we assign it to the <span class="No-Break"><strong class="source-inline">rooms_ids</strong></span><span class="No-Break"> variable.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Both JSON-RPC and XML-RPC generate an error when you try to create the record without providing values for the required field, so make sure you have added all the required fields to the <span class="No-Break"><strong class="source-inline">create</strong></span><span class="No-Break"> values.</span></p>
			<p>In the next RPC call, we used the <strong class="source-inline">write</strong> method to update the existing records. The <strong class="source-inline">write</strong> method accepts two positional arguments; the records to update and the values to write. In our example, we have updated the name of the room by using the ID of the second room from a created room’s IDs. This will change the name of the second room from <strong class="source-inline">Room 3</strong> to <span class="No-Break"><strong class="source-inline">Room 2</strong></span><span class="No-Break">.</span></p>
			<p>Then, we made the last RPC call to delete two room records. To do so, we used the <strong class="source-inline">unlink</strong> method. The <strong class="source-inline">unlink</strong> method accepts only one argument, which is the ID of the records you want to delete. This RPC call will delete the last <span class="No-Break">two rooms.</span></p>
			<h2 id="_idParaDest-891"><a id="_idTextAnchor1102"/>There’s more...</h2>
			<p>Like XML-RPC, you <a id="_idIndexMarker1493"/>can use the <strong class="source-inline">check_access_rights</strong> method in JSON-RPC to check whether you have access rights to perform the operation. This method requires two parameters: the model name and the operation name. In the following example, we check access rights for the <strong class="source-inline">create</strong> operation on the <span class="No-Break"><strong class="source-inline">hostel.room</strong></span><span class="No-Break"> model:</span></p>
			<pre class="source-code">
# place authentication and get_json_payload method (see last recipe for more)
if user_id:
    payload = get_json_payload("object", "execute_kw",
        db_name, user_id, password,
        'hostel.room', 'check_access_rights', ['create'])
    res = requests.post(json_endpoint, data=payload, headers=headers).json()
    print("Has create access:", res['result'])
else:
    print("Failed: wrong credentials")</pre>			<p>This program <a id="_idIndexMarker1494"/>will generate the <span class="No-Break">following output:</span></p>
			<pre class="console">
$ python3 jsonrpc_access_rights.py
Has create access: True</pre>			<p>When you are performing complex operations via RPC, the use of the <strong class="source-inline">check_access_rights</strong> method can be used before performing an operation to make sure you have proper <span class="No-Break">access rights.</span></p>
			<h1 id="_idParaDest-892"><a id="_idTextAnchor1103"/>Calling methods using JSON-RPC</h1>
			<p>In this recipe, we will <a id="_idIndexMarker1495"/>learn how to invoke a custom method <a id="_idIndexMarker1496"/>of the model through JSON-RPC. We will change the status of the room by calling the <span class="No-Break"><strong class="source-inline">make_available()</strong></span><span class="No-Break"> method.</span></p>
			<h2 id="_idParaDest-893"><a id="_idTextAnchor1104"/>Getting ready</h2>
			<p>We will create the Python program to call <strong class="source-inline">make_available</strong> on the <strong class="source-inline">hostel.room</strong> model. Make sure you have installed the <strong class="source-inline">my_hostel</strong> module and that the server is running <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">http://localhost:8017</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-894"><a id="_idTextAnchor1105"/>How to do it...</h2>
			<p>Perform the <a id="_idIndexMarker1497"/>following steps to create, write, and update a <a id="_idIndexMarker1498"/>room’s information <span class="No-Break">through RPC:</span></p>
			<ol>
				<li>Add the <strong class="source-inline">jsonrpc_method.py</strong> file. You can place this file anywhere you want because the RPC program will <span class="No-Break">work independently.</span></li>
				<li>Add the following code to <span class="No-Break">the file:</span><pre class="source-code">
# place authentication and get_json_payload method (see last recipe for more)</pre></li>			</ol>
			<pre class="source-code">
if user_id:
    # Create the room record in draft state
    payload = get_json_payload("object", "execute_kw",
        db_name, user_id, password,
        'hostel.room', 'create', [{
            'name': 'Room 1',
            'room_no': '101',
            'state': 'draft'
        }])
    res = requests.post(json_endpoint, data=payload, headers=headers).json()
    print("Room created with id:", res['result'])
    room_id = res['result']
    # Change the room state by calling make_available method
    payload = get_json_payload("object", "execute_kw",
        db_name, user_id, password,
        'hostel.room', 'make_available', [room_id])
    res = requests.post(json_endpoint, data=payload, headers=headers).json()
    # Check the room status after method call
    payload = get_json_payload("object", "execute_kw",
        db_name, user_id, password,
        'hostel.room', 'read', [room_id, ['name', 'state']])
    res = requests.post(json_endpoint, data=payload, headers=headers).json()
    print("Room state after the method call:", res['result'])
else:
    print("Failed: wrong credentials")</pre>			<p>3.	Run the <a id="_idIndexMarker1499"/>Python script from the Terminal with the <a id="_idIndexMarker1500"/><span class="No-Break">following command:</span></p>
			<pre class="source-code">
<strong class="bold">python3 jsonrpc_method.py</strong></pre>			<p>The preceding command will create one room using <strong class="source-inline">draft</strong> and then we will change the room state by calling the <strong class="source-inline">make_available</strong> method. After that, we will fetch the room data to check the room’s status, which will generate the <span class="No-Break">following output:</span></p>
			<pre class="console">
$ python3 jsonrpc_method.py
Room created with id: 53
Room state after the method call: [{'id': 53, 'name': 'Room 1', 'state': 'available'}]</pre>			<p>The program of this recipe will create a new room record and change the state of the room by calling the model method. By the end of the program, we will have read the room record and printed the <span class="No-Break">updated state.</span></p>
			<h2 id="_idParaDest-895"><a id="_idTextAnchor1106"/>How it works...</h2>
			<p><strong class="source-inline">execute_kw()</strong> is capable of calling any public method of the model. As we saw in the <em class="italic">Calling methods through XML-RPC</em> recipe, public methods are those that have names that don’t start with <strong class="source-inline">_</strong> (underscore). Methods that start with <strong class="source-inline">_</strong> are private, and you cannot invoke them <span class="No-Break">from JSON-RPC.</span></p>
			<p>In our example, we created a room with a state of <strong class="source-inline">draft</strong>. Then, we made one more RPC call to <a id="_idIndexMarker1501"/>invoke the <strong class="source-inline">make_available</strong> method, which will change the room’s state to <strong class="source-inline">available</strong>. Finally, we made <a id="_idIndexMarker1502"/>one more RPC call to check the state of the room. This will show that the room’s state has changed to <strong class="bold">Available</strong>, as seen in <span class="No-Break"><em class="italic">Figure 20</em></span><span class="No-Break"><em class="italic">.10</em></span><span class="No-Break">.</span></p>
			<p>Methods that do not return anything internally return <strong class="source-inline">None</strong> by default. Such methods cannot be used from RPC. Consequently, if you want to use your method from RPC, at least add the return <span class="No-Break"><strong class="source-inline">True</strong></span><span class="No-Break"> statement.</span></p>
			<h1 id="_idParaDest-896"><a id="_idTextAnchor1107"/>The OCA odoorpc library</h1>
			<p>The <strong class="bold">Odoo Community Association</strong> (<strong class="bold">OCA</strong>) provides a Python library called <strong class="source-inline">odoorpc</strong>. This <a id="_idIndexMarker1503"/>is available at <a href="https://github.com/OCA/odoorpc">https://github.com/OCA/odoorpc</a>. The <strong class="source-inline">odoorpc</strong> library provides a user-friendly syntax from <a id="_idIndexMarker1504"/>which to access Odoo data through RPC. It provides a similar a syntax similar to that of the server. In this recipe, we will see how you can use the <strong class="source-inline">odoorpc</strong> library to perform operations <span class="No-Break">through RPC.</span></p>
			<h2 id="_idParaDest-897"><a id="_idTextAnchor1108"/>Getting ready</h2>
			<p>The <strong class="source-inline">odoorpc</strong> library is <a id="_idIndexMarker1505"/>registered on the Python package (<strong class="source-inline">PyPI</strong>) index. In order to use the library, you need to install it using the following command. You can use this in a separate virtual environment if <span class="No-Break">you want:</span></p>
			<pre class="console">
pip install OdooRPC</pre>			<p>In this recipe, we will perform some basic operations using the <strong class="source-inline">odoorpc</strong> library. We will use the <strong class="source-inline">hostel.room</strong> model to perform these operations. Make sure you have installed the <strong class="source-inline">my_hostel</strong> module and that the server is running <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">http://localhost:8017</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-898"><a id="_idTextAnchor1109"/>How to do it...</h2>
			<p>Perform the following steps to create, write, and update a room’s information <span class="No-Break">through RPC:</span></p>
			<ol>
				<li>Add the <strong class="source-inline">odoorpc_hostel.py</strong> file. You can place this file anywhere you want because the RPC program will <span class="No-Break">work independently.</span></li>
				<li>Add the following code to <span class="No-Break">the file:</span><pre class="source-code">
import odoorpc
db_name = 'cookbook_17e'
user_name = 'admin'
password = 'admin'
# Prepare the connection to the server
odoo = odoorpc.ODOO('localhost', port=8017)
odoo.login(db_name, user_name, password)  # login
# User information
user = odoo.env.user
print(user.name)             # name of the user connected
print(user.company_id.name)  # the name of user's company
print(user.email)            # the email of user
RoomModel = odoo.env['hostel.room']
search_domain = [['name', 'ilike', 'Standard']]
rooms_ids = RoomModel.search(search_domain, limit=5)
for room in RoomModel.browse(rooms_ids):
    print(room.name, room.room_no)
# create the room and update the state
room_id = RoomModel.create({
    'name': 'Test Room',
    'room_no': '103',
    'state': 'draft'
})
room = RoomModel.browse(room_id)
print("Room state before make_available:", room.state)
room.make_available()
room = RoomModel.browse(room_id)
print("Room state after make_available:", room.state)</pre></li>				<li>Run the <a id="_idIndexMarker1506"/>Python script from the Terminal with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">python3 odoorpc_hostel.py</strong></pre></li>			</ol>
			<p>The program will do the authentication, print user information, and perform an operation in the <strong class="source-inline">hostel.room</strong> model. It will generate the <span class="No-Break">following output:</span></p>
			<pre class="console">
$ python3 odoorpc_hostel.py
Mitchell Admin
Packt publishing
admin@yourcompany.example.com
8th Standard 1
9th Standard 2
10th Standard 3
11th Standard 4
12th Standard 5
Room state before make_available: draft
Room state after make_available: available</pre>			<p>The preceding output is the result of several RPC calls. We have fetched user info, some room info, and we have changed the state of <span class="No-Break">the room.</span></p>
			<h2 id="_idParaDest-899"><a id="_idTextAnchor1110"/>How it works...</h2>
			<p>After installing the <strong class="source-inline">odoorpc</strong> library, you can start using it straight away. To do so, you will need <a id="_idIndexMarker1507"/>to import the <strong class="source-inline">odoorpc</strong> package and then we will create the object of the <strong class="source-inline">ODOO</strong> class by passing the server URL and port. This will make the <strong class="source-inline">/version_info</strong> call to the server to check the connection. To log in, you need to use the <strong class="source-inline">login()</strong> method of the object. Here, you need to pass the <strong class="source-inline">database </strong><strong class="source-inline">name</strong>, <strong class="source-inline">username</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">password</strong></span><span class="No-Break">.</span></p>
			<p>Upon successful login, you can access the user information at <strong class="source-inline">odoo.env.user</strong>. <strong class="source-inline">odoorpc</strong> provides a user-friendly version of RPC, so you can use this user object exactly like the record set in the server. In our example, we accessed the name, email, and company name from this <span class="No-Break">user object.</span></p>
			<p>If you want to access the model registry, you can use the <strong class="source-inline">odoo.env</strong> object. You can call any model method on the model. Under the hood, the <strong class="source-inline">odoorpc</strong> library uses <strong class="source-inline">jsonrpc</strong>, so you can’t invoke any private model method name that starts with an <strong class="source-inline">_</strong>. In our example, we accessed the <strong class="source-inline">hostel.room</strong> model from the registry. After that, we called the <strong class="source-inline">search</strong> method with the <strong class="source-inline">domain</strong> and <strong class="source-inline">limit</strong> parameters. This will return the IDs of the rooms. By passing the room IDs to the <strong class="source-inline">browse()</strong> method, you can generate a record set for the <span class="No-Break"><strong class="source-inline">hostel.room</strong></span><span class="No-Break"> model.</span></p>
			<p>By the end of <a id="_idIndexMarker1508"/>the program, we will have created a new room and changed the room’s state by calling the <strong class="source-inline">make_available()</strong> method. If you look closely at the syntax of the program, you will see that it uses the same syntax as <span class="No-Break">the server.</span></p>
			<h2 id="_idParaDest-900"><a id="_idTextAnchor1111"/>There’s more...</h2>
			<p>Although it provides a user-friendly syntax like the server, you can use the library just like the normal RPC syntax. To do so, you need to use the <strong class="source-inline">odoo.execute</strong> method with the model <a id="_idIndexMarker1509"/>name, method name, and arguments. Here is an example of reading some room information in the raw <span class="No-Break">RPC syntax:</span></p>
			<pre class="source-code">
import odoorpc
db_name = 'cookbook_17e'
user_name = 'admin'
password = 'admin'
# Prepare the connection to the server
odoo = odoorpc.ODOO('localhost', port=8017)
odoo.login(db_name, user_name, password)  # login
rooms_info = odoo.execute('hostel.room', 'search_read',
    [['name', 'ilike', 'Standard']])
print(rooms_info)</pre>			<h2 id="_idParaDest-901"><a id="_idTextAnchor1112"/>See also</h2>
			<p>There are several other implementations of RPC libraries for Odoo, <span class="No-Break">as follows:</span></p>
			<ul>
				<li><a href="https://github.com/akretion/ooor"><span class="No-Break">https://github.com/akretion/ooor</span></a></li>
				<li><a href="https://github.com/OCA/odoorpc"><span class="No-Break">https://github.com/OCA/odoorpc</span></a></li>
				<li><a href="https://github.com/odoo/openerp-client-lib"><span class="No-Break">https://github.com/odoo/openerp-client-lib</span></a></li>
				<li><a href="http://pythonhosted.org/OdooRPC"><span class="No-Break">http://pythonhosted.org/OdooRPC</span></a></li>
				<li><a href="https://github.com/abhishek-jaiswal/php-openerp-lib"><span class="No-Break">https://github.com/abhishek-jaiswal/php-openerp-lib</span></a></li>
			</ul>
			<h1 id="_idParaDest-902"><a id="_idTextAnchor1113"/>Generating API keys</h1>
			<p>Odoo v17 has built-in <a id="_idIndexMarker1510"/>support for the <strong class="bold">two-factor authentication</strong> (<strong class="bold">2FA</strong>) feature. 2FA is an extra layer of security for user accounts and users need to enter a password and time-based code. If you have enabled 2FA, then you <a id="_idIndexMarker1511"/>won’t be able to use RPC by entering your user ID and password. To fix this, you will need to generate an API key for the user. In this recipe, we will see how you can generate <span class="No-Break">API keys.</span></p>
			<h2 id="_idParaDest-903"><a id="_idTextAnchor1114"/>How to do it...</h2>
			<p>Perform the following steps to generate an API key <span class="No-Break">for RPC:</span></p>
			<ol>
				<li>Open user preferences and open the <strong class="bold">Account </strong><span class="No-Break"><strong class="bold">Security</strong></span><span class="No-Break"> tab.</span></li>
				<li>Click on the <strong class="bold">New API </strong><span class="No-Break"><strong class="bold">Key</strong></span><span class="No-Break"> button:</span></li>
			</ol>
			<div>
				<div id="_idContainer192" class="IMG---Figure">
					<img src="image/B20997_20_01.jpg" alt="Figure 20.1 – Generating a new API key"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 20.1 – Generating a new API key</p>
			<ol>
				<li value="3">It will open <a id="_idIndexMarker1512"/>a popup, as in the following screenshot. Enter the API key name and click on the <strong class="bold">Generate </strong><span class="No-Break"><strong class="bold">key</strong></span><span class="No-Break"> button:</span></li>
			</ol>
			<div>
				<div id="_idContainer193" class="IMG---Figure">
					<img src="image/B20997_20_02.jpg" alt="Figure 20.2 – Naming your key"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 20.2 – Naming your key</p>
			<ol>
				<li value="4">This will generate the API key and show it in a new popup. Note down the API key because <a id="_idIndexMarker1513"/>you will need <span class="No-Break">this again:</span></li>
			</ol>
			<div>
				<div id="_idContainer194" class="IMG---Figure">
					<img src="image/B20997_20_03.jpg" alt="Figure 20.3 – Noting the generated API key"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 20.3 – Noting the generated API key</p>
			<p>Once the API key is generated, you can start using the API key for RPC in the same way as the <span class="No-Break">normal password.</span></p>
			<h2 id="_idParaDest-904"><a id="_idTextAnchor1115"/>How it works…</h2>
			<p>Using API keys is straightforward. However, there are a few things that you need to take care of. The API keys are generated per user, and if you want to utilize RPC for multiple users, you will need to generate an API key for each user. Additionally, the API key for a user will have the same access rights as the user would have, so if someone gains access to the key, they can perform all the operations that the user can. So, you need to keep the API <span class="No-Break">key secret.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">When you <a id="_idIndexMarker1514"/>generate the API key, it is displayed only once. You need to note down the key. If you lose it, there is no way to get it back. In such cases, you would need to delete the API key and generate a <span class="No-Break">new one.</span></p>
			<p>Using the API <a id="_idTextAnchor1116"/>key is very simple. During RPC calls, you just need to use the API key instead of the user password. You will be able to call RPC even if 2FA <span class="No-Break">is activated.</span></p>
		</div>
	</body></html>