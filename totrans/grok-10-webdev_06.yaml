- en: 'Chapter 6. The Catalog: An Object-Oriented Search Engine'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have an application with multiple projects and lists. As we start adding
    more lists, there will come a time when we'll need to find a particular list item.
    We might want to find all items containing a specific word, or maybe all of the
    items completed on a specific date. Since all of the application data is stored
    in the ZODB, we need a tool to help us look for specific objects contained therein.
    This tool comes with Grok by default and is called the catalog.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to learn how to use the catalog. In particular,
    we will look at the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: What a catalog is and how it works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What indexes are and how they work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing data in the catalog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing simple queries on the catalog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a search interface for our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catalogs and indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we work with small amounts of data, we can always look at all of the elements
    of a list, for example, to find the ones that we want. However, this approach
    obviously does not scale up when we are dealing with thousands or millions of
    objects. A common way of attacking this problem is to use some sort of lookup
    table that will allow us to quickly and easily find a specific object by using
    one of its attributes. This is known as an **index**.
  prefs: []
  type: TYPE_NORMAL
- en: A **catalog** is a tool that allows us to manage a collection of related indexes
    and perform queries against the catalog by using one or more of them. We can add
    indexes to the catalog that will keep track of a specific attribute of an object.
    From then on, whenever we create a new object, we can call the catalog to index
    it, and it will take all of the objects' attributes that have an index setup and
    includes them in the corresponding index. Once they are there, we can query the
    catalog by using specific attribute values, and get back the objects that match
    the query.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a simple search function to the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The catalog contains references to the actual objects that are stored in the
    ZODB, and each index is related to one attribute of these objects.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to search for an object in the catalog, the object needs to be indexed
    by the catalog. This works better if it happens at specific events in the lifetime
    of the object, so that it gets indexed at creation time and when it gets modified.
  prefs: []
  type: TYPE_NORMAL
- en: Since working with the catalog is the best way of dealing with searches when
    using the ZODB, Grok comes with a class that allows us to easily hook into the
    catalog, create indexes, and perform searches. This class is called `grok.Indexes`,
    and allows us to define indexes and hook our application objects with the appropriate
    life cycle events, for automatic indexing.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a simple index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s define a simple index for the `title` attribute of a project, and show
    how to perform a search on the catalog by using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We are going to create an index for the `Project` class, so we name our class
    `ProjectIndexes`. The name is not important, as the key is using `grok.Indexes`
    as a base for the class. The `grok.site` class annotation is used to signal to
    Grok which type of object in our application is going to use the indexes defined
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to tell Grok which objects will be automatically indexed when
    they are modified. This is done by using `grok.context` with either a class or
    an interface as the parameter. In this case, we select `IProject` as the interface
    that will mark the objects to be indexed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we define the indexes themselves. In this example, we want the whole
    text of the `title` attribute to be searchable, so we will use a `Text` index.
    We''ll have more to say about the types of indexes shortly. For now, just note
    that the attribute that will be indexed is the same as the name of the index,
    which in this case means that the `title` attribute from the project model will
    be indexed in this catalog. It is possible to have an index named differently
    than the attribute to be indexed, but then we need to specify the real attribute
    name with the keyword parameter `attribute`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That's it. Simply by declaring the indexes in this class, Grok will take it
    upon itself to create the catalog and append the indexes to it, as well as keeping
    track of when an object needs to be reindexed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the search view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will now create the search view that will allow us to see the catalog in
    action. First, let''s take a look at the view code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is a view for the main application, and is named search. The important
    bit is in the `update` method. We receive a query as a parameter, which represents
    the text that the user is looking for inside the title of the projects. We then
    have to get the actual catalog before we can perform a search. Note that the catalog
    at this point will already contain the indexes that we defined earlier for `Project`.
    We don't have to do anything else to connect them with the catalog; Grok takes
    care of all the plumbing.
  prefs: []
  type: TYPE_NORMAL
- en: After we get the `catalog` object, we can search it by using the `searchResults`
    method, which accepts key/value pairs with index names and query values. In this
    case, we pass the query that came in the request to the `title` index, so that
    we get all of the projects that match this query text in their titles, as results.
  prefs: []
  type: TYPE_NORMAL
- en: You might recall that earlier we mentioned that interfaces, besides being useful
    for documentation and attribute introspection, are very helpful for working with
    component architectures. Under the hood, Grok contains a registry, which keeps
    track of all of the interface declarations for objects, so that it's possible
    to find an object by querying its interface. A catalog always implements the interface
    `ICatalog`, which is found in the `zope.app.catalog.interfaces` package included
    with Grok.
  prefs: []
  type: TYPE_NORMAL
- en: As Grok is making our lives simpler by not forcing us to instantiate a catalog
    and manually add and populate indexes to it, we do not control the code where
    this happens. So how do we find it? By using the registry, we can query it for
    an object that implements the `ICatalog` interface and that will be the catalog
    that we are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s precisely what the `getUtility` method from the `zope.component` package
    does. So, after calling this method we will have the catalog referenced by our
    `catalog` variable. This might seem to be a roundabout mechanism for getting at
    the catalog. Why not simply have Grok define a global catalog and use that directly?
    Well, we can answer that with another question or two: what if we need more than
    one catalog? Or what if we decide to replace the catalog that Grok creates with
    our own? When using interfaces and component registration we can cover these cases
    and the code barely needs to be changed.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a template to display the search results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we have the results placed in the view in the last line of the `update`
    method, we need a template to show this result. Create a template called `todosearch.pt`
    inside the `app_templates` directory. First comes the header, with our stylesheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Next, we are going to add a search box inside our top header. We use `tal:attributes`
    to set the text input value to whatever we searched for before, or leave it empty
    if there was no previous search.
  prefs: []
  type: TYPE_NORMAL
- en: 'The form action is set to call the search view that we defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We now come to the heart of the matter. Recall that in the view we performed
    a search by title, and defined an attribute named `results`. Now we can use those
    results in the template. First, we need to make sure that we have something to
    show, and if we don''t, we will display a message saying so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, if there are results, we prepare a table with the correct headings, and
    use `tal:repeat` to loop through the results. The view variable `results` contains
    all of the projects whose title matched the query, so we iterate through these
    results and simply show all of their attributes in a table similar to the one
    that we used for the dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create a new application instance in the Grok admin UI and define
    some projects so that we can see how the search works. The reason why we need
    to define a new application is that indexes only get created when an application
    is installed. Our `ProjectIndexes` class will actually do nothing if it gets added
    after the application was created. Take a look at the following screenshot, to
    see how the search results are displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a template to display the search results](img/7481_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A brief diversion: Structuring our application for search'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have experimented with the basics of catalog searches, we'll need
    to refactor our application a little to play well with the catalog, because our
    to-do items don't have all the attributes we will likely need to make the search
    powerful enough. For instance, we are certainly going to be interested in searching
    for them by date and eventually by user.
  prefs: []
  type: TYPE_NORMAL
- en: Let's pause a bit and reflect on where we want our application to go. If we
    are going to be managing 'projects', we'll need to add some more attributes to
    our models. We have not bothered about this until now, but as the complexity of
    our application grows, it becomes more important to have a clear plan.
  prefs: []
  type: TYPE_NORMAL
- en: The top-level unit of our application will be a project. For our purposes, a
    *project* is a collection of related to-do lists. We will need to store the project's
    creation date as well as the last time it was modified. A project is 'done' when
    all of the items in all of its lists are checked off.
  prefs: []
  type: TYPE_NORMAL
- en: The project can have owners and members. Members are users who have one or more
    items assigned; owners are members who can also add, edit, or remove lists and
    items. We haven't seen yet how user management works in Grok, but we will see
    it in the next chapter, so for now we'll just store the project's creator.
  prefs: []
  type: TYPE_NORMAL
- en: A to-do list can have any number of items. We'll also store the list's creation
    date. An item will have a completed date as well as a creation date. We'll also
    keep track of who performed each of these.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we worked with forms that were automatically constructed
    by using interface schemas as a base. At that time, we only added an interface
    for the `Project` class. Let's finish that work and do the same for the other
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: We are dealing with different kinds of objects, but surely there will be some
    attributes that are used in most of them. For example, every project, list, and
    item will have a creator and a creation date. We'd like to avoid repeating these
    attributes on every interface definition, so we'll create a general interface
    for them and make all other classes implement this.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed interfaces briefly before, when working with forms, and saw that
    a class can promise to implement an interface simply by saying that it does so
    by using the `grok.implements` class annotation. However, a class is not limited
    to implementing a single interface. In fact, there's no limit to the number of
    interfaces that a class can implement. This will be useful for us because all
    of our classes can implement both the general metadata interfaces as well as their
    own particular interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our refactored models will look like the code below. First, our shared attributes
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The main application class does not need to use the metadata schema; only its
    own schema will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We added `title` and `next_id` to the schema and set default values for the
    class, after the `grok.implements` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now look at the `Project` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we define the `Project` schema, and then tell Grok that this
    class will use both the schemas this one and the metadata schema that we defined
    earlier. This is fairly simple: we just pass the two interface definitions as
    arguments to `grok.implements`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use the new attributes when a new project is added to the application,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After creating a new project and applying the form data to it, we set values
    for the dates and creator. Keep in mind that interfaces are informative. We are
    never required to use all of the fields in an interface's schema, but it's very
    convenient to be able to refer to the schema for documentation purposes. In some
    cases, it is used to generate a form using one or more fields from it. Incidentally,
    it's probably very clear what's happening in the date assignments, but the `self.request.principal.title`
    line may seem a bit odd. A **principal** is a user in Grok, and its title is a
    string description of who this user is.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s all there is to know for now about our model restructuring. Here are
    the final two models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have added the desired attributes and interfaces, let''s create
    a home page template where we can see at a glance all our projects and their attributes,
    along with links to every project. This will be our application''s dashboard.
    While we are at it, let''s add a search box at the top, too. We''ll start by adding
    a view for our dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, for the template, call the `dashboard.pt` file and place it inside `app_templates`.
    Notice how we use the name `index`, so that this will be the default view for
    the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The template is very straightforward. We just get all of the projects by using
    the `context/values` call and then iterate through the results showing all of
    the attributes in a table. The template can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A brief diversion: Structuring our application for search](img/7481_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Back to search: Using multiple indexes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's recap briefly where we were with respect to the search before we set out
    to reorganize our code. The key thing to understand when using the catalog in
    Grok is that the indexes define the kinds of searches that we can perform. In
    our example, we used a `Text` index for the `title` attribute and the Grok context
    for that index was the `Project` model. This means that even if a project has
    several attributes, we can only search inside the title, at this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not limited to using only one index, of course. We can add any number
    of indexes even one for every attribute of the object. Let''s add one for `description`,
    immediately after the title in the `ProjectIndexes` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the only thing that changes is the index name, which points to the
    actual attribute to be indexed. To keep things simple for now, we can use the
    following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We pass the `query` parameter to both indexes, because all we have is a text
    box with room for one parameter. The results will be all of the projects for which
    both the title and description match the values specified in the query. If we
    had several parameters, we could pass a different value to each index and we would
    get back all of the items where all indexes match.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider how we would like the search box to work in this application.
    The ideal thing would be for it to be as inclusive as possible, so that we could
    type a word or two and have the catalog look at different indexes to find results.
    For example, it would be good if a text search could be performed in such a way
    that the catalog returns all items that match the query either on the `description`
    or the `title` indexes. As this is a common situation, Grok offers a solution
    that is generally useful and also easy to implement. Basically, we can define
    a method that can collect information from all of the attributes and return the
    collected information as a single index.
  prefs: []
  type: TYPE_NORMAL
- en: First, we add an empty method definition to our interface. This is done both
    to document the method and to let the `grok.Indexes` class find the attribute
    when we declare its name as an index. Remember, the project indexes are connected
    to the `IProject` interface, so that every attribute or method defined here may
    be used as an index for searching.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention to the absence of a `self` parameter inside the method definition.
    This parameter is not necessary because we are not defining a class, but an interface.
    It is customary to include a description of the method as a comment in the body
    of its definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then add this method''s name as an index in the `ProjectIndexes` class,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Grok uses the interface definition to find a method or attribute with this
    name. If it''s a method, it will be called at the time of indexing, so what is
    happening here is that we are informing Grok that the full-text entry for a project
    will be available by calling its own `searchableText` method. This method is then
    defined in the `Project` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The method is extremely simple. We just return the `title` and `description`
    attributes as a single string, so that the index will actually include both fields.
    In this way, we can search both of them at the same time by querying the catalog
    with the new `searchableText` index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: That's all we need to cover this requirement, but as we can see, this approach
    can be used to have the `index` method return any kind of content, which gives
    us enough freedom to create any number of combined indexes that we may need.
  prefs: []
  type: TYPE_NORMAL
