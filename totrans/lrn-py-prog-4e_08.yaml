- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Files and Data Persistence
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件和数据持久化
- en: ”It is not that I’m so smart, it is just that I stay with problems longer.”
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “不是因为我有多聪明，只是我愿意与问题相处更久。”
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Albert Einstein
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: – 阿尔伯特·爱因斯坦
- en: In the previous chapters, we explored several different aspects of Python. As
    the examples have a didactic purpose, we ran them in a simple Python shell or
    in the form of a Python module. They ran, maybe printed something on the console,
    and then they terminated, leaving no trace of their brief existence.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了Python的几个不同方面。由于示例具有教学目的，我们在简单的Python shell或Python模块的形式下运行它们。它们运行，可能在控制台上打印了一些内容，然后终止，没有留下它们短暂存在的痕迹。
- en: Real-world applications are rather different. Naturally, they still run in memory,
    but they interact with networks, disks, and databases. They also exchange information
    with other applications and devices, using formats that are suitable for the situation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 实际应用相当不同。自然地，它们仍然在内存中运行，但它们与网络、磁盘和数据库交互。它们还与其他应用程序和设备交换信息，使用适合该情况格式的格式。
- en: 'In this chapter, we are going to start closing in on the real world by exploring
    the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过探索以下内容来开始关注现实世界：
- en: Files and directories
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件和目录
- en: Compression
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩
- en: Networks and streams
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络和流
- en: The JSON data-interchange format
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON数据交换格式
- en: Data persistence with `pickle` and `shelve` from the standard library
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准库中的`pickle`和`shelve`进行数据持久化
- en: Data persistence with SQLAlchemy
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SQLAlchemy进行数据持久化
- en: Configuration files
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件
- en: As usual, we will try to balance breadth and depth so that by the end of the
    chapter, you will have a solid grasp of the fundamentals and will know how to
    fetch further information from the web.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们将尝试平衡广度和深度，以便到本章结束时，你将牢固掌握基础知识，并知道如何从网络中获取更多信息。
- en: Working with files and directories
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与文件和目录一起工作
- en: When it comes to files and directories, Python offers plenty of useful tools.
    In the following examples, we will use the `os` , `pathlib` , and `shutil` modules.
    As we will be reading and writing on the disk, we will be using a file, `fear.txt`
    , which contains an excerpt from *Fear* , by Thich Nhat Hanh, as a base for some
    of our examples.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到文件和目录时，Python提供了许多有用的工具。在下面的示例中，我们将使用`os`、`pathlib`和`shutil`模块。由于我们将要在磁盘上进行读写操作，我们将使用一个文件`fear.txt`作为一些示例的基础，该文件包含来自一行禅宗大师一行禅的《恐惧》摘录。
- en: Opening files
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打开文件
- en: 'Opening a file in Python is simple and intuitive. In fact, we just need to
    use the `open()` function. Let us see a quick example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中打开文件简单直观。实际上，我们只需要使用`open()`函数。让我们看看一个快速示例：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The previous code is straightforward. We call `open()` , passing the filename,
    and telling `open()` that we want to read it in text mode (via the `"rt"` flag).
    There is no path information before the filename; therefore, `open()` will assume
    the file is in the same folder the script is run from. This means that if we run
    this script from outside the `files` folder, then `fear.txt` will not be found.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码很简单。我们调用`open()`，传递文件名，并告诉`open()`我们想要以文本模式（通过`"rt"`标志）读取它。文件名之前没有路径信息；因此，`open()`将假设文件位于脚本运行的同一文件夹中。这意味着如果我们从这个`files`文件夹外部运行此脚本，那么`fear.txt`将找不到。
- en: Once the file has been opened, we obtain a file object, `fh` , which we can
    use to work on the content of the file. We chose that name because, in Python,
    a file object is essentially a high-level abstraction that wraps the underlying
    file handle ( `fh` ). In this case, we use the `readlines()` method to iterate
    over all the lines in the file and print them. We call `strip()` on each line
    to get rid of any extra spaces around the content, including the line termination
    character at the end, since `print()` will already add one for us. This is a quick
    and dirty solution that works in this example but should the content of the file
    contain meaningful spaces that need to be preserved, you will have to be slightly
    more careful in how you sanitize the data. At the end of the script, we close
    the stream.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件被打开，我们就获得了一个文件对象，`fh`，我们可以用它来处理文件的内容。我们选择这个名字是因为，在Python中，文件对象本质上是一个高级抽象，它封装了底层的文件句柄（`fh`）。在这种情况下，我们使用`readlines()`方法遍历文件中的所有行并打印它们。我们对每一行调用`strip()`以去除内容周围的任何额外空格，包括行终止字符，因为`print()`已经为我们添加了一个。这是一个快速且简单的解决方案，在这个例子中有效，但如果文件内容包含需要保留的有意义的空格，你将不得不在清理数据时更加小心。在脚本末尾，我们关闭流。
- en: Closing a file is important as we do not want to risk failing to release the
    handle ( `fh` ) we have on it. When that happens, you can encounter issues such
    as memory leaks, or the annoying *“you cannot delete this file”* pop-up that informs
    you that some software is still using it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭文件很重要，因为我们不希望冒无法释放我们对它的句柄（`fh`）的风险。当这种情况发生时，你可能会遇到内存泄漏或令人烦恼的 *“你不能删除此文件”*
    弹窗，告诉你某些软件仍在使用它。
- en: 'Therefore, we need to apply some precautions and wrap the previous logic in
    a `try/finally` block. This means that, whatever error might occur when we try
    to open and read the file, we can rest assured that `close()` will be called:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要采取一些预防措施，并将之前的逻辑包装在 `try/finally` 块中。这意味着无论我们尝试打开和读取文件时可能发生的任何错误，我们都可以确信
    `close()` 会被调用：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The logic is the same, but now it is also safe.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑是相同的，但现在它也是安全的。
- en: If you are not familiar with the `try` / `finally` block, make sure you go back
    to the *Handling Exceptions* section of *Chapter 7* , *Exceptions and Context
    Managers* , and study it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉 `try` / `finally` 块，请确保你回到 *第7章* 的 *处理异常* 部分，*异常和上下文管理器*，并学习它。
- en: 'We can simplify the previous example further like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步简化之前的例子，如下所示：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The default mode for opening files is `"rt"` , so we do not need to specify
    it. Moreover, we can simply iterate on `fh` without explicitly calling `readlines()`
    on it. Python often gives us shorthands to make our code more compact and simpler
    to read.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件的默认模式是 `"rt"`，因此我们不需要指定它。此外，我们可以简单地迭代 `fh`，而不需要显式调用 `readlines()`。Python
    经常给我们提供简写，使我们的代码更加紧凑且易于阅读。
- en: 'All the previous examples produce a print of the file on the console (check
    out the source code to read the whole content):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前一个例子都会在控制台上打印出文件的内容（查看源代码以读取全部内容）：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using a context manager to open a file
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用上下文管理器打开文件
- en: 'To avoid having to use `try` / `finally` blocks throughout our code, Python
    gives us a nicer and equally safe way to do it: by using a context manager. Let
    us see the code first:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在代码中到处使用 `try` / `finally` 块，Python 给我们提供了一种更优雅且同样安全的做法：通过使用上下文管理器。让我们先看看代码：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This example is equivalent to the previous one but reads better. The `open()`
    function returns a file object when invoked by a context manager, and it conveniently
    calls `fh.close()` automatically when execution exits the context manager scope.
    This will happen even in the case of errors.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与上一个例子等效，但读起来更好。当通过上下文管理器调用时，`open()` 函数返回一个文件对象，并且当执行退出上下文管理器的作用域时，它会方便地自动调用
    `fh.close()`。即使发生错误，也会发生这种情况。
- en: Reading from and writing to a file
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从文件中读取和写入
- en: 'Now that we know how to open a file, let us see how to read from and write
    to it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何打开文件，让我们看看如何从文件中读取和写入：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This first approach uses the `print()` function, with which we are already familiar
    from previous chapters. After obtaining a file object, this time specifying that
    we intend to write to it ( `"w"` ), we can tell the call to `print()` to direct
    its output to the file, instead of to the **standard output** stream as it normally
    does.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种第一种方法使用 `print()` 函数，我们已经在之前的章节中熟悉了它。在获得文件对象后，这次指定我们打算写入它（`"w"`），我们可以告诉 `print()`
    调用将输出定向到文件，而不是像通常那样定向到 **标准输出** 流。
- en: In Python, the standard input, output, and error streams are represented by
    the file objects `sys.stdin` , `sys.stdout` , and `sys.stderr` . Unless input
    or output is redirected, reading from `sys.stdin` usually corresponds to reading
    from the keyboard, and writing to `sys.stdout` or `sys.stderr` usually prints
    to the console screen.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，标准输入、输出和错误流由文件对象 `sys.stdin`、`sys.stdout` 和 `sys.stderr` 表示。除非输入或输出被重定向，否则从
    `sys.stdin` 读取通常对应于从键盘读取，而将内容写入 `sys.stdout` 或 `sys.stderr` 通常会在控制台屏幕上打印。
- en: The previous code creates the `print_example.txt` file if it does not exist,
    or truncates it if it does, and writes the line `Hey I am printing into a file!!!`
    into it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码会在文件不存在时创建 `print_example.txt` 文件，或者如果它已存在，则截断它，并将行 `Hey I am printing
    into a file!!!` 写入其中。
- en: Truncating a file means erasing its contents without deleting it. After truncation,
    the file still exists on the filesystem, but it is empty.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 截断文件意味着在不删除文件的情况下擦除其内容。截断后，文件仍然存在于文件系统中，但它为空。
- en: 'This example does the job, but it is not what we would typically do when writing
    to a file. Let us see a more common approach:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子完成了工作，但这并不是我们写入文件时通常会做的事情。让我们看看一种更常见的方法：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we first open `fear.txt` and gather its content into a list,
    line by line. Notice that, this time, we are calling a different method, `rstrip()`
    , as an example, to make sure we only strip the whitespace on the right-hand side
    of every line.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先打开 `fear.txt` 并逐行收集其内容到一个列表中。注意，这次我们调用了一个不同的方法 `rstrip()`，作为一个例子，以确保我们只去除每行的右侧空白。
- en: In the second part of the snippet, we create a new file, `fear_copy.txt` , and
    we write to it all the strings in `lines` , joined by a newline, `\n` . Python
    works by default with **universal newlines** , which means that even though the
    original file might have a newline that is different from `\n` , it will be translated
    automatically for us before the line is returned. This behavior is, of course,
    customizable, but normally it is exactly what we want. Speaking of newlines, can
    you think of one that might be missing in the copy?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段的第二部分，我们创建了一个新文件 `fear_copy.txt`，并将 `lines` 中的所有字符串写入其中，通过换行符 `\n` 连接。Python
    默认使用 **通用换行符**，这意味着即使原始文件可能有与 `\n` 不同的换行符，它也会在我们返回行之前自动为我们转换。这种行为当然是可以定制的，但通常这正是我们想要的。说到换行符，你能想到在复制中可能缺失的一个吗？
- en: Reading and writing in binary mode
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以二进制模式读写
- en: Notice that by opening a file and passing `t` in the options (or omitting it,
    as it is the default), we are opening the file in text mode. This means that the
    content of the file is treated and interpreted as text.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过打开一个文件并传递 `t` 选项（或者省略它，因为它默认是这样），我们是以文本模式打开文件的。这意味着文件的内容被当作文本处理和解释。
- en: If you wish to write bytes to a file, you can open it in **binary mode** . This
    is a common requirement when you handle files that do not just contain raw text,
    such as images, audio/video, and, in general, any other proprietary format.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望向文件写入字节，你可以以 **二进制模式** 打开它。当你处理不包含纯文本的文件时，这是一个常见的需求，例如图像、音频/视频，以及通常的任何其他专有格式。
- en: 'To handle files in binary mode, simply specify the `b` flag when opening them,
    as in the following example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要以二进制模式处理文件，只需在打开时指定 `b` 标志，如下面的例子所示：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, we are still using text as binary data, for simplicity, but
    it could be anything you want. You can see it is treated as binary by the fact
    that you get the `b` prefix in the output string.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们仍然使用文本作为二进制数据，为了简单起见，但它可以是任何你想要的东西。你可以看到它被当作二进制处理，因为输出字符串中有 `b` 前缀。
- en: Protecting against overwriting an existing file
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防止覆盖现有文件
- en: 'As we have seen, Python gives us the ability to open files for writing. By
    using the `w` flag, we open a file and truncate its content. This means the file
    is overwritten with an empty file, and the original content is lost. If you wish
    to only open a file for writing if it does not already exist, you can use the
    `x` flag instead, as in the following example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Python 给我们提供了打开文件进行写入的能力。通过使用 `w` 标志，我们打开一个文件并截断其内容。这意味着文件被一个空文件覆盖，原始内容丢失。如果你希望只有在文件不存在时才打开文件进行写入，你可以使用
    `x` 标志，如下面的例子所示：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you run this snippet, you will find a file called `write_x.txt` in your
    directory, containing only one line of text. The second part of the snippet, in
    fact, fails to execute. This is the output we get on our console (the file path
    has been shortened for editorial purposes):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个代码片段，你将在你的目录中找到一个名为 `write_x.txt` 的文件，其中只包含一行文本。实际上，代码片段的第二部分未能执行。这是我们控制台上的输出（为了编辑目的，文件路径已被缩短）：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we have seen, there are different modes for opening a file. You can find
    the full list of flags at [https://docs.python.org/3/library/functions.html#open](https://docs.python.org/3/library/functions.html#open)
    .
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，打开文件有不同的模式。你可以在 [https://docs.python.org/3/library/functions.html#open](https://docs.python.org/3/library/functions.html#open)
    找到完整的标志列表。
- en: Checking for file and directory existence
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查文件和目录是否存在
- en: 'If you want to make sure a file or directory exists (or does not), the `pathlib`
    module is what you need. Let us see a small example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要确保一个文件或目录存在（或者不存在），你需要使用 `pathlib` 模块。让我们看一个小例子：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding snippet, we create a `Path` object that we set up with the
    name of the text file we want to inspect. We use the `parent()` method to retrieve
    the folder in which the file is contained, and we call the `absolute()` method
    on it to extract the absolute path information.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个 `Path` 对象，我们用要检查的文本文件的名字来设置它。我们使用 `parent()` 方法来检索包含文件的文件夹，并对其调用
    `absolute()` 方法以提取绝对路径信息。
- en: We check if `"fear.txt"` is a file and the folder in which it is contained is
    indeed a folder (or directory, which is equivalent).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查`"fear.txt"`是否是一个文件，以及它所在的文件夹确实是一个文件夹（或目录，两者等价）。
- en: The old way to do these operations was to use the `os.path` module from the
    standard library. While `os.path` works on strings, `pathlib` offers classes representing
    filesystem paths with semantics appropriate for different operating systems. Hence,
    we suggest using `pathlib` whenever possible, and reverting to the old way of
    doing things only when there is no alternative.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以前执行这些操作的方法是使用标准库中的`os.path`模块。虽然`os.path`在字符串上工作，但`pathlib`提供了表示文件系统路径的类，具有适用于不同操作系统的语义。因此，我们建议尽可能使用`pathlib`，只有在没有其他选择的情况下才回退到旧的方法。
- en: Manipulating files and directories
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件和目录操作
- en: 'Let us see a couple of quick examples of how to manipulate files and directories.
    The first example manipulates the content:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个快速示例，说明如何操作文件和目录。第一个示例操作内容：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This example defines two functions: `sanitize()` and `reverse()` . They are
    simple functions whose purpose is to remove anything that is not a letter or space
    from a string and produce the reversed copy of a string, respectively.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例定义了两个函数：`sanitize()`和`reverse()`。它们是简单的函数，其目的是从一个字符串中移除所有非字母或空格的字符，并分别产生字符串的反转副本。
- en: 'We open `fear.txt` and we read its content into a list. Then we create a new
    file, `raef.txt` , which will contain the horizontally mirrored version of the
    original. We write all the content of `lines` with a single operation, using `join`
    on a newline character. Maybe more interesting is the bit at the end. First, we
    reassign `lines` to a sanitized version of itself by means of a list comprehension.
    Then we put the lines together in the `whole` string, and finally, we pass the
    result to a `Counter` object. Notice that we split the lowercase version of the
    string into a list of words. This way, each word will be counted correctly, regardless
    of its case, and, thanks to `split()` , we don’t need to worry about extra spaces
    anywhere. When we print the three most common words, we realize that, truly, Thich
    Nhat Hanh’s focus was on others, as *“we”* is the most common word in the text:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开`fear.txt`并将其内容读取到一个列表中。然后我们创建一个新的文件`raef.txt`，它将包含原始的横向镜像版本。我们通过在换行符上使用`join`操作，一次性写入`lines`中的所有内容。也许更有趣的是结尾的部分。首先，我们通过列表推导式将`lines`重新赋值为它的净化版本。然后我们将这些行组合成一个`whole`字符串，最后，我们将结果传递给一个`Counter`对象。请注意，我们将字符串的小写版本拆分成一个单词列表。这样，每个单词都会被正确计数，无论其大小写如何，而且，多亏了`split()`，我们不需要担心任何地方的额外空格。当我们打印最常见的三个单词时，我们意识到，确实，一行禅的焦点是他人，因为*“我们”*是文本中最常见的单词：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let us now see an example of manipulation that’s more related to disk operations,
    in which we put the `shutil` module to use:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个更接近磁盘操作的示例，我们将使用`shutil`模块：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code, we start by declaring a base path, which will contain
    all the files and folders we are going to create. We then use `mkdir()` to create
    two directories: `ops_example/A/B` and `ops_example/A/C` . Notice that we don’t
    need to specify `parents=True` when calling `path_c.mkdir()` , since all the parents
    have already been created by the previous call on `path_b` .'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先声明了一个基础路径，该路径将包含我们即将创建的所有文件和文件夹。然后，我们使用`mkdir()`创建两个目录：`ops_example/A/B`和`ops_example/A/C`。请注意，在调用`path_c.mkdir()`时，我们不需要指定`parents=True`，因为所有父目录都已经在之前的`path_b`调用中创建好了。
- en: We use the `/` operator to concatenate directory names; `pathlib` takes care
    of using the right path separator for us, behind the scenes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`/`运算符来连接目录名称；`pathlib`会为我们处理背后的正确路径分隔符。
- en: 'After creating the directories, we loop to create three files in directory
    `B` . Then, we move directory `B` and its contents to a different name: `D` .
    We also could have done this in another way: `path_b.rename(path_d)` .'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建目录后，我们在目录`B`中循环创建三个文件。然后，我们将目录`B`及其内容移动到不同的名称：`D`。我们也可以用另一种方式来做这件事：`path_b.rename(path_d)`。
- en: 'Finally, we rename `ex1.txt` to `ex1.renamed.txt` . If you open that file,
    you will see it still contains the original text from the loop logic. Calling
    `tree` on the result produces the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`ex1.txt`重命名为`ex1.renamed.txt`。如果你打开该文件，你会看到它仍然包含循环逻辑中的原始文本。对结果调用`tree`会产生以下内容：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Manipulating pathnames
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作路径名
- en: 'Let us explore the abilities of `pathlib` a little more by means of an example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来更深入地探索`pathlib`的能力：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Reading the result is probably a good enough explanation for this simple example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读结果可能是对这个简单例子足够好的解释：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note how, in the last two lines, we have two different representations of the
    same path. The first one ( `readme_path.absolute()` ) shows two `"` `.."` , each
    of which, in path terms, indicates changing to the parent folder. So, by changing
    to the parent folder twice in a row, from `…/lpp4e/ch08/files/` , we go back to
    `…/lpp4e/` . This is confirmed by the last line in the example, which shows the
    output of `readme_path.resolve()` .
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在最后两行中，我们有同一路径的两种不同表示。第一个（`readme_path.absolute()`）显示了两个 `"` `.."`，每个在路径术语中都表示切换到父文件夹。因此，通过连续两次切换到父文件夹，从
    `…/lpp4e/ch08/files/`，我们回到了 `…/lpp4e/`。这由示例中的最后一行确认，它显示了 `readme_path.resolve()`
    的输出。
- en: Temporary files and directories
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 临时文件和目录
- en: 'Sometimes, it is useful to create a temporary directory or file. For example,
    when writing tests that affect the disk, you can use temporary files and directories
    to run your logic and assert that it is correct, and to be sure that at the end
    of the test run, the test folder has no leftovers. Let us see how to do it in
    Python:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，创建一个临时目录或文件是有用的。例如，当编写影响磁盘的测试时，你可以使用临时文件和目录来运行你的逻辑并断言它是正确的，并且确保在测试运行结束时，测试文件夹没有遗留物。让我们看看如何在
    Python 中做到这一点：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding example is quite straightforward: we create a temporary directory
    in the current one ( `"."` ), and we create a named temporary file in it. We print
    the filename, as well as its full path:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子相当简单：我们在当前目录（`"."`）中创建一个临时目录，并在其中创建一个命名的临时文件。我们打印文件名，以及它的完整路径：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Running this script will produce a different result every time as these are
    temporary random names.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个脚本将每次产生不同的结果，因为这些是临时的随机名称。
- en: Directory content
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目录内容
- en: 'With Python, you can also inspect the contents of a directory. We will show
    you two ways of doing this. This is the first one:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python，你还可以检查目录的内容。我们将向你展示两种方法。这是第一种：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This snippet uses the `glob()` method of a `Path` object, applied from the
    current directory. We iterate over the results, each of which is an instance of
    a subclass of `Path` ( `PosixPath` or `WindowsPath` , according to which OS we
    are running). For each `entry` , we inspect if it is a directory, and print accordingly.
    Running the code yields the following (we omitted a few results for brevity):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段使用了 `Path` 对象的 `glob()` 方法，从当前目录应用。我们遍历结果，每个结果都是一个 `Path` 子类的实例（`PosixPath`
    或 `WindowsPath`，根据我们运行的操作系统）。对于每个 `entry`，我们检查它是否是目录，并相应地打印。运行代码将产生以下结果（为了简洁，我们省略了一些结果）：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'An alternative way is to use the `Path.walk()` method to scan a directory tree.
    Let us see an example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 `Path.walk()` 方法来扫描目录树。让我们看一个例子：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Running the preceding snippet will produce a list of all the files and directories
    in the current one, and it will do the same for each sub-directory. In the source
    code for this book, you will find another module, `walking.py` , which does exactly
    the same but uses the `os.walk()` function instead.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码片段将生成当前目录中所有文件和目录的列表，并且它将为每个子目录做同样的事情。在本书的源代码中，你会找到一个名为 `walking.py`
    的模块，它做的是完全相同的事情，但使用的是 `os.walk()` 函数。
- en: File and directory compression
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件和目录压缩
- en: 'Before we leave this section, let us give you an example of how to create a
    compressed file. In the source code for this chapter, in the `files/compression`
    folder, we have two examples: one creates a `.zip` file, while the other one creates
    a `tar.gz` file. Python allows you to create compressed files in several different
    ways and formats. Here, we are going to show you how to create the most common
    one, **ZIP** :'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开这个部分之前，让我们给你一个如何创建压缩文件的例子。在本章的源代码中，在 `files/compression` 文件夹中，我们有两个例子：一个创建
    `.zip` 文件，而另一个创建 `tar.gz` 文件。Python 允许你以多种不同的方式和格式创建压缩文件。在这里，我们将向你展示如何创建最常见的一种，**ZIP**：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code, we import `ZipFile` , and then, within a context manager,
    we write into it four files (two of which are in a sub-folder, to show how ZIP
    preserves the full path). Afterward, as an example, we open the compressed file
    and extract a couple of files from it into the `extract_zip` directory. If you
    are interested in learning more about data compression, make sure you check out
    the *Data Compression and Archiving* section on the standard library ( [https://docs.python.org/3.9/library/archiving.html](https://docs.python.org/3.9/library/archiving.html)
    ), where you’ll be able to learn all about this topic.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们导入`ZipFile`，然后在上下文管理器中写入四个文件（其中两个位于子文件夹中，以展示ZIP如何保留完整路径）。之后，作为一个例子，我们打开压缩文件，从中提取一些文件到`extract_zip`目录。如果您对数据压缩感兴趣，请确保查看标准库中的*数据压缩和归档*部分（[https://docs.python.org/3.9/library/archiving.html](https://docs.python.org/3.9/library/archiving.html)），在那里您可以了解有关此主题的所有内容。
- en: Data interchange formats
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据交换格式
- en: Modern software architectures tend to split an application into several components.
    Whether you embrace the service-oriented architecture paradigm or push it even
    further into the microservices realm, these components will have to exchange data.
    But even if you are coding a monolithic application whose codebase is contained
    in one project, chances are that you still have to exchange data with APIs or
    programs, or simply handle the data flow between the frontend and backend parts
    of your website, which likely won’t speak the same language.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现代软件架构倾向于将应用程序拆分为几个组件。无论您是采用面向服务的架构范式，还是将其进一步推进到微服务领域，这些组件都必须要交换数据。但即使您正在编写一个单体应用程序，其代码库包含在一个项目中，您仍然可能需要与API或程序交换数据，或者简单地处理网站的前端和后端部分之间的数据流，这些部分可能不会使用相同的语言。
- en: Choosing the right format in which to exchange information is crucial. A language-specific
    format has the advantage that the language itself is likely to provide you with
    all the tools to make **serialization** and **deserialization** a breeze. However,
    you will lack the ability to talk natively to other components that have been
    written in different versions of the same language, or in different languages
    altogether. Regardless of what the future looks like, going with a language-specific
    format should only be done if it is the only possible choice for the given situation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的信息交换格式至关重要。语言特定的格式具有优势，因为该语言本身很可能为您提供所有工具，使**序列化**和**反序列化**变得轻而易举。然而，您将无法与用同一语言的不同版本或完全不同的语言编写的其他组件进行本地通信。无论未来看起来如何，只有在是给定情况下唯一可能的选择时，才应该采用语言特定的格式。
- en: 'According to Wikipedia ( [https://en.wikipedia.org/wiki/Serialization](https://en.wikipedia.org/wiki/Serialization)
    ):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科（[https://en.wikipedia.org/wiki/Serialization](https://en.wikipedia.org/wiki/Serialization)）：
- en: In computing, serialization is the process of translating a data structure or
    object state into a format that can be stored (for example, in a file or memory
    data buffer) or transmitted (for example, over a computer network) and reconstructed
    later (possibly in a different computer environment).
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在计算机科学中，序列化是将数据结构或对象状态转换为一种可以存储（例如，在文件或内存数据缓冲区中）或传输（例如，通过计算机网络）的格式，并在以后重建（可能在不同的计算机环境中）的过程。
- en: A safer approach is to choose a language-agnostic format. In software, some
    popular formats have become the de facto standard for data interchange. The most
    famous ones probably are **XML** , **YAML** , and **JSON** . The Python standard
    library features the `xml` and `json` modules, and, on PyPI ( [https://pypi.org/](https://pypi.org/)
    ), you can find a few different packages to work with YAML.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更安全的方法是选择一种语言无关的格式。在软件中，一些流行的格式已经成为数据交换的事实标准。最著名的可能是**XML**、**YAML**和**JSON**。Python标准库提供了`xml`和`json`模块，在PyPI（[https://pypi.org/](https://pypi.org/)）上，您可以找到一些用于处理YAML的不同包。
- en: In the Python environment, JSON is perhaps the most commonly used format. It
    wins over the other two because of being part of the standard library, and for
    its simplicity. XML tends to be quite verbose, and harder to read.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python环境中，JSON可能是最常用的格式。它之所以胜过其他两种，是因为它是标准库的一部分，以及它的简单性。XML往往相当冗长，难以阅读。
- en: Moreover, when working with a database like PostgreSQL, the ability to use native
    JSON fields makes a compelling case for adopting JSON in the application as well.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当与像PostgreSQL这样的数据库一起工作时，能够使用原生JSON字段的能力使得在应用程序中也采用JSON具有很大的吸引力。
- en: Working with JSON
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JSON
- en: '**JSON** is the acronym for **JavaScript Object Notation** , and it is a subset
    of the JavaScript language. It has been around for almost two decades now, so
    it is well known and widely adopted by most languages, even though it is actually
    language independent. You can read all about it on its website ( [https://www.json.org/](https://www.json.org/)
    ), but we are going to give you a quick introduction to it now.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON**是**JavaScript Object Notation**的缩写，它是JavaScript语言的一个子集。它已经存在了近二十年，因此它广为人知，并被大多数语言广泛采用，尽管它实际上是语言无关的。你可以在其网站上阅读所有关于它的信息（[https://www.json.org/](https://www.json.org/)），但现在我们将给你一个快速介绍。'
- en: 'JSON is based on two structures:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: JSON基于两种结构：
- en: A collection of name/value pairs
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组名称/值对
- en: An ordered list of values
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值的有序列表
- en: 'Unsurprisingly, these two objects map to the `dict` and `list` data types in
    Python, respectively. As data types, JSON offers strings, numbers, objects, and
    values consisting of `true` , `false` , and `null` . Let us see a quick example
    to get us started:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，这两个对象分别映射到Python中的`dict`和`list`数据类型。作为数据类型，JSON提供字符串、数字、对象以及由`true`、`false`和`null`组成的值。让我们通过一个快速示例开始：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We begin by importing the `sys` and `json` modules. Then, we create a simple
    dictionary with some numbers and a list of integers. We wanted to test serializing
    and deserializing using very big numbers, both `int` and `float` , so we put 2
    ^(3141) and whatever is the biggest floating point number our system can handle.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入`sys`和`json`模块。然后，我们创建一个包含一些数字和一个整数列表的简单字典。我们想测试使用非常大的数字进行序列化和反序列化，包括`int`和`float`，所以我们放入了2的3141次方以及系统可以处理的最大浮点数。
- en: 'We serialize with `json.dumps()` , which converts data into a JSON formatted
    string. That data is then fed into `json.loads()` , which does the opposite: from
    a JSON formatted string, it reconstructs the data into Python.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`json.dumps()`进行序列化，它将数据转换为JSON格式的字符串。然后，该数据被输入到`json.loads()`中，它执行相反的操作：从一个JSON格式的字符串中，它将数据重构为Python。
- en: Notice that the JSON module also provides the `dump` and `load` functions, which
    convert data to and from a file-like object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，JSON模块还提供了`dump`和`load`函数，它们可以将数据转换为文件对象并从文件对象转换数据。
- en: On the last line, by means of an assertion, we make sure that the original data
    and the result of the serialization/deserialization through JSON match. Should
    the condition that follows the assert statement be falsy, that statement will
    raise an `AssertionError` . We will cover assertions in more detail in *Chapter
    10* , *Testing* .
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，通过断言，我们确保原始数据和通过JSON序列化/反序列化的结果相匹配。如果断言语句后面的条件为假，那么该语句将引发`AssertionError`。我们将在第10章*测试*中更详细地介绍断言。
- en: In programming, the term **falsy** refers to an object or a condition that,
    when evaluated in a boolean context, is considered false.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，术语**falsy**指的是在布尔上下文中评估时被认为是假的对象或条件。
- en: 'Let us see what JSON data would look like if we printed it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们打印JSON数据会是什么样子：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, we create a dictionary with Sherlock Holmes’ data in it. If,
    like us, you are a fan of Sherlock Holmes, and are in London, you will find his
    museum at that address (which we recommend visiting; it is small but very nice).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个包含福尔摩斯数据的字典。如果你像我们一样是福尔摩斯的粉丝，并且身处伦敦，你会在那个地址找到他的博物馆（我们推荐你去参观；虽然不大，但非常不错）。
- en: 'Notice how we call `json.dumps()` , though. We instruct it to indent with two
    spaces and sort keys alphabetically. The result is this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何调用`json.dumps()`的。我们指示它使用两个空格缩进并按字母顺序排序键。结果是这个：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The similarity with Python is evident. The one difference is that if you place
    a comma on the last element in a dictionary, as is customary in Python, JSON will
    complain.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python的相似性显而易见。唯一的区别是，如果你在字典中的最后一个元素后面放置一个逗号，这在Python中是惯例，JSON将会抱怨。
- en: 'Let us show you something interesting:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们展示一些有趣的东西：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, we have used a tuple instead of a list. The interesting bit
    is that, conceptually, a tuple is also an ordered list of items. It does not have
    the flexibility of a list, but still, it is considered the same from the perspective
    of JSON. Therefore, as you can see by the first `print()` , in JSON a tuple is
    transformed into a list. Naturally, then, the information that the original object
    was a tuple is lost, and when deserialization happens, what originally was a tuple
    is instead translated to a Python list. It is important that you keep this in
    mind when dealing with data, as going through a transformation process that involves
    a format that only comprises a subset of the data structures you can use implies
    there may be information loss. In this case, we lost the information about the
    type (tuple versus list).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了一个元组而不是列表。有趣的是，从概念上讲，元组也是一个有序项列表。它没有列表的灵活性，但仍然，从JSON的角度来看，它被认为是相同的。因此，正如你通过第一个`print()`看到的，在JSON中元组被转换成了列表。自然地，那么，原始对象是一个元组的信息就丢失了，在反序列化发生时，原本是元组的东西被转换成了Python列表。在处理数据时，这一点很重要，因为涉及到只包含你可用数据结构子集的格式转换过程可能意味着信息丢失。在这种情况下，我们丢失了关于类型（元组与列表）的信息。
- en: This is actually a common problem. For example, you cannot serialize all Python
    objects to JSON, as it is not always clear how JSON should revert that object.
    Think about `datetime` , for example. An instance of that class is a Python object
    that JSON will not be able to serialize. If we transform it into a string such
    as `2018-03-04T12:00:30Z` , which is the ISO 8601 representation of a date with
    time and time zone information, what should JSON do when deserializing? Should
    it decide that *this is deserializable into a datetime object, so I’d better do
    it* , or should it simply consider it as a string and leave it as it is? What
    about data types that can be interpreted in more than one way?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个常见问题。例如，你不能将所有Python对象序列化为JSON，因为并不总是清楚JSON应该如何还原那个对象。以`datetime`为例。该类的一个实例是一个JSON无法序列化的Python对象。如果我们将其转换为如`2018-03-04T12:00:30Z`这样的字符串，这是ISO
    8601格式的日期和时间以及时区信息，那么在反序列化时JSON应该怎么做？它应该决定*这可以反序列化为datetime对象，所以我最好这么做*，还是简单地将其视为字符串并保持原样？对于可以有多种解释的数据类型呢？
- en: The answer is that when dealing with data interchange, we often need to transform
    our objects into a simpler format prior to serializing them with JSON. The more
    we manage to simplify our data, the easier it is to represent that data in a format
    like JSON, which has limitations.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，在处理数据交换时，我们通常需要在将对象序列化为JSON之前将其转换为更简单的格式。我们能够使数据简化得越多，在像JSON这样的格式中表示数据就越容易，而JSON有其局限性。
- en: 'In some cases, though, and mostly for internal use, it is useful to be able
    to serialize custom objects, so, just for fun, we are going to show you how with
    two examples: complex numbers and *datetime* objects.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，尤其是内部使用时，能够序列化自定义对象非常有用，所以为了好玩，我们将通过两个例子来展示如何实现：复数和*datetime*对象。
- en: Custom encoding/decoding with JSON
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用JSON进行自定义编码/解码
- en: In the JSON world, we can consider terms like encoding/decoding as synonyms
    for serializing/deserializing. They basically mean transforming to and back from
    JSON.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSON的世界里，我们可以将编码/解码术语视为序列化/反序列化的同义词。它们基本上意味着转换到和从JSON转换回来。
- en: 'In the following example, we are going to learn how to encode complex numbers
    – which are not serializable to JSON by default – by writing a custom encoder:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们将学习如何通过编写自定义编码器来编码复数——默认情况下复数不能序列化为JSON：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We start by defining a `ComplexEncoder` class as a subclass of `JSONEncoder`
    . This class overrides the `default()` method. This method is called whenever
    the encoder encounters an object that it cannot encode natively and is expected
    to return an encodable representation of that object.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个`ComplexEncoder`类，作为`JSONEncoder`的子类。这个类重写了`default()`方法。每当编码器遇到它无法原生编码的对象时，都会调用这个方法，并期望它返回该对象的可编码表示。
- en: The `default()` method checks whether its argument is a `complex` object, in
    which case it returns a dictionary with some custom meta information and a list
    that contains both the real and the imaginary part of the number. That is all
    we need to do to avoid losing information for a complex number. If we receive
    anything other than an instance of `complex` , we call the `default()` method
    from the parent class.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`default()` 方法检查其参数是否是一个 `complex` 对象，如果是的话，它将返回一个包含一些自定义元信息和包含数字实部和虚部的列表的字典。这就是我们避免丢失复数信息所需做的全部工作。如果我们收到除
    `complex` 实例之外的其他任何内容，我们将从父类调用 `default()` 方法。'
- en: 'In the example, we then call `json.dumps()` , but this time we use the `cls`
    argument to specify the custom encoder. Finally, the result is printed:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们随后调用了 `json.dumps()`，但这次我们使用 `cls` 参数来指定自定义编码器。最后，结果被打印出来：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Half the job is done. For the deserialization part, we could have written another
    class that would inherit from `JSONDecoder` , but instead, we have chosen to use
    a different technique that is simpler and uses a small function: `object_hook()`
    .'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有一半的工作已经完成了。对于反序列化部分，我们本可以编写另一个从 `JSONDecoder` 继承的类，但相反，我们选择使用一种更简单的技术，它使用一个小的函数：`object_hook()`。
- en: Within the body of `object_hook()` , we find a `try` block. The important part
    is the two lines within the body of the `try` block itself. The function receives
    an object (note that the function is only called when `obj` is a dictionary),
    and if the metadata matches our convention for complex numbers, we pass the real
    and imaginary parts to the `complex()` function. The `try` / `except` block is
    there because our function will be called for every dictionary object that is
    decoded, so we need to handle the case where our `_meta` key is not present.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `object_hook()` 的主体中，我们找到一个 `try` 块。重要的是 `try` 块主体中的两行。该函数接收一个对象（注意，只有当 `obj`
    是字典时，该函数才会被调用），如果元数据与我们的复数约定相匹配，我们将实部和虚部传递给 `complex()` 函数。`try` / `except` 块的存在是因为我们的函数将为每个解码的字典对象被调用，因此我们需要处理
    `_meta` 键不存在的情况。
- en: 'The decoding part of the example outputs:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 示例的反序列化部分输出：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can see that `a_complex` has been correctly deserialized. As an exercise,
    we suggest writing your own custom encoders for `Fraction` and `Decimal` objects.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到 `a_complex` 已经被正确反序列化。作为练习，我们建议编写你自己的自定义编码器，用于 `Fraction` 和 `Decimal`
    对象。
- en: 'Let us now consider a slightly more complex (no pun intended) example: dealing
    with `datetime` objects. We are going to split the code into two blocks, first
    the serializing part, and then the deserializing part:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个稍微复杂一些（不是字面意义上的）例子：处理 `datetime` 对象。我们将把代码分成两个部分，首先是序列化部分，然后是反序列化部分：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The reason this example is slightly more complex lies in the fact that `datetime`
    objects in Python can either be time-zone-aware or not; therefore, we need to
    handle them carefully. The flow is as before, only we are dealing with a different
    data type. We start by getting the current date and time information, and we do
    it both without ( `now` ) and with ( `now_tz` ) time zone awareness. We then proceed
    to define a custom encoder as before, overriding the `default()` method. The important
    bits in that method are how we get the time zone offset ( `off` ) information,
    in seconds, and how we structure the dictionary that returns the data. This time,
    the metadata says it is *datetime* information. We save the first six items from
    the time tuple (year, month, day, hour, minute, and second), plus the microseconds
    in the `data` key, and the offset after that. Good job if you could tell that
    the value of `"data"` is a concatenation of tuples.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子之所以稍微复杂一些，是因为 Python 中的 `datetime` 对象可以是时区感知的，也可以不是；因此，我们需要小心处理它们。流程与之前相同，只是我们现在处理的是不同的数据类型。我们首先获取当前的日期和时间信息，并且我们在没有（`now`）和有（`now_tz`）时区感知的情况下都这样做。然后我们继续定义一个自定义编码器，就像之前一样，覆盖了
    `default()` 方法。该方法中的重要部分是我们如何获取时区偏移量（`off`）信息（以秒为单位），以及我们如何构建返回数据的字典。这次，元数据表明这是
    *datetime* 信息。我们将时间元组的前六项（年、月、日、时、分和秒）保存在 `data` 键中，以及之后的微秒，然后是偏移量。如果你能看出 `"data"`
    的值是元组的拼接，那么你做得很好。
- en: 'After the custom encoder, we proceed to create some data, and then we serialize
    it. The `print()` statement outputs the following (we have reformatted the output
    to make it more readable):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在自定义编码器之后，我们继续创建一些数据，然后对其进行序列化。`print()` 语句输出了以下内容（我们已重新格式化输出，使其更易于阅读）：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Interestingly, we find out that `None` is translated to `null` , its JavaScript
    equivalent. Moreover, we can see that the data seems to have been encoded properly.
    Let us proceed with the second part of the script:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们发现 `None` 被翻译成了其JavaScript等价物 `null`。此外，我们可以看到数据似乎已经被正确编码。让我们继续脚本的第二部分：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once again, we first verify that the metadata is telling us it is a `datetime`
    , and then we proceed to fetch the time zone information. Once we have it, we
    pass the 7-tuple (using `*` to unpack its values in the call) and the time zone
    information to the `datetime()` call, getting back our original object. Let us
    verify it by printing `data_out` :'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们首先验证元数据告诉我们它是一个 `datetime`，然后我们继续获取时区信息。一旦我们有了它，我们就将7元组（使用 `*` 在调用中解包其值）和时区信息传递给
    `datetime()` 调用，得到我们原始的对象。让我们通过打印 `data_out` 来验证它：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, we got everything back correctly. As an exercise, we suggest
    you write the same logic but for a `date` object, which should be simpler.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们正确地获取了所有内容。作为练习，我们建议你编写相同的逻辑，但针对 `date` 对象，这应该会简单一些。
- en: Before we move on to the next topic, a word of caution. Perhaps it is counter-intuitive,
    but working with `datetime` objects can be quite tricky, so although we are pretty
    sure this code is doing what it is supposed to do, we want to stress that we only
    tested it superficially. So, if you intend to use it, please do test it thoroughly.
    Test for different time zones, test for daylight saving time being on and off,
    test for dates before the epoch, and so on. You might find that the code in this
    section needs some modifications to suit your case.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一个主题之前，有一个警告。可能这听起来有些反直觉，但处理 `datetime` 对象可能相当棘手，所以我们虽然相当确信这段代码正在做它应该做的事情，但我们想强调我们只是对其进行了表面测试。因此，如果你打算使用它，请务必彻底测试。测试不同的时区，测试夏令时是否开启或关闭，测试纪元之前的日期，等等。你可能会发现本节中的代码需要一些修改才能适应你的情况。
- en: I/O, streams, and requests
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: I/O、流和请求
- en: '**I/O** stands for **input/output** , and it broadly refers to the communication
    between a computer and the outside world. There are several different types of
    I/O, and it is outside the scope of this chapter to explain all of them, but it
    is worth going through a couple of examples. The first one will introduce the
    `io.StringIO` class, which is an in-memory stream for text I/O. The second one
    instead will escape the locality of our computer and demonstrate how to perform
    an HTTP request.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**I/O** 代表 **输入/输出**，它广泛地指代计算机与外部世界之间的通信。有几种不同的I/O类型，本章的范围不包括解释所有这些类型，但值得通过几个例子来了解。第一个例子将介绍
    `io.StringIO` 类，这是一个用于文本I/O的内存流。第二个例子将超出我们计算机的本地性，演示如何执行HTTP请求。'
- en: Using an in-memory stream
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内存中的流
- en: In-memory objects can be useful in a multitude of situations. Memory is much
    faster than a hard disk, it is always available, and for small amounts of data
    can be the perfect choice.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 内存中的对象在多种情况下都可能很有用。内存比硬盘快得多，它总是可用，对于少量数据来说可能是完美的选择。
- en: 'Let us see the first example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第一个例子：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code snippet, we import the `io` module from the standard library.
    This module features many tools related to streams and I/O. One of them is `StringIO`
    , which is an in-memory buffer in which we have written two sentences, using two
    different methods, as we did with files in the first examples of this chapter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们从标准库中导入了 `io` 模块。这个模块包含了许多与流和I/O相关的工具。其中之一是 `StringIO`，它是一个内存缓冲区，我们在其中使用了两种不同的方法写入了两个句子，就像我们在本章的第一个例子中使用文件一样。
- en: '`StringIO` is useful when you need to:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要时，`StringIO` 很有用：
- en: Simulate file-like behavior for strings.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟字符串的文件-like行为。
- en: Test code that works with file-like objects without using actual files.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试与文件对象一起工作的代码，而不使用实际文件。
- en: Build or manipulate large strings efficiently.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效地构建或操作大字符串。
- en: Capture or mock input/output for testing purposes. Tests run much faster because
    they avoid disk I/O.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了测试目的捕获或模拟输入/输出。测试运行得更快，因为它们避免了磁盘I/O。
- en: We can either call `StringIO.write()` or we can use `print()` , instructing
    it to direct the data to our stream.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用 `StringIO.write()`，或者我们可以使用 `print()`，指示它将数据导向我们的流。
- en: By calling `getvalue()` , we can get the content of the stream. We then proceed
    to print it, and finally, we close it. The call to `close()` causes the text buffer
    to be immediately discarded.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `getvalue()`，我们可以获取流的内 容。然后我们继续打印它，最后关闭它。调用 `close()` 会导致文本缓冲区立即被丢弃。
- en: 'There is a more elegant way to write the previous code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种更优雅的方式来编写之前的代码：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Like the built-in `open()` , `io.StringIO()` too works well within a context
    manager block. Notice the similarity with `open()` ; in this case as well, we
    don’t need to manually close the stream.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 就像内置的 `open()` 函数一样，`io.StringIO()` 也在上下文管理器块中工作得很好。注意与 `open()` 的相似性；在这种情况下，我们也不需要手动关闭流。
- en: 'When running the script, the output is:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行脚本时，输出如下：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Let us now proceed with the second example.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续第二个示例。
- en: Making HTTP requests
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送 HTTP 请求
- en: In this section, we explore two examples of HTTP requests. We will use the `requests`
    library for these examples, which you can install with `pip` , and it is included
    in the requirements file for this chapter.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了两个 HTTP 请求的例子。我们将使用 `requests` 库来演示这些例子，你可以使用 `pip` 安装它，并且它包含在本章节的要求文件中。
- en: We are going to perform HTTP requests against the httpbin.org ( [https://httpbin.org/](https://httpbin.org/)
    ) API, which, interestingly, was developed by Kenneth Reitz, the creator of the
    `requests` library. Httpbin is a simple HTTP request and response service that
    is useful when we want to experiment with the HTTP protocol.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向 httpbin.org（[https://httpbin.org/](https://httpbin.org/)）API 发起 HTTP 请求，有趣的是，这个
    API 是由 `requests` 库的创建者 Kenneth Reitz 开发的。Httpbin 是一个简单的 HTTP 请求和响应服务，当我们想要实验
    HTTP 协议时非常有用。
- en: 'This library is among the most widely adopted:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库是最广泛采用的之一：
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding snippet should be straightforward. We declare a dictionary of
    URLs against which we want to perform HTTP requests. We have encapsulated the
    code that performs the request into the `get_content()` function. As you can see,
    we perform a GET request (by using `requests.get()` ), and we print the title
    and the JSON-decoded version of the body of the response. Let us spend a few words
    on this last bit.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段应该很简单。我们声明了一个字典，其中包含了我们想要对其发起 HTTP 请求的 URL。我们将执行请求的代码封装到了 `get_content()`
    函数中。正如你所看到的，我们执行了一个 GET 请求（通过使用 `requests.get()` ），并打印了响应的标题和 JSON 解码后的响应体。让我们花点时间来谈谈最后这部分。
- en: When we perform a request to a website, or to an API, we get back a response
    object encapsulating the data that was returned by the server we performed the
    request against. The body of some responses from `httpbin.org` happens to be JSON
    encoded, so instead of getting the body as it is (by reading `resp.text` ) and
    manually decoding it by calling `json.loads()` on it, we simply combine the two
    by using the `json()` method of the response object. There are plenty of reasons
    why the `requests` package has become so widely adopted, and one of them is its
    ease of use.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向一个网站或 API 发起请求时，我们会收到一个响应对象，该对象封装了服务器返回的数据。`httpbin.org` 的一些响应体恰好是 JSON
    编码的，因此我们不是直接读取 `resp.text` 并手动调用 `json.loads()` 来解码，而是通过使用响应对象的 `json()` 方法将两者结合起来。`requests`
    包之所以被广泛采用，有很多原因，其中之一就是它的易用性。
- en: Now, when you perform a request in your application, you will want to have a
    much more robust approach for dealing with errors and so on, but for this chapter,
    a simple example will do. We will see more examples of requests in *Chapter 14*
    , *Introduction to API Development* .
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你在你应用程序中发起请求时，你将希望有一个更健壮的方法来处理错误等，但在这个章节中，一个简单的例子就足够了。我们将在 *第 14 章* ，*API
    开发简介* 中看到更多请求的例子。
- en: 'Going back to our code, in the end, we run a `for` loop and get all the URLs.
    When you run it, you will see the result of each call printed on your console,
    which should look like this (prettified and trimmed for brevity):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的代码，最后我们运行一个 `for` 循环并获取所有 URL。当你运行它时，你将在控制台上看到每个调用的结果打印出来，它应该看起来像这样（为了简洁而进行了美化并裁剪）：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Notice that you might get a slightly different output in terms of version numbers
    and IPs, which is fine. Now, `GET` is only one of the HTTP verbs, albeit one of
    the most commonly used. Let us also look at how to use the `POST` verb. This is
    the type of request you make when you need to send data to the server, for example,
    to request the creation of a resource. Every time you submit a form on the web,
    you are making a `POST` request. So, let us try to make one programmatically:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可能会得到一些关于版本号和 IP 的不同输出，这是正常的。现在，`GET` 只是 HTTP 动词之一，尽管是最常用的之一。让我们也看看如何使用
    `POST` 动词。当你需要向服务器发送数据时，例如请求创建资源，你会发起一个 `POST` 请求。所以，让我们尝试通过编程来发起一个请求：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding code is very similar to what we saw before, only this time we
    don’t call `get()` , but `post()` , and because we want to send some data, we
    specify that in the call. The `requests` library offers much more than this. It
    is a project that we encourage you to check out and explore, as it is quite likely
    you will be using it too.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码与我们之前看到的非常相似，只是这次我们没有调用`get()`，而是调用`post()`，因为我们想发送一些数据，我们在调用中指定了这一点。`requests`库提供了比这更多的功能。这是一个我们鼓励你检查和探索的项目，因为它很可能你也会用到它。
- en: 'Running the previous script (and applying some prettifying magic to the output)
    yields the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的脚本（并对输出应用一些美化魔法）会产生以下结果：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Notice how the headers are now different, and we find the data we sent in the
    form of a key/value pair of the response body.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在头部已经不同了，我们找到了以响应体的键/值对形式发送的数据。
- en: We hope these short examples are enough to get you started, especially with
    requests. The web changes every day, so it is worth learning the basics and then
    brushing up every now and then.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这些简短的例子足以让你开始，特别是对于请求。网络每天都在变化，因此学习基础知识并时不时地复习是值得的。
- en: Persisting data on disk
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在磁盘上持久化数据
- en: In this section of this chapter, we will look at how to persist data on disk
    in three different formats. To persist data means that the data is written to
    non-volatile storage, like a hard drive, for example, and it is not deleted when
    the process that wrote it ends its life cycle. We will explore the `pickle` and
    `shelve` modules, as well as a short example that will involve accessing a database
    using **SQLAlchemy** , perhaps the most widely adopted ORM library in the Python
    ecosystem.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一节中，我们将探讨如何以三种不同的格式在磁盘上持久化数据。持久化数据意味着数据被写入非易失性存储，例如硬盘驱动器，并且当写入它的进程结束其生命周期时，数据不会被删除。我们将探讨`pickle`和`shelve`模块，以及一个简短的例子，该例子将涉及使用**SQLAlchemy**访问数据库，SQLAlchemy可能是Python生态系统中最广泛采用的ORM库。
- en: Serializing data with pickle
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用pickle序列化数据
- en: The `pickle` module, from the Python standard library, offers tools to convert
    Python objects into byte streams, and vice versa. Even though there is a partial
    overlap in the API that `pickle` and `json` expose, the two are quite different.
    As we have seen previously in this chapter, JSON is a text format that is human
    readable, language independent, and supports only a restricted subset of Python
    data types. The `pickle` module, on the other hand, is not human readable, translates
    to bytes, is Python-specific, and, thanks to the wonderful Python introspection
    capabilities, supports a large number of data types.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库中的`pickle`模块提供了将Python对象转换为字节流以及相反的工具。尽管`pickle`和`json`暴露的API有部分重叠，但这两个模块相当不同。正如我们在本章前面所见，JSON是一种人类可读的文本格式，语言无关，仅支持Python数据类型的一个受限子集。另一方面，`pickle`模块不是人类可读的，转换为字节，是Python特定的，并且，多亏了Python出色的内省能力，支持大量数据类型。
- en: Besides these differences between `pickle` and `json` , there are also some
    important security concerns that you need to be aware of if you are considering
    using `pickle` . *Unpickling* erroneous or malicious data from an untrusted source
    can be dangerous, so if we decide to adopt it in our application, we need to be
    extra careful.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`pickle`和`json`之间的这些差异之外，还有一些重要的安全问题需要你注意，如果你考虑使用`pickle`的话。从不受信任的来源*反序列化*错误或恶意数据可能是危险的，因此如果我们决定在我们的应用程序中采用它，我们需要格外小心。
- en: If you do use `pickle` , you should consider using a cryptographic signature
    to ensure that your pickled data has not been tampered with. We will see how to
    generate cryptographic signatures in Python in *Chapter 9* , *Cryptography and
    Tokens* .
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实使用`pickle`，你应该考虑使用加密签名来确保你的序列化数据没有被篡改。我们将在*第9章*，*密码学和令牌*中看到如何在Python中生成加密签名。
- en: 'That said, let us see it in action by means of a simple example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们通过一个简单的例子来看看它的实际应用：
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this example, we create a `Person` class using the `dataclass` decorator,
    which we saw in *Chapter 6* , *OOP, Decorators, and Iterators* . The only reason
    we wrote this example using `dataclass` is to show you how effortlessly `pickle`
    deals with it, with no need for us to do anything we would not do for a simpler
    data type.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`dataclass`装饰器创建了一个`Person`类，这在*第6章*，*面向对象编程、装饰器和迭代器*中我们见过。我们之所以用`dataclass`写这个例子，只是为了向你展示`pickle`处理它有多么轻松，我们不需要为简单数据类型做任何额外的事情。
- en: 'The class has three attributes: `first_name` , `last_name` , and `id` . It
    also exposes a `greet()` method, which prints a hello message with the instance
    data.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有三个属性：`first_name`、`last_name`和`id`。它还公开了一个`greet()`方法，该方法使用实例数据打印一条问候消息。
- en: 'We create a list of instances and save it to a file. In order to do so, we
    use `pickle.dump()` , to which we feed the content to be *pickled* , and the stream
    to which we want to write. Immediately after that, we read from that same file,
    using `pickle.load()` to convert the entire content of the stream back into Python
    objects. To make sure that the objects have been converted correctly, we call
    the `greet()` method on both of them. The result is the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个实例列表并将其保存到文件中。为此，我们使用`pickle.dump()`，向其中提供要*序列化*的内容，以及我们想要写入的流。紧接着，我们使用`pickle.load()`从同一个文件中读取，将流中的整个内容转换回Python对象。为了确保对象已正确转换，我们在它们两个上调用`greet()`方法。结果是以下内容：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `pickle` module also allows you to convert to (and from) byte objects, by
    means of the `dumps()` and `loads()` functions (note the `s` at the end of both
    names). In day-to-day applications, `pickle` is usually used when we need to persist
    Python data that is not supposed to be exchanged with another application. One
    example we stumbled upon a few years ago was the session manager of a `flask`
    plugin, which pickles the session object before storing it in a Redis database.
    In practice, though, you are unlikely to have to deal with this library very often.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickle`模块还允许你通过`dumps()`和`loads()`函数（注意两个名称末尾的`s`）将数据转换为（和从）字节对象。在日常应用中，`pickle`通常在我们需要持久化不应与其他应用程序交换的Python数据时使用。几年前我们遇到的一个例子是一个`flask`插件的会话管理器，它在将会话对象存储到Redis数据库之前将其序列化。然而，在实践中，你不太可能经常需要处理这个库。'
- en: Another tool that is possibly used even less, but that proves to be useful when
    you are short on resources, is `shelve` .
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能使用得更少的工具，但在资源不足时证明是有用的，是`shelve`。
- en: Saving data with shelve
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用shelve保存数据
- en: 'A “shelf” is a persistent dictionary-like object. The beauty of it is that
    the values you save into a shelf can be any objects you can `pickle` , so you’re
    not restricted like you would be if you were using a database. Albeit interesting
    and useful, the `shelve` module is used quite rarely in practice. Just for completeness,
    let us see a quick example of how it works:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: “书架”是一个持久的类似字典的对象。它的美妙之处在于，你可以将任何可以`pickle`的对象保存到书架中，因此你不会像使用数据库那样受到限制。尽管有趣且有用，但在实际应用中`shelve`模块的使用相当罕见。为了完整性，让我们快速看看它的工作示例：
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Apart from the wiring and the boilerplate around it, this example resembles
    an exercise with dictionaries. We create a `Person` class and then we open a `shelve`
    file within a context manager. As you can see, we use the dictionary syntax to
    store four objects: two `Person` instances, a list, and a string. If we print
    the keys, we get a list containing the four keys we used. Immediately after printing
    it, we delete the (aptly named) `delete_me` key/value pair from the shelf. Printing
    the keys again shows the deletion has succeeded. We then test a couple of keys
    for membership and, finally, we append number `7` to `a_list` . Notice how we
    have to extract the list from the shelf, modify it, and save it again.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 除了相关的连接和模板代码之外，这个例子类似于字典练习。我们创建一个`Person`类，然后在上下文管理器中打开一个`shelve`文件。正如你所看到的，我们使用字典语法存储了四个对象：两个`Person`实例、一个列表和一个字符串。如果我们打印键，我们会得到一个包含我们使用的四个键的列表。在打印之后，我们立即从书架中删除（恰如其名）的`delete_me`键/值对。再次打印键时，我们可以看到删除已成功。然后我们测试几个键的成员资格，最后，我们将数字`7`追加到`a_list`。注意，我们必须从书架中提取列表，修改它，然后再保存。
- en: 'There is another way to open a shelf that speeds up the process a bit:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种打开书架的方法可以稍微加快这个过程：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: By opening the shelf with `writeback=True` , we enable the `writeback` feature,
    which allows us to simply append to `a_list` as if it was a value within a regular
    dictionary. The reason this feature is not active by default is that it comes
    with a price that you pay in terms of memory consumption and slower closing of
    the shelf.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以`writeback=True`打开书架，我们启用了`writeback`功能，这使得我们可以像在常规字典中添加值一样简单地追加到`a_list`。这个功能默认不激活的原因是，它伴随着你在内存消耗和关闭书架时需要付出的代价。
- en: 'Now that we have paid homage to the standard library modules related to data
    persistence, let us look at one of the most widely adopted ORMs in the Python
    ecosystem: SQLAlchemy.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经向与数据持久性相关的标准库模块致敬，让我们来看看Python生态系统中最广泛采用的ORM之一：SQLAlchemy。
- en: Saving data to a database
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据保存到数据库中
- en: For this example, we are going to work with an in-memory database, which will
    make things simpler for us. In the source code of the book, we have left a couple
    of comments to show you how to generate a SQLite file, so we hope you’ll explore
    that option as well.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用一个内存数据库，这将使事情对我们来说更简单。在本书的源代码中，我们留下了一些注释来展示如何生成SQLite文件，所以我们希望您也能探索这个选项。
- en: 'You can find a free database browser for SQLite at [https://dbeaver.io/](https://dbeaver.io/)
    . DBeaver is a free multi-platform database tool for developers, database administrators,
    analysts, and all people who need to work with databases. It supports all popular
    databases: MySQL, PostgreSQL, SQLite, Oracle, DB2, SQL Server, Sybase, MS Access,
    Teradata, Firebird, Apache Hive, Phoenix, Presto, etc.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://dbeaver.io/](https://dbeaver.io/)找到免费的SQLite数据库浏览器。DBeaver是一款免费的跨平台数据库工具，适用于开发者、数据库管理员、分析师以及所有需要与数据库打交道的人。它支持所有流行的数据库：MySQL、PostgreSQL、SQLite、Oracle、DB2、SQL
    Server、Sybase、MS Access、Teradata、Firebird、Apache Hive、Phoenix、Presto等。
- en: Before we dive into the code, allow us to briefly introduce the concept of a
    relational database.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，让我们简要介绍一下关系数据库的概念。
- en: 'A relational database is a database that allows you to save data following
    the **relational model** , invented in 1969 by Edgar F. Codd. In this model, data
    is stored in one or more tables. Each table has rows (also known as **records**
    , or **tuples** ), each of which represents an entry in the table. Tables also
    have columns (also known as **attributes** ), each of which represents an attribute
    of the records. Each record is identified through a unique key, more commonly
    known as the **primary key** , which consists of one or more columns in the table.
    To give you an example: imagine a table called `Users` , with columns `id` , `username`
    , `password` , `name` , and `surname` .'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库是一种允许您按照1969年由爱德华·F·科德发明的**关系模型**保存数据的数据库。在这个模型中，数据存储在一个或多个表中。每个表都有行（也称为**记录**或**元组**），每行代表表中的一个条目。表也有列（也称为**属性**），每列代表记录的一个属性。每个记录通过一个唯一键来识别，更常见的是**主键**，它由表中的一列或多列组成。为了给您一个例子：想象一个名为`Users`的表，有`id`、`username`、`password`、`name`和`surname`列。
- en: Such a table would be suitable for containing users of our system; each row
    would represent a different user. For example, a row with the values `3` , `fab`
    , `my_wonderful_pwd` , `Fabrizio` , and `Romano` would represent Fabrizio’s user
    in the system.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的表非常适合包含我们系统的用户；每一行代表一个不同的用户。例如，具有值`3`、`fab`、`my_wonderful_pwd`、`Fabrizio`和`Romano`的行将代表系统中的Fabrizio用户。
- en: The model is called *relational* because you can establish relations between
    tables. For example, if you added a table called `PhoneNumbers` to this database,
    you could insert phone numbers into it, and then, through a relation, establish
    which phone number belongs to which user.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型被称为*关系*，因为您可以在表之间建立关系。例如，如果您向这个数据库添加一个名为`PhoneNumbers`的表，您可以将电话号码插入其中，然后通过关系确定哪个电话号码属于哪个用户。
- en: 'To query a relational database, we need a special language. The main standard
    is called **SQL** , which stands for **Structured Query Language** . It originates
    from **relational algebra** , which is a formal system and theoretical framework
    for manipulating and querying data stored in relational databases. The most common
    operations you can perform usually involve filtering on the rows or columns, joining
    tables, aggregating the results according to some criteria, and so on. To give
    you an example in English, a query on our imaginary database could be: *Fetch
    all users (username, name, surname) whose username starts with “m” and who have
    at most one phone number* . In this example, we are querying for a subset of the
    rows in the database, and are only interested in three of the columns in the `User`
    table for the results. We are filtering on users by taking only those whose username
    starts with the letter *m* , and even further, only those who have at most one
    phone number.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询关系型数据库，我们需要一种特殊的语言。主要的标准化语言被称为**SQL**，即**结构化查询语言**。它起源于**关系代数**，这是一种用于操作和查询存储在关系型数据库中的数据的正式系统和理论框架。你可以执行的最常见操作通常涉及对行或列进行过滤、连接表、根据某些标准聚合结果等。以英语为例，对我们假设的数据库进行查询可能是：*检索所有用户名以“m”开头且最多有一个电话号码的用户（username,
    name, surname）*。在这个例子中，我们正在查询数据库中行的一个子集，并且只对`User`表中的三个列感兴趣的结果。我们通过只选择以字母*m*开头的用户进行过滤，更进一步，只选择最多有一个电话号码的用户。
- en: Each database comes with its own *flavor* of SQL. They all respect the standard
    to some extent, but none fully do, and they are all different from one another
    in some respects. This poses an issue in modern software development. If our application
    contained raw SQL code, it is quite likely that if we decided to use a different
    database engine, or maybe a different version of the same engine, we would need
    to amend the SQL code in our application.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据库都附带其自己的**风味**SQL。它们都在某种程度上尊重标准，但没有一个完全遵守，它们在某种程度上都各不相同。这在现代软件开发中引发了一个问题。如果我们的应用程序包含原始SQL代码，那么如果我们决定使用不同的数据库引擎，或者可能是同一引擎的不同版本，我们可能需要修改应用程序中的SQL代码。
- en: This can be quite painful, especially since SQL queries can be quite complex.
    To alleviate this issue, computer scientists have created code that maps objects
    of a programming language to tables of a relational database. Unsurprisingly,
    the name of such a tool is **Object-Relational Mapping** ( **ORM** ).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会相当痛苦，尤其是由于SQL查询可能非常复杂。为了减轻这个问题，计算机科学家们创建了将编程语言的对象映射到关系型数据库表的代码。不出所料，这种工具的名称是**对象关系映射**（**ORM**）。
- en: In modern application development, one would normally start interacting with
    a database by using an ORM. Should they then find themselves in a situation where
    they cannot perform a certain query through the ORM, they would then, and only
    then, resort to using SQL directly. This is a good compromise between having no
    SQL at all and using no ORM, which means specializing the code that interacts
    with the database, with the aforementioned disadvantages.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代应用程序开发中，人们通常会通过使用ORM（对象关系映射）来开始与数据库交互。如果他们发现自己无法通过ORM执行某个查询，那么他们就会，而且只有在这种情况下，才会直接使用SQL。这是在完全没有SQL和完全不使用ORM之间的一种良好折衷，这意味着专门化与数据库交互的代码，具有上述缺点。
- en: In this section, we would like to show an example that leverages SQLAlchemy,
    one of the most popular third-party Python ORMs. You will have to install it into
    the virtual environment for this chapter. We are going to define two models (
    `Person` and `Email` ), each of which maps to a table, and then we are going to
    populate the database and perform a few queries on it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们想展示一个利用 SQLAlchemy 的例子，它是最受欢迎的第三方 Python ORM 之一。您需要将此章节的虚拟环境中安装它。我们将定义两个模型（`Person`和`Email`），每个模型都映射到一个表，然后我们将填充数据库并在其上执行一些查询。
- en: 'Let us start with the model declarations:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从模型声明开始：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'At the beginning, we import some functions and types. We then proceed to write
    the `Person` and `Email` classes, as well as the mandatory base class for them.
    Let us see these definitions:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，我们导入一些函数和类型。然后我们继续编写`Person`和`Email`类，以及它们必需的基类。让我们看看这些定义：
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Each model inherits from the `Base` class, which in this example is a simple
    class that inherits from SQLAlchemy’s `DeclarativeBase` . We define `Person` ,
    which maps to a table called `"person"` , and exposes the attributes `id` , `name`
    , and `age` . We also declare a relationship with the `Email` model, by stating
    that accessing the `emails` attribute will fetch all the entries in the `Email`
    table that are related to the particular `Person` instance we are dealing with.
    The `cascade` option affects how creation and deletion work, but it is a more
    advanced concept, so we suggest you ignore it for now and maybe investigate more
    later.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模型都继承自 `Base` 类，在这个例子中，它是一个简单地继承自 SQLAlchemy 的 `DeclarativeBase` 的类。我们定义了
    `Person`，它映射到名为 `"person"` 的表，并公开了 `id`、`name` 和 `age` 属性。我们还通过声明访问 `emails` 属性将检索与特定
    `Person` 实例相关的 `"Email"` 表中的所有条目来声明与 `"Email"` 模型的关系。`cascade` 选项影响创建和删除的工作方式，但它是一个更高级的概念，所以我们建议你现在忽略它，也许以后再深入研究。
- en: The last thing we declare is the `__repr__()` method, which provides us with
    the official string representation of an object. This is supposed to be a representation
    that can be used to completely reconstruct the object, but in this example, we
    simply use it to provide something as output. Python redirects `repr(obj)` to
    a call to `obj.__repr__()` .
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后声明的是 `__repr__()` 方法，它为我们提供了对象的官方字符串表示形式。这个表示形式应该能够用来完全重建对象，但在这个例子中，我们只是简单地用它来提供输出。Python
    将 `repr(obj)` 重定向到对 `obj.__repr__()` 的调用。
- en: We also declare the `Email` model, which maps to a table called `"email"` and
    will contain email addresses, and a reference to the person they belong to. You
    can see the `person_id` and `person` attributes are both about setting a relation
    between the `Email` and `Person` classes. Note also how we declare the `__str__()`
    method on `Email` , and then assign an alias to it, called `__repr__()` . This
    means that calling either `repr()` or `str()` on `Email` objects will ultimately
    result in calling the `__str__()` method. This is quite a common technique in
    Python, used to avoid duplicating the same code, so we took the opportunity to
    show it to you here.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还声明了 `"Email"` 模型，它映射到名为 `"email"` 的表，并将包含电子邮件地址以及属于这些电子邮件地址的人的引用。你可以看到 `person_id`
    和 `person` 属性都是关于在 `"Email"` 和 `"Person"` 类之间设置关系。注意我们还如何在 `"Email"` 上声明 `__str__()`
    方法，然后将其分配给一个名为 `__repr__()` 的别名。这意味着在 `"Email"` 对象上调用 `repr()` 或 `str()` 最终都会调用
    `__str__()` 方法。这在 Python 中是一种相当常见的技巧，用于避免重复相同的代码，所以我们有机会在这里向你展示它。
- en: A deeper understanding of this code would require more space than we can afford,
    so we encourage you to read up on **database management systems** ( **DBMS** ),
    SQL, relational algebra, and SQLAlchemy.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对这段代码的深入理解需要比我们所能提供的空间更多，所以我们鼓励你阅读有关 **数据库管理系统**（**DBMS**）、SQL、关系代数和 SQLAlchemy
    的资料。
- en: Now that we have our models, let us use them to persist some data.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的模型，让我们使用它们来持久化一些数据。
- en: 'Look at the following example (all the snippets presented here, until indicated
    otherwise, belong to the file `alchemy.py` in the `persistence` folder):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的例子（这里展示的所有片段，除非另有说明，都属于 `persistence` 文件夹中的 `alchemy.py` 文件）：
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: First, we import the functions and classes we need. We then proceed to create
    an engine for the application, and finally, we instruct SQLAlchemy to create all
    the tables through the given engine.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入我们需要的函数和类。然后我们继续为应用程序创建一个引擎，最后我们指示 SQLAlchemy 通过给定的引擎创建所有表。
- en: The `create_engine()` function supports a parameter called `echo` , which can
    be set to `True` , `False` , or the string `"debug"` , to enable different levels
    of logging of all statements and the `repr()` of their parameters. Please refer
    to the official SQLAlchemy documentation for further information.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_engine()` 函数支持一个名为 `echo` 的参数，可以设置为 `True`、`False` 或字符串 `"debug"`，以启用不同级别的所有语句和它们参数的
    `repr()` 的日志记录。请参阅 SQLAlchemy 的官方文档以获取更多信息。'
- en: 'In SQLAlchemy, an engine is a core component that serves as the primary interface
    between Python applications and databases. It manages two crucial aspects of database
    interactions: connections and SQL statement execution.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLAlchemy 中，引擎是一个核心组件，它作为 Python 应用程序和数据库之间的主要接口。它管理数据库交互的两个关键方面：连接和 SQL
    语句执行。
- en: 'After the imports and creating the engine and tables, we set up a session via
    a context manager, using the engine we just created. We start by creating two
    `Person` objects:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入和创建引擎以及表之后，我们通过使用我们刚刚创建的引擎设置了一个会话，使用上下文管理器。我们首先创建两个 `Person` 对象：
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We then add email addresses to both objects using two different techniques.
    One assigns them to a list, and the other one simply appends them:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后使用两种不同的技术给这两个对象添加电子邮件地址。一种是将它们分配给一个列表，另一种则是简单地追加：
- en: '[PRE49]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We have not touched the database yet. It is only when we use the `session`
    object that something actually happens in it:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有接触数据库。只有当我们使用`session`对象时，其中才会发生实际的操作：
- en: '[PRE50]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Adding the two `Person` instances is enough to also add their email addresses
    (this is thanks to the cascading effect). Calling `commit()` causes SQLAlchemy
    to commit the transaction and save the data in the database.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 添加两个`Person`实例也足以添加它们的电子邮件地址（这要归功于级联效应）。调用`commit()`会导致SQLAlchemy提交事务并将数据保存到数据库中。
- en: A **transaction** is an operation that provides something like a sandbox, but
    in a database context. As long as the transaction hasn’t been committed, we can
    roll back any modification we have done to the database, and by doing so, revert
    to the state we were in before starting the transaction itself. SQLAlchemy offers
    more complex and granular ways to deal with transactions, which you can study
    in its official documentation, as it is quite an advanced topic.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**事务**是一个提供类似沙盒的操作，但在数据库上下文中。只要事务没有被提交，我们就可以回滚对数据库所做的任何修改，并通过这样做，回到开始事务之前的状态。SQLAlchemy提供了更复杂和更细粒度的处理事务的方法，您可以在其官方文档中学习，这是一个相当高级的话题。'
- en: 'We now query for all the people whose name starts with `Obi` by using `like()`
    , which hooks to the `LIKE` operator in SQL:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用`like()`查询所有名字以`Obi`开头的所有人，这会连接到SQL中的`LIKE`运算符：
- en: '[PRE51]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We take the first result of that query (we know we only have Obi-Wan anyway)
    and print it. We then fetch `anakin` by using an exact match on his name, just
    to show you another way of filtering:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查询该查询的第一个结果（我们知道我们只有欧比旺）并打印它。然后我们通过使用对名字的精确匹配来获取`anakin`，只是为了展示另一种过滤方式：
- en: '[PRE52]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We then capture Anakin’s ID, and delete the `anakin` object from the global
    frame (this does not delete the entry from the database):'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后捕获安纳金的ID，并从全局框架中删除`anakin`对象（这并不会从数据库中删除条目）：
- en: '[PRE53]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The reason we do this is because we want to show you how to fetch an object
    by its ID. To display the full content of the database, we have written a `display_info()`
    function. It works by fetching the email addresses first and person objects later,
    through their relationship with `Email` . It also provides a count of all objects
    per model. In the module, this function is defined before entering the context
    manager that provides the session:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做的原因是我们想向您展示如何通过ID获取对象。为了显示数据库的全部内容，我们编写了一个`display_info()`函数。它通过从`Email`的关系中获取电子邮件地址和人员对象来工作，同时也提供了每个模型的所有对象的计数。在这个模块中，这个函数在进入提供会话的上下文管理器之前定义：
- en: '[PRE54]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We call this function, then we fetch and delete `anakin` . Finally, we display
    the info again to verify that he has actually disappeared from the database:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用这个函数，然后获取并删除`anakin`。最后，我们再次显示信息以验证他确实已经从数据库中消失：
- en: '[PRE55]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output of all these snippets run together is the following (for your convenience,
    we have separated the output into four blocks, to reflect the four blocks of code
    that produce that output):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些片段的输出合并在一起如下（为了您的方便，我们已经将输出分为四个部分，以反映产生该输出的四个代码块）：
- en: '[PRE56]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see from the last two blocks, deleting `anakin` has deleted one `Person`
    object and the three email addresses associated with it. Again, this is because
    cascading took place when we deleted `anakin` .
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从最后两个块中看到的，删除`anakin`已经删除了一个`Person`对象及其关联的三个电子邮件地址。再次强调，这是因为当我们删除`anakin`时发生了级联。
- en: This concludes our brief introduction to data persistence. It is a vast and,
    at times, complex domain that we encourage you to explore, learning as much theory
    as possible. Lack of knowledge or proper understanding, when it comes to database
    systems, can impact the number of bugs in the system, as well as its performance.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对数据持久性的简要介绍。这是一个庞大且有时复杂的领域，我们鼓励您去探索，尽可能多地学习理论。在数据库系统方面，知识的缺乏或理解不当可能会影响系统中的错误数量以及其性能。
- en: Configuration files
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置文件
- en: Configuration files are crucial components of many Python applications. They
    allow developers to separate the main application code from settings and parameters.
    This separation is helpful for maintaining, managing, and distributing software,
    especially when an application needs to run in different environments – such as
    development, production, and testing – with different configurations.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件是许多 Python 应用程序的关键组成部分。它们允许开发者将主应用程序代码与设置和参数分离。这种分离对于维护、管理和分发软件非常有帮助，尤其是在应用程序需要在不同的环境中运行时——例如开发、生产和测试——并且具有不同的配置。
- en: 'Configuration files allow:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件允许：
- en: '**Flexibility** : Users can change the behavior of an application without modifying
    its code. This is particularly useful for applications that are deployed across
    different environments, or require credentials to a database, API keys, and so
    on.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：用户可以在不修改应用程序代码的情况下更改应用程序的行为。这对于在不同环境中部署的应用程序或需要数据库、API 密钥等凭证的应用程序特别有用。'
- en: '**Security** : Sensitive information, like authentication credentials, API
    keys, or secret tokens, should be kept out of the source code and managed separately
    from the codebase.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：敏感信息，如认证凭证、API 密钥或秘密令牌，应从源代码中移除，并独立于代码库进行管理。'
- en: Common formats
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见格式
- en: Configuration files can be written in several formats, each of which has its
    own syntax and features. A few popular ones are `INI` , `JSON` , `YAML` , `TOML`
    , and `.env` .
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件可以写成几种格式，每种格式都有自己的语法和功能。一些流行的格式是 `INI`、`JSON`、`YAML`、`TOML` 和 `.env`。
- en: In this short section, we are going to briefly explore the `INI` and `TOML`
    formats. In *Chapter 14* , *Introduction to API Development* , we will also use
    a `.env` file.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要探讨 `INI` 和 `TOML` 格式。在 *第 14 章*，*API 开发简介* 中，我们还将使用 `.env` 文件。
- en: The INI configuration format
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: INI 配置格式
- en: The `INI` format is a simple text file, divided into sections. Each section
    contains properties expressed in the form of key/value pairs.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`INI` 格式是一个简单的文本文件，分为几个部分。每个部分包含以键/值对形式表示的属性。'
- en: To learn more about this format, please visit [https://en.wikipedia.org/wiki/INI_file](https://en.wikipedia.org/wiki/INI_file)
    .
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于此格式的信息，请访问 [https://en.wikipedia.org/wiki/INI_file](https://en.wikipedia.org/wiki/INI_file)。
- en: 'Let us look at an example INI configuration file:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例 INI 配置文件：
- en: '[PRE57]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the preceding text, there are some sections dedicated to a database connection.
    Common properties can be found in the `database` section, whereas specific properties
    are placed in the `.primary` or `.secondary` sections, which represent configurations
    to connect to a *primary* and *secondary* database, respectively. There is also
    an `owner` section and a `DEFAULT` section.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的文本中，有一些部分专门用于数据库连接。常见属性可以在 `database` 部分找到，而特定属性则放在 `.primary` 或 `.secondary`
    部分中，分别代表连接到 *主* 和 *次* 数据库的配置。还有一个 `owner` 部分和一个 `DEFAULT` 部分。
- en: To read this configuration in an application, we can use the `configparser`
    module from the standard library ( [https://docs.python.org/3/library/configparser.html](https://docs.python.org/3/library/configparser.html)
    ). It is straightforward in that it will produce an object similar to a dictionary,
    with the added bonus that the `DEFAULT` section automatically provides values
    for all other sections.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要在应用程序中读取此配置，我们可以使用标准库中的 `configparser` 模块（[https://docs.python.org/3/library/configparser.html](https://docs.python.org/3/library/configparser.html)）。它非常直观，因为它将生成一个类似于字典的对象，并且额外的好处是
    `DEFAULT` 部分会自动为所有其他部分提供值。
- en: 'Let us see an example session from the Python shell:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个来自 Python 脚本的一个示例会话：
- en: '[PRE58]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Notice how we import `configparser` and use it to create a `config` object.
    This object exposes various methods; you can get a list of sections, as well as
    retrieving any value in it.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何导入 `configparser` 并使用它来创建一个 `config` 对象。此对象公开了各种方法；您可以获取部分列表，以及检索其中的任何值。
- en: Internally, `configparser` stores values as strings, so we need to cast them
    appropriately, if we want to use them as the Python object they represent. There
    are some methods on the `ConfigParser` object, namely `getint()` , `getfloat()`
    , and `getboolean()` , that will retrieve a value and return it cast to the indicated
    type, but as you can see the list is rather short.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`configparser` 将值存储为字符串，因此如果我们想将它们用作它们所代表的 Python 对象，我们需要适当地进行类型转换。`ConfigParser`
    对象上有一些方法，例如 `getint()`、`getfloat()` 和 `getboolean()`，它们将检索一个值并将其转换为指定的类型，但如您所见，这个列表相当短。
- en: Notice also how properties from the `DEFAULT` section are injected in all other
    sections. Moreover, when a section defines a key that is also present in the `DEFAULT`
    section, the value from the original section will not be overwritten by the `DEFAULT`
    one. You can see an example of this in the highlighted code, which shows that
    the `title` property is present in the `database` section, and the `host` one,
    which is present in both sections, retains the value `'192.168.1.255'` correctly.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，来自 `DEFAULT` 部分的属性被注入到所有其他部分中。此外，当一个部分定义了一个也存在于 `DEFAULT` 部分的键时，原始部分的值不会被
    `DEFAULT` 部分的值覆盖。你可以在高亮显示的代码中看到一个示例，它显示 `title` 属性存在于 `database` 部分中，而 `host`
    属性存在于两个部分中，它正确地保留了 `'192.168.1.255'` 的值。
- en: The TOML configuration format
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TOML 配置格式
- en: The `TOML` format is quite popular in Python applications, and it has a richer
    set of features compared to the INI one. If you wish to learn its syntax, please
    refer to [https://toml.io/](https://toml.io/) .
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`TOML` 格式在 Python 应用中相当流行，与 INI 格式相比，它具有更丰富的功能集。如果您想了解其语法，请参阅 [https://toml.io/](https://toml.io/)
    。'
- en: Here, we are going to see a quick example that follows the previous one.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将看到一个快速示例，它遵循之前的示例。
- en: '[PRE59]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This time, we have no `DEFAULT` section, and properties are specified slightly
    differently, in that strings are surrounded by quotes, while numbers are not.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们没有 `DEFAULT` 部分，属性指定略有不同，即字符串被引号包围，而数字则不是。
- en: 'We will use the `tomllib` module from the standard library ( [https://docs.python.org/3/library/tomllib.html](https://docs.python.org/3/library/tomllib.html)
    ) to read this configuration:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用标准库中的 `tomllib` 模块（[https://docs.python.org/3/library/tomllib.html](https://docs.python.org/3/library/tomllib.html)）来读取此配置：
- en: '[PRE60]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Notice how, this time, the `config` object is a dictionary. Because of the way
    we have specified the `database.primary` and `database.secondary` sections, `tomllib`
    has created a nested structure to represent them.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这次，`config` 对象是一个字典。由于我们指定了 `database.primary` 和 `database.secondary` 部分，`tomllib`
    创建了一个嵌套结构来表示它们。
- en: With TOML, values are correctly cast to Python objects. We have strings, numbers,
    lists, and even a `datetime` object, created from the iso-formatted string representing
    Fabrizio’s date of birth. On the `tomllib` documentation page, you can find a
    table with all possible conversions.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TOML，值会被正确地转换为 Python 对象。我们有字符串、数字、列表，甚至是从代表 Fabrizio 出生日期的 iso 格式化字符串创建的
    `datetime` 对象。在 `tomllib` 文档页面上，你可以找到一个包含所有可能转换的表格。
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we explored working with files and directories. We learned
    how to read and write on files, and how to do that elegantly by using context
    managers. We also explored directories: how to list their content, both recursively
    and not. We also learned about paths, which are the gateway to accessing both
    files and directories.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了与文件和目录一起工作。我们学习了如何读取和写入文件，以及如何通过使用上下文管理器优雅地完成这些操作。我们还探讨了目录：如何递归和非递归地列出其内容。我们还了解了路径，它们是访问文件和目录的门户。
- en: 'We then briefly saw how to create a ZIP archive and extract its content. The
    source code of the book also contains an example with a different compression
    format: `tar.gz` .'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要地看到了如何创建 ZIP 归档并提取其内容。本书的源代码还包含了一个使用不同压缩格式的示例：`tar.gz` 。
- en: We talked about data interchange formats and explored JSON in some depth. We
    had some fun writing custom encoders and decoders for specific Python data types.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了数据交换格式，并深入探讨了 JSON。我们编写了一些自定义编码器和解码器，用于特定的 Python 数据类型，并从中获得了乐趣。
- en: Then, we explored I/O, both with in-memory streams and HTTP requests.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探讨了 I/O，包括内存流和 HTTP 请求。
- en: We saw how to persist data using `pickle` , `shelve` , and the SQLAlchemy ORM
    library.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何使用 `pickle`、`shelve` 和 SQLAlchemy ORM 库持久化数据。
- en: And finally, we explored two examples of configuration files, using the INI
    and TOML formats.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探索了两种配置文件示例，使用了 INI 和 TOML 格式。
- en: You should now have a good understanding of how to deal with files and data
    persistence, and we hope you will take the time to explore these topics in much
    more depth by yourself.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，你应该已经很好地理解了如何处理文件和数据持久化，我们希望你能花时间自己深入探索这些主题。 '
- en: The next chapter will look at cryptography and tokens.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨密码学和令牌。
- en: Join our community on Discord
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区空间，与作者和其他读者进行讨论：
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_8.xhtml)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.com/invite/uaKmaz7FEC](Chapter_8.xhtml)'
- en: '![img](img/QR_Code119001106417026468.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/QR_Code119001106417026468.png)'
