- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Files and Data Persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ”It is not that I’m so smart, it is just that I stay with problems longer.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Albert Einstein
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the previous chapters, we explored several different aspects of Python. As
    the examples have a didactic purpose, we ran them in a simple Python shell or
    in the form of a Python module. They ran, maybe printed something on the console,
    and then they terminated, leaving no trace of their brief existence.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world applications are rather different. Naturally, they still run in memory,
    but they interact with networks, disks, and databases. They also exchange information
    with other applications and devices, using formats that are suitable for the situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to start closing in on the real world by exploring
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Files and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networks and streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JSON data-interchange format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data persistence with `pickle` and `shelve` from the standard library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data persistence with SQLAlchemy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As usual, we will try to balance breadth and depth so that by the end of the
    chapter, you will have a solid grasp of the fundamentals and will know how to
    fetch further information from the web.
  prefs: []
  type: TYPE_NORMAL
- en: Working with files and directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to files and directories, Python offers plenty of useful tools.
    In the following examples, we will use the `os` , `pathlib` , and `shutil` modules.
    As we will be reading and writing on the disk, we will be using a file, `fear.txt`
    , which contains an excerpt from *Fear* , by Thich Nhat Hanh, as a base for some
    of our examples.
  prefs: []
  type: TYPE_NORMAL
- en: Opening files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Opening a file in Python is simple and intuitive. In fact, we just need to
    use the `open()` function. Let us see a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is straightforward. We call `open()` , passing the filename,
    and telling `open()` that we want to read it in text mode (via the `"rt"` flag).
    There is no path information before the filename; therefore, `open()` will assume
    the file is in the same folder the script is run from. This means that if we run
    this script from outside the `files` folder, then `fear.txt` will not be found.
  prefs: []
  type: TYPE_NORMAL
- en: Once the file has been opened, we obtain a file object, `fh` , which we can
    use to work on the content of the file. We chose that name because, in Python,
    a file object is essentially a high-level abstraction that wraps the underlying
    file handle ( `fh` ). In this case, we use the `readlines()` method to iterate
    over all the lines in the file and print them. We call `strip()` on each line
    to get rid of any extra spaces around the content, including the line termination
    character at the end, since `print()` will already add one for us. This is a quick
    and dirty solution that works in this example but should the content of the file
    contain meaningful spaces that need to be preserved, you will have to be slightly
    more careful in how you sanitize the data. At the end of the script, we close
    the stream.
  prefs: []
  type: TYPE_NORMAL
- en: Closing a file is important as we do not want to risk failing to release the
    handle ( `fh` ) we have on it. When that happens, you can encounter issues such
    as memory leaks, or the annoying *“you cannot delete this file”* pop-up that informs
    you that some software is still using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we need to apply some precautions and wrap the previous logic in
    a `try/finally` block. This means that, whatever error might occur when we try
    to open and read the file, we can rest assured that `close()` will be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The logic is the same, but now it is also safe.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not familiar with the `try` / `finally` block, make sure you go back
    to the *Handling Exceptions* section of *Chapter 7* , *Exceptions and Context
    Managers* , and study it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can simplify the previous example further like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The default mode for opening files is `"rt"` , so we do not need to specify
    it. Moreover, we can simply iterate on `fh` without explicitly calling `readlines()`
    on it. Python often gives us shorthands to make our code more compact and simpler
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the previous examples produce a print of the file on the console (check
    out the source code to read the whole content):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using a context manager to open a file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To avoid having to use `try` / `finally` blocks throughout our code, Python
    gives us a nicer and equally safe way to do it: by using a context manager. Let
    us see the code first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This example is equivalent to the previous one but reads better. The `open()`
    function returns a file object when invoked by a context manager, and it conveniently
    calls `fh.close()` automatically when execution exits the context manager scope.
    This will happen even in the case of errors.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from and writing to a file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know how to open a file, let us see how to read from and write
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This first approach uses the `print()` function, with which we are already familiar
    from previous chapters. After obtaining a file object, this time specifying that
    we intend to write to it ( `"w"` ), we can tell the call to `print()` to direct
    its output to the file, instead of to the **standard output** stream as it normally
    does.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, the standard input, output, and error streams are represented by
    the file objects `sys.stdin` , `sys.stdout` , and `sys.stderr` . Unless input
    or output is redirected, reading from `sys.stdin` usually corresponds to reading
    from the keyboard, and writing to `sys.stdout` or `sys.stderr` usually prints
    to the console screen.
  prefs: []
  type: TYPE_NORMAL
- en: The previous code creates the `print_example.txt` file if it does not exist,
    or truncates it if it does, and writes the line `Hey I am printing into a file!!!`
    into it.
  prefs: []
  type: TYPE_NORMAL
- en: Truncating a file means erasing its contents without deleting it. After truncation,
    the file still exists on the filesystem, but it is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example does the job, but it is not what we would typically do when writing
    to a file. Let us see a more common approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first open `fear.txt` and gather its content into a list,
    line by line. Notice that, this time, we are calling a different method, `rstrip()`
    , as an example, to make sure we only strip the whitespace on the right-hand side
    of every line.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of the snippet, we create a new file, `fear_copy.txt` , and
    we write to it all the strings in `lines` , joined by a newline, `\n` . Python
    works by default with **universal newlines** , which means that even though the
    original file might have a newline that is different from `\n` , it will be translated
    automatically for us before the line is returned. This behavior is, of course,
    customizable, but normally it is exactly what we want. Speaking of newlines, can
    you think of one that might be missing in the copy?
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing in binary mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that by opening a file and passing `t` in the options (or omitting it,
    as it is the default), we are opening the file in text mode. This means that the
    content of the file is treated and interpreted as text.
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to write bytes to a file, you can open it in **binary mode** . This
    is a common requirement when you handle files that do not just contain raw text,
    such as images, audio/video, and, in general, any other proprietary format.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle files in binary mode, simply specify the `b` flag when opening them,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are still using text as binary data, for simplicity, but
    it could be anything you want. You can see it is treated as binary by the fact
    that you get the `b` prefix in the output string.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting against overwriting an existing file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we have seen, Python gives us the ability to open files for writing. By
    using the `w` flag, we open a file and truncate its content. This means the file
    is overwritten with an empty file, and the original content is lost. If you wish
    to only open a file for writing if it does not already exist, you can use the
    `x` flag instead, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this snippet, you will find a file called `write_x.txt` in your
    directory, containing only one line of text. The second part of the snippet, in
    fact, fails to execute. This is the output we get on our console (the file path
    has been shortened for editorial purposes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we have seen, there are different modes for opening a file. You can find
    the full list of flags at [https://docs.python.org/3/library/functions.html#open](https://docs.python.org/3/library/functions.html#open)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Checking for file and directory existence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to make sure a file or directory exists (or does not), the `pathlib`
    module is what you need. Let us see a small example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we create a `Path` object that we set up with the
    name of the text file we want to inspect. We use the `parent()` method to retrieve
    the folder in which the file is contained, and we call the `absolute()` method
    on it to extract the absolute path information.
  prefs: []
  type: TYPE_NORMAL
- en: We check if `"fear.txt"` is a file and the folder in which it is contained is
    indeed a folder (or directory, which is equivalent).
  prefs: []
  type: TYPE_NORMAL
- en: The old way to do these operations was to use the `os.path` module from the
    standard library. While `os.path` works on strings, `pathlib` offers classes representing
    filesystem paths with semantics appropriate for different operating systems. Hence,
    we suggest using `pathlib` whenever possible, and reverting to the old way of
    doing things only when there is no alternative.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating files and directories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us see a couple of quick examples of how to manipulate files and directories.
    The first example manipulates the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This example defines two functions: `sanitize()` and `reverse()` . They are
    simple functions whose purpose is to remove anything that is not a letter or space
    from a string and produce the reversed copy of a string, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We open `fear.txt` and we read its content into a list. Then we create a new
    file, `raef.txt` , which will contain the horizontally mirrored version of the
    original. We write all the content of `lines` with a single operation, using `join`
    on a newline character. Maybe more interesting is the bit at the end. First, we
    reassign `lines` to a sanitized version of itself by means of a list comprehension.
    Then we put the lines together in the `whole` string, and finally, we pass the
    result to a `Counter` object. Notice that we split the lowercase version of the
    string into a list of words. This way, each word will be counted correctly, regardless
    of its case, and, thanks to `split()` , we don’t need to worry about extra spaces
    anywhere. When we print the three most common words, we realize that, truly, Thich
    Nhat Hanh’s focus was on others, as *“we”* is the most common word in the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us now see an example of manipulation that’s more related to disk operations,
    in which we put the `shutil` module to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we start by declaring a base path, which will contain
    all the files and folders we are going to create. We then use `mkdir()` to create
    two directories: `ops_example/A/B` and `ops_example/A/C` . Notice that we don’t
    need to specify `parents=True` when calling `path_c.mkdir()` , since all the parents
    have already been created by the previous call on `path_b` .'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `/` operator to concatenate directory names; `pathlib` takes care
    of using the right path separator for us, behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the directories, we loop to create three files in directory
    `B` . Then, we move directory `B` and its contents to a different name: `D` .
    We also could have done this in another way: `path_b.rename(path_d)` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we rename `ex1.txt` to `ex1.renamed.txt` . If you open that file,
    you will see it still contains the original text from the loop logic. Calling
    `tree` on the result produces the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Manipulating pathnames
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us explore the abilities of `pathlib` a little more by means of an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading the result is probably a good enough explanation for this simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note how, in the last two lines, we have two different representations of the
    same path. The first one ( `readme_path.absolute()` ) shows two `"` `.."` , each
    of which, in path terms, indicates changing to the parent folder. So, by changing
    to the parent folder twice in a row, from `…/lpp4e/ch08/files/` , we go back to
    `…/lpp4e/` . This is confirmed by the last line in the example, which shows the
    output of `readme_path.resolve()` .
  prefs: []
  type: TYPE_NORMAL
- en: Temporary files and directories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, it is useful to create a temporary directory or file. For example,
    when writing tests that affect the disk, you can use temporary files and directories
    to run your logic and assert that it is correct, and to be sure that at the end
    of the test run, the test folder has no leftovers. Let us see how to do it in
    Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example is quite straightforward: we create a temporary directory
    in the current one ( `"."` ), and we create a named temporary file in it. We print
    the filename, as well as its full path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Running this script will produce a different result every time as these are
    temporary random names.
  prefs: []
  type: TYPE_NORMAL
- en: Directory content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With Python, you can also inspect the contents of a directory. We will show
    you two ways of doing this. This is the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This snippet uses the `glob()` method of a `Path` object, applied from the
    current directory. We iterate over the results, each of which is an instance of
    a subclass of `Path` ( `PosixPath` or `WindowsPath` , according to which OS we
    are running). For each `entry` , we inspect if it is a directory, and print accordingly.
    Running the code yields the following (we omitted a few results for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative way is to use the `Path.walk()` method to scan a directory tree.
    Let us see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Running the preceding snippet will produce a list of all the files and directories
    in the current one, and it will do the same for each sub-directory. In the source
    code for this book, you will find another module, `walking.py` , which does exactly
    the same but uses the `os.walk()` function instead.
  prefs: []
  type: TYPE_NORMAL
- en: File and directory compression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we leave this section, let us give you an example of how to create a
    compressed file. In the source code for this chapter, in the `files/compression`
    folder, we have two examples: one creates a `.zip` file, while the other one creates
    a `tar.gz` file. Python allows you to create compressed files in several different
    ways and formats. Here, we are going to show you how to create the most common
    one, **ZIP** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we import `ZipFile` , and then, within a context manager,
    we write into it four files (two of which are in a sub-folder, to show how ZIP
    preserves the full path). Afterward, as an example, we open the compressed file
    and extract a couple of files from it into the `extract_zip` directory. If you
    are interested in learning more about data compression, make sure you check out
    the *Data Compression and Archiving* section on the standard library ( [https://docs.python.org/3.9/library/archiving.html](https://docs.python.org/3.9/library/archiving.html)
    ), where you’ll be able to learn all about this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Data interchange formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern software architectures tend to split an application into several components.
    Whether you embrace the service-oriented architecture paradigm or push it even
    further into the microservices realm, these components will have to exchange data.
    But even if you are coding a monolithic application whose codebase is contained
    in one project, chances are that you still have to exchange data with APIs or
    programs, or simply handle the data flow between the frontend and backend parts
    of your website, which likely won’t speak the same language.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right format in which to exchange information is crucial. A language-specific
    format has the advantage that the language itself is likely to provide you with
    all the tools to make **serialization** and **deserialization** a breeze. However,
    you will lack the ability to talk natively to other components that have been
    written in different versions of the same language, or in different languages
    altogether. Regardless of what the future looks like, going with a language-specific
    format should only be done if it is the only possible choice for the given situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to Wikipedia ( [https://en.wikipedia.org/wiki/Serialization](https://en.wikipedia.org/wiki/Serialization)
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: In computing, serialization is the process of translating a data structure or
    object state into a format that can be stored (for example, in a file or memory
    data buffer) or transmitted (for example, over a computer network) and reconstructed
    later (possibly in a different computer environment).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A safer approach is to choose a language-agnostic format. In software, some
    popular formats have become the de facto standard for data interchange. The most
    famous ones probably are **XML** , **YAML** , and **JSON** . The Python standard
    library features the `xml` and `json` modules, and, on PyPI ( [https://pypi.org/](https://pypi.org/)
    ), you can find a few different packages to work with YAML.
  prefs: []
  type: TYPE_NORMAL
- en: In the Python environment, JSON is perhaps the most commonly used format. It
    wins over the other two because of being part of the standard library, and for
    its simplicity. XML tends to be quite verbose, and harder to read.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, when working with a database like PostgreSQL, the ability to use native
    JSON fields makes a compelling case for adopting JSON in the application as well.
  prefs: []
  type: TYPE_NORMAL
- en: Working with JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**JSON** is the acronym for **JavaScript Object Notation** , and it is a subset
    of the JavaScript language. It has been around for almost two decades now, so
    it is well known and widely adopted by most languages, even though it is actually
    language independent. You can read all about it on its website ( [https://www.json.org/](https://www.json.org/)
    ), but we are going to give you a quick introduction to it now.'
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON is based on two structures:'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of name/value pairs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An ordered list of values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unsurprisingly, these two objects map to the `dict` and `list` data types in
    Python, respectively. As data types, JSON offers strings, numbers, objects, and
    values consisting of `true` , `false` , and `null` . Let us see a quick example
    to get us started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We begin by importing the `sys` and `json` modules. Then, we create a simple
    dictionary with some numbers and a list of integers. We wanted to test serializing
    and deserializing using very big numbers, both `int` and `float` , so we put 2
    ^(3141) and whatever is the biggest floating point number our system can handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'We serialize with `json.dumps()` , which converts data into a JSON formatted
    string. That data is then fed into `json.loads()` , which does the opposite: from
    a JSON formatted string, it reconstructs the data into Python.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the JSON module also provides the `dump` and `load` functions, which
    convert data to and from a file-like object.
  prefs: []
  type: TYPE_NORMAL
- en: On the last line, by means of an assertion, we make sure that the original data
    and the result of the serialization/deserialization through JSON match. Should
    the condition that follows the assert statement be falsy, that statement will
    raise an `AssertionError` . We will cover assertions in more detail in *Chapter
    10* , *Testing* .
  prefs: []
  type: TYPE_NORMAL
- en: In programming, the term **falsy** refers to an object or a condition that,
    when evaluated in a boolean context, is considered false.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see what JSON data would look like if we printed it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a dictionary with Sherlock Holmes’ data in it. If,
    like us, you are a fan of Sherlock Holmes, and are in London, you will find his
    museum at that address (which we recommend visiting; it is small but very nice).
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how we call `json.dumps()` , though. We instruct it to indent with two
    spaces and sort keys alphabetically. The result is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The similarity with Python is evident. The one difference is that if you place
    a comma on the last element in a dictionary, as is customary in Python, JSON will
    complain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us show you something interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have used a tuple instead of a list. The interesting bit
    is that, conceptually, a tuple is also an ordered list of items. It does not have
    the flexibility of a list, but still, it is considered the same from the perspective
    of JSON. Therefore, as you can see by the first `print()` , in JSON a tuple is
    transformed into a list. Naturally, then, the information that the original object
    was a tuple is lost, and when deserialization happens, what originally was a tuple
    is instead translated to a Python list. It is important that you keep this in
    mind when dealing with data, as going through a transformation process that involves
    a format that only comprises a subset of the data structures you can use implies
    there may be information loss. In this case, we lost the information about the
    type (tuple versus list).
  prefs: []
  type: TYPE_NORMAL
- en: This is actually a common problem. For example, you cannot serialize all Python
    objects to JSON, as it is not always clear how JSON should revert that object.
    Think about `datetime` , for example. An instance of that class is a Python object
    that JSON will not be able to serialize. If we transform it into a string such
    as `2018-03-04T12:00:30Z` , which is the ISO 8601 representation of a date with
    time and time zone information, what should JSON do when deserializing? Should
    it decide that *this is deserializable into a datetime object, so I’d better do
    it* , or should it simply consider it as a string and leave it as it is? What
    about data types that can be interpreted in more than one way?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that when dealing with data interchange, we often need to transform
    our objects into a simpler format prior to serializing them with JSON. The more
    we manage to simplify our data, the easier it is to represent that data in a format
    like JSON, which has limitations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, though, and mostly for internal use, it is useful to be able
    to serialize custom objects, so, just for fun, we are going to show you how with
    two examples: complex numbers and *datetime* objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom encoding/decoding with JSON
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the JSON world, we can consider terms like encoding/decoding as synonyms
    for serializing/deserializing. They basically mean transforming to and back from
    JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we are going to learn how to encode complex numbers
    – which are not serializable to JSON by default – by writing a custom encoder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining a `ComplexEncoder` class as a subclass of `JSONEncoder`
    . This class overrides the `default()` method. This method is called whenever
    the encoder encounters an object that it cannot encode natively and is expected
    to return an encodable representation of that object.
  prefs: []
  type: TYPE_NORMAL
- en: The `default()` method checks whether its argument is a `complex` object, in
    which case it returns a dictionary with some custom meta information and a list
    that contains both the real and the imaginary part of the number. That is all
    we need to do to avoid losing information for a complex number. If we receive
    anything other than an instance of `complex` , we call the `default()` method
    from the parent class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example, we then call `json.dumps()` , but this time we use the `cls`
    argument to specify the custom encoder. Finally, the result is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Half the job is done. For the deserialization part, we could have written another
    class that would inherit from `JSONDecoder` , but instead, we have chosen to use
    a different technique that is simpler and uses a small function: `object_hook()`
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Within the body of `object_hook()` , we find a `try` block. The important part
    is the two lines within the body of the `try` block itself. The function receives
    an object (note that the function is only called when `obj` is a dictionary),
    and if the metadata matches our convention for complex numbers, we pass the real
    and imaginary parts to the `complex()` function. The `try` / `except` block is
    there because our function will be called for every dictionary object that is
    decoded, so we need to handle the case where our `_meta` key is not present.
  prefs: []
  type: TYPE_NORMAL
- en: 'The decoding part of the example outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You can see that `a_complex` has been correctly deserialized. As an exercise,
    we suggest writing your own custom encoders for `Fraction` and `Decimal` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now consider a slightly more complex (no pun intended) example: dealing
    with `datetime` objects. We are going to split the code into two blocks, first
    the serializing part, and then the deserializing part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The reason this example is slightly more complex lies in the fact that `datetime`
    objects in Python can either be time-zone-aware or not; therefore, we need to
    handle them carefully. The flow is as before, only we are dealing with a different
    data type. We start by getting the current date and time information, and we do
    it both without ( `now` ) and with ( `now_tz` ) time zone awareness. We then proceed
    to define a custom encoder as before, overriding the `default()` method. The important
    bits in that method are how we get the time zone offset ( `off` ) information,
    in seconds, and how we structure the dictionary that returns the data. This time,
    the metadata says it is *datetime* information. We save the first six items from
    the time tuple (year, month, day, hour, minute, and second), plus the microseconds
    in the `data` key, and the offset after that. Good job if you could tell that
    the value of `"data"` is a concatenation of tuples.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the custom encoder, we proceed to create some data, and then we serialize
    it. The `print()` statement outputs the following (we have reformatted the output
    to make it more readable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, we find out that `None` is translated to `null` , its JavaScript
    equivalent. Moreover, we can see that the data seems to have been encoded properly.
    Let us proceed with the second part of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we first verify that the metadata is telling us it is a `datetime`
    , and then we proceed to fetch the time zone information. Once we have it, we
    pass the 7-tuple (using `*` to unpack its values in the call) and the time zone
    information to the `datetime()` call, getting back our original object. Let us
    verify it by printing `data_out` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we got everything back correctly. As an exercise, we suggest
    you write the same logic but for a `date` object, which should be simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to the next topic, a word of caution. Perhaps it is counter-intuitive,
    but working with `datetime` objects can be quite tricky, so although we are pretty
    sure this code is doing what it is supposed to do, we want to stress that we only
    tested it superficially. So, if you intend to use it, please do test it thoroughly.
    Test for different time zones, test for daylight saving time being on and off,
    test for dates before the epoch, and so on. You might find that the code in this
    section needs some modifications to suit your case.
  prefs: []
  type: TYPE_NORMAL
- en: I/O, streams, and requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**I/O** stands for **input/output** , and it broadly refers to the communication
    between a computer and the outside world. There are several different types of
    I/O, and it is outside the scope of this chapter to explain all of them, but it
    is worth going through a couple of examples. The first one will introduce the
    `io.StringIO` class, which is an in-memory stream for text I/O. The second one
    instead will escape the locality of our computer and demonstrate how to perform
    an HTTP request.'
  prefs: []
  type: TYPE_NORMAL
- en: Using an in-memory stream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In-memory objects can be useful in a multitude of situations. Memory is much
    faster than a hard disk, it is always available, and for small amounts of data
    can be the perfect choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see the first example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we import the `io` module from the standard library.
    This module features many tools related to streams and I/O. One of them is `StringIO`
    , which is an in-memory buffer in which we have written two sentences, using two
    different methods, as we did with files in the first examples of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '`StringIO` is useful when you need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Simulate file-like behavior for strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test code that works with file-like objects without using actual files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build or manipulate large strings efficiently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capture or mock input/output for testing purposes. Tests run much faster because
    they avoid disk I/O.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can either call `StringIO.write()` or we can use `print()` , instructing
    it to direct the data to our stream.
  prefs: []
  type: TYPE_NORMAL
- en: By calling `getvalue()` , we can get the content of the stream. We then proceed
    to print it, and finally, we close it. The call to `close()` causes the text buffer
    to be immediately discarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a more elegant way to write the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Like the built-in `open()` , `io.StringIO()` too works well within a context
    manager block. Notice the similarity with `open()` ; in this case as well, we
    don’t need to manually close the stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running the script, the output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Let us now proceed with the second example.
  prefs: []
  type: TYPE_NORMAL
- en: Making HTTP requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we explore two examples of HTTP requests. We will use the `requests`
    library for these examples, which you can install with `pip` , and it is included
    in the requirements file for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to perform HTTP requests against the httpbin.org ( [https://httpbin.org/](https://httpbin.org/)
    ) API, which, interestingly, was developed by Kenneth Reitz, the creator of the
    `requests` library. Httpbin is a simple HTTP request and response service that
    is useful when we want to experiment with the HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'This library is among the most widely adopted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet should be straightforward. We declare a dictionary of
    URLs against which we want to perform HTTP requests. We have encapsulated the
    code that performs the request into the `get_content()` function. As you can see,
    we perform a GET request (by using `requests.get()` ), and we print the title
    and the JSON-decoded version of the body of the response. Let us spend a few words
    on this last bit.
  prefs: []
  type: TYPE_NORMAL
- en: When we perform a request to a website, or to an API, we get back a response
    object encapsulating the data that was returned by the server we performed the
    request against. The body of some responses from `httpbin.org` happens to be JSON
    encoded, so instead of getting the body as it is (by reading `resp.text` ) and
    manually decoding it by calling `json.loads()` on it, we simply combine the two
    by using the `json()` method of the response object. There are plenty of reasons
    why the `requests` package has become so widely adopted, and one of them is its
    ease of use.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when you perform a request in your application, you will want to have a
    much more robust approach for dealing with errors and so on, but for this chapter,
    a simple example will do. We will see more examples of requests in *Chapter 14*
    , *Introduction to API Development* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our code, in the end, we run a `for` loop and get all the URLs.
    When you run it, you will see the result of each call printed on your console,
    which should look like this (prettified and trimmed for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that you might get a slightly different output in terms of version numbers
    and IPs, which is fine. Now, `GET` is only one of the HTTP verbs, albeit one of
    the most commonly used. Let us also look at how to use the `POST` verb. This is
    the type of request you make when you need to send data to the server, for example,
    to request the creation of a resource. Every time you submit a form on the web,
    you are making a `POST` request. So, let us try to make one programmatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is very similar to what we saw before, only this time we
    don’t call `get()` , but `post()` , and because we want to send some data, we
    specify that in the call. The `requests` library offers much more than this. It
    is a project that we encourage you to check out and explore, as it is quite likely
    you will be using it too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the previous script (and applying some prettifying magic to the output)
    yields the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the headers are now different, and we find the data we sent in the
    form of a key/value pair of the response body.
  prefs: []
  type: TYPE_NORMAL
- en: We hope these short examples are enough to get you started, especially with
    requests. The web changes every day, so it is worth learning the basics and then
    brushing up every now and then.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting data on disk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section of this chapter, we will look at how to persist data on disk
    in three different formats. To persist data means that the data is written to
    non-volatile storage, like a hard drive, for example, and it is not deleted when
    the process that wrote it ends its life cycle. We will explore the `pickle` and
    `shelve` modules, as well as a short example that will involve accessing a database
    using **SQLAlchemy** , perhaps the most widely adopted ORM library in the Python
    ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing data with pickle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `pickle` module, from the Python standard library, offers tools to convert
    Python objects into byte streams, and vice versa. Even though there is a partial
    overlap in the API that `pickle` and `json` expose, the two are quite different.
    As we have seen previously in this chapter, JSON is a text format that is human
    readable, language independent, and supports only a restricted subset of Python
    data types. The `pickle` module, on the other hand, is not human readable, translates
    to bytes, is Python-specific, and, thanks to the wonderful Python introspection
    capabilities, supports a large number of data types.
  prefs: []
  type: TYPE_NORMAL
- en: Besides these differences between `pickle` and `json` , there are also some
    important security concerns that you need to be aware of if you are considering
    using `pickle` . *Unpickling* erroneous or malicious data from an untrusted source
    can be dangerous, so if we decide to adopt it in our application, we need to be
    extra careful.
  prefs: []
  type: TYPE_NORMAL
- en: If you do use `pickle` , you should consider using a cryptographic signature
    to ensure that your pickled data has not been tampered with. We will see how to
    generate cryptographic signatures in Python in *Chapter 9* , *Cryptography and
    Tokens* .
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, let us see it in action by means of a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a `Person` class using the `dataclass` decorator,
    which we saw in *Chapter 6* , *OOP, Decorators, and Iterators* . The only reason
    we wrote this example using `dataclass` is to show you how effortlessly `pickle`
    deals with it, with no need for us to do anything we would not do for a simpler
    data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class has three attributes: `first_name` , `last_name` , and `id` . It
    also exposes a `greet()` method, which prints a hello message with the instance
    data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a list of instances and save it to a file. In order to do so, we
    use `pickle.dump()` , to which we feed the content to be *pickled* , and the stream
    to which we want to write. Immediately after that, we read from that same file,
    using `pickle.load()` to convert the entire content of the stream back into Python
    objects. To make sure that the objects have been converted correctly, we call
    the `greet()` method on both of them. The result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `pickle` module also allows you to convert to (and from) byte objects, by
    means of the `dumps()` and `loads()` functions (note the `s` at the end of both
    names). In day-to-day applications, `pickle` is usually used when we need to persist
    Python data that is not supposed to be exchanged with another application. One
    example we stumbled upon a few years ago was the session manager of a `flask`
    plugin, which pickles the session object before storing it in a Redis database.
    In practice, though, you are unlikely to have to deal with this library very often.
  prefs: []
  type: TYPE_NORMAL
- en: Another tool that is possibly used even less, but that proves to be useful when
    you are short on resources, is `shelve` .
  prefs: []
  type: TYPE_NORMAL
- en: Saving data with shelve
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A “shelf” is a persistent dictionary-like object. The beauty of it is that
    the values you save into a shelf can be any objects you can `pickle` , so you’re
    not restricted like you would be if you were using a database. Albeit interesting
    and useful, the `shelve` module is used quite rarely in practice. Just for completeness,
    let us see a quick example of how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from the wiring and the boilerplate around it, this example resembles
    an exercise with dictionaries. We create a `Person` class and then we open a `shelve`
    file within a context manager. As you can see, we use the dictionary syntax to
    store four objects: two `Person` instances, a list, and a string. If we print
    the keys, we get a list containing the four keys we used. Immediately after printing
    it, we delete the (aptly named) `delete_me` key/value pair from the shelf. Printing
    the keys again shows the deletion has succeeded. We then test a couple of keys
    for membership and, finally, we append number `7` to `a_list` . Notice how we
    have to extract the list from the shelf, modify it, and save it again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another way to open a shelf that speeds up the process a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: By opening the shelf with `writeback=True` , we enable the `writeback` feature,
    which allows us to simply append to `a_list` as if it was a value within a regular
    dictionary. The reason this feature is not active by default is that it comes
    with a price that you pay in terms of memory consumption and slower closing of
    the shelf.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have paid homage to the standard library modules related to data
    persistence, let us look at one of the most widely adopted ORMs in the Python
    ecosystem: SQLAlchemy.'
  prefs: []
  type: TYPE_NORMAL
- en: Saving data to a database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this example, we are going to work with an in-memory database, which will
    make things simpler for us. In the source code of the book, we have left a couple
    of comments to show you how to generate a SQLite file, so we hope you’ll explore
    that option as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a free database browser for SQLite at [https://dbeaver.io/](https://dbeaver.io/)
    . DBeaver is a free multi-platform database tool for developers, database administrators,
    analysts, and all people who need to work with databases. It supports all popular
    databases: MySQL, PostgreSQL, SQLite, Oracle, DB2, SQL Server, Sybase, MS Access,
    Teradata, Firebird, Apache Hive, Phoenix, Presto, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into the code, allow us to briefly introduce the concept of a
    relational database.
  prefs: []
  type: TYPE_NORMAL
- en: 'A relational database is a database that allows you to save data following
    the **relational model** , invented in 1969 by Edgar F. Codd. In this model, data
    is stored in one or more tables. Each table has rows (also known as **records**
    , or **tuples** ), each of which represents an entry in the table. Tables also
    have columns (also known as **attributes** ), each of which represents an attribute
    of the records. Each record is identified through a unique key, more commonly
    known as the **primary key** , which consists of one or more columns in the table.
    To give you an example: imagine a table called `Users` , with columns `id` , `username`
    , `password` , `name` , and `surname` .'
  prefs: []
  type: TYPE_NORMAL
- en: Such a table would be suitable for containing users of our system; each row
    would represent a different user. For example, a row with the values `3` , `fab`
    , `my_wonderful_pwd` , `Fabrizio` , and `Romano` would represent Fabrizio’s user
    in the system.
  prefs: []
  type: TYPE_NORMAL
- en: The model is called *relational* because you can establish relations between
    tables. For example, if you added a table called `PhoneNumbers` to this database,
    you could insert phone numbers into it, and then, through a relation, establish
    which phone number belongs to which user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To query a relational database, we need a special language. The main standard
    is called **SQL** , which stands for **Structured Query Language** . It originates
    from **relational algebra** , which is a formal system and theoretical framework
    for manipulating and querying data stored in relational databases. The most common
    operations you can perform usually involve filtering on the rows or columns, joining
    tables, aggregating the results according to some criteria, and so on. To give
    you an example in English, a query on our imaginary database could be: *Fetch
    all users (username, name, surname) whose username starts with “m” and who have
    at most one phone number* . In this example, we are querying for a subset of the
    rows in the database, and are only interested in three of the columns in the `User`
    table for the results. We are filtering on users by taking only those whose username
    starts with the letter *m* , and even further, only those who have at most one
    phone number.'
  prefs: []
  type: TYPE_NORMAL
- en: Each database comes with its own *flavor* of SQL. They all respect the standard
    to some extent, but none fully do, and they are all different from one another
    in some respects. This poses an issue in modern software development. If our application
    contained raw SQL code, it is quite likely that if we decided to use a different
    database engine, or maybe a different version of the same engine, we would need
    to amend the SQL code in our application.
  prefs: []
  type: TYPE_NORMAL
- en: This can be quite painful, especially since SQL queries can be quite complex.
    To alleviate this issue, computer scientists have created code that maps objects
    of a programming language to tables of a relational database. Unsurprisingly,
    the name of such a tool is **Object-Relational Mapping** ( **ORM** ).
  prefs: []
  type: TYPE_NORMAL
- en: In modern application development, one would normally start interacting with
    a database by using an ORM. Should they then find themselves in a situation where
    they cannot perform a certain query through the ORM, they would then, and only
    then, resort to using SQL directly. This is a good compromise between having no
    SQL at all and using no ORM, which means specializing the code that interacts
    with the database, with the aforementioned disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we would like to show an example that leverages SQLAlchemy,
    one of the most popular third-party Python ORMs. You will have to install it into
    the virtual environment for this chapter. We are going to define two models (
    `Person` and `Email` ), each of which maps to a table, and then we are going to
    populate the database and perform a few queries on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start with the model declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'At the beginning, we import some functions and types. We then proceed to write
    the `Person` and `Email` classes, as well as the mandatory base class for them.
    Let us see these definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Each model inherits from the `Base` class, which in this example is a simple
    class that inherits from SQLAlchemy’s `DeclarativeBase` . We define `Person` ,
    which maps to a table called `"person"` , and exposes the attributes `id` , `name`
    , and `age` . We also declare a relationship with the `Email` model, by stating
    that accessing the `emails` attribute will fetch all the entries in the `Email`
    table that are related to the particular `Person` instance we are dealing with.
    The `cascade` option affects how creation and deletion work, but it is a more
    advanced concept, so we suggest you ignore it for now and maybe investigate more
    later.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we declare is the `__repr__()` method, which provides us with
    the official string representation of an object. This is supposed to be a representation
    that can be used to completely reconstruct the object, but in this example, we
    simply use it to provide something as output. Python redirects `repr(obj)` to
    a call to `obj.__repr__()` .
  prefs: []
  type: TYPE_NORMAL
- en: We also declare the `Email` model, which maps to a table called `"email"` and
    will contain email addresses, and a reference to the person they belong to. You
    can see the `person_id` and `person` attributes are both about setting a relation
    between the `Email` and `Person` classes. Note also how we declare the `__str__()`
    method on `Email` , and then assign an alias to it, called `__repr__()` . This
    means that calling either `repr()` or `str()` on `Email` objects will ultimately
    result in calling the `__str__()` method. This is quite a common technique in
    Python, used to avoid duplicating the same code, so we took the opportunity to
    show it to you here.
  prefs: []
  type: TYPE_NORMAL
- en: A deeper understanding of this code would require more space than we can afford,
    so we encourage you to read up on **database management systems** ( **DBMS** ),
    SQL, relational algebra, and SQLAlchemy.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our models, let us use them to persist some data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following example (all the snippets presented here, until indicated
    otherwise, belong to the file `alchemy.py` in the `persistence` folder):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: First, we import the functions and classes we need. We then proceed to create
    an engine for the application, and finally, we instruct SQLAlchemy to create all
    the tables through the given engine.
  prefs: []
  type: TYPE_NORMAL
- en: The `create_engine()` function supports a parameter called `echo` , which can
    be set to `True` , `False` , or the string `"debug"` , to enable different levels
    of logging of all statements and the `repr()` of their parameters. Please refer
    to the official SQLAlchemy documentation for further information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In SQLAlchemy, an engine is a core component that serves as the primary interface
    between Python applications and databases. It manages two crucial aspects of database
    interactions: connections and SQL statement execution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the imports and creating the engine and tables, we set up a session via
    a context manager, using the engine we just created. We start by creating two
    `Person` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We then add email addresses to both objects using two different techniques.
    One assigns them to a list, and the other one simply appends them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We have not touched the database yet. It is only when we use the `session`
    object that something actually happens in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Adding the two `Person` instances is enough to also add their email addresses
    (this is thanks to the cascading effect). Calling `commit()` causes SQLAlchemy
    to commit the transaction and save the data in the database.
  prefs: []
  type: TYPE_NORMAL
- en: A **transaction** is an operation that provides something like a sandbox, but
    in a database context. As long as the transaction hasn’t been committed, we can
    roll back any modification we have done to the database, and by doing so, revert
    to the state we were in before starting the transaction itself. SQLAlchemy offers
    more complex and granular ways to deal with transactions, which you can study
    in its official documentation, as it is quite an advanced topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now query for all the people whose name starts with `Obi` by using `like()`
    , which hooks to the `LIKE` operator in SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We take the first result of that query (we know we only have Obi-Wan anyway)
    and print it. We then fetch `anakin` by using an exact match on his name, just
    to show you another way of filtering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We then capture Anakin’s ID, and delete the `anakin` object from the global
    frame (this does not delete the entry from the database):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason we do this is because we want to show you how to fetch an object
    by its ID. To display the full content of the database, we have written a `display_info()`
    function. It works by fetching the email addresses first and person objects later,
    through their relationship with `Email` . It also provides a count of all objects
    per model. In the module, this function is defined before entering the context
    manager that provides the session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We call this function, then we fetch and delete `anakin` . Finally, we display
    the info again to verify that he has actually disappeared from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of all these snippets run together is the following (for your convenience,
    we have separated the output into four blocks, to reflect the four blocks of code
    that produce that output):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the last two blocks, deleting `anakin` has deleted one `Person`
    object and the three email addresses associated with it. Again, this is because
    cascading took place when we deleted `anakin` .
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our brief introduction to data persistence. It is a vast and,
    at times, complex domain that we encourage you to explore, learning as much theory
    as possible. Lack of knowledge or proper understanding, when it comes to database
    systems, can impact the number of bugs in the system, as well as its performance.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuration files are crucial components of many Python applications. They
    allow developers to separate the main application code from settings and parameters.
    This separation is helpful for maintaining, managing, and distributing software,
    especially when an application needs to run in different environments – such as
    development, production, and testing – with different configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuration files allow:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flexibility** : Users can change the behavior of an application without modifying
    its code. This is particularly useful for applications that are deployed across
    different environments, or require credentials to a database, API keys, and so
    on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security** : Sensitive information, like authentication credentials, API
    keys, or secret tokens, should be kept out of the source code and managed separately
    from the codebase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Configuration files can be written in several formats, each of which has its
    own syntax and features. A few popular ones are `INI` , `JSON` , `YAML` , `TOML`
    , and `.env` .
  prefs: []
  type: TYPE_NORMAL
- en: In this short section, we are going to briefly explore the `INI` and `TOML`
    formats. In *Chapter 14* , *Introduction to API Development* , we will also use
    a `.env` file.
  prefs: []
  type: TYPE_NORMAL
- en: The INI configuration format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `INI` format is a simple text file, divided into sections. Each section
    contains properties expressed in the form of key/value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about this format, please visit [https://en.wikipedia.org/wiki/INI_file](https://en.wikipedia.org/wiki/INI_file)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at an example INI configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding text, there are some sections dedicated to a database connection.
    Common properties can be found in the `database` section, whereas specific properties
    are placed in the `.primary` or `.secondary` sections, which represent configurations
    to connect to a *primary* and *secondary* database, respectively. There is also
    an `owner` section and a `DEFAULT` section.
  prefs: []
  type: TYPE_NORMAL
- en: To read this configuration in an application, we can use the `configparser`
    module from the standard library ( [https://docs.python.org/3/library/configparser.html](https://docs.python.org/3/library/configparser.html)
    ). It is straightforward in that it will produce an object similar to a dictionary,
    with the added bonus that the `DEFAULT` section automatically provides values
    for all other sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see an example session from the Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we import `configparser` and use it to create a `config` object.
    This object exposes various methods; you can get a list of sections, as well as
    retrieving any value in it.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, `configparser` stores values as strings, so we need to cast them
    appropriately, if we want to use them as the Python object they represent. There
    are some methods on the `ConfigParser` object, namely `getint()` , `getfloat()`
    , and `getboolean()` , that will retrieve a value and return it cast to the indicated
    type, but as you can see the list is rather short.
  prefs: []
  type: TYPE_NORMAL
- en: Notice also how properties from the `DEFAULT` section are injected in all other
    sections. Moreover, when a section defines a key that is also present in the `DEFAULT`
    section, the value from the original section will not be overwritten by the `DEFAULT`
    one. You can see an example of this in the highlighted code, which shows that
    the `title` property is present in the `database` section, and the `host` one,
    which is present in both sections, retains the value `'192.168.1.255'` correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The TOML configuration format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `TOML` format is quite popular in Python applications, and it has a richer
    set of features compared to the INI one. If you wish to learn its syntax, please
    refer to [https://toml.io/](https://toml.io/) .
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are going to see a quick example that follows the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This time, we have no `DEFAULT` section, and properties are specified slightly
    differently, in that strings are surrounded by quotes, while numbers are not.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `tomllib` module from the standard library ( [https://docs.python.org/3/library/tomllib.html](https://docs.python.org/3/library/tomllib.html)
    ) to read this configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Notice how, this time, the `config` object is a dictionary. Because of the way
    we have specified the `database.primary` and `database.secondary` sections, `tomllib`
    has created a nested structure to represent them.
  prefs: []
  type: TYPE_NORMAL
- en: With TOML, values are correctly cast to Python objects. We have strings, numbers,
    lists, and even a `datetime` object, created from the iso-formatted string representing
    Fabrizio’s date of birth. On the `tomllib` documentation page, you can find a
    table with all possible conversions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we explored working with files and directories. We learned
    how to read and write on files, and how to do that elegantly by using context
    managers. We also explored directories: how to list their content, both recursively
    and not. We also learned about paths, which are the gateway to accessing both
    files and directories.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then briefly saw how to create a ZIP archive and extract its content. The
    source code of the book also contains an example with a different compression
    format: `tar.gz` .'
  prefs: []
  type: TYPE_NORMAL
- en: We talked about data interchange formats and explored JSON in some depth. We
    had some fun writing custom encoders and decoders for specific Python data types.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we explored I/O, both with in-memory streams and HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to persist data using `pickle` , `shelve` , and the SQLAlchemy ORM
    library.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, we explored two examples of configuration files, using the INI
    and TOML formats.
  prefs: []
  type: TYPE_NORMAL
- en: You should now have a good understanding of how to deal with files and data
    persistence, and we hope you will take the time to explore these topics in much
    more depth by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will look at cryptography and tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_8.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/QR_Code119001106417026468.png)'
  prefs: []
  type: TYPE_IMG
