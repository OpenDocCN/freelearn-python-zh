- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Files and Data Persistence
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件和数据持久化
- en: ”It is not that I’m so smart, it is just that I stay with problems longer.”
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “不是因为我有多聪明，只是我愿意与问题相处更久。”
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Albert Einstein
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: – 阿尔伯特·爱因斯坦
- en: In the previous chapters, we explored several different aspects of Python. As
    the examples have a didactic purpose, we ran them in a simple Python shell or
    in the form of a Python module. They ran, maybe printed something on the console,
    and then they terminated, leaving no trace of their brief existence.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了Python的几个不同方面。由于示例具有教学目的，我们在简单的Python shell或Python模块的形式下运行它们。它们运行，可能在控制台上打印了一些内容，然后终止，没有留下它们短暂存在的痕迹。
- en: Real-world applications are rather different. Naturally, they still run in memory,
    but they interact with networks, disks, and databases. They also exchange information
    with other applications and devices, using formats that are suitable for the situation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 实际应用相当不同。自然地，它们仍然在内存中运行，但它们与网络、磁盘和数据库交互。它们还与其他应用程序和设备交换信息，使用适合该情况格式的格式。
- en: 'In this chapter, we are going to start closing in on the real world by exploring
    the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过探索以下内容来开始关注现实世界：
- en: Files and directories
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件和目录
- en: Compression
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩
- en: Networks and streams
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络和流
- en: The JSON data-interchange format
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON数据交换格式
- en: Data persistence with `pickle` and `shelve` from the standard library
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准库中的`pickle`和`shelve`进行数据持久化
- en: Data persistence with SQLAlchemy
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SQLAlchemy进行数据持久化
- en: Configuration files
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件
- en: As usual, we will try to balance breadth and depth so that by the end of the
    chapter, you will have a solid grasp of the fundamentals and will know how to
    fetch further information from the web.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们将尝试平衡广度和深度，以便到本章结束时，你将牢固掌握基础知识，并知道如何从网络中获取更多信息。
- en: Working with files and directories
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与文件和目录一起工作
- en: When it comes to files and directories, Python offers plenty of useful tools.
    In the following examples, we will use the `os` , `pathlib` , and `shutil` modules.
    As we will be reading and writing on the disk, we will be using a file, `fear.txt`
    , which contains an excerpt from *Fear* , by Thich Nhat Hanh, as a base for some
    of our examples.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到文件和目录时，Python提供了许多有用的工具。在下面的示例中，我们将使用`os`、`pathlib`和`shutil`模块。由于我们将要在磁盘上进行读写操作，我们将使用一个文件`fear.txt`作为一些示例的基础，该文件包含来自一行禅宗大师一行禅的《恐惧》摘录。
- en: Opening files
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打开文件
- en: 'Opening a file in Python is simple and intuitive. In fact, we just need to
    use the `open()` function. Let us see a quick example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中打开文件简单直观。实际上，我们只需要使用`open()`函数。让我们看看一个快速示例：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The previous code is straightforward. We call `open()` , passing the filename,
    and telling `open()` that we want to read it in text mode (via the `"rt"` flag).
    There is no path information before the filename; therefore, `open()` will assume
    the file is in the same folder the script is run from. This means that if we run
    this script from outside the `files` folder, then `fear.txt` will not be found.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码很简单。我们调用`open()`，传递文件名，并告诉`open()`我们想要以文本模式（通过`"rt"`标志）读取它。文件名之前没有路径信息；因此，`open()`将假设文件位于脚本运行的同一文件夹中。这意味着如果我们从这个`files`文件夹外部运行此脚本，那么`fear.txt`将找不到。
- en: Once the file has been opened, we obtain a file object, `fh` , which we can
    use to work on the content of the file. We chose that name because, in Python,
    a file object is essentially a high-level abstraction that wraps the underlying
    file handle ( `fh` ). In this case, we use the `readlines()` method to iterate
    over all the lines in the file and print them. We call `strip()` on each line
    to get rid of any extra spaces around the content, including the line termination
    character at the end, since `print()` will already add one for us. This is a quick
    and dirty solution that works in this example but should the content of the file
    contain meaningful spaces that need to be preserved, you will have to be slightly
    more careful in how you sanitize the data. At the end of the script, we close
    the stream.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件被打开，我们就获得了一个文件对象，`fh`，我们可以用它来处理文件的内容。我们选择这个名字是因为，在Python中，文件对象本质上是一个高级抽象，它封装了底层的文件句柄（`fh`）。在这种情况下，我们使用`readlines()`方法遍历文件中的所有行并打印它们。我们对每一行调用`strip()`以去除内容周围的任何额外空格，包括行终止字符，因为`print()`已经为我们添加了一个。这是一个快速且简单的解决方案，在这个例子中有效，但如果文件内容包含需要保留的有意义的空格，你将不得不在清理数据时更加小心。在脚本末尾，我们关闭流。
- en: Closing a file is important as we do not want to risk failing to release the
    handle ( `fh` ) we have on it. When that happens, you can encounter issues such
    as memory leaks, or the annoying *“you cannot delete this file”* pop-up that informs
    you that some software is still using it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭文件很重要，因为我们不希望冒无法释放我们对它的句柄（`fh`）的风险。当这种情况发生时，你可能会遇到内存泄漏或令人烦恼的 *“你不能删除此文件”*
    弹窗，告诉你某些软件仍在使用它。
- en: 'Therefore, we need to apply some precautions and wrap the previous logic in
    a `try/finally` block. This means that, whatever error might occur when we try
    to open and read the file, we can rest assured that `close()` will be called:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要采取一些预防措施，并将之前的逻辑包装在 `try/finally` 块中。这意味着无论我们尝试打开和读取文件时可能发生的任何错误，我们都可以确信
    `close()` 会被调用：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The logic is the same, but now it is also safe.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑是相同的，但现在它也是安全的。
- en: If you are not familiar with the `try` / `finally` block, make sure you go back
    to the *Handling Exceptions* section of *Chapter 7* , *Exceptions and Context
    Managers* , and study it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉 `try` / `finally` 块，请确保你回到 *第7章* 的 *处理异常* 部分，*异常和上下文管理器*，并学习它。
- en: 'We can simplify the previous example further like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步简化之前的例子，如下所示：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The default mode for opening files is `"rt"` , so we do not need to specify
    it. Moreover, we can simply iterate on `fh` without explicitly calling `readlines()`
    on it. Python often gives us shorthands to make our code more compact and simpler
    to read.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件的默认模式是 `"rt"`，因此我们不需要指定它。此外，我们可以简单地迭代 `fh`，而不需要显式调用 `readlines()`。Python
    经常给我们提供简写，使我们的代码更加紧凑且易于阅读。
- en: 'All the previous examples produce a print of the file on the console (check
    out the source code to read the whole content):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前一个例子都会在控制台上打印出文件的内容（查看源代码以读取全部内容）：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using a context manager to open a file
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用上下文管理器打开文件
- en: 'To avoid having to use `try` / `finally` blocks throughout our code, Python
    gives us a nicer and equally safe way to do it: by using a context manager. Let
    us see the code first:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在代码中到处使用 `try` / `finally` 块，Python 给我们提供了一种更优雅且同样安全的做法：通过使用上下文管理器。让我们先看看代码：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This example is equivalent to the previous one but reads better. The `open()`
    function returns a file object when invoked by a context manager, and it conveniently
    calls `fh.close()` automatically when execution exits the context manager scope.
    This will happen even in the case of errors.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与上一个例子等效，但读起来更好。当通过上下文管理器调用时，`open()` 函数返回一个文件对象，并且当执行退出上下文管理器的作用域时，它会方便地自动调用
    `fh.close()`。即使发生错误，也会发生这种情况。
- en: Reading from and writing to a file
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从文件中读取和写入
- en: 'Now that we know how to open a file, let us see how to read from and write
    to it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何打开文件，让我们看看如何从文件中读取和写入：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This first approach uses the `print()` function, with which we are already familiar
    from previous chapters. After obtaining a file object, this time specifying that
    we intend to write to it ( `"w"` ), we can tell the call to `print()` to direct
    its output to the file, instead of to the **standard output** stream as it normally
    does.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种第一种方法使用 `print()` 函数，我们已经在之前的章节中熟悉了它。在获得文件对象后，这次指定我们打算写入它（`"w"`），我们可以告诉 `print()`
    调用将输出定向到文件，而不是像通常那样定向到 **标准输出** 流。
- en: In Python, the standard input, output, and error streams are represented by
    the file objects `sys.stdin` , `sys.stdout` , and `sys.stderr` . Unless input
    or output is redirected, reading from `sys.stdin` usually corresponds to reading
    from the keyboard, and writing to `sys.stdout` or `sys.stderr` usually prints
    to the console screen.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，标准输入、输出和错误流由文件对象 `sys.stdin`、`sys.stdout` 和 `sys.stderr` 表示。除非输入或输出被重定向，否则从
    `sys.stdin` 读取通常对应于从键盘读取，而将内容写入 `sys.stdout` 或 `sys.stderr` 通常会在控制台屏幕上打印。
- en: The previous code creates the `print_example.txt` file if it does not exist,
    or truncates it if it does, and writes the line `Hey I am printing into a file!!!`
    into it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码会在文件不存在时创建 `print_example.txt` 文件，或者如果它已存在，则截断它，并将行 `Hey I am printing
    into a file!!!` 写入其中。
- en: Truncating a file means erasing its contents without deleting it. After truncation,
    the file still exists on the filesystem, but it is empty.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 截断文件意味着在不删除文件的情况下擦除其内容。截断后，文件仍然存在于文件系统中，但它为空。
- en: 'This example does the job, but it is not what we would typically do when writing
    to a file. Let us see a more common approach:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子完成了工作，但这并不是我们写入文件时通常会做的事情。让我们看看一种更常见的方法：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we first open `fear.txt` and gather its content into a list,
    line by line. Notice that, this time, we are calling a different method, `rstrip()`
    , as an example, to make sure we only strip the whitespace on the right-hand side
    of every line.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先打开 `fear.txt` 并逐行收集其内容到一个列表中。注意，这次我们调用了一个不同的方法 `rstrip()`，作为一个例子，以确保我们只去除每行的右侧空白。
- en: In the second part of the snippet, we create a new file, `fear_copy.txt` , and
    we write to it all the strings in `lines` , joined by a newline, `\n` . Python
    works by default with **universal newlines** , which means that even though the
    original file might have a newline that is different from `\n` , it will be translated
    automatically for us before the line is returned. This behavior is, of course,
    customizable, but normally it is exactly what we want. Speaking of newlines, can
    you think of one that might be missing in the copy?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段的第二部分，我们创建了一个新文件 `fear_copy.txt`，并将 `lines` 中的所有字符串写入其中，通过换行符 `\n` 连接。Python
    默认使用 **通用换行符**，这意味着即使原始文件可能有与 `\n` 不同的换行符，它也会在我们返回行之前自动为我们转换。这种行为当然是可以定制的，但通常这正是我们想要的。说到换行符，你能想到在复制中可能缺失的一个吗？
- en: Reading and writing in binary mode
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以二进制模式读写
- en: Notice that by opening a file and passing `t` in the options (or omitting it,
    as it is the default), we are opening the file in text mode. This means that the
    content of the file is treated and interpreted as text.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过打开一个文件并传递 `t` 选项（或者省略它，因为它默认是这样），我们是以文本模式打开文件的。这意味着文件的内容被当作文本处理和解释。
- en: If you wish to write bytes to a file, you can open it in **binary mode** . This
    is a common requirement when you handle files that do not just contain raw text,
    such as images, audio/video, and, in general, any other proprietary format.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望向文件写入字节，你可以以 **二进制模式** 打开它。当你处理不包含纯文本的文件时，这是一个常见的需求，例如图像、音频/视频，以及通常的任何其他专有格式。
- en: 'To handle files in binary mode, simply specify the `b` flag when opening them,
    as in the following example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要以二进制模式处理文件，只需在打开时指定 `b` 标志，如下面的例子所示：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, we are still using text as binary data, for simplicity, but
    it could be anything you want. You can see it is treated as binary by the fact
    that you get the `b` prefix in the output string.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们仍然使用文本作为二进制数据，为了简单起见，但它可以是任何你想要的东西。你可以看到它被当作二进制处理，因为输出字符串中有 `b` 前缀。
- en: Protecting against overwriting an existing file
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防止覆盖现有文件
- en: 'As we have seen, Python gives us the ability to open files for writing. By
    using the `w` flag, we open a file and truncate its content. This means the file
    is overwritten with an empty file, and the original content is lost. If you wish
    to only open a file for writing if it does not already exist, you can use the
    `x` flag instead, as in the following example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Python 给我们提供了打开文件进行写入的能力。通过使用 `w` 标志，我们打开一个文件并截断其内容。这意味着文件被一个空文件覆盖，原始内容丢失。如果你希望只有在文件不存在时才打开文件进行写入，你可以使用
    `x` 标志，如下面的例子所示：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you run this snippet, you will find a file called `write_x.txt` in your
    directory, containing only one line of text. The second part of the snippet, in
    fact, fails to execute. This is the output we get on our console (the file path
    has been shortened for editorial purposes):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个代码片段，你将在你的目录中找到一个名为 `write_x.txt` 的文件，其中只包含一行文本。实际上，代码片段的第二部分未能执行。这是我们控制台上的输出（为了编辑目的，文件路径已被缩短）：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we have seen, there are different modes for opening a file. You can find
    the full list of flags at [https://docs.python.org/3/library/functions.html#open](https://docs.python.org/3/library/functions.html#open)
    .
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，打开文件有不同的模式。你可以在 [https://docs.python.org/3/library/functions.html#open](https://docs.python.org/3/library/functions.html#open)
    找到完整的标志列表。
- en: Checking for file and directory existence
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查文件和目录是否存在
- en: 'If you want to make sure a file or directory exists (or does not), the `pathlib`
    module is what you need. Let us see a small example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要确保一个文件或目录存在（或者不存在），你需要使用 `pathlib` 模块。让我们看一个小例子：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding snippet, we create a `Path` object that we set up with the
    name of the text file we want to inspect. We use the `parent()` method to retrieve
    the folder in which the file is contained, and we call the `absolute()` method
    on it to extract the absolute path information.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个 `Path` 对象，我们用要检查的文本文件的名字来设置它。我们使用 `parent()` 方法来检索包含文件的文件夹，并对其调用
    `absolute()` 方法以提取绝对路径信息。
- en: We check if `"fear.txt"` is a file and the folder in which it is contained is
    indeed a folder (or directory, which is equivalent).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: The old way to do these operations was to use the `os.path` module from the
    standard library. While `os.path` works on strings, `pathlib` offers classes representing
    filesystem paths with semantics appropriate for different operating systems. Hence,
    we suggest using `pathlib` whenever possible, and reverting to the old way of
    doing things only when there is no alternative.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating files and directories
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us see a couple of quick examples of how to manipulate files and directories.
    The first example manipulates the content:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This example defines two functions: `sanitize()` and `reverse()` . They are
    simple functions whose purpose is to remove anything that is not a letter or space
    from a string and produce the reversed copy of a string, respectively.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'We open `fear.txt` and we read its content into a list. Then we create a new
    file, `raef.txt` , which will contain the horizontally mirrored version of the
    original. We write all the content of `lines` with a single operation, using `join`
    on a newline character. Maybe more interesting is the bit at the end. First, we
    reassign `lines` to a sanitized version of itself by means of a list comprehension.
    Then we put the lines together in the `whole` string, and finally, we pass the
    result to a `Counter` object. Notice that we split the lowercase version of the
    string into a list of words. This way, each word will be counted correctly, regardless
    of its case, and, thanks to `split()` , we don’t need to worry about extra spaces
    anywhere. When we print the three most common words, we realize that, truly, Thich
    Nhat Hanh’s focus was on others, as *“we”* is the most common word in the text:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let us now see an example of manipulation that’s more related to disk operations,
    in which we put the `shutil` module to use:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code, we start by declaring a base path, which will contain
    all the files and folders we are going to create. We then use `mkdir()` to create
    two directories: `ops_example/A/B` and `ops_example/A/C` . Notice that we don’t
    need to specify `parents=True` when calling `path_c.mkdir()` , since all the parents
    have already been created by the previous call on `path_b` .'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: We use the `/` operator to concatenate directory names; `pathlib` takes care
    of using the right path separator for us, behind the scenes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the directories, we loop to create three files in directory
    `B` . Then, we move directory `B` and its contents to a different name: `D` .
    We also could have done this in another way: `path_b.rename(path_d)` .'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we rename `ex1.txt` to `ex1.renamed.txt` . If you open that file,
    you will see it still contains the original text from the loop logic. Calling
    `tree` on the result produces the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Manipulating pathnames
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us explore the abilities of `pathlib` a little more by means of an example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Reading the result is probably a good enough explanation for this simple example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读结果可能是对这个简单例子足够好的解释：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note how, in the last two lines, we have two different representations of the
    same path. The first one ( `readme_path.absolute()` ) shows two `"` `.."` , each
    of which, in path terms, indicates changing to the parent folder. So, by changing
    to the parent folder twice in a row, from `…/lpp4e/ch08/files/` , we go back to
    `…/lpp4e/` . This is confirmed by the last line in the example, which shows the
    output of `readme_path.resolve()` .
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在最后两行中，我们有同一路径的两种不同表示。第一个（`readme_path.absolute()`）显示了两个 `"` `.."`，每个在路径术语中都表示切换到父文件夹。因此，通过连续两次切换到父文件夹，从
    `…/lpp4e/ch08/files/`，我们回到了 `…/lpp4e/`。这由示例中的最后一行确认，它显示了 `readme_path.resolve()`
    的输出。
- en: Temporary files and directories
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 临时文件和目录
- en: 'Sometimes, it is useful to create a temporary directory or file. For example,
    when writing tests that affect the disk, you can use temporary files and directories
    to run your logic and assert that it is correct, and to be sure that at the end
    of the test run, the test folder has no leftovers. Let us see how to do it in
    Python:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，创建一个临时目录或文件是有用的。例如，当编写影响磁盘的测试时，你可以使用临时文件和目录来运行你的逻辑并断言它是正确的，并且确保在测试运行结束时，测试文件夹没有遗留物。让我们看看如何在
    Python 中做到这一点：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding example is quite straightforward: we create a temporary directory
    in the current one ( `"."` ), and we create a named temporary file in it. We print
    the filename, as well as its full path:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子相当简单：我们在当前目录（`"."`）中创建一个临时目录，并在其中创建一个命名的临时文件。我们打印文件名，以及它的完整路径：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Running this script will produce a different result every time as these are
    temporary random names.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个脚本将每次产生不同的结果，因为这些是临时的随机名称。
- en: Directory content
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目录内容
- en: 'With Python, you can also inspect the contents of a directory. We will show
    you two ways of doing this. This is the first one:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python，你还可以检查目录的内容。我们将向你展示两种方法。这是第一种：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This snippet uses the `glob()` method of a `Path` object, applied from the
    current directory. We iterate over the results, each of which is an instance of
    a subclass of `Path` ( `PosixPath` or `WindowsPath` , according to which OS we
    are running). For each `entry` , we inspect if it is a directory, and print accordingly.
    Running the code yields the following (we omitted a few results for brevity):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段使用了 `Path` 对象的 `glob()` 方法，从当前目录应用。我们遍历结果，每个结果都是一个 `Path` 子类的实例（`PosixPath`
    或 `WindowsPath`，根据我们运行的操作系统）。对于每个 `entry`，我们检查它是否是目录，并相应地打印。运行代码将产生以下结果（为了简洁，我们省略了一些结果）：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'An alternative way is to use the `Path.walk()` method to scan a directory tree.
    Let us see an example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 `Path.walk()` 方法来扫描目录树。让我们看一个例子：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Running the preceding snippet will produce a list of all the files and directories
    in the current one, and it will do the same for each sub-directory. In the source
    code for this book, you will find another module, `walking.py` , which does exactly
    the same but uses the `os.walk()` function instead.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码片段将生成当前目录中所有文件和目录的列表，并且它将为每个子目录做同样的事情。在本书的源代码中，你会找到一个名为 `walking.py`
    的模块，它做的是完全相同的事情，但使用的是 `os.walk()` 函数。
- en: File and directory compression
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件和目录压缩
- en: 'Before we leave this section, let us give you an example of how to create a
    compressed file. In the source code for this chapter, in the `files/compression`
    folder, we have two examples: one creates a `.zip` file, while the other one creates
    a `tar.gz` file. Python allows you to create compressed files in several different
    ways and formats. Here, we are going to show you how to create the most common
    one, **ZIP** :'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开这个部分之前，让我们给你一个如何创建压缩文件的例子。在本章的源代码中，在 `files/compression` 文件夹中，我们有两个例子：一个创建
    `.zip` 文件，而另一个创建 `tar.gz` 文件。Python 允许你以多种不同的方式和格式创建压缩文件。在这里，我们将向你展示如何创建最常见的一种，**ZIP**：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code, we import `ZipFile` , and then, within a context manager,
    we write into it four files (two of which are in a sub-folder, to show how ZIP
    preserves the full path). Afterward, as an example, we open the compressed file
    and extract a couple of files from it into the `extract_zip` directory. If you
    are interested in learning more about data compression, make sure you check out
    the *Data Compression and Archiving* section on the standard library ( [https://docs.python.org/3.9/library/archiving.html](https://docs.python.org/3.9/library/archiving.html)
    ), where you’ll be able to learn all about this topic.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们导入`ZipFile`，然后在上下文管理器中写入四个文件（其中两个位于子文件夹中，以展示ZIP如何保留完整路径）。之后，作为一个例子，我们打开压缩文件，从中提取一些文件到`extract_zip`目录。如果您对数据压缩感兴趣，请确保查看标准库中的*数据压缩和归档*部分（[https://docs.python.org/3.9/library/archiving.html](https://docs.python.org/3.9/library/archiving.html)），在那里您可以了解有关此主题的所有内容。
- en: Data interchange formats
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据交换格式
- en: Modern software architectures tend to split an application into several components.
    Whether you embrace the service-oriented architecture paradigm or push it even
    further into the microservices realm, these components will have to exchange data.
    But even if you are coding a monolithic application whose codebase is contained
    in one project, chances are that you still have to exchange data with APIs or
    programs, or simply handle the data flow between the frontend and backend parts
    of your website, which likely won’t speak the same language.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现代软件架构倾向于将应用程序拆分为几个组件。无论您是采用面向服务的架构范式，还是将其进一步推进到微服务领域，这些组件都必须要交换数据。但即使您正在编写一个单体应用程序，其代码库包含在一个项目中，您仍然可能需要与API或程序交换数据，或者简单地处理网站的前端和后端部分之间的数据流，这些部分可能不会使用相同的语言。
- en: Choosing the right format in which to exchange information is crucial. A language-specific
    format has the advantage that the language itself is likely to provide you with
    all the tools to make **serialization** and **deserialization** a breeze. However,
    you will lack the ability to talk natively to other components that have been
    written in different versions of the same language, or in different languages
    altogether. Regardless of what the future looks like, going with a language-specific
    format should only be done if it is the only possible choice for the given situation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的信息交换格式至关重要。语言特定的格式具有优势，因为该语言本身很可能为您提供所有工具，使**序列化**和**反序列化**变得轻而易举。然而，您将无法与用同一语言的不同版本或完全不同的语言编写的其他组件进行本地通信。无论未来看起来如何，只有在是给定情况下唯一可能的选择时，才应该采用语言特定的格式。
- en: 'According to Wikipedia ( [https://en.wikipedia.org/wiki/Serialization](https://en.wikipedia.org/wiki/Serialization)
    ):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科（[https://en.wikipedia.org/wiki/Serialization](https://en.wikipedia.org/wiki/Serialization)）：
- en: In computing, serialization is the process of translating a data structure or
    object state into a format that can be stored (for example, in a file or memory
    data buffer) or transmitted (for example, over a computer network) and reconstructed
    later (possibly in a different computer environment).
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在计算机科学中，序列化是将数据结构或对象状态转换为一种可以存储（例如，在文件或内存数据缓冲区中）或传输（例如，通过计算机网络）的格式，并在以后重建（可能在不同的计算机环境中）的过程。
- en: A safer approach is to choose a language-agnostic format. In software, some
    popular formats have become the de facto standard for data interchange. The most
    famous ones probably are **XML** , **YAML** , and **JSON** . The Python standard
    library features the `xml` and `json` modules, and, on PyPI ( [https://pypi.org/](https://pypi.org/)
    ), you can find a few different packages to work with YAML.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更安全的方法是选择一种语言无关的格式。在软件中，一些流行的格式已经成为数据交换的事实标准。最著名的可能是**XML**、**YAML**和**JSON**。Python标准库提供了`xml`和`json`模块，在PyPI（[https://pypi.org/](https://pypi.org/)）上，您可以找到一些用于处理YAML的不同包。
- en: In the Python environment, JSON is perhaps the most commonly used format. It
    wins over the other two because of being part of the standard library, and for
    its simplicity. XML tends to be quite verbose, and harder to read.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python环境中，JSON可能是最常用的格式。它之所以胜过其他两种，是因为它是标准库的一部分，以及它的简单性。XML往往相当冗长，难以阅读。
- en: Moreover, when working with a database like PostgreSQL, the ability to use native
    JSON fields makes a compelling case for adopting JSON in the application as well.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当与像PostgreSQL这样的数据库一起工作时，能够使用原生JSON字段的能力使得在应用程序中也采用JSON具有很大的吸引力。
- en: Working with JSON
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JSON
- en: '**JSON** is the acronym for **JavaScript Object Notation** , and it is a subset
    of the JavaScript language. It has been around for almost two decades now, so
    it is well known and widely adopted by most languages, even though it is actually
    language independent. You can read all about it on its website ( [https://www.json.org/](https://www.json.org/)
    ), but we are going to give you a quick introduction to it now.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON**是**JavaScript Object Notation**的缩写，它是JavaScript语言的一个子集。它已经存在了近二十年，因此它广为人知，并被大多数语言广泛采用，尽管它实际上是语言无关的。你可以在其网站上阅读所有关于它的信息（[https://www.json.org/](https://www.json.org/)），但现在我们将给你一个快速介绍。'
- en: 'JSON is based on two structures:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: JSON基于两种结构：
- en: A collection of name/value pairs
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组名称/值对
- en: An ordered list of values
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值的有序列表
- en: 'Unsurprisingly, these two objects map to the `dict` and `list` data types in
    Python, respectively. As data types, JSON offers strings, numbers, objects, and
    values consisting of `true` , `false` , and `null` . Let us see a quick example
    to get us started:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，这两个对象分别映射到Python中的`dict`和`list`数据类型。作为数据类型，JSON提供字符串、数字、对象以及由`true`、`false`和`null`组成的值。让我们通过一个快速示例开始：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We begin by importing the `sys` and `json` modules. Then, we create a simple
    dictionary with some numbers and a list of integers. We wanted to test serializing
    and deserializing using very big numbers, both `int` and `float` , so we put 2
    ^(3141) and whatever is the biggest floating point number our system can handle.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入`sys`和`json`模块。然后，我们创建一个包含一些数字和一个整数列表的简单字典。我们想测试使用非常大的数字进行序列化和反序列化，包括`int`和`float`，所以我们放入了2的3141次方以及系统可以处理的最大浮点数。
- en: 'We serialize with `json.dumps()` , which converts data into a JSON formatted
    string. That data is then fed into `json.loads()` , which does the opposite: from
    a JSON formatted string, it reconstructs the data into Python.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`json.dumps()`进行序列化，它将数据转换为JSON格式的字符串。然后，该数据被输入到`json.loads()`中，它执行相反的操作：从一个JSON格式的字符串中，它将数据重构为Python。
- en: Notice that the JSON module also provides the `dump` and `load` functions, which
    convert data to and from a file-like object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，JSON模块还提供了`dump`和`load`函数，它们可以将数据转换为文件对象并从文件对象转换数据。
- en: On the last line, by means of an assertion, we make sure that the original data
    and the result of the serialization/deserialization through JSON match. Should
    the condition that follows the assert statement be falsy, that statement will
    raise an `AssertionError` . We will cover assertions in more detail in *Chapter
    10* , *Testing* .
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，通过断言，我们确保原始数据和通过JSON序列化/反序列化的结果相匹配。如果断言语句后面的条件为假，那么该语句将引发`AssertionError`。我们将在第10章*测试*中更详细地介绍断言。
- en: In programming, the term **falsy** refers to an object or a condition that,
    when evaluated in a boolean context, is considered false.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，术语**falsy**指的是在布尔上下文中评估时被认为是假的对象或条件。
- en: 'Let us see what JSON data would look like if we printed it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们打印JSON数据会是什么样子：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, we create a dictionary with Sherlock Holmes’ data in it. If,
    like us, you are a fan of Sherlock Holmes, and are in London, you will find his
    museum at that address (which we recommend visiting; it is small but very nice).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个包含福尔摩斯数据的字典。如果你像我们一样是福尔摩斯的粉丝，并且身处伦敦，你会在那个地址找到他的博物馆（我们推荐你去参观；虽然不大，但非常不错）。
- en: 'Notice how we call `json.dumps()` , though. We instruct it to indent with two
    spaces and sort keys alphabetically. The result is this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何调用`json.dumps()`的。我们指示它使用两个空格缩进并按字母顺序排序键。结果是这个：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The similarity with Python is evident. The one difference is that if you place
    a comma on the last element in a dictionary, as is customary in Python, JSON will
    complain.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python的相似性显而易见。唯一的区别是，如果你在字典中的最后一个元素后面放置一个逗号，这在Python中是惯例，JSON将会抱怨。
- en: 'Let us show you something interesting:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们展示一些有趣的东西：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, we have used a tuple instead of a list. The interesting bit
    is that, conceptually, a tuple is also an ordered list of items. It does not have
    the flexibility of a list, but still, it is considered the same from the perspective
    of JSON. Therefore, as you can see by the first `print()` , in JSON a tuple is
    transformed into a list. Naturally, then, the information that the original object
    was a tuple is lost, and when deserialization happens, what originally was a tuple
    is instead translated to a Python list. It is important that you keep this in
    mind when dealing with data, as going through a transformation process that involves
    a format that only comprises a subset of the data structures you can use implies
    there may be information loss. In this case, we lost the information about the
    type (tuple versus list).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了一个元组而不是列表。有趣的是，从概念上讲，元组也是一个有序项列表。它没有列表的灵活性，但仍然，从JSON的角度来看，它被认为是相同的。因此，正如你通过第一个`print()`看到的，在JSON中元组被转换成了列表。自然地，那么，原始对象是一个元组的信息就丢失了，在反序列化发生时，原本是元组的东西被转换成了Python列表。在处理数据时，这一点很重要，因为涉及到只包含你可用数据结构子集的格式转换过程可能意味着信息丢失。在这种情况下，我们丢失了关于类型（元组与列表）的信息。
- en: This is actually a common problem. For example, you cannot serialize all Python
    objects to JSON, as it is not always clear how JSON should revert that object.
    Think about `datetime` , for example. An instance of that class is a Python object
    that JSON will not be able to serialize. If we transform it into a string such
    as `2018-03-04T12:00:30Z` , which is the ISO 8601 representation of a date with
    time and time zone information, what should JSON do when deserializing? Should
    it decide that *this is deserializable into a datetime object, so I’d better do
    it* , or should it simply consider it as a string and leave it as it is? What
    about data types that can be interpreted in more than one way?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个常见问题。例如，你不能将所有Python对象序列化为JSON，因为并不总是清楚JSON应该如何还原那个对象。以`datetime`为例。该类的一个实例是一个JSON无法序列化的Python对象。如果我们将其转换为如`2018-03-04T12:00:30Z`这样的字符串，这是ISO
    8601格式的日期和时间以及时区信息，那么在反序列化时JSON应该怎么做？它应该决定*这可以反序列化为datetime对象，所以我最好这么做*，还是简单地将其视为字符串并保持原样？对于可以有多种解释的数据类型呢？
- en: The answer is that when dealing with data interchange, we often need to transform
    our objects into a simpler format prior to serializing them with JSON. The more
    we manage to simplify our data, the easier it is to represent that data in a format
    like JSON, which has limitations.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，在处理数据交换时，我们通常需要在将对象序列化为JSON之前将其转换为更简单的格式。我们能够使数据简化得越多，在像JSON这样的格式中表示数据就越容易，而JSON有其局限性。
- en: 'In some cases, though, and mostly for internal use, it is useful to be able
    to serialize custom objects, so, just for fun, we are going to show you how with
    two examples: complex numbers and *datetime* objects.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，尤其是内部使用时，能够序列化自定义对象非常有用，所以为了好玩，我们将通过两个例子来展示如何实现：复数和*datetime*对象。
- en: Custom encoding/decoding with JSON
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用JSON进行自定义编码/解码
- en: In the JSON world, we can consider terms like encoding/decoding as synonyms
    for serializing/deserializing. They basically mean transforming to and back from
    JSON.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSON的世界里，我们可以将编码/解码术语视为序列化/反序列化的同义词。它们基本上意味着转换到和从JSON转换回来。
- en: 'In the following example, we are going to learn how to encode complex numbers
    – which are not serializable to JSON by default – by writing a custom encoder:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们将学习如何通过编写自定义编码器来编码复数——默认情况下复数不能序列化为JSON：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We start by defining a `ComplexEncoder` class as a subclass of `JSONEncoder`
    . This class overrides the `default()` method. This method is called whenever
    the encoder encounters an object that it cannot encode natively and is expected
    to return an encodable representation of that object.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个`ComplexEncoder`类，作为`JSONEncoder`的子类。这个类重写了`default()`方法。每当编码器遇到它无法原生编码的对象时，都会调用这个方法，并期望它返回该对象的可编码表示。
- en: The `default()` method checks whether its argument is a `complex` object, in
    which case it returns a dictionary with some custom meta information and a list
    that contains both the real and the imaginary part of the number. That is all
    we need to do to avoid losing information for a complex number. If we receive
    anything other than an instance of `complex` , we call the `default()` method
    from the parent class.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example, we then call `json.dumps()` , but this time we use the `cls`
    argument to specify the custom encoder. Finally, the result is printed:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Half the job is done. For the deserialization part, we could have written another
    class that would inherit from `JSONDecoder` , but instead, we have chosen to use
    a different technique that is simpler and uses a small function: `object_hook()`
    .'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Within the body of `object_hook()` , we find a `try` block. The important part
    is the two lines within the body of the `try` block itself. The function receives
    an object (note that the function is only called when `obj` is a dictionary),
    and if the metadata matches our convention for complex numbers, we pass the real
    and imaginary parts to the `complex()` function. The `try` / `except` block is
    there because our function will be called for every dictionary object that is
    decoded, so we need to handle the case where our `_meta` key is not present.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'The decoding part of the example outputs:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can see that `a_complex` has been correctly deserialized. As an exercise,
    we suggest writing your own custom encoders for `Fraction` and `Decimal` objects.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now consider a slightly more complex (no pun intended) example: dealing
    with `datetime` objects. We are going to split the code into two blocks, first
    the serializing part, and then the deserializing part:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The reason this example is slightly more complex lies in the fact that `datetime`
    objects in Python can either be time-zone-aware or not; therefore, we need to
    handle them carefully. The flow is as before, only we are dealing with a different
    data type. We start by getting the current date and time information, and we do
    it both without ( `now` ) and with ( `now_tz` ) time zone awareness. We then proceed
    to define a custom encoder as before, overriding the `default()` method. The important
    bits in that method are how we get the time zone offset ( `off` ) information,
    in seconds, and how we structure the dictionary that returns the data. This time,
    the metadata says it is *datetime* information. We save the first six items from
    the time tuple (year, month, day, hour, minute, and second), plus the microseconds
    in the `data` key, and the offset after that. Good job if you could tell that
    the value of `"data"` is a concatenation of tuples.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'After the custom encoder, we proceed to create some data, and then we serialize
    it. The `print()` statement outputs the following (we have reformatted the output
    to make it more readable):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Interestingly, we find out that `None` is translated to `null` , its JavaScript
    equivalent. Moreover, we can see that the data seems to have been encoded properly.
    Let us proceed with the second part of the script:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once again, we first verify that the metadata is telling us it is a `datetime`
    , and then we proceed to fetch the time zone information. Once we have it, we
    pass the 7-tuple (using `*` to unpack its values in the call) and the time zone
    information to the `datetime()` call, getting back our original object. Let us
    verify it by printing `data_out` :'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, we got everything back correctly. As an exercise, we suggest
    you write the same logic but for a `date` object, which should be simpler.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to the next topic, a word of caution. Perhaps it is counter-intuitive,
    but working with `datetime` objects can be quite tricky, so although we are pretty
    sure this code is doing what it is supposed to do, we want to stress that we only
    tested it superficially. So, if you intend to use it, please do test it thoroughly.
    Test for different time zones, test for daylight saving time being on and off,
    test for dates before the epoch, and so on. You might find that the code in this
    section needs some modifications to suit your case.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: I/O, streams, and requests
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**I/O** stands for **input/output** , and it broadly refers to the communication
    between a computer and the outside world. There are several different types of
    I/O, and it is outside the scope of this chapter to explain all of them, but it
    is worth going through a couple of examples. The first one will introduce the
    `io.StringIO` class, which is an in-memory stream for text I/O. The second one
    instead will escape the locality of our computer and demonstrate how to perform
    an HTTP request.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Using an in-memory stream
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In-memory objects can be useful in a multitude of situations. Memory is much
    faster than a hard disk, it is always available, and for small amounts of data
    can be the perfect choice.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see the first example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code snippet, we import the `io` module from the standard library.
    This module features many tools related to streams and I/O. One of them is `StringIO`
    , which is an in-memory buffer in which we have written two sentences, using two
    different methods, as we did with files in the first examples of this chapter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '`StringIO` is useful when you need to:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Simulate file-like behavior for strings.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test code that works with file-like objects without using actual files.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build or manipulate large strings efficiently.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capture or mock input/output for testing purposes. Tests run much faster because
    they avoid disk I/O.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can either call `StringIO.write()` or we can use `print()` , instructing
    it to direct the data to our stream.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: By calling `getvalue()` , we can get the content of the stream. We then proceed
    to print it, and finally, we close it. The call to `close()` causes the text buffer
    to be immediately discarded.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a more elegant way to write the previous code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Like the built-in `open()` , `io.StringIO()` too works well within a context
    manager block. Notice the similarity with `open()` ; in this case as well, we
    don’t need to manually close the stream.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'When running the script, the output is:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Let us now proceed with the second example.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Making HTTP requests
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we explore two examples of HTTP requests. We will use the `requests`
    library for these examples, which you can install with `pip` , and it is included
    in the requirements file for this chapter.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: We are going to perform HTTP requests against the httpbin.org ( [https://httpbin.org/](https://httpbin.org/)
    ) API, which, interestingly, was developed by Kenneth Reitz, the creator of the
    `requests` library. Httpbin is a simple HTTP request and response service that
    is useful when we want to experiment with the HTTP protocol.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'This library is among the most widely adopted:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding snippet should be straightforward. We declare a dictionary of
    URLs against which we want to perform HTTP requests. We have encapsulated the
    code that performs the request into the `get_content()` function. As you can see,
    we perform a GET request (by using `requests.get()` ), and we print the title
    and the JSON-decoded version of the body of the response. Let us spend a few words
    on this last bit.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: When we perform a request to a website, or to an API, we get back a response
    object encapsulating the data that was returned by the server we performed the
    request against. The body of some responses from `httpbin.org` happens to be JSON
    encoded, so instead of getting the body as it is (by reading `resp.text` ) and
    manually decoding it by calling `json.loads()` on it, we simply combine the two
    by using the `json()` method of the response object. There are plenty of reasons
    why the `requests` package has become so widely adopted, and one of them is its
    ease of use.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Now, when you perform a request in your application, you will want to have a
    much more robust approach for dealing with errors and so on, but for this chapter,
    a simple example will do. We will see more examples of requests in *Chapter 14*
    , *Introduction to API Development* .
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our code, in the end, we run a `for` loop and get all the URLs.
    When you run it, you will see the result of each call printed on your console,
    which should look like this (prettified and trimmed for brevity):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Notice that you might get a slightly different output in terms of version numbers
    and IPs, which is fine. Now, `GET` is only one of the HTTP verbs, albeit one of
    the most commonly used. Let us also look at how to use the `POST` verb. This is
    the type of request you make when you need to send data to the server, for example,
    to request the creation of a resource. Every time you submit a form on the web,
    you are making a `POST` request. So, let us try to make one programmatically:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding code is very similar to what we saw before, only this time we
    don’t call `get()` , but `post()` , and because we want to send some data, we
    specify that in the call. The `requests` library offers much more than this. It
    is a project that we encourage you to check out and explore, as it is quite likely
    you will be using it too.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the previous script (and applying some prettifying magic to the output)
    yields the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Notice how the headers are now different, and we find the data we sent in the
    form of a key/value pair of the response body.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: We hope these short examples are enough to get you started, especially with
    requests. The web changes every day, so it is worth learning the basics and then
    brushing up every now and then.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Persisting data on disk
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section of this chapter, we will look at how to persist data on disk
    in three different formats. To persist data means that the data is written to
    non-volatile storage, like a hard drive, for example, and it is not deleted when
    the process that wrote it ends its life cycle. We will explore the `pickle` and
    `shelve` modules, as well as a short example that will involve accessing a database
    using **SQLAlchemy** , perhaps the most widely adopted ORM library in the Python
    ecosystem.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Serializing data with pickle
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `pickle` module, from the Python standard library, offers tools to convert
    Python objects into byte streams, and vice versa. Even though there is a partial
    overlap in the API that `pickle` and `json` expose, the two are quite different.
    As we have seen previously in this chapter, JSON is a text format that is human
    readable, language independent, and supports only a restricted subset of Python
    data types. The `pickle` module, on the other hand, is not human readable, translates
    to bytes, is Python-specific, and, thanks to the wonderful Python introspection
    capabilities, supports a large number of data types.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Besides these differences between `pickle` and `json` , there are also some
    important security concerns that you need to be aware of if you are considering
    using `pickle` . *Unpickling* erroneous or malicious data from an untrusted source
    can be dangerous, so if we decide to adopt it in our application, we need to be
    extra careful.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: If you do use `pickle` , you should consider using a cryptographic signature
    to ensure that your pickled data has not been tampered with. We will see how to
    generate cryptographic signatures in Python in *Chapter 9* , *Cryptography and
    Tokens* .
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, let us see it in action by means of a simple example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this example, we create a `Person` class using the `dataclass` decorator,
    which we saw in *Chapter 6* , *OOP, Decorators, and Iterators* . The only reason
    we wrote this example using `dataclass` is to show you how effortlessly `pickle`
    deals with it, with no need for us to do anything we would not do for a simpler
    data type.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'The class has three attributes: `first_name` , `last_name` , and `id` . It
    also exposes a `greet()` method, which prints a hello message with the instance
    data.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a list of instances and save it to a file. In order to do so, we
    use `pickle.dump()` , to which we feed the content to be *pickled* , and the stream
    to which we want to write. Immediately after that, we read from that same file,
    using `pickle.load()` to convert the entire content of the stream back into Python
    objects. To make sure that the objects have been converted correctly, we call
    the `greet()` method on both of them. The result is the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `pickle` module also allows you to convert to (and from) byte objects, by
    means of the `dumps()` and `loads()` functions (note the `s` at the end of both
    names). In day-to-day applications, `pickle` is usually used when we need to persist
    Python data that is not supposed to be exchanged with another application. One
    example we stumbled upon a few years ago was the session manager of a `flask`
    plugin, which pickles the session object before storing it in a Redis database.
    In practice, though, you are unlikely to have to deal with this library very often.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Another tool that is possibly used even less, but that proves to be useful when
    you are short on resources, is `shelve` .
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Saving data with shelve
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A “shelf” is a persistent dictionary-like object. The beauty of it is that
    the values you save into a shelf can be any objects you can `pickle` , so you’re
    not restricted like you would be if you were using a database. Albeit interesting
    and useful, the `shelve` module is used quite rarely in practice. Just for completeness,
    let us see a quick example of how it works:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Apart from the wiring and the boilerplate around it, this example resembles
    an exercise with dictionaries. We create a `Person` class and then we open a `shelve`
    file within a context manager. As you can see, we use the dictionary syntax to
    store four objects: two `Person` instances, a list, and a string. If we print
    the keys, we get a list containing the four keys we used. Immediately after printing
    it, we delete the (aptly named) `delete_me` key/value pair from the shelf. Printing
    the keys again shows the deletion has succeeded. We then test a couple of keys
    for membership and, finally, we append number `7` to `a_list` . Notice how we
    have to extract the list from the shelf, modify it, and save it again.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another way to open a shelf that speeds up the process a bit:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: By opening the shelf with `writeback=True` , we enable the `writeback` feature,
    which allows us to simply append to `a_list` as if it was a value within a regular
    dictionary. The reason this feature is not active by default is that it comes
    with a price that you pay in terms of memory consumption and slower closing of
    the shelf.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have paid homage to the standard library modules related to data
    persistence, let us look at one of the most widely adopted ORMs in the Python
    ecosystem: SQLAlchemy.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Saving data to a database
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this example, we are going to work with an in-memory database, which will
    make things simpler for us. In the source code of the book, we have left a couple
    of comments to show you how to generate a SQLite file, so we hope you’ll explore
    that option as well.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a free database browser for SQLite at [https://dbeaver.io/](https://dbeaver.io/)
    . DBeaver is a free multi-platform database tool for developers, database administrators,
    analysts, and all people who need to work with databases. It supports all popular
    databases: MySQL, PostgreSQL, SQLite, Oracle, DB2, SQL Server, Sybase, MS Access,
    Teradata, Firebird, Apache Hive, Phoenix, Presto, etc.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into the code, allow us to briefly introduce the concept of a
    relational database.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'A relational database is a database that allows you to save data following
    the **relational model** , invented in 1969 by Edgar F. Codd. In this model, data
    is stored in one or more tables. Each table has rows (also known as **records**
    , or **tuples** ), each of which represents an entry in the table. Tables also
    have columns (also known as **attributes** ), each of which represents an attribute
    of the records. Each record is identified through a unique key, more commonly
    known as the **primary key** , which consists of one or more columns in the table.
    To give you an example: imagine a table called `Users` , with columns `id` , `username`
    , `password` , `name` , and `surname` .'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Such a table would be suitable for containing users of our system; each row
    would represent a different user. For example, a row with the values `3` , `fab`
    , `my_wonderful_pwd` , `Fabrizio` , and `Romano` would represent Fabrizio’s user
    in the system.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: The model is called *relational* because you can establish relations between
    tables. For example, if you added a table called `PhoneNumbers` to this database,
    you could insert phone numbers into it, and then, through a relation, establish
    which phone number belongs to which user.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'To query a relational database, we need a special language. The main standard
    is called **SQL** , which stands for **Structured Query Language** . It originates
    from **relational algebra** , which is a formal system and theoretical framework
    for manipulating and querying data stored in relational databases. The most common
    operations you can perform usually involve filtering on the rows or columns, joining
    tables, aggregating the results according to some criteria, and so on. To give
    you an example in English, a query on our imaginary database could be: *Fetch
    all users (username, name, surname) whose username starts with “m” and who have
    at most one phone number* . In this example, we are querying for a subset of the
    rows in the database, and are only interested in three of the columns in the `User`
    table for the results. We are filtering on users by taking only those whose username
    starts with the letter *m* , and even further, only those who have at most one
    phone number.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Each database comes with its own *flavor* of SQL. They all respect the standard
    to some extent, but none fully do, and they are all different from one another
    in some respects. This poses an issue in modern software development. If our application
    contained raw SQL code, it is quite likely that if we decided to use a different
    database engine, or maybe a different version of the same engine, we would need
    to amend the SQL code in our application.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: This can be quite painful, especially since SQL queries can be quite complex.
    To alleviate this issue, computer scientists have created code that maps objects
    of a programming language to tables of a relational database. Unsurprisingly,
    the name of such a tool is **Object-Relational Mapping** ( **ORM** ).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: In modern application development, one would normally start interacting with
    a database by using an ORM. Should they then find themselves in a situation where
    they cannot perform a certain query through the ORM, they would then, and only
    then, resort to using SQL directly. This is a good compromise between having no
    SQL at all and using no ORM, which means specializing the code that interacts
    with the database, with the aforementioned disadvantages.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we would like to show an example that leverages SQLAlchemy,
    one of the most popular third-party Python ORMs. You will have to install it into
    the virtual environment for this chapter. We are going to define two models (
    `Person` and `Email` ), each of which maps to a table, and then we are going to
    populate the database and perform a few queries on it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start with the model declarations:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'At the beginning, we import some functions and types. We then proceed to write
    the `Person` and `Email` classes, as well as the mandatory base class for them.
    Let us see these definitions:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Each model inherits from the `Base` class, which in this example is a simple
    class that inherits from SQLAlchemy’s `DeclarativeBase` . We define `Person` ,
    which maps to a table called `"person"` , and exposes the attributes `id` , `name`
    , and `age` . We also declare a relationship with the `Email` model, by stating
    that accessing the `emails` attribute will fetch all the entries in the `Email`
    table that are related to the particular `Person` instance we are dealing with.
    The `cascade` option affects how creation and deletion work, but it is a more
    advanced concept, so we suggest you ignore it for now and maybe investigate more
    later.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we declare is the `__repr__()` method, which provides us with
    the official string representation of an object. This is supposed to be a representation
    that can be used to completely reconstruct the object, but in this example, we
    simply use it to provide something as output. Python redirects `repr(obj)` to
    a call to `obj.__repr__()` .
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: We also declare the `Email` model, which maps to a table called `"email"` and
    will contain email addresses, and a reference to the person they belong to. You
    can see the `person_id` and `person` attributes are both about setting a relation
    between the `Email` and `Person` classes. Note also how we declare the `__str__()`
    method on `Email` , and then assign an alias to it, called `__repr__()` . This
    means that calling either `repr()` or `str()` on `Email` objects will ultimately
    result in calling the `__str__()` method. This is quite a common technique in
    Python, used to avoid duplicating the same code, so we took the opportunity to
    show it to you here.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: A deeper understanding of this code would require more space than we can afford,
    so we encourage you to read up on **database management systems** ( **DBMS** ),
    SQL, relational algebra, and SQLAlchemy.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our models, let us use them to persist some data.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following example (all the snippets presented here, until indicated
    otherwise, belong to the file `alchemy.py` in the `persistence` folder):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: First, we import the functions and classes we need. We then proceed to create
    an engine for the application, and finally, we instruct SQLAlchemy to create all
    the tables through the given engine.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: The `create_engine()` function supports a parameter called `echo` , which can
    be set to `True` , `False` , or the string `"debug"` , to enable different levels
    of logging of all statements and the `repr()` of their parameters. Please refer
    to the official SQLAlchemy documentation for further information.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'In SQLAlchemy, an engine is a core component that serves as the primary interface
    between Python applications and databases. It manages two crucial aspects of database
    interactions: connections and SQL statement execution.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'After the imports and creating the engine and tables, we set up a session via
    a context manager, using the engine we just created. We start by creating two
    `Person` objects:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We then add email addresses to both objects using two different techniques.
    One assigns them to a list, and the other one simply appends them:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We have not touched the database yet. It is only when we use the `session`
    object that something actually happens in it:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Adding the two `Person` instances is enough to also add their email addresses
    (this is thanks to the cascading effect). Calling `commit()` causes SQLAlchemy
    to commit the transaction and save the data in the database.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: A **transaction** is an operation that provides something like a sandbox, but
    in a database context. As long as the transaction hasn’t been committed, we can
    roll back any modification we have done to the database, and by doing so, revert
    to the state we were in before starting the transaction itself. SQLAlchemy offers
    more complex and granular ways to deal with transactions, which you can study
    in its official documentation, as it is quite an advanced topic.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'We now query for all the people whose name starts with `Obi` by using `like()`
    , which hooks to the `LIKE` operator in SQL:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We take the first result of that query (we know we only have Obi-Wan anyway)
    and print it. We then fetch `anakin` by using an exact match on his name, just
    to show you another way of filtering:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We then capture Anakin’s ID, and delete the `anakin` object from the global
    frame (this does not delete the entry from the database):'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The reason we do this is because we want to show you how to fetch an object
    by its ID. To display the full content of the database, we have written a `display_info()`
    function. It works by fetching the email addresses first and person objects later,
    through their relationship with `Email` . It also provides a count of all objects
    per model. In the module, this function is defined before entering the context
    manager that provides the session:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We call this function, then we fetch and delete `anakin` . Finally, we display
    the info again to verify that he has actually disappeared from the database:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output of all these snippets run together is the following (for your convenience,
    we have separated the output into four blocks, to reflect the four blocks of code
    that produce that output):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see from the last two blocks, deleting `anakin` has deleted one `Person`
    object and the three email addresses associated with it. Again, this is because
    cascading took place when we deleted `anakin` .
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our brief introduction to data persistence. It is a vast and,
    at times, complex domain that we encourage you to explore, learning as much theory
    as possible. Lack of knowledge or proper understanding, when it comes to database
    systems, can impact the number of bugs in the system, as well as its performance.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Configuration files
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuration files are crucial components of many Python applications. They
    allow developers to separate the main application code from settings and parameters.
    This separation is helpful for maintaining, managing, and distributing software,
    especially when an application needs to run in different environments – such as
    development, production, and testing – with different configurations.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuration files allow:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '**Flexibility** : Users can change the behavior of an application without modifying
    its code. This is particularly useful for applications that are deployed across
    different environments, or require credentials to a database, API keys, and so
    on.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security** : Sensitive information, like authentication credentials, API
    keys, or secret tokens, should be kept out of the source code and managed separately
    from the codebase.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common formats
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Configuration files can be written in several formats, each of which has its
    own syntax and features. A few popular ones are `INI` , `JSON` , `YAML` , `TOML`
    , and `.env` .
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: In this short section, we are going to briefly explore the `INI` and `TOML`
    formats. In *Chapter 14* , *Introduction to API Development* , we will also use
    a `.env` file.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: The INI configuration format
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `INI` format is a simple text file, divided into sections. Each section
    contains properties expressed in the form of key/value pairs.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about this format, please visit [https://en.wikipedia.org/wiki/INI_file](https://en.wikipedia.org/wiki/INI_file)
    .
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at an example INI configuration file:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the preceding text, there are some sections dedicated to a database connection.
    Common properties can be found in the `database` section, whereas specific properties
    are placed in the `.primary` or `.secondary` sections, which represent configurations
    to connect to a *primary* and *secondary* database, respectively. There is also
    an `owner` section and a `DEFAULT` section.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: To read this configuration in an application, we can use the `configparser`
    module from the standard library ( [https://docs.python.org/3/library/configparser.html](https://docs.python.org/3/library/configparser.html)
    ). It is straightforward in that it will produce an object similar to a dictionary,
    with the added bonus that the `DEFAULT` section automatically provides values
    for all other sections.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see an example session from the Python shell:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Notice how we import `configparser` and use it to create a `config` object.
    This object exposes various methods; you can get a list of sections, as well as
    retrieving any value in it.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Internally, `configparser` stores values as strings, so we need to cast them
    appropriately, if we want to use them as the Python object they represent. There
    are some methods on the `ConfigParser` object, namely `getint()` , `getfloat()`
    , and `getboolean()` , that will retrieve a value and return it cast to the indicated
    type, but as you can see the list is rather short.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Notice also how properties from the `DEFAULT` section are injected in all other
    sections. Moreover, when a section defines a key that is also present in the `DEFAULT`
    section, the value from the original section will not be overwritten by the `DEFAULT`
    one. You can see an example of this in the highlighted code, which shows that
    the `title` property is present in the `database` section, and the `host` one,
    which is present in both sections, retains the value `'192.168.1.255'` correctly.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: The TOML configuration format
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `TOML` format is quite popular in Python applications, and it has a richer
    set of features compared to the INI one. If you wish to learn its syntax, please
    refer to [https://toml.io/](https://toml.io/) .
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are going to see a quick example that follows the previous one.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This time, we have no `DEFAULT` section, and properties are specified slightly
    differently, in that strings are surrounded by quotes, while numbers are not.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `tomllib` module from the standard library ( [https://docs.python.org/3/library/tomllib.html](https://docs.python.org/3/library/tomllib.html)
    ) to read this configuration:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Notice how, this time, the `config` object is a dictionary. Because of the way
    we have specified the `database.primary` and `database.secondary` sections, `tomllib`
    has created a nested structure to represent them.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: With TOML, values are correctly cast to Python objects. We have strings, numbers,
    lists, and even a `datetime` object, created from the iso-formatted string representing
    Fabrizio’s date of birth. On the `tomllib` documentation page, you can find a
    table with all possible conversions.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we explored working with files and directories. We learned
    how to read and write on files, and how to do that elegantly by using context
    managers. We also explored directories: how to list their content, both recursively
    and not. We also learned about paths, which are the gateway to accessing both
    files and directories.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'We then briefly saw how to create a ZIP archive and extract its content. The
    source code of the book also contains an example with a different compression
    format: `tar.gz` .'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: We talked about data interchange formats and explored JSON in some depth. We
    had some fun writing custom encoders and decoders for specific Python data types.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Then, we explored I/O, both with in-memory streams and HTTP requests.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to persist data using `pickle` , `shelve` , and the SQLAlchemy ORM
    library.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: And finally, we explored two examples of configuration files, using the INI
    and TOML formats.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: You should now have a good understanding of how to deal with files and data
    persistence, and we hope you will take the time to explore these topics in much
    more depth by yourself.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will look at cryptography and tokens.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_8.xhtml)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/QR_Code119001106417026468.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
