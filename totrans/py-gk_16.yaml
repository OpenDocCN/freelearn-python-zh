- en: '*Chapter 12*: Building Serverless Functions using Python'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serverless computing is a new model of cloud computing that separates the management
    of physical or virtual servers and infrastructure-level software, such as database
    systems, from the application itself. This model allows developers to solely focus
    on application development and enables someone else to manage the underlying infrastructure
    resources. Cloud providers are the best option to use to adopt this model. Containers
    are not only opportune for complex deployments, but they are also a breakthrough
    technology for the **serverless computing** era. In addition to containers, there
    is another form of serverless computing, which is known as **Function as a Service**
    (**FaaS**). In this new paradigm, cloud providers offer a platform to develop
    and run application functions or **serverless functions**, usually in response
    to an event or as a direct call to those functions. All public cloud providers,
    such as Amazon, Google, Microsoft, IBM, and Oracle, offer this service. The focus
    of this chapter will be on understanding and building serverless functions using
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing serverless functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding deployment options for serverless functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to build serverless functions with a case study
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After completing this chapter, you should have a clear understanding of the
    role of serverless functions in cloud computing and how to build them using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a list of the technical requirements for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: You will need to have Python 3.7, or later, installed on your computer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To deploy a serverless function in **Google Cloud Platform** (**GCP**) Cloud
    Functions, you will need a GCP account (a free trial will work fine).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will need an account (that is, a free account) with *SendGrid* for sending
    emails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sample code for this chapter can be found at [https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter12](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter12).
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin with an introduction to serverless functions.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing serverless functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A serverless function is a model that can be used to develop and execute software
    components or modules without needing to know or worry about an underlying hosting
    platform. These software modules or components are known as **Lambda functions**
    or **Cloud functions** in the public cloud providers' product offerings. Amazon
    was the first vendor that offered such serverless functions on its AWS platform
    as **AWS Lambda**. It was followed by Google and Microsoft, which offer Google
    **Cloud Functions** and **Azure Functions**, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, a serverless function has four components, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – The components of a serverless function'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_12_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.1 – The components of a serverless function
  prefs: []
  type: TYPE_NORMAL
- en: 'These four components are described next:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functional code**: This is a programming unit that performs certain tasks
    as per the business or functional goal of the function. For example, we can write
    a serverless function to process an input stream of data or write a scheduled
    activity to check certain data resources for monitoring purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Events**: Serverless functions are not meant to be used like microservices.
    Instead, they are meant to be used based on a trigger that can be initiated by
    an event from a pub/sub system, or they can come as HTTP calls based on an external
    event in the field such as events from field sensors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Outcome**: When a serverless function is triggered to do a job, there is
    an output from the function, which can either be a simple response to the caller
    or trigger the next actions to mitigate the impact of an event. One example of
    the outcome of a serverless function is to trigger another cloud service such
    as a database service or send an email to subscribed parties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resources**: Sometimes, functional code has to use an additional resource
    to do its job, for example, a database service or cloud storage to access or push
    files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benefits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Serverless functions bring with them all the benefits of serverless computing,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ease of development**: Serverless functions take away infrastructure complexities
    from developers so that they can focus on the functional aspect of the program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Built-in scalability**: Serverless functions are offered with built-in scalability
    to handle any traffic growth at any time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cost efficiency**: Serverless functions not only reduce development costs
    but also offer optimized deployment and an operational mode. Typically, this is
    a *pay-as-you-use* model that means you will only be charged for the time during
    which your function is being executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technology agnostic**: Serverless functions are technology agnostic. This
    means that you can build them in many programming languages using a variety of
    different cloud resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that there are a few limitations to serverless functions; for instance,
    we will have less system-level control in building such functions and troubleshooting
    can be tricky without system-level access.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several possible uses of serverless functions. For example, we can
    use such functions for data processing if we receive an event of a file upload
    in cloud storage or if we have data available through real-time streaming. In
    particular, serverless functions can be integrated with the **Internet of Things**
    (**IoT**) sensors. Typically, IoT sensors are thousands in number. Serverless
    functions possess the ability to handle the requests from such a large number
    of sensors in a scalable manner. A mobile application can use such functions as
    a backend service to perform certain tasks or process data without jeopardizing
    the mobile device resources. One practical use of serverless functions in real
    life is the **Amazon Alexa** product. It is not possible to put every skill or
    ounce of intelligence inside the Alexa device itself. Instead, it uses Amazon
    Lambda functions for these skills. Another reason why Alexa uses Amazon Lambda
    functions is the ability to scale them based on the demand. For instance, some
    functions might be used more often than others such as weather queries.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will investigate the various deployment options for
    implementing and executing serverless functions.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the deployment options for serverless functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using a virtual machine or another runtime resource on public clouds for sporadically
    accessed applications might not be a commercially attractive solution. In such
    situations, serverless functions come to the rescue. Here, a cloud provider offers
    dynamically managed resources for your application and only charges you when your
    application is executed in response to a certain event. In other words, a serverless
    function is a backend computing method that is an on-demand and a pay-as-you-use
    service that is only offered on public clouds. We will introduce a few options
    for deploying serverless functions in the public clouds, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AWS Lambda**: This is considered to be one of the first service offerings
    from any of the public cloud providers. AWS Lambda functions can be written in
    Python, Node.js, Java, PowerShell, Ruby, Java, C#, and Go. AWS Lambda functions
    can be executed in response to events, such as file uploads to **Amazon S3**,
    a notification from **Amazon SNS**, or a direct API call. AWS Lambda functions
    are stateless.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Functions**: Microsoft introduced Azure Functions almost two years
    after the launch of AWS Lambda functions. These functions can be attached to events
    within the cloud infrastructure. Microsoft provides support to build and debug
    these functions using Visual Studio, Visual Studio Code, IntelliJ, and Eclipse.
    Azure Functions can be written in C#, F#, Node.js, PowerShell, PHP, and Python.
    Additionally, Microsoft offers **Durable Functions** that allow us to write stateful
    functions in a serverless environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Cloud Functions**: GCP offers Google Cloud Functions as serverless
    functions. Google Cloud Functions can be written in Python, Node.js, Go, .NET,
    Ruby, and PHP. Like its competitors, AWS Lambda and Azure Functions, Google Cloud
    Functions can be triggered by HTTP requests or by events from the Google Cloud
    infrastructure. Google allows you to use Cloud Build for the automatic testing
    and deployment of Cloud Functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the top three public cloud providers, there are a few more offerings
    from other cloud providers. For example, IBM offers Cloud Functions that are based
    on the open source **Apache OpenWhisk** project. Oracle offers its serverless
    computing platform based on the open source **Fn** project. The beauty of using
    these open source projects is that you can develop and test your code locally.
    Additionally, these projects allow you to port your code from one cloud to another
    cloud or even to an on-premises environment deployment without any changes.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning another framework that is well known in serverless computing,
    called the **Serverless Framework**. This is not a deployment platform but a software
    tool that can be used locally to build and package your code for serverless deployment
    and then be used to deploy the package to one of your favorite public clouds.
    The serverless framework supports several programming languages such as Python,
    Java, Node.js, Go, C#, Ruby, and PHP.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will build a couple of serverless functions using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to build serverless functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will investigate how to build serverless functions for one
    of the public cloud providers. Although Amazon AWS pioneered serverless functions
    in 2014 by offering AWS Lambda functions, we will use the Google Cloud Functions
    platform for our example functions. The reason for this is that we already introduced
    GCP in great detail in previous chapters, and you can leverage the same GCP account
    for the deployment of these example functions. However, we strongly recommend
    that you use the other platforms, especially if you are planning to use their
    serverless functions in the future. The core principles of building and deploying
    these functions on various cloud platforms are the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'GCP Cloud Functions offers several ways in which to develop and deploy serverless
    functions (going forward, we will call them *Cloud Functions* in the context of
    GCP). We will explore two types of events in our example Cloud Functions, which
    can be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first Cloud Function will be built and deployed using the GCP Console from
    end to end. This Cloud Function will be triggered based on an HTTP call (or event).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second Cloud Function will be part of a case study to build an application
    that listens to an event in the cloud infrastructure and takes an action such
    as sending an email as a response to this event. The Cloud Function used in this
    case study will be built and deployed using the Cloud **Software Development Kit**
    (**SDK**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start by building a Cloud Function using the GCP Console.
  prefs: []
  type: TYPE_NORMAL
- en: Building an HTTP-based Cloud Function using the GCP Console
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's begin with the Google Cloud Function development process. We will build
    a very simple Cloud Function that provides today's date and current time for an
    HTTP trigger. Note that the HTTP trigger is the easiest way in which a Cloud Function
    can be invoked. First, we will need a GCP project. You can create a new GCP project
    using the GCP Console for this Cloud Function or an existing GCP project. The
    steps regarding how to create a GCP project and associate a billing account with
    it are discussed in [*Chapter 9*](B17189_09_Final_PG_ePub.xhtml#_idTextAnchor247),
    *Python Programming for the Cloud*. Once you have a GCP project ready, building
    a new Cloud Function is a three-step process. We will explain these steps in the
    following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Cloud Function attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we initiate the **Create Function** workflow from the GCP Console, we
    are prompted to provide the Cloud Function definition, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – The steps to create a new Cloud Function using the GCP Console
    (1/2)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_12_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.2 – The steps to create a new Cloud Function using the GCP Console
    (1/2)
  prefs: []
  type: TYPE_NORMAL
- en: 'A high-level summary of the Cloud Function definition appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We provide the `my-datetime`) and select the GCP **Region** to host this function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We select `HTTP` as the **Trigger type** for our function. Selecting a trigger
    for your function is the most important step. There are also other triggers available
    such as **Cloud Pub/Sub** and **Cloud Storage**. At the time of writing this book,
    GCP has added a few more triggers for evaluation purposes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the sake of simplicity, we will allow unauthenticated access for our function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After clicking on the **Save** button, we will be prompted to enter **RUNTIME,
    BUILD AND CONNECTIONS SETTINGS**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – The steps to create a new Cloud Function using the GCP Console
    (2/2)](img/B17189_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – The steps to create a new Cloud Function using the GCP Console
    (2/2)
  prefs: []
  type: TYPE_NORMAL
- en: 'We can provide the **RUNTIME, BUILD AND CONNECTIONS SETTINGS** as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We can leave the runtime attributes in their default settings, but we will reduce
    the **Memory allocated** to **128 MiB** for our function. We have associated a
    default service account as a **Runtime service account** to this function. We
    will leave **Auto-scaling** to its default setting, but this can be set to a maximum
    number of instances for our function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can add **Runtime environment variables** underneath the **RUNTIME** tab
    if we have such a requirement to do so. We will not add any environment variables
    for our Cloud Function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Underneath the **BUILD** tab, there is an option to add **Build environment
    variables**. We will not add any variable for our Cloud Function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Underneath the **CONNECTIONS** tab, we can leave the default settings as they
    are and allow all traffic to access our Cloud Function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After setting the Cloud Function's runtime, build, and connection settings,
    the next step will be to add the implementation code for this Cloud Function.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Python code to a Cloud Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After clicking on the **Next** button, as shown in *Figure 12.3*, the GCP Console
    will offer us a view to define or add the function implementation details, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – The implementation steps of a Cloud Function using the GCP
    Console'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_12_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.4 – The implementation steps of a Cloud Function using the GCP Console
  prefs: []
  type: TYPE_NORMAL
- en: 'The options that are available for adding our Python code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We can select several runtime options such as Java, PHP, Node.js, or various
    Python versions. We selected **Python 3.8** as the **Runtime** for our Cloud Function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Entry point** attribute must be the name of the function in our code.
    Google Cloud Function will invoke the function in our code based on this **Entry
    point** attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python source code can be added inline using the **Inline Editor** on the
    right-hand side; alternatively, it can be uploaded using a ZIP file from your
    local machine or even from cloud storage. We can also provide the GCP **Cloud
    Source** repository location for the source code. Here, we selected to implement
    our function using the **Inline Editor** tool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Python, the GCP Cloud Functions platform automatically creates two files:
    `main.py` and `requirements.txt`. The `main.py` file will have our code implementation
    and the `requirements.txt` file should contain our dependencies on third-party
    libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sample code, which is shown inside the `requester` attribute in the HTTP request
    or not. Based on the `requester` attribute value, we will send a welcome message
    with today's date and time. We implemented a similar code example with two separate
    web APIs using a Flask web application in [*Chapter 9*](B17189_09_Final_PG_ePub.xhtml#_idTextAnchor247),
    *Python Programming for the Cloud*, to demonstrate the capabilities of GCP App
    Engine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once we are satisfied with our Python code, we will deploy the function on the
    Google Cloud Functions platform.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a Cloud Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step is to deploy this function using the **Deploy** button at the
    bottom of the screen, as shown in *Figure 12.4*. GCP will start deploying the
    function immediately, and it can take a few minutes to complete this activity.
    It is important to understand that Google Cloud Functions are deployed using containers
    just like microservices on GCP Cloud Run. The key differences are that they can
    be invoked using different types of events and they use the pay-as-you-use pricing
    model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once our function has been deployed, we can duplicate it, test it, or delete
    it from the **Cloud Functions** list, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – The main view of Google Cloud Functions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_12_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.5 – The main view of Google Cloud Functions
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will quickly show you how convenient it is to test and troubleshoot
    our Cloud Function using the GCP Console. Once we have selected the `requester`
    attribute in JSON format, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After clicking on `CURL` utility from anywhere on the internet. However, we
    have to make sure that our Cloud Function includes `allUsers` as its member with
    the role of `Cloud Functions Invoker`. This can be set underneath the **PERMISSIONS**
    tab. However, we do not recommend doing so without setting an authentication mechanism
    for your Cloud Function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Testing your Cloud Function using the GCP Console'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_12_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.6 – Testing your Cloud Function using the GCP Console
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple Cloud Function using the GCP Console is a straightforward
    process. Next, we will explore a case study of a real-world application of Cloud
    Functions.
  prefs: []
  type: TYPE_NORMAL
- en: Case study – building a notification app for cloud storage events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this case study, we will develop a Cloud Function that is triggered for
    events on a **Google Storage bucket**. On receiving such an event, our Cloud Function
    will send an email to a predefined list of email addresses as a notification.
    The flow of this notification app with a Cloud Function appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – A Cloud Function listening to Google storage bucket events'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_12_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.7 – A Cloud Function listening to Google storage bucket events
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we can set our Cloud Function to listen to one or more Google Storage
    events. Google Cloud Functions supports the following Google Storage events:'
  prefs: []
  type: TYPE_NORMAL
- en: '**finalize**: This event is created when a new file is added or replaced within
    a storage bucket.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**delete**: This event represents the deletion of a file from a storage bucket.
    This applies to non-versioning buckets. Note that a file is not deleted in reality,
    but it is archived if the bucket is set to use versioning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**archive**: This event is raised when a file is archived. The archive operation
    is triggered when a file is deleted or overwritten for buckets with versioning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**metadata update**: If there is any update in the metadata of a file, this
    event is created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After receiving an event from a Google Storage bucket, the Cloud Function will
    extract the attributes from the context and event objects passed as arguments
    to our Cloud Function. Then, the cloud function will use a third-party email service
    (such as *SendGrid* from *Twilio*) to send the notification.
  prefs: []
  type: TYPE_NORMAL
- en: As a prerequisite, you have to create a free account with *SendGrid* ([https://sendgrid.com/](https://sendgrid.com/)).
    After creating an account, you will need to create at least one sender user inside
    your *SendGrid* account. Additionally, you will need to set up a secret API key
    inside the *SendGrid* account that can be used with the Cloud Function to send
    emails. Twilio SendGrid offers within the range of *100* emails per day for free,
    which is good enough for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this case study, we will write our Python code for the Cloud Function locally
    and then deploy it to the Google Cloud Functions platform using the Cloud SDK.
    We will implement this notification application step by step, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a storage bucket to attach to our Cloud Function, and we will
    upload or delete files from this bucket to simulate the events of our Cloud Function.
    We can use the following Cloud SDK command to create a new bucket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To keep the generation of these events simple, we will turn off the versioning
    on our storage bucket by using the following Cloud SDK command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the storage bucket is ready, we will create a local project directory
    and set up a virtual environment using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will install the `sendgrid` Python package using the `pip` utility,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once our third-party libraries have been installed, we will need to create
    the `requirements.txt` dependencies file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create a new Python file (`main.py`) with a `handle_storage_event`
    function within it. This function will be the entry point for our Cloud Function.
    The sample code for this entry point function is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have our Python code file (in our case, this is `main.py`) and `requirements.txt`
    files ready, we can trigger the deployment operation using the following Cloud
    SDK command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we deploy our Cloud Function, we can test it by uploading a local file
    to our storage bucket using the Cloud SDK command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: gcloud functions logs read --limit 50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For this notification app, we attached our Cloud Function to the `Finalize`
    event only. However, what if want to attach another event type as well, such as
    a `Delete` event? Well, only one Cloud Function can be attached to one trigger
    event. But hold on, a Cloud Function is a deployment entity and not the actual
    program code. This means we do not need to write or duplicate our Python code
    to handle another type of event. We can create a new Cloud Function using the
    same Python code but for the `Delete` event, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you notice this version of the `deploy` command, the only changes we made
    were with the *name* of the Cloud Function and the *type* of the trigger event.
    This `deploy` command will create a new Cloud Function and will work in parallel
    to an earlier Cloud Function but will be triggered based on a different event
    (in this case, this is `delete`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the `delete` event with our newly added Cloud Function, we can remove
    the already uploaded file (or any file) from our storage bucket using the following
    Cloud SDK command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can create more Cloud Functions using the same Python code for other storage
    events. This concludes our discussion of how to build Cloud Functions for storage
    events using the Cloud SDK. All the steps discussed using the Cloud SDK can also
    be implemented using the GCP Console.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced serverless computing and FaaS, followed by an
    analysis of the main ingredients of serverless functions. Next, we discussed the
    key benefits of serverless functions and their pitfalls. Additionally, we analyzed
    several deployment options that are available to build and deploy serverless functions,
    and these options include AWS Lambda, Azure Functions, Google Cloud Functions,
    Oracle Fn, and IBM Cloud Functions. In the final part of this chapter, we built
    a simple Google Cloud Function based on an HTTP trigger using the GCP Console.
    Then, we built a notification app based on Google storage events and a Google
    Cloud Function using the Cloud SDK. These serverless functions were deployed using
    the Google Cloud Functions platform.
  prefs: []
  type: TYPE_NORMAL
- en: The code examples included in this chapter should provide you with some experience
    of how to use both the GCP Console and the Cloud SDK to build and deploy Cloud
    Functions. This hands-on knowledge is beneficial for anyone who is looking to
    build a career in serverless computing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore how to use Python with machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How are serverless functions different from microservices?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the practical use of serverless functions in real-world examples?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are Durable functions and who offers them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One Cloud Function can be attached to multiple triggers. Is this true or false?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Serverless Computing with Google Cloud* by Richard Rose'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mastering AWS Lambda* by Yohan Wadia'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mastering Azure Serverless Computing* by Lorenzo Barbieri and Massimo Bonanni'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Google Cloud Functions Quickstart tutorials* for building and deploying Cloud
    Functions, which is available at [https://cloud.google.com/functions/docs/quickstarts](https://cloud.google.com/functions/docs/quickstarts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both are two different offerings of serverless computing. Typically, serverless
    functions are triggered by an event and are based on the *pay-as-you-use* model.
    In comparison, microservices are typically consumed through API calls and are
    not based on the *pay-as-you-use* model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Amazon Alexa uses AWS Lambda functions to provide intelligence and other skills
    for its users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Durable functions are an extension of Microsoft Azure Functions, which offers
    stateful functionality in a serverless environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: False. One Cloud Function can only be attached to a single trigger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
