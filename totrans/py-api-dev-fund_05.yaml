- en: 5\. Object Serialization with marshmallow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a schema for serialization/deserialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validate the data in a client request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform data filtering before displaying the data to the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the HTTP PATCH method to partially update data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter covers serialization and deserialization, as well as data filtering
    and validation with marshmallow.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this era of information explosion, the correctness of data is crucially important.
    We need to ensure that the data passed in by the client is in the format we expect.
    For example, we expect the `cooking time` variable to be a data type integer with
    a value of 30, but the client could pass in a string data type, with `value =
    "thirty minutes"`. They mean the same thing, and both are understandable to human
    beings but the system won't be able to interpret them. In this chapter, we will
    learn about data validation, making sure the system only takes valid data. The
    marshmallow package not only helps us to verify the client's data but also to
    verify the data that we send back. This ensures data integrity in both directions,
    which will greatly improve the quality of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on doing three essential things: first, we will
    modify the `User` class and add in the API verification. This is mainly to show
    the basic functions of marshmallow. We''ll then modify the `Recipe` class, add
    a custom authentication method, and optimize the code. Finally, a new feature
    will be added, which allows us to query all the recipes of a specific user and
    filter the recipes with different publish statuses by the visibility parameter.
    With this in mind, let''s move on to the first topic: **Serialization** versus
    **Deserialization**.'
  prefs: []
  type: TYPE_NORMAL
- en: Serialization versus Deserialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Figure 5.1: Serialization versus deserialization'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C15309_05_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.1: Serialization versus deserialization'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An object is something that lives in the application memory. We can invoke its
    method or access its attributes in our application. However, when we want to transfer
    or store an object, we will have to convert it into a storable or transferrable
    format, and that format will be a stream of bytes. It can then be stored in a
    text file, in a database, or be transmitted over the internet. The process of
    converting an object to a stream of bytes is called serialization. This stream
    of bytes persists the state of the object so that it can be recreated later. The
    recreation of the object from a stream of bytes is called deserialization.
  prefs: []
  type: TYPE_NORMAL
- en: Serialization/deserialization is an essential part of RESTful API development.
    During actual development, the data validation related to business logic will
    often be included in the serialization and deserialization implementation processes
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: marshmallow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**marshmallow** itself is an excellent package for serialization and deserialization
    in Python, as well as providing validation features. It allows developers to define
    schemas, which can be used to represent a field in various ways (required and
    validation), and automatically perform validation during deserialization. We will
    start by implementing a data validation function in this chapter. We will implement
    it using the marshmallow package to ensure that the information the user entered
    is correct. We will work with you through various exercises and activities to
    test serialization and deserialization afterward with Postman.'
  prefs: []
  type: TYPE_NORMAL
- en: A Simple Schema
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be using the `Schema` class from marshmallow to specify the fields
    for the objects that we want to serialize/deserialize. Without knowing the schema
    of the objects and how we want to serialize the fields, we can''t perform serialization
    or deserialization. In the following example, you can see we have a simple `SimpleSchema`
    class, which extends `marshmallow.Schema`, and there are two fields defined there,
    `id` and `username`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The data type of the fields are defined using the `marshmallow` fields. From
    the preceding example, the `id` field is an `username` field is a **string**.
    There are a number of different data types in marshmallow, including **Str**,
    **Int**, **Bool**, **Float**, **DateTime**, **Email**, **Nested**, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: With the schema specified, we can start doing object serialization and deserialization.
    We can serialize objects in our application and return them in the HTTP response.
    Or, the other way round, we can take in a request from users and deserialize that
    into an object so that it can be used in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Field Validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also add field-level validation during serialization/deserialization.
    Again, this can be done in the schema definition. For example, if we want to specify
    a field as mandatory, we can add in the `required=True` argument. Using the same
    `SimpleSchema` example, we can specify the `username` field as mandatory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If this `SimpleSchema` is used to deserialize the JSON request from the user
    and the `username` field is not filled in there, there will be an error message,
    `Validation errors`, and the HTTP status code will be **400 Bad Request**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now we will learn how to customize deserialization methods.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing Deserialization Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also customize the way we want to deserialize certain fields. We can
    do so by using `Method` fields in marshmallow. A `Method` field receives an optional
    `deserialize` argument, which defines how the field should be deserialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the following `SimpleSchema` example, we can define a custom method to
    deserialize the `password` field. We just need to pass in the `deserialize=''load_password''`
    argument. It will invoke the `load_password` method to deserialize the `password`
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will learn how to use the `UserSchema` design.
  prefs: []
  type: TYPE_NORMAL
- en: UserSchema Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we have learned why we need to use `Schema` and how we can define a schema,
    we will start to work on that in our `Smilecook` application. In the case of user
    registration, we will expect the user to fill in their information on a web form,
    and then send the details in JSON format to the server. Our `Smilecook` application
    will then deserialize it to be a `User` object, which can be worked on in our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will, therefore, need to define a `UserSchema` class to specify the expected
    attributes in the JSON request coming from the frontend. We will need the following
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: Use `fields.Int()` to represent an integer. In addition, `dump_only=True`
    means that this property is only available for serialization, not deserialization.
    This is because `id` is autogenerated, not passed in by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`username`: Use `fields.String()` to represent a string and apply `required=True`
    to indicate that this property is mandatory. When the client sends JSON data without
    the username, there will be a validation error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`: Use `fields.Email()` to indicate that `email` format is needed, and
    apply `required=True` to indicate that this property is mandatory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password:fields.Method()` is a `Method` field. The `Method` field here receives
    an optional `deserialize` argument, which defines how the field should be deserialized.
    We use `deserialize=''load_password''` to indicate that the `load_password(self,
    value)` method will be invoked when using `load()` deserialization. Please note
    that this `load_password(self, value)` method will only be invoked during `load()`
    deserialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created_at:fields.DateTime()` represents the time format, and `dump_only=True`
    means that this property will only be available in serialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updated_at:fields.DateTime()` represents the time format, and `dump_only=True`
    means that this property will only be available in serialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our next exercise, we will install the marshmallow package in our `Smilecook`
    project. Then, we will define the `UserSchema` and use it in `UserListResource`
    and `UserResource`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 33: Using marshmallow to Validate the User Data'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Firstly, we will perform data verification using marshmallow. We will install
    the `marshmallow` package and build `UserSchema`, and then use it in `UserListResource`
    to transmit the `User` object:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first install the marshmallow package. Please enter the following in
    `requirements.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `pip install` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the result that follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a folder under the `Smilecook` project and name it `schemas`. We will
    store all our schema files here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `user.py` file under that and enter the following code. Use a schema
    to define the basic structure of the content of our expected client request. The
    following code creates `UserSchema` to define the attributes we will receive in
    the client request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before defining `UserSchema`, we need to first import `Schema` and `fields`
    from marshmallow. All self-defined marshmallow schemas must inherit `marshmallow.Schema`.
    Then, we import `hash_password`, and we define four attributes: `id`, `username`,
    `email`, and `password` in `UserSchema`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following code in `resources/user.py`. We will first import the `UserSchema`
    class from the previous step and instantiate two `UserSchema` objects here. One
    of them is for use in public, and we can see that the email is excluded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For our `user` resource, when the authenticated user accesses its `users/<username>`
    endpoint, they can get `id`, `username`, and `email`. But if they are not authenticated
    or are accessing other people's `/users/<username>` endpoint, the email address
    will be hidden.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will then modify `UserListResource` to the following to validate the data
    in the user''s request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same `UserListResource.post`, we will proceed if there is no error.
    It will then check whether `username` and `email` exist, and if everything is
    fine, we will use `User(**data)` to create a user instance, the `**data` will
    give us keyword arguments for the `User` class, then we use `user.save()` to store
    things in the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, also in `UsersLitResource.post`, we use `user_schema.dump(user).data`
    to return the successfully registered user data. It will contain `id`, `username`,
    `created_at`, `updated_at`, and `email`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will modify `UserResource`. We will see the difference between with
    and without filtering email using `user_schema` and `user_public_schema` here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When a user sends a request to `/users/<username/`, we will get their username.
    If a user can't be found, we will get `user_schema.dump(user).data`, which contains
    all the information. Otherwise, `user_public_schema.dump(user).data` will be used,
    which excludes the email information. Finally, it returns data with the HTTP status
    code **200 OK**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we will modify `MeResource`. It will be serialized using `user_schema.dump(user).data`,
    which contains all the information of the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save `app.py` and right-click on it to run the application. Flask will then
    be started up and run on the localhost (`127.0.0.1`) at port `5000`:![Figure 5.2:
    Run the application and then run Flask on the localhost'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_05_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.2: Run the application and then run Flask on the localhost'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: So, we have finished adding marshmallow to the picture. From now onward, when
    we transfer the `User` object between the frontend and backend, it will first
    be serialized/deserialized. In the process, we can leverage the data validation
    functions provided by marshmallow to make our API endpoints even more secure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 34: Testing the User Endpoint before and after Authentication'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We implemented different user schemas in the previous exercise one for private
    viewing and one for public viewing. In this exercise, we are going to test whether
    they work as expected. We will check the data in the HTTP response and verify
    whether we get different user information before and after authentication. We
    want to hide the user's email address from the public, to protect user privacy.
  prefs: []
  type: TYPE_NORMAL
- en: We will do the whole test using Postman. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Check the `user` details before the user has logged in. We shouldn't see the
    user's email address in the result. Click on the **Collections** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **GET User** request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `http://localhost:5000/users/james` in the URL field. You can replace
    the username `James` with any username that is appropriate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click `user` details. And in the response body, we can see the user details
    for James. We can see the `username`, `created_at`, `updated_at`, and `id`, but
    not the email address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s login using Postman. Select the **POST Token** request. Click **Send**
    to log in. The result is shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.4: Log in and select the POST Token request'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_05_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.4: Log in and select the POST Token request'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: You will then see the response body for the access token and the refresh token.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Check the `user` details after the user has logged in. You should see the user's
    email address in the result. Click on the **Collections** tab. Choose to **GET
    User**. Select the **Headers** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `Authorization` in the `Bearer {token}` in the `JWT` token we got in *step
    5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **Send** to check the user details for James. The result is shown in
    the following screenshot:![Figure 5.5: Checking the details after the user has
    logged in'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_05_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.5: Checking the details after the user has logged in'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You will then see the return response. In the response body, we can see the
    user details for James. We can see all his information, including his email address.
  prefs: []
  type: TYPE_NORMAL
- en: So, by using the `exclude` parameter in the user schema, we can easily exclude
    certain sensitive fields from showing up in the HTTP response. Apart from the
    `exclude` parameter, marshmallow also has the `include` parameter, which you can
    explore more yourself if you are interested.
  prefs: []
  type: TYPE_NORMAL
- en: RecipeSchema Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, we have done the serialization/deserialization for the `User` object. Now
    we are going to design the schema for the `Recipe` object. In the case of the
    `Recipe` update, we will expect the user to fill in updated recipe details on
    a web form, and then send the details in JSON format to the server. Our `Smilecook`
    application will then deserialize it to be a `Recipe` object, which can be worked
    on in our application.
  prefs: []
  type: TYPE_NORMAL
- en: '`RecipeSchema` should inherit `marshmallow.Schema` and contains the following
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: Use `fields.Int()` to represent an integer, and apply `dump_only=True`
    to specify that this property is only available for serialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: Use `fields.String()` to represent a string and apply `required=True`
    to indicate that this attribute is required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: Use `fields.String()` to represent a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num_of_servings`: Use `fields.Int()` to represent an integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cook_time`: Use `fields.Int()` to represent an integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`directions`: Use `fields.String()` to represent a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_publish`: Use `fields.Boolean()` to represent a Boolean, and apply `dump_only=True`
    to specify that this attribute is only available for serialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`author`: This attribute is used to display the author of the recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created_at`: Use `fields.DateTime` to represent the format of the time, and
    `dump_only=True` means that this attribute is only available for serialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updated_at`: Use `fields.DateTime` to represent the format of the time, and
    `dump_only=True` means that this attribute is only available for serialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 35: Implementing RecipeSchema'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we have the `RecipeSchema` design in mind. In this exercise, we will learn
    more about marshmallow by implementing `RecipeSchema`. Not only can we just validate
    the data type of `fields`, but we can also build our own validation function.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import `schema`, `fields`, `post_dump`, `validate`, `validates`,
    and `ValidationError` and create the `recipe schema` by entering the following
    code in `schemas/recipe.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can perform additional validation for a field by passing in the `validate`
    argument. We use `validate.Length(max=100)` to limit the maximum length of this
    attribute to `100`. When it exceeds `100`, it will trigger a validation error.
    This can prevent users from passing in an extremely long string, which will create
    a burden on our database. Using the `validation` function from marshmallow, that
    can be easily prevented.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we define the `validate_num_of_servings(n)` method in `RecipeSchema`,
    which is a customized validation function. This will validate that this attribute
    has a minimum of `1` and cannot be greater than `50`. If its value doesn''t fall
    within this range, it will raise an error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the `num_of_servings` attribute in `RecipeSchema`. Use `validate=validate_num_of_servings`
    to link to our custom function, which will verify the number of servings of this
    recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There is another way for us to add a customized validation method. We can add
    the `cooktime` attribute in `RecipeSchema`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, in `RecipeSchema`, use the `@validates(''cook_time'')` decorator to define
    the validation method. When validating the `cook_time` property, it will call
    the `validate_cook_time` method to specify that the cooking time should be between
    1 minute and 300 minutes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On top of the `schemas/recipe.py` file, import `UserSchema` from marshmallow,
    because we will display the author information for the recipe together when displaying
    the recipe information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, in `RecipeSchema`, define the attribute `author`. We use `fields.Nested`
    to link this attribute to an external object, which is `UserSchema` in this case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To avoid any confusion, this attribute is named `author` in the JSON response,
    but the original attribute name is the `user`. In addition, `dump_only=True` means
    that this attribute is only available for serialization. Finally, add `only=['id',
    ' username']` to specify that we will only show the user's ID and username.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In addition, we add the `@post_dump(pass_many=True)` decorator so that further
    processing can be done when the recipe is serialized. The code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the case of returning only one recipe, it will be simply returned in a JSON
    string. But when we are returning multiple recipes, we will store the recipes
    in a list and return them using the `{''data'': data}` format in JSON. This format
    will be beneficial for us when we develop the pagination feature.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The code in `schemas/recipe.py` should now look like the following – please
    review it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once we have completed the recipe schema, we can start to use it in the related
    resources.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will then modify `resources/recipe.py` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We first import `RecipeSchema` from `schemas.recipe`,then define the `recipe_schema`
    variable and `recipe_list_schema`; they are for storing single and multiple recipes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify the `RecipeListResource` `get` method to return all the published recipes
    back to the client by using the `recipe_list_schema.dump(recipes).data` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `RecipeListResource` `post` method to use the recipe schema:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After receiving the JSON data, the data is verified by `recipe_schema.load(data=json_data)`.
    If there is an error, it will return `Recipe(**data)` will be used to create a
    `recipe` object, then specify it as the currently logged-in user's ID via `recipe.user_id
    = current_user`. The recipe will then be saved to the repository via `recipe.save()`,
    and finally, converted to JSON using `recipe_schema.dump(recipe).data` to the
    client, with a HTTP status code **201 CREATED** message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Because the rendering of our data has been done through marshmallow, we don''t
    need the `data` method in the recipe, so we can delete the `data` method in `model/recipe.py`.
    That is, delete the following code from the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we have finished the implementation. Right-click on it to run the application.
    Flask will then be started up and run on the localhost (`127.0.0.1`) at port `5000`:![Figure
    5.6: Run the application and then Flask on the localhost'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_05_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.6: Run the application and then Flask on the localhost'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: So, we have just completed the work on `RecipeSchema`, as well as modifying
    the API endpoints to transmit the object using the serialization/deserialization
    approach. In the next exercise, we will test whether our implementation works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 36: Testing the Recipe API'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To test whether the serialization/deserialization of the object works, we will
    again need to test it in Postman. This exercise is to test creating and getting
    all our recipe details using Postman.
  prefs: []
  type: TYPE_NORMAL
- en: First, log in to the account. Our previous token was only valid for 15 minutes.
    If it expires, we need to log in again via `/token` or reacquire the token using
    the **Refresh** Token. Click on the **Collections** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **POST** **Token** request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **Send** to log in. The result is shown in the following screenshot:![Figure
    5.7: Log in to the account and select the POST Token request'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_05_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.7: Log in to the account and select the POST Token request'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: You will then see the return response, **HTTP Status is 200 OK**, meaning the
    login was successful, and we will see the access token in the response body. This
    access token will be used in later steps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we will create a new recipe. Click on the **Collections** tab. Choose
    **POST RecipeList**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Authorization` in the `Bearer {token}` in the `JWT` token we got
    in our previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **Body** tab. Fill in the recipe details as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Click **Send** to create a new recipe. The result is shown in the following
    screenshot:![Figure 5.8: Creating a new recipe'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_05_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.8: Creating a new recipe'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: You will then see the return response, **HTTP Status is 201 CREATED**, meaning
    the new recipe has been created successfully. In the response body, we can see
    the recipe details. We can also see the author's details shown in a nested format.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, we will publish the recipe with `id = 4`. Click on the `http://localhost:5000/recipes/4/publish`
    in **Enter request URL**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the `Authorization` in the `Bearer {token}` in the `id = 4`. The result
    is shown in the following screenshot:![Figure 5.9: Publish the recipe with ID
    4'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_05_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.9: Publish the recipe with ID 4'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: You will then see the return response, HTTP Status is **204 NO CONTENT**, meaning
    it is published successfully. You will see no content in the body.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we will get all the recipes back. Select the **GET RecipeList** request.
    Click **Send** to get all the recipes back. The result is shown in the following
    screenshot:![Figure 5.10: Getting all the recipes back by selecting the GET RecipeList
    request'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_05_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.10: Getting all the recipes back by selecting the GET RecipeList request'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You will then see the return response, HTTP Status is 200 **OK**, meaning we
    have successfully retrieved all the recipe details. In the response body, we can
    see that there is a list of data, which contains all the published recipes.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have successfully implemented and tested the serialization (creating
    the recipe) and deserialization (retrieving the recipe) on the recipe-related
    API endpoints. We are making good progress here!
  prefs: []
  type: TYPE_NORMAL
- en: The PATCH Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have been using the `PUT` HTTP method all along for data updates. However,
    the actual usage of the `PUT` method is to `PUT /items/1` means to replace everything
    in `/items/1`. If this item already exists, it will be replaced. Otherwise, it
    will create a new item. `PUT` must contain all attribute data for `items/1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This doesn''t seem to work very well in all cases. If you just want to update
    only one of the attributes of `items/1`, you need to retransmit all the attributes
    of `items/1` to the server, which is not efficient at all. So, there is a new
    HTTP method: `PATCH` method was invented to do a partial update. With this method,
    we need to pass in only the attributes that need to be modified to the server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 37: Using the PATCH Method to Update the Recipe'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will change the recipe update method from `PUT` to `PATCH`.
    We will also use the serialization/deserialization approach to transmit the recipes.
    Finally, we will test our changes in Postman, to make sure things work as expected.
    The aim of this exercise is to reduce the bandwidth and server processing resources
    when we update the recipe data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `patch` method in `RecipeListResource`. We will first use `request.get_json()`
    to get the JSON recipe details sent by the client, and then use `recipe_schema.load(data=json_data,
    partial=(''name'',))` to validate the data format. We are using `partial=(''name'',)`
    because the original name is a required field in the schema. When the client only
    wants to update a single attribute, using `partial` allows us to specify that
    the `Name` attribute is optional, so no error will occur even though we are not
    passing in this attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, in the same `patch` method, we will check whether there is an error message.
    If any, it will return the **HTTP Status Code 400 Bad Request** error message.
    If the validation passes, then check whether the user has permission to update
    this recipe. If not, **HTTP status code Forbidden 403** will be returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We continue to work on the same `patch` method. `recipe.name = data.get(''name'')
    or recipe.name` means it will try to get the name of the key value of the data.
    If this value exists, it will be used. Otherwise, `recipe.name` will stay the
    same. This is basically how we do the update:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same `patch` method, we use the `save` method to save everything to
    the database and return the recipe data in JSON format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we have the new `patch` method ready. Right-click on it to run the application.
    Flask will then be started up and run on the localhost (`127.0.0.1`) at port `5000`:![Figure
    5.11: Run the application and then run Flask on the localhost'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_05_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.11: Run the application and then run Flask on the localhost'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Next, we are going to update the recipe with `id = 4`. We will update only
    two fields: `num_of_servings,` and `cook_time`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the **Collections** tab. Choose the **PUT Recipe** request. Change
    the **HTTP** method from **PUT** to **PATCH**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Authorization` in the `Bearer {token}` in the `JWT` token we got
    in our previous exercise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **Body** tab. Type the following in the **Body** field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Click **Send** to update the recipe. The result is shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.12: Updating the recipe'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C15309_05_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.12: Updating the recipe'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You will then see the return response `num_of_servings` and `cook_time` is updated.
    We can also see the `updated_at` timestamp has been automatically updated as well.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for Authors and Unpublished Recipes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On the `Smilecook` platform, there will be many different foodies from around
    the world (here, we call them authors) to share their recipes. Among these outstanding
    authors, we will definitely have a favorite author, and we will definitely want
    to learn all of their recipes. Therefore, we have added a new endpoint (or function),
    which is to list the recipes of a specific author. This endpoint not only lists
    all the recipes published by a particular gourmet but can also allow the author
    to search all of their own published/unpublished recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Using the webargs Package to Parse the Request Arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The request arguments, also known as the query string, are the arguments that
    we can pass in through the URL. For example, in the URL `http://localhost/testing?abc=123`,
    `abc=123` is the request argument.
  prefs: []
  type: TYPE_NORMAL
- en: '`GET http://localhost:5000/user/{username}/recipes`, to get all the published
    recipes from a particular author. For this endpoint, we will pass in the visibility
    request argument. The `visibility` request argument can have a value of `public`,
    `private`, or `all`. The default value is `public`. If it is `private` or `all`,
    the user needs to be authenticated first.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to get only the unpublished recipes, you can add the request argument
    `visibility=private`. So, the URL will look like this: `http://localhost:5000/user/{username}/recipes?visibility=private`.
    The `webargs` package provides functions to parse this `visibility=private` argument
    in the URL, and then our `Smilecook` application will know this request is asking
    for private information in the recipe. Our `Smilecook` application will then determine
    whether the authenticated user is the author. If they are, it will return all
    the unpublished recipes. Otherwise, there is no permission for the user to see
    the unpublished recipes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 38: Implementing Access Control on Recipes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to implement access control on recipes. So,
    only authenticated users will be able to see all of their own recipes, including
    unpublished ones. The user will pass in the `visibility` mode by using the `request`
    argument. We use `webargs` to parse the visibility mode and return published,
    unpublished, or all recipes accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `get_all_by_user` method in the `Recipe` class in `models/recipe.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method needs to take in `user_id` and `visibility`. If the `visibility`
    is not defined, the default will be `public`. If the `visibility` is `public`,
    it will get all the recipes by `user_id` and `is_publish=True`. If the visibility
    is `private`, it will search for the recipe with `is_publish=False`. If the visibility
    is not `public` or `private`, it will get all the recipes of this user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will install the `webargs` package, which is a package for interpreting
    and verifying HTTP arguments (for example, `visibility`). Please add the following
    package in `requirements.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the package using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see a result like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the necessary modules, functions, and classes in `resources/user.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, import `webargs.fields` and `webargs.flaskparser.use_kwargs`, then we
    will need to use the recipe data, so we also need to import the recipe model and
    schema.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we will declare the `recipe_list_schema` variable. Use `RecipeSchema`
    with the `many=True` parameter. This is to show that we will have multiple recipes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will then create the `UserRecipeListResource` class. This resource is mainly
    for getting the recipes under a specific user. Please refer to the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, define `@jwt_optional` to mean that this endpoint can be accessed without
    a user being logged in. Then, use `@use_kwargs({''visibility'': fields.Str(missing=''public'')})`
    to specify that we expect to receive the parameters of `visibility` here. If the
    parameter is absent, the default will be public. The `visibility` parameter will
    then be passed into `def get(self, username, visibility)`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will implement access control in `UserRecipeListResource.get`. If the username
    (the author of the recipe) is the currently authenticated user, then they can
    see all the recipes, including the private ones. Otherwise, they can only see
    the published recipes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The user is then obtained by `User.get_by_username(username=username)`. If the
    user cannot be found, will return a HTTP status code `get_jwt_identity()` and
    save it to the `current_user` variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Based on the user and their permission, we will display a different set of recipes.
    After the recipe is obtained, `recipe_list_schema.dump(recipes).data` is used
    to convert the recipes into JSON format and return to the client with HTTP Status
    Code is **200 OK**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, import `UserRecipeListResource` in `app.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add the following endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we have finished the implementation. Right-click on it to run the application.
    Flask will then be started up and run on the localhost (`127.0.0.1`) at port `5000`:![Figure
    5.13: Run Flask on the localhost'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_05_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.13: Run Flask on the localhost'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now we have learned how to use `webargs` to parse `request` arguments and have
    applied that to our `Smilecook` application. Next, as usual, we want to test and
    make sure that it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 39: Retrieving Recipes from a Specific Author'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This exercise is to test what we implemented in our last exercise. We will
    make sure the API is parsing the visibility mode that the user passes in and returns
    different sets of recipes accordingly. We will use a specific user (James) for
    testing. We will see that before and after authentication, the user will be able
    to see different sets of recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: We will get all the published recipes for a particular user before they have
    logged in. First, click on the **Collections** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new request under the `UserRecipeList` and save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the newly created `http://localhost:5000/users/james/recipes` in the
    **URL** field (change the username if necessary).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **Send** to check all the published recipes under this particular user
    (James here). The result is shown in the following screenshot:![Figure 5.14: Get
    all the published recipes for a user before they have logged in'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_05_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.14: Get all the published recipes for a user before they have logged
    in'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: You will then see the return response. The HTTP status code **200 OK** here
    indicates that the request has succeeded and, in the body, we can see one published
    recipe under this author.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Similar to the previous step, we will see whether we can get all the recipes
    under a particular user before the user has logged in – it shouldn''t be allowed.
    Select the `visibility`. Set `all`. Click **Send** to check all the recipes under
    this particular user. The result is shown in the following screenshot:![Figure
    5.15: Check all the recipes under a particular user'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_05_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.15: Check all the recipes under a particular user'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: You will then see the return response. The HTTP status code **200 OK** here
    indicates that the request has succeeded, and in the body again, though we are
    asking for all recipes, we can only see one published recipe under this author
    because the user hasn't logged in.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Log in and click on the **Collections** tab. Select the **POST** **Token**
    request. Click **Send** to check all the recipes under this particular user. The
    result is shown in the following screenshot:![Figure 5.16: Select the POST Token
    request and send the request'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_05_16.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.16: Select the POST Token request and send the request'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: You will then see the return response. The **HTTP status code 200 OK** here
    indicates that the request has succeeded, and in the body, we can get the access
    token and refresh token that we will use in the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Select the `Authorization` in the `Bearer {token}` in the **Value** field,
    where the token is the **JWT** token we got in our previous step. Click **Send**
    to query. The result is shown in the following screenshot:![Figure 5.17: Use the
    JWT token and send to query'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_05_17.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.17: Use the JWT token and send to query'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You will then see the return response. The **HTTP status code 200 OK** here
    indicates that the request has succeeded. In the response body, we can get all
    the recipes under this user, including the unpublished ones.
  prefs: []
  type: TYPE_NORMAL
- en: This testing exercise concluded what we have learned about the `webargs` package,
    as well as testing the new access control functions we added for viewing recipes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 8: Serializing the recipe Object Using marshmallow'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this activity, we want you to work on the serialization of the `RecipeResource.get`
    method. We did serialization for `User` and `RecipeList` in previous exercises.
    Now, it is your turn to work on this last one.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, `RecipeResource.get` is returning the `recipe` object using `recipe.data()`.
    We want you to replace that by serializing the `recipe` object using marshmallow.
    The `recipe` object should be converted into JSON format and return to the frontend
    client-side. To do that, you will modify `recipe_schema` in `resources/recipe.py`.
    You are also required to test your implementation using Postman at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps to perform:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify the recipe schema, to include all attributes except for `email`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `get` method in `RecipeResource` to serialize the `recipe` object
    into JSON format using the recipe schema.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the application so that Flask will start and run on the localhost.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the implementation by getting one specific published recipe in Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for the activity can be found on page 312.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After this activity, you should have a good understanding of how to use schema
    to serialize objects. We have the flexibility to specify the attributes that need
    to be serialized, and how they are going to be serialized. Attributes that linked
    to another object can be serialized as well. As you can see from this activity,
    the author's information is included in this recipe response.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we have learned a lot of things. The data verification of an
    API through marshmallow is very important. This function should also be constantly
    updated in the production environment to ensure that the information we receive
    is correct.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we started with the verification of registered members and
    then talked about basic verification methods, such as setting mandatory fields,
    performing data type validation, and so on. Apart from data validation, marshmallow
    can be used for data filtering as well. We can use the `exclude` parameter to
    display the user email field. Based on what we learned, we then developed customized
    verifications for our application, such as verifying the length of the recipe
    creation time.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, we added the functionality to get all the recipes
    written by our favorite author. Then, we searched for different publish statuses
    through the `visibility` parameter and applied access control accordingly.
  prefs: []
  type: TYPE_NORMAL
