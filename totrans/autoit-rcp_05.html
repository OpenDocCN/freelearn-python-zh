<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Fun with E-mails</h1></div></div></div><p>E-mail communication has become a primary mode of information exchange over last couple of decades. You work with e-mails on a daily basis and for multiple  reasons. But did it ever strike that you could manipulate your inbox with Python?</p><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sending e-mail messages</li><li class="listitem" style="list-style-type: disc">E-mail encryption</li><li class="listitem" style="list-style-type: disc">Beautifying e-mail messages with MIME messages</li><li class="listitem" style="list-style-type: disc">E-mail messages with attachments</li><li class="listitem" style="list-style-type: disc">Connecting to your inbox</li><li class="listitem" style="list-style-type: disc">Fetching and reading e-mail messages</li><li class="listitem" style="list-style-type: disc">Marking e-mail messages</li><li class="listitem" style="list-style-type: disc">Clearing up e-mail messages from your inbox</li><li class="listitem" style="list-style-type: disc">Automating customer support flows with e-mail responses</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Introduction</h1></div></div></div><p>Hello, folks! Hope you're having a great day. In this chapter, we will talk about e-mails and the numerous operations we can achieve with e-mails using Python. We will also understand ways of automating business processes with e-mails with the help of real world business use case.</p><p>So, what are we waiting for? Let's get started and understand a bit about the history of e-mails and its technical implementation.</p><p>E-mails don't need any introduction actually; of course, they're a method of exchanging digital messages between computer users. E-mails operate on computer networks available over Internet for information exchange. You can log in to your favorite e-mail client and start working on your messages stored in the e-mail servers. The most widely used web client is Gmail.</p><p>E-mails have a very interesting history. In the past, e-mails needed the sender and the recipient to be online for the communication to succeed. That didn't make much sense, right? Gradually with time, e-mail servers became intelligent and started to work on a store-and-forward philosophy. Today, e-mail messages are stored asynchronously on the servers so that recipients can view them later at their convenience. E-mail servers are thus able to provide facilities such as accepting, forwarding, and marking messages.</p><p>E-mail messages started with ASCII-only characters, which were later extended by <strong>Multipurpose Internet Mail Extensions</strong> (<strong>MIME</strong>) for rich text and attachments. From a protocols standpoint, e-mails initially worked with the <strong>File Transfer Protocol</strong> (<strong>FTP</strong>) to send messages across computers, but as you might be aware, <strong>Simple Mail Transfer Protocol</strong> (<strong>SMTP</strong>) is the most widely used protocol for working with e-mails.</p><div><div><h3 class="title"><a id="note14"/>Note</h3><p>Please note that setting up of e-mail servers is not covered in this book. If you look on the Internet, you'll find many more resources that can help you get started. The scope of this chapter is to make you aware of things you can do with e-mail using Python programs. We take examples that apply to the Gmail web client so that you can try out code examples quickly and get to appreciate the power of using Python to automate e-mail tasks without having to set up your own e-mail server. While we use Gmail as an example, these snippets will work with any other e-mail servers that support SMTP for sending e-mails and IMAP for retrieving e-mails.</p></div></div><p>In this chapter, we'll learn how to work with e-mails using Python. We'll also use multiple Python modules, listed below, to perform various operations on e-mail messages:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">smtplib</code> (<a class="ulink" href="https://docs.python.org/2/library/smtplib.html">https://docs.python.org/2/library/smtplib.html</a>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">email</code> (<a class="ulink" href="https://docs.python.org/2/library/email.html">https://docs.python.org/2/library/email.html</a>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">imaplib</code> (<a class="ulink" href="https://docs.python.org/2/library/imaplib.html">https://docs.python.org/2/library/imaplib.html</a>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">gmail</code> (<a class="ulink" href="https://github.com/charlierguo/gmail">https://github.com/charlierguo/gmail</a>)</li></ul></div><div><div><h3 class="title"><a id="note15"/>Note</h3><p>When it comes to working with e-mails using Python , what you need is a module that helps you construct messages, a module that can send e-mails, and a module that helps retrieve and update messages.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Sending e-mail messages</h1></div></div></div><p>The first and foremost thing that you may want to achieve with an e-mail client is to send a message to your friend's or colleague's e-mail address. Let's go ahead and see how we can achieve this in Python.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec123"/>Getting ready</h2></div></div></div><p>In order to send e-mail messages, we will need to have Python's <code class="literal">smtplib</code> module. This library, as the name suggests, uses the SMTP protocol to send e-mail messages. We can install <code class="literal">smtplib</code> with our favorite <code class="literal">pip</code> tool with the following command. But Python's default installation should also have this module already:</p><pre class="programlisting">
<strong>pip install smtplib</strong>
</pre></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec124"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">On your computer, open your favorite editor and add the following code snippet. Let this be known as <code class="literal">config.py</code>. The configuration file has login details, such as e-mail address, password, and the e-mail address to which the e-mail needs to be sent:<pre class="programlisting">        fromaddr = "abc@gmail.com"&#13;
        password = "xyz@123"&#13;
        toaddr = "abc@gmail.com"</pre></li><li class="listitem">Now, let's write the code to send an e-mail using this configuration file:<pre class="programlisting">        import smtplib&#13;
        import config server = smtplib.SMTP('smtp.gmail.com', 587)&#13;
        server.starttls()&#13;
        server.login(config.fromaddr, config.password)&#13;
        msg = "Some nice msg"&#13;
        server.sendmail(config.fromaddr, config.toaddr, msg) &#13;
        server.quit()</pre></li><li class="listitem">Store the preceding code as <code class="literal">basic_email.py</code>, and run the code using the following command:<pre class="programlisting">
<strong>        python basic_email.py &#13;
</strong>
</pre></li><li class="listitem">If you run the preceding code, you'll see exceptions with <code class="literal">SMTPAuthenticationError</code>, and your program will fail with exit code  <code class="literal">1</code>. This is how your exception will look like:<p>
</p><div><img alt="How to do it..." src="img/image_06_001.jpg"/></div><p>
</p></li><li class="listitem">Okay, that's bad, but on the contrary, it's good as well! Exception suggests that the login to the server was fine, but Gmail blocked you from sending the message. Now, if you log in to Gmail, you should see an e-mail suggesting there was a signup detected from a less secure app. Really?! Yes, that's because we tried to access the Gmail account from our Python program. This is why we get an e-mail from Google suggesting a possible security breach in case there was a malicious activity on our account. The e-mail message from Google can be viewed in the following screenshot:<p>
</p><div><img alt="How to do it..." src="img/image_06_002.jpg"/></div><p>
</p></li><li class="listitem">But obviously, this was a legitimate attempt to use the Gmail account, so let's confirm that to Google. Open the e-mail message from Google and click on <strong>ALLOW ACCESS.</strong> You'll be taken to the <strong>Less secure apps</strong> page where you can turn this setting on, as shown in the following screenshot:<p>
</p><div><img alt="How to do it..." src="img/image_06_003.jpg"/></div><p>
</p></li><li class="listitem">Now, log out of the Gmail web client and log in again to let the settings take effect on your account. If this went through fine, you will receive an e-mail from Google that the <strong>Access for less secure apps is turned on. </strong>The confirmation e-mail from Google will look similar to this screenshot:<p>
</p><div><img alt="How to do it..." src="img/image_06_004.jpg"/></div><p>
</p><p>Now, if you run the Python program again, it should run successfully and you will receive an e-mail in your inbox:</p><p>
</p><div><img alt="How to do it..." src="img/image_06_005.jpg"/></div><p>
</p></li><li class="listitem">Cool! Notice, the message contents are the same as we added in our code snippet. Also, since the <em>from</em> and <em>to</em> addresses were the same, the e-mail came from you, but it doesn't have any subject, which is not great. We will do something about this in the next recipe.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec125"/>How it works...</h2></div></div></div><p>As stated earlier, SMTP is used to send e-mail messages. We use Python module, <code class="literal">smtplib</code>, for this purpose.</p><p>If you look at the preceding code snippet, we use the constructor, <code class="literal">smtplib.SMTP()</code> to configure Gmail's SMTP settings and get access to the e-mail server. Gmail's SMTP server runs on <code class="literal">smtp.gmail.com</code> and on port 587.</p><p>Once we have the server object, <code class="literal">server</code>, we use this to log in to Gmail with our username and password. Note that we have another line in the preceding code: <code class="literal">server.starttls()</code>; we will come to this later in this chapter.</p><p>We have created a test message and stored it in the variable <code class="literal">msg</code>, which is then sent using the <code class="literal">sendmail</code> method <code class="literal">('fromaddr', 'toddr', msg)</code>.</p><p>Finally, we close the connection to the e-mail server with <code class="literal">server.quit()</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec126"/>There's more...</h2></div></div></div><p>We looked at how to sign in to Gmail and send a basic e-mail using the SMTP protocol and Python's <code class="literal">smptlib</code> library. While this recipe gets us started, there are more details that we'll delve into in the next recipe. Let's look at them.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec46"/>E-mail encryption</h1></div></div></div><p>E-mail is prone to disclosure of information. Most e-mails are currently transmitted in clear text format. E-mail encryption involves encrypting or disguising content of the e-mail so that the content is read by the intended recipients. Always remember that security is of prime importance when dealing with e-mails. Let's see how we can encrypt e-mails with Python.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec127"/>Getting ready</h2></div></div></div><p>We looked at sending a basic e-mail in the previous recipe, but what's the <code class="literal">starttls()</code> method? How does e-mail encryption work? We will get answers to these questions in this section.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec128"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Let's start by opening our favorite editor and typing in the following code snippet:<pre class="programlisting">        import smtplib&#13;
        server = smtplib.SMTP('smtp.gmail.com', 587)&#13;
        try:&#13;
            server.set_debuglevel(True)&#13;
            print "Sending ehlo"&#13;
            server.ehlo()&#13;
            if server.has_extn('STARTTLS'):&#13;
               print "Starting TLS Session"&#13;
               server.starttls()&#13;
               print "Sending ehlo again"&#13;
               server.ehlo()&#13;
        finally:&#13;
            server.quit()</pre></li><li class="listitem">Now, let's run the Python code and see what it prints. We have outputs in three different segments. The first one is when we send an <code class="literal">ehlo()</code> message to our e-mail server:<p>
</p><div><img alt="How to do it..." src="img/image_06_006.jpg"/></div><p>
</p></li><li class="listitem">The second one is when we call <code class="literal">starttls()</code> method on the server object. Check out the following screenshot:<p>
</p><div><img alt="How to do it..." src="img/image_06_007.jpg"/></div><p>
</p></li><li class="listitem">The third one is when we connect to the e-mail server with <code class="literal">ehlo()</code> again:<p>
</p><div><img alt="How to do it..." src="img/image_06_008.jpg"/></div><p>
</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec129"/>How it works...</h2></div></div></div><p>Let's start with the basics. E-mail encryption means protecting e-mail messages from being read by someone other than the intended parties. E-mails are typically sent in clear text and can be sniffed by third parties. To avoid this, we encrypt e-mails at the protocol layer; this may include authentication as well.</p><p>SMTP servers typically send e-mails on port 25 using SSL/TLS protocols. However, with the advent of STARTTLS (layer on top of SMTP) and the usage of port 587 for message submissions, e-mail clients like Gmail use STARTTLS and port 587 for sending e-mails. Gmail also has authentication implemented; remember that we used <code class="literal">server.login (username, password)</code> to login to the Gmail server.</p><p>For STARTTLS to be used across the server and client, the client needs to first know if the server supports this protocol. When we issue <code class="literal">server.ehlo()</code>, the program sends an <code class="literal">EHLO</code> message to the SMTP server to establish communication. The server responds with the message and allowed extensions, as observed in the first screenshot.</p><p>Now, from the code, we check whether the server supports the <code class="literal">STARTTLS</code> extension with <code class="literal">server.has_extn('STARTTLS')</code>. As we saw in the first screenshot, the SMTP server responded with the <code class="literal">STARTTLS</code> extension; this confirms that gmail supports the <code class="literal">STARTTLS</code> protocol layer, which is awesome.</p><p>Now, we communicate with the server using <code class="literal">server.starttls()</code>. The server responds to this by sending a message, <code class="literal">Ready to start TLS</code>. This way, we have encrypted our session. If you now look at the third screenshot, when we send <code class="literal">server.ehlo()</code>, we re-identify ourselves with the server over the TLS session. It also suggests that the server implements an authentication extension.</p><p>Finally, we quit our SMTP session using <code class="literal">server.quit()</code> and the server responds with <code class="literal">closing connection</code>, as shown in the third screenshot.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec130"/>There's more...</h2></div></div></div><p>Well, that was pretty detailed. Take a few moments to understand it. It's actually interesting what goes on behind the sending of a simple e-mail message. But don't worry about it too much; let's start the fun and get into many more examples.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Beautifying e-mail messages with MIME</h1></div></div></div><p>In the first few recipes, we sent e-mail messages in a simple plain old text format. The MIME Internet standard helps us construct messages with non-ASCII characters, multipart messages and images. It also helps with attachments and many other tasks. This way, we can construct enriched e-mail messages. Let's look at how the MIME format is used in this recipe.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec131"/>Getting ready</h2></div></div></div><p>For this recipe, we will use the same module, <code class="literal">smtplib</code>, to send e-mail messages. We will also introduce another module <code class="literal">email</code>, which will help us construct better e-mail messages with the MIME format. The <code class="literal">email</code> module comes in with Python installation; hence, we don't need any new modules or installations to be carried out. In this section, we will look at how to use the MIME attributes to send better looking e-mails.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec132"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Let's start by importing all of the modules we need:<pre class="programlisting">        import smtplib&#13;
        from email.mime.multipart import MIMEMultipart&#13;
        from email.mime.text import MIMEText&#13;
        import config&#13;
        import email.utils</pre></li><li class="listitem">Now, let's construct our e-mail message using the MIME module. The following code creates the message:<pre class="programlisting">        fromaddr = config.fromaddr&#13;
        toaddr = config.toaddr&#13;
        msg = MIMEMultipart()&#13;
        msg['Subject'] = "Hello from the Author of Automate It!"&#13;
        msg['To'] = email.utils.formataddr(('Recipient', toaddr))&#13;
        msg['From'] = email.utils.formataddr(('Author',&#13;
        fromaddr))&#13;
        body = "What a wonderful world!"&#13;
        msgBody = MIMEText(body, 'plain')&#13;
        msg.attach(msgBody)</pre></li><li class="listitem">So, now we have the details of whom to send the e-mail message to. We have also constructed the e-mail message in the MIME format. What are we waiting for? Let's send it using the following code:<pre class="programlisting">        server = smtplib.SMTP('smtp.gmail.com', 587)&#13;
        server.starttls()&#13;
        server.login(fromaddr, config.password)&#13;
        text = msg.as_string()&#13;
        print "Text is:", text&#13;
        server.sendmail(fromaddr, toaddr, text)&#13;
        server.quit()</pre><p>The received e-mail looks as follows:</p><p>
</p><div><img alt="How to do it..." src="img/B05370_07_09.jpg"/></div><p>
</p></li></ol></div><p>Awesome! That's great, but hey... how did it work?</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec133"/>How it works...</h2></div></div></div><p>In the preceding example, we imported the configuration file from where we got <code class="literal">fromaddress</code> and <code class="literal">password</code> to log in to the SMTP server and <code class="literal">toaddress</code> to whom the e-mail message will be sent.</p><p>Now, before sending the message, we construct a new MIME message object. We do that with <code class="literal">MIMEMultipart()</code> class from the <code class="literal">email.mime.multipart</code> module of Python. For those who are not aware, a MIME multipart message means both HTML and text content in a single e-mail. So, in this code, we create a new multipart MIME message and then add the text content to it.</p><p>The text content, which is the body of the e-mail, is created with the <code class="literal">MIMEText()</code> constructor from the <code class="literal">email.mime.text</code> module and is then attached to the multipart message with the <code class="literal">attach()</code> method.</p><p>The constructed MIME message is seen in the following screenshot, where the content-type is multipart and the MIME Version is 1.0, the <strong>Subject</strong>, <strong>To</strong>, and <strong>From </strong>details are as expected, and the e-mail body contains the expected text:</p><p>
</p><div><img alt="How it works..." src="img/B05370_07_10.jpg"/></div><p>
</p><p>Once we have the message and the recipient details, we send the e-mail as usual, using the <code class="literal">SMTP.sendmail()</code> method.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec48"/>E-mail messages with attachments</h1></div></div></div><p>One of the most used and simple use cases with e-mail is the ability to add attachments to your e-mail messages. In this section, we will learn how to add attachments to our e-mails in Python.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec134"/>Getting ready</h2></div></div></div><p>We use the same <code class="literal">smtplib</code> and <code class="literal">email</code> modules for this example. So, don't bother about the modules to be installed. Let's get on with the recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec135"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Let's begin by quickly creating a small text file. We will call it <code class="literal">attach.txt</code>, and its contents are shown in the following screenshot:<p>
</p><div><img alt="How to do it..." src="img/image_06_011.jpg"/></div><p>
</p></li><li class="listitem">Let's look at the code that will help add an attachment to our e-mail:<pre class="programlisting">        import smtplib&#13;
        from email.mime.multipart import MIMEMultipart&#13;
        from email.mime.text import MIMEText&#13;
        from email.mime.base import MIMEBase&#13;
        from email import encoders&#13;
        import config&#13;
&#13;
        fromaddr = config.fromaddr&#13;
        toaddr = config.toaddr&#13;
 &#13;
        msg = MIMEMultipart()&#13;
&#13;
        msg['From'] = fromaddr&#13;
        msg['To'] = toaddr&#13;
        msg['Subject'] = "Email with an attachment"&#13;
&#13;
        body = "Click to open the attachment"&#13;
&#13;
        msg.attach(MIMEText(body, 'plain'))&#13;
&#13;
        filename = "attach.txt"&#13;
        attachment = open(filename, "rb")&#13;
&#13;
        part = MIMEBase('application', 'octet-stream') &#13;
        part.set_payload((attachment).read())&#13;
        encoders.encode_base64(part)&#13;
        part.add_header('Content-Disposition', "attachment;&#13;
                        filename= %s" % filename)&#13;
        msg.attach(part)&#13;
        server = smtplib.SMTP('smtp.gmail.com', 587)&#13;
        server.starttls()&#13;
        server.login(fromaddr, config.password)&#13;
        text = msg.as_string()&#13;
        server.sendmail(fromaddr, toaddr, text)&#13;
        server.quit()</pre></li><li class="listitem">When you run the preceding code, you will receive the e-mail in your inbox, which will look similar to the following screenshot:<p>
</p><div><img alt="How to do it..." src="img/image_06_012.jpg"/></div><p>
</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec136"/>How it works...</h2></div></div></div><p>We're already familiar with creating MIME message objects. So, in this code, we create a multipart message object, <code class="literal">msg</code>. We then add a text message to it with <code class="literal">msg.attach()</code>. The text body says <code class="literal">Click to open the attachment</code>.</p><p>In this recipe, we use another new class, <code class="literal">MIMEBase</code> from the <code class="literal">email</code> module that will be used to attach the text file. Remember, we already have the <code class="literal">attach.txt</code> file created, we open the file using Python's <code class="literal">open()</code> method and get the file handle <code class="literal">attachment</code>. We then create a <code class="literal">MIMEBase</code> object, <code class="literal">part</code>, and assign the contents of the file as payload to this object. The contents of the file are obtained with <code class="literal">attachment.read()</code> and the payload is set with the <code class="literal">set_payload()</code> method.</p><p>To attach the file, the <code class="literal">MIMEBase</code> object has to be encoded to base64 and the <code class="literal">Content-Disposition</code> header needs to be added to the <code class="literal">part</code> object. Now that we have the <code class="literal">part</code> object, it can be attached to the multipart object, <code class="literal">msg</code>, with the <code class="literal">attach()</code> method, as we did for the body text.</p><p>Cool, so we have the complete MIME message and the details of whom to send the message to. So, we go ahead and send the e-mail with the attachment. Just what we intended to achieve.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Connecting to your inbox</h1></div></div></div><p>Throughout the chapter, we have been talking about sending e-mails with Python. However, at some point, you might also want to scan through your inbox and read the incoming messages. So, how do you do that? Let's understand and learn it in this recipe.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec137"/>Getting ready</h2></div></div></div><p>In this recipe, we use a new Python module that will help us retrieve messages from the inbox. We use the Python module, <code class="literal">imaplib</code>, which is available in the default Python installation. Cool, so let's get started.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec138"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">We start by using the configuration file, which we have already created to store our e-mail and password, to log in to the server. We then add our code to create a handle or an object to work with our inbox. This is how the code looks:<pre class="programlisting">         import config, imaplib&#13;
         M = imaplib.IMAP4_SSL("imap.gmail.com", 993)&#13;
         M.login(config.fromaddr, config.password)&#13;
         print "Inbox:", M&#13;
         M.logout()</pre><p>If you run the preceding piece of code, you will get the following output:</p><p>
</p><div><img alt="How to do it..." src="img/image_06_013.jpg"/></div><p>
</p></li><li class="listitem">By default, when we login to Gmail, default inbox gets selected, but if we have created other inboxes as well, we can get the list by adding a small line of code. Now, from all the labels, if we specifically want to select <code class="literal">Inbox</code>, even that can be achieved. Look at the following code example:<pre class="programlisting">        import config, imaplib&#13;
        M = imaplib.IMAP4_SSL("imap.gmail.com", 993)&#13;
        M.login(config.fromaddr, config.password)&#13;
        print M.list()&#13;
        M.select('INBOX')&#13;
        print "Inbox:", M&#13;
        M.logout()</pre><p>The output of the preceding code snippet is shown in the following screenshot. Though I have many labels created, I have taken a screenshot with fewer labels:</p><p>
</p><div><img alt="How to do it..." src="img/image_06_014.jpg"/></div><p>
</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec139"/>How it works...</h2></div></div></div><p>As discussed in the beginning of this chapter, we have three main protocols to work with e-mails. We used SMTP heavily for sending e-mails, but while reading e-mails, we can use either POP or IMAP to retrieve messages from the e-mail server. We will go through the code step by step.</p><p>Python's <code class="literal">imaplib</code> library helps us connect to our mailbox using the <strong>Internet Message Access Protocol</strong> (<strong>IMAP</strong>). The Gmail server is configured to IMAP, with the server running on <code class="literal">imap.gmail.com</code> and on port '993'.</p><p>In our code example, we create an object of type <code class="literal">imaplib</code> with the constructor <code class="literal">IMAP4_SSL("imap.gmail.com", 993)</code>; we call this object <code class="literal">M</code>.</p><p>Regarding the encryption, we use <code class="literal">IMAP4_SSL</code> for connecting to the server because it uses encrypted communications over SSL sockets. We avoid the usage of <code class="literal">IMAP4</code> class, which internally uses clear text sockets.</p><p>Now, with object <code class="literal">M</code>, we can log in to Gmail with our username and password and get connected to our inbox.</p><p>When we call the <code class="literal">list()</code> method on object <code class="literal">M</code>, it returns all the labels you have already created. Now, in my case, I have created the <code class="literal">ACM</code> label (for my work with ACM), and hence it shows up in my list of labels.</p><p>If you look at the code example, we can explicitly connect to the <code class="literal">INBOX</code> using the <code class="literal">select()</code> method. Once connected to the inbox, we can start fetching the e-mail messages from the inbox.</p><p>Finally, we close our connection with the inbox using the <code class="literal">M.logout()</code> method. Cool! That was nice and easy.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec140"/>There's more...</h2></div></div></div><p>So, we learnt how to connect to our inbox in this recipe, but we may also want to read the messages, mark them, and perform interesting actions on them. Let's look at how to perform operations on the messages in the next recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec50"/>Fetching and reading e-mail messages</h1></div></div></div><p>Retrieving e-mail messages with <code class="literal">imaplib</code> is also easy to achieve. In this recipe, we will learn how to do that with Python code. In this recipe, we will search for e-mails with a particular subject line and fetch the latest message from the inbox that matches a predefined criteria.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec141"/>Getting ready</h2></div></div></div><p>We continue to use the <code class="literal">imaplib</code> module for reading e-mail messages, so no new installations are required for this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec142"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">We utilize the configuration file and import <code class="literal">fromaddress</code>, <code class="literal">password</code>, and <code class="literal">toaddress</code> to log in to the server. Once we're logged in, we select the default inbox, fetch e-mail messages, and read them. Let's look at the complete code:<pre class="programlisting">        import config, imaplib&#13;
        M = imaplib.IMAP4_SSL("imap.gmail.com", 993) &#13;
        M.login(config.fromaddr, config.password)&#13;
        M.select("INBOX")&#13;
        typ, data = M.search(None, 'SUBJECT', &#13;
                             "Email with an attachment")&#13;
        typs, msg = M.fetch(data[0].split()[-1], '(RFC822)')&#13;
        print "Message is ", msg[0][1]&#13;
        M.close()&#13;
        M.logout()</pre></li><li class="listitem">Store the preceding file as <code class="literal">inbox_search.py</code> and run the code using the following command:<pre class="programlisting">
<strong>        python inbox_search.py  &#13;
</strong>
</pre></li><li class="listitem">The output of the preceding code snippet is shown in the following screenshot:<p>
</p><div><img alt="How to do it..." src="img/image_06_015.jpg"/></div><p>
</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec143"/>How it works...</h2></div></div></div><p>In the preceding code snippet, we first create an object of <code class="literal">IMAP_SSL4()</code> with the appropriate IMAP settings. We then log in to the client using the credentials from the configuration file with the help of the IMAP object. We then select our <code class="literal">INBOX</code> so that we can perform search operations on it.</p><p>The <code class="literal">M.search()</code> method called on the IMAP object helps us search for e-mails with the subject <em>Email with an attachment</em>. The <code class="literal">search()</code> method returns an array of messages that match the criteria we searched for.</p><p>Now, if we have to get to a particular message, and since we have to read the latest e-mail message that matched our criteria, we use the <code class="literal">M.fetch()</code> method. The <code class="literal">fetch()</code> method requires a given message object and the part of the message that you want to fetch. So, in this code example, we pass the latest e-mail object that matches the criteria and pass <code class="literal">RFC822</code>, which suggests that we want the e-mail body in the RFC 822 format.</p><p>When we print the message obtained from <code class="literal">fetch()</code>, we get the contents of the e-mail body for the latest e-mail that matched the search.</p><p>Now, do you remember seeing the contents of the e-mail? Well, it's the same e-mail message we had sent in one of our earlier recipes, which was used for demonstrating the e-mail attachment.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec144"/>There's more...</h2></div></div></div><p>Good! So, now we can search for a message and fetch it too. There are many more granular operations such as marking messages that we'd like to perform on our inbox. Let's look at them in the next recipe.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec51"/>Marking e-mail messages</h1></div></div></div><p>In the previous recipe, we looked at fetching and reading messages. Wasn't it too complicated? Do we have to take care of so many details while doing a simple operation like search or read? In this section, let's look at another library that can help us not only to search or read better, but also to perform various operations on our e-mails.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec145"/>Getting ready</h2></div></div></div><p>For this section, we will install the <code class="literal">gmail</code> module. You can install this module through your Terminal using the <code class="literal">pip</code> command, as shown here:</p><pre class="programlisting">
<strong>pip install gmail </strong>
</pre><p>Let's look at how to search for e-mails and read them using <code class="literal">gmail</code> APIs. This will get us started with the <code class="literal">gmail</code> module. The following code snippet searches for e-mails that were received after July 22, 2016. We then take the latest message and fetch it. Once we have the message fetched, we just go ahead and read the body of the e-mail:</p><pre class="programlisting">import gmail, config&#13;
from datetime import date&#13;
g = gmail.login(config.fromaddr, config.password)&#13;
mails = g.inbox().mail(after=date(2016, 7, 22))&#13;
mails[-1].fetch()&#13;
print "Email Body:\n", mails[-1].body&#13;
g.logout()</pre><p>The output of the preceding code is shown in the following screenshot. Looks like I may have received an e-mail digest from Quora!</p><p>
</p><div><img alt="Getting ready" src="img/image_06_016.jpg"/></div><p>
</p><p>Here's a screenshot from my inbox:</p><p>
</p><div><img alt="Getting ready" src="img/Chapter5-Page-21.jpg"/></div><p>
</p><p>Wasn't that too easy? Incidentally, the <code class="literal">gmail</code> module is written on top of <code class="literal">imaplib</code> but has better APIs, so let's take advantage of this module and do some fantastic operations.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec146"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Let's open the inbox and look for an unread message that matches a certain criteria and mark the message as read. The following code easily does this:<pre class="programlisting">        import gmail, config&#13;
        g = gmail.login(config.fromaddr, config.password)&#13;
        mails = g.inbox().mail(unread=True,&#13;
        sender='noreply@glassdoor.com')&#13;
        mails[-1].fetch()&#13;
        mails[-1].read()&#13;
        g.logout()</pre><p>Before running this program, I had one e-mail in my inbox from <a class="ulink" href="https://glassdoor.com">https://glassdoor.com</a> that I hadn't read. It looked like this in my inbox:</p><p>
</p><div><img alt="How to do it..." src="img/image_06_017.jpg"/></div><p>
</p><p>After running the code snippet, it identified this e-mail as matching my criteria of unread messages from <code class="literal">noreply@glassdoor.com</code> and marked my message as read. So, now it looks like this in my inbox. Gmail un-bolds the read messages and that's what happened in my inbox:</p><p>
</p><div><img alt="How to do it..." src="img/image_06_018.jpg"/></div><p>
</p><p>Nice!</p></li><li class="listitem">Let's look at another example. I have been receiving so many promotional e-mails from Amazon Now from Jan 2016. This is how my mailbox looks:<p>
</p><div><img alt="How to do it..." src="img/image_06_019.jpg"/></div><p>
</p></li><li class="listitem">Now, I want to mark them all as <code class="literal">read</code> and assign them under one label, <code class="literal">AMAZON</code>. How can I do it? The following code does this operation:<pre class="programlisting">        import gmail, config&#13;
        from datetime import date&#13;
        g = gmail.login(config.fromaddr, config.password)&#13;
        mails = g.inbox().mail(unread=True, &#13;
                               sender='store-news@amazon.in',&#13;
                               after=date(2016, 01, 01))&#13;
       for email in mails:&#13;
           email.read()&#13;
           email.add_label("AMAZON")&#13;
           g.logout()</pre></li><li class="listitem">After running this code, a new label will appear in your inbox with the name, <code class="literal">AMAZON</code>. Now, if you search your inbox for all e-mails with the label <code class="literal">AMAZON</code>, you'll see that all these e-mail messages have been marked as read. Look at the following screenshot where I search for e-mails with the label <code class="literal">AMAZON</code>:<p>
</p><div><img alt="How to do it..." src="img/image_06_020.jpg"/></div><p>
</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec147"/>How it works...</h2></div></div></div><p>In the first step, we created an object, <code class="literal">g</code> by logging into the Gmail server. Note that we didn't pass any parameters like IMAP settings or port to create the object. The <code class="literal">gmail</code> module internally handles this.</p><p>Now, using this object, we start searching our inbox for e-mails that are <em>unread</em> and sent by <code class="literal">noreply@glassdoor.in</code>', and all the mail objects matching this criteria are stored in <em>mails</em>.</p><p>Later, we fetch the latest record with the <code class="literal">fetch()</code> method and mark this mail as read with the <code class="literal">read()</code> method.</p><p>Similarly, in the second recipe, we iterate through all the e-mail messages that are <em>unread</em>, sent by <code class="literal">store-news@amazon.in</code>, and that were sent to me this year.</p><p>Each mail is then marked as read with the <code class="literal">read()</code> method and added to the label, <code class="literal">AMAZON</code>. Works like a breeze, awesome!</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec148"/>There's more...</h2></div></div></div><p>We looked at some of the operations that we can perform on our e-mail messages. There are many more. With the <code class="literal">gmail</code> module, you can mark messages as unread or even make them important with a star. Let's look at an example with which we can clear up our inbox.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec52"/>Clearing up e-mail messages from your inbox</h1></div></div></div><p>Last but not least, this recipe will take you through the steps with which you can delete e-mail messages from your inbox. As you'd expect, it's pretty straightforward to delete your e-mails programmatically. </p><div><div><h3 class="title"><a id="note16"/>Note</h3><p>Even if you delete the messages from your e-mail client, the e-mail server can still choose to store them. So, when you delete your messages, you're merely marking them to be hidden from your inbox while they can continue to stay on your e-mail server, based on the server implementation.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec149"/>Getting ready</h2></div></div></div><p>We continue to use the <code class="literal">imaplib </code>module for deleting e-mail messages, so no new installations are required for this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec150"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Let's utilize the configuration file and import the <code class="literal">fromaddress</code>, <code class="literal">password</code>, and <code class="literal">toaddress</code> to log in to the server.</li><li class="listitem">This is how the complete code looks like:<pre class="programlisting">        import gmail, config&#13;
        g = gmail.login(config.fromaddr, config.password)&#13;
        emails = g.inbox().mail(sender='junk@xyz.com')&#13;
        if emails:&#13;
           for mail in emails:&#13;
               mail.delete()</pre></li><li class="listitem">Store the preceding file as <code class="literal">inbox_delete.py</code> and run the code using the following command:<pre class="programlisting">
<strong>        python inbox_delete.py  &#13;
</strong>
</pre></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec151"/>How it works...</h2></div></div></div><p>Similar to what we saw in the previous examples, we first log in to Gmail with our login credentials from the configuration file.</p><p>We then connect to our inbox and search for e-mails coming from <code class="literal">junk@xyz.com</code>. If we find any e-mails that match this criteria, we want to delete them.</p><p>So, we loop over the mail objects and perform the <code class="literal">delete()</code> operation on them, and that's it! Our inbox is now free from all messages that we deem as junk. :)</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec152"/>There's more...</h2></div></div></div><p>Excellent! So, now we know how to send e-mail messages, add attachments, and fetch and read them. We also learnt how to mark our message as read, add appropriate labels, and delete these messages if needed. Armed with this knowledge, can we do something for Kelly who has a few problems?</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec53"/>Automating customer support flows with with e-mail responses</h1></div></div></div><p>Kelly, Director of Customer Support, has a problem at hand. Most of her support engineers end up responding to Level 1 support requests where customers are looking for information that is already available on the website. Customers just end up sending e-mails to support without trying to search for themselves.</p><p>This sequence of events is non-productive for the customer and support engineers. Customers simply wait for information instead of getting it on the website directly, and support engineers manually send a pointer to the <strong>Frequently Asked Questions</strong> (<strong>FAQ</strong>) section from the website to the customers. Kelly sees it as an opportunity to improve and wants to reduce the time spent on support by automating this flow. Can we do something to help her?</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec153"/>Getting ready</h2></div></div></div><p>Of course, this is a bigger problem to solve but at the very least, we can do something that will help automate the flow. Whenever the support team receives a new ticket via e-mail, we can auto respond to the ticket acknowledging the receipt of the ticket and also send the link to the FAQ section from the company's website. This way, the customers can browse and look up the information they need from the FAQ section. It also reduces the load on support engineers as the auto-response e-mail would have already resolved the customer query and that too in a quick time.</p><p>So now, what do we actually need? We need to monitor our support inbox, look at any new customer queries, and then auto-respond with our template e-mail.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec154"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Let's directly jump to our solution. Create a Python file and copy the following code snippet into it. It does exactly what we need to automate the support flow:<pre class="programlisting">        from email.mime.multipart import MIMEMultipart&#13;
        from email.mime.text import MIMEText&#13;
        from email.mime.image import MIMEImage&#13;
        import config, time, gmail&#13;
&#13;
        def send_email(strTo):&#13;
            strFrom = config.fromaddr&#13;
            msgRoot = MIMEMultipart('related')&#13;
            msgRoot['Subject'] = 'Thanks for your ticket'&#13;
            msgRoot['From'] = strFrom&#13;
            msgRoot['To'] = strTo&#13;
&#13;
            msgRoot.preamble = 'This is a multi-part message &#13;
                                in MIME format.'&#13;
            msgAlternative = MIMEMultipart('alternative')&#13;
            msgRoot.attach(msgAlternative)&#13;
            msgText = MIMEText('This is the alternative plain&#13;
                                text message.')&#13;
            msgAlternative.attach(msgText)&#13;
            msgText = MIMEText('Hi there, &lt;br&gt;&lt;br&gt;Thanks for your &#13;
                                query with us today.'&#13;
                               ' You can look at our &#13;
                               &lt;a href="https://google.com"&gt;FAQs&lt;/a&gt;'&#13;
                               ' and we shall get back to you &#13;
                                 soon.&lt;br&gt;&lt;br&gt;'&#13;
                               'Thanks,&lt;br&gt;Support Team&lt;br&gt;&lt;br&gt;&#13;
                               &lt;img src="img/cid:image1"&gt;', 'html')&#13;
            msgAlternative.attach(msgText)&#13;
            fp = open('google.png', 'rb')&#13;
            msgImage = MIMEImage(fp.read())&#13;
            fp.close()&#13;
            msgImage.add_header('Content-ID', '&lt;image1&gt;')&#13;
            msgRoot.attach(msgImage)&#13;
&#13;
            import smtplib&#13;
            server = smtplib.SMTP('smtp.gmail.com', 587)&#13;
            server.starttls()&#13;
            server.login(config.fromaddr, config.password)&#13;
            server.sendmail(config.fromaddr, config.toaddr, &#13;
                            msgRoot.as_string())&#13;
            server.quit()&#13;
&#13;
            while True:&#13;
                  g = gmail.login(config.fromaddr, config.password)&#13;
                  mails = g.inbox().mail(unread=True)&#13;
                  mails[-1].fetch()&#13;
                  from_ = mails[-1].fr&#13;
                  send_email(from_)&#13;
                  time.sleep(60)</pre></li><li class="listitem">Run the preceding code with Python, and you will observe that the program is still running. It is actually waiting for new e-mails, in this context, the customer requests for the support engineers.</li><li class="listitem">If you now send an e-mail to customer support, you will receive an auto reply from our Python program.<div><div><h3 class="title"><a id="note17"/>Note</h3><p>In this case the support inbox is my e-mail address, but you can easily set up an e-mail account for your company so that the customer requests are directed to this account.</p></div></div><p>This is how the auto response e-mail looks:</p><p>
</p><div><img alt="How to do it..." src="img/image_06_021.jpg"/></div><p>
</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec155"/>How it works...</h2></div></div></div><p>We start with a <code class="literal">while</code> loop that runs every one min (60 seconds). Every iteration reads the support inbox and searches for unread e-mails.</p><p>If the <code class="literal">while</code> loop finds any unread e-mail, it will fetch the e-mail and get the <code class="literal">fr</code> attribute. The <code class="literal">fr</code> attribute gets you the <code class="literal">from</code> field of the e-mail message. The <code class="literal">from</code> field is the e-mail address of the customer asking for information from the support engineer.</p><p>Once we have the customer's e-mail address, we send an automated response to the customer from our inbox. The preceding screenshot shows exactly what the auto response looks like.
Cool, so now when the customers asks a question to the customer support engineer by sending an e-mail, they will get an automated e-mail response with the link to the Frequently Asked Questions section.</p><p>This way, the customer gets the required information quickly from the FAQ link. Also, the load on the support engineers is reduced, as they don't have to respond to the mundane support requests manually.</p><p>I'm sure Kelly feels happy about this improvement. She understands that the customer support flow is automated to a certain extent and hopes to see productivity gains soon!</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec156"/>There's more...</h2></div></div></div><p>Awesome! There are many other things that you can do with e-mails. Tried downloading e-mail attachments? Want to give it a shot? We'll let you try that for yourself. See you in the next chapter!</p></div></div></body></html>