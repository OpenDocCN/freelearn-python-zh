- en: Chapter 1. Objects in Depth
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 深入了解对象
- en: 'In this chapter, we will dive into Python objects. Objects are the building
    blocks of the language. They may represent or abstract a real entity. We will
    be more interested in factors affecting such behavior. This will help us understand
    and appreciate the language in a better way. We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究Python对象。对象是语言的基本构建块。它们可能代表或抽象一个真实实体。我们将更感兴趣的是影响这种行为的因素。这将帮助我们更好地理解和欣赏这门语言。我们将涵盖以下主题：
- en: Object characteristics
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象特征
- en: Calling objects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用对象
- en: How objects are created
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象是如何创建的
- en: Playing with attributes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩转属性
- en: Understanding objects
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解对象
- en: '**Key 1: Objects are language''s abstraction for data. Identity, value, and
    type are characteristic of them.**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键1：对象是语言对数据的抽象。标识、值和类型是它们的特性。**'
- en: All data and items that we work on in a program are objects, such as numbers,
    strings, classes, instances, and modules. They possess some qualities that are
    similar to real things as all of them are uniquely identifiable just like humans
    are identifiable by their DNA. They have a type that defines what kind of object
    it is, and the properties that it supports, just like humans of type cobbler support
    repairing shoes, and blacksmiths support making metal items. They possess some
    value, such as strength, money, knowledge, and beauty do for humans.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，我们处理的所有数据和项目都是对象，例如数字、字符串、类、实例和模块。它们具有一些类似于真实事物的特性，因为它们都像人类通过DNA一样具有唯一可识别性。它们有一个类型，定义了它是哪种类型的对象，以及它支持哪些属性，就像鞋匠类型的人类支持修鞋，铁匠支持制作金属物品一样。它们具有一些价值，如力量、金钱、知识和美丽对人类的作用。
- en: Name is just a means to identify an object in a namespace similar to how it
    is used to identify a person in a group.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 名称只是一个在命名空间中识别对象的手段，就像它被用来在群体中识别一个人一样。
- en: Identity
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标识
- en: In Python, every object has a unique identity. We can get this identity by passing
    an object to built-in ID function ID (object).This returns the memory address
    of the object in CPython.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，每个对象都有一个唯一的标识。我们可以通过将对象传递给内置的ID函数ID（对象）来获取这个标识。这返回了对象在CPython中的内存地址。
- en: 'Interpreter can reuse some objects so that the total number of objects remains
    low. For example, integers and strings can be reused in the following manner:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器可以重用一些对象，以便对象的总量保持较低。例如，整数和字符串可以按以下方式重用：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is also a reason that addition of two strings is a third new string, and,
    hence, it is best to use the StringIO module to work with a buffer, or use the
    join attribute of strings:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么两个字符串相加会生成第三个新字符串的原因，因此最好使用StringIO模块来处理缓冲区，或者使用字符串的join属性：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Value
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值
- en: '**Key 2: Immutability is the inability to change an object''s value.**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键2：不可变性是指无法改变对象的值。**'
- en: 'The value of the object is the data that is stored in it. Data in an object
    can be stored as numbers, strings, or references to other objects. Strings, and
    integers are objects themselves. Hence, for objects that are not implemented in
    C (or core objects), it is a reference to other objects, and we perceive value
    as the group value of the referenced object. Let''s take an example of an object
    **iC** instance of the C class with the `str` and `lst` attributes, as shown in
    the following diagram:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的值是存储在其中的数据。对象中的数据可以存储为数字、字符串或其他对象的引用。字符串和整数本身就是对象。因此，对于不是用C（或核心对象）实现的对象，它是对其他对象的引用，我们感知的值是引用对象的组值。让我们以一个对象**iC**为例，它是C类的实例，具有`str`和`lst`属性，如下面的图所示：
- en: '![Value](img/B04885_01_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![值](img/B04885_01_01.jpg)'
- en: 'The code snippet to create this object will be as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此对象的代码片段如下：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then, when we modify **iC**, we are either changing the objects references via
    attributes, or we are changing the references themselves and not the object **iC**.
    This is important in understanding immutable objects because being immutable means
    not being able to change references. Hence, we can change mutable objects that
    are referenced by immutable objects. For example, lists inside tuple can be changed
    because the referenced objects are changing, not the references.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们修改**iC**时，我们要么通过属性更改对象的引用，要么更改引用本身而不是对象**iC**。这在理解不可变对象时很重要，因为不可变意味着无法更改引用。因此，我们可以更改由不可变对象引用的可变对象。例如，元组内的列表可以更改，因为引用的对象正在更改，而不是引用本身。
- en: Type
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型
- en: '**Key 3: Type is instance''s class.**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键3：类型是实例的类。**'
- en: An object's type tells us about the operations and functionality that the object
    supports, and it may also define the possible values for objects of that type.
    For example, your pet may be of type `dog` (an instance of the `dog` class) or
    cat (an instance of the `cat` class). If it is of type dog, it can bark; and if
    it is type cat, it can meow. Both are a type of animal (`cat` and `dog` inherit
    from the `animal` class).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的类型告诉我们对象支持的运算和功能，它还可能定义该类型对象的可能值。例如，你的宠物可能是`dog`类型（`dog`类的实例）或`cat`类型（`cat`类的实例）。如果是狗类型，它可以吠叫；如果是猫类型，它可以喵喵叫。两者都是动物类型（`cat`和`dog`继承自`animal`类）。
- en: 'An object''s class provides a type to it. Interpreter gets the object''s class
    by checking its `__class__` attribute. So, we can change an object''s type by
    changing its `__class__` attribute:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象的类为其提供类型。解释器通过检查其`__class__`属性来获取对象的类。因此，我们可以通过更改对象的`__class__`属性来更改对象的类型：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This will not work for built-in, compiled classes as it works only for class
    objects defined on runtime.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于内置、编译的类不起作用，因为它只适用于在运行时定义的类对象。
- en: Making calls to objects
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象的调用
- en: '**Key 4: All objects can be made callable.**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键4：所有对象都可以被调用。**'
- en: 'To reuse and group code for some task, we group it in the functions classes,
    and then call it with different inputs. The objects that have a `__call__` attribute
    are callable and `__call__` is the entry point. For the C class, `tp_call` is
    checked in its structure:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重用和分组某些任务的代码，我们将它们分组在函数类中，然后使用不同的输入调用它们。具有`__call__`属性的对象是可调用的，`__call__`是入口点。对于C类，在其结构中检查`tp_call`：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Methods in classes are similar to functions, except that they are called with
    an implicit instance as a first argument. The functions are exposed as methods
    when they are accessed from the instance. The function is wrapped in a method
    class and returned. The method class stores instances in `__self__` and function
    in `__func__`, and its `__call__` method calls `__func__` with first argument
    as `__self__`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的方法类似于函数，除了它们使用隐式实例作为第一个参数进行调用。当从实例访问时，函数作为方法公开。函数被包装在方法类中并返回。方法类在`__self__`中存储实例，在`__func__`中存储函数，其`__call__`方法使用`__self__`作为第一个参数调用`__func__`：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using this logic, we can also collect methods that are needed from other classes
    in the current class, like the following code, instead of multiple inheritances
    if data attributes do not clash. This will result in two dictionary lookups for
    an attribute search: one for instance, and one for class.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个逻辑，我们还可以从当前类中收集所需的其他类的方法，如下面的代码所示，而不是在数据属性不冲突的情况下进行多重继承。这将导致对属性搜索进行两次字典查找：一次是实例，一次是类。
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we call classes, we are calling its type, that is `metaclass`, with class
    as a first argument to give us a new instance:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用类时，我们是在调用其类型，即元类，以类作为第一个参数来给我们一个新的实例：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Similarly, when we call instances, we are calling their type, that is class,
    with instance as first argument:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当我们调用实例时，我们是在调用它们的类型，即类，以实例作为第一个参数：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How objects are created
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象是如何创建的
- en: Objects other than built-in types or compiled module classes are created at
    runtime. Objects can be classes, instances, functions, and so on. We call an object's
    type to give us a new instance; or put in another way, we call a `type` class
    to give us an instance of that type.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内置类型或编译的模块类之外的对象是在运行时创建的。对象可以是类、实例、函数等。我们调用对象类型以给我们一个新的实例；或者换句话说，我们调用`type`类以给我们该类型的实例。
- en: Creation of function objects
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数对象的创建
- en: '**Key 5: Create function on runtime.**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键5：在运行时创建函数。**'
- en: 'Let''s first take a look at how function objects can be created. This will
    broaden our view. This process is done by interpreter behind the scenes when it
    sees a `def` keyword. It compiles the code, which is shown as follows, and passes
    the code name arguments to the function class that returns an object:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何创建函数对象。这将拓宽我们的视野。这个过程是在解释器看到`def`关键字时在幕后完成的。它编译代码，如下所示，并将代码名称参数传递给返回对象的函数类：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Creation of instances
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例的创建
- en: '**Key 6: Process flow for instance creation.**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键6：实例创建的处理流程。**'
- en: 'We call class to get a new instance. We saw from the making calls to objects
    section that when we call class, it calls its metaclass `__call__` method to get
    a new instance. It is the responsibility of `__call__` to return a new object
    that is properly initialized. It is able to call class''s `__new__`, and `__init__`
    because class is passed as first argument, and instance is created by this function
    itself:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用类以获取一个新实例。我们从对象调用部分看到，当我们调用类时，它会调用其元类的 `__call__` 方法来获取一个新实例。`__call__`
    负责返回一个正确初始化的新对象。它能够调用类的 `__new__` 和 `__init__`，因为类作为第一个参数传递，实例是由这个函数本身创建的：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To enable developer access to both functionalities, creating new object, and
    initializing new object, in class itself; `__call__` calls the `__new__` class
    to return a new object and `__init__` to initialize it. The full flow can be visualized
    as shown in the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使开发者能够访问这两种功能，在类本身中创建新对象和初始化新对象；`__call__` 调用 `__new__` 类以返回一个新对象，并调用 `__init__`
    来初始化它。完整的流程可以如图所示：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Take a look at the following diagram:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下图解：
- en: '![Creation of instances](img/B04885_01_02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![实例的创建](img/B04885_01_02.jpg)'
- en: Creation of class objects
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类对象的创建
- en: '**Key 7: Process flow for class creation.**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键点 7：类创建的处理流程。**'
- en: 'There are three ways in which we can create classes. One is to simply define
    the class. The second one is to use the built-in `__build_class__` function, and
    the third is to use the `new_class` method of `type` module. Method one uses two,
    method two uses method three internally. When interpreter sees a class keyword,
    it collects the name, bases, and metaclass that is defined for the class. It will
    call the `__build_class__` built-in function with function (with the code object
    of the class), name of the class, base classes, metaclass that is defined, and
    so on:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以三种方式创建类。一种简单地定义类。第二种是使用内置的 `__build_class__` 函数，第三种是使用 `type` 模块的 `new_class`
    方法。第一种方法使用第二种方法，第二种方法内部使用第三种方法。当解释器看到类关键字时，它会收集类的名称、基类和为类定义的元类。它将使用函数（带有类的代码对象）、类的名称、基类、定义的元类等调用内置的
    `__build_class__` 函数：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This function returns the class. This will call the `__prepare__` class method
    of metaclass to get a mapping data structure to use as a namespace. The class
    body will be evaluated, and local variables will be stored in this mapping data
    structure. Metaclass''s type will be called with this namespace dictionary, bases,
    and class name. It will in turn call the `__new__` and `__init__` methods of metaclass.
    Metaclass can change attributes passed to its method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回类。这将调用元类的 `__prepare__` 类方法以获取用作命名空间的映射数据结构。类体将被评估，局部变量将存储在这个映射数据结构中。元类的类型将使用此命名空间字典、基类和类名进行调用。它将依次调用元类的
    `__new__` 和 `__init__` 方法。元类可以更改传递给其方法中的属性：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Take a look at the following diagram:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下图解：
- en: '![Creation of class objects](img/B04885_01_03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![类对象的创建](img/B04885_01_03.jpg)'
- en: Playing with attributes
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转属性
- en: '**Key 8: Which attribute will be used.**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键点 8：将使用哪个属性。**'
- en: 'Attributes are values that are associated with an object that can be referenced
    by name using dotted expressions. It is important to understand how attributes
    of an object are found. The following is the sequence that is used to search an
    attribute:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是与对象相关联的值，可以通过点表达式按名称引用。理解对象属性是如何找到的非常重要。以下用于搜索属性的顺序：
- en: 'If an attribute is a special method, and it exists in the object''s type (or
    bases), return it, for example: `__call__`, `__str__`, and `__init__`. When these
    methods are searched, their behavior is only in the instance''s type:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个属性是特殊方法，并且它存在于对象的类型（或基类）中，则返回它，例如：`__call__`、`__str__` 和 `__init__`。当搜索这些方法时，它们的行仅在实例的类型中：
- en: '[PRE14]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If an object''s type has a `__getattribute__` attribute, then this method is
    invoked to get the attribute whether this attribute is present or not. It is the
    total responsibility of `__getattribute__` to get the attribute. As shown in the
    following code snippet, even if the do method is present, it is not found as `getattribute`
    didn''t return any attribute:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果对象的类型具有 `__getattribute__` 属性，则无论该属性是否存在，都会调用此方法来获取属性。获取属性是 `__getattribute__`
    的全部责任。如下面的代码片段所示，即使存在 do 方法，它也不会被找到，因为 `getattribute` 没有返回任何属性：
- en: '[PRE15]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Search in object''s type `__dict__` to find the attribute. If it is present,
    and it is data descriptor, return it:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对象的类型 `__dict__` 中搜索以找到属性。如果存在，并且它是数据描述符，则返回它：
- en: '[PRE16]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Search in object's `__dict__` type (and if this object is class, search bases
    `__dict__` as well) to find the attribute. If the attribute is descriptor, return
    the result.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对象的`__dict__`类型中搜索以找到属性（如果此对象是类，则也搜索基类的`__dict__`）。如果属性是描述符，则返回结果。
- en: 'Search in object''s type`__dict__` to find the attribute. If the attribute
    is found, return it. If it is non-data descriptor, return its result, and check
    in other bases using the same logic:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对象的类型`__dict__`中搜索以找到属性。如果找到属性，则返回它。如果它是非数据描述符，则返回其结果，并使用相同的逻辑在其他基类中检查：
- en: '[PRE17]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If object type''s `__getattr__` is defined, check whether it can give us the
    attribute:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果对象类型的`__getattr__`被定义，检查它是否可以给我们提供属性：
- en: '[PRE18]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Raise `AttributeError`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引发`AttributeError`。
- en: Descriptors
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述符
- en: '**Key 9: Making custom behavior attributes.**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键9：创建自定义行为属性。**'
- en: 'Any attribute of a class, which is an object defining any of these methods,
    acts as a descriptor:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 任何定义了这些方法之一的对象属性，在类中都是描述符：
- en: '`__get__(self, obj, type=None) --> value`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__get__(self, obj, type=None) --> value`'
- en: '`__set__(self, obj, value) --> None`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__set__(self, obj, value) --> None`'
- en: '`__delete__(self, obj) --> None`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__delete__(self, obj) --> None`'
- en: 'When an attribute is searched in an object first, it is searched in its dictionary
    then its type''s (base class''s) dictionary. If found, object has one of these
    methods defined and that method is invoked instead. Let''s assume that b is an
    instance of the `B` class, then the following will happen:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当在对象中首先搜索属性时，它首先在对象的字典中搜索，然后在其类型（基类）的字典中搜索。如果找到，则对象定义了这些方法之一，并且将调用该方法。假设b是`B`类的实例，那么以下将发生：
- en: Invocation through class is type`.__getattribute__()` transforming to `B.__dict__['x'].__get__(None,
    B)`
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过类调用是`type.__getattribute__()`转换为`B.__dict__['x'].__get__(None, B)`
- en: Invocation through instance is object `.__getattribute__() --> type(b).__dict__['x'].__get__(b,
    type(b))`
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实例调用是`.__getattribute__() --> type(b).__dict__['x'].__get__(b, type(b))`
- en: Objects with only `__get__` are non-data descriptors, and objects that include
    `__set__` / `__del__` are data descriptors. Data descriptors take precedence over
    instance attributes, whereas non-data descriptors do not.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 只有`__get__`的对象是非数据描述符，而包含`__set__` / `__del__`的对象是数据描述符。数据描述符优先于实例属性，而非数据描述符则没有。
- en: Class, static, and instance methods
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类、静态和实例方法
- en: '**Key 10: Implementing class method and static method.**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键10：实现类方法和静态方法。**'
- en: 'Class, static, and instance methods are all implementable using descriptors.
    We can understand descriptors and these methods in one go:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 类、静态和实例方法都可以使用描述符实现。我们可以一次理解描述符和这些方法：
- en: Class methods are methods that always get class as their first argument and
    they can be executed without any instance of class.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类方法是始终将类作为其第一个参数的方法，并且可以在没有类实例的情况下执行。
- en: Static methods are methods that do not get any implicit objects as first argument
    when executed via class or instance.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态方法是当通过类或实例执行时不会获得任何隐式对象的第一个参数的方法。
- en: Instance methods get instances when called via instance but no implicit argument
    when called via class.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例方法在通过实例调用时获取实例，但在通过类调用时没有隐式参数。
- en: 'A sample code usage of these methods is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的示例代码使用如下：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'They can be understood and implemented using descriptors easily as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 他们可以很容易地使用描述符来理解和实现，如下所示：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户中下载示例代码文件，以获取您购买的所有Packt
    Publishing书籍。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we dived into how objects work in the Python language, how
    are they connected, and how are they called. Descriptors and instance creation
    are very important topics as they give us a picture of how system works. We also
    dived into how attributes are looked up for objects.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了Python语言中对象的工作方式，它们是如何连接的，以及它们是如何被调用的。描述符和实例创建是两个非常重要的主题，因为它们为我们描绘了系统是如何工作的。我们还深入探讨了对象属性查找的方式。
- en: Now, we are all prepared to learn how to use language constructs to their maximum
    potential. In the next chapter, we will also discover utilities that are extremely
    helpful in elegantly finishing a project.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们都已准备好学习如何充分利用语言结构。在下一章中，我们还将发现一些在优雅地完成项目时极为有用的工具。
