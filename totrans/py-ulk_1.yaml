- en: Chapter 1. Objects in Depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will dive into Python objects. Objects are the building
    blocks of the language. They may represent or abstract a real entity. We will
    be more interested in factors affecting such behavior. This will help us understand
    and appreciate the language in a better way. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Object characteristics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How objects are created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing with attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 1: Objects are language''s abstraction for data. Identity, value, and
    type are characteristic of them.**'
  prefs: []
  type: TYPE_NORMAL
- en: All data and items that we work on in a program are objects, such as numbers,
    strings, classes, instances, and modules. They possess some qualities that are
    similar to real things as all of them are uniquely identifiable just like humans
    are identifiable by their DNA. They have a type that defines what kind of object
    it is, and the properties that it supports, just like humans of type cobbler support
    repairing shoes, and blacksmiths support making metal items. They possess some
    value, such as strength, money, knowledge, and beauty do for humans.
  prefs: []
  type: TYPE_NORMAL
- en: Name is just a means to identify an object in a namespace similar to how it
    is used to identify a person in a group.
  prefs: []
  type: TYPE_NORMAL
- en: Identity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Python, every object has a unique identity. We can get this identity by passing
    an object to built-in ID function ID (object).This returns the memory address
    of the object in CPython.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interpreter can reuse some objects so that the total number of objects remains
    low. For example, integers and strings can be reused in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is also a reason that addition of two strings is a third new string, and,
    hence, it is best to use the StringIO module to work with a buffer, or use the
    join attribute of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Key 2: Immutability is the inability to change an object''s value.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of the object is the data that is stored in it. Data in an object
    can be stored as numbers, strings, or references to other objects. Strings, and
    integers are objects themselves. Hence, for objects that are not implemented in
    C (or core objects), it is a reference to other objects, and we perceive value
    as the group value of the referenced object. Let''s take an example of an object
    **iC** instance of the C class with the `str` and `lst` attributes, as shown in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Value](img/B04885_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The code snippet to create this object will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Then, when we modify **iC**, we are either changing the objects references via
    attributes, or we are changing the references themselves and not the object **iC**.
    This is important in understanding immutable objects because being immutable means
    not being able to change references. Hence, we can change mutable objects that
    are referenced by immutable objects. For example, lists inside tuple can be changed
    because the referenced objects are changing, not the references.
  prefs: []
  type: TYPE_NORMAL
- en: Type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Key 3: Type is instance''s class.**'
  prefs: []
  type: TYPE_NORMAL
- en: An object's type tells us about the operations and functionality that the object
    supports, and it may also define the possible values for objects of that type.
    For example, your pet may be of type `dog` (an instance of the `dog` class) or
    cat (an instance of the `cat` class). If it is of type dog, it can bark; and if
    it is type cat, it can meow. Both are a type of animal (`cat` and `dog` inherit
    from the `animal` class).
  prefs: []
  type: TYPE_NORMAL
- en: 'An object''s class provides a type to it. Interpreter gets the object''s class
    by checking its `__class__` attribute. So, we can change an object''s type by
    changing its `__class__` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This will not work for built-in, compiled classes as it works only for class
    objects defined on runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Making calls to objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 4: All objects can be made callable.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To reuse and group code for some task, we group it in the functions classes,
    and then call it with different inputs. The objects that have a `__call__` attribute
    are callable and `__call__` is the entry point. For the C class, `tp_call` is
    checked in its structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Methods in classes are similar to functions, except that they are called with
    an implicit instance as a first argument. The functions are exposed as methods
    when they are accessed from the instance. The function is wrapped in a method
    class and returned. The method class stores instances in `__self__` and function
    in `__func__`, and its `__call__` method calls `__func__` with first argument
    as `__self__`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this logic, we can also collect methods that are needed from other classes
    in the current class, like the following code, instead of multiple inheritances
    if data attributes do not clash. This will result in two dictionary lookups for
    an attribute search: one for instance, and one for class.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call classes, we are calling its type, that is `metaclass`, with class
    as a first argument to give us a new instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, when we call instances, we are calling their type, that is class,
    with instance as first argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How objects are created
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Objects other than built-in types or compiled module classes are created at
    runtime. Objects can be classes, instances, functions, and so on. We call an object's
    type to give us a new instance; or put in another way, we call a `type` class
    to give us an instance of that type.
  prefs: []
  type: TYPE_NORMAL
- en: Creation of function objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Key 5: Create function on runtime.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first take a look at how function objects can be created. This will
    broaden our view. This process is done by interpreter behind the scenes when it
    sees a `def` keyword. It compiles the code, which is shown as follows, and passes
    the code name arguments to the function class that returns an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Creation of instances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Key 6: Process flow for instance creation.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We call class to get a new instance. We saw from the making calls to objects
    section that when we call class, it calls its metaclass `__call__` method to get
    a new instance. It is the responsibility of `__call__` to return a new object
    that is properly initialized. It is able to call class''s `__new__`, and `__init__`
    because class is passed as first argument, and instance is created by this function
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable developer access to both functionalities, creating new object, and
    initializing new object, in class itself; `__call__` calls the `__new__` class
    to return a new object and `__init__` to initialize it. The full flow can be visualized
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creation of instances](img/B04885_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creation of class objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Key 7: Process flow for class creation.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three ways in which we can create classes. One is to simply define
    the class. The second one is to use the built-in `__build_class__` function, and
    the third is to use the `new_class` method of `type` module. Method one uses two,
    method two uses method three internally. When interpreter sees a class keyword,
    it collects the name, bases, and metaclass that is defined for the class. It will
    call the `__build_class__` built-in function with function (with the code object
    of the class), name of the class, base classes, metaclass that is defined, and
    so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This function returns the class. This will call the `__prepare__` class method
    of metaclass to get a mapping data structure to use as a namespace. The class
    body will be evaluated, and local variables will be stored in this mapping data
    structure. Metaclass''s type will be called with this namespace dictionary, bases,
    and class name. It will in turn call the `__new__` and `__init__` methods of metaclass.
    Metaclass can change attributes passed to its method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creation of class objects](img/B04885_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Playing with attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 8: Which attribute will be used.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Attributes are values that are associated with an object that can be referenced
    by name using dotted expressions. It is important to understand how attributes
    of an object are found. The following is the sequence that is used to search an
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If an attribute is a special method, and it exists in the object''s type (or
    bases), return it, for example: `__call__`, `__str__`, and `__init__`. When these
    methods are searched, their behavior is only in the instance''s type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If an object''s type has a `__getattribute__` attribute, then this method is
    invoked to get the attribute whether this attribute is present or not. It is the
    total responsibility of `__getattribute__` to get the attribute. As shown in the
    following code snippet, even if the do method is present, it is not found as `getattribute`
    didn''t return any attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Search in object''s type `__dict__` to find the attribute. If it is present,
    and it is data descriptor, return it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Search in object's `__dict__` type (and if this object is class, search bases
    `__dict__` as well) to find the attribute. If the attribute is descriptor, return
    the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Search in object''s type`__dict__` to find the attribute. If the attribute
    is found, return it. If it is non-data descriptor, return its result, and check
    in other bases using the same logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If object type''s `__getattr__` is defined, check whether it can give us the
    attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Raise `AttributeError`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Descriptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Key 9: Making custom behavior attributes.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Any attribute of a class, which is an object defining any of these methods,
    acts as a descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__get__(self, obj, type=None) --> value`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__set__(self, obj, value) --> None`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__delete__(self, obj) --> None`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When an attribute is searched in an object first, it is searched in its dictionary
    then its type''s (base class''s) dictionary. If found, object has one of these
    methods defined and that method is invoked instead. Let''s assume that b is an
    instance of the `B` class, then the following will happen:'
  prefs: []
  type: TYPE_NORMAL
- en: Invocation through class is type`.__getattribute__()` transforming to `B.__dict__['x'].__get__(None,
    B)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invocation through instance is object `.__getattribute__() --> type(b).__dict__['x'].__get__(b,
    type(b))`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects with only `__get__` are non-data descriptors, and objects that include
    `__set__` / `__del__` are data descriptors. Data descriptors take precedence over
    instance attributes, whereas non-data descriptors do not.
  prefs: []
  type: TYPE_NORMAL
- en: Class, static, and instance methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Key 10: Implementing class method and static method.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Class, static, and instance methods are all implementable using descriptors.
    We can understand descriptors and these methods in one go:'
  prefs: []
  type: TYPE_NORMAL
- en: Class methods are methods that always get class as their first argument and
    they can be executed without any instance of class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static methods are methods that do not get any implicit objects as first argument
    when executed via class or instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance methods get instances when called via instance but no implicit argument
    when called via class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A sample code usage of these methods is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'They can be understood and implemented using descriptors easily as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dived into how objects work in the Python language, how
    are they connected, and how are they called. Descriptors and instance creation
    are very important topics as they give us a picture of how system works. We also
    dived into how attributes are looked up for objects.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are all prepared to learn how to use language constructs to their maximum
    potential. In the next chapter, we will also discover utilities that are extremely
    helpful in elegantly finishing a project.
  prefs: []
  type: TYPE_NORMAL
