["```py\ndef sum_numeric(limit: int = 10) -> int: \n    s = 0 \n    for n in range(1, limit): \n        if n % 3 == 0 or n % 5 == 0: \n            s += n \n    return s\n```", "```py\nfrom collections.abc import Sequence \ndef sumr(seq : Sequence[int]) -> int: \n    if len(seq) == 0: \n        return 0 \n    return seq[0] + sumr(seq[1:])\n```", "```py\n>>> sumr([7, 11]) \n18 \n>>> sumr([11]) \n11 \n>>> sumr([]) \n0\n```", "```py\nfrom collections.abc import Sequence, Callable \ndef until( \n        limit: int, \n        filter_func: Callable[[int], bool], \n        v: int \n) -> list[int]: \n    if v == limit: \n        return [] \n    elif filter_func(v): \n        return [v] + until(limit, filter_func, v + 1) \n    else: \n        return until(limit, filter_func, v + 1)\n```", "```py\ndef mult_3_5(x: int) -> bool: \n    return x % 3 == 0 or x % 5 == 0\n```", "```py\n>>> until(10, mult_3_5, 0) \n[0, 3, 5, 6, 9]\n```", "```py\ndef sum_functional(limit: int = 10) -> int: \n    return sumr(until(limit, mult_3_5, 0))\n```", "```py\ndef sum_hybrid(limit: int = 10) -> int: \n    return sum( \n        n for n in range(1, limit) \n        if n % 3 == 0 or n % 5 == 0 \n    )\n```", "```py\n>>> sum( \n...     n for n in range(1, 10) \n...     if n % 3 == 0 or n % 5 == 0 \n... ) \n23 \n>>> n \nTraceback (most recent call last): \n   File \"<stdin>\", line 1, in <module> \nNameError: name ’n’ is not defined\n```", "```py\ndef next_(n: float, x: float) -> float: \n    return (x + n / x) / 2\n```", "```py\n>>> n = 2 \n>>> f = lambda x: next_(n, x) \n>>> a0 = 1.0 \n>>> [round(x, 4) \n... for x in (a0, f(a0), f(f(a0)), f(f(f(a0))),) \n... ] \n[1.0, 1.5, 1.4167, 1.4142]\n```", "```py\nfrom collections.abc import Iterator, Callable \ndef repeat( \n        f: Callable[[float], float], \n        a: float \n) -> Iterator[float]: \n    yield a \n    yield from repeat(f, f(a))\n```", "```py\n    for x in some_iter: yield x\n    ```", "```py\n    yield from some_iter\n    ```", "```py\nfrom collections.abc import Iterator \ndef within( \n        𝜖: float, \n        iterable: Iterator[float] \n) -> float: \n    def head_tail( \n            𝜖: float, \n            a: float, \n            iterable: Iterator[float] \n    ) -> float: \n        b = next(iterable) \n        if abs(a-b) <= 𝜖: \n            return b \n        return head_tail(𝜖, b, iterable) \n\n    return head_tail(𝜖, next(iterable), iterable)\n```", "```py\ndef sqrt(n: float) -> float: \n    return within( \n        𝜖=0.0001, \n        iterable=repeat( \n            lambda x: next_(n, x), \n            1.0 \n        ) \n    )\n```", "```py\nfrom collections import Counter \nimport csv \nfrom pathlib import Path \n\nDEFAULT_PATH = Path.cwd() / \"address.csv\" \n\ndef main(source_path: Path = DEFAULT_PATH) -> None: \n    frequency: Counter[str] = Counter() \n    with source_path.open() as source: \n        rdr = csv.DictReader(source) \n        for row in rdr: \n            if \"-\" in row[’ZIP’]: \n                text_zip = row[’ZIP’] \n                missing_zeroes = 10 - len(text_zip) \n                if missing_zeroes: \n                    text_zip = missing_zeroes*’0’ + text_zip \n            else: \n                text_zip = row[’ZIP’] \n                if 5 < len(row[’ZIP’]) < 9: \n                    missing_zeroes = 9 - len(text_zip) \n                else: \n                    missing_zeroes = 5 - len(text_zip) \n                if missing_zeroes: \n                    text_zip = missing_zeroes*’0’ + text_zip \n            frequency[text_zip] += 1 \n    print(frequency) \n\nif __name__ == \"__main__\": \n    main()\n```", "```py\n        def zip_histogram( \n                reader: csv.DictReader[str]) -> Counter[str]: \n            pass\n    ```", "```py\ndef zip_histogram( \n        reader: csv.DictReader[str]) -> Counter[str]: \n    return Counter( \n        zip_cleanse( \n            row[’ZIP’] \n        ) for row in reader \n    )\n```"]