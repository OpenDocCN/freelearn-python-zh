<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-202"><a id="_idTextAnchor203"/>12</h1>
<h1 id="_idParaDest-203"><a id="_idTextAnchor204"/>Sample Strategy – Trend-Following</h1>
<p>In the previous chapter, we developed two trading applications: one to use in production and another one to facilitate the testing and research of trading strategies. Better said, these are two versions of the same application, with different data processing modules. We designed them so that the trading logic developed in the backtesting app could be used in the production one without modifications (or with just minimal modifications in complex cases). We also tested the code using a sample "<em class="italic">strategy"</em> and saw that the code worked correctly, but the "<em class="italic">strategy"</em> was steadily losing money – fortunately only on paper (and that’s why I consistently put this word in "italics").</p>
<p>Now it’s time to learn the process of researching and developing one of the most popular classical trading strategies applied to the FX market. We already discussed it earlier in the book, but only from a qualitative, not a quantitative, perspective. Now we will suggest a formal mathematical model and implement it in code. And, of course, we will backtest and check whether the result can be used for live trading.</p>
<p>In this chapter, we will consider trend-following strategies and learn about the following topics:</p>
<ul>
<li>Trend-following revisited – trading setup</li>
<li>Choosing the market and preparing data</li>
<li>Trend-following strategy – implementation</li>
</ul>
<h1 id="_idParaDest-204"><a id="_idTextAnchor205"/>Trend-following revisited – trading setup</h1>
<p>In <a href="B19145_09.xhtml#_idTextAnchor152"><em class="italic">Chapter 9</em></a>, <em class="italic">Trading Strategies and Their Core Elements</em>, we considered trend-following<a id="_idIndexMarker829"/> and came to the conclusion that although it is one of the simplest and most intuitive trading strategies, we still need a set of rules that determine the following:</p>
<ul>
<li>Whether there is a trend in the market</li>
<li>Whether the trend goes north or south (up or down, that is)</li>
<li>When it’s time to join the trend (buy or sell respectively)</li>
<li>When it’s time to exit the existing<a id="_idIndexMarker830"/> position (so we expect the trend to end and/or reverse)</li>
</ul>
<p>Let’s understand more in the upcoming sections.</p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor206"/>Determining a trend, part 1 – market model</h2>
<p>If I ask you whether it’s sunny<a id="_idIndexMarker831"/> or rainy outdoors, I’m sure you won’t hesitate with an answer<a id="_idIndexMarker832"/> in most cases. You can easily tell one from another because you are very familiar with a number of attributes that help you make the decision. Indeed, it’s easy to tell light from darkness, warmth from cold, moisture from dryness, and so on.</p>
<p>Now, say I ask you whether it’s slightly rainy or foggy and do so in the middle of the night. I imagine you’d have a really hard time telling one from another. Most likely, you would even go outside, try to feel the air on your skin and smell the air, and finally return with something such as <em class="italic">“well, it seems to be rain.”</em> In this case, you had to do several tests and use their results to make your judgment.</p>
<p>Why were you able to do these tests and use their results?</p>
<p>Because you have a <em class="italic">model</em> in your mind, a model of the weather. You wouldn’t think about it unless it’s your profession and, in most cases, you make decisions intuitively and instantly. However, if put under pressure, you can find some more or less formal attributes – such as humidity, temperature, and wind – to decide upon the weather, again within the framework of the weather model.</p>
<p>Let’s now develop a model of market trends following the same example with the weather.</p>
<p>First, and above all, we should decide whether trends are something that always exists or occurs only at times. If we compare both models (permanent trends and occasional trends) with our weather example, we will see the following parallels:</p>
<table class="T---Table _idGenTablePara-1" id="table001-2">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><strong class="bold">Market</strong></p>
</td>
<td class="T---Table T---Body T---Body">
<p><strong class="bold">Weather</strong></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p>The market is always in an uptrend or downtrend. Trends may be more or less visible.</p>
</td>
<td class="T---Table T---Body T---Body">
<p>The wind blows all the time, only sometimes stronger and other times weaker.</p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p>The market can be in <em class="italic">trend mode</em> or <em class="italic">non-trend</em> mode.</p>
</td>
<td class="T---Table T---Body T---Body">
<p>Sometimes the wind blows and other times the wind doesn’t blow at all.</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 12.1 – Drawing parallels between market trends and the weather</p>
<p>Despite looking quite simple, this table<a id="_idIndexMarker833"/> perfectly illustrates the fundamental difference<a id="_idIndexMarker834"/> in approaches to modeling the process (market or weather). It is up to the model’s developer to decide either that the observed process can only be in one state (only in trend; only wind blowing) or that it can be in multiple states (trend or non-trend in the market example; windy or not windy in the weather example).</p>
<p>This said, we come to a very important conclusion.</p>
<p>There is no such thing as a <em class="italic">true</em> or <em class="italic">false</em> model. A model only tries to explain the observed phenomena with certain precision and serves the purpose of making decisions.</p>
<p>So, the ability of a model to help make a practical decision is the only criterion of the model’s validity. If looking outside the window is enough to know how to dress for the day, then the weather model is valid. If you make decisions whether to take an umbrella with you by consulting sophisticated equipment and still regularly get wet to the skin, most likely, the model used in this sophisticated equipment is not valid.</p>
<p>In the market, the situation is similar. If we can suggest a simplistic market model that nevertheless is able to consistently outperform a benchmark (see <a href="B19145_09.xhtml#_idTextAnchor152"><em class="italic">Chapter 9</em></a>, <em class="italic">Trading Strategies and Their Core Elements</em>), then this is an acceptable model. At the same time, we may have an extremely sophisticated model that uses artificial intelligence and quantum mechanics, but if in the long run it doesn’t beat the market, then it may only be interesting from an academic standpoint.</p>
<p>As we’re making our first steps in algo trading, let’s start with something simple. We can make our model more complicated later if a simplistic model doesn’t work.</p>
<p>In our present case, we should make a decision regarding how we model the market from a trending standpoint:</p>
<ul>
<li>The market is always in a trend, up or down; it’s just the duration of these trends that may be long or short</li>
<li>The market is in either a trend or non-trend state, and we should distinguish between the two before determining an uptrend or downtrend</li>
</ul>
<p>Of course, the first model is simpler: we don’t need to suggest a method to tell trend from non-trend, focusing now only on technical setups that tell an uptrend from a downtrend. Again, if this approach doesn’t work, we can return to this decision point, change our model, and start the research all over.</p>
<p>So, we have decided upon the first point in our checklist: we choose the <em class="italic">always-in-trend</em> market model for further research.</p>
<p>Now that we have decided<a id="_idIndexMarker835"/> upon the market model, let’s move on to finding a proper tool <a id="_idIndexMarker836"/>to distinguish an uptrend from a downtrend. Again, we start this step with the simplest solution: moving averages.</p>
<h2 id="_idParaDest-206"><a id="_idTextAnchor207"/>Determining a trend, part 2 – moving averages</h2>
<p>One of the classical technical<a id="_idIndexMarker837"/> analysis studies typically used to determine<a id="_idIndexMarker838"/> trends is the moving average. In <a href="B19145_07.xhtml#_idTextAnchor114"><em class="italic">Chapter 7</em></a>, <em class="italic">Technical Analysis and Its Implementation in Python</em>, we already considered moving averages and found that they act as digital filters that eliminate higher frequencies (short-term price fluctuations) and keep lower frequencies, which we consider as dominating long-term tendencies in price movements. Let’s quickly refresh our knowledge of this by plotting a 20-period moving average (MA20) over a price chart.</p>
<div><div><img alt="Figure 12.1 – 20-period moving average on top of a 1-minute chart of EURJPY. Chart by Multicharts" src="img/B19145_12_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – 20-period moving average on top of a 1-minute chart of EURJPY. Chart by Multicharts</p>
<p>We can see that sometimes, the bars’ closing prices tend to remain above the MA20, while sometimes they are below it. It is reasonable to suppose that as long as these closing prices remain above the MA20, the market is in an uptrend, and while they remain below it, it is in a downtrend.</p>
<p>The problem with this technical<a id="_idIndexMarker839"/> setup is that sometimes prices remain<a id="_idIndexMarker840"/> above or below a moving average for too short a period of time. We already agreed that in our model the market is always in trend and we do not separate any special non-trending condition. However, maybe there’s a better technical setup, something that would better indicate an uptrend or downtrend without so many <em class="italic">short-term trends</em>, which we intuitively wouldn’t like to even call <em class="italic">trends</em>.</p>
<p>Yes, there is, and this is one of the oldest classical technical trading setups: we use two moving averages, one with a short period and another one with a long period. Then, we consider an uptrend only when both of the following two conditions are met:</p>
<ul>
<li>The price is above the short-period moving average</li>
<li>The short-period moving average is itself above the long-period moving average</li>
</ul>
<p>It is similar for downtrends:</p>
<ul>
<li>The price is below the short-term moving average</li>
<li>The short-period moving average is itself below the long-period moving average</li>
</ul>
<p>Let’s see what it may look like on a chart.</p>
<div><div><img alt="Figure 12.2 – Adding a longer-term moving average helps exclude unwanted situations" src="img/B19145_12_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Adding a longer-term moving average helps exclude unwanted situations</p>
<p>In the preceding figure, I added<a id="_idIndexMarker841"/> a 50-period moving average (MA50) to the existing<a id="_idIndexMarker842"/> MA20 and zoomed the figure in to see more details. The area encompassed by a dotted oval illustrates how adding the second moving average may filter out certain (but, of course, not all) unwanted situations. If we decide whether it’s an uptrend or a downtrend only by closing prices being above or below MA20, then during the phase shown in <em class="italic">Figure 12</em><em class="italic">.2</em>, we would have to decide whether there was a downtrend. However, if we use a setup with both requirements as we suggested previously (that the price should be below MA20 and MA20 should be below MA50), then we can qualify it neither as an uptrend nor as a downtrend. So, in the trade logic, we simply skip this interval – and then we can see that the following price movement develops into a <em class="italic">true</em> uptrend.</p>
<p>Great, now we have covered<a id="_idIndexMarker843"/> two points in our list– we know when there’s a trend<a id="_idIndexMarker844"/> in the market and know its direction. Now we need to decide when we actually enter and exit a position in the market.</p>
<h2 id="_idParaDest-207"><a id="_idTextAnchor208"/>Entry and exit rules</h2>
<p>After all the elements of a technical trading<a id="_idIndexMarker845"/> setup are determined, the key <a id="_idIndexMarker846"/>question remains of when to actually enter and exit a position. In some cases, it may be a non-trivial question and the answer to it may seriously affect the resulting performance of a strategy. However, within our simplistic model, we can assume that we can enter the market as soon as the trend conditions are met. This means that we open a new long position when the following apply:</p>
<ul>
<li>The bar’s closing price is above the short-period moving average</li>
<li>The short-period moving average is above the long-period moving average</li>
<li>Currently, we don’t have a long position in the market (so we don’t add to an existing position, and we don’t buy more if we’re already long)</li>
</ul>
<p>As to exiting from an open position – again, within our market model there’s no need to actually exit a position because the model assumes that the market is always in a trend. So, we exit a long position only when we open a short position and vice versa.</p>
<p>In other words, we plan a strategy that is <em class="italic">always in the market</em> and changes the trade’s direction as soon as the change in the trend is detected.</p>
<p>As with the market model, we can change this approach later, if testing the current simplistic model doesn’t produce acceptable results.</p>
<h2 id="_idParaDest-208"><a id="_idTextAnchor209"/>Money management</h2>
<p><strong class="bold">Money management</strong> means how much you trade with each<a id="_idIndexMarker847"/> new order. There are many money management<a id="_idIndexMarker848"/> theories and techniques, from very simple to quite sophisticated. Unfortunately, we cannot really cover all of them in one chapter – it would require a separate book! But since we are keeping things simple at the moment and are more interested in learning how the trade logic works in general, let’s use the most simplistic money management concept as well: we will use the same constant trading size for all trades, doubling it when we should make a reversal from long to short or from short to long. We already did that in the previous chapter when we developed our backtesting platform.</p>
<p>The rule of thumb is: if your strategy performs acceptably well with a constant trading size, its performance may be improved with money management. If the strategy doesn’t perform well with constant trading size then attempts to improve its performance by using various money management rules fail most of the time.</p>
<p>So, we have successfully covered the four key points that we outlined at the beginning of this chapter:</p>
<ul>
<li>We know when the market is in trend</li>
<li>We know the trend’s direction</li>
<li>We know when to enter the market</li>
<li>We know when to exit it</li>
</ul>
<p>Plus, we also know how much we have at stake with each trade.</p>
<p>Great, now we can proceed<a id="_idIndexMarker849"/> to choose the market we’re going to trade<a id="_idIndexMarker850"/> using trend-following and prepare the data.</p>
<h1 id="_idParaDest-209"><a id="_idTextAnchor210"/>Choosing the market and preparing data</h1>
<p>There is one very common<a id="_idIndexMarker851"/> misconception regarding systematic trading: it is believed that a technical trading<a id="_idIndexMarker852"/> strategy should work in any market. I hope that the previous chapters have already dispelled this myth. Just as an example, let’s recall the famous EURCHF market while the Swiss national bank was keeping the rate of the Swiss franc pegged to the euro (see <a href="B19145_09.xhtml#_idTextAnchor152"><em class="italic">Chapter 9</em></a>, <em class="italic">Trading Strategies and Their Core Elements</em>) – go and trade it using trend-following if the price virtually doesn’t move at all!</p>
<p>Even if we set aside such extreme examples, anyway, choosing the market can be a non-trivial task. Most of the time, we have to try many markets even if we can make an educated guess about which should perform better with a specific kind of strategy. However, there are some general guidelines that we are going to use now.</p>
<p>First, since we’re focused on trend-following, we would like to trade a market that is full of trends (however much it may sound like a truism). If we are in the FX domain, we may want to focus on currency pairs with the greatest difference in the interest rates between the two currencies (see the <em class="italic">Fundamental analysis</em> section of <a href="B19145_06.xhtml#_idTextAnchor101"><em class="italic">Chapter 6</em></a>, <em class="italic">Basics of Fundamental Analysis and Its Possible Use in FX Trading</em>, for a brief discussion on interest rates and carry trading) because this is one of the very few factors that may lead to forming a more or less long-term trend. So, pairs with currencies such as the Australian dollar or the New Zealand dollar versus the Japanese yen or even the US dollar (especially when the US rates were low) may be good to start with.</p>
<p>Another reason to choose the Australian dollar for trading with a trend-following strategy is that the Australian economy is dependent on gold production, much like the Canadian economy depends on oil (though perhaps to a lesser extent). As a result, the rate of the Australian dollar is prone to corresponding changes in the price of gold and other export commodities. Since commodity prices exhibit cyclic behavior due to manufacturing cycles, we can see this reflected in AUDUSD or AUDJPY. Therefore, with these two considerations in mind, choosing AUDUSD as the first currency pair to try a trend-following strategy seems like a natural choice.</p>
<p>Second, we should decide upon the timeframe or data resolution. Although the previous sample charts with moving averages were made using a resolution of 1 minute, intraday data is not really good for trend-following strategies. The reason is that intraday the FX market exhibits strongly cyclical behavior in volatility patterns (see the <em class="italic">Liquidity and volatility – how one transforms into another</em> section of <a href="B19145_03.xhtml#_idTextAnchor044"><em class="italic">Chapter 3</em></a>, <em class="italic">FX Market Overview from a Developer’s Standpoint</em>). These markets are active during the daytime and slow during the night. This periodicity will produce many <em class="italic">false trends</em> and make the task of determining a <em class="italic">true trend</em> significantly more difficult. At the same time, the daily timeframe is free from this feature and we may expect more steady trending behavior with this data resolution (of course, depending on whether the market is prone to trending at all). So, when we have a choice of making our model more complicated by adding a module to the trading logic, which would distinguish between <em class="italic">true</em> and <em class="italic">false</em> trends, we’d rather use data with higher resolution to eliminate the problem completely.</p>
<p>Thus, we have decided<a id="_idIndexMarker853"/> upon the market (let’s start with AUDUSD) and the dat<a id="_idIndexMarker854"/>a resolution (daily). As always, let me note that if we get unsatisfactory results, we can try different markets and timeframes.</p>
<p>Now that we have settled upon all the prerequisites, let’s get to coding.</p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor211"/>Compressing data to a daily timeframe</h2>
<p>Let’s start with writing<a id="_idIndexMarker855"/> a simple utility that would compress the market data to the required resolution and convert it into the desired format, compatible with our backtesting and live trading code (see <a href="B19145_11.xhtml#_idTextAnchor186"><em class="italic">Chapter 11</em></a>, <em class="italic">Backtesting and Theoretical Performance</em>). We will use the <code>getBarRealtime()</code> function from the live version and slightly adapt it as a stand-alone utility.</p>
<p>This utility should do the following:</p>
<ul>
<li>Read the source data file (tick or 1-minute bars)</li>
<li>Aggregate data into any greater timeframe</li>
<li>Save data to disk using a format compatible with the backtester</li>
</ul>
<p>As always, we start with imports:</p>
<pre class="source-code">
import csv
from datetime import datetime</pre>
<p>We add a sliding window class similar to the one we used in <a href="B19145_06.xhtml#_idTextAnchor101"><em class="italic">Chapter 6</em></a>, <em class="italic">Basics of Fundamental Analysis and Its Possible Use in FX Trading</em>, but we will use it in a bit of a different way: to store values of any parameter (price, time, volume, or whatever) on the current bar and the previous bar. Thus, we add two respective methods to quickly retrieve these values:</p>
<pre class="source-code">
class slidingWindow:
    def __init__(self, len):
        self.data = [0 for i in range(len)]
    def add(self, element):
        self.data.pop(0)
        self.data.append(element)
    def last(self):
        return self.data[-1]
    def previous(self):
        return self.data[-2]</pre>
<p>Then, we specify the source file and the destination file and read the saved data (tick or 1 minute) – pretty much like we did in the previous chapter:</p>
<pre class="source-code">
source_file = open("LMAX AUD_USD 1 Minute.txt")
dest_file = open("AUDUSD_daily.csv", "w")
csvFile = csv.DictReader(source_file)
all_data = list(csvFile)</pre>
<p>We immediately write the first line to the destination file – this line will act as a header for further processing the file as a CSV:</p>
<pre class="source-code">
dest_file.write(("Date,Time,Open,High,Low,Close\n"))</pre>
<p>Then, we create an instance of the <code>slidingWindow</code> class and initiate the first bar, which we’re going to aggregate and then save to the destination file:</p>
<pre class="source-code">
timestamp = slidingWindow(2)
bar = {'Open': 0, 'High': 0, 'Low': 0, 'Close': 0}</pre>
<p>Now, we start iterating over all samples in the source file, convert the data, and add the timestamp to the timestamp<a id="_idIndexMarker856"/> sliding window:</p>
<pre class="source-code">
for sample in all_data:
    open = float(sample[' &lt;Open&gt;'])
    high = float(sample[' &lt;High&gt;'])
    low = float(sample[' &lt;Low&gt;'])
    close = float(sample[' &lt;Close&gt;'])
    ts = datetime.strptime(sample['&lt;Date&gt;'] + 'T' + sample[' &lt;Time&gt;'] + 'Z', "%m/%d/%YT%H:%M:%SZ")
    timestamp.add(ts)</pre>
<p class="callout-heading">Note</p>
<p class="callout">The header format of the source file may be different. In the files that I use in this book, there are at least two different formats: plain words (<code>'Open'</code>, <code>'High'</code>, etc.) and words in triangle brackets (<code>&lt;Open&gt;</code>, etc.). Be careful and don’t forget to adapt this piece of code to the source data you’re going to use yourself!</p>
<p>If the date of the timestamp is not equal to that of the previous timestamp – meaning that a new day had started – we save the updated daily bar to the destination file and reinitialize the bar:</p>
<pre class="source-code">
    if timestamp.previous() != 0:
        if timestamp.last().date() != timestamp.previous().date():
            if bar['Open'] != 0:
                dest_file.write(','.join(map(str,[*bar.values()])) + "\n")
            bar = {'Date': timestamp.last().date(), 'Time': timestamp.last().time(), 'Open': open, 'High': high, 'Low': low, 'Close': close}</pre>
<p>Finally, we update<a id="_idIndexMarker857"/> the currently forming bar:</p>
<pre class="source-code">
    bar['High'] = max([bar['High'], high])
    bar['Low'] = min([bar['Low'], low])
    bar['Close'] = close
    bar['Time'] = timestamp.last().time()</pre>
<p>Don’t forget to close the destination file after the <code>for</code> loop has finished:</p>
<pre class="source-code">
dest_file.close()</pre>
<p>If you run this code using the same AUDUSD 1-minute historical data as I used (you can find it on GitHub along with the code), you will get a CSV file with daily bars where the <code>'Time'</code> column features two different times: <code>17:00</code> and <code>23:59</code>. Why is that?</p>
<p>In fact, this is a very important question that deserves an insightful answer.</p>
<h2 id="_idParaDest-211"><a id="_idTextAnchor212"/>Be careful with time!</h2>
<p>No, this doesn’t mean that<a id="_idIndexMarker858"/> you should be looking at your watch every other minute. It means that when working with market data, time is the very thing that leads to confusion, especially in cases where you work with data from decentralized markets such as forex.</p>
<p>Working with data from a centralized exchange is somewhat easier: in this case, we always know in which time zone the exchange is located and its working hours. So, in any market data from that exchange, all timestamps will be in the same time zone as the exchange and only between market open and close.</p>
<p>With forex, it’s different. We know that there’s no single exchange in this market and that it works almost 24 hours, 5 days a week.</p>
<p><em class="italic">Almost</em>, mind you.</p>
<p>First, we must consider time zones. Every FX data vendor and every FX broker may deliver data in any time zone they think is correct. Most frequently used are GMT (UTC) or BST (UTC+1) for London, CET (UTC+1) or CEST (UTC+2) for Frankfurt, and EST (UTC-5) or EDT (UTC-4) for New York. You should check the data source about the time zone used before you do any manipulations with timestamps.</p>
<p>Second, we must consider working hours. Most FX trading venues open on Sunday at around 5 p.m. New York time (New York bank settlement time; see the <em class="italic">FX instruments</em> section of <a href="B19145_03.xhtml#_idTextAnchor044"><em class="italic">Chapter 3</em></a>, <em class="italic">FX Market Overview from a Developer’s Standpoint</em>), but some may open at a later time. Same with the market close before the weekend: most venues close on Friday at that same time of 5 p.m. in New York, but some even offer weekend trading. We can’t consider this weekend trading seriously because the trading volume for weekend deals is negligible, but you may get hold of market data from a venue which provides weekend trading and this weekend data will add quite some confusion to your research process. If you plan to trade exotic currencies, most likely they will only be traded during the work hours of the respective state central bank or just a bit longer.</p>
<p>Besides regular working hours, there are exceptions, mostly around holidays. For example, don’t be surprised if you see an early close before or a late open after Christmas.</p>
<p>Third, we must consider how 0:00 time is interpreted. Some data providers treat this time as the start of a new day, while others believe it refers to the previous day. Moreover, some data providers even don’t have such a timestamp and the last time of the day in their data is 23:59 (for 1-minute data).</p>
<p>This 0:00 time is quite confusing. When we work with data compressed in bars, the bar’s timestamp means the time when the bar closes. Therefore, 0:00 means that the bar closed at midnight. But it still represents price movements that happened before midnight, so they belong to the day that just finished! So, if you want to be absolutely precise when working with time, you may want to add some additional checks to your code that take into account the issues we’ve just discussed.</p>
<p>Now, let’s look at the data we used in our example and see what we actually did. This data is in the New York time zone, so the last time of the week is 17:00 – and this is what we see in the compressed daily data for every Friday. This data provider treats 0:00 as the first time of the new day, so since we divide days by date and do not take time into consideration, the last time of a day is now 23:59.</p>
<p>We may want to modify the new day conditions in the code of the bar-making utility. One of the possible solutions could be a condition like this:</p>
<pre class="source-code">
if (timestamp.last().date() != timestamp.previous().date() and str(timestamp.last().time()) != '00:00:00') or (str(timestamp.previous().time()) == '00:00:00'):</pre>
<p>If we now run the modified <a id="_idIndexMarker859"/>code, we get correctly compressed data, but keep in mind that 0:00 timestamps now denote the end of the day, not its beginning!</p>
<p>Now we have all the data prepared and it’s time to try writing the code for our first strategy.</p>
<h1 id="_idParaDest-212"><a id="_idTextAnchor213"/>Trend-following strategy – implementation</h1>
<p>Since we’re going to use<a id="_idIndexMarker860"/> the backtesting code that we developed in the previous chapter (see the <em class="italic">Backtesting platform with historical data feed</em> section in <a href="B19145_11.xhtml#_idTextAnchor186"><em class="italic">Chapter 11</em></a>, <em class="italic">Backtesting and Theoretical Performance</em>), we need to add only small pieces of code that support the required objects.</p>
<p class="callout-heading">Note</p>
<p class="callout">Don’t forget to change the data source to the file with the daily AUDUSD data that we’ve just created!</p>
<p>Let’s start with adding the <code>slidingWindow</code> class to implement moving averages. Obviously, we copy it from the code in the preceding section. The code (as usual with class declaration) goes somewhere after the imports and before the declaration of the first function:</p>
<pre class="source-code">
class slidingWindow:
    def __init__(self, len):
        self.data = [0 for i in range(len)]
    def add(self, element):
        self.data.pop(0)
        self.data.append(element)</pre>
<p>As you progress in developing various strategies, sooner or later you will find that many classes or functions are used in most strategies, so you can move them to a separate module and import the module into any strategy prototype.</p>
<p>We add two sliding windows to implement moving averages:</p>
<pre class="source-code">
data_window_small = slidingWindow(5)
data_window_large = slidingWindow(20)</pre>
<p>Why <code>5</code> and <code>20</code> for periods of moving <a id="_idIndexMarker861"/>averages? Well, no real reason in particular: when we work with daily data, <code>5</code> is usually used to represent a work week and <code>20</code> a work month. These values can often be found in technical analysis studies. Other popular periods are <code>50</code> (for a quarter) and <code>200</code> (for a year). In any case, this is only a draft, so we will be able to modify these values later, after having evaluated the strategy performance.</p>
<p>Then we have the function that actually calculates a moving average:</p>
<pre class="source-code">
def moving_average(data):
    return sum(data) / len(data)</pre>
<p>All that we need to modify now is part of the <code>tradeLogic()</code> function. It is the block of code between the <code>trade logic starts here</code> and <code>trade logic ends </code><code>here</code> comments:</p>
<pre class="source-code">
        ####################################
        #     trade logic starts here     #
        ####################################</pre>
<p>First of all, we retrieve a new closing price and add it to both sliding windows. Then we calculate the moving averages:</p>
<pre class="source-code">
        close = bar['Close']
        data_window_small.add(close)
        data_window_large.add(close)
        ma_small = moving_average(data_window_small.data)
        ma_large = moving_average(data_window_large.data)</pre>
<p>Now the main part: the entry<a id="_idIndexMarker862"/> condition. We sell if the close is below the short-period MA and the short-period MA is below the long-period MA. Don’t forget that we do that only if we don’t have an open short position already (see the <em class="italic">Trading application with live data feed</em> section in <a href="B19145_11.xhtml#_idTextAnchor186"><em class="italic">Chapter 11</em></a>, <em class="italic">Backtesting and </em><em class="italic">Theoretical Performance</em>):</p>
<pre class="source-code">
        if close &lt; ma_small and ma_small &lt; ma_large and System.market_position &gt;= 0:</pre>
<p>The rest of the trade logic code in the <code>'Sell'</code> clause remains untouched, and I have reproduced it here only to maintain integrity:</p>
<pre class="source-code">
            order = {}
            order['Type'] = 'Market'
            order['Price'] = close
            order['Side'] = 'Sell'
            if System.market_position == 0:
                order['Size'] = 10000
            else:
                order['Size'] = 20000
            orders_stream.put(order)</pre>
<p>And symmetrical for a buy order: we buy when the close is greater than the short-period MA and the short-period MA is greater than the long-period MA:</p>
<pre class="source-code">
        if close &gt; ma_small and ma_small &gt; ma_large and System.market_position &lt;= 0:
            order = {}
            order['Type'] = 'Market'
            order['Price'] = close
            order['Side'] = 'Buy'
            if System.market_position == 0:
                order['Size'] = 10000
            else:
                order['Size'] = 20000
            orders_stream.put(order)
        ####################################
        #      trade logic ends here      #
        ####################################</pre>
<p>This is it. Nothing else needs any modification.</p>
<p>Are you ready to test your first<a id="_idIndexMarker863"/> trading strategy? Let’s run the code and look at the equity curve.</p>
<p>If you did everything correctly so far, you should see an equity curve similar to the one shown in <em class="italic">Figure 12</em><em class="italic">.3</em>.</p>
<div><div><img alt="Figure 12.3 – Equity curve of the backtest of the trend-following strategy using AUDUSD daily data" src="img/B19145_12_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Equity curve of the backtest of the trend-following strategy using AUDUSD daily data</p>
<p>Not a bad start! In <a href="B19145_11.xhtml#_idTextAnchor186"><em class="italic">Chapter 11</em></a>, <em class="italic">Backtesting and Theoretical Performance</em>, we talked about the equity curve and noted that traders (and investors, above all!) are looking for strategies that demonstrate consistent growth over time. Since our equity curve is a representation of our trend-following strategy PnL day by day, we can agree that this strategy indeed demonstrates growth in equity.</p>
<p>However, this result raises<a id="_idIndexMarker864"/> further questions. What is the meaning of the numbers on the <em class="italic">x</em> and <em class="italic">y</em> axes? How do we interpret this result in terms of money or percent growth? Can we say that the growth demonstrated by the backtest is consistent? These and other questions will be discussed in the very next chapter.</p>
<h1 id="_idParaDest-213"><a id="_idTextAnchor214"/>Summary</h1>
<p>Let’s quickly recap what we learned in this chapter. It indeed is the ultimate point where all the knowledge and skills we obtained in previous chapters unite and transform into a working trading application. More than that, in fact, we’ve got now a scalable <em class="italic">trading platform</em> suitable for both research and live trading. We suggested a robust design of the platform that keeps the architecture modular and scalable. We learned how to synchronize threads to ensure the correct order of execution of the platform modules while keeping these modules isolated. We saw practical examples of using various data sources that allow the platform to work with both live data feeds and historical data. We completely isolated the trade logic from the rest of the app so now we can develop a strategy using a backtest and then immediately copy and paste the code into the production version of our platform. Finally, using our knowledge of FX markets from previous chapters, we developed a simple trend-following strategy, tested it, and saw a promising result.</p>
<p>Now it’s time to analyze our result to get a full understanding of the strategy’s behavior and performance.</p>
</div>
</body></html>