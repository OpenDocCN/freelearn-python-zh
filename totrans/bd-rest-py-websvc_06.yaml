- en: Chapter 6.  Working with Models, SQLAlchemy, and Hyperlinked APIs in Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will expand the capabilities of the RESTful API that we
    started in the previous chapter. We will use SQLAlchemy as our ORM to work with
    a PostgreSQL database and we will take advantage of advanced features included
    in Flask and Flask-RESTful that will allow us to easily organize code for complex
    APIs, such as models and blueprints. In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Design a RESTful API to interact with a PostgreSQL database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the tasks performed by each HTTP method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install packages to simplify our common tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and configure the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write code for the models with their relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use schemas to validate, serialize, and deserialize models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine blueprints with resourceful routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register the blueprint and run migrations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and retrieve related resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a RESTful API to interact with a PostgreSQL database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our RESTful API has performed CRUD operations on a simple dictionary
    that acted as a data repository. Now, we want to create a more complex RESTful
    API with Flask RESTful to interact with a database model that has to allow us
    to work with messages that are grouped into message categories. In our previous
    RESTful API, we used a string attribute to specify the message category for a
    message. In this case, we want to be able to easily retrieve all the messages
    that belong to a specific message category, and therefore, we will have a relationship
    between a message and a message category.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must be able to perform CRUD operations on different related resources and
    resource collections. The following list enumerates the resources and the class
    name that we will create to represent the model:'
  prefs: []
  type: TYPE_NORMAL
- en: Message categories (`Category` model)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messages (`Message` model)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The message category (`Category`) just requires an integer name, and we need
    the following data for a message (`Message`):'
  prefs: []
  type: TYPE_NORMAL
- en: An integer identifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A foreign key to a message category (`Category`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A string message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The duration in seconds that will indicate the time the message has to be printed
    on the OLED display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The creation date and time. The timestamp will be added automatically when adding
    a new message to the collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integer counter that indicates the times the message has been printed in
    the OLED display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `bool` value indicating whether the message was printed at least once on the
    OLED display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will take advantage of the many packages related to Flask RESTful and SQLAlchemy
    that make it easier to serialize and deserialize data, perform validations, and
    integrate SQLAlchemy with Flask and Flask RESTful.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the tasks performed by each HTTP method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows the HTTP verbs, the scope, and the semantics for
    the methods that our new API must support. Each method is composed of an HTTP
    verb, a scope, and all the methods have well-defined meanings for all the resources
    and collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP verb** | **Scope** | **Semantics** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Collection of message categories | Retrieve all the stored message
    categories in the collection and return them sorted by their name in ascending
    order. Each category must include the full URL for the resource. Each category
    must include a list with all the details for the messages that belong to the category.
    The messages don''t have to include the category in order to avoid repeating data.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Message category | Retrieve a single message category. The category
    must include the same information explained for each category when we retrieve
    a collection of message category. |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Collection of message categories | Create a new message category
    in the collection. |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Message category | Update the name of an existing message category.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Message category | Delete an existing message category. |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Collection of messages | Retrieve all the stored messages in the
    collection, sorted by their message in ascending order. Each message must include
    its message category details, including the full URL to access the related resource.
    The message category details don''t have to include the messages that belong to
    the category. The message must include the full URL to access the resource. |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Message | Retrieve a single message. The message must include the
    same information explained for each message when we retrieve a collection of messages.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Collection of messages | Create a new message in the collection.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Message | Update any of the following fields of an existing message:
    message, duration, printed_times, and printed_once. |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Message | Delete an existing message. |'
  prefs: []
  type: TYPE_TB
- en: In addition, our RESTful API must support the `OPTIONS` method for all the resources
    and collection of resources. We will use SQLAlchemy as our ORM and we will work
    with a PostgreSQL database. However, in case you don't want to spend time installing
    PostgreSQL, you can use any other database supported by SQLAlchemy, such as MySQL.
    In case you want the simplest database, you can work with SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding table, there are many methods and scopes. The following list
    enumerates the URIs for each scope mentioned in the preceding table, where `{id}`
    has to be replaced with the numeric id or primary key of the resource. As happened
    in the previous example, we want our API to differentiate collections from a single
    resource of the collection in the URLs. When we refer to a collection, we will
    use a slash (`/`) as the last character for the URL and when we refer to a single
    resource of the collection, we won''t use a slash (`/`) as the last character
    for the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Collection of message categories**: `/categories/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message category**: `/category/{id}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collection of messages**: `/messages/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message**: `/message/{id}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's consider that `http://localhost:5000/api/` is the URL for the API running
    on the Flask development server. We have to compose and send an HTTP request with
    the following HTTP verb (`GET`) and request URL (`http://localhost:5000/api/categories/`)
    to retrieve all the stored message categories in the collection. Each category
    will include a list with all the messages that belong to the category.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Installing packages to simplify our common tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure you quit Flask's development server. Remember that you just need to
    press ***Ctrl*** + ***C*** in the Terminal or Command Prompt window in which it
    is running. Now, we will install many additional packages. Make sure you have
    activated the virtual environment we have created in the previous chapter and
    we named `Flask01`. In case you created a new virtual environment to work with
    this example or you downloaded the sample code for the book, make sure you install
    the packages we used in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: After you activate the virtual environment, it is time to run commands that
    will be the same for either macOS, Linux, or Windows. We can install all the necessary
    packages with pip with a single command. However, we will run independent commands
    to make it easier to detect any problems in case a specific installation fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we must run the following command to install Flask-SQLAlchemy with pip.
    Flask-SQLAlchemy adds support for the SQLAlchemy ORM to Flask applications. This
    extension simplifies executing common SQLAlchemy tasks within a Flask application.
    SQLAlchemy is a dependency for Flask-SQLAlchemy, and therefore, pip will install
    it automatically, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines of the output will indicate all the packages that have been
    successfully installed, including `SQLAlchemy` and `Flask-SQLAlchemy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Run the following command to install Flask-Migrate with pip. Flask-Migrate uses
    the Alembic package to handle SQLAlchemy database migrations for Flask applications.
    We will use Flask-Migrate to set up our PostgreSQL database. Flask-Script is one
    of the dependencies for Flask-Migrate, and therefore, pip will install it automatically.
    Flask-Script adds support for writing external scripts in Flask, including scripts
    to set up a database.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines for the output will indicate all the packages that have been
    successfully installed, including `Flask-Migrate` and `Flask-Script`. The other
    installed packages are additional dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to install marshmallow with pip. Marshmallow is a
    lightweight library for converting complex datatypes to and from native Python
    datatypes. Marshmallow provides schemas that we can use to validate input data,
    deserialize input data to app-level objects, and serialize app-level objects to
    Python primitive types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines for the output will indicate `marshmallow` has been successfully
    installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to install Marshmallow-sqlalchemy with pip. Marshmallow-sqlalchemy
    provides SQLAlchemy integration with the previously installed marshmallow validation,
    serialization, and deserialization lightweight library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines for the output will indicate `marshmallow-sqlalchemy` has been
    successfully installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, run the following command to install Flask-Marshmallow with pip. Flask-Marshmallow
    integrates the previously installed `marshmallow` library with Flask applications
    and makes it easy to generate a URL and Hyperlink fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines for the output will indicate `Flask-Marshmallow` has been successfully
    installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Creating and configuring the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will create the PostgreSQL database that we will use as a repository
    for our API. You will have to download and install a PostgreSQL database in case
    you aren''t already running it in your computer or in a development server. You
    can download and install this database management system from its web page: [http://www.postgresql.org](http://www.postgresql.org).
    In case you are working with macOS, `Postgres.app` provides a really easy way
    to install and use PostgreSQL on this operating system: [http://postgresapp.com](http://postgresapp.com):'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have to make sure that the PostgreSQL bin folder is included in the `PATH`
    environmental variable. You should be able to execute the `psql` command-line
    utility from your current Terminal or Command Prompt. In case the folder isn't
    included in the PATH, you will receive an error indicating that the `pg_config`
    file cannot be found when trying to install the `psycopg2` package. In addition,
    you will have to use the full path to each of the PostgreSQL command-line tools
    we will use in the next steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the PostgreSQL command-line tools to create a new database named
    `messages`. In case you already have a PostgreSQL database with this name, make
    sure that you use another name in all the commands and configurations. You can
    perform the same task with any PostgreSQL GUI tool. In case you are developing
    on Linux, it is necessary to run the commands as the `postgres` user. Run the
    following command in macOS or Windows to create a new database named `messages`.
    Note that the command won''t produce any output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In Linux, run the following command to use the `postgres` user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will use the `psql` command-line tool to run some SQL statements to
    create a specific user that we will use in Flask and assign the necessary roles
    for it. In macOS or Windows, run the following command to launch psql:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In Linux, run the following command to use the postgres user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Then, run the following SQL statements and finally enter \q to exit the psql
    command-line tool. Replace user_name with your desired user name to use in the
    new database and password with your chosen password. We will use the user name
    and password in the Flask configuration. You don't need to run the steps in case
    you are already working with a specific user in PostgreSQL and you have already
    granted privileges to the database for the user. You will see the output indicating
    that the permission was granted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It is necessary to install the Psycopg 2 package (psycopg2). This package is
    a Python-PostgreSQL Database Adapter and SQLAlchemy will use it to interact with
    our recently created PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we made sure that the PostgreSQL `bin` folder is included in the PATH
    environmental variable, we just need to run the following command to install this
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines of the output will indicate that the `psycopg2` package has
    been successfully installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In case you are using the same virtual environment that we created for the previous
    example, the `api` folder already exists. If you create a new virtual environment,
    create a folder named `api` within the root folder for the created virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `config.py` file within the `api` folder. The following lines show
    the code that declares variables that determine the configuration for Flask and
    SQLAlchemy. The `SQL_ALCHEMY_DATABASE_URI` variable generates an SQLAlchemy URI
    for the PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you specify the desired database name in the value for `DB_NAME`
    and that you configure the user, password, host, and port based on your PostgreSQL
    configuration. In case you followed the previous steps, use the settings specified
    in these steps. The code file for the sample is included in the `restful_python_chapter_06_01`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We will specify the module created earlier as an argument to a function that
    will create a *Flask* app. This way, we have one module that specifies all the
    values for the different configuration variables and another module that creates
    a *Flask* app. We will create the Flask app factory as our final step towards
    our new API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating models with their relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will create the models that we can use to represent and persist the
    message categories, messages, and their relationships. Open the `api/models.py`
    file and replace its contents with the following code. The lines that declare
    fields related to other models are highlighted in the code listing. In case you
    created a new virtual environment, create a new `models.py` file within the `api`
    folder. The code file for the sample is included in the `restful_python_chapter_06_01`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: First, the code creates an instance of the `flask_sqlalchemy.SQLAlchemy` class
    named `db`. This instance will allow us to control the SQLAlchemy integration
    for our Flask application. In addition, the instance will provide access to all
    the SQLAlchemy functions and classes.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code creates an instance of the `flask_marshmallow.Marshmallow` class
    named `ma`. It is very important to create the `flask_sqlalchemy.SQLAlchemy` instance
    before the `Marshmallow` instance, and therefore, order matters in this case.
    Marshmallow is a wrapper class that integrates Mashmallow with a *Flask* application.
    The instance named `ma` will provide access to the `Schema` class, the fields
    defined in `marshmallow.fields`, and the Flask-specific fields declared in `flask_marshmallow.fields`.
    We will use them later when we declare the schemas related to our models.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code creates the `AddUpdateDelete` class that declares the following three
    methods to add, update, and delete a resource through SQLAlchemy sessions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add`: This method receives the object to be added in the `resource` argument
    and calls the `db.session.add` method with the received resource as an argument
    to create the object in the underlying database. Finally, the code commits the
    session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update`: This method just commits the session to persist the changes made
    to the objects in the underlying database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete`: This method receives the object to be deleted in the `resource` argument
    and calls the `db.session.delete` method with the received resource as an argument
    to remove the object in the underlying database. Finally, the code commits the
    session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code declares the following two models, specifically, two classes, as a
    subclass of both the `db.Model`, and the `AddUpdateDelete` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Message`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Category`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We specified the field types, maximum lengths, and defaults for many attributes.
    The attributes that represent fields without any relationship are instances of
    the `db.Column` class. Both models declare an `id` attribute and specify the `True`
    value for the `primary_key` argument to indicate it is the primary key. SQLAlchemy
    will use the data to generate the necessary tables in the PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Message` model declares the `category` field with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The previous line uses the db.relationship function to provide a many-to-one
    relationship to the Category model. The backref argument specifies a call to the
    db.backref function with 'messages' as the first value that indicates the name
    to use for the relation from the related Category object back to a Message object.
    The order_by argument specifies 'Message.message' because we want the messages
    for each category to be sorted by the value of the message field in ascending
    order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both models declare a constructor, that is, the `__init__` method. This constructor
    for the `Message` model receives many arguments and uses them to initialize the
    attributes with the same names: `message`, `duration`, and `category`. The constructor
    for the `Category` model receives a `name` argument and uses it to initialize
    the attribute with the same name.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating schemas to validate, serialize, and deserialize models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will create the Flask-Marshmallow schemas that we will use to validate,
    serialize, and deserialize the previously declared `Category` and `Message` models
    and their relationships. Open the `api/models.py` file and add the following code
    after the existing lines. The lines that declare the fields related to the other
    schemas are highlighted in the code listing. The code file for the sample is included
    in the `restful_python_chapter_06_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The code declares the following two schemas, specifically, two subclasses of
    the `ma.Schema` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CategorySchema`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MessageSchema`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't use the Flask-Marshmallow features that allow us to automatically determine
    the appropriate type for each attribute based on the fields declared in a model
    because we want to use specific options for each field. We declare the attributes
    that represent fields as instances of the appropriate class declared in the `marshmallow.fields`
    module. Whenever we specify the `True` value for the `dump_only` argument, it
    means that we want the field to be read-only. For example, we won't be able to
    provide a value for the `id` field in any of the schemas. The value for this field
    will be automatically generated by the auto-increment primary key in the database.
  prefs: []
  type: TYPE_NORMAL
- en: The `CategorySchema` class declares the `name` attribute as an instance of `fields.String`.
    The `required` argument is set to `True` to specify that the field cannot be an
    empty string. The `validate` argument is set to `validate.Length(3)` to specify
    that the field must have a minimum length of 3 characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class declares the `url` field with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `url` attribute is an instance of the `ma.URLFor` class, and this field
    will output the full URL of the resource, that is, of the message category resource.
    The first argument is the Flask endpoint name-`'api.categoryresource'`. We will
    create a `CategoryResource` class later and the `URLFor` class will use it to
    generate the URL. The `id` argument specifies `'<id>'` because we want the `id`
    to be pulled from the object to be serialized. The `id` string enclosed within
    less than (`<`) and greater than (`>`) symbols specifies that we want the field
    to be pulled from the object that has to be serialized. The `_external` attribute
    is set to `True` because we want to generate the full URL for the resource. This
    way, each time we serialize a `Category`, it will include the full URL for the
    resource in the `url` key.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case, we are using our insecure API behind HTTP. In case our API is
    configured with HTTPS, we should set the `_scheme` argument to `'https'` when
    we create the `ma.URLFor` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class declares the `messages` field with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `messages` attribute is an instance of the `marshmallow.fields.Nested` class,
    and this field will nest a collection of `Schema`, and therefore, we specify `True`
    for the `many` argument. The first argument specifies the name for the nested
    `Schema` class as a string. We declare the `MessageSchema` class after we defined
    the `CategorySchema` class. Thus, we specify the `Schema` class name as a string
    instead of using the type that we haven't defined yet.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we will end up with two objects that nest to each other, that is, we
    will create a two-way nesting between categories and messages. We use the `exclude`
    parameter with a tuple of string to indicate that we want the `category` field
    to be excluded from the fields that are serialized for each message. This way,
    we can avoid infinite recursion because the inclusion of the category field would
    serialize all the messages related to the category.
  prefs: []
  type: TYPE_NORMAL
- en: When we declared the `Message` model, we used the `db.relationship` function
    to provide a many-to-one relationship to the `Category` model. The `backref` argument
    specified a call to the `db.backref` function with `'messages'` as the first value
    that indicates the name to use for the relation from the related `Category` object
    back to a `Message` object. With the previously explained line, we created the
    messages fields that uses the same name we indicated for the `db.backref` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `MessageSchema` class declares the `message` attribute as an instance of
    `fields.String`. The `required` argument is set to `True` to specify that the
    field cannot be an empty string. The `validate` argument is set to `validate.Length(1)`
    to specify that the field must have a minimum length of 1 character. The class
    declares the `duration`, `creation_date`, `printed_times` and `printed_once` fields
    with the corresponding classes based on the types we used in the `Message` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class declares the `category` field with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `category` attribute is an instance of the `marshmallow.fields.Nested` class
    and this field will nest a single `CategorySchema`. We specify `True` for the
    `required` argument because a message must belong to a category. The first argument
    specifies the name for the nested `Schema` class. We already declared the `CategorySchema`
    class, and therefore, we specify `CategorySchema` as the value for the first argument.
    We use the only parameter with a list of string to indicate the field names that
    we want to be included when the nested `CategorySchema` is serialized. We want
    the `id`, `url`, and `name` fields to be included. We don't specify the `messages`
    field because we don't want the category to serialize the list of messages that
    belong to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class declares the `url` field with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `url` attribute is an instance of the `ma.URLFor` class and this field
    will output the full URL of the resource, that is, of the message resource. The
    first argument is the Flask endpoint name: `''api.messageresource''`. We will
    create a `MessageResource` class later and the `URLFor` class will use it to generate
    the URL. The `id` argument specifies `''<id>''` because we want the `id` to be
    pulled from the object to be serialized. The `_external` attribute is set to `True`
    because we want to generate the full URL for the resource. This way, each time
    we serialize a `Message`, it will include the full URL for the resource in the
    `url` key.'
  prefs: []
  type: TYPE_NORMAL
- en: The `MessageSchema` class declares a `process_category` method that uses the
    `@pre_load` decorator, specifically, `marshmallow.pre_load`. This decorator registers
    a method to invoke before deserializing an object. This way, before Marshmallow
    deserializes a message, the `process_category` method will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: The method receives the data to be deserialized in the `data` argument and it
    returns the processed data. When we receive a request to `POST` a new message,
    the category name can be specified in a key named `'category'`. If a category
    with the specified name exists, we will use the existing category as the one that
    is related to the new message. If a category with the specified name doesn't exist,
    we will create a new category and then we will use this new category as the one
    that is related to the new message. This way, we make it easy for the user to
    create new messages.
  prefs: []
  type: TYPE_NORMAL
- en: The `data` argument might have a category name specified as a string for the
    `'category'` key. However, in other cases, the `'category'` key will include the
    key-value pairs with the field name and field values for an existing category.
    The code in the `process_category` method checks the value for the `'category'`
    key and returns a dictionary with the appropriate data to make it sure that we
    are able to deserialize a category with the appropriate key-value pairs, no matter
    the differences of the incoming data. Finally, the methods returned the processed
    dictionary. We will dive deep on the work done by the `process_category` method
    later when we start composing and sending HTTP requests to the API.
  prefs: []
  type: TYPE_NORMAL
- en: Combining blueprints with resourceful routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will create the resources that compose our main building blocks for
    the RESTful API. First, we will create a few instances that we will use in the
    different resources. Then, we will create a `MessageResource` class, that we will
    use to represent the message resource. Create a new `views.py` file within the
    `api` folder and add the following lines. The code file for the sample is included
    in the `restful_python_chapter_06_01` folder, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The first lines declare the imports and create the following instances that
    we will use in the different classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`api_bp`: It is an instance of the `flask.Blueprint` class that will allow
    us to factor the Flask application into this blueprint. The first argument specifies
    the URL prefix on which we want to register the blueprint: `''api''`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`category_schema`: It is an instance of the `CategorySchema` class we declared
    in the `models.py` module. We will use `category_schema` to validate, serialize,
    and deserialize categories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message_schema`: It is an instance of the `MessageSchema` class we declared
    in the `models.py` module. We will use `message_schema` to validate, serialize
    and, deserialize categories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`api`: It is an instance of the `flask_restful.Api` class that represents the
    main entry point for the application. We pass the previously created `flask.Blueprint`
    instance named `api_bp` as an argument to link the `Api` to the `Blueprint`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `MessageResource` class is a subclass of `flask_restful.Resource` and declares
    the following three methods that will be called when the HTTP method with the
    same name arrives as a request on the represented resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get`: This method receives the id of the message that has to be retrieved
    in the `id` argument. The code calls the `Message.query.get_or_404` method to
    return an HTTP `404 Not Found` status in case there is no message with the requested
    id in the underlying database. In case the message exists, the code calls the
    `message_schema.dump` method with the retrieved message as an argument to use
    the `MessageSchema` instance to serialize the `Message` instance whose `id` matches
    the specified `id`. The `dump` method takes the `Message` instance and applies
    the field filtering and output formatting specified in the `MessageSchema` class.
    The code returns the `data` attribute of the result returned by the `dump` method,
    that is, the serialized message in JSON format as the body, with the default HTTP
    `200 OK` status code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete`: This method receives the id of the message that has to be deleted
    in the `id` argument. The code calls the `Message.query.get_or_404` method to
    return an HTTP `404 Not Found` status in case there is no message with the requested
    id in the underlying database. In case the message exists, the code calls the
    `message.delete` method with the retrieved message as an argument to use the `Message`
    instance to erase itself from the database. Then, the code returns an empty response
    body and a `204 No Content` status code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`patch`: This method receives the id of the message that has to be updated
    or patched in the `id` argument. The code calls the `Message.query.get_or_404`
    method to return an HTTP `404 Not Found` status in case there is no message with
    the requested id in the underlying database. In case the message exists, the code
    calls the `request.get_json` method to retrieve the key-value pairs received as
    arguments with the request. The code updates specific attributes in case they
    have new values in the `message_dict` dictionary in the `Message` instance: `message`.
    Then, the code calls the `message_schema.dump` method to retrieve any errors generated
    when serializing the updated message. In case there were errors, the code returns
    the errors and an HTTP `400 Bad Request` status. If the serialization didn''t
    generate errors, the code calls the `message_schema.validate` method to retrieve
    any errors generated while validating the updated message. In case there were
    validation errors, the code returns the validation errors and an HTTP `400 Bad
    Request` status. If the validation is successful, the code calls the update method
    for the Message instance to persist the changes in the database and returns the
    results of calling the previously explained `self.get` method with the id of the
    updated message as an argument. This way, the method returns the serialized updated
    message in JSON format as the body, with the default HTTP `200 OK` status code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will create a `MessageListResource` class that we will use to represent
    the collection of messages. Open the previously created `api/views.py` file and
    add the following lines. The code file for the sample is included in the `restful_python_chapter_06_01`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MessageListResource` class is a subclass of `flask_restful.Resource` and
    declares the following two methods that will be called when the `HTTP` method
    with the same name arrives as a request on the represented resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get`: This method returns a list with all the `Message` instances saved in
    the database. First, the code calls the `Message.query.all` method to retrieve
    all the `Message` instances persisted in the database. Then, the code calls the
    `message_schema.dump` method with the retrieved messages and the `many` argument
    set to `True` to serialize the iterable collection of objects. The `dump` method
    will take each `Message` instance retrieved from the database and apply the field
    filtering and output formatting specified the `MessageSchema` class. The code
    returns the `data` attribute of the result returned by the dump method, that is,
    the serialized messages in JSON format as the body with the default HTTP `200
    OK` status code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post`: This method retrieves the key-value pairs received in the JSON body,
    creates a new `Message` instance and persists it in the database. In case the
    specified category name exists, it uses the existing category. Otherwise, the
    method creates a new `Category` instance and associates the new message to this
    new category. First, the code calls the `request.get_json` method to retrieve
    the key-value pairs received as arguments with the request. Then, the code calls
    the `message_schema.validate` method to validate the new message built with the
    retrieved key-value pairs. Remember that the `MessageSchema` class will execute
    the previously explained `process_category` method before we call the validate
    method, and therefore, the data will be processed before the validation takes
    place. In case there were validation errors, the code returns the validation errors
    and an HTTP `400 Bad Request` status. If the validation is successful, the code
    retrieves the category name received in the JSON body, specifically in the value
    for the `''name''` key of the `''category''` key. Then, the code calls the `Category.query.filter_by`
    method to retrieve a category that matches the retrieved category name. If no
    match is found, the code creates a new `Category` with the retrieved name and
    persists in the database. Then, the code creates a new message with the `message`,
    `duration`, and the appropriate `Category` instance, and persists it in the database.
    Finally, the code returns the serialized saved message in JSON format as the body,
    with the HTTP `201 Created` status code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will create a `CategoryResource` class that we will use to represent
    a category resource. Open the previously created `api/views.py` file and add the
    following lines. The code file for the sample is included in the `restful_python_chapter_06_01`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CategoryResource` class is a subclass of `flask_restful.Resource` and
    declares the following three methods that will be called when the `HTTP` method
    with the same name arrives as a request on the represented resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get`: This method receives the id of the category that has to be retrieved
    in the `id` argument. The code calls the `Category.query.get_or_404` method to
    return an HTTP `404 Not Found` status in case there is no category with the requested
    id in the underlying database. In case the message exists, the code calls the
    `category_schema.dump` method with the retrieved category as an argument to use
    the `CategorySchema` instance to serialize the `Category` instance whose `id`
    matches the specified `id`. The `dump` method takes the `Category` instance and
    applies the field filtering and output formatting specified in the `CategorySchema`
    class. The code returns the `data` attribute of the result returned by the `dump`
    method, that is, the serialized message in JSON format as the body, with the default
    HTTP `200 OK` status code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`patch`: This method receives the id of the category that has to be updated
    or patched in the `id` argument. The code calls the `Category.query.get_or_404`
    method to return an HTTP `404 Not Found` status in case there is no category with
    the requested id in the underlying database. In case the category exists, the
    code calls the `request.get_json` method to retrieve the key-value pairs received
    as arguments with the request. The code updates just the name attribute in case
    it has a new value in the `category_dict` dictionary in the `Category` instance:
    `category`. Then, the code calls the `category_schema.validate` method to retrieve
    any errors generated when validating the updated category. In case there were
    validation errors, the code returns the validation errors and an HTTP `400 Bad
    Request` status. If the validation is successful, the code calls the update method
    for the `Category` instance to persist the changes in the database and returns
    the results of calling the previously explained `self.get` method with the id
    of the updated category as an argument. This way, the method returns the serialized
    updated message in JSON format as the body, with the default HTTP `200 OK` status
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete`: This method receives the id of the category that has to be deleted
    in the `id` argument. The code calls the `Category.query.get_or_404` method to
    return an HTTP `404 Not Found` status in case there is no category with the requested
    id in the underlying database. In case the category exists, the code calls the
    `category.delete` method with the retrieved category as an argument to use the
    `Category` instance to erase itself from the database. Then, the code returns
    an empty response body and a `204 No Content` status code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will create a `CategoryListResource` class that we will use to represent
    the collection of categories. Open the previously created `api/views.py` file
    and add the following lines. The code file for the sample is included in the `restful_python_chapter_06_01`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CategoryListResource` class is a subclass of `flask_restful.Resource`
    and declares the following two methods that will be called when the HTTP method
    with the same name arrives as a request on the represented resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get`: This method returns a list with all the `Category` instances saved in
    the database. First, the code calls the `Category.query.all` method to retrieve
    all the `Category` instances persisted in the database. Then, the code calls the
    `category_schema.dump` method with the retrieved messages and the `many` argument
    set to `True` to serialize the iterable collection of objects. The `dump` method
    will take each `Category` instance retrieved from the database and apply the field
    filtering and output formatting specified the `CategorySchema` class. The code
    returns the `data` attribute of the result returned by the dump method, that is,
    the serialized messages in JSON format as the body, with the default HTTP `200
    OK` status code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post`: This method retrieves the key-value pairs received in the JSON body,
    creates a new `Category` instance and persists it in the database. First, the
    code calls the `request.get_json` method to retrieve the key-value pairs received
    as arguments with the request. Then, the code calls the `category_schema.validate`
    method to validate the new category built with the retrieved key-value pairs.
    In case there were validation errors, the code returns the validation errors and
    an HTTP `400 Bad Request` status. If the validation is successful, the code creates
    a new category with the specified `name`, and persists it in the database. Finally,
    the code returns the serialized saved category in JSON format as the body, with
    the HTTP `201 Created` status code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table shows the method of our previously created classes that
    we want to be executed for each combination of HTTP verb and scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP verb** | **Scope** | **Class and method** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Collection of messages | MessageListResource.get |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Message | MessageResource.get |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Collection of messages | MessageListResource.post |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Message | MessageResource.patch |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Message | MessageResource.delete |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Collection of categories | CategoryListResource.get |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Message | CategoryResource.get |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Collection of messages | CategoryListResource.post |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Message | CategoryResource.patch |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Message | CategoryResource.delete |'
  prefs: []
  type: TYPE_TB
- en: If the request results in the invocation of a resource with an unsupported `HTTP`
    method, Flask-RESTful will return a response with the HTTP `405 Method Not Allowed`
    status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must make the necessary resource routing configurations to call the appropriate
    methods and pass them all the necessary arguments by defining URL rules. The following
    lines configure the resource routing for the api. Open the `api/views.py` file
    created earlier and add the following lines. The code file for the sample is included
    in the `restful_python_chapter_06_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Each call to the `api.add_resource` method routes a URL to a resource, specifically
    to one of the previously declared subclasses of the `flask_restful.Resource` class.
    When there is a request to the API and the URL matches one of the URLs specified
    in the `api.add_resource` method, Flask will call the method that matches the
    HTTP verb in the request for the specified class.
  prefs: []
  type: TYPE_NORMAL
- en: Registering the blueprint and running migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new `app.py` file within the `api` folder. The following lines show
    the code that creates a Flask application. The code file for the sample is included
    in the `restful_python_chapter_06_01` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The code in the `api/app.py` file declares a `create_app` function that receives
    the configuration file name in the `config_filename` argument, set ups a *Flask*
    app with this configuration file, and returns the `app` object. First, the function
    creates the main entry point for the Flask application named `app`. Then, the
    code calls the `app.config.from_object` method with the `config_filename` received
    as an argument. This way, the Flask app uses the values that are specified in
    the variables defined in the Python module received as an argument to set up the
    settings for the *Flask* app.
  prefs: []
  type: TYPE_NORMAL
- en: The next line calls the `init_app` method for the `flask_sqlalchemy.SQLAlchemy`
    instance created in the `models` module named `db`. The code passes app as an
    argument to link the created Flask app with the SQLAlchemy instance.
  prefs: []
  type: TYPE_NORMAL
- en: The next line calls the `app.register_blueprint` method to register the blueprint
    created in the `views` module, named `api_bp`. The url_prefix argument is set
    to `'/api'` because we want the resources to be available with `/api` as a prefix.
    Now `http://localhost:5000/api/` is going to be the URL for the API running on
    the Flask development server. Finally, the function returns the `app` object.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `run.py` file within the `api` folder. The following lines show
    the code that uses the previously defined create_app function to create a Flask
    application and run it. The code file for the sample is included in the `restful_python_chapter_06_01`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The code in the `api/run.py` file calls the `create_app` function, declared
    in the `app` module, with `'config'` as an argument. The function will set up
    a *Flask* app with this module as the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: The last line just calls the `app.run` method to start the Flask application
    with the host, port and debug values read from the `config` module. The code starts
    the application by calling the `run` method to immediately launch a local server.
    Remember that we could also achieve the same goal using the `flask` command-line
    script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `migrate.py` file within the `api` folder. The following lines
    show the code that use `flask_script` and `flask_migrate` to run migrations. The
    code file for the sample is included in the `restful_python_chapter_06_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The code creates an instance of `flask_migrate.Migrate` with the *Flask* app
    created in the previously explained `run` module, `app`, and the `flask_sqlalchemy.SQLAlchemy`
    instance created in the models module, `db`. Then, the code creates a `flask_script.Manager`
    class with the Flask app as an argument and saves its reference in the `manager`
    variable. The next line calls the `add_command` method with `'db'` and `MigrateCommand`
    as arguments. The main function calls the run method for the `Manager` instance.
  prefs: []
  type: TYPE_NORMAL
- en: This way, after the extension initializes, the code adds a db group to the command-line
    options. The db group has many sub-commands that we will use through the `migrate.py`
    script.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will run the scripts to run migrations and generate the necessary tables
    in the PostgreSQL database. Make sure you run the scripts in the terminal or Command
    Prompt window in which you have activated the virtual environment and that you
    are located in the `api` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Run the first script, that initializes migration support for the application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the sample output generated after running the previous
    script. Your output will be different according to the base folder in which you
    have created the virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The script generated a new `migrations` sub-folder within the `api` folder with
    a versions sub-folder and many other files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the second script that populates the migration script with the detected
    changes in the models. In this case, it is the first time we populate the migration
    script, and therefore, the migration script will generate the tables that will
    persist our two models: `Category` and `Message`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the sample output generated after running the previous
    script. Your output will be different according to the base folder in which you
    have created the virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output indicates that the `api/migrations/versions/417543056ac3_.py` file
    includes the code to create the `category` and `message` tables. The following
    lines show the code for this file that was automatically generated based on the
    models. Note that the filename will be different in your configuration. The code
    file for the sample is included in the `restful_python_chapter_06_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The code defines two functions: `upgrade` and `downgrade`. The `upgrade` function
    runs the necessary code to create the `category` and `message` tables by making
    calls to `alembic.op.create_table`. The `downgrade` function runs the necessary
    code to go back to the previous version.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the third script to upgrade the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the sample output generated after running the previous
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The previous script called the `upgrade` function defined in the automatically
    generated `api/migrations/versions/417543056ac3_.py` script. Don't forget that
    the file name will be different in your configuration.
  prefs: []
  type: TYPE_NORMAL
- en: After we run the previous scripts, we can use the PostgreSQL command line or
    any other application that allows us to easily verify the contents of the PostreSQL
    database to check the tables that the migration generated.
  prefs: []
  type: TYPE_NORMAL
- en: Run the following command to list the generated tables. In case the database
    name you are using is not named `messages`, make sure you use the appropriate
    database name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output with all the generated table names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: SQLAlchemy generated the tables, the unique constraints, and the foreign keys
    based on the information included in our models.
  prefs: []
  type: TYPE_NORMAL
- en: '`category`: Persists the `Category` model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message`: Persists the `Message` model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following command will allow you to check the contents of the four tables
    after we compose and send HTTP requests to the RESTful API and make CRUD operations
    to the two tables. The commands assume that you are running PostgreSQL on the
    same computer in which you are running the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of working with the PostgreSQL command-line utility, you can use a GUI
    tool to check the contents of the PostgreSQL database. You also use also the database
    tools included in your favorite IDE to check the contents for the SQLite database.
  prefs: []
  type: TYPE_NORMAL
- en: Alembic generated an additional table named `alembic_version` that saves the
    version number for the database in the `version_num` column. This table makes
    is possible for the migration scripts to retrieve the current version of the database
    and upgrade or downgrade it based on our needs.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and retrieving related resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we can run the `api/run.py` script that launches Flask's development. Execute
    the following command in the api folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The following lines show the output after we execute the preceding command.
    The development server is listening at port `5000`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will use the HTTPie command or its curl equivalents to compose and send
    HTTP requests to the API. We will use JSON for the requests that require additional
    data. Remember that you can perform the same tasks with your favorite GUI-based
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will compose and send HTTP requests to create two message categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the equivalent `curl` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The preceding commands will compose and send two `POST` HTTP requests with the
    specified JSON key-value pair. The requests specify `/api/categories/`, and therefore,
    they will match the `'/api'url_prefix` for the `api_bp` blueprint. Then, the request
    will match the `'/categories/'` URL route for the `CategoryList` resource and
    run the `CategoryList.post` method. The method doesn't receive arguments because
    the URL route doesn't include any parameters. As the HTTP verb for the request
    is `POST`, Flask calls the `post` method. If the two new `Category` instances
    were successfully persisted in the database, the two calls will return an `HTTP
    201 Created` status code and the recently persisted `Category` serialized to JSON
    in the response body. The following lines show an example response for the two
    HTTP requests, with the new `Category` objects in the JSON responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the responses include the URL, `url`, for the created categories.
    The `messages` array is empty in both cases because there aren''t messages related
    to each new category yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will compose and send HTTP requests to create two messages that belong
    to the first message category we recently created: `Information`. We will specify
    the `category` key with the name of the desired message category. The database
    table that persists the `Message` model will save the value of the primary key
    of the related `Category` whose name value matches the one we provide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the equivalent `curl` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The first command will compose and send the following HTTP request: `POST http://localhost:5000/api/messages/`
    with the following JSON key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The second command will compose and send the same HTTP request with the following
    JSON key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The requests specify `/api/categories/`, and therefore, they will match the
    `'/api'url_prefix` for the `api_bp` blueprint. Then, the request will match the
    `'/messages/'` URL route for the `MessageList` resource and run the `MessageList.post`
    method. The method doesn't receive arguments because the URL route doesn't include
    any parameters. As the HTTP verb for the request is `POST`, Flask calls the `post`
    method. The the `MessageSchema.process_category` method will process the data
    for the category and the `MessageListResource.post` method will retrieve the `Category`
    that matches the specified category name from the database, to use it as the related
    category for the new message. If the two new `Message` instances were successfully
    persisted in the database, the two calls will return an `HTTP 201 Created` status
    code and the recently persisted `Message` serialized to JSON in the response body.
    The following lines show an example response for the two HTTP requests, with the
    new `Message` objects in the JSON responses. Note that the responses include the
    URL, `url`, for the created messages. In addition, the response includes the `id`,
    `name`, and `url` for the related category.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the preceding commands to check the contents of the tables that
    the migrations created in the PostgreSQL database. We will notice that the `category_id`
    column for the `message` table saves the value of the primary key of the related
    row in the `category` table. The `MessageSchema` class uses a `fields.Nested`
    instance to render the `id`, `url` and name fields for the related `Category`.
    The following screenshot shows the contents for the `category` and the `message`
    table in a PostgreSQL database after running the HTTP requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and retrieving related resources](img/image_06_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will compose and send an HTTP request to retrieve the category that
    contains two messages, that is the category resource whose id or primary key is
    equal to `1`. Don''t forget to replace `1` with the primary key value of the category
    whose name is equal to `''Information''` in your configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will compose and send a `GET` HTTP request. The request
    has a number after `/api/categories/`, and therefore, it will match `''/categories/<int:id>''`
    and run the `CategoryResource.get` method, that is, the `get` method for the `CategoryResource`
    class. If a `Category` instance with the specified id exists in the database,
    the call to the method will will return an `HTTP200 OK` status code and the `Category`
    instance serialized to JSON in the response body. The `CategorySchema` class uses
    a `fields.Nested` instance to render all the fields for all the messages related
    to the category excepting the category field. The following lines show a sample
    response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will compose and send a `POST` HTTP request to create a message related
    to a category name that doesn''t exist: `''Error''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the equivalent curl commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CategoryListResource.post` method won''t be able to retrieve a `Category`
    instance whose `name` is equal to the specified value, and therefore, the method
    will create a new `Category`, save it and use it as the related category for the
    new message. The following lines show an example response for the HTTP request,
    with the new `Message` object in the JSON responses and the details for the new
    `Category` object related to the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the commands explained earlier to check the contents of the tables
    that the migrations created in the PostgreSQL database. We will notice that we
    have a new row in the category table with the recently added category when we
    created a new message. The following screenshot shows the contents for the `category`
    and `message` tables in a PostgreSQL database after running the HTTP requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and retrieving related resources](img/image_06_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Marshmallow is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A lightweight library for converting complex datatypes to and from native Python
    datatypes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An ORM .
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A lightweight web framework that replaces Flask.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'SQLAlchemy is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A lightweight library for converting complex datatypes to and from native Python
    datatypes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An ORM .
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A lightweight web framework that replaces Flask.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `marshmallow.pre_load` decorator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Registers a method to run after any instance of the `MessageSchema` class is
    created.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Registers a method to invoke after serializing an object.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Registers a method to invoke before deserializing an object.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `dump` method for any instance of a Schema subclass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Routes URLs to Python primitives.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Persists the instance or collection of instances passed as an argument to the
    database.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Takes the instance or collection of instances passed as an argument and applies
    the field filtering and output formatting specified in the Schema subclass to
    the instance or collection of instances.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we declare an attribute as an instance of the `marshmallow.fields.Nested`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The field will nest a single `Schema` or a collection of `Schema` based on the
    value for the `many` argument.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The field will nest a single `Schema`. If we want to nest a collection of `Schema`,
    we have to use an instance of the `marshmallow.fields.NestedCollection` class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The field will nest a collection of `Schema`. If we want to nest a single `Schema`,
    we have to use an instance of the `marshmallow.fields.NestedSingle` class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we expanded the capabilities of the previous version of the
    RESTful API that we created in the previous chapter. We used SQLAlchemy as our
    ORM to work with a PostgreSQL database. We installed many packages to simplify
    many common tasks, wrote code for the models and their relationships, and worked
    with schemas to validate, serialize, and deserialize these models.
  prefs: []
  type: TYPE_NORMAL
- en: We combined blueprints with resourceful routing and were able to generate the
    database from the models. We composed and sent many HTTP requests to our RESTful
    API and analyzed how each HTTP request was processed in our code and how the models
    persisted in the database tables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we built a complex API with Flask, Flask-RESTful, and SQLAlchemy, we
    will use additional features and add security and authentication, which is what
    we are going to discuss in the next chapter.
  prefs: []
  type: TYPE_NORMAL
