- en: Chapter 6.  Working with Models, SQLAlchemy, and Hyperlinked APIs in Flask
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。在Flask中使用模型、SQLAlchemy和超链接API进行工作
- en: 'In this chapter, we will expand the capabilities of the RESTful API that we
    started in the previous chapter. We will use SQLAlchemy as our ORM to work with
    a PostgreSQL database and we will take advantage of advanced features included
    in Flask and Flask-RESTful that will allow us to easily organize code for complex
    APIs, such as models and blueprints. In this chapter, we will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将扩展上一章开始构建的RESTful API的功能。我们将使用SQLAlchemy作为我们的ORM来与PostgreSQL数据库交互，并且我们将利用Flask和Flask-RESTful中包含的先进功能，这将使我们能够轻松组织代码以构建复杂的API，如模型和蓝图。在本章中，我们将：
- en: Design a RESTful API to interact with a PostgreSQL database
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个RESTful API以与PostgreSQL数据库交互
- en: Understand the tasks performed by each HTTP method
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解每个HTTP方法执行的任务
- en: Install packages to simplify our common tasks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装包以简化我们的常见任务
- en: Create and configure the database
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和配置数据库
- en: Write code for the models with their relationships
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为模型编写包含其关系的代码
- en: Use schemas to validate, serialize, and deserialize models
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模式来验证、序列化和反序列化模型
- en: Combine blueprints with resourceful routing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将蓝图与资源路由相结合
- en: Register the blueprint and run migrations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册蓝图并运行迁移
- en: Create and retrieve related resources
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和检索相关资源
- en: Designing a RESTful API to interact with a PostgreSQL database
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计一个与PostgreSQL数据库交互的RESTful API
- en: So far, our RESTful API has performed CRUD operations on a simple dictionary
    that acted as a data repository. Now, we want to create a more complex RESTful
    API with Flask RESTful to interact with a database model that has to allow us
    to work with messages that are grouped into message categories. In our previous
    RESTful API, we used a string attribute to specify the message category for a
    message. In this case, we want to be able to easily retrieve all the messages
    that belong to a specific message category, and therefore, we will have a relationship
    between a message and a message category.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的RESTful API已经在充当数据存储库的简单字典上执行了CRUD操作。现在，我们想要使用Flask RESTful创建一个更复杂的RESTful
    API，以与必须允许我们处理分组到消息类别中的消息的数据库模型交互。在我们的上一个RESTful API中，我们使用一个字符串属性来指定消息的消息类别。在这种情况下，我们希望能够轻松检索属于特定消息类别的所有消息，因此，我们将有一个消息与消息类别之间的关系。
- en: 'We must be able to perform CRUD operations on different related resources and
    resource collections. The following list enumerates the resources and the class
    name that we will create to represent the model:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须能够对不同的相关资源和资源集合执行CRUD操作。以下列表列举了我们将创建以表示模型的资源和类名：
- en: Message categories (`Category` model)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息类别（`Category`模型）
- en: Messages (`Message` model)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息（`Message`模型）
- en: 'The message category (`Category`) just requires an integer name, and we need
    the following data for a message (`Message`):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 消息类别（`Category`）只需要一个整数字符串名称，而对于消息（`Message`），我们需要以下数据：
- en: An integer identifier
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数标识符
- en: A foreign key to a message category (`Category`)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向消息类别（`Category`）的外键
- en: A string message
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字符串消息
- en: The duration in seconds that will indicate the time the message has to be printed
    on the OLED display
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将指示消息在OLED显示屏上打印时间的秒数
- en: The creation date and time. The timestamp will be added automatically when adding
    a new message to the collection
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建日期和时间。时间戳将在将新消息添加到集合时自动添加
- en: An integer counter that indicates the times the message has been printed in
    the OLED display
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指示消息在OLED显示屏上打印次数的整数计数器
- en: A `bool` value indicating whether the message was printed at least once on the
    OLED display
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`bool`值，指示消息是否至少在OLED显示屏上打印过一次
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We will take advantage of the many packages related to Flask RESTful and SQLAlchemy
    that make it easier to serialize and deserialize data, perform validations, and
    integrate SQLAlchemy with Flask and Flask RESTful.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用与Flask RESTful和SQLAlchemy相关的许多包，这些包使得序列化和反序列化数据、执行验证以及将SQLAlchemy与Flask和Flask
    RESTful集成变得更加容易。
- en: Understanding the tasks performed by each HTTP method
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解每个HTTP方法执行的任务
- en: 'The following table shows the HTTP verbs, the scope, and the semantics for
    the methods that our new API must support. Each method is composed of an HTTP
    verb, a scope, and all the methods have well-defined meanings for all the resources
    and collections:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了我们的新API必须支持的方法的HTTP动词、作用域和语义。每个方法由一个HTTP动词、一个作用域以及所有方法对所有资源和集合都有明确定义的意义组成：
- en: '| **HTTP verb** | **Scope** | **Semantics** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP动词** | **作用域** | **语义** |'
- en: '| `GET` | Collection of message categories | Retrieve all the stored message
    categories in the collection and return them sorted by their name in ascending
    order. Each category must include the full URL for the resource. Each category
    must include a list with all the details for the messages that belong to the category.
    The messages don''t have to include the category in order to avoid repeating data.
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 消息类别集合 | 获取集合中所有存储的消息类别，并按名称升序排序返回它们。每个类别必须包括资源的完整URL。每个类别必须包括一个包含属于该类别所有消息详细信息的列表。消息不必包括类别，以避免重复数据。
    |'
- en: '| `GET` | Message category | Retrieve a single message category. The category
    must include the same information explained for each category when we retrieve
    a collection of message category. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 消息类别 | 获取单个消息类别。该类别必须包括我们在检索消息类别集合时为每个类别解释的相同信息。 |'
- en: '| `POST` | Collection of message categories | Create a new message category
    in the collection. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 消息类别集合 | 在集合中创建一个新的消息类别。 |'
- en: '| `PATCH` | Message category | Update the name of an existing message category.
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 消息类别 | 更新现有消息类别的名称。 |'
- en: '| `DELETE` | Message category | Delete an existing message category. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 消息类别 | 删除现有的消息类别。 |'
- en: '| `GET` | Collection of messages | Retrieve all the stored messages in the
    collection, sorted by their message in ascending order. Each message must include
    its message category details, including the full URL to access the related resource.
    The message category details don''t have to include the messages that belong to
    the category. The message must include the full URL to access the resource. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 消息集合 | 获取集合中所有存储的消息，按消息升序排序。每条消息必须包括其消息类别详情，包括访问相关资源的完整URL。消息类别详情不必包括属于该类别的消息。消息必须包括访问资源的完整URL。
    |'
- en: '| `GET` | Message | Retrieve a single message. The message must include the
    same information explained for each message when we retrieve a collection of messages.
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 消息 | 获取单个消息。消息必须包括我们在检索消息集合时为每个消息解释的相同信息。 |'
- en: '| `POST` | Collection of messages | Create a new message in the collection.
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 消息集合 | 在集合中创建一个新的消息。 |'
- en: '| `PATCH` | Message | Update any of the following fields of an existing message:
    message, duration, printed_times, and printed_once. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 消息 | 更新现有消息的以下字段：消息、持续时间、打印次数和打印一次。 |'
- en: '| `DELETE` | Message | Delete an existing message. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 消息 | 删除一个现有的消息。 |'
- en: In addition, our RESTful API must support the `OPTIONS` method for all the resources
    and collection of resources. We will use SQLAlchemy as our ORM and we will work
    with a PostgreSQL database. However, in case you don't want to spend time installing
    PostgreSQL, you can use any other database supported by SQLAlchemy, such as MySQL.
    In case you want the simplest database, you can work with SQLite.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的RESTful API必须支持所有资源及其集合的`OPTIONS`方法。我们将使用SQLAlchemy作为我们的ORM，并将与PostgreSQL数据库一起工作。然而，如果你不想花时间安装PostgreSQL，你可以使用SQLAlchemy支持的任何其他数据库，例如MySQL。如果你想要最简单的数据库，你可以使用SQLite。
- en: 'In the preceding table, there are many methods and scopes. The following list
    enumerates the URIs for each scope mentioned in the preceding table, where `{id}`
    has to be replaced with the numeric id or primary key of the resource. As happened
    in the previous example, we want our API to differentiate collections from a single
    resource of the collection in the URLs. When we refer to a collection, we will
    use a slash (`/`) as the last character for the URL and when we refer to a single
    resource of the collection, we won''t use a slash (`/`) as the last character
    for the URL:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表中，有许多方法和范围。以下列表列举了前面表中提到的每个范围的URI，其中`{id}`需要替换为资源的数字ID或主键。正如前一个示例中发生的那样，我们希望我们的API在URL中区分集合和单个集合资源。当我们提到一个集合时，我们将使用斜杠（`/`）作为URL的最后一个字符，当我们提到集合的单个资源时，我们不会使用斜杠（`/`）作为URL的最后一个字符：
- en: '**Collection of message categories**: `/categories/`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息类别集合**: `/categories/`'
- en: '**Message category**: `/category/{id}`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息类别**: `/category/{id}`'
- en: '**Collection of messages**: `/messages/`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息集合**: `/messages/`'
- en: '**Message**: `/message/{id}`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息**: `/message/{id}`'
- en: Let's consider that `http://localhost:5000/api/` is the URL for the API running
    on the Flask development server. We have to compose and send an HTTP request with
    the following HTTP verb (`GET`) and request URL (`http://localhost:5000/api/categories/`)
    to retrieve all the stored message categories in the collection. Each category
    will include a list with all the messages that belong to the category.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设 `http://localhost:5000/api/` 是 Flask 开发服务器上运行的 API 的 URL。我们必须使用以下 HTTP
    动词 (`GET`) 和请求 URL (`http://localhost:5000/api/categories/`) 来组合和发送一个 HTTP 请求，以检索存储在集合中的所有消息类别。每个类别将包含一个列表，列出属于该类别的所有消息。
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Installing packages to simplify our common tasks
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装包以简化我们的常见任务
- en: Make sure you quit Flask's development server. Remember that you just need to
    press ***Ctrl*** + ***C*** in the Terminal or Command Prompt window in which it
    is running. Now, we will install many additional packages. Make sure you have
    activated the virtual environment we have created in the previous chapter and
    we named `Flask01`. In case you created a new virtual environment to work with
    this example or you downloaded the sample code for the book, make sure you install
    the packages we used in the previous example.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已退出 Flask 的开发服务器。请记住，您只需在运行它的终端或命令提示符窗口中按 ***Ctrl*** + ***C*** 即可。现在，我们将安装许多额外的包。确保您已激活我们在上一章中创建并命名为
    `Flask01` 的虚拟环境。如果您为处理此示例或下载了本书的示例代码创建了新的虚拟环境，请确保您安装了我们在上一示例中使用的包。
- en: After you activate the virtual environment, it is time to run commands that
    will be the same for either macOS, Linux, or Windows. We can install all the necessary
    packages with pip with a single command. However, we will run independent commands
    to make it easier to detect any problems in case a specific installation fails.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在激活虚拟环境后，现在是时候运行适用于 macOS、Linux 或 Windows 的相同命令了。我们可以使用单个命令使用 pip 安装所有必要的包。然而，我们将运行独立的命令，以便在特定安装失败时更容易检测到任何问题。
- en: 'Now, we must run the following command to install Flask-SQLAlchemy with pip.
    Flask-SQLAlchemy adds support for the SQLAlchemy ORM to Flask applications. This
    extension simplifies executing common SQLAlchemy tasks within a Flask application.
    SQLAlchemy is a dependency for Flask-SQLAlchemy, and therefore, pip will install
    it automatically, too:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须运行以下命令使用 pip 安装 Flask-SQLAlchemy。Flask-SQLAlchemy 为 Flask 应用程序添加了对 SQLAlchemy
    ORM 的支持。此扩展简化了在 Flask 应用程序中执行常见 SQLAlchemy 任务。SQLAlchemy 是 Flask-SQLAlchemy 的依赖项，因此，pip
    也会自动安装它：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The last lines of the output will indicate all the packages that have been
    successfully installed, including `SQLAlchemy` and `Flask-SQLAlchemy`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示所有成功安装的包，包括 `SQLAlchemy` 和 `Flask-SQLAlchemy`：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the following command to install Flask-Migrate with pip. Flask-Migrate uses
    the Alembic package to handle SQLAlchemy database migrations for Flask applications.
    We will use Flask-Migrate to set up our PostgreSQL database. Flask-Script is one
    of the dependencies for Flask-Migrate, and therefore, pip will install it automatically.
    Flask-Script adds support for writing external scripts in Flask, including scripts
    to set up a database.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令使用 pip 安装 Flask-Migrate。Flask-Migrate 使用 Alembic 包来处理 Flask 应用程序的 SQLAlchemy
    数据库迁移。我们将使用 Flask-Migrate 来设置我们的 PostgreSQL 数据库。Flask-Script 是 Flask-Migrate 的一个依赖项，因此，pip
    也会自动安装它。Flask-Script 为 Flask 添加了编写外部脚本的支持，包括设置数据库的脚本。
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The last lines for the output will indicate all the packages that have been
    successfully installed, including `Flask-Migrate` and `Flask-Script`. The other
    installed packages are additional dependencies:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示所有成功安装的包，包括 `Flask-Migrate` 和 `Flask-Script`。其他已安装的包是额外的依赖项：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Run the following command to install marshmallow with pip. Marshmallow is a
    lightweight library for converting complex datatypes to and from native Python
    datatypes. Marshmallow provides schemas that we can use to validate input data,
    deserialize input data to app-level objects, and serialize app-level objects to
    Python primitive types:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令使用 pip 安装 marshmallow。Marshmallow 是一个轻量级库，用于将复杂的数据类型转换为原生 Python 数据类型，反之亦然。Marshmallow
    提供了我们可以用来验证输入数据、将输入数据反序列化为应用级对象以及将应用级对象序列化为 Python 原始类型的模式：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The last lines for the output will indicate `marshmallow` has been successfully
    installed:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示 `marshmallow` 已成功安装：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the following command to install Marshmallow-sqlalchemy with pip. Marshmallow-sqlalchemy
    provides SQLAlchemy integration with the previously installed marshmallow validation,
    serialization, and deserialization lightweight library:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令使用pip安装Marshmallow-sqlalchemy。Marshmallow-sqlalchemy提供了与之前安装的marshmallow验证、序列化和反序列化轻量级库的SQLAlchemy集成：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The last lines for the output will indicate `marshmallow-sqlalchemy` has been
    successfully installed:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示`marshmallow-sqlalchemy`已成功安装：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, run the following command to install Flask-Marshmallow with pip. Flask-Marshmallow
    integrates the previously installed `marshmallow` library with Flask applications
    and makes it easy to generate a URL and Hyperlink fields:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行以下命令使用pip安装Flask-Marshmallow。Flask-Marshmallow将之前安装的`marshmallow`库与Flask应用程序集成，使得生成URL和超链接字段变得简单：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The last lines for the output will indicate `Flask-Marshmallow` has been successfully
    installed:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示`Flask-Marshmallow`已成功安装：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Creating and configuring the database
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和配置数据库
- en: 'Now, we will create the PostgreSQL database that we will use as a repository
    for our API. You will have to download and install a PostgreSQL database in case
    you aren''t already running it in your computer or in a development server. You
    can download and install this database management system from its web page: [http://www.postgresql.org](http://www.postgresql.org).
    In case you are working with macOS, `Postgres.app` provides a really easy way
    to install and use PostgreSQL on this operating system: [http://postgresapp.com](http://postgresapp.com):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个PostgreSQL数据库，我们将使用它作为API的存储库。如果你还没有在电脑或开发服务器上运行PostgreSQL数据库，你需要下载并安装它。你可以从其网页：[http://www.postgresql.org](http://www.postgresql.org)下载并安装这个数据库管理系统。如果你在macOS上工作，`Postgres.app`提供了一个非常简单的方法来安装和使用PostgreSQL在这个操作系统上：[http://postgresapp.com](http://postgresapp.com)：
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You have to make sure that the PostgreSQL bin folder is included in the `PATH`
    environmental variable. You should be able to execute the `psql` command-line
    utility from your current Terminal or Command Prompt. In case the folder isn't
    included in the PATH, you will receive an error indicating that the `pg_config`
    file cannot be found when trying to install the `psycopg2` package. In addition,
    you will have to use the full path to each of the PostgreSQL command-line tools
    we will use in the next steps.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须确保PostgreSQL的bin文件夹包含在`PATH`环境变量中。你应该能够从当前的终端或命令提示符中执行`psql`命令行工具。如果文件夹没有包含在PATH中，当你尝试安装`psycopg2`包时，你会收到一个错误，指示找不到`pg_config`文件。此外，你将不得不使用每个我们将要使用的PostgreSQL命令行工具的完整路径。
- en: 'We will use the PostgreSQL command-line tools to create a new database named
    `messages`. In case you already have a PostgreSQL database with this name, make
    sure that you use another name in all the commands and configurations. You can
    perform the same task with any PostgreSQL GUI tool. In case you are developing
    on Linux, it is necessary to run the commands as the `postgres` user. Run the
    following command in macOS or Windows to create a new database named `messages`.
    Note that the command won''t produce any output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用PostgreSQL命令行工具创建一个名为`messages`的新数据库。如果你已经有一个同名PostgreSQL数据库，确保你在所有命令和配置中使用另一个名称。你可以使用任何PostgreSQL
    GUI工具执行相同的任务。如果你在Linux上开发，运行命令时必须以`postgres`用户身份。在macOS或Windows上运行以下命令以创建一个名为`messages`的新数据库。请注意，该命令不会产生任何输出：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In Linux, run the following command to use the `postgres` user:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，运行以下命令以使用`postgres`用户：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we will use the `psql` command-line tool to run some SQL statements to
    create a specific user that we will use in Flask and assign the necessary roles
    for it. In macOS or Windows, run the following command to launch psql:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用`psql`命令行工具运行一些SQL语句来创建一个特定的用户，我们将在Flask中使用它，并为其分配必要的角色。在macOS或Windows上，运行以下命令来启动psql：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In Linux, run the following command to use the postgres user:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，运行以下命令以使用`postgres`用户：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then, run the following SQL statements and finally enter \q to exit the psql
    command-line tool. Replace user_name with your desired user name to use in the
    new database and password with your chosen password. We will use the user name
    and password in the Flask configuration. You don't need to run the steps in case
    you are already working with a specific user in PostgreSQL and you have already
    granted privileges to the database for the user. You will see the output indicating
    that the permission was granted.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行以下 SQL 语句，最后输入 \q 以退出 psql 命令行工具。将 user_name 替换为您在新的数据库中希望使用的用户名，将 password
    替换为您选择的密码。我们将在 Flask 配置中使用用户名和密码。如果您已经在 PostgreSQL 中使用特定的用户并且已经为该用户授予了数据库权限，则无需运行这些步骤。您将看到表示权限已授予的输出。
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is necessary to install the Psycopg 2 package (psycopg2). This package is
    a Python-PostgreSQL Database Adapter and SQLAlchemy will use it to interact with
    our recently created PostgreSQL database.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 必须安装 Psycopg 2 软件包（psycopg2）。此软件包是一个 Python-PostgreSQL 数据库适配器，SQLAlchemy 将使用它来与我们的新创建的
    PostgreSQL 数据库交互。
- en: 'Once we made sure that the PostgreSQL `bin` folder is included in the PATH
    environmental variable, we just need to run the following command to install this
    package:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确认 PostgreSQL 的 `bin` 文件夹已包含在 PATH 环境变量中，我们只需运行以下命令来安装此软件包：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The last lines of the output will indicate that the `psycopg2` package has
    been successfully installed:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示 `psycopg2` 软件包已成功安装：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In case you are using the same virtual environment that we created for the previous
    example, the `api` folder already exists. If you create a new virtual environment,
    create a folder named `api` within the root folder for the created virtual environment.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用我们为上一个示例创建的相同虚拟环境，`api` 文件夹已经存在。如果您创建一个新的虚拟环境，请在创建的虚拟环境根目录下创建一个名为 `api`
    的文件夹。
- en: Create a new `config.py` file within the `api` folder. The following lines show
    the code that declares variables that determine the configuration for Flask and
    SQLAlchemy. The `SQL_ALCHEMY_DATABASE_URI` variable generates an SQLAlchemy URI
    for the PostgreSQL database.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `api` 文件夹内创建一个新的 `config.py` 文件。以下行显示了声明变量以确定 Flask 和 SQLAlchemy 配置的代码。`SQL_ALCHEMY_DATABASE_URI`
    变量生成用于 PostgreSQL 数据库的 SQLAlchemy URI。
- en: 'Make sure you specify the desired database name in the value for `DB_NAME`
    and that you configure the user, password, host, and port based on your PostgreSQL
    configuration. In case you followed the previous steps, use the settings specified
    in these steps. The code file for the sample is included in the `restful_python_chapter_06_01`
    folder:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您在 `DB_NAME` 的值中指定了所需的数据库名称，并根据您的 PostgreSQL 配置配置用户、密码、主机和端口。如果您遵循了前面的步骤，请使用这些步骤中指定的设置。示例代码文件包含在
    `restful_python_chapter_06_01` 文件夹中：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will specify the module created earlier as an argument to a function that
    will create a *Flask* app. This way, we have one module that specifies all the
    values for the different configuration variables and another module that creates
    a *Flask* app. We will create the Flask app factory as our final step towards
    our new API.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将指定之前创建的模块作为创建 *Flask* 应用的函数的参数。这样，我们有一个模块指定了所有不同的配置变量，另一个模块创建了一个 *Flask*
    应用。我们将创建 Flask 应用工厂作为我们迈向新 API 的最后一步。
- en: Creating models with their relationships
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有其关系的模型
- en: 'Now, we will create the models that we can use to represent and persist the
    message categories, messages, and their relationships. Open the `api/models.py`
    file and replace its contents with the following code. The lines that declare
    fields related to other models are highlighted in the code listing. In case you
    created a new virtual environment, create a new `models.py` file within the `api`
    folder. The code file for the sample is included in the `restful_python_chapter_06_01`
    folder:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建可以用来表示和持久化消息类别、消息及其关系的模型。打开 `api/models.py` 文件，并用以下代码替换其内容。与其它模型相关的字段声明在代码列表中突出显示。如果您创建了一个新的虚拟环境，请在
    `api` 文件夹中创建一个新的 `models.py` 文件。示例代码文件包含在 `restful_python_chapter_06_01` 文件夹中：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First, the code creates an instance of the `flask_sqlalchemy.SQLAlchemy` class
    named `db`. This instance will allow us to control the SQLAlchemy integration
    for our Flask application. In addition, the instance will provide access to all
    the SQLAlchemy functions and classes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码创建了一个名为 `db` 的 `flask_sqlalchemy.SQLAlchemy` 类的实例。这个实例将允许我们控制 Flask 应用程序的
    SQLAlchemy 集成。此外，该实例将提供访问所有 SQLAlchemy 函数和类的方法。
- en: Then, the code creates an instance of the `flask_marshmallow.Marshmallow` class
    named `ma`. It is very important to create the `flask_sqlalchemy.SQLAlchemy` instance
    before the `Marshmallow` instance, and therefore, order matters in this case.
    Marshmallow is a wrapper class that integrates Mashmallow with a *Flask* application.
    The instance named `ma` will provide access to the `Schema` class, the fields
    defined in `marshmallow.fields`, and the Flask-specific fields declared in `flask_marshmallow.fields`.
    We will use them later when we declare the schemas related to our models.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码创建了一个名为 `ma` 的 `flask_marshmallow.Marshmallow` 类的实例。在创建 `Marshmallow` 实例之前创建
    `flask_sqlalchemy.SQLAlchemy` 实例非常重要，因此在这种情况下，顺序很重要。Marshmallow 是一个包装类，它将 Mashmallow
    与 *Flask* 应用程序集成。名为 `ma` 的实例将提供对 `Schema` 类、在 `marshmallow.fields` 中定义的字段以及声明在
    `flask_marshmallow.fields` 中的 Flask 特定字段的访问。我们将在声明与我们的模型相关的模式时使用它们。
- en: 'The code creates the `AddUpdateDelete` class that declares the following three
    methods to add, update, and delete a resource through SQLAlchemy sessions:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了一个名为 `AddUpdateDelete` 的类，该类声明了以下三个方法，通过 SQLAlchemy 会话添加、更新和删除资源：
- en: '`add`: This method receives the object to be added in the `resource` argument
    and calls the `db.session.add` method with the received resource as an argument
    to create the object in the underlying database. Finally, the code commits the
    session.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add`：此方法接收要添加的对象，并将其作为 `resource` 参数传递，然后使用接收到的资源作为参数调用 `db.session.add` 方法，在底层数据库中创建对象。最后，代码提交会话。'
- en: '`update`: This method just commits the session to persist the changes made
    to the objects in the underlying database.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update`：此方法只是提交会话，以持久化对底层数据库中对象所做的更改。'
- en: '`delete`: This method receives the object to be deleted in the `resource` argument
    and calls the `db.session.delete` method with the received resource as an argument
    to remove the object in the underlying database. Finally, the code commits the
    session.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete`：此方法接收要删除的对象，并将其作为 `resource` 参数传递，然后使用接收到的资源作为参数调用 `db.session.delete`
    方法，从底层数据库中删除对象。最后，代码提交会话。'
- en: 'The code declares the following two models, specifically, two classes, as a
    subclass of both the `db.Model`, and the `AddUpdateDelete` classes:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了以下两个模型，具体来说，是两个类，作为 `db.Model` 和 `AddUpdateDelete` 类的子类：
- en: '`Message`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Message`'
- en: '`Category`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Category`'
- en: We specified the field types, maximum lengths, and defaults for many attributes.
    The attributes that represent fields without any relationship are instances of
    the `db.Column` class. Both models declare an `id` attribute and specify the `True`
    value for the `primary_key` argument to indicate it is the primary key. SQLAlchemy
    will use the data to generate the necessary tables in the PostgreSQL database.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了许多属性的字段类型、最大长度和默认值。表示没有任何关系的字段属性是 `db.Column` 类的实例。两个模型都声明了一个 `id` 属性，并指定了
    `primary_key` 参数的 `True` 值，以指示它是主键。SQLAlchemy 将使用这些数据在 PostgreSQL 数据库中生成必要的表。
- en: 'The `Message` model declares the `category` field with the following line:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message` 模型使用以下行声明了 `category` 字段：'
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The previous line uses the db.relationship function to provide a many-to-one
    relationship to the Category model. The backref argument specifies a call to the
    db.backref function with 'messages' as the first value that indicates the name
    to use for the relation from the related Category object back to a Message object.
    The order_by argument specifies 'Message.message' because we want the messages
    for each category to be sorted by the value of the message field in ascending
    order.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行使用 `db.relationship` 函数提供了到 `Category` 模型的多对一关系。`backref` 参数指定了一个调用 `db.backref`
    函数的调用，其中 `'messages'` 作为第一个值，表示从相关的 `Category` 对象返回到 `Message` 对象的关系名称。`order_by`
    参数指定 `'Message.message'`，因为我们希望每个类别的消息按消息字段的值升序排序。
- en: 'Both models declare a constructor, that is, the `__init__` method. This constructor
    for the `Message` model receives many arguments and uses them to initialize the
    attributes with the same names: `message`, `duration`, and `category`. The constructor
    for the `Category` model receives a `name` argument and uses it to initialize
    the attribute with the same name.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 两个模型都声明了一个构造函数，即 `__init__` 方法。`Message` 模型的构造函数接收许多参数，并使用它们来初始化具有相同名称的属性：`message`、`duration`
    和 `category`。`Category` 模型的构造函数接收一个 `name` 参数，并使用它来初始化具有相同名称的属性。
- en: Creating schemas to validate, serialize, and deserialize models
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用于验证、序列化和反序列化模型的模式
- en: 'Now, we will create the Flask-Marshmallow schemas that we will use to validate,
    serialize, and deserialize the previously declared `Category` and `Message` models
    and their relationships. Open the `api/models.py` file and add the following code
    after the existing lines. The lines that declare the fields related to the other
    schemas are highlighted in the code listing. The code file for the sample is included
    in the `restful_python_chapter_06_01` folder:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建Flask-Marshmallow模式，我们将使用这些模式来验证、序列化和反序列化之前声明的`Category`和`Message`模型及其关系。打开`api/models.py`文件，在现有行之后添加以下代码。与其它模式相关的字段声明在代码列表中被突出显示。示例的代码文件包含在`restful_python_chapter_06_01`文件夹中：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The code declares the following two schemas, specifically, two subclasses of
    the `ma.Schema` class:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了以下两个模式，具体来说，是`ma.Schema`类的两个子类：
- en: '`CategorySchema`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CategorySchema`'
- en: '`MessageSchema`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MessageSchema`'
- en: We don't use the Flask-Marshmallow features that allow us to automatically determine
    the appropriate type for each attribute based on the fields declared in a model
    because we want to use specific options for each field. We declare the attributes
    that represent fields as instances of the appropriate class declared in the `marshmallow.fields`
    module. Whenever we specify the `True` value for the `dump_only` argument, it
    means that we want the field to be read-only. For example, we won't be able to
    provide a value for the `id` field in any of the schemas. The value for this field
    will be automatically generated by the auto-increment primary key in the database.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不使用Flask-Marshmallow提供的特性，这些特性允许我们根据模型中声明的字段自动确定每个属性的适当类型，因为我们想为每个字段使用特定的选项。我们将表示字段的属性声明为`marshmallow.fields`模块中声明的适当类的实例。当我们指定`dump_only`参数的`True`值时，这意味着我们希望该字段为只读。例如，我们无法为任何模式中的`id`字段提供值。该字段的值将由数据库中的自增主键自动生成。
- en: The `CategorySchema` class declares the `name` attribute as an instance of `fields.String`.
    The `required` argument is set to `True` to specify that the field cannot be an
    empty string. The `validate` argument is set to `validate.Length(3)` to specify
    that the field must have a minimum length of 3 characters.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`CategorySchema`类将`name`属性声明为`fields.String`的实例。将`required`参数设置为`True`以指定该字段不能为空字符串。将`validate`参数设置为`validate.Length(3)`以指定该字段必须至少有3个字符长。'
- en: 'The class declares the `url` field with the following line:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 该类通过以下行声明了`url`字段：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `url` attribute is an instance of the `ma.URLFor` class, and this field
    will output the full URL of the resource, that is, of the message category resource.
    The first argument is the Flask endpoint name-`'api.categoryresource'`. We will
    create a `CategoryResource` class later and the `URLFor` class will use it to
    generate the URL. The `id` argument specifies `'<id>'` because we want the `id`
    to be pulled from the object to be serialized. The `id` string enclosed within
    less than (`<`) and greater than (`>`) symbols specifies that we want the field
    to be pulled from the object that has to be serialized. The `_external` attribute
    is set to `True` because we want to generate the full URL for the resource. This
    way, each time we serialize a `Category`, it will include the full URL for the
    resource in the `url` key.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`url`属性是`ma.URLFor`类的实例，该字段将输出资源的完整URL，即消息类别资源的URL。第一个参数是Flask端点名称-`''api.categoryresource''`。我们将在稍后创建`CategoryResource`类，`URLFor`类将使用它来生成URL。`id`参数指定`''<id>''`，因为我们想从要序列化的对象中提取`id`。小于（`<`）和大于（`>`）符号内的`id`字符串指定我们希望从必须序列化的对象中提取字段。`_external`属性设置为`True`，因为我们想为资源生成完整的URL。这样，每次我们序列化`Category`时，它都会在`url`键中包含资源的完整URL。'
- en: Tip
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In this case, we are using our insecure API behind HTTP. In case our API is
    configured with HTTPS, we should set the `_scheme` argument to `'https'` when
    we create the `ma.URLFor` instance.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在使用不安全的API通过HTTP。如果我们的API配置为HTTPS，那么在创建`ma.URLFor`实例时，我们应该将`_scheme`参数设置为`'https'`。
- en: 'The class declares the `messages` field with the following line:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该类通过以下行声明了`messages`字段：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `messages` attribute is an instance of the `marshmallow.fields.Nested` class,
    and this field will nest a collection of `Schema`, and therefore, we specify `True`
    for the `many` argument. The first argument specifies the name for the nested
    `Schema` class as a string. We declare the `MessageSchema` class after we defined
    the `CategorySchema` class. Thus, we specify the `Schema` class name as a string
    instead of using the type that we haven't defined yet.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`messages` 属性是 `marshmallow.fields.Nested` 类的实例，并且这个字段将嵌套一个 `Schema` 集合，因此我们为
    `many` 参数指定了 `True`。第一个参数指定了嵌套 `Schema` 类的名称，作为一个字符串。我们在定义了 `CategorySchema` 类之后声明了
    `MessageSchema` 类。因此，我们指定 `Schema` 类的名称为一个字符串，而不是使用我们尚未定义的类型。'
- en: In fact, we will end up with two objects that nest to each other, that is, we
    will create a two-way nesting between categories and messages. We use the `exclude`
    parameter with a tuple of string to indicate that we want the `category` field
    to be excluded from the fields that are serialized for each message. This way,
    we can avoid infinite recursion because the inclusion of the category field would
    serialize all the messages related to the category.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们将最终得到两个相互嵌套的对象，也就是说，我们将在类别和消息之间创建双向嵌套。我们使用一个字符串元组作为 `exclude` 参数，以指示我们希望从为每个消息序列化的字段中排除
    `category` 字段。这样，我们可以避免无限递归，因为包含类别字段将序列化与该类别相关的所有消息。
- en: When we declared the `Message` model, we used the `db.relationship` function
    to provide a many-to-one relationship to the `Category` model. The `backref` argument
    specified a call to the `db.backref` function with `'messages'` as the first value
    that indicates the name to use for the relation from the related `Category` object
    back to a `Message` object. With the previously explained line, we created the
    messages fields that uses the same name we indicated for the `db.backref` function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明 `Message` 模型时，我们使用了 `db.relationship` 函数来提供与 `Category` 模型的多对一关系。`backref`
    参数指定了一个调用 `db.backref` 函数的调用，其中 `'messages'` 作为第一个值，表示从相关的 `Category` 对象返回到 `Message`
    对象的关系名称。通过之前解释的行，我们创建了使用我们为 `db.backref` 函数指定的相同名称的消息字段。
- en: The `MessageSchema` class declares the `message` attribute as an instance of
    `fields.String`. The `required` argument is set to `True` to specify that the
    field cannot be an empty string. The `validate` argument is set to `validate.Length(1)`
    to specify that the field must have a minimum length of 1 character. The class
    declares the `duration`, `creation_date`, `printed_times` and `printed_once` fields
    with the corresponding classes based on the types we used in the `Message` model.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageSchema` 类将 `message` 属性声明为 `fields.String` 类的实例。`required` 参数设置为 `True`，以指定该字段不能为空字符串。`validate`
    参数设置为 `validate.Length(1)`，以指定该字段必须至少有 1 个字符长。该类使用与我们在 `Message` 模型中使用的类型相对应的类声明了
    `duration`、`creation_date`、`printed_times` 和 `printed_once` 字段。'
- en: 'The class declares the `category` field with the following line:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 类使用以下行声明了 `category` 字段：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `category` attribute is an instance of the `marshmallow.fields.Nested` class
    and this field will nest a single `CategorySchema`. We specify `True` for the
    `required` argument because a message must belong to a category. The first argument
    specifies the name for the nested `Schema` class. We already declared the `CategorySchema`
    class, and therefore, we specify `CategorySchema` as the value for the first argument.
    We use the only parameter with a list of string to indicate the field names that
    we want to be included when the nested `CategorySchema` is serialized. We want
    the `id`, `url`, and `name` fields to be included. We don't specify the `messages`
    field because we don't want the category to serialize the list of messages that
    belong to it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`category` 属性是 `marshmallow.fields.Nested` 类的实例，并且这个字段将嵌套一个 `CategorySchema`。我们为
    `required` 参数指定了 `True`，因为消息必须属于一个类别。第一个参数指定了嵌套 `Schema` 类的名称。我们已经声明了 `CategorySchema`
    类，因此我们指定 `CategorySchema` 作为第一个参数的值。我们使用一个包含字符串列表的唯一参数来指示在序列化嵌套 `CategorySchema`
    时要包含的字段名称。我们希望包含 `id`、`url` 和 `name` 字段。我们没有指定 `messages` 字段，因为我们不希望类别序列化属于它的消息列表。'
- en: 'The class declares the `url` field with the following line:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 类使用以下行声明了 `url` 字段：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `url` attribute is an instance of the `ma.URLFor` class and this field
    will output the full URL of the resource, that is, of the message resource. The
    first argument is the Flask endpoint name: `''api.messageresource''`. We will
    create a `MessageResource` class later and the `URLFor` class will use it to generate
    the URL. The `id` argument specifies `''<id>''` because we want the `id` to be
    pulled from the object to be serialized. The `_external` attribute is set to `True`
    because we want to generate the full URL for the resource. This way, each time
    we serialize a `Message`, it will include the full URL for the resource in the
    `url` key.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`url`属性是`ma.URLFor`类的一个实例，这个字段将输出资源的完整URL，即消息资源的URL。第一个参数是Flask端点名称：`''api.messageresource''`。我们将在稍后创建`MessageResource`类，`URLFor`类将使用它来生成URL。`id`参数指定为`''<id>''`，因为我们希望从要序列化的对象中提取`id`。`_external`属性设置为`True`，因为我们希望为资源生成完整的URL。这样，每次我们序列化一个`Message`时，它将在`url`键中包含资源的完整URL。'
- en: The `MessageSchema` class declares a `process_category` method that uses the
    `@pre_load` decorator, specifically, `marshmallow.pre_load`. This decorator registers
    a method to invoke before deserializing an object. This way, before Marshmallow
    deserializes a message, the `process_category` method will be executed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageSchema`类声明了一个使用`@pre_load`装饰器的方法，具体来说，是`marshmallow.pre_load`。这个装饰器注册了一个在反序列化对象之前调用的方法。这样，在Marshmallow反序列化消息之前，`process_category`方法将被执行。'
- en: The method receives the data to be deserialized in the `data` argument and it
    returns the processed data. When we receive a request to `POST` a new message,
    the category name can be specified in a key named `'category'`. If a category
    with the specified name exists, we will use the existing category as the one that
    is related to the new message. If a category with the specified name doesn't exist,
    we will create a new category and then we will use this new category as the one
    that is related to the new message. This way, we make it easy for the user to
    create new messages.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接收在`data`参数中的要反序列化的数据，并返回处理后的数据。当我们收到一个`POST`新消息的请求时，可以在名为`'category'`的键中指定类别名称。如果存在具有指定名称的类别，我们将使用现有的类别作为与新的消息相关联的类别。如果不存在具有指定名称的类别，我们将创建一个新的类别，然后我们将使用这个新类别作为与新的消息相关联的类别。这样，我们使得用户创建新消息变得容易。
- en: The `data` argument might have a category name specified as a string for the
    `'category'` key. However, in other cases, the `'category'` key will include the
    key-value pairs with the field name and field values for an existing category.
    The code in the `process_category` method checks the value for the `'category'`
    key and returns a dictionary with the appropriate data to make it sure that we
    are able to deserialize a category with the appropriate key-value pairs, no matter
    the differences of the incoming data. Finally, the methods returned the processed
    dictionary. We will dive deep on the work done by the `process_category` method
    later when we start composing and sending HTTP requests to the API.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`参数可能指定了作为`''category''`键的字符串形式的类别名称。然而，在其他情况下，`''category''`键将包括具有字段名称和字段值的现有类别的键值对。`process_category`方法中的代码检查`''category''`键的值，并返回一个包含适当数据的字典，以确保我们能够使用适当的键值对反序列化类别，无论传入数据的不同。最后，这些方法返回处理后的字典。我们将在开始编写和发送HTTP请求到API时，深入探讨`process_category`方法所做的工作。'
- en: Combining blueprints with resourceful routing
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将蓝图与资源丰富的路由相结合
- en: 'Now, we will create the resources that compose our main building blocks for
    the RESTful API. First, we will create a few instances that we will use in the
    different resources. Then, we will create a `MessageResource` class, that we will
    use to represent the message resource. Create a new `views.py` file within the
    `api` folder and add the following lines. The code file for the sample is included
    in the `restful_python_chapter_06_01` folder, as shown:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建组成我们的RESTful API主要构建块的资源。首先，我们将创建一些实例，我们将在不同的资源中使用它们。然后，我们将创建一个`MessageResource`类，我们将使用它来表示消息资源。在`api`文件夹内创建一个新的`views.py`文件，并添加以下行。示例的代码文件包含在`restful_python_chapter_06_01`文件夹中，如下所示：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The first lines declare the imports and create the following instances that
    we will use in the different classes:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 前几行声明了导入并创建了以下实例，我们将在不同的类中使用它们：
- en: '`api_bp`: It is an instance of the `flask.Blueprint` class that will allow
    us to factor the Flask application into this blueprint. The first argument specifies
    the URL prefix on which we want to register the blueprint: `''api''`.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api_bp`: 它是`flask.Blueprint`类的一个实例，这将使我们能够将Flask应用程序分解为这个蓝图。第一个参数指定了我们想要注册蓝图的URL前缀：`''api''`。'
- en: '`category_schema`: It is an instance of the `CategorySchema` class we declared
    in the `models.py` module. We will use `category_schema` to validate, serialize,
    and deserialize categories.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`category_schema`: 它是我们在`models.py`模块中声明的`CategorySchema`类的一个实例。我们将使用`category_schema`来验证、序列化和反序列化类别。'
- en: '`message_schema`: It is an instance of the `MessageSchema` class we declared
    in the `models.py` module. We will use `message_schema` to validate, serialize
    and, deserialize categories.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message_schema`: 它是我们在`models.py`模块中声明的`MessageSchema`类的一个实例。我们将使用`message_schema`来验证、序列化和反序列化类别。'
- en: '`api`: It is an instance of the `flask_restful.Api` class that represents the
    main entry point for the application. We pass the previously created `flask.Blueprint`
    instance named `api_bp` as an argument to link the `Api` to the `Blueprint`.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api`: 它是`flask_restful.Api`类的一个实例，代表应用程序的主要入口点。我们将之前创建的名为`api_bp`的`flask.Blueprint`实例作为参数传递，以将`Api`链接到`Blueprint`。'
- en: 'The `MessageResource` class is a subclass of `flask_restful.Resource` and declares
    the following three methods that will be called when the HTTP method with the
    same name arrives as a request on the represented resource:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageResource`类是`flask_restful.Resource`的子类，并声明了以下三个方法，当HTTP方法以相同的名称作为对表示资源的请求到达时将被调用：'
- en: '`get`: This method receives the id of the message that has to be retrieved
    in the `id` argument. The code calls the `Message.query.get_or_404` method to
    return an HTTP `404 Not Found` status in case there is no message with the requested
    id in the underlying database. In case the message exists, the code calls the
    `message_schema.dump` method with the retrieved message as an argument to use
    the `MessageSchema` instance to serialize the `Message` instance whose `id` matches
    the specified `id`. The `dump` method takes the `Message` instance and applies
    the field filtering and output formatting specified in the `MessageSchema` class.
    The code returns the `data` attribute of the result returned by the `dump` method,
    that is, the serialized message in JSON format as the body, with the default HTTP
    `200 OK` status code.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`: 这个方法接收要检索的消息的id，作为`id`参数。代码调用`Message.query.get_or_404`方法，在底层数据库中没有请求id的消息时返回HTTP
    `404 Not Found`状态。如果消息存在，代码将调用`message_schema.dump`方法，将检索到的消息作为参数，使用`MessageSchema`实例序列化与指定`id`匹配的`Message`实例。`dump`方法接收`Message`实例，并应用在`MessageSchema`类中指定的字段过滤和输出格式化。代码返回`dump`方法返回的结果的`data`属性，即序列化的消息以JSON格式作为正文，带有默认的HTTP
    `200 OK`状态码。'
- en: '`delete`: This method receives the id of the message that has to be deleted
    in the `id` argument. The code calls the `Message.query.get_or_404` method to
    return an HTTP `404 Not Found` status in case there is no message with the requested
    id in the underlying database. In case the message exists, the code calls the
    `message.delete` method with the retrieved message as an argument to use the `Message`
    instance to erase itself from the database. Then, the code returns an empty response
    body and a `204 No Content` status code.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete`: 这个方法接收要删除的消息的id，作为`id`参数。代码调用`Message.query.get_or_404`方法，在底层数据库中没有请求id的消息时返回HTTP
    `404 Not Found`状态。如果消息存在，代码将调用`message.delete`方法，将检索到的消息作为参数，使用`Message`实例从数据库中删除自身。然后，代码返回一个空的响应体和一个`204
    No Content`状态码。'
- en: '`patch`: This method receives the id of the message that has to be updated
    or patched in the `id` argument. The code calls the `Message.query.get_or_404`
    method to return an HTTP `404 Not Found` status in case there is no message with
    the requested id in the underlying database. In case the message exists, the code
    calls the `request.get_json` method to retrieve the key-value pairs received as
    arguments with the request. The code updates specific attributes in case they
    have new values in the `message_dict` dictionary in the `Message` instance: `message`.
    Then, the code calls the `message_schema.dump` method to retrieve any errors generated
    when serializing the updated message. In case there were errors, the code returns
    the errors and an HTTP `400 Bad Request` status. If the serialization didn''t
    generate errors, the code calls the `message_schema.validate` method to retrieve
    any errors generated while validating the updated message. In case there were
    validation errors, the code returns the validation errors and an HTTP `400 Bad
    Request` status. If the validation is successful, the code calls the update method
    for the Message instance to persist the changes in the database and returns the
    results of calling the previously explained `self.get` method with the id of the
    updated message as an argument. This way, the method returns the serialized updated
    message in JSON format as the body, with the default HTTP `200 OK` status code.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`patch`: 此方法接收要更新或修补的消息的id，作为`id`参数。代码调用`Message.query.get_or_404`方法，在底层数据库中没有请求id的消息时返回HTTP
    `404 Not Found`状态。如果消息存在，代码调用`request.get_json`方法来检索请求中作为参数接收到的键值对。代码在`Message`实例的`message_dict`字典中更新特定属性，如果它们有新值：`message`。然后，代码调用`message_schema.dump`方法来检索序列化更新消息时生成的任何错误。如果有错误，代码返回错误和HTTP
    `400 Bad Request`状态。如果没有生成错误，代码调用`message_schema.validate`方法来检索在验证更新消息时生成的任何错误。如果有验证错误，代码返回验证错误和HTTP
    `400 Bad Request`状态。如果验证成功，代码调用Message实例的更新方法以在数据库中持久化更改，并返回调用之前解释的`self.get`方法的结果，其中将更新消息的id作为参数。这样，该方法以JSON格式作为主体返回序列化的更新消息，并带有默认的HTTP
    `200 OK`状态码。'
- en: 'Now, we will create a `MessageListResource` class that we will use to represent
    the collection of messages. Open the previously created `api/views.py` file and
    add the following lines. The code file for the sample is included in the `restful_python_chapter_06_01`
    folder:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个`MessageListResource`类，我们将使用它来表示消息集合。打开之前创建的`api/views.py`文件，并添加以下行。示例的代码文件包含在`restful_python_chapter_06_01`文件夹中：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `MessageListResource` class is a subclass of `flask_restful.Resource` and
    declares the following two methods that will be called when the `HTTP` method
    with the same name arrives as a request on the represented resource:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageListResource`类是`flask_restful.Resource`的子类，并声明了以下两个方法，当在表示的资源上接收到具有相同名称的`HTTP`方法请求时将被调用：'
- en: '`get`: This method returns a list with all the `Message` instances saved in
    the database. First, the code calls the `Message.query.all` method to retrieve
    all the `Message` instances persisted in the database. Then, the code calls the
    `message_schema.dump` method with the retrieved messages and the `many` argument
    set to `True` to serialize the iterable collection of objects. The `dump` method
    will take each `Message` instance retrieved from the database and apply the field
    filtering and output formatting specified the `MessageSchema` class. The code
    returns the `data` attribute of the result returned by the dump method, that is,
    the serialized messages in JSON format as the body with the default HTTP `200
    OK` status code.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`: 此方法返回一个包含数据库中保存的所有`Message`实例的列表。首先，代码调用`Message.query.all`方法来检索数据库中持久化的所有`Message`实例。然后，代码调用`message_schema.dump`方法，将检索到的消息和`many`参数设置为`True`以序列化对象的可迭代集合。`dump`方法将取自数据库检索到的每个`Message`实例，并应用由`MessageSchema`类指定的字段过滤和输出格式。代码返回由`dump`方法返回的结果的`data`属性，即以默认HTTP
    `200 OK`状态码作为主体的JSON格式的序列化消息。'
- en: '`post`: This method retrieves the key-value pairs received in the JSON body,
    creates a new `Message` instance and persists it in the database. In case the
    specified category name exists, it uses the existing category. Otherwise, the
    method creates a new `Category` instance and associates the new message to this
    new category. First, the code calls the `request.get_json` method to retrieve
    the key-value pairs received as arguments with the request. Then, the code calls
    the `message_schema.validate` method to validate the new message built with the
    retrieved key-value pairs. Remember that the `MessageSchema` class will execute
    the previously explained `process_category` method before we call the validate
    method, and therefore, the data will be processed before the validation takes
    place. In case there were validation errors, the code returns the validation errors
    and an HTTP `400 Bad Request` status. If the validation is successful, the code
    retrieves the category name received in the JSON body, specifically in the value
    for the `''name''` key of the `''category''` key. Then, the code calls the `Category.query.filter_by`
    method to retrieve a category that matches the retrieved category name. If no
    match is found, the code creates a new `Category` with the retrieved name and
    persists in the database. Then, the code creates a new message with the `message`,
    `duration`, and the appropriate `Category` instance, and persists it in the database.
    Finally, the code returns the serialized saved message in JSON format as the body,
    with the HTTP `201 Created` status code.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post`: 此方法检索JSON体中接收到的键值对，创建一个新的`Message`实例并将其持久化到数据库中。如果指定的类别名称存在，则使用现有的类别。否则，该方法创建一个新的`Category`实例并将新消息关联到这个新类别。首先，代码调用`request.get_json`方法来检索请求中作为参数接收的键值对。然后，代码调用`message_schema.validate`方法来验证使用检索到的键值对构建的新消息。请记住，在调用验证方法之前，`MessageSchema`类将执行之前解释的`process_category`方法，因此数据将在验证之前进行处理。如果存在验证错误，代码将返回验证错误和HTTP
    `400 Bad Request`状态。如果验证成功，代码将检索JSON体中接收到的类别名称，具体是在`''category''`键的`''name''`键的值中。然后，代码调用`Category.query.filter_by`方法来检索与检索到的类别名称匹配的类别。如果没有找到匹配项，代码将使用检索到的名称创建一个新的`Category`并将其持久化到数据库中。然后，代码创建一个新的消息，包含`message`、`duration`和适当的`Category`实例，并将其持久化到数据库中。最后，代码以JSON格式返回序列化的已保存消息作为正文，并带有HTTP
    `201 Created`状态码。'
- en: 'Now, we will create a `CategoryResource` class that we will use to represent
    a category resource. Open the previously created `api/views.py` file and add the
    following lines. The code file for the sample is included in the `restful_python_chapter_06_01`
    folder:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个`CategoryResource`类，我们将使用它来表示类别资源。打开之前创建的`api/views.py`文件，并添加以下行。示例的代码文件包含在`restful_python_chapter_06_01`文件夹中：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `CategoryResource` class is a subclass of `flask_restful.Resource` and
    declares the following three methods that will be called when the `HTTP` method
    with the same name arrives as a request on the represented resource:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`CategoryResource`类是`flask_restful.Resource`的子类，并声明了以下三个方法，当在表示的资源上接收到具有相同名称的HTTP方法请求时将被调用：'
- en: '`get`: This method receives the id of the category that has to be retrieved
    in the `id` argument. The code calls the `Category.query.get_or_404` method to
    return an HTTP `404 Not Found` status in case there is no category with the requested
    id in the underlying database. In case the message exists, the code calls the
    `category_schema.dump` method with the retrieved category as an argument to use
    the `CategorySchema` instance to serialize the `Category` instance whose `id`
    matches the specified `id`. The `dump` method takes the `Category` instance and
    applies the field filtering and output formatting specified in the `CategorySchema`
    class. The code returns the `data` attribute of the result returned by the `dump`
    method, that is, the serialized message in JSON format as the body, with the default
    HTTP `200 OK` status code.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`: 此方法接收要检索的类别的id作为`id`参数。如果底层数据库中没有与请求的id匹配的类别，代码将调用`Category.query.get_or_404`方法返回HTTP
    `404 Not Found`状态。如果消息存在，代码将调用`category_schema.dump`方法，将检索到的类别作为参数，使用`CategorySchema`实例来序列化与指定的`id`匹配的`Category`实例。`dump`方法接受`Category`实例并应用在`CategorySchema`类中指定的字段过滤和输出格式。代码返回`dump`方法返回的结果的`data`属性，即作为正文的序列化消息，以JSON格式，并带有默认的HTTP
    `200 OK`状态码。'
- en: '`patch`: This method receives the id of the category that has to be updated
    or patched in the `id` argument. The code calls the `Category.query.get_or_404`
    method to return an HTTP `404 Not Found` status in case there is no category with
    the requested id in the underlying database. In case the category exists, the
    code calls the `request.get_json` method to retrieve the key-value pairs received
    as arguments with the request. The code updates just the name attribute in case
    it has a new value in the `category_dict` dictionary in the `Category` instance:
    `category`. Then, the code calls the `category_schema.validate` method to retrieve
    any errors generated when validating the updated category. In case there were
    validation errors, the code returns the validation errors and an HTTP `400 Bad
    Request` status. If the validation is successful, the code calls the update method
    for the `Category` instance to persist the changes in the database and returns
    the results of calling the previously explained `self.get` method with the id
    of the updated category as an argument. This way, the method returns the serialized
    updated message in JSON format as the body, with the default HTTP `200 OK` status
    code.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`patch`：此方法接收要更新或修补的类别的 id，作为 `id` 参数。代码调用 `Category.query.get_or_404` 方法，在底层数据库中没有请求
    id 的类别时返回 HTTP `404 Not Found` 状态。如果类别存在，代码调用 `request.get_json` 方法检索请求中作为参数接收的键值对。如果
    `category_dict` 字典中的 `Category` 实例 `category` 有新值，则仅更新名称属性。然后，代码调用 `category_schema.validate`
    方法检索在验证更新类别时生成的任何错误。如果有验证错误，代码返回验证错误和 HTTP `400 Bad Request` 状态。如果验证成功，代码调用 `Category`
    实例的更新方法以将更改持久化到数据库，并返回调用之前解释的 `self.get` 方法的结果，其中以更新类别的 id 作为参数。这样，该方法以 JSON 格式序列化的更新消息作为正文返回，默认
    HTTP `200 OK` 状态码。'
- en: '`delete`: This method receives the id of the category that has to be deleted
    in the `id` argument. The code calls the `Category.query.get_or_404` method to
    return an HTTP `404 Not Found` status in case there is no category with the requested
    id in the underlying database. In case the category exists, the code calls the
    `category.delete` method with the retrieved category as an argument to use the
    `Category` instance to erase itself from the database. Then, the code returns
    an empty response body and a `204 No Content` status code.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete`：此方法接收要删除的类别的 id，作为 `id` 参数。代码调用 `Category.query.get_or_404` 方法，在底层数据库中没有请求
    id 的类别时返回 HTTP `404 Not Found` 状态。如果类别存在，代码调用 `category.delete` 方法，将检索到的类别作为参数，使用
    `Category` 实例将其从数据库中删除。然后，代码返回一个空的响应体和一个 `204 No Content` 状态码。'
- en: 'Now, we will create a `CategoryListResource` class that we will use to represent
    the collection of categories. Open the previously created `api/views.py` file
    and add the following lines. The code file for the sample is included in the `restful_python_chapter_06_01`
    folder:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个 `CategoryListResource` 类，我们将使用它来表示类别集合。打开之前创建的 `api/views.py` 文件，并添加以下行。示例的代码文件包含在
    `restful_python_chapter_06_01` 文件夹中：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `CategoryListResource` class is a subclass of `flask_restful.Resource`
    and declares the following two methods that will be called when the HTTP method
    with the same name arrives as a request on the represented resource:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`CategoryListResource` 类是 `flask_restful.Resource` 的子类，并声明了以下两个方法，当在表示的资源上接收到具有相同名称的
    HTTP 方法请求时，将调用这些方法：'
- en: '`get`: This method returns a list with all the `Category` instances saved in
    the database. First, the code calls the `Category.query.all` method to retrieve
    all the `Category` instances persisted in the database. Then, the code calls the
    `category_schema.dump` method with the retrieved messages and the `many` argument
    set to `True` to serialize the iterable collection of objects. The `dump` method
    will take each `Category` instance retrieved from the database and apply the field
    filtering and output formatting specified the `CategorySchema` class. The code
    returns the `data` attribute of the result returned by the dump method, that is,
    the serialized messages in JSON format as the body, with the default HTTP `200
    OK` status code.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`：此方法返回一个包含在数据库中保存的所有 `Category` 实例的列表。首先，代码调用 `Category.query.all` 方法检索数据库中持久化的所有
    `Category` 实例。然后，代码调用 `category_schema.dump` 方法，将检索到的消息和 `many` 参数设置为 `True` 以序列化对象的可迭代集合。`dump`
    方法将取从数据库检索到的每个 `Category` 实例，并应用由 `CategorySchema` 类指定的字段过滤和输出格式化。代码返回由 `dump`
    方法返回的结果的 `data` 属性，即以 JSON 格式序列化的消息作为正文，默认 HTTP `200 OK` 状态码。'
- en: '`post`: This method retrieves the key-value pairs received in the JSON body,
    creates a new `Category` instance and persists it in the database. First, the
    code calls the `request.get_json` method to retrieve the key-value pairs received
    as arguments with the request. Then, the code calls the `category_schema.validate`
    method to validate the new category built with the retrieved key-value pairs.
    In case there were validation errors, the code returns the validation errors and
    an HTTP `400 Bad Request` status. If the validation is successful, the code creates
    a new category with the specified `name`, and persists it in the database. Finally,
    the code returns the serialized saved category in JSON format as the body, with
    the HTTP `201 Created` status code.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post`：此方法检索 JSON 主体中接收到的键值对，创建一个新的 `Category` 实例并将其持久化到数据库中。首先，代码调用 `request.get_json`
    方法来检索作为请求参数接收到的键值对。然后，代码调用 `category_schema.validate` 方法来验证使用检索到的键值对构建的新类别。如果存在验证错误，代码将返回验证错误和
    HTTP `400 请求错误` 状态。如果验证成功，代码将创建一个新的类别，并使用指定的 `name` 持久化它。最后，代码以 JSON 格式返回序列化的已保存类别作为主体，并带有
    HTTP `201 已创建` 状态码。'
- en: 'The following table shows the method of our previously created classes that
    we want to be executed for each combination of HTTP verb and scope:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了我们要为每个 HTTP 动词和作用域组合执行的先前创建的类的函数：
- en: '| **HTTP verb** | **Scope** | **Class and method** |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP 动词** | **作用域** | **类和方法** |'
- en: '| `GET` | Collection of messages | MessageListResource.get |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 消息集合 | MessageListResource.get |'
- en: '| `GET` | Message | MessageResource.get |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 消息 | MessageResource.get |'
- en: '| `POST` | Collection of messages | MessageListResource.post |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 消息集合 | MessageListResource.post |'
- en: '| `PATCH` | Message | MessageResource.patch |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 消息 | MessageResource.patch |'
- en: '| `DELETE` | Message | MessageResource.delete |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 消息 | MessageResource.delete |'
- en: '| `GET` | Collection of categories | CategoryListResource.get |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 分类集合 | CategoryListResource.get |'
- en: '| `GET` | Message | CategoryResource.get |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 消息 | CategoryResource.get |'
- en: '| `POST` | Collection of messages | CategoryListResource.post |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 消息集合 | CategoryListResource.post |'
- en: '| `PATCH` | Message | CategoryResource.patch |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 消息 | CategoryResource.patch |'
- en: '| `DELETE` | Message | CategoryResource.delete |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 消息 | CategoryResource.delete |'
- en: If the request results in the invocation of a resource with an unsupported `HTTP`
    method, Flask-RESTful will return a response with the HTTP `405 Method Not Allowed`
    status code.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求导致调用一个不支持 `HTTP` 方法的资源，Flask-RESTful 将返回一个包含 HTTP `405 方法不允许` 状态码的响应。
- en: 'We must make the necessary resource routing configurations to call the appropriate
    methods and pass them all the necessary arguments by defining URL rules. The following
    lines configure the resource routing for the api. Open the `api/views.py` file
    created earlier and add the following lines. The code file for the sample is included
    in the `restful_python_chapter_06_01` folder:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须通过定义 URL 规则来进行必要的资源路由配置，以调用适当的方法，并通过传递所有必要的参数。以下行配置了 api 的资源路由。打开之前创建的 `api/views.py`
    文件，并添加以下行。示例的代码文件包含在 `restful_python_chapter_06_01` 文件夹中：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Each call to the `api.add_resource` method routes a URL to a resource, specifically
    to one of the previously declared subclasses of the `flask_restful.Resource` class.
    When there is a request to the API and the URL matches one of the URLs specified
    in the `api.add_resource` method, Flask will call the method that matches the
    HTTP verb in the request for the specified class.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `api.add_resource` 方法都会将一个 URL 路由到一个资源，具体是到 `flask_restful.Resource` 类之前声明的子类之一。当有
    API 请求且 URL 与 `api.add_resource` 方法中指定的 URL 匹配时，Flask 将调用与请求中 HTTP 动词匹配的指定类的相应方法。
- en: Registering the blueprint and running migrations
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册蓝图和运行迁移
- en: Create a new `app.py` file within the `api` folder. The following lines show
    the code that creates a Flask application. The code file for the sample is included
    in the `restful_python_chapter_06_01` folder.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `api` 文件夹中创建一个新的 `app.py` 文件。以下行显示了创建 Flask 应用的代码。示例的代码文件包含在 `restful_python_chapter_06_01`
    文件夹中。
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The code in the `api/app.py` file declares a `create_app` function that receives
    the configuration file name in the `config_filename` argument, set ups a *Flask*
    app with this configuration file, and returns the `app` object. First, the function
    creates the main entry point for the Flask application named `app`. Then, the
    code calls the `app.config.from_object` method with the `config_filename` received
    as an argument. This way, the Flask app uses the values that are specified in
    the variables defined in the Python module received as an argument to set up the
    settings for the *Flask* app.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`api/app.py`文件中的代码声明了一个`create_app`函数，该函数接收配置文件名作为`config_filename`参数，使用此配置文件设置一个`Flask`应用程序，并返回`app`对象。首先，该函数创建Flask应用程序的主要入口点，命名为`app`。然后，代码调用`app.config.from_object`方法，将接收到的`config_filename`作为参数。这样，Flask应用程序使用作为参数接收到的Python模块中定义的变量指定的值来设置`Flask`应用程序的设置。'
- en: The next line calls the `init_app` method for the `flask_sqlalchemy.SQLAlchemy`
    instance created in the `models` module named `db`. The code passes app as an
    argument to link the created Flask app with the SQLAlchemy instance.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行调用`models`模块中创建的`flask_sqlalchemy.SQLAlchemy`实例`db`的`init_app`方法。代码将`app`作为参数传递，以将创建的Flask应用程序与SQLAlchemy实例链接起来。
- en: The next line calls the `app.register_blueprint` method to register the blueprint
    created in the `views` module, named `api_bp`. The url_prefix argument is set
    to `'/api'` because we want the resources to be available with `/api` as a prefix.
    Now `http://localhost:5000/api/` is going to be the URL for the API running on
    the Flask development server. Finally, the function returns the `app` object.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行调用`app.register_blueprint`方法来注册在`views`模块中创建的蓝图，命名为`api_bp`。`url_prefix`参数设置为`'/api'`，因为我们希望资源以`/api`作为前缀可用。现在`http://localhost:5000/api/`将是运行在Flask开发服务器上的API的URL。最后，函数返回`app`对象。
- en: Create a new `run.py` file within the `api` folder. The following lines show
    the code that uses the previously defined create_app function to create a Flask
    application and run it. The code file for the sample is included in the `restful_python_chapter_06_01`
    folder.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在`api`文件夹内创建一个新的`run.py`文件。以下行展示了使用之前定义的`create_app`函数创建Flask应用程序并运行的相关代码。示例代码文件包含在`restful_python_chapter_06_01`文件夹中。
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The code in the `api/run.py` file calls the `create_app` function, declared
    in the `app` module, with `'config'` as an argument. The function will set up
    a *Flask* app with this module as the configuration file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`api/run.py`文件中的代码调用在`app`模块中声明的`create_app`函数，参数为`''config''`。该函数将以该模块作为配置文件设置一个`Flask`应用程序。'
- en: The last line just calls the `app.run` method to start the Flask application
    with the host, port and debug values read from the `config` module. The code starts
    the application by calling the `run` method to immediately launch a local server.
    Remember that we could also achieve the same goal using the `flask` command-line
    script.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行只是调用`app.run`方法，以从`config`模块读取的主机、端口和调试值启动Flask应用程序。代码通过调用`run`方法立即启动本地服务器。记住，我们也可以使用`flask`命令行脚本来达到相同的目的。
- en: 'Create a new `migrate.py` file within the `api` folder. The following lines
    show the code that use `flask_script` and `flask_migrate` to run migrations. The
    code file for the sample is included in the `restful_python_chapter_06_01` folder:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在`api`文件夹内创建一个新的`migrate.py`文件。以下行展示了使用`flask_script`和`flask_migrate`运行迁移的代码。示例代码文件包含在`restful_python_chapter_06_01`文件夹中：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The code creates an instance of `flask_migrate.Migrate` with the *Flask* app
    created in the previously explained `run` module, `app`, and the `flask_sqlalchemy.SQLAlchemy`
    instance created in the models module, `db`. Then, the code creates a `flask_script.Manager`
    class with the Flask app as an argument and saves its reference in the `manager`
    variable. The next line calls the `add_command` method with `'db'` and `MigrateCommand`
    as arguments. The main function calls the run method for the `Manager` instance.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了一个`flask_migrate.Migrate`实例，该实例使用之前在`run`模块中解释的`app`模块创建的`Flask`应用程序和`models`模块中创建的`flask_sqlalchemy.SQLAlchemy`实例`db`。然后，代码创建了一个`flask_script.Manager`类，将Flask应用程序作为参数传递，并将它的引用保存在`manager`变量中。下一行调用`add_command`方法，参数为`'db'`和`MigrateCommand`。主函数调用`Manager`实例的`run`方法。
- en: This way, after the extension initializes, the code adds a db group to the command-line
    options. The db group has many sub-commands that we will use through the `migrate.py`
    script.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，在扩展初始化后，代码向命令行选项中添加了一个db组。该db组有许多子命令，我们将通过`migrate.py`脚本使用这些子命令。
- en: Now, we will run the scripts to run migrations and generate the necessary tables
    in the PostgreSQL database. Make sure you run the scripts in the terminal or Command
    Prompt window in which you have activated the virtual environment and that you
    are located in the `api` folder.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将运行脚本以在PostgreSQL数据库中运行迁移并生成必要的表。请确保您在激活了虚拟环境的终端或命令提示符窗口中运行脚本，并且您位于`api`文件夹中。
- en: Run the first script, that initializes migration support for the application.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 运行第一个脚本，该脚本初始化应用程序的迁移支持。
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following lines show the sample output generated after running the previous
    script. Your output will be different according to the base folder in which you
    have created the virtual environment:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了运行之前的脚本后生成的示例输出。您的输出将根据您创建虚拟环境的基准文件夹而有所不同：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The script generated a new `migrations` sub-folder within the `api` folder with
    a versions sub-folder and many other files.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本在`api`文件夹内生成了一个名为`migrations`的子文件夹，其中包含一个名为`versions`的子文件夹和许多其他文件。
- en: 'Run the second script that populates the migration script with the detected
    changes in the models. In this case, it is the first time we populate the migration
    script, and therefore, the migration script will generate the tables that will
    persist our two models: `Category` and `Message`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 运行第二个脚本，该脚本将检测到的模型更改填充到迁移脚本中。在这种情况下，这是我们第一次填充迁移脚本，因此迁移脚本将生成将持久化我们的两个模型（`Category`和`Message`）的表：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following lines show the sample output generated after running the previous
    script. Your output will be different according to the base folder in which you
    have created the virtual environment:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了运行之前的脚本后生成的示例输出。您的输出将根据您创建虚拟环境的基准文件夹而有所不同：
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output indicates that the `api/migrations/versions/417543056ac3_.py` file
    includes the code to create the `category` and `message` tables. The following
    lines show the code for this file that was automatically generated based on the
    models. Note that the filename will be different in your configuration. The code
    file for the sample is included in the `restful_python_chapter_06_01` folder:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 输出指示`api/migrations/versions/417543056ac3_.py`文件包含了创建`category`和`message`表的代码。以下行显示了基于模型自动生成的此文件的代码。请注意，在您的配置中文件名将会不同。示例的代码文件包含在`restful_python_chapter_06_01`文件夹中：
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The code defines two functions: `upgrade` and `downgrade`. The `upgrade` function
    runs the necessary code to create the `category` and `message` tables by making
    calls to `alembic.op.create_table`. The `downgrade` function runs the necessary
    code to go back to the previous version.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 代码定义了两个函数：`upgrade`和`downgrade`。`upgrade`函数通过调用`alembic.op.create_table`来运行创建`category`和`message`表的必要代码。`downgrade`函数运行必要的代码以回到上一个版本。
- en: 'Run the third script to upgrade the database:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 运行第三个脚本以升级数据库：
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following lines show the sample output generated after running the previous
    script:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了运行之前的脚本后生成的示例输出：
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The previous script called the `upgrade` function defined in the automatically
    generated `api/migrations/versions/417543056ac3_.py` script. Don't forget that
    the file name will be different in your configuration.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的脚本调用了在自动生成的`api/migrations/versions/417543056ac3_.py`脚本中定义的`upgrade`函数。别忘了在您的配置中文件名将会不同。
- en: After we run the previous scripts, we can use the PostgreSQL command line or
    any other application that allows us to easily verify the contents of the PostreSQL
    database to check the tables that the migration generated.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行之前的脚本后，我们可以使用PostgreSQL命令行或任何允许我们轻松验证PostreSQL数据库内容的其他应用程序来检查迁移生成的表。
- en: Run the following command to list the generated tables. In case the database
    name you are using is not named `messages`, make sure you use the appropriate
    database name.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以列出生成的表。如果您使用的数据库名称不是`messages`，请确保您使用适当的数据库名称。
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following lines show the output with all the generated table names:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了所有生成的表名的输出：
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: SQLAlchemy generated the tables, the unique constraints, and the foreign keys
    based on the information included in our models.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy根据我们模型中包含的信息生成了表、唯一约束和外键。
- en: '`category`: Persists the `Category` model.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`category`：持久化`Category`模型。'
- en: '`message`: Persists the `Message` model.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message`：持久化`Message`模型。'
- en: 'The following command will allow you to check the contents of the four tables
    after we compose and send HTTP requests to the RESTful API and make CRUD operations
    to the two tables. The commands assume that you are running PostgreSQL on the
    same computer in which you are running the command:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将允许您在我们编写并发送 HTTP 请求到 RESTful API 并对两个表执行 CRUD 操作后检查四个表的内容。这些命令假设您在运行命令的同一台计算机上运行
    PostgreSQL：
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Tip
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Instead of working with the PostgreSQL command-line utility, you can use a GUI
    tool to check the contents of the PostgreSQL database. You also use also the database
    tools included in your favorite IDE to check the contents for the SQLite database.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 GUI 工具而不是 PostgreSQL 命令行实用程序来检查 PostgreSQL 数据库的内容。您还可以使用您最喜欢的 IDE 中包含的数据库工具来检查
    SQLite 数据库的内容。
- en: Alembic generated an additional table named `alembic_version` that saves the
    version number for the database in the `version_num` column. This table makes
    is possible for the migration scripts to retrieve the current version of the database
    and upgrade or downgrade it based on our needs.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Alembic 生成了一个名为 `alembic_version` 的附加表，该表在 `version_num` 列中保存数据库的版本号。这个表使得迁移脚本能够检索数据库的当前版本，并根据我们的需求升级或降级它。
- en: Creating and retrieving related resources
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和检索相关资源
- en: Now, we can run the `api/run.py` script that launches Flask's development. Execute
    the following command in the api folder.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行`api/run.py`脚本以启动 Flask 的开发模式。在 api 文件夹中执行以下命令。
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The following lines show the output after we execute the preceding command.
    The development server is listening at port `5000`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了执行上述命令后的输出。开发服务器正在端口 `5000` 上监听。
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now, we will use the HTTPie command or its curl equivalents to compose and send
    HTTP requests to the API. We will use JSON for the requests that require additional
    data. Remember that you can perform the same tasks with your favorite GUI-based
    tool.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 HTTPie 命令或其 curl 等效命令来编写并发送 HTTP 请求到 API。对于需要额外数据的请求，我们将使用 JSON。请记住，您可以使用您喜欢的基于
    GUI 的工具执行相同的任务。
- en: 'First, we will compose and send HTTP requests to create two message categories:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将编写并发送 HTTP 请求来创建两个消息类别：
- en: '[PRE46]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following are the equivalent `curl` commands:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与 `curl` 命令等效的命令：
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The preceding commands will compose and send two `POST` HTTP requests with the
    specified JSON key-value pair. The requests specify `/api/categories/`, and therefore,
    they will match the `'/api'url_prefix` for the `api_bp` blueprint. Then, the request
    will match the `'/categories/'` URL route for the `CategoryList` resource and
    run the `CategoryList.post` method. The method doesn't receive arguments because
    the URL route doesn't include any parameters. As the HTTP verb for the request
    is `POST`, Flask calls the `post` method. If the two new `Category` instances
    were successfully persisted in the database, the two calls will return an `HTTP
    201 Created` status code and the recently persisted `Category` serialized to JSON
    in the response body. The following lines show an example response for the two
    HTTP requests, with the new `Category` objects in the JSON responses.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将编写并发送两个带有指定 JSON 键值对的 `POST` HTTP 请求。请求指定 `/api/categories/`，因此它们将匹配 `api_bp`
    蓝图的 `'/api'url_prefix`。然后，请求将匹配 `'/categories/'` URL 路由，并运行 `CategoryList.post`
    方法。由于 URL 路由不包含任何参数，该方法不接收任何参数。由于请求的 HTTP 动词是 `POST`，Flask 调用 `post` 方法。如果两个新的
    `Category` 实例成功持久化到数据库中，这两个调用将返回 `HTTP 201 Created` 状态码，并在响应体中将最近持久化的 `Category`
    序列化为 JSON。以下行显示了两个 HTTP 请求的示例响应，其中包含 JSON 响应中的新 `Category` 对象。
- en: 'Note that the responses include the URL, `url`, for the created categories.
    The `messages` array is empty in both cases because there aren''t messages related
    to each new category yet:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，响应包括创建的类别的 URL，`url`。在两种情况下，`messages`数组都是空的，因为没有与每个新类别相关的消息：
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we will compose and send HTTP requests to create two messages that belong
    to the first message category we recently created: `Information`. We will specify
    the `category` key with the name of the desired message category. The database
    table that persists the `Message` model will save the value of the primary key
    of the related `Category` whose name value matches the one we provide:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送 HTTP 请求来创建两个属于我们最近创建的第一个消息类别的消息：`信息`。我们将使用所需消息类别的名称指定`category`键。持久化`Message`模型的数据库表将保存与名称值匹配的关联`Category`的主键值：
- en: '[PRE49]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following are the equivalent `curl` commands:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE50]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The first command will compose and send the following HTTP request: `POST http://localhost:5000/api/messages/`
    with the following JSON key-value pairs:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令将编写并发送以下 HTTP 请求：`POST http://localhost:5000/api/messages/`，并带有以下 JSON
    键值对：
- en: '[PRE51]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The second command will compose and send the same HTTP request with the following
    JSON key-value pairs:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命令将使用以下 JSON 键值对编写并发送相同的 HTTP 请求：
- en: '[PRE52]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The requests specify `/api/categories/`, and therefore, they will match the
    `'/api'url_prefix` for the `api_bp` blueprint. Then, the request will match the
    `'/messages/'` URL route for the `MessageList` resource and run the `MessageList.post`
    method. The method doesn't receive arguments because the URL route doesn't include
    any parameters. As the HTTP verb for the request is `POST`, Flask calls the `post`
    method. The the `MessageSchema.process_category` method will process the data
    for the category and the `MessageListResource.post` method will retrieve the `Category`
    that matches the specified category name from the database, to use it as the related
    category for the new message. If the two new `Message` instances were successfully
    persisted in the database, the two calls will return an `HTTP 201 Created` status
    code and the recently persisted `Message` serialized to JSON in the response body.
    The following lines show an example response for the two HTTP requests, with the
    new `Message` objects in the JSON responses. Note that the responses include the
    URL, `url`, for the created messages. In addition, the response includes the `id`,
    `name`, and `url` for the related category.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 请求指定了 `/api/categories/`，因此，它们将与 `api_bp` 蓝图的 `'/api'url_prefix` 匹配。然后，请求将与
    `MessageList` 资源的 `'/messages/'` URL 路由匹配，并运行 `MessageList.post` 方法。由于 URL 路由不包含任何参数，该方法不接收任何参数。由于请求的
    HTTP 动词是 `POST`，Flask 调用 `post` 方法。`MessageSchema.process_category` 方法将处理类别的数据，而
    `MessageListResource.post` 方法将从数据库中检索与指定的类别名称匹配的 `Category`，用作新消息的相关类别。如果两个新的
    `Message` 实例成功持久化到数据库中，这两个调用将返回 `HTTP 201 Created` 状态码，并在响应体中将最近持久化的 `Message`
    序列化为 JSON。以下行显示了两个 HTTP 请求的示例响应，其中包含 JSON 响应中的新 `Message` 对象。请注意，响应包括创建消息的 URL，即
    `url`。此外，响应还包括相关类别的 `id`、`name` 和 `url`。
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can run the preceding commands to check the contents of the tables that
    the migrations created in the PostgreSQL database. We will notice that the `category_id`
    column for the `message` table saves the value of the primary key of the related
    row in the `category` table. The `MessageSchema` class uses a `fields.Nested`
    instance to render the `id`, `url` and name fields for the related `Category`.
    The following screenshot shows the contents for the `category` and the `message`
    table in a PostgreSQL database after running the HTTP requests:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行前面的命令来检查在 PostgreSQL 数据库中创建的迁移的表内容。我们会注意到 `message` 表的 `category_id` 列保存了
    `category` 表中相关行的主键值。`MessageSchema` 类使用 `fields.Nested` 实例来渲染相关 `Category` 的
    `id`、`url` 和名称字段。以下截图显示了在运行 HTTP 请求后 PostgreSQL 数据库中 `category` 和 `message` 表的内容：
- en: '![Creating and retrieving related resources](img/image_06_001.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![创建和检索相关资源](img/image_06_001.jpg)'
- en: 'Now, we will compose and send an HTTP request to retrieve the category that
    contains two messages, that is the category resource whose id or primary key is
    equal to `1`. Don''t forget to replace `1` with the primary key value of the category
    whose name is equal to `''Information''` in your configuration:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送一个 HTTP 请求来检索包含两个消息的类别，即 id 或主键等于 `1` 的类别资源。不要忘记将 `1` 替换为您配置中名称等于
    `'Information'` 的类别的主键值：
- en: '[PRE54]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The following is the equivalent curl command:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 curl 命令：
- en: '[PRE55]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The preceding command will compose and send a `GET` HTTP request. The request
    has a number after `/api/categories/`, and therefore, it will match `''/categories/<int:id>''`
    and run the `CategoryResource.get` method, that is, the `get` method for the `CategoryResource`
    class. If a `Category` instance with the specified id exists in the database,
    the call to the method will will return an `HTTP200 OK` status code and the `Category`
    instance serialized to JSON in the response body. The `CategorySchema` class uses
    a `fields.Nested` instance to render all the fields for all the messages related
    to the category excepting the category field. The following lines show a sample
    response:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将组合并发送一个 `GET` HTTP 请求。请求在 `/api/categories/` 后面有一个数字，因此，它将匹配 `'/categories/<int:id>'`
    并运行 `CategoryResource.get` 方法，即 `CategoryResource` 类的 `get` 方法。如果数据库中存在具有指定 id
    的 `Category` 实例，该方法调用将返回 `HTTP200 OK` 状态码，并在响应体中将 `Category` 实例序列化为 JSON。`CategorySchema`
    类使用一个 `fields.Nested` 实例来渲染与类别相关的所有消息的字段，除了类别字段。以下行显示了一个示例响应：
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we will compose and send a `POST` HTTP request to create a message related
    to a category name that doesn''t exist: `''Error''`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将组合并发送一个 `POST` HTTP 请求来创建一个与不存在类别名称相关的消息：`'Error'`：
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The following are the equivalent curl commands:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 curl 命令：
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `CategoryListResource.post` method won''t be able to retrieve a `Category`
    instance whose `name` is equal to the specified value, and therefore, the method
    will create a new `Category`, save it and use it as the related category for the
    new message. The following lines show an example response for the HTTP request,
    with the new `Message` object in the JSON responses and the details for the new
    `Category` object related to the message:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`CategoryListResource.post` 方法无法检索一个 `name` 等于指定值的 `Category` 实例，因此，该方法将创建一个新的
    `Category`，保存它并将其用作新消息的相关类别。以下行显示了一个 HTTP 请求的示例响应，其中包含 JSON 响应中的新 `Message` 对象以及与消息相关的新
    `Category` 对象的详细信息：'
- en: '[PRE59]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We can run the commands explained earlier to check the contents of the tables
    that the migrations created in the PostgreSQL database. We will notice that we
    have a new row in the category table with the recently added category when we
    created a new message. The following screenshot shows the contents for the `category`
    and `message` tables in a PostgreSQL database after running the HTTP requests:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行前面解释的命令来检查在 PostgreSQL 数据库中由迁移创建的表的内容。当我们创建新消息时，我们会注意到类别表中出现了一行新行，其中包含最近添加的类别。以下屏幕截图显示了在运行
    HTTP 请求后 PostgreSQL 数据库中 `category` 和 `message` 表的内容：
- en: '![Creating and retrieving related resources](img/image_06_002.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![创建和检索相关资源](img/image_06_002.jpg)'
- en: Test your knowledge
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'Marshmallow is:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Marshmallow 是：
- en: A lightweight library for converting complex datatypes to and from native Python
    datatypes.
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个用于将复杂数据类型转换为和从原生 Python 数据类型转换的轻量级库。
- en: An ORM .
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 ORM。
- en: A lightweight web framework that replaces Flask.
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个轻量级 Web 框架，用于替代 Flask。
- en: 'SQLAlchemy is:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SQLAlchemy 是：
- en: A lightweight library for converting complex datatypes to and from native Python
    datatypes.
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个用于将复杂数据类型转换为和从原生 Python 数据类型转换的轻量级库。
- en: An ORM .
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 ORM。
- en: A lightweight web framework that replaces Flask.
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个轻量级 Web 框架，用于替代 Flask。
- en: 'The `marshmallow.pre_load` decorator:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`marshmallow.pre_load` 装饰器：'
- en: Registers a method to run after any instance of the `MessageSchema` class is
    created.
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建 `MessageSchema` 类的任何实例之后注册一个要运行的方法。
- en: Registers a method to invoke after serializing an object.
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在序列化对象之后注册一个要调用的方法。
- en: Registers a method to invoke before deserializing an object.
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在反序列化对象之前注册一个要调用的方法。
- en: 'The `dump` method for any instance of a Schema subclass:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何 Schema 子类实例的 `dump` 方法：
- en: Routes URLs to Python primitives.
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 URL 路由到 Python 原语。
- en: Persists the instance or collection of instances passed as an argument to the
    database.
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将作为参数传递的实例或实例集合持久化到数据库。
- en: Takes the instance or collection of instances passed as an argument and applies
    the field filtering and output formatting specified in the Schema subclass to
    the instance or collection of instances.
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受作为参数传递的实例或实例集合，并将 Schema 子类中指定的字段过滤和输出格式应用于实例或实例集合。
- en: 'When we declare an attribute as an instance of the `marshmallow.fields.Nested`
    class:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们声明一个属性为 `marshmallow.fields.Nested` 类的实例时：
- en: The field will nest a single `Schema` or a collection of `Schema` based on the
    value for the `many` argument.
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该字段将根据 `many` 参数的值嵌套单个 `Schema` 或 `Schema` 的集合。
- en: The field will nest a single `Schema`. If we want to nest a collection of `Schema`,
    we have to use an instance of the `marshmallow.fields.NestedCollection` class.
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该字段将嵌套一个单个 `Schema`。如果我们想嵌套一个 `Schema` 集合，我们必须使用 `marshmallow.fields.NestedCollection`
    类的实例。
- en: The field will nest a collection of `Schema`. If we want to nest a single `Schema`,
    we have to use an instance of the `marshmallow.fields.NestedSingle` class.
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该字段将嵌套一个 `Schema` 集合。如果我们想嵌套一个单个 `Schema`，我们必须使用 `marshmallow.fields.NestedSingle`
    类的实例。
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we expanded the capabilities of the previous version of the
    RESTful API that we created in the previous chapter. We used SQLAlchemy as our
    ORM to work with a PostgreSQL database. We installed many packages to simplify
    many common tasks, wrote code for the models and their relationships, and worked
    with schemas to validate, serialize, and deserialize these models.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们扩展了上一章中创建的 RESTful API 的功能。我们使用 SQLAlchemy 作为我们的 ORM 与 PostgreSQL 数据库一起工作。我们安装了许多包以简化许多常见任务，为模型及其关系编写了代码，并使用模式来验证、序列化和反序列化这些模型。
- en: We combined blueprints with resourceful routing and were able to generate the
    database from the models. We composed and sent many HTTP requests to our RESTful
    API and analyzed how each HTTP request was processed in our code and how the models
    persisted in the database tables.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将蓝图与资源路由相结合，能够从模型生成数据库。我们对 RESTful API 发送了许多 HTTP 请求，并分析了每个 HTTP 请求在我们的代码中是如何处理的，以及模型如何在数据库表中持久化。
- en: Now that we built a complex API with Flask, Flask-RESTful, and SQLAlchemy, we
    will use additional features and add security and authentication, which is what
    we are going to discuss in the next chapter.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用 Flask、Flask-RESTful 和 SQLAlchemy 构建了一个复杂的 API，我们将使用额外的功能并添加安全性和认证，这是我们将在下一章中讨论的内容。
