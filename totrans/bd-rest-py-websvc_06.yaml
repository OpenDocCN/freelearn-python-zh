- en: Chapter 6.  Working with Models, SQLAlchemy, and Hyperlinked APIs in Flask
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。在Flask中使用模型、SQLAlchemy和超链接API进行工作
- en: 'In this chapter, we will expand the capabilities of the RESTful API that we
    started in the previous chapter. We will use SQLAlchemy as our ORM to work with
    a PostgreSQL database and we will take advantage of advanced features included
    in Flask and Flask-RESTful that will allow us to easily organize code for complex
    APIs, such as models and blueprints. In this chapter, we will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将扩展上一章开始构建的RESTful API的功能。我们将使用SQLAlchemy作为我们的ORM来与PostgreSQL数据库交互，并且我们将利用Flask和Flask-RESTful中包含的先进功能，这将使我们能够轻松组织代码以构建复杂的API，如模型和蓝图。在本章中，我们将：
- en: Design a RESTful API to interact with a PostgreSQL database
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个RESTful API以与PostgreSQL数据库交互
- en: Understand the tasks performed by each HTTP method
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解每个HTTP方法执行的任务
- en: Install packages to simplify our common tasks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装包以简化我们的常见任务
- en: Create and configure the database
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和配置数据库
- en: Write code for the models with their relationships
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为模型编写包含其关系的代码
- en: Use schemas to validate, serialize, and deserialize models
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模式来验证、序列化和反序列化模型
- en: Combine blueprints with resourceful routing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将蓝图与资源路由相结合
- en: Register the blueprint and run migrations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册蓝图并运行迁移
- en: Create and retrieve related resources
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和检索相关资源
- en: Designing a RESTful API to interact with a PostgreSQL database
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计一个与PostgreSQL数据库交互的RESTful API
- en: So far, our RESTful API has performed CRUD operations on a simple dictionary
    that acted as a data repository. Now, we want to create a more complex RESTful
    API with Flask RESTful to interact with a database model that has to allow us
    to work with messages that are grouped into message categories. In our previous
    RESTful API, we used a string attribute to specify the message category for a
    message. In this case, we want to be able to easily retrieve all the messages
    that belong to a specific message category, and therefore, we will have a relationship
    between a message and a message category.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的RESTful API已经在充当数据存储库的简单字典上执行了CRUD操作。现在，我们想要使用Flask RESTful创建一个更复杂的RESTful
    API，以与必须允许我们处理分组到消息类别中的消息的数据库模型交互。在我们的上一个RESTful API中，我们使用一个字符串属性来指定消息的消息类别。在这种情况下，我们希望能够轻松检索属于特定消息类别的所有消息，因此，我们将有一个消息与消息类别之间的关系。
- en: 'We must be able to perform CRUD operations on different related resources and
    resource collections. The following list enumerates the resources and the class
    name that we will create to represent the model:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须能够对不同的相关资源和资源集合执行CRUD操作。以下列表列举了我们将创建以表示模型的资源和类名：
- en: Message categories (`Category` model)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息类别（`Category`模型）
- en: Messages (`Message` model)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息（`Message`模型）
- en: 'The message category (`Category`) just requires an integer name, and we need
    the following data for a message (`Message`):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 消息类别（`Category`）只需要一个整数字符串名称，而对于消息（`Message`），我们需要以下数据：
- en: An integer identifier
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数标识符
- en: A foreign key to a message category (`Category`)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向消息类别（`Category`）的外键
- en: A string message
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字符串消息
- en: The duration in seconds that will indicate the time the message has to be printed
    on the OLED display
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将指示消息在OLED显示屏上打印时间的秒数
- en: The creation date and time. The timestamp will be added automatically when adding
    a new message to the collection
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建日期和时间。时间戳将在将新消息添加到集合时自动添加
- en: An integer counter that indicates the times the message has been printed in
    the OLED display
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指示消息在OLED显示屏上打印次数的整数计数器
- en: A `bool` value indicating whether the message was printed at least once on the
    OLED display
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`bool`值，指示消息是否至少在OLED显示屏上打印过一次
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We will take advantage of the many packages related to Flask RESTful and SQLAlchemy
    that make it easier to serialize and deserialize data, perform validations, and
    integrate SQLAlchemy with Flask and Flask RESTful.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用与Flask RESTful和SQLAlchemy相关的许多包，这些包使得序列化和反序列化数据、执行验证以及将SQLAlchemy与Flask和Flask
    RESTful集成变得更加容易。
- en: Understanding the tasks performed by each HTTP method
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解每个HTTP方法执行的任务
- en: 'The following table shows the HTTP verbs, the scope, and the semantics for
    the methods that our new API must support. Each method is composed of an HTTP
    verb, a scope, and all the methods have well-defined meanings for all the resources
    and collections:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了我们的新API必须支持的方法的HTTP动词、作用域和语义。每个方法由一个HTTP动词、一个作用域以及所有方法对所有资源和集合都有明确定义的意义组成：
- en: '| **HTTP verb** | **Scope** | **Semantics** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP动词** | **作用域** | **语义** |'
- en: '| `GET` | Collection of message categories | Retrieve all the stored message
    categories in the collection and return them sorted by their name in ascending
    order. Each category must include the full URL for the resource. Each category
    must include a list with all the details for the messages that belong to the category.
    The messages don''t have to include the category in order to avoid repeating data.
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 消息类别集合 | 获取集合中所有存储的消息类别，并按名称升序排序返回它们。每个类别必须包括资源的完整URL。每个类别必须包括一个包含属于该类别所有消息详细信息的列表。消息不必包括类别，以避免重复数据。
    |'
- en: '| `GET` | Message category | Retrieve a single message category. The category
    must include the same information explained for each category when we retrieve
    a collection of message category. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 消息类别 | 获取单个消息类别。该类别必须包括我们在检索消息类别集合时为每个类别解释的相同信息。 |'
- en: '| `POST` | Collection of message categories | Create a new message category
    in the collection. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 消息类别集合 | 在集合中创建一个新的消息类别。 |'
- en: '| `PATCH` | Message category | Update the name of an existing message category.
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 消息类别 | 更新现有消息类别的名称。 |'
- en: '| `DELETE` | Message category | Delete an existing message category. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 消息类别 | 删除现有的消息类别。 |'
- en: '| `GET` | Collection of messages | Retrieve all the stored messages in the
    collection, sorted by their message in ascending order. Each message must include
    its message category details, including the full URL to access the related resource.
    The message category details don''t have to include the messages that belong to
    the category. The message must include the full URL to access the resource. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 消息集合 | 获取集合中所有存储的消息，按消息升序排序。每条消息必须包括其消息类别详情，包括访问相关资源的完整URL。消息类别详情不必包括属于该类别的消息。消息必须包括访问资源的完整URL。
    |'
- en: '| `GET` | Message | Retrieve a single message. The message must include the
    same information explained for each message when we retrieve a collection of messages.
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 消息 | 获取单个消息。消息必须包括我们在检索消息集合时为每个消息解释的相同信息。 |'
- en: '| `POST` | Collection of messages | Create a new message in the collection.
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 消息集合 | 在集合中创建一个新的消息。 |'
- en: '| `PATCH` | Message | Update any of the following fields of an existing message:
    message, duration, printed_times, and printed_once. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 消息 | 更新现有消息的以下字段：消息、持续时间、打印次数和打印一次。 |'
- en: '| `DELETE` | Message | Delete an existing message. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 消息 | 删除一个现有的消息。 |'
- en: In addition, our RESTful API must support the `OPTIONS` method for all the resources
    and collection of resources. We will use SQLAlchemy as our ORM and we will work
    with a PostgreSQL database. However, in case you don't want to spend time installing
    PostgreSQL, you can use any other database supported by SQLAlchemy, such as MySQL.
    In case you want the simplest database, you can work with SQLite.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的RESTful API必须支持所有资源及其集合的`OPTIONS`方法。我们将使用SQLAlchemy作为我们的ORM，并将与PostgreSQL数据库一起工作。然而，如果你不想花时间安装PostgreSQL，你可以使用SQLAlchemy支持的任何其他数据库，例如MySQL。如果你想要最简单的数据库，你可以使用SQLite。
- en: 'In the preceding table, there are many methods and scopes. The following list
    enumerates the URIs for each scope mentioned in the preceding table, where `{id}`
    has to be replaced with the numeric id or primary key of the resource. As happened
    in the previous example, we want our API to differentiate collections from a single
    resource of the collection in the URLs. When we refer to a collection, we will
    use a slash (`/`) as the last character for the URL and when we refer to a single
    resource of the collection, we won''t use a slash (`/`) as the last character
    for the URL:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表中，有许多方法和范围。以下列表列举了前面表中提到的每个范围的URI，其中`{id}`需要替换为资源的数字ID或主键。正如前一个示例中发生的那样，我们希望我们的API在URL中区分集合和单个集合资源。当我们提到一个集合时，我们将使用斜杠（`/`）作为URL的最后一个字符，当我们提到集合的单个资源时，我们不会使用斜杠（`/`）作为URL的最后一个字符：
- en: '**Collection of message categories**: `/categories/`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息类别集合**: `/categories/`'
- en: '**Message category**: `/category/{id}`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息类别**: `/category/{id}`'
- en: '**Collection of messages**: `/messages/`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息集合**: `/messages/`'
- en: '**Message**: `/message/{id}`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息**: `/message/{id}`'
- en: Let's consider that `http://localhost:5000/api/` is the URL for the API running
    on the Flask development server. We have to compose and send an HTTP request with
    the following HTTP verb (`GET`) and request URL (`http://localhost:5000/api/categories/`)
    to retrieve all the stored message categories in the collection. Each category
    will include a list with all the messages that belong to the category.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设 `http://localhost:5000/api/` 是 Flask 开发服务器上运行的 API 的 URL。我们必须使用以下 HTTP
    动词 (`GET`) 和请求 URL (`http://localhost:5000/api/categories/`) 来组合和发送一个 HTTP 请求，以检索存储在集合中的所有消息类别。每个类别将包含一个列表，列出属于该类别的所有消息。
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Installing packages to simplify our common tasks
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装包以简化我们的常见任务
- en: Make sure you quit Flask's development server. Remember that you just need to
    press ***Ctrl*** + ***C*** in the Terminal or Command Prompt window in which it
    is running. Now, we will install many additional packages. Make sure you have
    activated the virtual environment we have created in the previous chapter and
    we named `Flask01`. In case you created a new virtual environment to work with
    this example or you downloaded the sample code for the book, make sure you install
    the packages we used in the previous example.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已退出 Flask 的开发服务器。请记住，您只需在运行它的终端或命令提示符窗口中按 ***Ctrl*** + ***C*** 即可。现在，我们将安装许多额外的包。确保您已激活我们在上一章中创建并命名为
    `Flask01` 的虚拟环境。如果您为处理此示例或下载了本书的示例代码创建了新的虚拟环境，请确保您安装了我们在上一示例中使用的包。
- en: After you activate the virtual environment, it is time to run commands that
    will be the same for either macOS, Linux, or Windows. We can install all the necessary
    packages with pip with a single command. However, we will run independent commands
    to make it easier to detect any problems in case a specific installation fails.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在激活虚拟环境后，现在是时候运行适用于 macOS、Linux 或 Windows 的相同命令了。我们可以使用单个命令使用 pip 安装所有必要的包。然而，我们将运行独立的命令，以便在特定安装失败时更容易检测到任何问题。
- en: 'Now, we must run the following command to install Flask-SQLAlchemy with pip.
    Flask-SQLAlchemy adds support for the SQLAlchemy ORM to Flask applications. This
    extension simplifies executing common SQLAlchemy tasks within a Flask application.
    SQLAlchemy is a dependency for Flask-SQLAlchemy, and therefore, pip will install
    it automatically, too:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须运行以下命令使用 pip 安装 Flask-SQLAlchemy。Flask-SQLAlchemy 为 Flask 应用程序添加了对 SQLAlchemy
    ORM 的支持。此扩展简化了在 Flask 应用程序中执行常见 SQLAlchemy 任务。SQLAlchemy 是 Flask-SQLAlchemy 的依赖项，因此，pip
    也会自动安装它：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The last lines of the output will indicate all the packages that have been
    successfully installed, including `SQLAlchemy` and `Flask-SQLAlchemy`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示所有成功安装的包，包括 `SQLAlchemy` 和 `Flask-SQLAlchemy`：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the following command to install Flask-Migrate with pip. Flask-Migrate uses
    the Alembic package to handle SQLAlchemy database migrations for Flask applications.
    We will use Flask-Migrate to set up our PostgreSQL database. Flask-Script is one
    of the dependencies for Flask-Migrate, and therefore, pip will install it automatically.
    Flask-Script adds support for writing external scripts in Flask, including scripts
    to set up a database.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令使用 pip 安装 Flask-Migrate。Flask-Migrate 使用 Alembic 包来处理 Flask 应用程序的 SQLAlchemy
    数据库迁移。我们将使用 Flask-Migrate 来设置我们的 PostgreSQL 数据库。Flask-Script 是 Flask-Migrate 的一个依赖项，因此，pip
    也会自动安装它。Flask-Script 为 Flask 添加了编写外部脚本的支持，包括设置数据库的脚本。
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The last lines for the output will indicate all the packages that have been
    successfully installed, including `Flask-Migrate` and `Flask-Script`. The other
    installed packages are additional dependencies:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示所有成功安装的包，包括 `Flask-Migrate` 和 `Flask-Script`。其他已安装的包是额外的依赖项：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Run the following command to install marshmallow with pip. Marshmallow is a
    lightweight library for converting complex datatypes to and from native Python
    datatypes. Marshmallow provides schemas that we can use to validate input data,
    deserialize input data to app-level objects, and serialize app-level objects to
    Python primitive types:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令使用 pip 安装 marshmallow。Marshmallow 是一个轻量级库，用于将复杂的数据类型转换为原生 Python 数据类型，反之亦然。Marshmallow
    提供了我们可以用来验证输入数据、将输入数据反序列化为应用级对象以及将应用级对象序列化为 Python 原始类型的模式：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The last lines for the output will indicate `marshmallow` has been successfully
    installed:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示 `marshmallow` 已成功安装：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the following command to install Marshmallow-sqlalchemy with pip. Marshmallow-sqlalchemy
    provides SQLAlchemy integration with the previously installed marshmallow validation,
    serialization, and deserialization lightweight library:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The last lines for the output will indicate `marshmallow-sqlalchemy` has been
    successfully installed:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, run the following command to install Flask-Marshmallow with pip. Flask-Marshmallow
    integrates the previously installed `marshmallow` library with Flask applications
    and makes it easy to generate a URL and Hyperlink fields:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The last lines for the output will indicate `Flask-Marshmallow` has been successfully
    installed:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Creating and configuring the database
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will create the PostgreSQL database that we will use as a repository
    for our API. You will have to download and install a PostgreSQL database in case
    you aren''t already running it in your computer or in a development server. You
    can download and install this database management system from its web page: [http://www.postgresql.org](http://www.postgresql.org).
    In case you are working with macOS, `Postgres.app` provides a really easy way
    to install and use PostgreSQL on this operating system: [http://postgresapp.com](http://postgresapp.com):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have to make sure that the PostgreSQL bin folder is included in the `PATH`
    environmental variable. You should be able to execute the `psql` command-line
    utility from your current Terminal or Command Prompt. In case the folder isn't
    included in the PATH, you will receive an error indicating that the `pg_config`
    file cannot be found when trying to install the `psycopg2` package. In addition,
    you will have to use the full path to each of the PostgreSQL command-line tools
    we will use in the next steps.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the PostgreSQL command-line tools to create a new database named
    `messages`. In case you already have a PostgreSQL database with this name, make
    sure that you use another name in all the commands and configurations. You can
    perform the same task with any PostgreSQL GUI tool. In case you are developing
    on Linux, it is necessary to run the commands as the `postgres` user. Run the
    following command in macOS or Windows to create a new database named `messages`.
    Note that the command won''t produce any output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In Linux, run the following command to use the `postgres` user:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we will use the `psql` command-line tool to run some SQL statements to
    create a specific user that we will use in Flask and assign the necessary roles
    for it. In macOS or Windows, run the following command to launch psql:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In Linux, run the following command to use the postgres user:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then, run the following SQL statements and finally enter \q to exit the psql
    command-line tool. Replace user_name with your desired user name to use in the
    new database and password with your chosen password. We will use the user name
    and password in the Flask configuration. You don't need to run the steps in case
    you are already working with a specific user in PostgreSQL and you have already
    granted privileges to the database for the user. You will see the output indicating
    that the permission was granted.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行以下 SQL 语句，最后输入 \q 以退出 psql 命令行工具。将 user_name 替换为您在新的数据库中希望使用的用户名，将 password
    替换为您选择的密码。我们将在 Flask 配置中使用用户名和密码。如果您已经在 PostgreSQL 中使用特定的用户并且已经为该用户授予了数据库权限，则无需运行这些步骤。您将看到表示权限已授予的输出。
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is necessary to install the Psycopg 2 package (psycopg2). This package is
    a Python-PostgreSQL Database Adapter and SQLAlchemy will use it to interact with
    our recently created PostgreSQL database.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 必须安装 Psycopg 2 软件包（psycopg2）。此软件包是一个 Python-PostgreSQL 数据库适配器，SQLAlchemy 将使用它来与我们的新创建的
    PostgreSQL 数据库交互。
- en: 'Once we made sure that the PostgreSQL `bin` folder is included in the PATH
    environmental variable, we just need to run the following command to install this
    package:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确认 PostgreSQL 的 `bin` 文件夹已包含在 PATH 环境变量中，我们只需运行以下命令来安装此软件包：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The last lines of the output will indicate that the `psycopg2` package has
    been successfully installed:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示 `psycopg2` 软件包已成功安装：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In case you are using the same virtual environment that we created for the previous
    example, the `api` folder already exists. If you create a new virtual environment,
    create a folder named `api` within the root folder for the created virtual environment.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用我们为上一个示例创建的相同虚拟环境，`api` 文件夹已经存在。如果您创建一个新的虚拟环境，请在创建的虚拟环境根目录下创建一个名为 `api`
    的文件夹。
- en: Create a new `config.py` file within the `api` folder. The following lines show
    the code that declares variables that determine the configuration for Flask and
    SQLAlchemy. The `SQL_ALCHEMY_DATABASE_URI` variable generates an SQLAlchemy URI
    for the PostgreSQL database.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `api` 文件夹内创建一个新的 `config.py` 文件。以下行显示了声明变量以确定 Flask 和 SQLAlchemy 配置的代码。`SQL_ALCHEMY_DATABASE_URI`
    变量生成用于 PostgreSQL 数据库的 SQLAlchemy URI。
- en: 'Make sure you specify the desired database name in the value for `DB_NAME`
    and that you configure the user, password, host, and port based on your PostgreSQL
    configuration. In case you followed the previous steps, use the settings specified
    in these steps. The code file for the sample is included in the `restful_python_chapter_06_01`
    folder:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您在 `DB_NAME` 的值中指定了所需的数据库名称，并根据您的 PostgreSQL 配置配置用户、密码、主机和端口。如果您遵循了前面的步骤，请使用这些步骤中指定的设置。示例代码文件包含在
    `restful_python_chapter_06_01` 文件夹中：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will specify the module created earlier as an argument to a function that
    will create a *Flask* app. This way, we have one module that specifies all the
    values for the different configuration variables and another module that creates
    a *Flask* app. We will create the Flask app factory as our final step towards
    our new API.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将指定之前创建的模块作为创建 *Flask* 应用的函数的参数。这样，我们有一个模块指定了所有不同的配置变量，另一个模块创建了一个 *Flask*
    应用。我们将创建 Flask 应用工厂作为我们迈向新 API 的最后一步。
- en: Creating models with their relationships
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有其关系的模型
- en: 'Now, we will create the models that we can use to represent and persist the
    message categories, messages, and their relationships. Open the `api/models.py`
    file and replace its contents with the following code. The lines that declare
    fields related to other models are highlighted in the code listing. In case you
    created a new virtual environment, create a new `models.py` file within the `api`
    folder. The code file for the sample is included in the `restful_python_chapter_06_01`
    folder:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建可以用来表示和持久化消息类别、消息及其关系的模型。打开 `api/models.py` 文件，并用以下代码替换其内容。与其它模型相关的字段声明在代码列表中突出显示。如果您创建了一个新的虚拟环境，请在
    `api` 文件夹中创建一个新的 `models.py` 文件。示例代码文件包含在 `restful_python_chapter_06_01` 文件夹中：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First, the code creates an instance of the `flask_sqlalchemy.SQLAlchemy` class
    named `db`. This instance will allow us to control the SQLAlchemy integration
    for our Flask application. In addition, the instance will provide access to all
    the SQLAlchemy functions and classes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码创建了一个名为 `db` 的 `flask_sqlalchemy.SQLAlchemy` 类的实例。这个实例将允许我们控制 Flask 应用程序的
    SQLAlchemy 集成。此外，该实例将提供访问所有 SQLAlchemy 函数和类的方法。
- en: Then, the code creates an instance of the `flask_marshmallow.Marshmallow` class
    named `ma`. It is very important to create the `flask_sqlalchemy.SQLAlchemy` instance
    before the `Marshmallow` instance, and therefore, order matters in this case.
    Marshmallow is a wrapper class that integrates Mashmallow with a *Flask* application.
    The instance named `ma` will provide access to the `Schema` class, the fields
    defined in `marshmallow.fields`, and the Flask-specific fields declared in `flask_marshmallow.fields`.
    We will use them later when we declare the schemas related to our models.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码创建了一个名为 `ma` 的 `flask_marshmallow.Marshmallow` 类的实例。在创建 `Marshmallow` 实例之前创建
    `flask_sqlalchemy.SQLAlchemy` 实例非常重要，因此在这种情况下，顺序很重要。Marshmallow 是一个包装类，它将 Mashmallow
    与 *Flask* 应用程序集成。名为 `ma` 的实例将提供对 `Schema` 类、在 `marshmallow.fields` 中定义的字段以及声明在
    `flask_marshmallow.fields` 中的 Flask 特定字段的访问。我们将在声明与我们的模型相关的模式时使用它们。
- en: 'The code creates the `AddUpdateDelete` class that declares the following three
    methods to add, update, and delete a resource through SQLAlchemy sessions:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了一个名为 `AddUpdateDelete` 的类，该类声明了以下三个方法，通过 SQLAlchemy 会话添加、更新和删除资源：
- en: '`add`: This method receives the object to be added in the `resource` argument
    and calls the `db.session.add` method with the received resource as an argument
    to create the object in the underlying database. Finally, the code commits the
    session.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add`：此方法接收要添加的对象，并将其作为 `resource` 参数传递，然后使用接收到的资源作为参数调用 `db.session.add` 方法，在底层数据库中创建对象。最后，代码提交会话。'
- en: '`update`: This method just commits the session to persist the changes made
    to the objects in the underlying database.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update`：此方法只是提交会话，以持久化对底层数据库中对象所做的更改。'
- en: '`delete`: This method receives the object to be deleted in the `resource` argument
    and calls the `db.session.delete` method with the received resource as an argument
    to remove the object in the underlying database. Finally, the code commits the
    session.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete`：此方法接收要删除的对象，并将其作为 `resource` 参数传递，然后使用接收到的资源作为参数调用 `db.session.delete`
    方法，从底层数据库中删除对象。最后，代码提交会话。'
- en: 'The code declares the following two models, specifically, two classes, as a
    subclass of both the `db.Model`, and the `AddUpdateDelete` classes:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了以下两个模型，具体来说，是两个类，作为 `db.Model` 和 `AddUpdateDelete` 类的子类：
- en: '`Message`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Message`'
- en: '`Category`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Category`'
- en: We specified the field types, maximum lengths, and defaults for many attributes.
    The attributes that represent fields without any relationship are instances of
    the `db.Column` class. Both models declare an `id` attribute and specify the `True`
    value for the `primary_key` argument to indicate it is the primary key. SQLAlchemy
    will use the data to generate the necessary tables in the PostgreSQL database.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了许多属性的字段类型、最大长度和默认值。表示没有任何关系的字段属性是 `db.Column` 类的实例。两个模型都声明了一个 `id` 属性，并指定了
    `primary_key` 参数的 `True` 值，以指示它是主键。SQLAlchemy 将使用这些数据在 PostgreSQL 数据库中生成必要的表。
- en: 'The `Message` model declares the `category` field with the following line:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message` 模型使用以下行声明了 `category` 字段：'
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The previous line uses the db.relationship function to provide a many-to-one
    relationship to the Category model. The backref argument specifies a call to the
    db.backref function with 'messages' as the first value that indicates the name
    to use for the relation from the related Category object back to a Message object.
    The order_by argument specifies 'Message.message' because we want the messages
    for each category to be sorted by the value of the message field in ascending
    order.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行使用 `db.relationship` 函数提供了到 `Category` 模型的多对一关系。`backref` 参数指定了一个调用 `db.backref`
    函数的调用，其中 `'messages'` 作为第一个值，表示从相关的 `Category` 对象返回到 `Message` 对象的关系名称。`order_by`
    参数指定 `'Message.message'`，因为我们希望每个类别的消息按消息字段的值升序排序。
- en: 'Both models declare a constructor, that is, the `__init__` method. This constructor
    for the `Message` model receives many arguments and uses them to initialize the
    attributes with the same names: `message`, `duration`, and `category`. The constructor
    for the `Category` model receives a `name` argument and uses it to initialize
    the attribute with the same name.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 两个模型都声明了一个构造函数，即 `__init__` 方法。`Message` 模型的构造函数接收许多参数，并使用它们来初始化具有相同名称的属性：`message`、`duration`
    和 `category`。`Category` 模型的构造函数接收一个 `name` 参数，并使用它来初始化具有相同名称的属性。
- en: Creating schemas to validate, serialize, and deserialize models
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用于验证、序列化和反序列化模型的模式
- en: 'Now, we will create the Flask-Marshmallow schemas that we will use to validate,
    serialize, and deserialize the previously declared `Category` and `Message` models
    and their relationships. Open the `api/models.py` file and add the following code
    after the existing lines. The lines that declare the fields related to the other
    schemas are highlighted in the code listing. The code file for the sample is included
    in the `restful_python_chapter_06_01` folder:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建Flask-Marshmallow模式，我们将使用这些模式来验证、序列化和反序列化之前声明的`Category`和`Message`模型及其关系。打开`api/models.py`文件，在现有行之后添加以下代码。与其它模式相关的字段声明在代码列表中被突出显示。示例的代码文件包含在`restful_python_chapter_06_01`文件夹中：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The code declares the following two schemas, specifically, two subclasses of
    the `ma.Schema` class:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了以下两个模式，具体来说，是`ma.Schema`类的两个子类：
- en: '`CategorySchema`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CategorySchema`'
- en: '`MessageSchema`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MessageSchema`'
- en: We don't use the Flask-Marshmallow features that allow us to automatically determine
    the appropriate type for each attribute based on the fields declared in a model
    because we want to use specific options for each field. We declare the attributes
    that represent fields as instances of the appropriate class declared in the `marshmallow.fields`
    module. Whenever we specify the `True` value for the `dump_only` argument, it
    means that we want the field to be read-only. For example, we won't be able to
    provide a value for the `id` field in any of the schemas. The value for this field
    will be automatically generated by the auto-increment primary key in the database.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不使用Flask-Marshmallow提供的特性，这些特性允许我们根据模型中声明的字段自动确定每个属性的适当类型，因为我们想为每个字段使用特定的选项。我们将表示字段的属性声明为`marshmallow.fields`模块中声明的适当类的实例。当我们指定`dump_only`参数的`True`值时，这意味着我们希望该字段为只读。例如，我们无法为任何模式中的`id`字段提供值。该字段的值将由数据库中的自增主键自动生成。
- en: The `CategorySchema` class declares the `name` attribute as an instance of `fields.String`.
    The `required` argument is set to `True` to specify that the field cannot be an
    empty string. The `validate` argument is set to `validate.Length(3)` to specify
    that the field must have a minimum length of 3 characters.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`CategorySchema`类将`name`属性声明为`fields.String`的实例。将`required`参数设置为`True`以指定该字段不能为空字符串。将`validate`参数设置为`validate.Length(3)`以指定该字段必须至少有3个字符长。'
- en: 'The class declares the `url` field with the following line:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 该类通过以下行声明了`url`字段：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `url` attribute is an instance of the `ma.URLFor` class, and this field
    will output the full URL of the resource, that is, of the message category resource.
    The first argument is the Flask endpoint name-`'api.categoryresource'`. We will
    create a `CategoryResource` class later and the `URLFor` class will use it to
    generate the URL. The `id` argument specifies `'<id>'` because we want the `id`
    to be pulled from the object to be serialized. The `id` string enclosed within
    less than (`<`) and greater than (`>`) symbols specifies that we want the field
    to be pulled from the object that has to be serialized. The `_external` attribute
    is set to `True` because we want to generate the full URL for the resource. This
    way, each time we serialize a `Category`, it will include the full URL for the
    resource in the `url` key.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`url`属性是`ma.URLFor`类的实例，该字段将输出资源的完整URL，即消息类别资源的URL。第一个参数是Flask端点名称-`''api.categoryresource''`。我们将在稍后创建`CategoryResource`类，`URLFor`类将使用它来生成URL。`id`参数指定`''<id>''`，因为我们想从要序列化的对象中提取`id`。小于（`<`）和大于（`>`）符号内的`id`字符串指定我们希望从必须序列化的对象中提取字段。`_external`属性设置为`True`，因为我们想为资源生成完整的URL。这样，每次我们序列化`Category`时，它都会在`url`键中包含资源的完整URL。'
- en: Tip
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In this case, we are using our insecure API behind HTTP. In case our API is
    configured with HTTPS, we should set the `_scheme` argument to `'https'` when
    we create the `ma.URLFor` instance.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在使用不安全的API通过HTTP。如果我们的API配置为HTTPS，那么在创建`ma.URLFor`实例时，我们应该将`_scheme`参数设置为`'https'`。
- en: 'The class declares the `messages` field with the following line:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该类通过以下行声明了`messages`字段：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `messages` attribute is an instance of the `marshmallow.fields.Nested` class,
    and this field will nest a collection of `Schema`, and therefore, we specify `True`
    for the `many` argument. The first argument specifies the name for the nested
    `Schema` class as a string. We declare the `MessageSchema` class after we defined
    the `CategorySchema` class. Thus, we specify the `Schema` class name as a string
    instead of using the type that we haven't defined yet.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`messages` 属性是 `marshmallow.fields.Nested` 类的实例，并且这个字段将嵌套一个 `Schema` 集合，因此我们为
    `many` 参数指定了 `True`。第一个参数指定了嵌套 `Schema` 类的名称，作为一个字符串。我们在定义了 `CategorySchema` 类之后声明了
    `MessageSchema` 类。因此，我们指定 `Schema` 类的名称为一个字符串，而不是使用我们尚未定义的类型。'
- en: In fact, we will end up with two objects that nest to each other, that is, we
    will create a two-way nesting between categories and messages. We use the `exclude`
    parameter with a tuple of string to indicate that we want the `category` field
    to be excluded from the fields that are serialized for each message. This way,
    we can avoid infinite recursion because the inclusion of the category field would
    serialize all the messages related to the category.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们将最终得到两个相互嵌套的对象，也就是说，我们将在类别和消息之间创建双向嵌套。我们使用一个字符串元组作为 `exclude` 参数，以指示我们希望从为每个消息序列化的字段中排除
    `category` 字段。这样，我们可以避免无限递归，因为包含类别字段将序列化与该类别相关的所有消息。
- en: When we declared the `Message` model, we used the `db.relationship` function
    to provide a many-to-one relationship to the `Category` model. The `backref` argument
    specified a call to the `db.backref` function with `'messages'` as the first value
    that indicates the name to use for the relation from the related `Category` object
    back to a `Message` object. With the previously explained line, we created the
    messages fields that uses the same name we indicated for the `db.backref` function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明 `Message` 模型时，我们使用了 `db.relationship` 函数来提供与 `Category` 模型的多对一关系。`backref`
    参数指定了一个调用 `db.backref` 函数的调用，其中 `'messages'` 作为第一个值，表示从相关的 `Category` 对象返回到 `Message`
    对象的关系名称。通过之前解释的行，我们创建了使用我们为 `db.backref` 函数指定的相同名称的消息字段。
- en: The `MessageSchema` class declares the `message` attribute as an instance of
    `fields.String`. The `required` argument is set to `True` to specify that the
    field cannot be an empty string. The `validate` argument is set to `validate.Length(1)`
    to specify that the field must have a minimum length of 1 character. The class
    declares the `duration`, `creation_date`, `printed_times` and `printed_once` fields
    with the corresponding classes based on the types we used in the `Message` model.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageSchema` 类将 `message` 属性声明为 `fields.String` 类的实例。`required` 参数设置为 `True`，以指定该字段不能为空字符串。`validate`
    参数设置为 `validate.Length(1)`，以指定该字段必须至少有 1 个字符长。该类使用与我们在 `Message` 模型中使用的类型相对应的类声明了
    `duration`、`creation_date`、`printed_times` 和 `printed_once` 字段。'
- en: 'The class declares the `category` field with the following line:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 类使用以下行声明了 `category` 字段：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `category` attribute is an instance of the `marshmallow.fields.Nested` class
    and this field will nest a single `CategorySchema`. We specify `True` for the
    `required` argument because a message must belong to a category. The first argument
    specifies the name for the nested `Schema` class. We already declared the `CategorySchema`
    class, and therefore, we specify `CategorySchema` as the value for the first argument.
    We use the only parameter with a list of string to indicate the field names that
    we want to be included when the nested `CategorySchema` is serialized. We want
    the `id`, `url`, and `name` fields to be included. We don't specify the `messages`
    field because we don't want the category to serialize the list of messages that
    belong to it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`category` 属性是 `marshmallow.fields.Nested` 类的实例，并且这个字段将嵌套一个 `CategorySchema`。我们为
    `required` 参数指定了 `True`，因为消息必须属于一个类别。第一个参数指定了嵌套 `Schema` 类的名称。我们已经声明了 `CategorySchema`
    类，因此我们指定 `CategorySchema` 作为第一个参数的值。我们使用一个包含字符串列表的唯一参数来指示在序列化嵌套 `CategorySchema`
    时要包含的字段名称。我们希望包含 `id`、`url` 和 `name` 字段。我们没有指定 `messages` 字段，因为我们不希望类别序列化属于它的消息列表。'
- en: 'The class declares the `url` field with the following line:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 类使用以下行声明了 `url` 字段：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `url` attribute is an instance of the `ma.URLFor` class and this field
    will output the full URL of the resource, that is, of the message resource. The
    first argument is the Flask endpoint name: `''api.messageresource''`. We will
    create a `MessageResource` class later and the `URLFor` class will use it to generate
    the URL. The `id` argument specifies `''<id>''` because we want the `id` to be
    pulled from the object to be serialized. The `_external` attribute is set to `True`
    because we want to generate the full URL for the resource. This way, each time
    we serialize a `Message`, it will include the full URL for the resource in the
    `url` key.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The `MessageSchema` class declares a `process_category` method that uses the
    `@pre_load` decorator, specifically, `marshmallow.pre_load`. This decorator registers
    a method to invoke before deserializing an object. This way, before Marshmallow
    deserializes a message, the `process_category` method will be executed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The method receives the data to be deserialized in the `data` argument and it
    returns the processed data. When we receive a request to `POST` a new message,
    the category name can be specified in a key named `'category'`. If a category
    with the specified name exists, we will use the existing category as the one that
    is related to the new message. If a category with the specified name doesn't exist,
    we will create a new category and then we will use this new category as the one
    that is related to the new message. This way, we make it easy for the user to
    create new messages.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The `data` argument might have a category name specified as a string for the
    `'category'` key. However, in other cases, the `'category'` key will include the
    key-value pairs with the field name and field values for an existing category.
    The code in the `process_category` method checks the value for the `'category'`
    key and returns a dictionary with the appropriate data to make it sure that we
    are able to deserialize a category with the appropriate key-value pairs, no matter
    the differences of the incoming data. Finally, the methods returned the processed
    dictionary. We will dive deep on the work done by the `process_category` method
    later when we start composing and sending HTTP requests to the API.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Combining blueprints with resourceful routing
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will create the resources that compose our main building blocks for
    the RESTful API. First, we will create a few instances that we will use in the
    different resources. Then, we will create a `MessageResource` class, that we will
    use to represent the message resource. Create a new `views.py` file within the
    `api` folder and add the following lines. The code file for the sample is included
    in the `restful_python_chapter_06_01` folder, as shown:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The first lines declare the imports and create the following instances that
    we will use in the different classes:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '`api_bp`: It is an instance of the `flask.Blueprint` class that will allow
    us to factor the Flask application into this blueprint. The first argument specifies
    the URL prefix on which we want to register the blueprint: `''api''`.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`category_schema`: It is an instance of the `CategorySchema` class we declared
    in the `models.py` module. We will use `category_schema` to validate, serialize,
    and deserialize categories.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message_schema`: It is an instance of the `MessageSchema` class we declared
    in the `models.py` module. We will use `message_schema` to validate, serialize
    and, deserialize categories.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`api`: It is an instance of the `flask_restful.Api` class that represents the
    main entry point for the application. We pass the previously created `flask.Blueprint`
    instance named `api_bp` as an argument to link the `Api` to the `Blueprint`.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `MessageResource` class is a subclass of `flask_restful.Resource` and declares
    the following three methods that will be called when the HTTP method with the
    same name arrives as a request on the represented resource:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '`get`: This method receives the id of the message that has to be retrieved
    in the `id` argument. The code calls the `Message.query.get_or_404` method to
    return an HTTP `404 Not Found` status in case there is no message with the requested
    id in the underlying database. In case the message exists, the code calls the
    `message_schema.dump` method with the retrieved message as an argument to use
    the `MessageSchema` instance to serialize the `Message` instance whose `id` matches
    the specified `id`. The `dump` method takes the `Message` instance and applies
    the field filtering and output formatting specified in the `MessageSchema` class.
    The code returns the `data` attribute of the result returned by the `dump` method,
    that is, the serialized message in JSON format as the body, with the default HTTP
    `200 OK` status code.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete`: This method receives the id of the message that has to be deleted
    in the `id` argument. The code calls the `Message.query.get_or_404` method to
    return an HTTP `404 Not Found` status in case there is no message with the requested
    id in the underlying database. In case the message exists, the code calls the
    `message.delete` method with the retrieved message as an argument to use the `Message`
    instance to erase itself from the database. Then, the code returns an empty response
    body and a `204 No Content` status code.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`patch`: This method receives the id of the message that has to be updated
    or patched in the `id` argument. The code calls the `Message.query.get_or_404`
    method to return an HTTP `404 Not Found` status in case there is no message with
    the requested id in the underlying database. In case the message exists, the code
    calls the `request.get_json` method to retrieve the key-value pairs received as
    arguments with the request. The code updates specific attributes in case they
    have new values in the `message_dict` dictionary in the `Message` instance: `message`.
    Then, the code calls the `message_schema.dump` method to retrieve any errors generated
    when serializing the updated message. In case there were errors, the code returns
    the errors and an HTTP `400 Bad Request` status. If the serialization didn''t
    generate errors, the code calls the `message_schema.validate` method to retrieve
    any errors generated while validating the updated message. In case there were
    validation errors, the code returns the validation errors and an HTTP `400 Bad
    Request` status. If the validation is successful, the code calls the update method
    for the Message instance to persist the changes in the database and returns the
    results of calling the previously explained `self.get` method with the id of the
    updated message as an argument. This way, the method returns the serialized updated
    message in JSON format as the body, with the default HTTP `200 OK` status code.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will create a `MessageListResource` class that we will use to represent
    the collection of messages. Open the previously created `api/views.py` file and
    add the following lines. The code file for the sample is included in the `restful_python_chapter_06_01`
    folder:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `MessageListResource` class is a subclass of `flask_restful.Resource` and
    declares the following two methods that will be called when the `HTTP` method
    with the same name arrives as a request on the represented resource:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '`get`: This method returns a list with all the `Message` instances saved in
    the database. First, the code calls the `Message.query.all` method to retrieve
    all the `Message` instances persisted in the database. Then, the code calls the
    `message_schema.dump` method with the retrieved messages and the `many` argument
    set to `True` to serialize the iterable collection of objects. The `dump` method
    will take each `Message` instance retrieved from the database and apply the field
    filtering and output formatting specified the `MessageSchema` class. The code
    returns the `data` attribute of the result returned by the dump method, that is,
    the serialized messages in JSON format as the body with the default HTTP `200
    OK` status code.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post`: This method retrieves the key-value pairs received in the JSON body,
    creates a new `Message` instance and persists it in the database. In case the
    specified category name exists, it uses the existing category. Otherwise, the
    method creates a new `Category` instance and associates the new message to this
    new category. First, the code calls the `request.get_json` method to retrieve
    the key-value pairs received as arguments with the request. Then, the code calls
    the `message_schema.validate` method to validate the new message built with the
    retrieved key-value pairs. Remember that the `MessageSchema` class will execute
    the previously explained `process_category` method before we call the validate
    method, and therefore, the data will be processed before the validation takes
    place. In case there were validation errors, the code returns the validation errors
    and an HTTP `400 Bad Request` status. If the validation is successful, the code
    retrieves the category name received in the JSON body, specifically in the value
    for the `''name''` key of the `''category''` key. Then, the code calls the `Category.query.filter_by`
    method to retrieve a category that matches the retrieved category name. If no
    match is found, the code creates a new `Category` with the retrieved name and
    persists in the database. Then, the code creates a new message with the `message`,
    `duration`, and the appropriate `Category` instance, and persists it in the database.
    Finally, the code returns the serialized saved message in JSON format as the body,
    with the HTTP `201 Created` status code.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will create a `CategoryResource` class that we will use to represent
    a category resource. Open the previously created `api/views.py` file and add the
    following lines. The code file for the sample is included in the `restful_python_chapter_06_01`
    folder:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `CategoryResource` class is a subclass of `flask_restful.Resource` and
    declares the following three methods that will be called when the `HTTP` method
    with the same name arrives as a request on the represented resource:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '`get`: This method receives the id of the category that has to be retrieved
    in the `id` argument. The code calls the `Category.query.get_or_404` method to
    return an HTTP `404 Not Found` status in case there is no category with the requested
    id in the underlying database. In case the message exists, the code calls the
    `category_schema.dump` method with the retrieved category as an argument to use
    the `CategorySchema` instance to serialize the `Category` instance whose `id`
    matches the specified `id`. The `dump` method takes the `Category` instance and
    applies the field filtering and output formatting specified in the `CategorySchema`
    class. The code returns the `data` attribute of the result returned by the `dump`
    method, that is, the serialized message in JSON format as the body, with the default
    HTTP `200 OK` status code.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`patch`: This method receives the id of the category that has to be updated
    or patched in the `id` argument. The code calls the `Category.query.get_or_404`
    method to return an HTTP `404 Not Found` status in case there is no category with
    the requested id in the underlying database. In case the category exists, the
    code calls the `request.get_json` method to retrieve the key-value pairs received
    as arguments with the request. The code updates just the name attribute in case
    it has a new value in the `category_dict` dictionary in the `Category` instance:
    `category`. Then, the code calls the `category_schema.validate` method to retrieve
    any errors generated when validating the updated category. In case there were
    validation errors, the code returns the validation errors and an HTTP `400 Bad
    Request` status. If the validation is successful, the code calls the update method
    for the `Category` instance to persist the changes in the database and returns
    the results of calling the previously explained `self.get` method with the id
    of the updated category as an argument. This way, the method returns the serialized
    updated message in JSON format as the body, with the default HTTP `200 OK` status
    code.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete`: This method receives the id of the category that has to be deleted
    in the `id` argument. The code calls the `Category.query.get_or_404` method to
    return an HTTP `404 Not Found` status in case there is no category with the requested
    id in the underlying database. In case the category exists, the code calls the
    `category.delete` method with the retrieved category as an argument to use the
    `Category` instance to erase itself from the database. Then, the code returns
    an empty response body and a `204 No Content` status code.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will create a `CategoryListResource` class that we will use to represent
    the collection of categories. Open the previously created `api/views.py` file
    and add the following lines. The code file for the sample is included in the `restful_python_chapter_06_01`
    folder:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `CategoryListResource` class is a subclass of `flask_restful.Resource`
    and declares the following two methods that will be called when the HTTP method
    with the same name arrives as a request on the represented resource:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '`get`: This method returns a list with all the `Category` instances saved in
    the database. First, the code calls the `Category.query.all` method to retrieve
    all the `Category` instances persisted in the database. Then, the code calls the
    `category_schema.dump` method with the retrieved messages and the `many` argument
    set to `True` to serialize the iterable collection of objects. The `dump` method
    will take each `Category` instance retrieved from the database and apply the field
    filtering and output formatting specified the `CategorySchema` class. The code
    returns the `data` attribute of the result returned by the dump method, that is,
    the serialized messages in JSON format as the body, with the default HTTP `200
    OK` status code.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post`: This method retrieves the key-value pairs received in the JSON body,
    creates a new `Category` instance and persists it in the database. First, the
    code calls the `request.get_json` method to retrieve the key-value pairs received
    as arguments with the request. Then, the code calls the `category_schema.validate`
    method to validate the new category built with the retrieved key-value pairs.
    In case there were validation errors, the code returns the validation errors and
    an HTTP `400 Bad Request` status. If the validation is successful, the code creates
    a new category with the specified `name`, and persists it in the database. Finally,
    the code returns the serialized saved category in JSON format as the body, with
    the HTTP `201 Created` status code.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table shows the method of our previously created classes that
    we want to be executed for each combination of HTTP verb and scope:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP verb** | **Scope** | **Class and method** |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Collection of messages | MessageListResource.get |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Message | MessageResource.get |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Collection of messages | MessageListResource.post |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Message | MessageResource.patch |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Message | MessageResource.delete |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Collection of categories | CategoryListResource.get |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Message | CategoryResource.get |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Collection of messages | CategoryListResource.post |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Message | CategoryResource.patch |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Message | CategoryResource.delete |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: If the request results in the invocation of a resource with an unsupported `HTTP`
    method, Flask-RESTful will return a response with the HTTP `405 Method Not Allowed`
    status code.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'We must make the necessary resource routing configurations to call the appropriate
    methods and pass them all the necessary arguments by defining URL rules. The following
    lines configure the resource routing for the api. Open the `api/views.py` file
    created earlier and add the following lines. The code file for the sample is included
    in the `restful_python_chapter_06_01` folder:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Each call to the `api.add_resource` method routes a URL to a resource, specifically
    to one of the previously declared subclasses of the `flask_restful.Resource` class.
    When there is a request to the API and the URL matches one of the URLs specified
    in the `api.add_resource` method, Flask will call the method that matches the
    HTTP verb in the request for the specified class.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Registering the blueprint and running migrations
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new `app.py` file within the `api` folder. The following lines show
    the code that creates a Flask application. The code file for the sample is included
    in the `restful_python_chapter_06_01` folder.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The code in the `api/app.py` file declares a `create_app` function that receives
    the configuration file name in the `config_filename` argument, set ups a *Flask*
    app with this configuration file, and returns the `app` object. First, the function
    creates the main entry point for the Flask application named `app`. Then, the
    code calls the `app.config.from_object` method with the `config_filename` received
    as an argument. This way, the Flask app uses the values that are specified in
    the variables defined in the Python module received as an argument to set up the
    settings for the *Flask* app.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: The next line calls the `init_app` method for the `flask_sqlalchemy.SQLAlchemy`
    instance created in the `models` module named `db`. The code passes app as an
    argument to link the created Flask app with the SQLAlchemy instance.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: The next line calls the `app.register_blueprint` method to register the blueprint
    created in the `views` module, named `api_bp`. The url_prefix argument is set
    to `'/api'` because we want the resources to be available with `/api` as a prefix.
    Now `http://localhost:5000/api/` is going to be the URL for the API running on
    the Flask development server. Finally, the function returns the `app` object.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `run.py` file within the `api` folder. The following lines show
    the code that uses the previously defined create_app function to create a Flask
    application and run it. The code file for the sample is included in the `restful_python_chapter_06_01`
    folder.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The code in the `api/run.py` file calls the `create_app` function, declared
    in the `app` module, with `'config'` as an argument. The function will set up
    a *Flask* app with this module as the configuration file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The last line just calls the `app.run` method to start the Flask application
    with the host, port and debug values read from the `config` module. The code starts
    the application by calling the `run` method to immediately launch a local server.
    Remember that we could also achieve the same goal using the `flask` command-line
    script.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `migrate.py` file within the `api` folder. The following lines
    show the code that use `flask_script` and `flask_migrate` to run migrations. The
    code file for the sample is included in the `restful_python_chapter_06_01` folder:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The code creates an instance of `flask_migrate.Migrate` with the *Flask* app
    created in the previously explained `run` module, `app`, and the `flask_sqlalchemy.SQLAlchemy`
    instance created in the models module, `db`. Then, the code creates a `flask_script.Manager`
    class with the Flask app as an argument and saves its reference in the `manager`
    variable. The next line calls the `add_command` method with `'db'` and `MigrateCommand`
    as arguments. The main function calls the run method for the `Manager` instance.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: This way, after the extension initializes, the code adds a db group to the command-line
    options. The db group has many sub-commands that we will use through the `migrate.py`
    script.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will run the scripts to run migrations and generate the necessary tables
    in the PostgreSQL database. Make sure you run the scripts in the terminal or Command
    Prompt window in which you have activated the virtual environment and that you
    are located in the `api` folder.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Run the first script, that initializes migration support for the application.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following lines show the sample output generated after running the previous
    script. Your output will be different according to the base folder in which you
    have created the virtual environment:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The script generated a new `migrations` sub-folder within the `api` folder with
    a versions sub-folder and many other files.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the second script that populates the migration script with the detected
    changes in the models. In this case, it is the first time we populate the migration
    script, and therefore, the migration script will generate the tables that will
    persist our two models: `Category` and `Message`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following lines show the sample output generated after running the previous
    script. Your output will be different according to the base folder in which you
    have created the virtual environment:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output indicates that the `api/migrations/versions/417543056ac3_.py` file
    includes the code to create the `category` and `message` tables. The following
    lines show the code for this file that was automatically generated based on the
    models. Note that the filename will be different in your configuration. The code
    file for the sample is included in the `restful_python_chapter_06_01` folder:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The code defines two functions: `upgrade` and `downgrade`. The `upgrade` function
    runs the necessary code to create the `category` and `message` tables by making
    calls to `alembic.op.create_table`. The `downgrade` function runs the necessary
    code to go back to the previous version.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the third script to upgrade the database:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following lines show the sample output generated after running the previous
    script:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The previous script called the `upgrade` function defined in the automatically
    generated `api/migrations/versions/417543056ac3_.py` script. Don't forget that
    the file name will be different in your configuration.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: After we run the previous scripts, we can use the PostgreSQL command line or
    any other application that allows us to easily verify the contents of the PostreSQL
    database to check the tables that the migration generated.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Run the following command to list the generated tables. In case the database
    name you are using is not named `messages`, make sure you use the appropriate
    database name.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following lines show the output with all the generated table names:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: SQLAlchemy generated the tables, the unique constraints, and the foreign keys
    based on the information included in our models.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '`category`: Persists the `Category` model.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message`: Persists the `Message` model.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following command will allow you to check the contents of the four tables
    after we compose and send HTTP requests to the RESTful API and make CRUD operations
    to the two tables. The commands assume that you are running PostgreSQL on the
    same computer in which you are running the command:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Tip
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of working with the PostgreSQL command-line utility, you can use a GUI
    tool to check the contents of the PostgreSQL database. You also use also the database
    tools included in your favorite IDE to check the contents for the SQLite database.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Alembic generated an additional table named `alembic_version` that saves the
    version number for the database in the `version_num` column. This table makes
    is possible for the migration scripts to retrieve the current version of the database
    and upgrade or downgrade it based on our needs.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Creating and retrieving related resources
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we can run the `api/run.py` script that launches Flask's development. Execute
    the following command in the api folder.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The following lines show the output after we execute the preceding command.
    The development server is listening at port `5000`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now, we will use the HTTPie command or its curl equivalents to compose and send
    HTTP requests to the API. We will use JSON for the requests that require additional
    data. Remember that you can perform the same tasks with your favorite GUI-based
    tool.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will compose and send HTTP requests to create two message categories:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following are the equivalent `curl` commands:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The preceding commands will compose and send two `POST` HTTP requests with the
    specified JSON key-value pair. The requests specify `/api/categories/`, and therefore,
    they will match the `'/api'url_prefix` for the `api_bp` blueprint. Then, the request
    will match the `'/categories/'` URL route for the `CategoryList` resource and
    run the `CategoryList.post` method. The method doesn't receive arguments because
    the URL route doesn't include any parameters. As the HTTP verb for the request
    is `POST`, Flask calls the `post` method. If the two new `Category` instances
    were successfully persisted in the database, the two calls will return an `HTTP
    201 Created` status code and the recently persisted `Category` serialized to JSON
    in the response body. The following lines show an example response for the two
    HTTP requests, with the new `Category` objects in the JSON responses.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the responses include the URL, `url`, for the created categories.
    The `messages` array is empty in both cases because there aren''t messages related
    to each new category yet:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we will compose and send HTTP requests to create two messages that belong
    to the first message category we recently created: `Information`. We will specify
    the `category` key with the name of the desired message category. The database
    table that persists the `Message` model will save the value of the primary key
    of the related `Category` whose name value matches the one we provide:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following are the equivalent `curl` commands:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The first command will compose and send the following HTTP request: `POST http://localhost:5000/api/messages/`
    with the following JSON key-value pairs:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The second command will compose and send the same HTTP request with the following
    JSON key-value pairs:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The requests specify `/api/categories/`, and therefore, they will match the
    `'/api'url_prefix` for the `api_bp` blueprint. Then, the request will match the
    `'/messages/'` URL route for the `MessageList` resource and run the `MessageList.post`
    method. The method doesn't receive arguments because the URL route doesn't include
    any parameters. As the HTTP verb for the request is `POST`, Flask calls the `post`
    method. The the `MessageSchema.process_category` method will process the data
    for the category and the `MessageListResource.post` method will retrieve the `Category`
    that matches the specified category name from the database, to use it as the related
    category for the new message. If the two new `Message` instances were successfully
    persisted in the database, the two calls will return an `HTTP 201 Created` status
    code and the recently persisted `Message` serialized to JSON in the response body.
    The following lines show an example response for the two HTTP requests, with the
    new `Message` objects in the JSON responses. Note that the responses include the
    URL, `url`, for the created messages. In addition, the response includes the `id`,
    `name`, and `url` for the related category.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can run the preceding commands to check the contents of the tables that
    the migrations created in the PostgreSQL database. We will notice that the `category_id`
    column for the `message` table saves the value of the primary key of the related
    row in the `category` table. The `MessageSchema` class uses a `fields.Nested`
    instance to render the `id`, `url` and name fields for the related `Category`.
    The following screenshot shows the contents for the `category` and the `message`
    table in a PostgreSQL database after running the HTTP requests:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and retrieving related resources](img/image_06_001.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will compose and send an HTTP request to retrieve the category that
    contains two messages, that is the category resource whose id or primary key is
    equal to `1`. Don''t forget to replace `1` with the primary key value of the category
    whose name is equal to `''Information''` in your configuration:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The following is the equivalent curl command:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The preceding command will compose and send a `GET` HTTP request. The request
    has a number after `/api/categories/`, and therefore, it will match `''/categories/<int:id>''`
    and run the `CategoryResource.get` method, that is, the `get` method for the `CategoryResource`
    class. If a `Category` instance with the specified id exists in the database,
    the call to the method will will return an `HTTP200 OK` status code and the `Category`
    instance serialized to JSON in the response body. The `CategorySchema` class uses
    a `fields.Nested` instance to render all the fields for all the messages related
    to the category excepting the category field. The following lines show a sample
    response:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we will compose and send a `POST` HTTP request to create a message related
    to a category name that doesn''t exist: `''Error''`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The following are the equivalent curl commands:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `CategoryListResource.post` method won''t be able to retrieve a `Category`
    instance whose `name` is equal to the specified value, and therefore, the method
    will create a new `Category`, save it and use it as the related category for the
    new message. The following lines show an example response for the HTTP request,
    with the new `Message` object in the JSON responses and the details for the new
    `Category` object related to the message:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We can run the commands explained earlier to check the contents of the tables
    that the migrations created in the PostgreSQL database. We will notice that we
    have a new row in the category table with the recently added category when we
    created a new message. The following screenshot shows the contents for the `category`
    and `message` tables in a PostgreSQL database after running the HTTP requests:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and retrieving related resources](img/image_06_002.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: Test your knowledge
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Marshmallow is:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A lightweight library for converting complex datatypes to and from native Python
    datatypes.
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An ORM .
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A lightweight web framework that replaces Flask.
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'SQLAlchemy is:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A lightweight library for converting complex datatypes to and from native Python
    datatypes.
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An ORM .
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A lightweight web framework that replaces Flask.
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `marshmallow.pre_load` decorator:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Registers a method to run after any instance of the `MessageSchema` class is
    created.
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Registers a method to invoke after serializing an object.
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Registers a method to invoke before deserializing an object.
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `dump` method for any instance of a Schema subclass:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Routes URLs to Python primitives.
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Persists the instance or collection of instances passed as an argument to the
    database.
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Takes the instance or collection of instances passed as an argument and applies
    the field filtering and output formatting specified in the Schema subclass to
    the instance or collection of instances.
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we declare an attribute as an instance of the `marshmallow.fields.Nested`
    class:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The field will nest a single `Schema` or a collection of `Schema` based on the
    value for the `many` argument.
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The field will nest a single `Schema`. If we want to nest a collection of `Schema`,
    we have to use an instance of the `marshmallow.fields.NestedCollection` class.
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The field will nest a collection of `Schema`. If we want to nest a single `Schema`,
    we have to use an instance of the `marshmallow.fields.NestedSingle` class.
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we expanded the capabilities of the previous version of the
    RESTful API that we created in the previous chapter. We used SQLAlchemy as our
    ORM to work with a PostgreSQL database. We installed many packages to simplify
    many common tasks, wrote code for the models and their relationships, and worked
    with schemas to validate, serialize, and deserialize these models.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: We combined blueprints with resourceful routing and were able to generate the
    database from the models. We composed and sent many HTTP requests to our RESTful
    API and analyzed how each HTTP request was processed in our code and how the models
    persisted in the database tables.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Now that we built a complex API with Flask, Flask-RESTful, and SQLAlchemy, we
    will use additional features and add security and authentication, which is what
    we are going to discuss in the next chapter.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
