<html><head></head><body><div><p>&#13;&#13;
    <h1 class="chapterNumber">4</h1>&#13;&#13;
    <h1 id="_idParaDest-79" class="chapterTitle">The Data Layer</h1>&#13;&#13;
    <p class="normal">The modeling of data when interacting with the application code is as important as how that data is stored in storage. The data layer is the layer that developers will interact with most often, so creating a good interface is critical to create a productive environment.</p>&#13;&#13;
    <p class="normal">In this chapter, we will describe how to create a software data layer that interacts with storage to abstract the specifics of storing data. We will see what Domain-Driven Design is, how to use an Object-Relational Mapping framework, and more advanced patterns, like Command Query Responsibility Segregation.</p>&#13;&#13;
    <p class="normal">We will also talk about how to make changes to the database as the application evolves and, finally, techniques to deal with legacy databases when the structure has already been defined before our involvement.</p>&#13;&#13;
    <p class="normal">In this chapter, we will look at the following topics:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet">The Model layer</li>&#13;&#13;
      <li class="bullet">Database migrations</li>&#13;&#13;
      <li class="bullet">Dealing with legacy databases</li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">Let's start by giving the context of the data design as part of the Model part of the <strong class="keyword">Model-View-Controller</strong> (<strong class="keyword">MVC</strong>) pattern.</p>&#13;&#13;
    <h1 id="_idParaDest-80" class="title">The Model layer</h1>&#13;&#13;
    <p class="normal">As we saw when we presented the Model-View-Controller architecture in <em class="chapterRef">Chapter 2</em>, <em class="italic">API Design</em>, the Model layer is <a id="_idIndexMarker250"/>the part that's intimately related with the data and storing and retrieving it.</p>&#13;&#13;
    <p class="normal">The Model abstracts all the data handling. This not only includes database access but also the related business logic. This creates a two-layer structure:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet">The internal data modeling layer, handling the storage and retrieval of data from the database. This layer needs to understand the way the data is stored in the database and handles it accordingly.</li>&#13;&#13;
      <li class="bullet">The next layer creates business logic and uses the internal data modeling layer to support it. This layer is in charge of ensuring that the data to be stored is consistent and enforces any relationships or constraints.</li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">It's very common to deal with the data layer as a pure extension of the database design, removing the business <a id="_idIndexMarker251"/>level or storing it as code in the Controller part. While this is doable, it's better to think about whether it's good to explicitly add the business layer on top and ensure there's separation between the entity models, which makes good business sense, and the database models, which contain the details on how to access the database.</p>&#13;&#13;
    <h2 id="_idParaDest-81" class="title">Domain-Driven Design</h2>&#13;&#13;
    <p class="normal">This way of operating has become common as part of Domain-Driven Design. When DDD was first <a id="_idIndexMarker252"/>introduced, it was aimed mainly at bridging the gap between the specific application and the technology implementing it to try to use proper nomenclature and ensure that the code was in sync with the real operations that the users of the code would use. For example, banking software will use methods for <em class="italic">lodging</em> and <em class="italic">withdrawing</em> funds, instead of <em class="italic">adding</em> and <em class="italic">subtracting</em> from an account.</p>&#13;&#13;
    <div>&#13;&#13;
      <p class="Tip--PACKT-">DDD is not only naming methods and attributes in a way that's consistent with the proper jargon of the domain, but also replicating the uses and flows.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">When paired with <strong class="keyword">Object-Oriented Programming</strong> (<strong class="keyword">OOP</strong>), DDD techniques will replicate the concepts <a id="_idIndexMarker253"/>required by the specific domain as objects. In our previous example, we would have an <code class="Code-In-Text--PACKT-">Account</code> object that accepts the methods <code class="Code-In-Text--PACKT-">lodge()</code> and <code class="Code-In-Text--PACKT-">withdraw()</code>. These would probably accept a <code class="Code-In-Text--PACKT-">Transfer</code> object that would keep the proper balance in the source of the funds.</p>&#13;&#13;
    <p class="normal">These days, DDD is understood as the creation of this business-oriented interface in the Model layer, so we can abstract the internals on how that's being mapped into accesses to the database and present a consistent interface that replicates the business flows.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-">DDD requires an intimate knowledge of the specific domain at hand to create an interface that makes sense and properly models the business actions. It requires close communication and collaboration with business experts to be sure that all possible gaps are covered.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">For a lot of different concepts, the Model works purely as a replication of the schema of the database. This way, if there's a table, it gets translated into a Model that accesses that table, replicates <a id="_idIndexMarker254"/>the fields, etc. An example of this is storing the user <a id="_idIndexMarker255"/>in a table with username, full name, subscription, and password fields.</p>&#13;&#13;
    <p class="normal">But remember that it is not a hard requirement. A Model can use multiple tables or combine multiple fields in a way that makes more business sense, even not exposing some fields as they should remain internal.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">We will use a relational database using SQL as our default example, as it is the most common kind of database. But everything that we are discussing is highly applicable to other kinds of databases, especially to document-based databases.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">For example, the example of the user above has the following fields in the database as columns in a SQL table:</p>&#13;&#13;
    <table id="table001-2" class="No-Table-Style _idGenTablePara-1">&#13;&#13;
      <colgroup>&#13;&#13;
        <col/>&#13;&#13;
        <col/>&#13;&#13;
        <col/>&#13;&#13;
      </colgroup>&#13;&#13;
      <tbody>&#13;&#13;
        <tr class="No-Table-Style">&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Heading--PACKT-">Field</p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Heading--PACKT-">Type</p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Heading--PACKT-">Description</p>&#13;&#13;
          </td>&#13;&#13;
        </tr>&#13;&#13;
        <tr class="No-Table-Style">&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">Username</code></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">String</code></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-">Unique username</p>&#13;&#13;
          </td>&#13;&#13;
        </tr>&#13;&#13;
        <tr class="No-Table-Style">&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">Password</code></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">String</code></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-">String describing the hashed password</p>&#13;&#13;
          </td>&#13;&#13;
        </tr>&#13;&#13;
        <tr class="No-Table-Style">&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">Full name</code></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">String</code></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-">Name of the user</p>&#13;&#13;
          </td>&#13;&#13;
        </tr>&#13;&#13;
        <tr class="No-Table-Style">&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">Subscription end</code></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">Datetime</code></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-">Time when the subscription ends</p>&#13;&#13;
          </td>&#13;&#13;
        </tr>&#13;&#13;
        <tr class="No-Table-Style">&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">Subscription type</code></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">Enum (Normal</code>, <code class="Code-In-Text--PACKT-">Premium</code>, <code class="Code-In-Text--PACKT-">NotSubscribed</code>)</p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-">Kind of subscription</p>&#13;&#13;
          </td>&#13;&#13;
        </tr>&#13;&#13;
      </tbody>&#13;&#13;
    </table>&#13;&#13;
    <p class="normal">But the Model may expose the following:</p>&#13;&#13;
    <table id="table002-2" class="No-Table-Style _idGenTablePara-1">&#13;&#13;
      <colgroup>&#13;&#13;
        <col/>&#13;&#13;
        <col/>&#13;&#13;
        <col/>&#13;&#13;
      </colgroup>&#13;&#13;
      <tbody>&#13;&#13;
        <tr class="No-Table-Style">&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Heading--PACKT-">Attribute/Method</p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Heading--PACKT-">Type</p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Heading--PACKT-">Description</p>&#13;&#13;
          </td>&#13;&#13;
        </tr>&#13;&#13;
        <tr class="No-Table-Style">&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">username</code></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-">String attribute</p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-">Directly translates the username column</p>&#13;&#13;
          </td>&#13;&#13;
        </tr>&#13;&#13;
        <tr class="No-Table-Style">&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">full_name</code></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-">String attribute</p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-">Directly translates the full_name column</p>&#13;&#13;
          </td>&#13;&#13;
        </tr>&#13;&#13;
        <tr class="No-Table-Style">&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">subscription</code></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-">Read-only property</p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-">Returns the subscription type column. If the subscription has ended (as indicated in the subscription end column), it returns <code class="Code-In-Text--PACKT-">NotSubscribed</code></p>&#13;&#13;
          </td>&#13;&#13;
        </tr>&#13;&#13;
        <tr class="No-Table-Style">&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">check_password(password)</code></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-">Method</p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-">Internally checks whether the <code class="Code-In-Text--PACKT-">password</code> input is valid by comparing it with the hash password column and returns whether it is correct or not</p>&#13;&#13;
          </td>&#13;&#13;
        </tr>&#13;&#13;
      </tbody>&#13;&#13;
    </table>&#13;&#13;
    <p class="normal">Note that this hides the password itself, as its internal details are not relevant outside the database. It also <a id="_idIndexMarker256"/>hides the internal subscription fields, presenting instead <a id="_idIndexMarker257"/>a single attribute that performs all the relevant checks.</p>&#13;&#13;
    <p class="normal">This Model transforms the actions from the raw database access to a fully defined object that <a id="_idIndexMarker258"/>abstracts the access to the database. This way of operating, when mapping an object to a table or collection, is called <strong class="keyword">Object-Relational Mapping</strong> (<strong class="keyword">ORM</strong>).</p>&#13;&#13;
    <h2 id="_idParaDest-82" class="title">Using ORM</h2>&#13;&#13;
    <p class="normal">As we've seen above, in essence, ORM is performing mapping between the collections or tables in a <a id="_idIndexMarker259"/>database, and generating objects in an OOP environment.</p>&#13;&#13;
    <p class="normal">While ORM itself refers to the technique, the way it is usually understood is <em class="italic">as a tool</em>. There are multiple ORM tools available that do the conversion from SQL tables to Python objects. This means that, instead of composing SQL statements, we will set up properties defined in classes and objects that will then be translated automatically by the ORM tool and will connect to the database.</p>&#13;&#13;
    <p class="normal">For example, a low-level access for a query in the "pens" table could look like this:</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; cur = con.cursor()&#13;&#13;
&gt;&gt;&gt; cur.execute('''CREATE TABLE pens (id INTEGER PRIMARY KEY DESC, name, color)''')&#13;&#13;
&lt;sqlite3.Cursor object at 0x10c484c70&gt;&#13;&#13;
&gt;&gt;&gt; con.commit()&#13;&#13;
&gt;&gt;&gt; cur.execute('''INSERT INTO pens VALUES (1, 'Waldorf', 'blue')''')&#13;&#13;
&lt;sqlite3.Cursor object at 0x10c484c70&gt;&#13;&#13;
&gt;&gt;&gt; con.commit()&#13;&#13;
&gt;&gt;&gt; cur.execute('SELECT * FROM pens');&#13;&#13;
&lt;sqlite3.Cursor object at 0x10c484c70&gt;&#13;&#13;
&gt;&gt;&gt; cur.fetchall()&#13;&#13;
[(1, 'Waldorf', 'blue')]&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Note that we are using the DB-API 2.0 standard Python interface, which abstracts away the <a id="_idIndexMarker260"/>differences between different databases, and allows us to retrieve the information using the standard <code class="Code-In-Text--PACKT-">fetchall()</code> method.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-">To connect Python and an SQL database, the most common ORMs are the ones included <a id="_idIndexMarker261"/>in the Django framework (<a href="https://www.djangoproject.com/">https://www.djangoproject.com/</a>) and <a id="_idIndexMarker262"/>SQLAlchemy (<a href="https://www.sqlalchemy.org/">https://www.sqlalchemy.org/</a>). There are other less-used options, such <a id="_idIndexMarker263"/>as Pony (<a href="https://ponyorm.org/">https://ponyorm.org/</a>) or Peewee (<a href="https://github.com/coleifer/peewee">https://github.com/coleifer/peewee</a>), that aim <a id="_idIndexMarker264"/>to have a simpler approach. </p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Using an ORM, like the one available in the Django framework, instead of creating a <code class="Code-In-Text--PACKT-">CREATE TABLE</code> statement, we describe the table in code as a class:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">from django.db import models&#13;&#13;
class Pens(models.Model):&#13;&#13;
     name = models.CharField(max_length=140)&#13;&#13;
     color = models.CharField(max_length=30)&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">This class allows us to retrieve and add elements using the class.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; new_pen = Pens(name='Waldorf', color='blue')&#13;&#13;
&gt;&gt;&gt; new_pen.save()&#13;&#13;
&gt;&gt;&gt; all_pens = Pens.objects.all()&#13;&#13;
&gt;&gt;&gt; all_pens[0].name&#13;&#13;
'Waldorf'&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The operation that in raw SQL is an <code class="Code-In-Text--PACKT-">INSERT</code> is to create a new object and then use the .<code class="Code-In-Text--PACKT-">save()</code> method to persist the data into the database. In the same way, instead of composing a <code class="Code-In-Text--PACKT-">SELECT</code> query, the search API can be called. For example, this code:</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; red_pens = Pens.objects.filter(color='red')&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Is equivalent to this code:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">SELECT * FROM Pens WHERE color = 'red;&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Using an ORM, compared with composing SQL directly, has some advantages:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet">Using an ORM detaches the database from the code</li>&#13;&#13;
      <li class="bullet">It removes the need for using SQL (or learning it)</li>&#13;&#13;
      <li class="bullet">It removes some problems with composing SQL queries, like security issues</li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">Let's take <a id="_idIndexMarker265"/>a closer look at these advantages and see their limits.</p>&#13;&#13;
    <h3 id="_idParaDest-83" class="title">Independence from the database</h3>&#13;&#13;
    <p class="normal">First of all, using an ORM detaches the database usage from the code. This means that a specific database <a id="_idIndexMarker266"/>can be changed, and the code will run unchanged. This can be useful sometimes to run code in different environments or to quickly change to use a different database.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">A very common use case for this is to run tests in SQLite and use another database like MySQL or PostgreSQL once the code is deployed in production.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">This approach is not problem-free, as some options may be available in one database and not in another. It may be a viable tactic for new projects, but the best approach is to run tests and production in the same technologies to avoid unexpected compatibility problems.</p>&#13;&#13;
    <h3 id="_idParaDest-84" class="title">Independence from SQL and the Repository pattern</h3>&#13;&#13;
    <p class="normal">Another advantage <a id="_idIndexMarker267"/>is that you don't need to learn SQL (or whatever language is used in the database backend) to work <a id="_idIndexMarker268"/>with the data. Instead, the ORM uses its own API, which can be intuitive and closer to OOP. This can reduce the barrier to entry to work with the code, as developers that are not familiar with SQL can understand the ORM code faster. </p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-">Using classes to abstract the access to the persistent layer from the database usage is called the <strong class="keyword">Repository pattern</strong>. Using an ORM will make use of this pattern <a id="_idIndexMarker269"/>automatically, as it will use programmatic actions without requiring any internal knowledge of the database. </p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">This advantage also has the counterpart that the translation of some actions can be clunky and produce highly inefficient SQL statements. This is especially true for complicated queries that require you to <code class="Code-In-Text--PACKT-">JOIN</code> multiple tables.</p>&#13;&#13;
    <p class="normal">A typical example of this is the following example code. The <code class="Code-In-Text--PACKT-">Books</code> objects have a reference to their author that's stored in a different table and stored as a foreign key reference.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">for book in Books.objects.find(publisher='packt'):&#13;&#13;
    author = book.author&#13;&#13;
    do_something(author)&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">This code is interpreted in the following way:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">Produce a query to retrieve all the books from publisher 'packt'&#13;&#13;
For each book, make a query to retrieve the author&#13;&#13;
Perform the action with the author&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">When the number of books is high, all those extra queries can be very costly. What we really want to do is</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">Produce a query to retrieve all the books from publisher 'packt', joining with their authors&#13;&#13;
For each book, perform the action with the author&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">This way, only <a id="_idIndexMarker270"/>a single query is generated, which is much more efficient than the first case. </p>&#13;&#13;
    <p class="normal">This join has to be manually indicated to the API, in the following way.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">for book in Books.objects.find(publisher='packt').select_related('author'):&#13;&#13;
    author = book.author&#13;&#13;
    do_something(author)&#13;&#13;
</code></pre>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">The need to require the addition of extra information is actually a good example of leaking abstractions, as discussed in <em class="chapterRef">Chapter 2</em>. You are still required to understand the details of the database to be able to create efficient code.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">This balance for ORM frameworks, between being intuitive to work with and sometimes requiring an understanding of the underlying implementation details, is a balance that needs to be defined. The framework itself will take a more or less flexible approach depending on how the specific SQL statements used are abstracted over a convenient API.</p>&#13;&#13;
    <h3 id="_idParaDest-85" class="title">No problems related to composing SQL</h3>&#13;&#13;
    <p class="normal">Even if the developer knows how to deal with SQL, there's a lot of gotchas when working with it. A pretty important advantage is that using an ORM avoids some of the problems <a id="_idIndexMarker271"/>of dealing with the direct manipulation of SQL statements. When directly composing SQL, it ends up becoming a pure string manipulation to generate the desired query. This can create a lot of problems.</p>&#13;&#13;
    <p class="normal">The most obvious ones are the requirement to compose the proper SQL statement, and not to generate a syntactically invalid SQL statement. For example, consider the following code:</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; color_list = ','.join(colors)&#13;&#13;
&gt;&gt;&gt; query = 'SELECT * FROM Pens WHERE color IN (' + color_list + ')'&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">This code works for values of <code class="Code-In-Text--PACKT-">colors</code> that contain values but will produce an error if <code class="Code-In-Text--PACKT-">colors</code> is empty.</p>&#13;&#13;
    <p class="normal">Even worse, if the query is composed using input parameters directly, it can produce security problems. There's a kind <a id="_idIndexMarker272"/>of attack called an <strong class="keyword">SQL injection attack</strong> that is aimed at precisely this kind of behavior.</p>&#13;&#13;
    <p class="normal">For example, let's say that the query presented above is produced when the user is calling a search that can be filtered by different colors. The user is directly asked for the colors. A malicious user may ask for the color <code class="Code-In-Text--PACKT-">'red'; DROP TABLE users;</code>. This will take advantage of the fact that the query is composed as a pure string to generate a malicious string that contains a hidden, non-expected operation.</p>&#13;&#13;
    <p class="normal">To avoid this problem, any input that may be used as part of a SQL query (or any other language) needs to be <em class="italic">sanitized</em>. This means removing or escaping characters that may affect the behavior of the expected query. </p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">Escaping characters means that they are properly encoded to be understood as a regular string, and not part of the syntax. For example, in Python, to escape the character <code class="Code-In-Text--PACKT-">"</code> to be included in a string instead of ending the string definition, it needs to be preceded by the <code class="Code-In-Text--PACKT-">\</code> character. Of course, the <code class="Code-In-Text--PACKT-">\</code> character needs to be escaped if it needs to be used in a string, in this case doubling it, using <code class="Code-In-Text--PACKT-">\\</code>.</p>&#13;&#13;
      <p class="Tip--PACKT-">For example: </p>&#13;&#13;
      <p class="Tip--PACKT-"><code class="Code-In-Text--PACKT-">"This string contains the double quote character \" and the backslash character \\."</code></p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">While there are specific techniques to manually compose SQL statements and sanitize the inputs, any ORM will sanitize them automatically, greatly reducing the risk of SQL injection by default. This is a great win in terms of security and it's probably the biggest advantage <a id="_idIndexMarker273"/>for ORM frameworks. Manually composing SQL statements is generally understood as a bad idea, relying instead on an indirect way that guarantees that any input is safe.</p>&#13;&#13;
    <p class="normal">The counterpart is that, even when having a good understanding of the ORM API, there are limits to the way elements are read for certain queries or results, which may lead to operations that are much more complicated or inefficient using an ORM framework than creating a bespoke SQL query.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">This typically happens when creating complex joins. The queries created from the ORM are good for straightforward queries but can struggle to create queries when there are too many relationships, as it will overcomplicate them.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">ORM frameworks will also have an impact in terms of performance, as they require time to compose the proper SQL query, encode and decode data, and do other checkups. While for most queries this time will be negligible, for specific ones perhaps this will greatly increase the time taken to retrieve the data. Unfortunately, there's a good chance that, at some point, a specific, tailored SQL query will need to be created for some action. When dealing with ORM frameworks, there's always a balance between convenience and being able to create exactly the right query for the task at hand.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">Another limit of ORM frameworks is that SQL access may allow operations that are not possible in the ORM interface. This may be a product of specific plugins or capabilities that are unique to the database in use.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">If using SQL is the way to go, a common approach is to use prepared statements, which are immutable queries with parameters, so they are replaced as part of the execution in the DB API. For example, the following code will work in a similar way to a <code class="Code-In-Text--PACKT-">print</code> statement.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">db.execute('SELECT * FROM Pens WHERE color={color}', color=color_input)&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">This code will safely replace the color with the proper input, encoded in a safe way. If there's a list of elements that need to be replaced, that could be done in two steps: first, preparing the proper template, with one parameter per input, and second, making the replacement. For example:</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con"># Input list&#13;&#13;
&gt;&gt;&gt; color_list = ['red', 'green', 'blue']&#13;&#13;
# Create a dictionary with a unique name per parameter (color_X) and the value&#13;&#13;
&gt;&gt;&gt; parameters = {f'color_{index}': value for index, value in enumerate(color_list)}&#13;&#13;
&gt;&gt;&gt; parameters&#13;&#13;
{'color_0': 'red', 'color_1': 'green', 'color_2': 'blue'}&#13;&#13;
# Create a clausule with the name of the parameters to be replaced&#13;&#13;
# by string substitution&#13;&#13;
# Note that {{ will be replaced by a single {&#13;&#13;
&gt;&gt;&gt; query_params = ','.join(f'{{{param}}}' for param in  parameters.keys())&#13;&#13;
&gt;&gt;&gt; query_params&#13;&#13;
'{color_0},{color_1},{color_2}'&#13;&#13;
# Compose the full query, replacing the prepared string&#13;&#13;
&gt;&gt;&gt; query = f'SELECT * FROM Pens WHERE color IN ({query_params})'&#13;&#13;
&gt;&gt;&gt; query&#13;&#13;
'SELECT * FROM Pens WHERE color IN ({color_0},{color_1},{color_2})'&#13;&#13;
# To execute, using ** on front of a dictionary will put all its keys as &#13;&#13;
# input parameters&#13;&#13;
&gt;&gt;&gt; query.format(**parameters)&#13;&#13;
'SELECT * FROM Pens WHERE color IN (red,green,blue)'&#13;&#13;
# Execute the query in a similar way, it will handle all &#13;&#13;
# required encoding and escaping from the string input&#13;&#13;
   &gt;&gt;&gt; db.execute(query, **query_params)&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">In our examples, we are using a <code class="Code-In-Text--PACKT-">SELECT *</code> statement that will return all the columns in the <a id="_idIndexMarker274"/>table for simplicity, but this is not the correct way of addressing them and should be avoided. The problem is that returning all columns may not be stable.</p>&#13;&#13;
    <p class="normal">New columns can be added to a table, so retrieving all columns may change the retrieved data, increasing the chance of producing a formatting error. For example:</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; cur.execute('SELECT * FROM pens');&#13;&#13;
&lt;sqlite3.Cursor object at 0x10e640810&gt;&#13;&#13;
# This returns a row&#13;&#13;
&gt;&gt;&gt; cur.fetchone()&#13;&#13;
(1, 'Waldorf', 'blue')&#13;&#13;
&gt;&gt;&gt; cur.execute('ALTER TABLE pens ADD brand')&#13;&#13;
&lt;sqlite3.Cursor object at 0x10e640810&gt;&#13;&#13;
&gt;&gt;&gt; cur.execute('SELECT * FROM pens');&#13;&#13;
&lt;sqlite3.Cursor object at 0x10e640810&gt;&#13;&#13;
# This is the same row as above, but now it returns an extra element&#13;&#13;
&gt;&gt;&gt; cur.fetchone()&#13;&#13;
(1, 'Waldorf', 'blue', None)&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">An ORM will handle this case automatically, but using raw SQL requires you to take this effect into <a id="_idIndexMarker275"/>account and always include explicitly the columns to retrieve to avoid problems when making changes in the schema later on.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; cur.execute('SELECT name, color FROM pens');&#13;&#13;
&lt;sqlite3.Cursor object at 0x10e640810&gt;&#13;&#13;
&gt;&gt;&gt; cur.fetchone()&#13;&#13;
('Waldorf', 'blue')&#13;&#13;
</code></pre>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">Backward compatibility is critical when dealing with stored data. We will talk more about <a id="_idIndexMarker276"/>that later in the chapter.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Queries generated programmatically by composing them are called <strong class="keyword">dynamic queries</strong>. While the default <a id="_idIndexMarker277"/>strategy should be to avoid them, preferring prepared statements, in certain cases dynamic queries are still very useful. There's a level of customization that can be impossible to produce unless there's a dynamic query involved.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">Exactly what is considered a dynamic query may depend on the environment. In some cases, any query that's not a stored query (a query stored in the database itself beforehand and called with some parameters) may be considered dynamic. From our point of view, we will consider dynamic queries any queries that require string manipulation to produce the query.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Even if the selected way to access the database is raw SQL statements, it's good to create an abstraction layer that deals with all the specific details of the access. This layer should be responsible for storing data, in the proper format in the database, without business logic on that.</p>&#13;&#13;
    <p class="normal">ORM frameworks will typically work a bit against this, as they are capable of handling a lot of <a id="_idIndexMarker278"/>complexity and will invite you to overload each of the defined objects with business logic. When the translation between the business concept and the database table is direct, for example, a user object, this is fine. But it's definitely possible to create an extra intermediate layer between the storage and the meaningful business object. </p>&#13;&#13;
    <h2 id="_idParaDest-86" class="title">The Unit of Work pattern and encapsulating the data</h2>&#13;&#13;
    <p class="normal">As we've seen before, ORM frameworks directly translate between tables in the database and objects. This creates <a id="_idIndexMarker279"/>a representation of the data itself, in the way it's stored in the database.</p>&#13;&#13;
    <p class="normal">In most situations, the design of the database will be tightly related to the business entities that we've <a id="_idIndexMarker280"/>introduced in the DDD philosophy. But that design may require an extra step, as some entities may be detached from the internal representation of the data, as it's stored inside the database.</p>&#13;&#13;
    <p class="normal">The creation of methods representing actions that are unique entities is called the <strong class="keyword">Unit of Work pattern</strong>. This means that everything that happens in this high-level action is performed as a single unit, even if internally it is implemented with multiple database operations. The operation acts atomically for the caller.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-">If the database allows for it, all the operations in a unit of work should be produced inside a transaction to ensure that the whole operation is done in one go. The name Unit of Work is very tightly associated with transactions and relational databases and normally is not used in databases that are not capable of creating transactions, though the pattern can still be used conceptually.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">For example, we saw earlier the example of an <code class="Code-In-Text--PACKT-">Account</code> class that accepts <code class="Code-In-Text--PACKT-">.lodge()</code> and <code class="Code-In-Text--PACKT-">.withdraw()</code> methods. While it is possible to directly implement an <code class="Code-In-Text--PACKT-">Account</code> table that contains an integer representing the funds, we can also automatically create with any change a double-entry accountability system that keeps track of the system.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-"><code class="Code-In-Text--PACKT-">Account</code> can be called <strong class="keyword">a Domain Model</strong> to indicate that it's independent of the database <a id="_idIndexMarker281"/>representation.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">To do so, each <code class="Code-In-Text--PACKT-">Account</code> should have <code class="Code-In-Text--PACKT-">debit</code> and <code class="Code-In-Text--PACKT-">credit</code> internal values that change accordingly. If we also add an extra <code class="Code-In-Text--PACKT-">Log</code> entry, in a different table, for keeping track of movements, it may be implemented as three different classes. The <code class="Code-In-Text--PACKT-">Account</code> class will be the one to <a id="_idIndexMarker282"/>be used to encapsulate the log, while <code class="Code-In-Text--PACKT-">InternalAccount</code> and <code class="Code-In-Text--PACKT-">Log</code> will correspond <a id="_idIndexMarker283"/>to tables in the database. Note that a single <code class="Code-In-Text--PACKT-">.lodge()</code> or <code class="Code-In-Text--PACKT-">.withdraw()</code> call will generate multiple accesses to the database, as we'll see later.</p>&#13;&#13;
    <figure class="mediaobject"><img src="img/B17580_04_01.png" alt="Shape, arrow&#13;&#10;&#13;&#10;Description automatically generated" width="826" height="245"/></figure>&#13;&#13;
    <p class="packt_figref">Figure 4.1: Design of the Account class</p>&#13;&#13;
    <p class="normal">The code could be something like this:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">class InternalAccount(models.Model):&#13;&#13;
    ''' This is the model related to a DB table '''&#13;&#13;
    account_number = models.IntegerField(unique=True)&#13;&#13;
    initial_amount = models.IntegerField(default=0)&#13;&#13;
     amount = models.IntegerField(default=0)&#13;&#13;
class Log(models.Model):&#13;&#13;
    ''' This models stores the operations '''&#13;&#13;
    source = models.ForeignKey('InternalAccount', &#13;&#13;
                               related_name='debit')&#13;&#13;
    destination = models.ForeignKey('InternalAccount',  &#13;&#13;
                                    related_name='credit')&#13;&#13;
    amount = models.IntegerField()&#13;&#13;
    timestamp = models.DateTimeField(auto_now=True)&#13;&#13;
    def commit():&#13;&#13;
        ''' this produces the operation '''&#13;&#13;
        with transaction.atomic():&#13;&#13;
            # Update the amounts&#13;&#13;
               self.source.amount -= self.amount&#13;&#13;
        self.destination.amount += self.amount&#13;&#13;
            # save everything&#13;&#13;
            self.source.save()&#13;&#13;
            self.destination.save()&#13;&#13;
            self.save()&#13;&#13;
class Account(object):&#13;&#13;
    ''' This is the exposed object that handled the operations '''&#13;&#13;
    def __init__(self, account_number, amount=0):&#13;&#13;
        # Retrieve or create the account&#13;&#13;
        self.internal, _ = InternalAccount.objects.get_or_create(&#13;&#13;
            account_number=account_number,&#13;&#13;
            initial_amount=amount,&#13;&#13;
            amount=amount)&#13;&#13;
       @property&#13;&#13;
       def amount(self):&#13;&#13;
           return self.internal.amount&#13;&#13;
    def lodge(source_account, amount):&#13;&#13;
        '''&#13;&#13;
        This operation adds funds from the source&#13;&#13;
        '''&#13;&#13;
        log = Log(source=source_account, destination=self,&#13;&#13;
                   amount=amount)&#13;&#13;
        log.commit()&#13;&#13;
    def withdraw(dest_account, amount):&#13;&#13;
        '''&#13;&#13;
        This operation transfer funds to the destination&#13;&#13;
        '''&#13;&#13;
        log = Log(source=self, destination=dest_account,&#13;&#13;
                   amount=amount)&#13;&#13;
        log.commit()&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">Account</code> class is <a id="_idIndexMarker284"/>the expected interface. It is not related directly to <a id="_idIndexMarker285"/>anything in the database but keeps a relation to the <code class="Code-In-Text--PACKT-">InternalAccount</code> using the unique reference of the <code class="Code-In-Text--PACKT-">account_number</code>.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-">The logic to store the different elements is presented in a different class than the ORM models. This can <a id="_idIndexMarker286"/>be understood in the way that the ORM model <a id="_idIndexMarker287"/>classes are the <strong class="keyword">Repositories</strong> classes and the <code class="Code-In-Text--PACKT-">Account</code> model is the <strong class="keyword">Unit of Work</strong> class.</p>&#13;&#13;
      <p class="Information-Box--PACKT-">In some manuals, they use Unit of Work classes, leaving them without much context, just as a container to perform the action to store the multiple elements. Nevertheless, it's more useful to assign a clear concept behind the <code class="Code-In-Text--PACKT-">Account</code> class to give context and meaning. And there could be several actions that are appropriate for the business entity.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Whenever there's an operation, it requires another account, and then a new <code class="Code-In-Text--PACKT-">Log</code> is created. The <code class="Code-In-Text--PACKT-">Log</code> references the source, destination, and amount of the funds, and, in a single transaction, performs the operation. This is done in the <code class="Code-In-Text--PACKT-">commit</code> method.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">    def commit():&#13;&#13;
        ''' this produces the operation '''&#13;&#13;
        with transaction.atomic():&#13;&#13;
            # Update the amounts&#13;&#13;
               self.source.amount -= self.amount&#13;&#13;
               self.destination.amount += self.amount&#13;&#13;
            # save everything&#13;&#13;
            self.source.save()&#13;&#13;
            self.destination.save()&#13;&#13;
            self.save()&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">In a single transaction, indicated by the usage of the <code class="Code-In-Text--PACKT-">with transaction.atomic()</code> context manager, it adds and subtracts funds from the accounts, and then saves the three related rows, the source, the destination, and the log itself.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-">The Django ORM requires you to set this atomic decorator, but other ORMs can work differently. For example, SQLAlchemy tends to work more by adding operations to a queue and requiring you to explicitly apply all of them in a batch operation. Please check the documentation of the specific software you are using for each case. </p>&#13;&#13;
    </p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">A missing detail due to simplicity is the validation that there are enough funds to perform the operation. In cases where there aren't enough funds, an exception should be produced that will abort the transaction.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Note how this format allows for each <code class="Code-In-Text--PACKT-">InternalAccount</code> to retrieve every <code class="Code-In-Text--PACKT-">Log</code> associated to the transactions, both <a id="_idIndexMarker288"/>debits and credits. That means it can be checked <a id="_idIndexMarker289"/>that the current amount is correct. This code will calculate the amount in an account, based on the logs, and that can be used to check the amount is correct.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">class InternalAccount(models.Model):&#13;&#13;
    ...&#13;&#13;
    def recalculate(self):&#13;&#13;
        '''&#13;&#13;
        Recalculate the amount, based on the logs&#13;&#13;
        '''&#13;&#13;
        total_credit = sum(log.amount for log in self.credit.all())&#13;&#13;
        total_debit = sum(log.amount for log in self.debit.all())&#13;&#13;
        return self.initial_amount + total_credit - total_debit&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The initial amount is required. The <code class="Code-In-Text--PACKT-">debit</code> and <code class="Code-In-Text--PACKT-">credit</code> fields are back-references to the <code class="Code-In-Text--PACKT-">Log</code>, as defined in the <code class="Code-In-Text--PACKT-">Log</code> class.</p>&#13;&#13;
    <p class="normal">From the point of view of a user only interested in operating with <code class="Code-In-Text--PACKT-">Account</code> objects, all these details are irrelevant. This extra layer allows us to cleanly abstract from the database implementation and store any relevant business logic there. This can be the exposed business Model layer (of the Domain Model) that handles relevant business operations with the proper logic and nomenclature.</p>&#13;&#13;
    <h2 id="_idParaDest-87" class="title">CQRS, using different models for read and write</h2>&#13;&#13;
    <p class="normal">Sometimes a simple CRUD model for the database is not descriptive of how the data flows in the system. In some complex settings, it may be necessary to use different ways to read the data and to write or interact with the data.</p>&#13;&#13;
    <p class="normal">A possibility is that sending data and reading it happen at different ends of a pipeline. For example, this is something that happens in event-driven systems, where the data is recorded in a queue, and then later processed. In most cases, this data is processed or aggregated in a different database. </p>&#13;&#13;
    <p class="normal">Let's see a more specific example. We store sales for different products. These sales contain the SKU (a unique identifier of the product sold) and the price. But we don't know, at the time of the sale, what the profit from the sale is, as the buying of the product depends on fluctuations of the market. The storing of a sale goes to a queue to start the process to reconcile it with the price paid. Finally, a relational database stores the final sale entry, which includes the purchase price and profit.</p>&#13;&#13;
    <p class="normal">The flow of information goes from the Domain Model to the queue, then by some external process to the relational database, where it is then represented with a relational model in an ORM way, and then back to the Domain Model.</p>&#13;&#13;
    <p class="normal">This structure is called <strong class="keyword">Command Query Responsibility Segregation</strong> (<strong class="keyword">CQRS</strong>), meaning that the <a id="_idIndexMarker290"/>Command (write operations) and Query (read operations) are separated. The pattern is not unique to event-driven structures; they are typically seen in these systems because their nature is to detach the input data from the output data.</p>&#13;&#13;
    <p class="normal">The Domain Model may require different methods to deal with the information. The input and output data has a different internal representation, and sometimes it may be easier to clearly distinguish them. It's anyway a good idea to use an explicit Domain Model layer for CQRS to group the functionality and treat it as a whole. In certain cases, the models and data may be quite different for read and write. For example, if there's a step where aggregated results are generated, that may create extra data in the read part that's never written.</p>&#13;&#13;
    <p class="normal">A description of the process of how the read and write parts connect is out of scope in our examples. In our example, that process would be how the data is stored in the database, including the amount paid.</p>&#13;&#13;
    <p class="normal">The following diagram depicts the flow of information in a CQRS structure:</p>&#13;&#13;
    <figure class="mediaobject"><img src="img/B17580_04_02.png" alt="Diagram&#13;&#10;&#13;&#10;Description automatically generated" width="826" height="330"/></figure>&#13;&#13;
    <p class="packt_figref">Figure 4.2: The flow of information in a CQRS structure</p>&#13;&#13;
    <p class="normal">Our <a id="_idIndexMarker291"/>model's definition could be like this:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">Class SaleModel(models.Model):&#13;&#13;
    ''' This is the usual ORM model '''&#13;&#13;
    Sale_id = models.IntegerField(unique=True)&#13;&#13;
    sku = models.IntegerField()&#13;&#13;
    amount = models.IntegerField()&#13;&#13;
    price = models.IntegerField()&#13;&#13;
class Sale(object):&#13;&#13;
    ''' &#13;&#13;
        This is the exposed Domain Model that handled the operations &#13;&#13;
        In a domain meaningful way, without exposing internal info&#13;&#13;
    '''&#13;&#13;
    def __init__(self, sale_id, sku, amount):&#13;&#13;
        self.sale_id = sale_id&#13;&#13;
        self.sku = sku&#13;&#13;
        self.amount = amount&#13;&#13;
        # These elements are won't be filled when creating a new element&#13;&#13;
        self._price = None&#13;&#13;
        self._profit = None&#13;&#13;
    @property&#13;&#13;
    def price(self):&#13;&#13;
        if self._price is None:&#13;&#13;
            raise Exception('No price yet for this sale')&#13;&#13;
        return self._price&#13;&#13;
    @property&#13;&#13;
    def profit(self):&#13;&#13;
        if self._profit is None:&#13;&#13;
            raise Exception('No price yet for this sale')&#13;&#13;
        return self._profit&#13;&#13;
       def save(self):&#13;&#13;
            # This sends the sale to the queue&#13;&#13;
            event = {&#13;&#13;
                'sale_id': self.sale_id,&#13;&#13;
                'sku': self.sku,&#13;&#13;
                'amount': self.amount,&#13;&#13;
            }&#13;&#13;
            # This sends the event to the external queue&#13;&#13;
            Queue.send(event)&#13;&#13;
       @classmethod&#13;&#13;
       def get(cls, sale_id):&#13;&#13;
           # if the sale is still not available it will raise an&#13;&#13;
           # Exception&#13;&#13;
           sale = SaleModel.objects.get(sale_id=sale_id)&#13;&#13;
           full_sale = Sale(sale_id=sale_id, sku=sale.sku,&#13;&#13;
                            amount=sale.amount)&#13;&#13;
           # fill the private attributes&#13;&#13;
           full_sale._price = sale.price&#13;&#13;
           full_sale._profit = sale.amount - full_sale._price&#13;&#13;
           return full_sale&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Note how the flow is different for save and retrieve:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">       &#13;&#13;
      # Create a new sale&#13;&#13;
      sale = Sale(sale_id=sale_id, sku=sale.sku, amount=sale.amount)&#13;&#13;
      sale.save()&#13;&#13;
      # Wait some time until totally processed&#13;&#13;
      full_sale = Sale.get(sale_id=sale_id)&#13;&#13;
      # retrieve the profit&#13;&#13;
      full_sale.profit&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">CQRS systems are complex, as the data in and the data out is different. They also normally <a id="_idIndexMarker292"/>incur some delay in being able to retrieve the information back, which can be inconvenient. </p>&#13;&#13;
    <p class="normal">Another important problem in CQRS systems is the fact that the different pieces need to be in sync. This includes both the read and write models, but also any transformation that happens within the pipeline. Over time, this creates a maintenance requirement, especially when backward compatibility needs to be maintained. </p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">All these problems make CQRS systems complicated. They should be used with care only when strictly necessary.</p>&#13;&#13;
    </p>&#13;&#13;
    <h1 id="_idParaDest-88" class="title">Database migrations</h1>&#13;&#13;
    <p class="normal">An unavoidable fact of development is that software systems are always changing. While the pace <a id="_idIndexMarker293"/>of changes in the database is typically not as fast as other areas, there are still changes and they need to be treated carefully.</p>&#13;&#13;
    <p class="normal">Data changes are roughly categorized into two different kinds:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet"><strong class="keyword">Format or schema changes</strong>: New elements, like fields or tables, to be added or removed; or changes in the format of some fields.</li>&#13;&#13;
      <li class="bullet"><strong class="keyword">Data changes</strong>: Requiring changing the data itself, without modifying the format. For example, normalizing <a id="_idIndexMarker294"/>an address field including the zip code, or making a string field uppercase.</li>&#13;&#13;
    </ul>&#13;&#13;
    <h2 id="_idParaDest-89" class="title">Backward compatibility</h2>&#13;&#13;
    <p class="normal">The basic principle related to changes in the database is backward compatibility. This means that <a id="_idIndexMarker295"/>any single change in the database needs to work <strong class="keyword">without</strong> any change in the code.</p>&#13;&#13;
    <p class="normal">This allows you to make changes without interrupting the service. If the changes in the database require a change in the code to understand it, the service will have to be interrupted. This is because you can't apply both changes at the same time, and if there is more than one server executing the code, it can't be applied simultaneously.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-">Of course, there's another option, which is to stop the service, perform all the changes, and restart again. While this is not great, it could be an option for small services or if scheduled downtime is acceptable.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Depending on the database, there are different approaches to data changes. </p>&#13;&#13;
    <p class="normal">For relational databases, given that they require a fixed structure to be defined, any change in the schema needs to be applied to the whole database as a single operation. </p>&#13;&#13;
    <p class="normal">For other databases that don't force defining a schema, there are ways of updating the database in a more iterative way.</p>&#13;&#13;
    <p class="normal">Let's take a look at the different approaches.</p>&#13;&#13;
    <h2 id="_idParaDest-90" class="title">Relational schema changes</h2>&#13;&#13;
    <p class="normal">In relational databases, each individual schema change is applied as a SQL statement that operates <a id="_idIndexMarker296"/>like a transaction. The schema change, called a <strong class="keyword">migration</strong>, can happen at the same time <a id="_idIndexMarker297"/>that some transformation of the data (for example, transforming integers to strings) takes place. </p>&#13;&#13;
    <p class="normal">Migrations are SQL commands that perform changes in an atomic way. They can involve changing the format of tables in the database, but also more operations like changing the data or multiple changes in one go. This can be achieved by creating a single transaction that groups these changes. Most ORM frameworks include support to create migrations and perform these operations natively.</p>&#13;&#13;
    <p class="normal">For example, Django will automatically create a migration file by running the command <code class="Code-In-Text--PACKT-">makemigrations</code>. This command needs to be run manually, but it will detect any change in the models and make the proper changes.</p>&#13;&#13;
    <p class="normal">For example, if we add an extra value <code class="Code-In-Text--PACKT-">branch_id</code> in the class introduced before</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">class InternalAccount(models.Model):&#13;&#13;
    ''' This is the model related to a DB table '''&#13;&#13;
    account_number = models.IntegerField(unique=True)&#13;&#13;
    initial_amount = models.IntegerField(default=0)&#13;&#13;
    amount = models.IntegerField(default=0)&#13;&#13;
    branch_id = models.IntegerField()&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Running the command <code class="Code-In-Text--PACKT-">makemigrations</code> will generate the proper file that describes the migration.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ python3 manage.py makemigrations&#13;&#13;
Migrations for 'example':&#13;&#13;
  example/migrations/0002_auto_20210501_1843.py&#13;&#13;
    - Add field branch_id to internalaccount&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Note that Django keeps track of the state in the models and automatically adjusts the changes <a id="_idIndexMarker298"/>creating the proper migration files. The pending migrations can be applied automatically with the command <code class="Code-In-Text--PACKT-">migrate</code>.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ python3 manage.py migrate&#13;&#13;
Operations to perform:&#13;&#13;
  Apply all migrations: admin, auth, contenttypes, example, sessions&#13;&#13;
Running migrations:&#13;&#13;
  Applying example.0002_auto_20210501_1843... OK&#13;&#13;
</code></pre>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">Django will store in the database the status of the applied migrations, to be sure that each <a id="_idIndexMarker299"/>one is applied exactly once. </p>&#13;&#13;
      <p class="Tip--PACKT-">Keep in mind that, to properly use migrations through Django no alterations outside of this method should be made, as this can confuse and create conflicts. If you need to apply changes that can't be replicated automatically with a change in the model, like a data migration, you can create an empty migration and fill it with your custom SQL statements. This can create complex, custom migrations, but that will be applied and kept in track with the rest of the automatically created Django migrations. Models can also be explicitly marked as not-handled by Django to manage them manually.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">For more details <a id="_idIndexMarker300"/>about Django migrations, check the documentation at <a href="https://docs.djangoproject.com/en/3.2/topics/migrations/">https://docs.djangoproject.com/en/3.2/topics/migrations/</a>.</p>&#13;&#13;
    <h3 id="_idParaDest-91" class="title">Changing the database without interruption</h3>&#13;&#13;
    <p class="normal">The process to <a id="_idIndexMarker301"/>migrate the data, then, needs to happen in the following order:</p>&#13;&#13;
    <ol>&#13;&#13;
      <li class="numbered">The old code and the old database schema are in place. This is the starting point.</li>&#13;&#13;
      <li class="numbered">The database applies a migration that's backward compatible with the old code. As the database can apply this change while in operation, the service is not interrupted.</li>&#13;&#13;
      <li class="numbered">The new code taking advantage of the new schema is deployed. This deployment won't require any special downtime and can be performed without interrupting the process.</li>&#13;&#13;
    </ol>&#13;&#13;
    <p class="normal">The critical element of this process is step 2, to ensure that the migration is backward compatible with the previous code.</p>&#13;&#13;
    <p class="normal">Most of the usual changes are relatively simple, like adding a new table or column to a table, and you'll have no problem with that. The old code won't make use of the column or table, and that will be totally fine. But other migrations can be more complex. </p>&#13;&#13;
    <p class="normal">For example, let's imagine that a field <code class="Code-In-Text--PACKT-">Field1</code> that has so far been an integer needs to be translated into a string. There'll be numbers stored, but also some special values like <code class="Code-In-Text--PACKT-">NaN</code> or <code class="Code-In-Text--PACKT-">Inf</code> that are not supported by the database. The new code will decode them and deal with them correctly.</p>&#13;&#13;
    <p class="normal">But obviously, a change that migrates the code from an integer to a string is going to produce an error if this is not taken into account in the old code.</p>&#13;&#13;
    <p class="normal">To solve this problem, it needs to be approached as a series of steps instead:</p>&#13;&#13;
    <ol>&#13;&#13;
      <li class="numbered" value="1">The old code and the old database schema are in place. This is the starting point.</li>&#13;&#13;
      <li class="numbered">The database applies a migration adding a new column, <code class="Code-In-Text--PACKT-">Field2</code>. In this migration, the value from <code class="Code-In-Text--PACKT-">Field1</code> is translated into a string and copied.</li>&#13;&#13;
      <li class="numbered">A new version of the code, intermediate code, is deployed. This version understands there may be one (<code class="Code-In-Text--PACKT-">Field2</code>) or two columns (<code class="Code-In-Text--PACKT-">Field1</code> and <code class="Code-In-Text--PACKT-">Field2</code>). It uses the value in <code class="Code-In-Text--PACKT-">Field2</code>, not the one in <code class="Code-In-Text--PACKT-">Field1</code>, but if there's a write, it should overwrite both.<p>&#13;&#13;
          <p class="Tip--PACKT-">To avoid having a problem with possible updates between the application of the migration and the new code, the code will need to check if the column <code class="Code-In-Text--PACKT-">Field1</code> exists, and if it does and has a different value than <code class="Code-In-Text--PACKT-">Field2</code>, update the latter before performing any operation. </p>&#13;&#13;
        </p>&#13;&#13;
      </li>&#13;&#13;
      <li class="numbered">A new migration removing <code class="Code-In-Text--PACKT-">Field1</code>, now unused, can be applied. <p>&#13;&#13;
          <p class="Tip--PACKT-">In the same migration, the same caveat as above should be applied – if the value in <code class="Code-In-Text--PACKT-">Field1</code> is different from the one in <code class="Code-In-Text--PACKT-">Field2</code>, overwrite it with <code class="Code-In-Text--PACKT-">Field1</code>. Note how the only case where this may happen is if it has been updated with the old code.</p>&#13;&#13;
        </p>&#13;&#13;
      </li>&#13;&#13;
      <li class="numbered">The new code that is only aware of <code class="Code-In-Text--PACKT-">Field2</code> can now be deployed safely.</li>&#13;&#13;
    </ol>&#13;&#13;
    <p class="normal">Depending on whether <code class="Code-In-Text--PACKT-">Field2</code> is an acceptable name or not, it may be possible that a further <a id="_idIndexMarker302"/>migration is deployed changing the name from <code class="Code-In-Text--PACKT-">Field2</code> to <code class="Code-In-Text--PACKT-">Field1</code>. In that case, the new code needs to be prepared in advance to use <code class="Code-In-Text--PACKT-">Field2</code> or, if not present, <code class="Code-In-Text--PACKT-">Field1</code>. </p>&#13;&#13;
    <p class="normal">A new deployment could be done after that to use only <code class="Code-In-Text--PACKT-">Field1</code> again:</p>&#13;&#13;
    <figure class="mediaobject"><img src="img/B17580_04_03.png" alt="Graphical user interface&#13;&#10;&#13;&#10;Description automatically generated" width="826" height="480"/></figure>&#13;&#13;
    <p class="packt_figref">Figure 4.3: Migrating from Field1 to Field2</p>&#13;&#13;
    <p class="normal">If this seems like a lot of work, well, it is. All these steps are required to enforce smooth operation and <a id="_idIndexMarker303"/>achieve no downtime. The alternative is to stop the old code, perform the migration with the format change in <code class="Code-In-Text--PACKT-">Field1</code>, and then start the new code. But this can cause several problems.</p>&#13;&#13;
    <p class="normal">The most obvious is the downtime. While the impact can be minimized by trying to set up a proper maintenance window, most modern applications are expected to work 24x7 and any downtime is considered a problem. If the application has a global audience, it may be difficult to justify a stop just for avoidable maintenance.</p>&#13;&#13;
    <p class="normal">The downtime also may last a while, depending on the migration side. A common problem is testing the migration in a database much smaller than the production one. This can create an unexpected problem when running in production, taking much longer than anticipated. Depending on the size of the data, a complex migration may take hours to complete. And, given that it will run as part of a transaction, it needs to be totally completed before proceeding or it will be rolled back.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">If possible, try to test the migrations of the system with a big enough test database that's representative. Some operations can be quite costly. It's possible that some migrations may need to be tweaked to run faster or even divided into smaller steps so each one can run in its own transaction to run in a reasonable time. It's even possible in some cases that the database will require more memory to allow the migration to run in a reasonable amount of time.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">But another problem is the risk of introducing a step, at the start of the new code, that can have <a id="_idIndexMarker304"/>problems and bugs, either related to the migration, or unrelated. With this process, after the migration is applied, there's no possibility of using the old code. If there's a bug in the new code, it needs to be fixed and a newer version deployed. This can create big trouble.</p>&#13;&#13;
    <p class="normal">While it's true that, as migrations are not reversible, applying a migration is always a risk, the fact that the code stays stable helps mitigate problems. Changing a single piece of code is less risky than changing two without being able to revert either of them.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-">Migrations may be reversible, as there could be steps that perform the reverse operation. While this is theoretically true, it is extremely difficult to enforce in real operations. It's possible that a migration like removing a column is effectively not reversible, as data gets lost.</p>&#13;&#13;
      <p class="Information-Box--PACKT-">This way migrations need to be applied very carefully and by ensuring that each step is small and deliberate.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Keep in mind how migrations inter-operate with the techniques that we talked about related to distributed databases. For example, a sharded database will need to apply each migration independently to each of the shards, which may be a time-consuming operation.</p>&#13;&#13;
    <h3 id="_idParaDest-92" class="title">Data migrations</h3>&#13;&#13;
    <p class="normal">Data migrations are changes in the database that don't change the format but change the <a id="_idIndexMarker305"/>values of some fields.</p>&#13;&#13;
    <p class="normal">These migrations are produced normally either to correct some error in the data, like a bug that stores a value with some encoding error, or to move old records to a more up-to-date format. For example, including zip codes in all addresses, if not already present, or to change the scale of a measurement from inches to centimeters.</p>&#13;&#13;
    <p class="normal">In either case, these actions may need to be performed for all rows or only for a selection of them. Applying them only to the relevant subset, if possible, can greatly speed up the process, especially for big databases.</p>&#13;&#13;
    <p class="normal">In cases like the scale change described above, the process may require more steps to ensure that <a id="_idIndexMarker306"/>the code can handle both scales and differentiate between them. For example, with an extra field describing the scale. In this case, the process will be as follows:</p>&#13;&#13;
    <ol>&#13;&#13;
      <li class="numbered" value="1">Create a migration to set a new column, <code class="Code-In-Text--PACKT-">scale</code>, to all rows, with a default value of <code class="Code-In-Text--PACKT-">inches</code>. Any new row introduced by the old code will automatically set up the values correctly, by using a default value.</li>&#13;&#13;
      <li class="numbered">Deploy a new version of the code able to work with both inches and centimeters reading the value in <code class="Code-In-Text--PACKT-">scale</code>.</li>&#13;&#13;
      <li class="numbered">Set up another migration to change the value of measurement. Each row will change both the <code class="Code-In-Text--PACKT-">scale</code> and the <code class="Code-In-Text--PACKT-">measurement</code> accordingly. Set the default value for <code class="Code-In-Text--PACKT-">scale</code> to <code class="Code-In-Text--PACKT-">centimeters</code>.</li>&#13;&#13;
      <li class="numbered">Now all the values in the database are in centimeters.</li>&#13;&#13;
      <li class="numbered">Optionally, clean up by deploying a new version of the code that doesn't access the <code class="Code-In-Text--PACKT-">scale</code> field and understands only centimeters, as both scales are not used. After that, a new migration removing the column can also be run.</li>&#13;&#13;
    </ol>&#13;&#13;
    <p class="normal">Step 5 is optional and normally there's not a great appetite for this kind of cleanup, as it's not strictly necessary and the versatility of having the extra column may be worth keeping for future usage.</p>&#13;&#13;
    <p class="normal">As we discussed before, the key element is to deploy code that's able to work with both database values, the old and the new, and understand them. This allows for a smooth transition between the values.</p>&#13;&#13;
    <h2 id="_idParaDest-93" class="title">Changes without enforcing a schema</h2>&#13;&#13;
    <p class="normal">One of the <a id="_idIndexMarker307"/>flexible aspects of non-relational databases is the fact that there's typically not an enforced schema. Instead, the stored documents accept different formats.</p>&#13;&#13;
    <p class="normal">This means that, instead of an all-or-nothing change as for relational databases, a more continuous change and dealing with multiple formats is preferred.</p>&#13;&#13;
    <p class="normal">Instead of the application of migrations, which is a concept not really applicable here, the code will have to perform the changes over time. In this case, the steps are like this:</p>&#13;&#13;
    <ol>&#13;&#13;
      <li class="numbered" value="1">The old code and the old database schema are in place. This is the starting point.</li>&#13;&#13;
      <li class="numbered">Each of the documents in the database has a <code class="Code-In-Text--PACKT-">version</code> field.</li>&#13;&#13;
      <li class="numbered">The new code contains a Model layer with the migration instructions from the previous version to the new one – in our example above, to translate <code class="Code-In-Text--PACKT-">Field1</code> from integer to string.</li>&#13;&#13;
      <li class="numbered">Every time that a particular document is accessed, the <code class="Code-In-Text--PACKT-">version</code> is checked. If it's not <a id="_idIndexMarker308"/>the latest, <code class="Code-In-Text--PACKT-">Field1</code> is transformed into a string, and the version is updated. This action happens before performing any operation. After the update, the operation is performed normally.<p class="bullet-para">This operation runs alongside the normal operation of the system. Given enough time, it will migrate, document by document, the whole database.</p>&#13;&#13;
        <p>&#13;&#13;
          <p class="Tip--PACKT-">The <code class="Code-In-Text--PACKT-">version</code> field may not be strictly necessary, as the type of <code class="Code-In-Text--PACKT-">Field1</code> may be easy to infer and change. But it presents the advantage that it makes the process explicit, and can be concatenated, migrating an old document from different versions in a single access.</p>&#13;&#13;
          <p class="Tip--PACKT-">If the <code class="Code-In-Text--PACKT-">version</code> field is not present, it may be understood as <code class="Code-In-Text--PACKT-">version 0</code> and be migrated to <code class="Code-In-Text--PACKT-">version 1</code>, now including the field.</p>&#13;&#13;
        </p>&#13;&#13;
      </li>&#13;&#13;
    </ol>&#13;&#13;
    <figure class="mediaobject"><img src="img/B17580_04_04.png" alt="Table&#13;&#10;&#13;&#10;Description automatically generated" width="826" height="261"/></figure>&#13;&#13;
    <p class="packt_figref">Figure 4.4: Changes over time</p>&#13;&#13;
    <p class="normal">This process is very clean, but sometimes leaving data in the old format for a long time, even if it's not accessed, may not be advisable. It may cause that code to migrate from <code class="Code-In-Text--PACKT-">version</code> 1 to 2, <code class="Code-In-Text--PACKT-">version</code> 2 to 3, etc, if still present in the code. If this is the case, an extra process running alongside may be covering every document, updating and saving it until the whole database is migrated.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-">This process is similar to the one described for data migration, though databases enforcing schemas need to perform migrations to change the format. In a schema-less database, the format can be changed at the same time as the value.</p>&#13;&#13;
      <p class="Information-Box--PACKT-">In the same way, a pure data change, like the example seen before where it was changing the scale, can be performed without the need for a migration, slowly changing the database as we described here. Doing it with a migration ensures a cleaner change, though, and may allow a simultaneous change in format.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Also note that, if this functionality is encapsulated in the internal database access layer, the logic <a id="_idIndexMarker309"/>above this one may use the newer functionality without caring about old formats, as they'll be translated on the fly.</p>&#13;&#13;
    <p class="normal">While there's still data in the database with the old <code class="Code-In-Text--PACKT-">version</code>, the code needs to be able to interpret it. This can cause some accumulation of old tech, so it's also possible to migrate all the data in the background, as it can be done document to document, filtering by the old version, while everything is in operation. Once this background migration is done, the code can be refactored and cleaned to remove the handling of obsolete versions.</p>&#13;&#13;
    <h1 id="_idParaDest-94" class="title">Dealing with legacy databases</h1>&#13;&#13;
    <p class="normal">ORM frameworks can generate the proper SQL commands to create the database schema. When <a id="_idIndexMarker310"/>designing and implementing a database from scratch, that means that we can create the ORM Model in code and the ORM framework will make the proper adjustments. </p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-">This way of <a id="_idIndexMarker311"/>describing the schema in code is called <strong class="keyword">declarative</strong>.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">But sometimes, we need to work with an existing database that was created previously by manually <a id="_idIndexMarker312"/>running SQL commands. There are two possible use cases:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet"><strong class="keyword">The schema will never be under the control of the ORM framework</strong>. In this case, we need a way to detect the existing schema and use it.</li>&#13;&#13;
      <li class="bullet"><strong class="keyword">We want to use the ORM framework from this situation to control the fields and any new changes</strong>. In this scenario, we need to create a Model that reflects the current situation and move from there to a <em class="italic">declarative</em> situation.</li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">Let's take a look at how to approach these situations.</p>&#13;&#13;
    <h2 id="_idParaDest-95" class="title">Detecting a schema from a database</h2>&#13;&#13;
    <p class="normal">For certain applications, if the database is stable or it's simple enough, it can be used as-is, and you <a id="_idIndexMarker313"/>can try to minimize the code to deal with it. SQLAlchemy allows you to automatically detect the schema of the database and work with it.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">SQLAlchemy is a very powerful ORM-capable library and arguably the best solution to perform complex and tailored accesses to a relational database. It allows <a id="_idIndexMarker314"/>complex definitions on how exactly tables relate to each other and allows you to tweak queries and create precise mappings. It's also more complex and potentially more difficult to use than other ORM frameworks such as the Django ORM.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">To automatically detect a database, you can automatically detect the tables and columns:</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from sqlalchemy.ext.automap import automap_base&#13;&#13;
&gt;&gt;&gt; from sqlalchemy.sql import select&#13;&#13;
&gt;&gt;&gt; from sqlalchemy import create_engine&#13;&#13;
# Read the database and detect it&#13;&#13;
&gt;&gt;&gt; engine = create_engine("sqlite:///database.db")&#13;&#13;
&gt;&gt;&gt; Base = automap_base()&#13;&#13;
&gt;&gt;&gt; Base.prepare(engine, reflect=True)&#13;&#13;
# The Pens class maps the table called "pens" in the DB&#13;&#13;
&gt;&gt;&gt; Pens = Base.classes.pens&#13;&#13;
# Create a session to query &#13;&#13;
&gt;&gt;&gt; session = Session(engine)&#13;&#13;
# Create a select query&#13;&#13;
&gt;&gt;&gt; query = select(Pens).where(Pens.color=='blue')&#13;&#13;
# Execute the query&#13;&#13;
&gt;&gt;&gt; result = session.execute(query)&#13;&#13;
&gt;&gt;&gt; for row, in result:&#13;&#13;
...     print(row.id, row.name, row.color)&#13;&#13;
...&#13;&#13;
1 Waldorf blue&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Note how the described names for the table <code class="Code-In-Text--PACKT-">pens</code> and columns <code class="Code-In-Text--PACKT-">id</code>, <code class="Code-In-Text--PACKT-">name</code>, and <code class="Code-In-Text--PACKT-">color</code> are detected automatically. The format of the query is also very similar to what a SQL construction will be.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">SQLAlchemy allows <a id="_idIndexMarker315"/>more complex usages and the creation of classes. For more information, refer to its documentation: <a href="https://docs.sqlalchemy.org/">https://docs.sqlalchemy.org/</a>.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">The Django ORM also has a command that allows you to dump a definition of the defined tables and relationships, using <code class="Code-In-Text--PACKT-">inspectdb</code>.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ python3 manage.py inspectdb &gt; models.py&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">This creates a <code class="Code-In-Text--PACKT-">models.py</code> file that contains the interpretation of the database based on the discovery that Django can do. This file may require adjustments.</p>&#13;&#13;
    <p class="normal">These methods of operation work perfectly for simple situations, where the most important <a id="_idIndexMarker316"/>part is to not spend too much effort having to replicate a schema in code. Other situations, where the schema gets mutated and requires better handling and control over the code, require a different approach.</p>&#13;&#13;
    <p class="normal">Check the Django documentation for more information: <a href="https://docs.djangoproject.com/en/3.2/howto/legacy-databases/">https://docs.djangoproject.com/en/3.2/howto/legacy-databases/</a>.</p>&#13;&#13;
    <h2 id="_idParaDest-96" class="title">Syncing the existing schema to the ORM definition</h2>&#13;&#13;
    <p class="normal">In other situations, there's a <a id="_idIndexMarker317"/>legacy database that was created by a method <a id="_idIndexMarker318"/>that cannot be replicated. Perhaps it was done through manual commands. The current code may use the database, but we want to migrate the code so we are up-to-date with it so we can, on one hand, understand exactly what the different relations and formats are, and on another, allow the ORM to make controlled changes to the schema in a compatible way. We will see the latter as migrations.</p>&#13;&#13;
    <p class="normal">The challenge in <a id="_idIndexMarker319"/>this case is to create a bunch of Models in the ORM framework <a id="_idIndexMarker320"/>that are up-to-date with the definition of the database. This is easier said than done, for several reasons:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet">There can be database features that are not exactly translated by the ORM. For example, ORM frameworks don't deal with stored procedures natively. If the database has stored procedures, they need to be either removed or replicated as part of the software operation.<p>&#13;&#13;
          <p class="Tip--PACKT-">Stored procedures are code functions inside the database that modify it. They can be manually <a id="_idIndexMarker321"/>called by using a SQL query, but normally they are triggered by certain operations, like inserting a new row or changing a column. Stored procedures are not very common these days, as they can be confusing to operate, and instead, in most cases, system designs tend to see databases as storage-only facilities, without the capacity to change the data that is stored. Managing stored procedures is complicated, as they can be difficult to debug and keep in sync with external code.</p>&#13;&#13;
          <p class="Tip--PACKT-">Stored procedures can be replicated by code that handles that complexity as part of a single Unit of Work action when the action will be triggered. This is the most common approach these days. But, of course, migrating already-existing stored procedures into external code is a process that may not be easy and requires care and planning.</p>&#13;&#13;
        </p>&#13;&#13;
      </li>&#13;&#13;
    </ul>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet">ORM frameworks can have their quirks in how to set up certain elements, which may not be compatible with the already-existing database. For example, how certain elements are named. The Django ORM doesn't allow you to set custom names for the indices and constraints. For a while, the constraint can remain only in the database, but "hidden" in the ORM, but in the long run that can create problems. This means that at some point, the index name needs to be changed externally to the compatible name.</li>&#13;&#13;
      <li class="bullet">Another example of this is the lack of support for composite primary keys in the Django ORM, which may require you to create a new numeric column to create a surrogate key.</li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">These limitations require that the creation of Models is done carefully and there are checks needed to ensure that they work as expected with the current schema. The created schema based on the code Models in the ORM framework can be produced and compared with the actual schema until there's parity or they are close enough.</p>&#13;&#13;
    <p class="normal">For example, for Django, the following general procedure can be used:</p>&#13;&#13;
    <ol>&#13;&#13;
      <li class="numbered" value="1">Create a dump of the database schema. This will be used as a reference.</li>&#13;&#13;
      <li class="numbered">Create the proper Model files. The starting point could be the output from the <code class="Code-In-Text--PACKT-">inspectdb</code> command described above.<p>&#13;&#13;
          <p class="Tip--PACKT-">Note that the <code class="Code-In-Text--PACKT-">inspectdb</code> creates the Models with their metadata set to not track changes in the database. That means that Django labels the Models as not tracked for changes as migrations. Once verified, this will need to be changed.</p>&#13;&#13;
        </p>&#13;&#13;
      </li>&#13;&#13;
      <li class="numbered">Create a single migration with all the required changes for the database. This migration is created normally, with <code class="Code-In-Text--PACKT-">makemigrations</code>.</li>&#13;&#13;
      <li class="numbered">Use the command <code class="Code-In-Text--PACKT-">sqlmigrate</code> to produce a SQL dump of the SQL statements that will be <a id="_idIndexMarker322"/>applied by the migration. This generates <a id="_idIndexMarker323"/>a database schema that can be compared with the reference.</li>&#13;&#13;
      <li class="numbered">Adjust the differences and repeat from step 2 onward. Remember to delete the migration file each time to generate it from scratch.<p class="bullet-para">Once the migration is tweaked to produce exactly the results that are currently applied, this migration can be applied using the parameter <code class="Code-In-Text--PACKT-">--fake</code> or <code class="Code-In-Text--PACKT-">–fake-initial</code>, meaning that it will be registered as applied, but the SQL won't run. </p>&#13;&#13;
      </li>&#13;&#13;
    </ol>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">This is a very simplified method. As we discussed above, there are some elements that can be difficult to replicate. Changes to the external database to solve incompatibility problems may be required.</p>&#13;&#13;
      <p class="Tip--PACKT-">On the other hand, sometimes it can be okay to live with small differences that are not creating any problems. For example, a different name in the primary key index may be something that can be acceptable and fixed later. Normally, these kinds of operations require a long time to be totally completed from a complex schema. Plan accordingly and do it in small increments.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">After that, changes can be applied normally by changing the Models and then autogenerating migrations.</p>&#13;&#13;
    <h1 id="_idParaDest-97" class="title">Summary</h1>&#13;&#13;
    <p class="normal">In this chapter, we described what the principles behind Domain-Driven Design are, to orient the abstraction of storing data and use rich objects that follow business principles. We also described ORM frameworks and how they can be useful to remove the need to deal with low-level interaction with specific libraries to work with the storage layer. We described different useful techniques for the code to interact with the database, like the Unit of Work pattern, which is related to the concept of a transaction, and CQRS for advanced cases where the write and read are addressed to different backends.</p>&#13;&#13;
    <p class="normal">We also discussed how to deal with database changes, both with explicit migrations that change the schema and with more soft changes that migrate the data as the application is running. </p>&#13;&#13;
    <p class="normal">Finally, we described different methods to deal with legacy databases, and how to create models to create a proper software abstraction when there's no control over the current schema of the data.</p>&#13;&#13;
  </div>&#13;&#13;
</div></body></html>