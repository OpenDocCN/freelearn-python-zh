<html><head></head><body>
<div id="_idContainer066">
<h1 class="chapter-number" id="_idParaDest-208"><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-209"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.2.1">Network Code Testing Framework</span></h1>
<p><span class="koboSpan" id="kobo.3.1">One important aspect when developing code is to add testing; we discussed and reviewed some code test strategies in </span><a href="B18165_05.xhtml#_idTextAnchor127"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.5.1">, </span><em class="italic"><span class="koboSpan" id="kobo.6.1">Do’s and Don’ts for Network Programming</span></em><span class="koboSpan" id="kobo.7.1">. </span><span class="koboSpan" id="kobo.7.2">But we have not investigated techniques that are unique to network automation, such as building a network testing environment where we can do some real testing with our network automation code.</span></p>
<p><span class="koboSpan" id="kobo.8.1">This chapter will focus on techniques for building a network testing framework that can be used for testing your network automation code. </span><span class="koboSpan" id="kobo.8.2">We are also going to look into advanced techniques that can be added to make your testing framework even more useful and reliable.</span></p>
<p><span class="koboSpan" id="kobo.9.1">Here are the topics we are going to cover in this chapter:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.10.1">Using software for testing</span></li>
<li><span class="koboSpan" id="kobo.11.1">Using device emulation</span></li>
<li><span class="koboSpan" id="kobo.12.1">Connecting devices for testing</span></li>
<li><span class="koboSpan" id="kobo.13.1">Using advanced testing techniques</span></li>
</ul>
<p><span class="koboSpan" id="kobo.14.1">By the end of this chapter, you should have enough information to build and use a testing framework that will add significant value to your network automation project.</span></p>
<h1 id="_idParaDest-210"><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.15.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.16.1">The source code described in this chapter is stored in this book’s GitHub repository at </span><a href="https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter09"><span class="koboSpan" id="kobo.17.1">https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter09</span></a><span class="koboSpan" id="kobo.18.1">.</span></p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.19.1">Using software for testing</span></h1>
<p><span class="koboSpan" id="kobo.20.1">Some</span><a id="_idIndexMarker1040"/><span class="koboSpan" id="kobo.21.1"> companies, when buying network devices, buy additional devices to be used for testing purposes. </span><span class="koboSpan" id="kobo.21.2">These extra devices are normally installed in a separate environment to replicate part of the production network for testing. </span><span class="koboSpan" id="kobo.21.3">Before one test is performed, the devices are connected and configured to replicate a particular part of the network. </span><span class="koboSpan" id="kobo.21.4">Once the tests are finished, the setup is then removed and another configuration with different connections may take place to perform tests for another part of the network. </span><span class="koboSpan" id="kobo.21.5">There are several reasons why these tests are necessary, such as testing new software, validating a new configuration, verifying an update, checking performance, qualifying a new network design, and testing new functionality, among others.</span></p>
<p><span class="koboSpan" id="kobo.22.1">But the </span><a id="_idIndexMarker1041"/><span class="koboSpan" id="kobo.23.1">main problem is that the testing environment is costly, slow to set up, and cannot be used by multiple test engineers in parallel. </span><span class="koboSpan" id="kobo.23.2">It also demands the physical presence of a specialized technician who will eventually have to sort new cable connections, perform hardware updates, add or remove network cards, and sometimes update the operating systems of the devices.</span></p>
<p><span class="koboSpan" id="kobo.24.1">The physical testing environment is ultimately inevitable, but a few tests can be performed by using software instead of physical hardware. </span><span class="koboSpan" id="kobo.24.2">The tests that can be performed by software will depend on the requirement of the test. </span><span class="koboSpan" id="kobo.24.3">Tests that evaluate software configuration, verify design concepts, validate routing behavior, and validate new features and perhaps router stability might be performed by software.</span></p>
<p><span class="koboSpan" id="kobo.25.1">In addition, software can be used to make connections between network devices, which also speeds up the setup process. </span><span class="koboSpan" id="kobo.25.2">But one area won’t be able to be tested, which is network stress and performance, such as measuring maximum throughput or capacity.</span></p>
<p><span class="koboSpan" id="kobo.26.1">There are several techniques we can use to use software for network testing, and most of them will be done using simulation and emulation. </span><span class="koboSpan" id="kobo.26.2">But what are the differences between emulation and simulation? </span><span class="koboSpan" id="kobo.26.3">Let’s discuss this now.</span></p>
<h2 id="_idParaDest-212"><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.27.1">Differences between emulation and simulation</span></h2>
<p><span class="koboSpan" id="kobo.28.1">Emulation and simulation</span><a id="_idIndexMarker1042"/><span class="koboSpan" id="kobo.29.1"> have their meanings commonly mixed it up. </span><span class="koboSpan" id="kobo.29.2">Although mistaking them is not that important, it is good to understand their meaning so that you can understand their limitations and capabilities when using them.</span></p>
<p><span class="koboSpan" id="kobo.30.1">In the case of </span><a id="_idIndexMarker1043"/><span class="koboSpan" id="kobo.31.1">emulation, it is</span><a id="_idIndexMarker1044"/><span class="koboSpan" id="kobo.32.1"> when you use software to mimic the physical aspects of the entity you want to test. </span><span class="koboSpan" id="kobo.32.2">So, in our network automation, it would be a router, a switch, or a network connection (link).</span></p>
<p><span class="koboSpan" id="kobo.33.1">Therefore, using a router emulation implies that all necessary hardware, such as network ports, console ports, CPU, and memory, must be mocked by software so that the operating system of the router can run seamlessly as if it were running in real hardware. </span><span class="koboSpan" id="kobo.33.2">One example of a router</span><a id="_idIndexMarker1045"/><span class="koboSpan" id="kobo.34.1"> emulator is </span><strong class="bold"><span class="koboSpan" id="kobo.35.1">Dynamips</span></strong><span class="koboSpan" id="kobo.36.1"> (there are more details at </span><a href="https://github.com/GNS3/dynamips"><span class="koboSpan" id="kobo.37.1">https://github.com/GNS3/dynamips</span></a><span class="koboSpan" id="kobo.38.1">).</span></p>
<p><span class="koboSpan" id="kobo.39.1">On the other</span><a id="_idIndexMarker1046"/><span class="koboSpan" id="kobo.40.1"> hand, a simulator is built to mimic some functionalities of the entity that you want to test. </span><span class="koboSpan" id="kobo.40.2">In the case of a router, normally, only particular functions are simulated, not all the functions of the router. </span><span class="koboSpan" id="kobo.40.3">Because of the characteristics of being smaller, a simulator can accomplish results much faster and can scale up to thousands in comparison to an emulator. </span><span class="koboSpan" id="kobo.40.4">Two popular examples of software used for </span><a id="_idIndexMarker1047"/><span class="koboSpan" id="kobo.41.1">simulating</span><a id="_idIndexMarker1048"/><span class="koboSpan" id="kobo.42.1"> networks are </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">ns-3</span></strong><span class="koboSpan" id="kobo.44.1"> (</span><a href="https://www.nsnam.org/"><span class="koboSpan" id="kobo.45.1">https://www.nsnam.org/</span></a><span class="koboSpan" id="kobo.46.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">NetworkX</span></strong><span class="koboSpan" id="kobo.48.1"> (</span><a href="https://networkx.org/"><span class="koboSpan" id="kobo.49.1">https://networkx.org/</span></a><span class="koboSpan" id="kobo.50.1">).</span></p>
<p><span class="koboSpan" id="kobo.51.1">Now that we know the differences between emulation and simulation, let’s dive a bit deeper into emulation.</span></p>
<h1 id="_idParaDest-213"><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.52.1">Using device emulation</span></h1>
<p><span class="koboSpan" id="kobo.53.1">The best </span><a id="_idIndexMarker1049"/><span class="koboSpan" id="kobo.54.1">use case for using emulation in </span><a id="_idIndexMarker1050"/><span class="koboSpan" id="kobo.55.1">our network automation would be for routers. </span><span class="koboSpan" id="kobo.55.2">With router emulation, we can test several features of the router without having it physically. </span><span class="koboSpan" id="kobo.55.3">But router emulation is perhaps the hardest to accomplish and the costliest in terms of resources. </span><span class="koboSpan" id="kobo.55.4">As an example, let’s explore how a popular Cisco router emulator works, called Dynamips. </span><em class="italic"><span class="koboSpan" id="kobo.56.1">Figure 9.1</span></em><span class="koboSpan" id="kobo.57.1"> represents a Cisco router being emulated by using Dynamips on a Linux host:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer057">
<span class="koboSpan" id="kobo.58.1"><img alt="Figure 9.1 – Cisco router emulation" src="image/B18165_09_001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.59.1">Figure 9.1 – Cisco router emulation</span></p>
<p><span class="koboSpan" id="kobo.60.1">As</span><a id="_idIndexMarker1051"/><span class="koboSpan" id="kobo.61.1"> illustrated, Dynamips is a software layer that emulates the hardware for Cisco routers. </span><span class="koboSpan" id="kobo.61.2">Dynamips can emulate some Cisco hardware</span><a id="_idIndexMarker1052"/><span class="koboSpan" id="kobo.62.1"> such as network ports, CPU, memory, auxiliary ports, and console ports. </span><span class="koboSpan" id="kobo.62.2">Dynamips was created by Christophe Fillot in 2005 to emulate the MIPS processor architecture for Cisco routers. </span><span class="koboSpan" id="kobo.62.3">Today, Dynamips is supported and maintained by the GNS network simulation team, more details of which can be found at </span><a href="https://github.com/GNS3/dynamips"><span class="koboSpan" id="kobo.63.1">https://github.com/GNS3/dynamips</span></a><span class="koboSpan" id="kobo.64.1">.</span></p>
<p><span class="koboSpan" id="kobo.65.1">Dynamips works like a virtual machine in that it will only run a Cisco operating system. </span><span class="koboSpan" id="kobo.65.2">To emulate a MIPs processor, Dynamips consumes a lot of CPU and memory. </span><span class="koboSpan" id="kobo.65.3">For instance, to run a legacy Cisco router 7200, Dynamips will allocate a minimum of 256 MB of RAM, plus 16 MB of cache. </span><span class="koboSpan" id="kobo.65.4">CPU is also heavily used to run the router by translating instruction by instruction. </span><span class="koboSpan" id="kobo.65.5">Earlier versions of Dynamips overloaded the CPU host, but with the introduction of a capability </span><a id="_idIndexMarker1053"/><span class="koboSpan" id="kobo.66.1">called </span><strong class="bold"><span class="koboSpan" id="kobo.67.1">idle-PC</span></strong><span class="koboSpan" id="kobo.68.1">, the CPU consumption was reduced by a significant amount.</span></p>
<p><span class="koboSpan" id="kobo.69.1">Other routers can be emulated but will need an emulator that provides the necessary hardware emulation for the CPU platform you require. </span><span class="koboSpan" id="kobo.69.2">Juniper routers can be emulated by using Juniper Olive. </span><span class="koboSpan" id="kobo.69.3">Juniper Olive is FreeBSD modified to load the Juniper router operational system called JunOS. </span><span class="koboSpan" id="kobo.69.4">With emulation, you can also run legacy routers by using a hardware emulator that can provide legacy CPU architecture.</span></p>
<p><span class="koboSpan" id="kobo.70.1">The following diagram illustrates a system running with four emulations, two Cisco routers, one Juniper router, and one legacy OpenWRT router:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<span class="koboSpan" id="kobo.71.1"><img alt="Figure 9.2 – Four emulations on one system" src="image/B18165_09_002.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.72.1">Figure 9.2 – Four emulations on one system</span></p>
<p><span class="koboSpan" id="kobo.73.1">The </span><a id="_idIndexMarker1054"/><span class="koboSpan" id="kobo.74.1">connection between these routers in </span><a id="_idIndexMarker1055"/><span class="koboSpan" id="kobo.75.1">the preceding diagram is created on the operating system host. </span><span class="koboSpan" id="kobo.75.2">The host can provide a more complex software link emulation to provide connectivity or just copy traffic from one end and send it to another end for point-to-point connections. </span><span class="koboSpan" id="kobo.75.3">More on these connections will be explained later in this chapter in the </span><em class="italic"><span class="koboSpan" id="kobo.76.1">Connecting devices for testing</span></em><span class="koboSpan" id="kobo.77.1"> section.</span></p>
<p><span class="koboSpan" id="kobo.78.1">Note that with emulation, it is possible to completely isolate the router, thus providing a completely different architecture. </span><span class="koboSpan" id="kobo.78.2">In </span><em class="italic"><span class="koboSpan" id="kobo.79.1">Figure 9.2</span></em><span class="koboSpan" id="kobo.80.1">, Dynamips provides a MIPS CPU architecture to emulate Cisco 7200, Qemu provides a 32-bit CPU architecture to emulate a legacy OpenWRT router, VMware provides a 64-bit x86 CPU architecture to emulate a Juniper router, and Qemu provides a 64-bit x86 CPU architecture to emulate a Cisco XRv 9000.</span></p>
<p><span class="koboSpan" id="kobo.81.1">The host that’s used for emulating these routers is Linux with a 6.1.4 kernel, but it could be another kernel or another operating system such as Windows that’s capable of running the emulators. </span><span class="koboSpan" id="kobo.81.2">The consumption of CPU and memory for </span><em class="italic"><span class="koboSpan" id="kobo.82.1">Figure 9.2</span></em><span class="koboSpan" id="kobo.83.1"> is quite high – Cisco 9000 requires at least 4 vCPUs and 16 GB of RAM, Juniper requires a minimum of 2 vCPUs and 512 MB of RAM, Legacy OpenWRT requires a minimum of 1 vCPU, and Cisco 7200 requires a minimum of 2 vCPUs and around 300 MB.</span></p>
<p><span class="koboSpan" id="kobo.84.1">Therefore, creating a large network using router emulation is hard, and perhaps impossible because of limited resources. </span><span class="koboSpan" id="kobo.84.2">One way to scale up the emulation is to share the hardware drivers, memory, and CPU by using some sort of operating system isolation, such as using Linux containers or FreeBSD jails. </span><span class="koboSpan" id="kobo.84.3">But with container setup, you will have to use the same version of the kernel and the same CPU architecture for all routers. </span><span class="koboSpan" id="kobo.84.4">Therefore, if your router runs on an ARM processor, and your host is an x86 processor, Linux containers won’t work. </span><span class="koboSpan" id="kobo.84.5">To work, the containers and the host must use the same CPU architecture.</span></p>
<p><span class="koboSpan" id="kobo.85.1">Now, let’s have a look at how to scale emulation using containers.</span></p>
<h2 id="_idParaDest-214"><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.86.1">Scaling up emulation with containers</span></h2>
<p><span class="koboSpan" id="kobo.87.1">Emulation </span><a id="_idIndexMarker1056"/><span class="koboSpan" id="kobo.88.1">will scale up if you share resources from the host dynamically. </span><span class="koboSpan" id="kobo.88.2">However, that requires your router to run as a program on a Linux host that can be isolated as a container. </span><span class="koboSpan" id="kobo.88.3">That is perhaps a big limitation as most commercial routers do not run on Linux and can’t be containerized. </span><span class="koboSpan" id="kobo.88.4">Choosing open source routers gives you the advantage of it being easy to move to a container-based architecture. </span><span class="koboSpan" id="kobo.88.5">Some big companies have chosen to move away from commercial operating system routers and migrate to a Linux-based routing architecture, which facilitates the creation of the emulated network.</span></p>
<p><span class="koboSpan" id="kobo.89.1">Despite the commercial limitations, some vendors provide versions that can be containerized, such as Arista, Cisco, Juniper, and Nokia. </span><span class="koboSpan" id="kobo.89.2">This includes Cisco XRv and CSRv versions, Juniper vMX and vQFX, Arista vEOS, and Nokia VSR. </span><span class="koboSpan" id="kobo.89.3">One project that explores these</span><a id="_idIndexMarker1057"/><span class="koboSpan" id="kobo.90.1"> capabilities is </span><strong class="bold"><span class="koboSpan" id="kobo.91.1">vrnetlab</span></strong><span class="koboSpan" id="kobo.92.1"> (there are more details at </span><a href="http://github.com/vrnetlab/vrnetlab"><span class="koboSpan" id="kobo.93.1">github.com/vrnetlab/vrnetlab</span></a><span class="koboSpan" id="kobo.94.1">).</span></p>
<p><span class="koboSpan" id="kobo.95.1">There are a bunch of network tests that can be done, even if the routers are not the same as production, such as network design tests, topology migration tests, IP filter-based tests, and topology failover tests, among others. </span><span class="koboSpan" id="kobo.95.2">The reason is that most topologies run standard protocols and can be translated into an open source network platform. </span><span class="koboSpan" id="kobo.95.3">If you are using SDN and OpenFlow, that is also true.</span></p>
<p><span class="koboSpan" id="kobo.96.1">The following diagram illustrates how you could run four emulated routers using containers:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer059">
<span class="koboSpan" id="kobo.97.1"><img alt="Figure 9.3 – Running emulation with containers" src="image/B18165_09_003.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.98.1">Figure 9.3 – Running emulation with containers</span></p>
<p><span class="koboSpan" id="kobo.99.1">As you can see in the preceding figure, the containers share CPU, memory, and network ports with the Linux host (green rectangle), but with isolation within the container. </span><span class="koboSpan" id="kobo.99.2">Each container isolates the shared resources from other containers, but they use the same Linux kernel, same drivers, and same CPU architecture. </span><span class="koboSpan" id="kobo.99.3">Different runtime libraries can be used, but the kernel and CPU architecture must be the same. </span><span class="koboSpan" id="kobo.99.4">Each container will have its own routing table, and programs running on the same container will share the same routing table but will not share the routing tables between containers unless using a routing protocol.</span></p>
<p><span class="koboSpan" id="kobo.100.1">You could </span><a id="_idIndexMarker1058"/><span class="koboSpan" id="kobo.101.1">also run a virtual machine inside a container, but then you are not saving resources, and the limitations shown previously are the same. </span><span class="koboSpan" id="kobo.101.2">So, if you want to scale up, you have to share the hardware resources with all containers, not emulate another layer like in </span><em class="italic"><span class="koboSpan" id="kobo.102.1">Figure 9.2</span></em><span class="koboSpan" id="kobo.103.1">.</span></p>
<p><span class="koboSpan" id="kobo.104.1">In the example in </span><em class="italic"><span class="koboSpan" id="kobo.105.1">Figure 9.3</span></em><span class="koboSpan" id="kobo.106.1">, there are four routers – one FRRouting, one OpenWRT, one Quagga, and one DD-WRT. </span><span class="koboSpan" id="kobo.106.2">All these routers are open source and can be containerized. </span><span class="koboSpan" id="kobo.106.3">But they are not necessarily one program running, but instead a group of programs. </span><span class="koboSpan" id="kobo.106.4">Quagga and FFRouting run several programs that do different tasks, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">bgpd</span></strong><span class="koboSpan" id="kobo.108.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">ospfd</span></strong><span class="koboSpan" id="kobo.110.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">zebra</span></strong><span class="koboSpan" id="kobo.112.1">. </span><span class="koboSpan" id="kobo.112.2">References to</span><a id="_idIndexMarker1059"/><span class="koboSpan" id="kobo.113.1"> these open source routers can be obtained from the following sources:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.114.1">FRRouting: </span><a href="https://frrouting.org/"><span class="koboSpan" id="kobo.115.1">https://frrouting.org/</span></a></li>
<li><span class="koboSpan" id="kobo.116.1">OpenWRT: </span><a href="https://openwrt.org/docs/guide-user/virtualization/lxc "><span class="koboSpan" id="kobo.117.1">https://openwrt.org/docs/guide-user/virtualization/lxc</span></a></li>
<li><span class="koboSpan" id="kobo.118.1">Quagga: </span><a href="https://www.nongnu.org/quagga/"><span class="koboSpan" id="kobo.119.1">https://www.nongnu.org/quagga/</span></a></li>
<li><span class="koboSpan" id="kobo.120.1">DD-WRT: </span><a href="https://dd-wrt.com/"><span class="koboSpan" id="kobo.121.1">https://dd-wrt.com/</span></a></li>
</ul>
<p><span class="koboSpan" id="kobo.122.1">You will need some connectivity capability to be able to connect the emulated routers. </span><span class="koboSpan" id="kobo.122.2">Now, let’s discuss the techniques we can use to connect devices in a network.</span></p>
<h1 id="_idParaDest-215"><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.123.1">Connecting devices for testing</span></h1>
<p><span class="koboSpan" id="kobo.124.1">Ensuring </span><a id="_idIndexMarker1060"/><span class="koboSpan" id="kobo.125.1">the connectivity </span><a id="_idIndexMarker1061"/><span class="koboSpan" id="kobo.126.1">of our devices for tests is important for obtaining a proper network environment for testing. </span><span class="koboSpan" id="kobo.126.2">There are several different ways to connect devices for testing, such as physical cables and software. </span><span class="koboSpan" id="kobo.126.3">Physical cables always have two caveats – they require technical personnel at the site and take time to implement. </span><span class="koboSpan" id="kobo.126.4">Via software, there is only one limitation – the maximum data throughput, which</span><a id="_idIndexMarker1062"/><span class="koboSpan" id="kobo.127.1"> is normally a fraction of a physical cable. </span><span class="koboSpan" id="kobo.127.2">Therefore, if your tests require high data throughput, you might need to use physical wires instead. </span><span class="koboSpan" id="kobo.127.3">There is a workaround to this limitation that we are going to explain later in this chapter when we look at advanced techniques.</span></p>
<p><span class="koboSpan" id="kobo.128.1">The environment</span><a id="_idIndexMarker1063"/><span class="koboSpan" id="kobo.129.1"> for using devices for testing is also known as a network testing laboratory or just a network lab. </span><span class="koboSpan" id="kobo.129.2">To explain how we can connect devices in our lab, let’s describe the three possible ways to connect devices in a lab.</span></p>
<h2 id="_idParaDest-216"><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.130.1">Using physical wires to connect</span></h2>
<p><span class="koboSpan" id="kobo.131.1">In a </span><a id="_idIndexMarker1064"/><span class="koboSpan" id="kobo.132.1">test environment, a physical connection normally consists of wires that connect the ports of  network devices. </span><span class="koboSpan" id="kobo.132.2">They are normally optical cables, coaxial cables, or twisted pair cables. </span><span class="koboSpan" id="kobo.132.3">If you have two devices, the cables are simple and will pass from one device to the other. </span><span class="koboSpan" id="kobo.132.4">However, if you are planning to have a lab with several racks and dozens of devices, you might want to use a patch cord and a patch panel instead of passing wires through the racks. </span><span class="koboSpan" id="kobo.132.5">The idea of using a patch panel is that the technician will only need to use patch cords to connect the devices, which makes the connection setup a bit faster and easier to remove later.</span></p>
<p><span class="koboSpan" id="kobo.133.1">It is important to understand how the patch panel and patch cords work in the physical lab because it will help us to understand the software version later. </span><span class="koboSpan" id="kobo.133.2">The following diagram illustrates the patch panels for connecting two racks with four routers each:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer060">
<span class="koboSpan" id="kobo.134.1"><img alt="Figure 9.4 – Connecting routers using patch panels" src="image/B18165_09_004.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.135.1">Figure 9.4 – Connecting routers using patch panels</span></p>
<p><span class="koboSpan" id="kobo.136.1">Note that </span><a id="_idIndexMarker1065"/><span class="koboSpan" id="kobo.137.1">in the preceding figure, the orange and blue wires represent permanent wires and will never be removed. </span><span class="koboSpan" id="kobo.137.2">The red and green lines represent the patch cords that are used to connect devices but can be removed and reconnected easily for a different topology setup. </span><span class="koboSpan" id="kobo.137.3">The blue lines in rack 1 are connecting routers R0, R1, R2, and R3 to patch panel P1, similar to rack 2, which connects routers R10, R11, R12, and R13 to patch panel P11. </span><span class="koboSpan" id="kobo.137.4">The orange lines represent the permanent wires that connect patch panel P0 to patch panel P10.</span></p>
<p><span class="koboSpan" id="kobo.138.1">Whenever a topology setup is required, the technician just needs patch cords to set up connections between the routers. </span><span class="koboSpan" id="kobo.138.2">The number of ports on each patch panel will depend on the number of available network ports on each router. </span><span class="koboSpan" id="kobo.138.3">As an example, for </span><em class="italic"><span class="koboSpan" id="kobo.139.1">Figure 9.4</span></em><span class="koboSpan" id="kobo.140.1">, let’s suppose that each router in rack 1 has five network ports available. </span><span class="koboSpan" id="kobo.140.2">Therefore, patch panel P1 needs to have at least 20 ports to allow connections to all routers on rack 1.</span></p>
<p><span class="koboSpan" id="kobo.141.1">In </span><em class="italic"><span class="koboSpan" id="kobo.142.1">Figure 9.4</span></em><span class="koboSpan" id="kobo.143.1">, there are three patch cords. </span><span class="koboSpan" id="kobo.143.2">The green one in rack 1 connects two devices inside rack 1, which could be, for instance, R0 and R1. </span><span class="koboSpan" id="kobo.143.3">The other two red patch cords are used to</span><a id="_idIndexMarker1066"/><span class="koboSpan" id="kobo.144.1"> interconnect devices between rack 1 and rack 2, which could be, for instance, between R0 and R10.</span></p>
<p><span class="koboSpan" id="kobo.145.1">Now, let’s see how we can link devices using software connections.</span></p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.146.1">Using software to connect</span></h2>
<p><span class="koboSpan" id="kobo.147.1">For the </span><a id="_idIndexMarker1067"/><span class="koboSpan" id="kobo.148.1">explanation in this subsection, we are going to assume all routers are software-emulated routers. </span><span class="koboSpan" id="kobo.148.2">A hybrid setup with software and real devices will be explained in the next subsection.</span></p>
<p><span class="koboSpan" id="kobo.149.1">Several software techniques can be used to interconnect emulated routers, and they will also depend on the operating system that is used as the host. </span><span class="koboSpan" id="kobo.149.2">For our example, we are going to use Linux as the host. </span><span class="koboSpan" id="kobo.149.3">For Windows, FreeBSD, or macOS, you might need different techniques.</span></p>
<p><span class="koboSpan" id="kobo.150.1">The methods to connect emulated routers will also depend on which emulation you are using. </span><span class="koboSpan" id="kobo.150.2">They may differ depending on whether you are using Dynamips, VirtualBox, VMware, Qemu, or Linux containers.</span></p>
<p><span class="koboSpan" id="kobo.151.1">Let’s explore a few methods to connect emulated routers using Linux.</span></p>
<h3><span class="koboSpan" id="kobo.152.1">Using TUN/TAP interfaces</span></h3>
<p><span class="koboSpan" id="kobo.153.1">In </span><a id="_idIndexMarker1068"/><span class="koboSpan" id="kobo.154.1">Linux, TUN/TAP interfaces are software interfaces that are used to receive and send network traffic, but they are not connected to any network. </span><span class="koboSpan" id="kobo.154.2">The interface is called TUN/TAP because the device can be either configured to work only on layer 3, which is called TUN mode, or on layer 2, which is called TAP interface mode. </span><span class="koboSpan" id="kobo.154.3">Both modes use the same Linux device driver (accessible via </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">/dev/net/tun</span></strong><span class="koboSpan" id="kobo.156.1">), just with a different flag. </span><span class="koboSpan" id="kobo.156.2">The flag to use TAP mode is </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">IFF_TAP</span></strong><span class="koboSpan" id="kobo.158.1">, whereas the flag to use TUN is </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">IFF_TUN</span></strong><span class="koboSpan" id="kobo.160.1">. </span><span class="koboSpan" id="kobo.160.2">More details on the kernel driver for </span><a id="_idIndexMarker1069"/><span class="koboSpan" id="kobo.161.1">TUN/TAPc can be found at </span><a href="https://www.kernel.org/doc/html/v5.8/networking/tuntap.html"><span class="koboSpan" id="kobo.162.1">https://www.kernel.org/doc/html/v5.8/networking/tuntap.html</span></a><span class="koboSpan" id="kobo.163.1">.</span></p>
<p><span class="koboSpan" id="kobo.164.1">Linux provides an easy interface for creating and removing TUN/TAP interfaces; you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">ip tuntap</span></strong><span class="koboSpan" id="kobo.166.1"> command for this. </span><span class="koboSpan" id="kobo.166.2">The following is an example of creating a tap interface:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.167.1">
claus@dev:~$ sudo ip tuntap add dev tap0 mode tap
claus@dev:~$ sudo ip link set tap0 up
claus@dev:~$ ip link show tap0
4: tap0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc fq_codel state DOWN mode DEFAULT group default qlen 1000
    link/ether b2:2e:f2:67:48:ff brd ff:ff:ff:ff:ff:ff</span></pre>
<p><span class="koboSpan" id="kobo.168.1">TAP interfaces </span><a id="_idIndexMarker1070"/><span class="koboSpan" id="kobo.169.1">are preferable to use compared to TUN interfaces, as they work at layer 2 and receive and send packets like real Ethernet interfaces.</span></p>
<p><span class="koboSpan" id="kobo.170.1">Now, let’s see how we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">veth</span></strong><span class="koboSpan" id="kobo.172.1"> interfaces.</span></p>
<h3><span class="koboSpan" id="kobo.173.1">Using veth interfaces</span></h3>
<p><span class="koboSpan" id="kobo.174.1">The </span><a id="_idIndexMarker1071"/><span class="koboSpan" id="kobo.175.1">network in a Linux container is </span><a id="_idIndexMarker1072"/><span class="koboSpan" id="kobo.176.1">isolated and has a namespace number associated with it. </span><span class="koboSpan" id="kobo.176.2">To connect to them, you will need to use veth interfaces. </span><span class="koboSpan" id="kobo.176.3">veth interfaces can be associated with the namespace and can be created on their own or with a peer in a point-to-point configuration. </span><span class="koboSpan" id="kobo.176.4">When creating a veth with a peer, you will need to associate the two namespaces, one for each side of the veth peering. </span><span class="koboSpan" id="kobo.176.5">Once the peer has been set, any information that is written to one side of the veth peer will be sent to the other side, which is a fast and easy way to interconnect emulated routers when using Linux containers. </span><span class="koboSpan" id="kobo.176.6">We are going to use them a lot in our examples. </span><span class="koboSpan" id="kobo.176.7">Here is an example of how to create a veth peer interface:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.177.1">
claus@dev:~$ sudo ip link add A type veth peer name B
claus@dev:~$ sudo ip link set A netns 41784
claus@dev:~$ sudo ip link set B netns 41634
claus@dev:~$ sudo nsenter -t 41784 -n ip link show A
11: </span><strong class="bold"><span class="koboSpan" id="kobo.178.1">A@if10</span></strong><span class="koboSpan" id="kobo.179.1">: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 9a:fa:1e:7f:0c:34 brd ff:ff:ff:ff:ff:ff link-netnsid 1
claus@dev:~$ sudo nsenter -t 41634 -n ip link show B
10: </span><strong class="bold"><span class="koboSpan" id="kobo.180.1">B@if11</span></strong><span class="koboSpan" id="kobo.181.1">: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether d6:de:78:9c:e9:73 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span></pre>
<p><span class="koboSpan" id="kobo.182.1">In this </span><a id="_idIndexMarker1073"/><span class="koboSpan" id="kobo.183.1">example, two containers are being used, which are identified by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">41784</span></strong><span class="koboSpan" id="kobo.185.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">41634</span></strong><span class="koboSpan" id="kobo.187.1"> network namespaces. </span><span class="koboSpan" id="kobo.187.2">A peer is created with interface names </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">A</span></strong><span class="koboSpan" id="kobo.189.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">B</span></strong><span class="koboSpan" id="kobo.191.1">, but the communication between the containers will only be possible after associating the interface name with the network namespace using </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">ip link set &lt;ifname&gt; netns &lt;namespace&gt;</span></strong><span class="koboSpan" id="kobo.193.1">, as in this example. </span><span class="koboSpan" id="kobo.193.2">The interface names can be the same but need to be renamed only after being associated with the namespace. </span><span class="koboSpan" id="kobo.193.3">This is because, before the association, the veth interfaces are in the host, and therefore in the same namespace, which won’t allow multiple interfaces with the same name to be created.</span></p>
<p><span class="koboSpan" id="kobo.194.1">Now, let’s learn how we can use software bridges.</span></p>
<h3><span class="koboSpan" id="kobo.195.1">Using software bridges</span></h3>
<p><span class="koboSpan" id="kobo.196.1">Software bridges </span><a id="_idIndexMarker1074"/><span class="koboSpan" id="kobo.197.1">are used to interconnect </span><a id="_idIndexMarker1075"/><span class="koboSpan" id="kobo.198.1">software and hardware network ports, which can be added and removed like a real network switch. </span><span class="koboSpan" id="kobo.198.2">The Linux kernel has a native software bridge that can be used by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">bridge</span></strong><span class="koboSpan" id="kobo.200.1"> command or by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">bridge-utils</span></strong><span class="koboSpan" id="kobo.202.1"> package and using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">brctl</span></strong><span class="koboSpan" id="kobo.204.1"> command. </span><span class="koboSpan" id="kobo.204.2">When a software bridge is created, it requires a name that is also attributed to a network interface that will or will not have an IP address. </span><span class="koboSpan" id="kobo.204.3">The following is an example of creating a bridge and associating three interfaces with it:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.205.1">
claus@dev:~$ sudo brctl addbr </span><strong class="bold"><span class="koboSpan" id="kobo.206.1">Mybridge</span></strong><span class="koboSpan" id="kobo.207.1">
claus@dev:~$ sudo brctl addif </span><strong class="bold"><span class="koboSpan" id="kobo.208.1">Mybridge</span></strong><span class="koboSpan" id="kobo.209.1"> tap0
claus@dev:~$ sudo brctl addif </span><strong class="bold"><span class="koboSpan" id="kobo.210.1">Mybridge</span></strong><span class="koboSpan" id="kobo.211.1"> tap1
claus@dev:~$ sudo brctl addif </span><strong class="bold"><span class="koboSpan" id="kobo.212.1">Mybridge</span></strong><span class="koboSpan" id="kobo.213.1"> enp0s3
claus@dev-sdwan:~$ brctl show </span><strong class="bold"><span class="koboSpan" id="kobo.214.1">Mybridge</span></strong><span class="koboSpan" id="kobo.215.1">
bridge name   bridge id   STP   enabled   interfaces
</span><strong class="bold"><span class="koboSpan" id="kobo.216.1">Mybridge</span></strong><span class="koboSpan" id="kobo.217.1">      8000.f65..  no              enp0s3
                                          tap0
                                          tap1</span></pre>
<p><span class="koboSpan" id="kobo.218.1">As </span><a id="_idIndexMarker1076"/><span class="koboSpan" id="kobo.219.1">explained previously, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">Mybridge</span></strong><span class="koboSpan" id="kobo.221.1"> bridge is also associated with a network interface on the Linux host. </span><span class="koboSpan" id="kobo.221.2">This can be seen by running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">ip link</span></strong><span class="koboSpan" id="kobo.223.1"> command, as shown here:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.224.1">
claus@dev-sdwan:~$ ip link show Mybridge
12: Mybridge: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default qlen 1000
    link/ether f6:78:c6:1a:1c:65 brd ff:ff:ff:ff:ff:ff</span></pre>
<p><span class="koboSpan" id="kobo.225.1">Linux native bridges are fast and simple, but there are advanced configurations that cannot be performed by them. </span><span class="koboSpan" id="kobo.225.2">To be able to use more advanced commands, the recommendation is to</span><a id="_idIndexMarker1077"/><span class="koboSpan" id="kobo.226.1"> use </span><strong class="bold"><span class="koboSpan" id="kobo.227.1">OpenvSwitch</span></strong><span class="koboSpan" id="kobo.228.1">, also known as </span><strong class="bold"><span class="koboSpan" id="kobo.229.1">OvS</span></strong><span class="koboSpan" id="kobo.230.1"> (there are more details at </span><a href="https://www.openvswitch.org/"><span class="koboSpan" id="kobo.231.1">https://www.openvswitch.org/</span></a><span class="koboSpan" id="kobo.232.1">).</span></p>
<h3><span class="koboSpan" id="kobo.233.1">Using VXLAN</span></h3>
<p><span class="koboSpan" id="kobo.234.1">Linux bridges, TAP, and </span><a id="_idIndexMarker1078"/><span class="koboSpan" id="kobo.235.1">veth interfaces are used locally inside the Linux host to create a connection between emulated routers, but it won’t work to interconnect emulated routers that are running in a different host. </span><span class="koboSpan" id="kobo.235.2">There are a few techniques that could be used to connect emulated routers across hosts, such as pseudowires, L2TP, and layer 2 VPNs, among others, but the best would be VXLAN.</span></p>
<p><span class="koboSpan" id="kobo.236.1">VXLAN </span><a id="_idIndexMarker1079"/><span class="koboSpan" id="kobo.237.1">works as a layer 2 tunnel that extends the local bridge to another remote device, which can be another Linux host, a network switch, or a router. </span><span class="koboSpan" id="kobo.237.2">With VXLAN, it is also possible to connect emulated routers to real routers as if they are connected by a wire on a back-to-back connection. </span><span class="koboSpan" id="kobo.237.3">As we are going to see later in this section, VXLAN is going to be used for hybrid labs where a connection between real routers and emulated routers is used.</span></p>
<p><span class="koboSpan" id="kobo.238.1">VLAN is a well-known protocol and was explained in </span><a href="B18165_02.xhtml#_idTextAnchor041"><em class="italic"><span class="koboSpan" id="kobo.239.1">Chapter 2</span></em></a><span class="koboSpan" id="kobo.240.1">, Original VLANs have 12 bits of identification, which allows for up to 4,096 VLAN IDs. </span><span class="koboSpan" id="kobo.240.2">But VLAN tagging (IEEE 802.1Q) adds an extra 12 bits, so that’s up to 24 bits for identifying a VLAN on a normal Ethernet layer 2 frame using VLAN tagging.</span></p>
<p><span class="koboSpan" id="kobo.241.1">VXLAN is</span><a id="_idIndexMarker1080"/><span class="koboSpan" id="kobo.242.1"> independent of VLAN or VLAN tagging, using </span><a id="_idIndexMarker1081"/><span class="koboSpan" id="kobo.243.1">a header identifier with 24 bits and UDP as transport with port number </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">4789</span></strong><span class="koboSpan" id="kobo.245.1">. </span><span class="koboSpan" id="kobo.245.2">An original Ethernet frame that uses a VXLAN tunnel will need an extra 54 bytes of overhead for the tunnel. </span><span class="koboSpan" id="kobo.245.3">So, if your network MTU is 1,500 bytes, the maximum MTU of payload that can be carried inside the tunnel will be reduced by 54 bytes. </span><span class="koboSpan" id="kobo.245.4">It is recommended to increase MTU when using VXLAN. </span><span class="koboSpan" id="kobo.245.5">The following diagram shows an example of protocol encapsulation for VXLAN:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer061">
<span class="koboSpan" id="kobo.246.1"><img alt="Figure 9.5 – VXLAN encapsulation" src="image/B18165_09_005.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.247.1">Figure 9.5 – VXLAN encapsulation</span></p>
<p><span class="koboSpan" id="kobo.248.1">A VXLAN connects </span><a id="_idIndexMarker1082"/><span class="koboSpan" id="kobo.249.1">endpoints, known as </span><strong class="bold"><span class="koboSpan" id="kobo.250.1">Virtual Tunnel Endpoints</span></strong><span class="koboSpan" id="kobo.251.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.252.1">VTEPs</span></strong><span class="koboSpan" id="kobo.253.1">). </span><span class="koboSpan" id="kobo.253.2">A device that works with VXLAN when receiving an Ethernet frame on a VTEP will then add the VXLAN header, UDP, and IP and will send it toward the other VTEP destination.</span></p>
<p><span class="koboSpan" id="kobo.254.1">Now, let’s see how we would set up a hybrid lab using software connections and physical wires.</span></p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.255.1">Building a hybrid lab</span></h2>
<p><span class="koboSpan" id="kobo.256.1">A hybrid lab </span><a id="_idIndexMarker1083"/><span class="koboSpan" id="kobo.257.1">is necessary whenever you want to combine emulated routers with physical routers. </span><span class="koboSpan" id="kobo.257.2">The main reason you will need such a configuration is when testing the performance of a real router and adding complexity such as an extra 500 routers in the OSPF backbone. </span><span class="koboSpan" id="kobo.257.3">It is also useful to test connections with different complex topologies, such as an external BGP with flapping routes. </span><span class="koboSpan" id="kobo.257.4">All extra anomalies can be automated and added using the emulated environment, helping the test gain agility and accuracy.</span></p>
<p><span class="koboSpan" id="kobo.258.1">With a</span><a id="_idIndexMarker1084"/><span class="koboSpan" id="kobo.259.1"> hybrid lab, you could have a few real routers connected to an unlimited number of emulated routers, perhaps building an entire network emulation that can be connected to real routers for closer production environment testing. </span><span class="koboSpan" id="kobo.259.2">Again, anomalies can be easily introduced automatically in the emulation, with precision, including packet loss, latency, and jitter. </span><span class="koboSpan" id="kobo.259.3">Therefore, your network automation skills are going to be the key to the success of a hybrid lab.</span></p>
<p><span class="koboSpan" id="kobo.260.1">The following diagram shows an example of a hybrid lab connecting four emulated routers to two real routers:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<span class="koboSpan" id="kobo.261.1"><img alt="Figure 9.6 – Connectivity example for a hybrid lab" src="image/B18165_09_006.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.262.1">Figure 9.6 – Connectivity example for a hybrid lab</span></p>
<p><span class="koboSpan" id="kobo.263.1">Note that in the preceding figure, the purple lines represent the physical cables that connect Linux host 1, Linux host 2, router A, and router B to network switch 1. </span><span class="koboSpan" id="kobo.263.2">VXLAN is used between these devices to allow the setup of any connection between these devices. </span><span class="koboSpan" id="kobo.263.3">Linux host 2 uses only container-emulated routers, and therefore veth interfaces. </span><span class="koboSpan" id="kobo.263.4">Linux host 1 uses a tap interface to connect emulated router 2, which could be, for instance, Dynamips with a Cisco-emulated router.</span></p>
<p><span class="koboSpan" id="kobo.264.1">The following</span><a id="_idIndexMarker1085"/><span class="koboSpan" id="kobo.265.1"> diagram shows a more complex hybrid setup:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer063">
<span class="koboSpan" id="kobo.266.1"><img alt="Figure 9.7 – A more complex hybrid lab setup" src="image/B18165_09_007.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.267.1">Figure 9.7 – A more complex hybrid lab setup</span></p>
<p><span class="koboSpan" id="kobo.268.1">As you can see in the preceding figure, there are 3,000 emulated routers and 6 physical routers connected via VXLAN switches and software VXLAN bridges. </span><span class="koboSpan" id="kobo.268.2">The setup looks clean and straightforward, but it can create very complex connections and topologies. </span><span class="koboSpan" id="kobo.268.3">The VXLAN switches work as patch panels that can be configured by software. </span><span class="koboSpan" id="kobo.268.4">It is also necessary to have a real router with all interfaces connected to a VXLAN switch so that it can work as a patch panel for that router, such as router A connected to VXLAN switch 2.</span></p>
<p><span class="koboSpan" id="kobo.269.1">Now, let’s discuss how we can add an OOB network.</span></p>
<h3><span class="koboSpan" id="kobo.270.1">Adding an OOB network to your lab</span></h3>
<p><span class="koboSpan" id="kobo.271.1">One important</span><a id="_idIndexMarker1086"/><span class="koboSpan" id="kobo.272.1"> problem we need to pay attention to is how</span><a id="_idIndexMarker1087"/><span class="koboSpan" id="kobo.273.1"> we access devices without needing to have any network connection. </span><span class="koboSpan" id="kobo.273.2">And the answer to this problem is to use an OOB network, or out-of-band management network, as we discussed in </span><a href="B18165_01.xhtml#_idTextAnchor015"><em class="italic"><span class="koboSpan" id="kobo.274.1">Chapter 1</span></em></a><span class="koboSpan" id="kobo.275.1">.</span></p>
<p><span class="koboSpan" id="kobo.276.1">Adding some sort of access to devices that do not require any network connection helps when performing catastrophic tests, such as when routers must be removed or turned off. </span><span class="koboSpan" id="kobo.276.2">There are several ways to access an emulated router, which is done by accessing the host where the emulation is running. </span><span class="koboSpan" id="kobo.276.3">For real routers, the way to access them is via a console or auxiliary ports, which is normally performed using serial communication. </span><span class="koboSpan" id="kobo.276.4">Therefore, to allow automation for all devices, you will require a serial port server device that will allow remote access via IP and SSH. </span><span class="koboSpan" id="kobo.276.5">Once connected to the serial port server via SSH, you will be able to access the router via a serial port from the port server. </span><span class="koboSpan" id="kobo.276.6">One example of this port server is the product Avocent ACS8000, which has 32 serial ports and can be accessed via IP using an Ethernet port or a 4G mobile network (</span><a href="https://www.amazon.com/Avocent-ACS8000-Management-Cellular-ACS8032-NA-DAC-400/dp/B099XFB39R"><span class="koboSpan" id="kobo.277.1">https://www.amazon.com/Avocent-ACS8000-Management-Cellular-ACS8032-NA-DAC-400/dp/B099XFB39R</span></a><span class="koboSpan" id="kobo.278.1">).</span></p>
<p><span class="koboSpan" id="kobo.279.1">Now, let’s use some advanced techniques to enhance our network code testing.</span></p>
<h1 id="_idParaDest-219"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.280.1">Using advanced testing techniques</span></h1>
<p><span class="koboSpan" id="kobo.281.1">I created</span><a id="_idIndexMarker1088"/><span class="koboSpan" id="kobo.282.1"> this section to explore some methods that can be used for testing that are not commonly used but might be somehow useful. </span><span class="koboSpan" id="kobo.282.2">These techniques are perhaps not used much today but might become mainstream in the future, so keep an eye on how things evolve.</span></p>
<p><span class="koboSpan" id="kobo.283.1">First, let’s see how we can use time dilation in our network code testing.</span></p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.284.1">Using time dilation</span></h2>
<p><span class="koboSpan" id="kobo.285.1">When building</span><a id="_idIndexMarker1089"/><span class="koboSpan" id="kobo.286.1"> your test environment, you might face </span><a id="_idIndexMarker1090"/><span class="koboSpan" id="kobo.287.1">requirements for testing that are physically impossible to do in a lab with emulated routers, such as measuring protocol convergence time or sending large amounts of data between devices. </span><span class="koboSpan" id="kobo.287.2">The reason these high-performance tests are physically impossible using emulation is that the CPU and I/O on an emulated router are smaller and limited compared to real routers. </span><span class="koboSpan" id="kobo.287.3">One way to overcome this limitation is to use </span><strong class="bold"><span class="koboSpan" id="kobo.288.1">time dilation</span></strong><span class="koboSpan" id="kobo.289.1">.</span></p>
<p><span class="koboSpan" id="kobo.290.1">Time dilation</span><a id="_idIndexMarker1091"/><span class="koboSpan" id="kobo.291.1"> is a technique that changes the </span><a id="_idIndexMarker1092"/><span class="koboSpan" id="kobo.292.1">CPU clock of the emulated environment in such a way that the emulated router will run slower compared to an emulation without time dilation. </span><span class="koboSpan" id="kobo.292.2">From the host’s perspective, the emulated router with time dilation will use fewer resources, as it is not running as fast as the emulated router without time dilation. </span><span class="koboSpan" id="kobo.292.3">But from the emulated router’s perspective, which uses time dilation, everything seems to run at normal speed, but in reality, is much slower.</span></p>
<p><span class="koboSpan" id="kobo.293.1">Imagine you want</span><a id="_idIndexMarker1093"/><span class="koboSpan" id="kobo.294.1"> to test the time it takes for an application to copy files between two ends using network emulation. </span><span class="koboSpan" id="kobo.294.2">In a real network, these devices will have 10 GE interfaces that can have up to 10 Gbps. </span><span class="koboSpan" id="kobo.294.3">But in an emulation environment, they might have only 100 Mbps available or even less. </span><span class="koboSpan" id="kobo.294.4">To overcome these limitations, one technique is to put all emulations, including the application, in a time dilation environment that </span><a id="_idIndexMarker1094"/><span class="koboSpan" id="kobo.295.1">has a </span><strong class="bold"><span class="koboSpan" id="kobo.296.1">time dilation factor</span></strong><span class="koboSpan" id="kobo.297.1"> (or </span><strong class="bold"><span class="koboSpan" id="kobo.298.1">TDF</span></strong><span class="koboSpan" id="kobo.299.1">) of 1,000 or more. </span><span class="koboSpan" id="kobo.299.2">With a TDF of 1,000, the CPU and I/O, including network interfaces, will be capable of performing more work from the emulated network and application perspective.</span></p>
<p><span class="koboSpan" id="kobo.300.1">For network testing, normally, TDF is greater than 1, but it is also possible to use one smaller than 1, meaning that the emulation will run faster than the host. </span><span class="koboSpan" id="kobo.300.2">The applications that use lower than 1 TDF are normally used when tests need to go faster and CPU constraints do not exist. </span><span class="koboSpan" id="kobo.300.3">For example, a TDF of 0.1 will run 10 times faster, but the implementation is normally not trivial and sometimes not possible because it relies on shortening the waiting time.</span></p>
<p><span class="koboSpan" id="kobo.301.1">The University of San Diego has done some work on time dilation based on a paper called </span><em class="italic"><span class="koboSpan" id="kobo.302.1">To Infinity and Beyond: Time-Warped Network Emulation</span></em><span class="koboSpan" id="kobo.303.1">, which does have some implementation code for Xen and Linux kernel. </span><span class="koboSpan" id="kobo.303.2">Details can be found at </span><a href="https://www.sysnet.ucsd.edu/projects/time-dilation"><span class="koboSpan" id="kobo.304.1">https://www.sysnet.ucsd.edu/projects/time-dilation</span></a><span class="koboSpan" id="kobo.305.1">. </span><span class="koboSpan" id="kobo.305.2">Other implementations for time dilation focus on virtual machines and use Qemu to manipulate time; one implementation is from the University of North Carolina, where they created a project called </span><em class="italic"><span class="koboSpan" id="kobo.306.1">Adaptive Time Dilation</span></em><span class="koboSpan" id="kobo.307.1">. </span><span class="koboSpan" id="kobo.307.2">Details can be found at </span><a href="https://research.ece.ncsu.edu/wireless/MadeInWALAN/AdaptiveTimeDilation"><span class="koboSpan" id="kobo.308.1">https://research.ece.ncsu.edu/wireless/MadeInWALAN/AdaptiveTimeDilation</span></a><span class="koboSpan" id="kobo.309.1">.</span></p>
<p><span class="koboSpan" id="kobo.310.1">One advantage of using time dilation is that TDF can be adjusted every time you perform a test in your environment. </span><span class="koboSpan" id="kobo.310.2">A low TDF will impose more CPU and I/O limitations and might be useful to test how the application and network would perform in low-performance conditions, giving a lower-bound test result. </span><span class="koboSpan" id="kobo.310.3">A high TDF would give enough CPU and I/O resources </span><a id="_idIndexMarker1095"/><span class="koboSpan" id="kobo.311.1">to test the application and network in an ideal world without resource limitations, giving an upper-bound test result. </span><span class="koboSpan" id="kobo.311.2">Adjusting TDF to a certain mid value would give</span><a id="_idIndexMarker1096"/><span class="koboSpan" id="kobo.312.1"> you the resources compatible with a real network with a real application, giving a test result that’s closer to reality.</span></p>
<p><span class="koboSpan" id="kobo.313.1">Now, let’s see how we can use monkey testing on network code testing.</span></p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.314.1">Using monkey testing</span></h2>
<p><span class="koboSpan" id="kobo.315.1">In </span><a id="_idIndexMarker1097"/><span class="koboSpan" id="kobo.316.1">software development, monkey testing is used when an application requires testing and there is no formal definition of what to test. </span><span class="koboSpan" id="kobo.316.2">Monkey testing</span><a id="_idIndexMarker1098"/><span class="koboSpan" id="kobo.317.1"> generates random inputs and evaluates the outputs.</span></p>
<p><span class="koboSpan" id="kobo.318.1">The idea of </span><a id="_idIndexMarker1099"/><span class="koboSpan" id="kobo.319.1">monkey testing is to find problems with the code that were not expected by the software developer. </span><span class="koboSpan" id="kobo.319.2">In our case, we can use monkey testing to evaluate the network automation tools and the network itself.  </span><span class="koboSpan" id="kobo.319.3">In some sense, penetration testing would be considered part of monkey testing, but more related to finding security holes, not failures.</span></p>
<p><span class="koboSpan" id="kobo.320.1">One great example </span><a id="_idIndexMarker1100"/><span class="koboSpan" id="kobo.321.1">of </span><a id="_idIndexMarker1101"/><span class="koboSpan" id="kobo.322.1">monkey testing is the Netflix implementation called </span><strong class="bold"><span class="koboSpan" id="kobo.323.1">Chaos Monkey</span></strong><span class="koboSpan" id="kobo.324.1"> (there are more details at </span><a href="https://github.com/Netflix/chaosmonkey"><span class="koboSpan" id="kobo.325.1">https://github.com/Netflix/chaosmonkey</span></a><span class="koboSpan" id="kobo.326.1">). </span><span class="koboSpan" id="kobo.326.2">Chaos Monkey is written in Go and used for randomly terminating containers and virtual machines. </span><span class="koboSpan" id="kobo.326.3">With a few modifications, it can be used to shut down interfaces and network links. </span><span class="koboSpan" id="kobo.326.4">It is based on chaos engineering (there are more details at </span><a href="http://principlesofchaos.org/"><span class="koboSpan" id="kobo.327.1">http://principlesofchaos.org/</span></a><span class="koboSpan" id="kobo.328.1">). </span><span class="koboSpan" id="kobo.328.2">Chaos Monkey</span><a id="_idIndexMarker1102"/><span class="koboSpan" id="kobo.329.1"> is a good example of monkey testing that can be added to our network automation testing infrastructure.</span></p>
<p><span class="koboSpan" id="kobo.330.1">Now, let’s explore how we could use </span><strong class="bold"><span class="koboSpan" id="kobo.331.1">artificial intelligence</span></strong><span class="koboSpan" id="kobo.332.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.333.1">AI</span></strong><span class="koboSpan" id="kobo.334.1">) for network code testing.</span></p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.335.1">Using artificial intelligence</span></h2>
<p><span class="koboSpan" id="kobo.336.1">Products that </span><a id="_idIndexMarker1103"/><span class="koboSpan" id="kobo.337.1">use AI for software</span><a id="_idIndexMarker1104"/><span class="koboSpan" id="kobo.338.1"> development are in their early stages, but they will become reality soon. </span><span class="koboSpan" id="kobo.338.2">Today, it is possible to generate code via AI platforms</span><a id="_idIndexMarker1105"/><span class="koboSpan" id="kobo.339.1"> such as </span><strong class="bold"><span class="koboSpan" id="kobo.340.1">ChatGPT</span></strong><span class="koboSpan" id="kobo.341.1"> (there’s more at </span><a href="https://chat.openai.com/auth/login"><span class="koboSpan" id="kobo.342.1">https://chat.openai.com/auth/login</span></a><span class="koboSpan" id="kobo.343.1">). </span><span class="koboSpan" id="kobo.343.2">Normally, the code generated by the AI is simple and not necessarily optimized, but it is an important milestone toward having to AI write code. </span><span class="koboSpan" id="kobo.343.3">The following is an example of the output of using</span><a id="_idIndexMarker1106"/><span class="koboSpan" id="kobo.344.1"> ChatGPT </span><a id="_idIndexMarker1107"/><span class="koboSpan" id="kobo.345.1">to write unit tests:</span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.346.1">Question: Write a unit test for the following code:</span></strong><span class="koboSpan" id="kobo.347.1">
from paramiko import SSHClient
client = SSHClient()
client.connect('10.1.1.1', username='user', password='pw')
</span><strong class="bold"><span class="koboSpan" id="kobo.348.1">AI: Here is the answer:</span></strong><span class="koboSpan" id="kobo.349.1">
import unittest
import mock
from paramiko import SSHClient
class TestSSHClient(unittest.TestCase):
    @mock.patch('paramiko.SSHClient.connect')
    def test_connect(self, mock_connect):
        client = SSHClient()
        client.connect('10.1.1.1', username='user', password='pw')
        mock_connect.assert_called_with('10.1.1.1', username='user', password='pw')
        client.close()
if __name__ == '__main__':
    unittest.main()</span></pre>
<p><span class="koboSpan" id="kobo.350.1">Note that</span><a id="_idIndexMarker1108"/><span class="koboSpan" id="kobo.351.1"> the question was very simple and did not specify the language or packages, such as Python or to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">unittest</span></strong><span class="koboSpan" id="kobo.353.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">mock</span></strong><span class="koboSpan" id="kobo.355.1"> packages. </span><span class="koboSpan" id="kobo.355.2">The AI figured out the language and the packages to import by itself. </span><span class="koboSpan" id="kobo.355.3">However, it introduced a small outdated import. </span><span class="koboSpan" id="kobo.355.4">Since Python 3.3, </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">mock</span></strong><span class="koboSpan" id="kobo.357.1"> has to be imported as </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">from unittest import mock</span></strong><span class="koboSpan" id="kobo.359.1">, instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">import mock</span></strong><span class="koboSpan" id="kobo.361.1">.</span></p>
<p><span class="koboSpan" id="kobo.362.1">Although</span><a id="_idIndexMarker1109"/><span class="koboSpan" id="kobo.363.1"> the unit test written previously </span><a id="_idIndexMarker1110"/><span class="koboSpan" id="kobo.364.1">was not complete and contained a small error, it is a huge step toward having computers automate tests during development. </span><span class="koboSpan" id="kobo.364.2">It can be used today to help developers improve their code.</span></p>
<p><span class="koboSpan" id="kobo.365.1">Some commercial products are already offering AI solutions for software development. </span><span class="koboSpan" id="kobo.365.2">For instance, GitHub has a</span><a id="_idIndexMarker1111"/><span class="koboSpan" id="kobo.366.1"> product called </span><strong class="bold"><span class="koboSpan" id="kobo.367.1">Copilot</span></strong><span class="koboSpan" id="kobo.368.1"> that</span><a id="_idIndexMarker1112"/><span class="koboSpan" id="kobo.369.1"> offers pair programming with AI (there are more details at </span><a href="http://github.com/features/copilot"><span class="koboSpan" id="kobo.370.1">github.com/features/copilot</span></a><span class="koboSpan" id="kobo.371.1">). </span><span class="koboSpan" id="kobo.371.2">Copilot claims that it can write unit tests for you, which is an amazing achievement.</span></p>
<p><span class="koboSpan" id="kobo.372.1">More and more companies will start offering solutions for code development, and for sure writing unit tests will be the first milestone to be accomplished by AI platforms. </span><span class="koboSpan" id="kobo.372.2">Unit tests consume a lot of the developer’s time, in most cases taking even more time to write than the code itself. </span><span class="koboSpan" id="kobo.372.3">Keep an eye on the market for network automation test tools that use AI – it will make development more robust and faster.</span></p>
<p><span class="koboSpan" id="kobo.373.1">Now, let’s see how we can add network simulation to enhance network code testing.</span></p>
<h2 id="_idParaDest-223"><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.374.1">Using network simulation</span></h2>
<p><span class="koboSpan" id="kobo.375.1">Network simulation, in </span><a id="_idIndexMarker1113"/><span class="koboSpan" id="kobo.376.1">contrast to network emulation, uses </span><a id="_idIndexMarker1114"/><span class="koboSpan" id="kobo.377.1">software to simulate part of the behavior of the network. </span><span class="koboSpan" id="kobo.377.2">Most network simulators are used either to simulate network protocol behaviors or to predict and calculate traffic demands and network paths. </span><span class="koboSpan" id="kobo.377.3">It can also be used to calculate resources, such as memory and network capacity on devices, but not much more beyond that.</span></p>
<p><span class="koboSpan" id="kobo.378.1">One of the very </span><a id="_idIndexMarker1115"/><span class="koboSpan" id="kobo.379.1">popular Python packages that is used for </span><a id="_idIndexMarker1116"/><span class="koboSpan" id="kobo.380.1">network simulation is </span><strong class="bold"><span class="koboSpan" id="kobo.381.1">NetworkX</span></strong><span class="koboSpan" id="kobo.382.1"> (there are more details at </span><a href="https://networkx.org/"><span class="koboSpan" id="kobo.383.1">https://networkx.org/</span></a><span class="koboSpan" id="kobo.384.1">), which is a graph manipulation library. </span><span class="koboSpan" id="kobo.384.2">With NetworkX, it is possible to create a large network with thousands of nodes and millions of links using much fewer resources than when using network emulation. </span><span class="koboSpan" id="kobo.384.3">Simulating a large network using NetworkX is possible if you wish to run several tests that will be performed much faster than using emulation. </span><span class="koboSpan" id="kobo.384.4">However, the tests will evaluate the behavior of the network due to link and node failures, not the control plane (routing protocols) or the operating system of the routers.</span></p>
<p><span class="koboSpan" id="kobo.385.1">Another useful application</span><a id="_idIndexMarker1117"/><span class="koboSpan" id="kobo.386.1"> of network simulation is to test a network access list table path for a particular IP prefix. </span><span class="koboSpan" id="kobo.386.2">Once the network simulation has been built, it is possible to determine where a certain IP packet would flow in terms of normal and failure conditions. </span><span class="koboSpan" id="kobo.386.3">The</span><a id="_idIndexMarker1118"/><span class="koboSpan" id="kobo.387.1"> simulation must be built using the network router configuration tables, and perhaps can be updated regularly to match production. </span><span class="koboSpan" id="kobo.387.2">Note that this kind of test will demand the creation of a network graph for each IP prefix to be tested, and the access list for each interface will dictate the inclusion (or not) of the link in the IP prefix graph.</span></p>
<p><span class="koboSpan" id="kobo.388.1">The following figure shows the topology that we are going to build using NetworkX as an example:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer064">
<span class="koboSpan" id="kobo.389.1"><img alt="Figure 9.8 – Topology to be used with NetworkX" src="image/B18165_09_008.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.390.1">Figure 9.8 – Topology to be used with NetworkX</span></p>
<p><span class="koboSpan" id="kobo.391.1">This topology is also described in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">Chapter09/NetworkX/topology.yaml</span></strong><span class="koboSpan" id="kobo.393.1"> file, which is included in the GitHub repo of this book. </span><span class="koboSpan" id="kobo.393.2">The following code reads this file and creates a NetworkX graph with this topology:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.394.1">
import networkx as nx
import yaml
G = nx.Graph()
devices = {}
with open("topology.yaml", "r") as file:
    yfile = yaml.safe_load(file)
for i, x in enumerate(yfile["devices"]):
    devices[x] = i
    G.add_node(i, name=x)
for link in yfile["links"]:
    G.add_edge(devices[link[0]], devices[link[1]])</span></pre>
<p><span class="koboSpan" id="kobo.395.1">After loading </span><a id="_idIndexMarker1119"/><span class="koboSpan" id="kobo.396.1">the topology, a series of tests</span><a id="_idIndexMarker1120"/><span class="koboSpan" id="kobo.397.1"> can be done to evaluate the behavior of the network. </span><span class="koboSpan" id="kobo.397.2">For instance, we could remove the link between </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">cpe-a</span></strong><span class="koboSpan" id="kobo.399.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">acc-a</span></strong><span class="koboSpan" id="kobo.401.1"> and see whether there is connectivity between </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">pc-a</span></strong><span class="koboSpan" id="kobo.403.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">internet</span></strong><span class="koboSpan" id="kobo.405.1">. </span><span class="koboSpan" id="kobo.405.2">As the process of adding and removing edges is more interactive, the best platform to use NetworkX for testing would be a Jupyter notebook (as described in </span><em class="italic"><span class="koboSpan" id="kobo.406.1">Chapter 6</span></em><span class="koboSpan" id="kobo.407.1">). </span><span class="koboSpan" id="kobo.407.2">The following screenshot shows the output of the Jupyter notebook, showing the test of removing a link and testing connectivity between </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">pc-a</span></strong><span class="koboSpan" id="kobo.409.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">internet</span></strong><span class="koboSpan" id="kobo.411.1">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer065">
<span class="koboSpan" id="kobo.412.1"><img alt="Figure 9.9 – Jupyter notebook output example" src="image/B18165_09_009.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.413.1">Figure 9.9 – Jupyter notebook output example</span></p>
<p><span class="koboSpan" id="kobo.414.1">As you can see, if you remove the link between </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">cpe-a</span></strong><span class="koboSpan" id="kobo.416.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">acc-a</span></strong><span class="koboSpan" id="kobo.418.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">edge 1,2</span></strong><span class="koboSpan" id="kobo.420.1">), </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">pc-a</span></strong><span class="koboSpan" id="kobo.422.1"> loses connectivity to </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">internet</span></strong><span class="koboSpan" id="kobo.424.1">. </span><span class="koboSpan" id="kobo.424.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">node_connectivity()</span></strong><span class="koboSpan" id="kobo.426.1"> method returns an </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">integer</span></strong><span class="koboSpan" id="kobo.428.1"> that, if greater than zero, indicates there is connectivity between nodes (more details on this method and other connectivity algorithms can be found at </span><a href="https://networkx.org/documentation/stable/reference/algorithms/connectivity.html"><span class="koboSpan" id="kobo.429.1">https://networkx.org/documentation/stable/reference/algorithms/connectivity.html</span></a><span class="koboSpan" id="kobo.430.1">). </span><span class="koboSpan" id="kobo.430.2">A series of additional tests can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">Chapter09/NetworkX/example.ipynb</span></strong><span class="koboSpan" id="kobo.432.1"> file.</span></p>
<p><span class="koboSpan" id="kobo.433.1">A combination of </span><a id="_idIndexMarker1121"/><span class="koboSpan" id="kobo.434.1">network simulation and network emulation can be used to increase the capacity and speed of your code testing. </span><span class="koboSpan" id="kobo.434.2">A mechanism must be included to build the emulation and create the simulation using the same configuration. </span><span class="koboSpan" id="kobo.434.3">In addition, some tests can be performed first on simulation and, if required, repeated in the emulation to be validated.</span></p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.435.1">Using traffic control</span></h2>
<p><span class="koboSpan" id="kobo.436.1">Using </span><a id="_idIndexMarker1122"/><span class="koboSpan" id="kobo.437.1">traffic shaping (or traffic control), it is</span><a id="_idIndexMarker1123"/><span class="koboSpan" id="kobo.438.1"> possible to add complexity to our emulation by adding some physical characteristics that are present in real links and multi-to-multi-point networks. </span><span class="koboSpan" id="kobo.438.2">With traffic shaping, we can add latency to specific connections, introduce packet loss, add random limitations, add network congestion, add jitter, and much more. </span><span class="koboSpan" id="kobo.438.3">On Linux, it can be easily obtained by using the built-in </span><strong class="bold"><span class="koboSpan" id="kobo.439.1">Linux Traffic Control</span></strong><span class="koboSpan" id="kobo.440.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.441.1">TC</span></strong><span class="koboSpan" id="kobo.442.1">), which</span><a id="_idIndexMarker1124"/><span class="koboSpan" id="kobo.443.1"> can be implemented by using the Linux </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">tc</span></strong><span class="koboSpan" id="kobo.445.1"> command.</span></p>
<p><span class="koboSpan" id="kobo.446.1">TC is implemented in Linux by using schedulers</span><a id="_idIndexMarker1125"/><span class="koboSpan" id="kobo.447.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.448.1">queuing disciplines</span></strong><span class="koboSpan" id="kobo.449.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.450.1">qdiscs</span></strong><span class="koboSpan" id="kobo.451.1">). </span><span class="koboSpan" id="kobo.451.2">Some qdiscs are included in the Linux kernel, whereas others have to be added as modules. </span><span class="koboSpan" id="kobo.451.3">There are classful qdiscs and classless qdiscs, and the difference between them is that one is hierarchical and uses classes and the other does not have any classes (more details on </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">tc</span></strong><span class="koboSpan" id="kobo.453.1"> and qdiscs can be found at </span><a href="https://tldp.org/HOWTO/Traffic-Control-HOWTO"><span class="koboSpan" id="kobo.454.1">https://tldp.org/HOWTO/Traffic-Control-HOWTO</span></a><span class="koboSpan" id="kobo.455.1">).</span></p>
<p><span class="koboSpan" id="kobo.456.1">The following is an example of using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">qdisc</span></strong><span class="koboSpan" id="kobo.458.1"> called </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">netem</span></strong><span class="koboSpan" id="kobo.460.1"> to add 10 ms of latency to the loopback interface:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.461.1">
$ sudo fping -q -c 100 -p 100 localhost
localhost : xmt/rcv/%loss = 100/100/0%, min/avg/max = 0.030/0.044/0.069
$ sudo tc qdisc add dev lo root netem delay </span><strong class="bold"><span class="koboSpan" id="kobo.462.1">10ms</span></strong><span class="koboSpan" id="kobo.463.1">
$ sudo fping -q -c 100 -p 100 localhost
localhost : xmt/rcv/%loss = 100/100/0%, min/avg/max = 20.4/</span><strong class="bold"><span class="koboSpan" id="kobo.464.1">21.4</span></strong><span class="koboSpan" id="kobo.465.1">/24.8</span></pre>
<p><span class="koboSpan" id="kobo.466.1">This example adds 10 ms to reach the </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">lo</span></strong><span class="koboSpan" id="kobo.468.1"> interface in each way, so the round-trip time is double, which appears in the results as a 21.4 ms average.</span></p>
<p><span class="koboSpan" id="kobo.469.1">Here is </span><a id="_idIndexMarker1126"/><span class="koboSpan" id="kobo.470.1">another example, showing how to add 5% packet loss using </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">netem</span></strong><span class="koboSpan" id="kobo.472.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.473.1">
$ sudo fping -q -c 100 -p 100 localhost
localhost : xmt/rcv/%loss = 100/100/0%, min/avg/max = 0.031/0.044/0.101
$ sudo tc qdisc add dev lo root netem loss 5%
$ sudo fping -q -c 100 -p 100 localhost
localhost : xmt/rcv/%loss = 100/96/</span><strong class="bold"><span class="koboSpan" id="kobo.474.1">4%</span></strong><span class="koboSpan" id="kobo.475.1">, min/avg/max = 0.032/0.056/0.197</span></pre>
<p><span class="koboSpan" id="kobo.476.1">In this</span><a id="_idIndexMarker1127"/><span class="koboSpan" id="kobo.477.1"> test example, the result was 4% of packet loss instead of 5% as configured. </span><span class="koboSpan" id="kobo.477.2">This is because </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">netem</span></strong><span class="koboSpan" id="kobo.479.1"> uses random selection to obtain packet loss, and it will require a larger testing sample to get closer to 5% – for example, 1,000 packets instead of 100, which was used in the preceding test.</span></p>
<p><span class="koboSpan" id="kobo.480.1">Other more complex network behaviors can be added to the</span><a id="_idIndexMarker1128"/><span class="koboSpan" id="kobo.481.1"> interface using </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">netem</span></strong><span class="koboSpan" id="kobo.483.1">, such as burst control, maximum capacity, network congestion, and random latency variance, among others. </span><span class="koboSpan" id="kobo.483.2">More details</span><a id="_idIndexMarker1129"/><span class="koboSpan" id="kobo.484.1"> on it can be found at </span><a href="https://wiki.linuxfoundation.org/networking/netem"><span class="koboSpan" id="kobo.485.1">https://wiki.linuxfoundation.org/networking/netem</span></a><span class="koboSpan" id="kobo.486.1">.</span></p>
<p><span class="koboSpan" id="kobo.487.1">There are lots of other schedulers besides </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">netem</span></strong><span class="koboSpan" id="kobo.489.1">, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">choke</span></strong><span class="koboSpan" id="kobo.491.1">,  </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">codel</span></strong><span class="koboSpan" id="kobo.493.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">hhf</span></strong><span class="koboSpan" id="kobo.495.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">ATM</span></strong><span class="koboSpan" id="kobo.497.1">. </span><span class="koboSpan" id="kobo.497.2">A list of all classless and classful qdiscs available can be obtained on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">tc</span></strong><span class="koboSpan" id="kobo.499.1"> man page, which can be visualized by just typing </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">man tc</span></strong><span class="koboSpan" id="kobo.501.1"> (the HTML version can be found at </span><a href="https://manpages.debian.org/buster/iproute2/tc.8.en.html"><span class="koboSpan" id="kobo.502.1">https://manpages.debian.org/buster/iproute2/tc.8.en.html</span></a><span class="koboSpan" id="kobo.503.1">).</span></p>
<p><span class="koboSpan" id="kobo.504.1">Hopefully, you have got the most out of this section and have started wondering whether some of these advanced techniques could be added to your project. </span><span class="koboSpan" id="kobo.504.2">Adding one of these techniques will likely make your project more reliable and closer to a real production environment.</span></p>
<h1 id="_idParaDest-225"><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.505.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.506.1">The goal of this chapter was to introduce you to how to build and use a proper infrastructure to test your automation code using software. </span><span class="koboSpan" id="kobo.506.2">You learned how software can be used to effectively test your automation code, how to use simulation and emulation, how to connect real and emulated devices, and finally, how advanced techniques can be incorporated.</span></p>
<p><span class="koboSpan" id="kobo.507.1">Adding some of the techniques described in this chapter will add superpowers to your network automation code project. </span><span class="koboSpan" id="kobo.507.2">From now on, it will be unbeatable.</span></p>
<p><span class="koboSpan" id="kobo.508.1">In the next chapter, we are going to get hands-on in a network lab and wrap up this book with a few additional remarks.</span></p>
</div>
</body></html>