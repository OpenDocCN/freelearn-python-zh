<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-208"><a id="_idTextAnchor209"/>9</h1>
<h1 id="_idParaDest-209"><a id="_idTextAnchor210"/>Network Code Testing Framework</h1>
<p>One important aspect when developing code is to add testing; we discussed and reviewed some code test strategies in <a href="B18165_05.xhtml#_idTextAnchor127"><em class="italic">Chapter 5</em></a>, <em class="italic">Do’s and Don’ts for Network Programming</em>. But we have not investigated techniques that are unique to network automation, such as building a network testing environment where we can do some real testing with our network automation code.</p>
<p>This chapter will focus on techniques for building a network testing framework that can be used for testing your network automation code. We are also going to look into advanced techniques that can be added to make your testing framework even more useful and reliable.</p>
<p>Here are the topics we are going to cover in this chapter:</p>
<ul>
<li>Using software for testing</li>
<li>Using device emulation</li>
<li>Connecting devices for testing</li>
<li>Using advanced testing techniques</li>
</ul>
<p>By the end of this chapter, you should have enough information to build and use a testing framework that will add significant value to your network automation project.</p>
<h1 id="_idParaDest-210"><a id="_idTextAnchor211"/>Technical requirements</h1>
<p>The source code described in this chapter is stored in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter09">https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter09</a>.</p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor212"/>Using software for testing</h1>
<p>Some<a id="_idIndexMarker1040"/> companies, when buying network devices, buy additional devices to be used for testing purposes. These extra devices are normally installed in a separate environment to replicate part of the production network for testing. Before one test is performed, the devices are connected and configured to replicate a particular part of the network. Once the tests are finished, the setup is then removed and another configuration with different connections may take place to perform tests for another part of the network. There are several reasons why these tests are necessary, such as testing new software, validating a new configuration, verifying an update, checking performance, qualifying a new network design, and testing new functionality, among others.</p>
<p>But the <a id="_idIndexMarker1041"/>main problem is that the testing environment is costly, slow to set up, and cannot be used by multiple test engineers in parallel. It also demands the physical presence of a specialized technician who will eventually have to sort new cable connections, perform hardware updates, add or remove network cards, and sometimes update the operating systems of the devices.</p>
<p>The physical testing environment is ultimately inevitable, but a few tests can be performed by using software instead of physical hardware. The tests that can be performed by software will depend on the requirement of the test. Tests that evaluate software configuration, verify design concepts, validate routing behavior, and validate new features and perhaps router stability might be performed by software.</p>
<p>In addition, software can be used to make connections between network devices, which also speeds up the setup process. But one area won’t be able to be tested, which is network stress and performance, such as measuring maximum throughput or capacity.</p>
<p>There are several techniques we can use to use software for network testing, and most of them will be done using simulation and emulation. But what are the differences between emulation and simulation? Let’s discuss this now.</p>
<h2 id="_idParaDest-212"><a id="_idTextAnchor213"/>Differences between emulation and simulation</h2>
<p>Emulation and simulation<a id="_idIndexMarker1042"/> have their meanings commonly mixed it up. Although mistaking them is not that important, it is good to understand their meaning so that you can understand their limitations and capabilities when using them.</p>
<p>In the case of <a id="_idIndexMarker1043"/>emulation, it is<a id="_idIndexMarker1044"/> when you use software to mimic the physical aspects of the entity you want to test. So, in our network automation, it would be a router, a switch, or a network connection (link).</p>
<p>Therefore, using a router emulation implies that all necessary hardware, such as network ports, console ports, CPU, and memory, must be mocked by software so that the operating system of the router can run seamlessly as if it were running in real hardware. One example of a router<a id="_idIndexMarker1045"/> emulator is <strong class="bold">Dynamips</strong> (there are more details at <a href="https://github.com/GNS3/dynamips">https://github.com/GNS3/dynamips</a>).</p>
<p>On the other<a id="_idIndexMarker1046"/> hand, a simulator is built to mimic some functionalities of the entity that you want to test. In the case of a router, normally, only particular functions are simulated, not all the functions of the router. Because of the characteristics of being smaller, a simulator can accomplish results much faster and can scale up to thousands in comparison to an emulator. Two popular examples of software used for <a id="_idIndexMarker1047"/>simulating<a id="_idIndexMarker1048"/> networks are <strong class="bold">ns-3</strong> (<a href="https://www.nsnam.org/">https://www.nsnam.org/</a>) and <strong class="bold">NetworkX</strong> (<a href="https://networkx.org/">https://networkx.org/</a>).</p>
<p>Now that we know the differences between emulation and simulation, let’s dive a bit deeper into emulation.</p>
<h1 id="_idParaDest-213"><a id="_idTextAnchor214"/>Using device emulation</h1>
<p>The best <a id="_idIndexMarker1049"/>use case for using emulation in <a id="_idIndexMarker1050"/>our network automation would be for routers. With router emulation, we can test several features of the router without having it physically. But router emulation is perhaps the hardest to accomplish and the costliest in terms of resources. As an example, let’s explore how a popular Cisco router emulator works, called Dynamips. <em class="italic">Figure 9.1</em> represents a Cisco router being emulated by using Dynamips on a Linux host:</p>
<div><div><img alt="Figure 9.1 – Cisco router emulation" src="img/B18165_09_001.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Cisco router emulation</p>
<p>As<a id="_idIndexMarker1051"/> illustrated, Dynamips is a software layer that emulates the hardware for Cisco routers. Dynamips can emulate some Cisco hardware<a id="_idIndexMarker1052"/> such as network ports, CPU, memory, auxiliary ports, and console ports. Dynamips was created by Christophe Fillot in 2005 to emulate the MIPS processor architecture for Cisco routers. Today, Dynamips is supported and maintained by the GNS network simulation team, more details of which can be found at <a href="https://github.com/GNS3/dynamips">https://github.com/GNS3/dynamips</a>.</p>
<p>Dynamips works like a virtual machine in that it will only run a Cisco operating system. To emulate a MIPs processor, Dynamips consumes a lot of CPU and memory. For instance, to run a legacy Cisco router 7200, Dynamips will allocate a minimum of 256 MB of RAM, plus 16 MB of cache. CPU is also heavily used to run the router by translating instruction by instruction. Earlier versions of Dynamips overloaded the CPU host, but with the introduction of a capability <a id="_idIndexMarker1053"/>called <strong class="bold">idle-PC</strong>, the CPU consumption was reduced by a significant amount.</p>
<p>Other routers can be emulated but will need an emulator that provides the necessary hardware emulation for the CPU platform you require. Juniper routers can be emulated by using Juniper Olive. Juniper Olive is FreeBSD modified to load the Juniper router operational system called JunOS. With emulation, you can also run legacy routers by using a hardware emulator that can provide legacy CPU architecture.</p>
<p>The following diagram illustrates a system running with four emulations, two Cisco routers, one Juniper router, and one legacy OpenWRT router:</p>
<div><div><img alt="Figure 9.2 – Four emulations on one system" src="img/B18165_09_002.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Four emulations on one system</p>
<p>The <a id="_idIndexMarker1054"/>connection between these routers in <a id="_idIndexMarker1055"/>the preceding diagram is created on the operating system host. The host can provide a more complex software link emulation to provide connectivity or just copy traffic from one end and send it to another end for point-to-point connections. More on these connections will be explained later in this chapter in the <em class="italic">Connecting devices for testing</em> section.</p>
<p>Note that with emulation, it is possible to completely isolate the router, thus providing a completely different architecture. In <em class="italic">Figure 9.2</em>, Dynamips provides a MIPS CPU architecture to emulate Cisco 7200, Qemu provides a 32-bit CPU architecture to emulate a legacy OpenWRT router, VMware provides a 64-bit x86 CPU architecture to emulate a Juniper router, and Qemu provides a 64-bit x86 CPU architecture to emulate a Cisco XRv 9000.</p>
<p>The host that’s used for emulating these routers is Linux with a 6.1.4 kernel, but it could be another kernel or another operating system such as Windows that’s capable of running the emulators. The consumption of CPU and memory for <em class="italic">Figure 9.2</em> is quite high – Cisco 9000 requires at least 4 vCPUs and 16 GB of RAM, Juniper requires a minimum of 2 vCPUs and 512 MB of RAM, Legacy OpenWRT requires a minimum of 1 vCPU, and Cisco 7200 requires a minimum of 2 vCPUs and around 300 MB.</p>
<p>Therefore, creating a large network using router emulation is hard, and perhaps impossible because of limited resources. One way to scale up the emulation is to share the hardware drivers, memory, and CPU by using some sort of operating system isolation, such as using Linux containers or FreeBSD jails. But with container setup, you will have to use the same version of the kernel and the same CPU architecture for all routers. Therefore, if your router runs on an ARM processor, and your host is an x86 processor, Linux containers won’t work. To work, the containers and the host must use the same CPU architecture.</p>
<p>Now, let’s have a look at how to scale emulation using containers.</p>
<h2 id="_idParaDest-214"><a id="_idTextAnchor215"/>Scaling up emulation with containers</h2>
<p>Emulation <a id="_idIndexMarker1056"/>will scale up if you share resources from the host dynamically. However, that requires your router to run as a program on a Linux host that can be isolated as a container. That is perhaps a big limitation as most commercial routers do not run on Linux and can’t be containerized. Choosing open source routers gives you the advantage of it being easy to move to a container-based architecture. Some big companies have chosen to move away from commercial operating system routers and migrate to a Linux-based routing architecture, which facilitates the creation of the emulated network.</p>
<p>Despite the commercial limitations, some vendors provide versions that can be containerized, such as Arista, Cisco, Juniper, and Nokia. This includes Cisco XRv and CSRv versions, Juniper vMX and vQFX, Arista vEOS, and Nokia VSR. One project that explores these<a id="_idIndexMarker1057"/> capabilities is <strong class="bold">vrnetlab</strong> (there are more details at <a href="http://github.com/vrnetlab/vrnetlab">github.com/vrnetlab/vrnetlab</a>).</p>
<p>There are a bunch of network tests that can be done, even if the routers are not the same as production, such as network design tests, topology migration tests, IP filter-based tests, and topology failover tests, among others. The reason is that most topologies run standard protocols and can be translated into an open source network platform. If you are using SDN and OpenFlow, that is also true.</p>
<p>The following diagram illustrates how you could run four emulated routers using containers:</p>
<div><div><img alt="Figure 9.3 – Running emulation with containers" src="img/B18165_09_003.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Running emulation with containers</p>
<p>As you can see in the preceding figure, the containers share CPU, memory, and network ports with the Linux host (green rectangle), but with isolation within the container. Each container isolates the shared resources from other containers, but they use the same Linux kernel, same drivers, and same CPU architecture. Different runtime libraries can be used, but the kernel and CPU architecture must be the same. Each container will have its own routing table, and programs running on the same container will share the same routing table but will not share the routing tables between containers unless using a routing protocol.</p>
<p>You could <a id="_idIndexMarker1058"/>also run a virtual machine inside a container, but then you are not saving resources, and the limitations shown previously are the same. So, if you want to scale up, you have to share the hardware resources with all containers, not emulate another layer like in <em class="italic">Figure 9.2</em>.</p>
<p>In the example in <em class="italic">Figure 9.3</em>, there are four routers – one FRRouting, one OpenWRT, one Quagga, and one DD-WRT. All these routers are open source and can be containerized. But they are not necessarily one program running, but instead a group of programs. Quagga and FFRouting run several programs that do different tasks, such as <code>bgpd</code>, <code>ospfd</code>, and <code>zebra</code>. References to<a id="_idIndexMarker1059"/> these open source routers can be obtained from the following sources:</p>
<ul>
<li>FRRouting: <a href="https://frrouting.org/">https://frrouting.org/</a></li>
<li>OpenWRT: <a href="https://openwrt.org/docs/guide-user/virtualization/lxc ">https://openwrt.org/docs/guide-user/virtualization/lxc</a></li>
<li>Quagga: <a href="https://www.nongnu.org/quagga/">https://www.nongnu.org/quagga/</a></li>
<li>DD-WRT: <a href="https://dd-wrt.com/">https://dd-wrt.com/</a></li>
</ul>
<p>You will need some connectivity capability to be able to connect the emulated routers. Now, let’s discuss the techniques we can use to connect devices in a network.</p>
<h1 id="_idParaDest-215"><a id="_idTextAnchor216"/>Connecting devices for testing</h1>
<p>Ensuring <a id="_idIndexMarker1060"/>the connectivity <a id="_idIndexMarker1061"/>of our devices for tests is important for obtaining a proper network environment for testing. There are several different ways to connect devices for testing, such as physical cables and software. Physical cables always have two caveats – they require technical personnel at the site and take time to implement. Via software, there is only one limitation – the maximum data throughput, which<a id="_idIndexMarker1062"/> is normally a fraction of a physical cable. Therefore, if your tests require high data throughput, you might need to use physical wires instead. There is a workaround to this limitation that we are going to explain later in this chapter when we look at advanced techniques.</p>
<p>The environment<a id="_idIndexMarker1063"/> for using devices for testing is also known as a network testing laboratory or just a network lab. To explain how we can connect devices in our lab, let’s describe the three possible ways to connect devices in a lab.</p>
<h2 id="_idParaDest-216"><a id="_idTextAnchor217"/>Using physical wires to connect</h2>
<p>In a <a id="_idIndexMarker1064"/>test environment, a physical connection normally consists of wires that connect the ports of  network devices. They are normally optical cables, coaxial cables, or twisted pair cables. If you have two devices, the cables are simple and will pass from one device to the other. However, if you are planning to have a lab with several racks and dozens of devices, you might want to use a patch cord and a patch panel instead of passing wires through the racks. The idea of using a patch panel is that the technician will only need to use patch cords to connect the devices, which makes the connection setup a bit faster and easier to remove later.</p>
<p>It is important to understand how the patch panel and patch cords work in the physical lab because it will help us to understand the software version later. The following diagram illustrates the patch panels for connecting two racks with four routers each:</p>
<div><div><img alt="Figure 9.4 – Connecting routers using patch panels" src="img/B18165_09_004.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Connecting routers using patch panels</p>
<p>Note that <a id="_idIndexMarker1065"/>in the preceding figure, the orange and blue wires represent permanent wires and will never be removed. The red and green lines represent the patch cords that are used to connect devices but can be removed and reconnected easily for a different topology setup. The blue lines in rack 1 are connecting routers R0, R1, R2, and R3 to patch panel P1, similar to rack 2, which connects routers R10, R11, R12, and R13 to patch panel P11. The orange lines represent the permanent wires that connect patch panel P0 to patch panel P10.</p>
<p>Whenever a topology setup is required, the technician just needs patch cords to set up connections between the routers. The number of ports on each patch panel will depend on the number of available network ports on each router. As an example, for <em class="italic">Figure 9.4</em>, let’s suppose that each router in rack 1 has five network ports available. Therefore, patch panel P1 needs to have at least 20 ports to allow connections to all routers on rack 1.</p>
<p>In <em class="italic">Figure 9.4</em>, there are three patch cords. The green one in rack 1 connects two devices inside rack 1, which could be, for instance, R0 and R1. The other two red patch cords are used to<a id="_idIndexMarker1066"/> interconnect devices between rack 1 and rack 2, which could be, for instance, between R0 and R10.</p>
<p>Now, let’s see how we can link devices using software connections.</p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor218"/>Using software to connect</h2>
<p>For the <a id="_idIndexMarker1067"/>explanation in this subsection, we are going to assume all routers are software-emulated routers. A hybrid setup with software and real devices will be explained in the next subsection.</p>
<p>Several software techniques can be used to interconnect emulated routers, and they will also depend on the operating system that is used as the host. For our example, we are going to use Linux as the host. For Windows, FreeBSD, or macOS, you might need different techniques.</p>
<p>The methods to connect emulated routers will also depend on which emulation you are using. They may differ depending on whether you are using Dynamips, VirtualBox, VMware, Qemu, or Linux containers.</p>
<p>Let’s explore a few methods to connect emulated routers using Linux.</p>
<h3>Using TUN/TAP interfaces</h3>
<p>In <a id="_idIndexMarker1068"/>Linux, TUN/TAP interfaces are software interfaces that are used to receive and send network traffic, but they are not connected to any network. The interface is called TUN/TAP because the device can be either configured to work only on layer 3, which is called TUN mode, or on layer 2, which is called TAP interface mode. Both modes use the same Linux device driver (accessible via <code>/dev/net/tun</code>), just with a different flag. The flag to use TAP mode is <code>IFF_TAP</code>, whereas the flag to use TUN is <code>IFF_TUN</code>. More details on the kernel driver for <a id="_idIndexMarker1069"/>TUN/TAPc can be found at <a href="https://www.kernel.org/doc/html/v5.8/networking/tuntap.html">https://www.kernel.org/doc/html/v5.8/networking/tuntap.html</a>.</p>
<p>Linux provides an easy interface for creating and removing TUN/TAP interfaces; you can use the <code>ip tuntap</code> command for this. The following is an example of creating a tap interface:</p>
<pre class="console">
claus@dev:~$ sudo ip tuntap add dev tap0 mode tap
claus@dev:~$ sudo ip link set tap0 up
claus@dev:~$ ip link show tap0
4: tap0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc fq_codel state DOWN mode DEFAULT group default qlen 1000
    link/ether b2:2e:f2:67:48:ff brd ff:ff:ff:ff:ff:ff</pre>
<p>TAP interfaces <a id="_idIndexMarker1070"/>are preferable to use compared to TUN interfaces, as they work at layer 2 and receive and send packets like real Ethernet interfaces.</p>
<p>Now, let’s see how we can use <code>veth</code> interfaces.</p>
<h3>Using veth interfaces</h3>
<p>The <a id="_idIndexMarker1071"/>network in a Linux container is <a id="_idIndexMarker1072"/>isolated and has a namespace number associated with it. To connect to them, you will need to use veth interfaces. veth interfaces can be associated with the namespace and can be created on their own or with a peer in a point-to-point configuration. When creating a veth with a peer, you will need to associate the two namespaces, one for each side of the veth peering. Once the peer has been set, any information that is written to one side of the veth peer will be sent to the other side, which is a fast and easy way to interconnect emulated routers when using Linux containers. We are going to use them a lot in our examples. Here is an example of how to create a veth peer interface:</p>
<pre class="source-code">
claus@dev:~$ sudo ip link add A type veth peer name B
claus@dev:~$ sudo ip link set A netns 41784
claus@dev:~$ sudo ip link set B netns 41634
claus@dev:~$ sudo nsenter -t 41784 -n ip link show A
11: <strong class="bold">A@if10</strong>: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 9a:fa:1e:7f:0c:34 brd ff:ff:ff:ff:ff:ff link-netnsid 1
claus@dev:~$ sudo nsenter -t 41634 -n ip link show B
10: <strong class="bold">B@if11</strong>: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether d6:de:78:9c:e9:73 brd ff:ff:ff:ff:ff:ff link-netnsid 1</pre>
<p>In this <a id="_idIndexMarker1073"/>example, two containers are being used, which are identified by the <code>41784</code> and <code>41634</code> network namespaces. A peer is created with interface names <code>A</code> and <code>B</code>, but the communication between the containers will only be possible after associating the interface name with the network namespace using <code>ip link set &lt;ifname&gt; netns &lt;namespace&gt;</code>, as in this example. The interface names can be the same but need to be renamed only after being associated with the namespace. This is because, before the association, the veth interfaces are in the host, and therefore in the same namespace, which won’t allow multiple interfaces with the same name to be created.</p>
<p>Now, let’s learn how we can use software bridges.</p>
<h3>Using software bridges</h3>
<p>Software bridges <a id="_idIndexMarker1074"/>are used to interconnect <a id="_idIndexMarker1075"/>software and hardware network ports, which can be added and removed like a real network switch. The Linux kernel has a native software bridge that can be used by using the <code>bridge</code> command or by adding the <code>bridge-utils</code> package and using the <code>brctl</code> command. When a software bridge is created, it requires a name that is also attributed to a network interface that will or will not have an IP address. The following is an example of creating a bridge and associating three interfaces with it:</p>
<pre class="source-code">
claus@dev:~$ sudo brctl addbr <strong class="bold">Mybridge</strong>
claus@dev:~$ sudo brctl addif <strong class="bold">Mybridge</strong> tap0
claus@dev:~$ sudo brctl addif <strong class="bold">Mybridge</strong> tap1
claus@dev:~$ sudo brctl addif <strong class="bold">Mybridge</strong> enp0s3
claus@dev-sdwan:~$ brctl show <strong class="bold">Mybridge</strong>
bridge name   bridge id   STP   enabled   interfaces
<strong class="bold">Mybridge</strong>      8000.f65..  no              enp0s3
                                          tap0
                                          tap1</pre>
<p>As <a id="_idIndexMarker1076"/>explained previously, the <code>Mybridge</code> bridge is also associated with a network interface on the Linux host. This can be seen by running the <code>ip link</code> command, as shown here:</p>
<pre class="console">
claus@dev-sdwan:~$ ip link show Mybridge
12: Mybridge: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default qlen 1000
    link/ether f6:78:c6:1a:1c:65 brd ff:ff:ff:ff:ff:ff</pre>
<p>Linux native bridges are fast and simple, but there are advanced configurations that cannot be performed by them. To be able to use more advanced commands, the recommendation is to<a id="_idIndexMarker1077"/> use <strong class="bold">OpenvSwitch</strong>, also known as <strong class="bold">OvS</strong> (there are more details at <a href="https://www.openvswitch.org/">https://www.openvswitch.org/</a>).</p>
<h3>Using VXLAN</h3>
<p>Linux bridges, TAP, and <a id="_idIndexMarker1078"/>veth interfaces are used locally inside the Linux host to create a connection between emulated routers, but it won’t work to interconnect emulated routers that are running in a different host. There are a few techniques that could be used to connect emulated routers across hosts, such as pseudowires, L2TP, and layer 2 VPNs, among others, but the best would be VXLAN.</p>
<p>VXLAN <a id="_idIndexMarker1079"/>works as a layer 2 tunnel that extends the local bridge to another remote device, which can be another Linux host, a network switch, or a router. With VXLAN, it is also possible to connect emulated routers to real routers as if they are connected by a wire on a back-to-back connection. As we are going to see later in this section, VXLAN is going to be used for hybrid labs where a connection between real routers and emulated routers is used.</p>
<p>VLAN is a well-known protocol and was explained in <a href="B18165_02.xhtml#_idTextAnchor041"><em class="italic">Chapter 2</em></a>, Original VLANs have 12 bits of identification, which allows for up to 4,096 VLAN IDs. But VLAN tagging (IEEE 802.1Q) adds an extra 12 bits, so that’s up to 24 bits for identifying a VLAN on a normal Ethernet layer 2 frame using VLAN tagging.</p>
<p>VXLAN is<a id="_idIndexMarker1080"/> independent of VLAN or VLAN tagging, using <a id="_idIndexMarker1081"/>a header identifier with 24 bits and UDP as transport with port number <code>4789</code>. An original Ethernet frame that uses a VXLAN tunnel will need an extra 54 bytes of overhead for the tunnel. So, if your network MTU is 1,500 bytes, the maximum MTU of payload that can be carried inside the tunnel will be reduced by 54 bytes. It is recommended to increase MTU when using VXLAN. The following diagram shows an example of protocol encapsulation for VXLAN:</p>
<div><div><img alt="Figure 9.5 – VXLAN encapsulation" src="img/B18165_09_005.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – VXLAN encapsulation</p>
<p>A VXLAN connects <a id="_idIndexMarker1082"/>endpoints, known as <strong class="bold">Virtual Tunnel Endpoints</strong> (<strong class="bold">VTEPs</strong>). A device that works with VXLAN when receiving an Ethernet frame on a VTEP will then add the VXLAN header, UDP, and IP and will send it toward the other VTEP destination.</p>
<p>Now, let’s see how we would set up a hybrid lab using software connections and physical wires.</p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor219"/>Building a hybrid lab</h2>
<p>A hybrid lab <a id="_idIndexMarker1083"/>is necessary whenever you want to combine emulated routers with physical routers. The main reason you will need such a configuration is when testing the performance of a real router and adding complexity such as an extra 500 routers in the OSPF backbone. It is also useful to test connections with different complex topologies, such as an external BGP with flapping routes. All extra anomalies can be automated and added using the emulated environment, helping the test gain agility and accuracy.</p>
<p>With a<a id="_idIndexMarker1084"/> hybrid lab, you could have a few real routers connected to an unlimited number of emulated routers, perhaps building an entire network emulation that can be connected to real routers for closer production environment testing. Again, anomalies can be easily introduced automatically in the emulation, with precision, including packet loss, latency, and jitter. Therefore, your network automation skills are going to be the key to the success of a hybrid lab.</p>
<p>The following diagram shows an example of a hybrid lab connecting four emulated routers to two real routers:</p>
<div><div><img alt="Figure 9.6 – Connectivity example for a hybrid lab" src="img/B18165_09_006.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Connectivity example for a hybrid lab</p>
<p>Note that in the preceding figure, the purple lines represent the physical cables that connect Linux host 1, Linux host 2, router A, and router B to network switch 1. VXLAN is used between these devices to allow the setup of any connection between these devices. Linux host 2 uses only container-emulated routers, and therefore veth interfaces. Linux host 1 uses a tap interface to connect emulated router 2, which could be, for instance, Dynamips with a Cisco-emulated router.</p>
<p>The following<a id="_idIndexMarker1085"/> diagram shows a more complex hybrid setup:</p>
<div><div><img alt="Figure 9.7 – A more complex hybrid lab setup" src="img/B18165_09_007.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – A more complex hybrid lab setup</p>
<p>As you can see in the preceding figure, there are 3,000 emulated routers and 6 physical routers connected via VXLAN switches and software VXLAN bridges. The setup looks clean and straightforward, but it can create very complex connections and topologies. The VXLAN switches work as patch panels that can be configured by software. It is also necessary to have a real router with all interfaces connected to a VXLAN switch so that it can work as a patch panel for that router, such as router A connected to VXLAN switch 2.</p>
<p>Now, let’s discuss how we can add an OOB network.</p>
<h3>Adding an OOB network to your lab</h3>
<p>One important<a id="_idIndexMarker1086"/> problem we need to pay attention to is how<a id="_idIndexMarker1087"/> we access devices without needing to have any network connection. And the answer to this problem is to use an OOB network, or out-of-band management network, as we discussed in <a href="B18165_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>.</p>
<p>Adding some sort of access to devices that do not require any network connection helps when performing catastrophic tests, such as when routers must be removed or turned off. There are several ways to access an emulated router, which is done by accessing the host where the emulation is running. For real routers, the way to access them is via a console or auxiliary ports, which is normally performed using serial communication. Therefore, to allow automation for all devices, you will require a serial port server device that will allow remote access via IP and SSH. Once connected to the serial port server via SSH, you will be able to access the router via a serial port from the port server. One example of this port server is the product Avocent ACS8000, which has 32 serial ports and can be accessed via IP using an Ethernet port or a 4G mobile network (<a href="https://www.amazon.com/Avocent-ACS8000-Management-Cellular-ACS8032-NA-DAC-400/dp/B099XFB39R">https://www.amazon.com/Avocent-ACS8000-Management-Cellular-ACS8032-NA-DAC-400/dp/B099XFB39R</a>).</p>
<p>Now, let’s use some advanced techniques to enhance our network code testing.</p>
<h1 id="_idParaDest-219"><a id="_idTextAnchor220"/>Using advanced testing techniques</h1>
<p>I created<a id="_idIndexMarker1088"/> this section to explore some methods that can be used for testing that are not commonly used but might be somehow useful. These techniques are perhaps not used much today but might become mainstream in the future, so keep an eye on how things evolve.</p>
<p>First, let’s see how we can use time dilation in our network code testing.</p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor221"/>Using time dilation</h2>
<p>When building<a id="_idIndexMarker1089"/> your test environment, you might face <a id="_idIndexMarker1090"/>requirements for testing that are physically impossible to do in a lab with emulated routers, such as measuring protocol convergence time or sending large amounts of data between devices. The reason these high-performance tests are physically impossible using emulation is that the CPU and I/O on an emulated router are smaller and limited compared to real routers. One way to overcome this limitation is to use <strong class="bold">time dilation</strong>.</p>
<p>Time dilation<a id="_idIndexMarker1091"/> is a technique that changes the <a id="_idIndexMarker1092"/>CPU clock of the emulated environment in such a way that the emulated router will run slower compared to an emulation without time dilation. From the host’s perspective, the emulated router with time dilation will use fewer resources, as it is not running as fast as the emulated router without time dilation. But from the emulated router’s perspective, which uses time dilation, everything seems to run at normal speed, but in reality, is much slower.</p>
<p>Imagine you want<a id="_idIndexMarker1093"/> to test the time it takes for an application to copy files between two ends using network emulation. In a real network, these devices will have 10 GE interfaces that can have up to 10 Gbps. But in an emulation environment, they might have only 100 Mbps available or even less. To overcome these limitations, one technique is to put all emulations, including the application, in a time dilation environment that <a id="_idIndexMarker1094"/>has a <strong class="bold">time dilation factor</strong> (or <strong class="bold">TDF</strong>) of 1,000 or more. With a TDF of 1,000, the CPU and I/O, including network interfaces, will be capable of performing more work from the emulated network and application perspective.</p>
<p>For network testing, normally, TDF is greater than 1, but it is also possible to use one smaller than 1, meaning that the emulation will run faster than the host. The applications that use lower than 1 TDF are normally used when tests need to go faster and CPU constraints do not exist. For example, a TDF of 0.1 will run 10 times faster, but the implementation is normally not trivial and sometimes not possible because it relies on shortening the waiting time.</p>
<p>The University of San Diego has done some work on time dilation based on a paper called <em class="italic">To Infinity and Beyond: Time-Warped Network Emulation</em>, which does have some implementation code for Xen and Linux kernel. Details can be found at <a href="https://www.sysnet.ucsd.edu/projects/time-dilation">https://www.sysnet.ucsd.edu/projects/time-dilation</a>. Other implementations for time dilation focus on virtual machines and use Qemu to manipulate time; one implementation is from the University of North Carolina, where they created a project called <em class="italic">Adaptive Time Dilation</em>. Details can be found at <a href="https://research.ece.ncsu.edu/wireless/MadeInWALAN/AdaptiveTimeDilation">https://research.ece.ncsu.edu/wireless/MadeInWALAN/AdaptiveTimeDilation</a>.</p>
<p>One advantage of using time dilation is that TDF can be adjusted every time you perform a test in your environment. A low TDF will impose more CPU and I/O limitations and might be useful to test how the application and network would perform in low-performance conditions, giving a lower-bound test result. A high TDF would give enough CPU and I/O resources <a id="_idIndexMarker1095"/>to test the application and network in an ideal world without resource limitations, giving an upper-bound test result. Adjusting TDF to a certain mid value would give<a id="_idIndexMarker1096"/> you the resources compatible with a real network with a real application, giving a test result that’s closer to reality.</p>
<p>Now, let’s see how we can use monkey testing on network code testing.</p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor222"/>Using monkey testing</h2>
<p>In <a id="_idIndexMarker1097"/>software development, monkey testing is used when an application requires testing and there is no formal definition of what to test. Monkey testing<a id="_idIndexMarker1098"/> generates random inputs and evaluates the outputs.</p>
<p>The idea of <a id="_idIndexMarker1099"/>monkey testing is to find problems with the code that were not expected by the software developer. In our case, we can use monkey testing to evaluate the network automation tools and the network itself.  In some sense, penetration testing would be considered part of monkey testing, but more related to finding security holes, not failures.</p>
<p>One great example <a id="_idIndexMarker1100"/>of <a id="_idIndexMarker1101"/>monkey testing is the Netflix implementation called <strong class="bold">Chaos Monkey</strong> (there are more details at <a href="https://github.com/Netflix/chaosmonkey">https://github.com/Netflix/chaosmonkey</a>). Chaos Monkey is written in Go and used for randomly terminating containers and virtual machines. With a few modifications, it can be used to shut down interfaces and network links. It is based on chaos engineering (there are more details at <a href="http://principlesofchaos.org/">http://principlesofchaos.org/</a>). Chaos Monkey<a id="_idIndexMarker1102"/> is a good example of monkey testing that can be added to our network automation testing infrastructure.</p>
<p>Now, let’s explore how we could use <strong class="bold">artificial intelligence</strong> (<strong class="bold">AI</strong>) for network code testing.</p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor223"/>Using artificial intelligence</h2>
<p>Products that <a id="_idIndexMarker1103"/>use AI for software<a id="_idIndexMarker1104"/> development are in their early stages, but they will become reality soon. Today, it is possible to generate code via AI platforms<a id="_idIndexMarker1105"/> such as <strong class="bold">ChatGPT</strong> (there’s more at <a href="https://chat.openai.com/auth/login">https://chat.openai.com/auth/login</a>). Normally, the code generated by the AI is simple and not necessarily optimized, but it is an important milestone toward having to AI write code. The following is an example of the output of using<a id="_idIndexMarker1106"/> ChatGPT <a id="_idIndexMarker1107"/>to write unit tests:</p>
<pre class="source-code">
<strong class="bold">Question: Write a unit test for the following code:</strong>
from paramiko import SSHClient
client = SSHClient()
client.connect('10.1.1.1', username='user', password='pw')
<strong class="bold">AI: Here is the answer:</strong>
import unittest
import mock
from paramiko import SSHClient
class TestSSHClient(unittest.TestCase):
    @mock.patch('paramiko.SSHClient.connect')
    def test_connect(self, mock_connect):
        client = SSHClient()
        client.connect('10.1.1.1', username='user', password='pw')
        mock_connect.assert_called_with('10.1.1.1', username='user', password='pw')
        client.close()
if __name__ == '__main__':
    unittest.main()</pre>
<p>Note that<a id="_idIndexMarker1108"/> the question was very simple and did not specify the language or packages, such as Python or to use the <code>unittest</code> and <code>mock</code> packages. The AI figured out the language and the packages to import by itself. However, it introduced a small outdated import. Since Python 3.3, <code>mock</code> has to be imported as <code>from unittest import mock</code>, instead of <code>import mock</code>.</p>
<p>Although<a id="_idIndexMarker1109"/> the unit test written previously <a id="_idIndexMarker1110"/>was not complete and contained a small error, it is a huge step toward having computers automate tests during development. It can be used today to help developers improve their code.</p>
<p>Some commercial products are already offering AI solutions for software development. For instance, GitHub has a<a id="_idIndexMarker1111"/> product called <strong class="bold">Copilot</strong> that<a id="_idIndexMarker1112"/> offers pair programming with AI (there are more details at <a href="http://github.com/features/copilot">github.com/features/copilot</a>). Copilot claims that it can write unit tests for you, which is an amazing achievement.</p>
<p>More and more companies will start offering solutions for code development, and for sure writing unit tests will be the first milestone to be accomplished by AI platforms. Unit tests consume a lot of the developer’s time, in most cases taking even more time to write than the code itself. Keep an eye on the market for network automation test tools that use AI – it will make development more robust and faster.</p>
<p>Now, let’s see how we can add network simulation to enhance network code testing.</p>
<h2 id="_idParaDest-223"><a id="_idTextAnchor224"/>Using network simulation</h2>
<p>Network simulation, in <a id="_idIndexMarker1113"/>contrast to network emulation, uses <a id="_idIndexMarker1114"/>software to simulate part of the behavior of the network. Most network simulators are used either to simulate network protocol behaviors or to predict and calculate traffic demands and network paths. It can also be used to calculate resources, such as memory and network capacity on devices, but not much more beyond that.</p>
<p>One of the very <a id="_idIndexMarker1115"/>popular Python packages that is used for <a id="_idIndexMarker1116"/>network simulation is <strong class="bold">NetworkX</strong> (there are more details at <a href="https://networkx.org/">https://networkx.org/</a>), which is a graph manipulation library. With NetworkX, it is possible to create a large network with thousands of nodes and millions of links using much fewer resources than when using network emulation. Simulating a large network using NetworkX is possible if you wish to run several tests that will be performed much faster than using emulation. However, the tests will evaluate the behavior of the network due to link and node failures, not the control plane (routing protocols) or the operating system of the routers.</p>
<p>Another useful application<a id="_idIndexMarker1117"/> of network simulation is to test a network access list table path for a particular IP prefix. Once the network simulation has been built, it is possible to determine where a certain IP packet would flow in terms of normal and failure conditions. The<a id="_idIndexMarker1118"/> simulation must be built using the network router configuration tables, and perhaps can be updated regularly to match production. Note that this kind of test will demand the creation of a network graph for each IP prefix to be tested, and the access list for each interface will dictate the inclusion (or not) of the link in the IP prefix graph.</p>
<p>The following figure shows the topology that we are going to build using NetworkX as an example:</p>
<div><div><img alt="Figure 9.8 – Topology to be used with NetworkX" src="img/B18165_09_008.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Topology to be used with NetworkX</p>
<p>This topology is also described in the <code>Chapter09/NetworkX/topology.yaml</code> file, which is included in the GitHub repo of this book. The following code reads this file and creates a NetworkX graph with this topology:</p>
<pre class="source-code">
import networkx as nx
import yaml
G = nx.Graph()
devices = {}
with open("topology.yaml", "r") as file:
    yfile = yaml.safe_load(file)
for i, x in enumerate(yfile["devices"]):
    devices[x] = i
    G.add_node(i, name=x)
for link in yfile["links"]:
    G.add_edge(devices[link[0]], devices[link[1]])</pre>
<p>After loading <a id="_idIndexMarker1119"/>the topology, a series of tests<a id="_idIndexMarker1120"/> can be done to evaluate the behavior of the network. For instance, we could remove the link between <code>cpe-a</code> and <code>acc-a</code> and see whether there is connectivity between <code>pc-a</code> and <code>internet</code>. As the process of adding and removing edges is more interactive, the best platform to use NetworkX for testing would be a Jupyter notebook (as described in <em class="italic">Chapter 6</em>). The following screenshot shows the output of the Jupyter notebook, showing the test of removing a link and testing connectivity between <code>pc-a</code> and <code>internet</code>:</p>
<div><div><img alt="Figure 9.9 – Jupyter notebook output example" src="img/B18165_09_009.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – Jupyter notebook output example</p>
<p>As you can see, if you remove the link between <code>cpe-a</code> and <code>acc-a</code> (<code>edge 1,2</code>), <code>pc-a</code> loses connectivity to <code>internet</code>. The <code>node_connectivity()</code> method returns an <code>integer</code> that, if greater than zero, indicates there is connectivity between nodes (more details on this method and other connectivity algorithms can be found at <a href="https://networkx.org/documentation/stable/reference/algorithms/connectivity.html">https://networkx.org/documentation/stable/reference/algorithms/connectivity.html</a>). A series of additional tests can be found in the <code>Chapter09/NetworkX/example.ipynb</code> file.</p>
<p>A combination of <a id="_idIndexMarker1121"/>network simulation and network emulation can be used to increase the capacity and speed of your code testing. A mechanism must be included to build the emulation and create the simulation using the same configuration. In addition, some tests can be performed first on simulation and, if required, repeated in the emulation to be validated.</p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor225"/>Using traffic control</h2>
<p>Using <a id="_idIndexMarker1122"/>traffic shaping (or traffic control), it is<a id="_idIndexMarker1123"/> possible to add complexity to our emulation by adding some physical characteristics that are present in real links and multi-to-multi-point networks. With traffic shaping, we can add latency to specific connections, introduce packet loss, add random limitations, add network congestion, add jitter, and much more. On Linux, it can be easily obtained by using the built-in <code>tc</code> command.</p>
<p>TC is implemented in Linux by using schedulers<a id="_idIndexMarker1125"/> or <code>tc</code> and qdiscs can be found at <a href="https://tldp.org/HOWTO/Traffic-Control-HOWTO">https://tldp.org/HOWTO/Traffic-Control-HOWTO</a>).</p>
<p>The following is an example of using a <code>qdisc</code> called <code>netem</code> to add 10 ms of latency to the loopback interface:</p>
<pre class="source-code">
$ sudo fping -q -c 100 -p 100 localhost
localhost : xmt/rcv/%loss = 100/100/0%, min/avg/max = 0.030/0.044/0.069
$ sudo tc qdisc add dev lo root netem delay <strong class="bold">10ms</strong>
$ sudo fping -q -c 100 -p 100 localhost
localhost : xmt/rcv/%loss = 100/100/0%, min/avg/max = 20.4/<strong class="bold">21.4</strong>/24.8</pre>
<p>This example adds 10 ms to reach the <code>lo</code> interface in each way, so the round-trip time is double, which appears in the results as a 21.4 ms average.</p>
<p>Here is <a id="_idIndexMarker1126"/>another example, showing how to add 5% packet loss using <code>netem</code>:</p>
<pre class="source-code">
$ sudo fping -q -c 100 -p 100 localhost
localhost : xmt/rcv/%loss = 100/100/0%, min/avg/max = 0.031/0.044/0.101
$ sudo tc qdisc add dev lo root netem loss 5%
$ sudo fping -q -c 100 -p 100 localhost
localhost : xmt/rcv/%loss = 100/96/<strong class="bold">4%</strong>, min/avg/max = 0.032/0.056/0.197</pre>
<p>In this<a id="_idIndexMarker1127"/> test example, the result was 4% of packet loss instead of 5% as configured. This is because <code>netem</code> uses random selection to obtain packet loss, and it will require a larger testing sample to get closer to 5% – for example, 1,000 packets instead of 100, which was used in the preceding test.</p>
<p>Other more complex network behaviors can be added to the<a id="_idIndexMarker1128"/> interface using <code>netem</code>, such as burst control, maximum capacity, network congestion, and random latency variance, among others. More details<a id="_idIndexMarker1129"/> on it can be found at <a href="https://wiki.linuxfoundation.org/networking/netem">https://wiki.linuxfoundation.org/networking/netem</a>.</p>
<p>There are lots of other schedulers besides <code>netem</code>, such as <code>choke</code>,  <code>codel</code>, <code>hhf</code>, and <code>ATM</code>. A list of all classless and classful qdiscs available can be obtained on the <code>tc</code> man page, which can be visualized by just typing <code>man tc</code> (the HTML version can be found at <a href="https://manpages.debian.org/buster/iproute2/tc.8.en.html">https://manpages.debian.org/buster/iproute2/tc.8.en.html</a>).</p>
<p>Hopefully, you have got the most out of this section and have started wondering whether some of these advanced techniques could be added to your project. Adding one of these techniques will likely make your project more reliable and closer to a real production environment.</p>
<h1 id="_idParaDest-225"><a id="_idTextAnchor226"/>Summary</h1>
<p>The goal of this chapter was to introduce you to how to build and use a proper infrastructure to test your automation code using software. You learned how software can be used to effectively test your automation code, how to use simulation and emulation, how to connect real and emulated devices, and finally, how advanced techniques can be incorporated.</p>
<p>Adding some of the techniques described in this chapter will add superpowers to your network automation code project. From now on, it will be unbeatable.</p>
<p>In the next chapter, we are going to get hands-on in a network lab and wrap up this book with a few additional remarks.</p>
</div>
</body></html>