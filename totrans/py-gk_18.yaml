- en: '*Chapter 14*: Using Python for Network Automation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, networks are built and operated by network experts, and this
    is still a trend in the telecom industry. However, this manual approach of managing
    and operating a network is slow and sometimes results in costly network outages
    due to human mistakes. Additionally, to obtain a new service (such as an internet
    service), customers have to wait for days after placing a request for a new service
    before it's ready. Based on the experience of smartphones and mobile applications,
    where you can enable new services and applications with a click of a button, customers
    expect network service readiness in minutes, if not seconds. This is not possible
    with the current approach to network management. The traditional approaches are
    also sometimes a roadblock in introducing new products and services by the telecom
    service providers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Network automation** can improve these situations by offering software for
    automating the management as well as operational aspects of a network. Network
    automation helps eliminate human errors in configuring network devices and reduce
    operational costs significantly by automating repetitive tasks. Network automation
    helps accelerate service delivery and enables telecom service providers to introduce
    new services.'
  prefs: []
  type: TYPE_NORMAL
- en: Python is a popular choice for network automation. In this chapter, we will
    discover Python capabilities for network automation. Python provides libraries
    such as **Paramiko**, **Netmiko**, and **NAPALM** that can be used to interact
    with network devices. If the network devices are managed by a **Network Management
    System** (**NMS**) or a network controller/orchestrator, Python can interact with
    these platforms using the **REST** or **RESTCONF** protocols. End-to-end network
    automation is not possible without listening to real-time events happening in
    the network. These real-time network events or real-time streaming data is typically
    available through systems such as **Apache Kafka**. We will also explore interaction
    with an event-driven system using Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing network automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with network devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating with network management systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with event-based systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After completing this chapter, you will understand how to use Python libraries
    to fetch data from a network device and to push configurational data to these
    devices. These are foundational steps for any network automation process.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the technical requirements for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to have Python 3.7 or later installed on your computer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to install Paramiko, Netmiko, NAPALM, ncclient, and the requests libraries
    on top of Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to have access to one or more network devices with the SSH protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to have access to a Nokia developer lab to be able to access Nokia's
    NMS (known as **Network Services Platform** (**NSP**)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sample code for this chapter can be found at [https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter14](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter14).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will need access to physical or virtual network devices
    and network management systems to execute the code examples. This may not be possible
    for everyone. You can use any network device with similar capabilities. We will
    focus more on the Python side of the implementation and make it convenient to
    reuse the code for any other device or management system.
  prefs: []
  type: TYPE_NORMAL
- en: We will start our discussion by providing an introduction to network automation.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing network automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network automation is the use of technology and software to automate the processes
    of managing and operationalizing networks. The keyword for network automation
    is *automating a process*, which means it is not only about deploying and configuring
    a network but also the steps that must be followed to achieve network automation.
    For example, sometimes, the automation steps involve gaining approval from different
    stakeholders before a configuration is pushed to a network. Automating such an
    approval step is part of network automation. Therefore, the network automation
    process can vary from one organization to another based on the internal processes
    each organization follows. This makes it challenging to build a single platform
    that can perform automation out of the box for many customers.
  prefs: []
  type: TYPE_NORMAL
- en: There are a significant number of ongoing efforts to provide the necessary platforms
    from the network device vendors that can help in building customized automation
    with minimal effort. A few examples of such platforms are Cisco **Network Services
    Orchestrator** (**NSO**), the **Paragon Automation** platform from Juniper Networks,
    and **NSP** from Nokia.
  prefs: []
  type: TYPE_NORMAL
- en: One of the challenges with these automation platforms is that they are typically
    vendor locked. This means that the vendors claim that their platform can manage
    and automate other vendors' network devices as well, but the process to achieve
    multi-vendor automation is tedious and costly. Therefore, telecom service providers
    are looking beyond the vendor's platforms for automation. **Python** and **Ansible**
    are two popular programming languages that are used for automation in the telecom
    industry. Before we jump into how Python achieves network automation, let's explore
    a few merits and challenges of network automation.
  prefs: []
  type: TYPE_NORMAL
- en: Merits and challenges of network automation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have highlighted a few merits of network automation already. We can summarize
    the key merits as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Expedite service delivery**: Faster service delivery to new customers enables
    you to start the service billing early and have more satisfied customers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reducing operational costs**: The operational costs of a network can be reduced
    by automating repetitive tasks and monitoring the network through tools and closed-loop
    automation platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eliminate humor errors**: The majority of network outages are because of
    human errors. Network automation can eliminate this cause by configuring the networks
    using standard templates. These templates are deeply evaluated and tested before
    being put into production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistent network setup**: When humans are configuring a network, it is
    impossible to follow consistent templates and naming conventions, which are important
    for the operations team to manage the network. Network automation brings consistency
    in setting up the network as we configure the network every time using the same
    script or template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network visibility**: With network automation tools and platforms, we can
    have access to performance monitoring capabilities and can visualize our network
    from end to end. Proactive network management is possible by detecting traffic
    spikes and heavy resources utilization before they cause bottlenecks for the network
    traffic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Network automation is a must for digital transformation, but there are some
    costs and challenges to achieve it. These challenges are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cost**: There is always a cost when it comes to building or customizing the
    software for network automation. Network automation is a journey and a cost budget
    must be set for it on an annual basis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Human resistance**: In many organizations, human resources consider network
    automation as a threat to their jobs, so they resist adopting network automation,
    especially within operation teams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Organizational structure**: Network automation brings a real **return on
    investment** (**ROI**) when it is used across different network layers and network
    domains such as IT and network domains. The challenge in many organizations is
    that these domains are owned by different departments and each has their own automation
    strategies and preferences regarding automation platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selecting an automation platform/tool**: Selecting an automation platform
    from network equipment vendors such as Cisco or Nokia, or working with third-party
    automation platforms such as HP or Accenture, is not an easy decision. In many
    cases, the telecom service providers end up with multiple vendors for building
    their network automation, and this brings a new set of challenges to make these
    vendors work together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintenance**: Maintaining automation tools and scripts is as essential as
    building them. This requires either buying essential maintenance contracts from
    automation vendors or setting an internal team to provide maintenance for such
    automation platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we look at the use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Several monotonous tasks regarding network management can be automated using
    Python or other tools. But the real benefits are to automate those tasks that
    are repetitive, error-prone, or tedious if done manually. From a telecom service
    provider''s point of view, the following are the main applications of network
    automation:'
  prefs: []
  type: TYPE_NORMAL
- en: We can automate the day-to-day configuration of network devices, such as creating
    new IP interfaces and network connectivity services. It is time-consuming to do
    these tasks manually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can configure firewall rules and policies to save time. Creating firewall
    rule configurations is a tedious activity, and any mistakes can result in wasting
    time in troubleshooting the communication challenges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we have thousands of devices in a network, upgrading their software is
    a big challenge and sometimes, it takes 1 to 2 years to achieve this. Network
    automation can expedite this activity and enforce pre- and post-upgrade checks
    conveniently for seamless upgrades.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use network automation to onboard new network devices in the network.
    If the device is to be installed on a customer's premises, we can save a truck
    roll by automating the device's onboarding process. This onboarding process is
    also known as **zero touch provisioning** (**ZTP**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've introduced network automation, let's explore how to interact
    with network devices using different protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with network devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is a popular choice for network automation because it is easy to learn
    and can be used to integrate with network devices directly, as well as through
    NMS. In fact, many vendors, such as Nokia and Cisco, support Python runtimes on
    their network devices. The option of on-device Python runtimes is useful for automating
    tasks and activities in the context of a single device. In this section, we will
    focus on the off-device Python runtime option. This option will give us the flexibility
    to work with multiple devices at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: For all the code examples provided in this section, we will use a virtual network
    device from Cisco (IOS XR with release 7.1.2). For integration with the NMS we
    will use the Nokia NSP system.
  prefs: []
  type: TYPE_NORMAL
- en: Before working with Python so that we can interact with network devices, we
    will discuss the protocols that are available for communicating with network devices.
  prefs: []
  type: TYPE_NORMAL
- en: Protocols for interacting with network devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to talking to network devices directly, there are several protocols
    we can use, such as **Secure Shell Protocol** (**SSH**), **Simple Network Management
    Protocol** (**SNMP**), and **Network Configuration** (**NETCONF**). Some of these
    protocols work on top of each other. The most commonly used protocols will be
    described next.
  prefs: []
  type: TYPE_NORMAL
- en: SSH
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SSH is a network protocol for communicating between any two devices or computers
    securely. All the information between the two entities will be encrypted before
    it''s sent to a transport channel. We typically use an SSH client to connect to
    a network device using the `ssh` command. The SSH client uses the *username* of
    the logged-in operating system user with the `ssh` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To use a different user other than the logged-in user, we can specify the *username*,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once an SSH connection has been established, we can send CLI commands either
    to retrieve configuration or operational information from a device or to configure
    the device. **SSH version 2** (**SSHv2**) is a popular choice for interacting
    with devices for network management and even for automation purposes.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss how to use the SSH protocol with Python libraries such as Paramiko,
    Netmiko, and NAPALM in the *Interacting with network devices using SSH-based protocols*
    section. SSH is also a foundational transport protocol for many advanced network
    management protocols, such as NETCONF.
  prefs: []
  type: TYPE_NORMAL
- en: SNMP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This protocol has been a de facto standard for network management for 30+ years
    and it is still used heavily for network management. However, it is being replaced
    by more advanced and scalable protocols such as NETCONF and gNMI. SNMP can be
    used both for network configuration and for network monitoring, but it is more
    popular for network monitoring. In today's world, it is considered a legacy protocol
    that was introduced in the late 1980s, purely for network management.
  prefs: []
  type: TYPE_NORMAL
- en: The SNMP protocol relies on **Management Information Base** (**MIB**), which
    is a device model. This model was built using a data modeling language called
    **Structure of Management Information** (**SMI**).
  prefs: []
  type: TYPE_NORMAL
- en: NETCONF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The NETCONF protocol, which was introduced by the **Internet Engineering Task
    Force** (**IETF**), is considered a successor of SNMP. NETCONF is primarily used
    for configuring network devices and is expected to be supported by all new network
    devices. NETCONF is based on four layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Content**: This is a data layer that relies on YANG modeling. Every device
    offers several YANG models for various modules it offers. These models can be
    explored at [https://github.com/YangModels/yang](https://github.com/YangModels/yang).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get`, `get-config`, `edit-config`, and `delete-config`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Messages**: These are **Remote Procedure Call** (**RPC**) messages that are
    exchanged between the NETCONF clients and NETCONF Agent. NETCONF operations and
    data that''s encoded as XML are wrapped within the RPC messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transport**: This layer provides a communication path between a client and
    a server. NETCONF messages can use NETCONF over SSH or NETCONF over TLS with the
    SSL certificate option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The NETCONF protocol is based on XML messages that have been exchanged via the
    SSH protocol using port `830` as the default port. There are typically two types
    of configuration databases that are managed by network devices. The first type
    is called the **running** database, which represents the active configuration
    on a device, including operation data. This is a mandatory database for each device.
    The second type is known as the **candidate** database, which represents the candidate
    configuration before it can be pushed to the running database. When a candidate
    database exists, configuration changes are not allowed to be made directly to
    the running database.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss how to work with NETCONF using Python in the *Interacting with
    network devices using NETCONF* section.
  prefs: []
  type: TYPE_NORMAL
- en: RESTCONF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: RESTCONF is another *IETF* standard that offers a subset of NETCONF functionality
    using the RESTful interface. Instead of using NETCONF RPC calls with XML encoding,
    RESTCONF offers HTTP/HTTPS-based REST calls, with the option of using XML or JSON
    messages. If network devices offer the RESTCONF interface, we can use HTTP methods
    (`GET`, `PATCH`, `PUT`, `POST`, and `DELETE`) for network management. When RESTCONF
    is used for network automation, we must understand that it provides a limited
    NETCONF functionality over HTTP/HTTPS. NETCONF operations such as commits, rollbacks,
    and configuration locking are not supported through RESTCONF.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC/gNMI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: gNMI is a gRPC **Network Management Interface** (**NMI**). gRPC is a remote
    procedure call that was developed by Google for low-latency and highly scalable
    data retrieval. The gRPC protocol was developed originally for mobile clients
    that wanted to communicate with cloud servers with stringent latency requirements.
    The gRPC protocol is highly efficient for transporting structured data through
    **protocol buffers** (**Protobufs**), which is a key component of this protocol.
    By using Protobufs, the data is packed in a binary format instead of a textual
    format such as JSON or XML. This format not only reduces the size of the data
    but is very efficient for serializing and deserializing data compared to JSON
    or XML. Moreover, the data is transported using HTTP/2 instead of HTTP 1.1\. HTTP/2
    offers both the request-response model and the bidirectional communication model.
    This bidirectional communication model makes it possible for clients to open long-lived
    connections that speed up the data transfer process significantly. These two technologies
    make the gRPC protocol *7 to 10* times faster than the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: gNMI is a specific implementation of the gRPC protocol for network management
    purposes and telemetry applications. It is also a YANG model-driven protocol like
    NETCONF and offers very few operations compared to NETCONF. These operations include
    `Get`, `Set`, and `Subscribe`. gNMI is getting more popular for telemetry data
    collection than for network management. The main reason for this is that it does
    not provide as much flexibility as NETCONG for network configuration, but it is
    an optimized protocol when it comes to collecting data from a remote system, especially
    in real time or near-real time.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss Python libraries for interacting with network devices.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with network devices using SSH-based Python libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several Python libraries available for interacting with network devices
    using SSH. Paramiko, Netmiko, and NAPALM are three popular libraries that are
    available, and we will explore them in the next subsections. We will start with
    Paramiko.
  prefs: []
  type: TYPE_NORMAL
- en: Paramiko
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Paramiko library is an abstraction of the SSH v2 protocol in Python and
    includes both server-side and client-side functionality. We will only focus on
    the client-side capabilities of the Paramiko library here.
  prefs: []
  type: TYPE_NORMAL
- en: When we interact with a network device, we either try to get configuration data,
    or we push a new configuration for certain objects. The former is achieved with
    *show* types of CLI commands, as per the operating system of the device, while
    the latter may require a special mode for executing the configuration CLI commands.
    These two types of commands are handled differently when working through Python
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching device configuration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To connect to a network device (listening as an SSH server) using the Paramiko
    library, we must use an instance of the `paramiko.SSHClient` class or directly
    use a low-level `paramiko.Transport` class. The `Transport` class offers low-level
    methods that provide direct control over sockets-based communication. The `SSHClient`
    class is a wrapper class and uses the `Transport` class under the hood to manage
    a session, with an SSH server implemented on a network device.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the Paramiko library to establish a connection with a network device
    (Cisco IOS XR, in our case) and to run a show command (`show ip int brief`, in
    our case) like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The key points of this code example are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We created an `SSHClient` instance and opened a connection with the SSH server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we are not using the host key for our SSH connection, we applied the `set_missing_host_key_policy`
    method to avoid any warnings or errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the SSH connection had been established, we sent our show command, `show
    ip int brief`, to the host machine using SSH transport and received the output
    of the command as an SSH reply.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output of this program is a tuple of `stdin`, `stdout`, and `stderr` objects.
    If our command is executed successfully, we will retrieve the output from the
    `stdout` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output of this program, when executed on a Cisco IOS XR device, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you are running this program on another device type, you must change the
    command that has been set as the `cmd` variable, as per your device's type.
  prefs: []
  type: TYPE_NORMAL
- en: The Paramiko library provides low-level control over network communication,
    but it can sometimes be quirky due to the non-standard or incomplete implementation
    of the SSH protocol by many network devices. If you face challenges in using Paramiko
    with some network devices, it is not you or Paramiko but the way the device expects
    you to communicate with it. A low-level transport channel can solve these issues,
    but this requires a bit of complex programming. Netmiko comes to the rescue here.
  prefs: []
  type: TYPE_NORMAL
- en: Netmiko
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Netmiko is an abstracted library for network management that is built on top
    of the Paramiko library. It eliminates the challenges of Paramiko by treating
    every network device differently. Netmiko uses Paramiko under the hood and hides
    many device-level communication details. Netmiko supports several devices from
    different vendors, such as Cisco, Arista, Juniper, and Nokia.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching device configuration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To connect to a network device using the show type of CLI commands, we must
    set a `device_type` definition that is used to connect with the target network
    device. This `device_type` definition is a dictionary that must include the device''s
    type, the host IP or the device''s `22`. The following code can be used to execute
    the same `show` command that we executed with the Paramiko library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The key points of this example code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a network connection using the `ConnectHandler` class using a context
    manager. The context manager will manage the life cycle of the connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Netmiko offers a simple method called `find_prompt` for grabbing the prompt
    of the target device, which is useful for parsing the output of many network devices.
    This is not required for the *Cisco IOS XR* network device but we used it as a
    best practice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Netmiko also allows us to enter *Enable* mode (it is a command-line prompt,
    `#`) for Cisco IOS devices by using the `enable` method. Again, this is not required
    for this example, but it is a best practice to use it, especially in cases where
    we are pushing CLI commands for configuration as part of the same programming
    script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We executed the `show ip int brief` command using the `send_command` method
    and got the same output that we did for the `show_cisco_int_pmk.py` program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the code example we shared for the same `show` command, we can conclude
    that working with Netmiko is much more convenient compared to Paramiko.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to set the correct device type for consistent results,
    even if you are using devices from the same vendor. This is especially important
    when using commands for configuring a device. An incorrect device type can give
    inconsistent errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we execute commands that require more time to complete than normal
    `show` commands. For example, we may want to copy a file from one location to
    the other on a device, and we know this can take a few hundred seconds for a large
    file. By default, Netmiko waits nearly *100* seconds for a command to complete.
    We can add a global delay factor as part of the device definition by adding a
    line like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will increase the wait time for all the commands for this device by a
    factor of 2\. Alternatively, we can set the delay factor for an individual command
    with the `send_command` method by passing the following argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We should be adding a delay factor when we expect a significant execution time.
    When we have to add a delay factor, we should also be adding another attribute
    as an argument with the `send_command` method, which will break the wait cycle
    early if we see a command prompt (for example, `#` in the case of Cisco IOS devices).
    This can be set by using the following attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Configuring a network device
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the following code example, we will provide some sample code for configuration
    purposes. Configuring a device using Netmiko is similar to executing `show` commands
    as Netmiko will take care of enabling the configuration terminal (if required,
    as per the device type) and exiting out of the configuration terminal gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our code example, we will set a `description` of an interface using Netmiko
    with the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The key points of this code example are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For this program, we created a list of three commands (`int <interface id>`,
    `description <new description>`, and `commit`). The first two commands can be
    sent as a single command as well, but we have kept them separate for illustration
    purposes. The `commit` command is used to save changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we send a command to the device for configuration, we use the `send_config_set`
    method from the Netmiko library to set up a connection for configuration purposes.
    Successfully executing this step depends on the correct setting of the device
    type. This is because the device behavior varies from one device to the other
    for the configuration commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The set of three commands will add or update the `description` attribute for
    the specified interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No special output will be expected from this program, except that the device
    config prompts with our commands. The console output will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Netmiko offers a lot more functionality, but we will leave this for you to explore
    by reading its official documentation ([https://pypi.org/project/netmiko/](https://pypi.org/project/netmiko/)).
    The code examples we've discussed in this section have been tested with a Cisco
    network device, but the same program can be used by changing the device type and
    the commands for any other device if the device is supported by Netmiko.
  prefs: []
  type: TYPE_NORMAL
- en: Netmiko simplifies our code for network device interaction, but we are still
    running the CLI commands for fetching the device configuration or pushing the
    configuration toward the device. Programmability is not easily to do with Netmiko,
    but another library called NAPALM is there to help.
  prefs: []
  type: TYPE_NORMAL
- en: NAPALM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**NAPALM** is an acronym for **Network Automation and Programmability Abstraction
    Layer with Multivendor**. This library provides the next level of abstraction
    on top of Netmiko by offering a set of functions as a unified API to interact
    with several network devices. It does not support as many devices as Netmiko.
    For release 3 of NAPALM, core drivers are available for the **Arista EOS**, **Cisco
    IOS**, **Cisco IOS-XR**, **Cisco NX-OS**, and **Juniper JunOS** network devices.
    However, there are several community-built drivers available for communicating
    with many other devices, such as **Nokia SROS**, **Aruba AOS-CX**, and **Ciena
    SAOS**.'
  prefs: []
  type: TYPE_NORMAL
- en: As we did for Netmiko, we will build NAPALM examples for interacting with a
    network device. In the first example, we will get a list of IP interfaces, while
    for the second example, we will add or update the `description` attribute for
    an IP interface. These two code examples will perform the same operations that
    we performed using the Paramiko and Netmiko libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching device configuration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To fetch a device configuration, we must set up the connection to our network
    device. We will do this in both code examples. Setting up a connection is a three-step
    process, as explained here:'
  prefs: []
  type: TYPE_NORMAL
- en: To set up a connection, we must get a device driver class based on the supported
    device type. This can be achieved using the `get_network_driver` function of the
    NAPALM library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we have a device driver class, we can create a device object by providing
    arguments such as `host id`, `username`, and `password` to the driver class constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is to connect to the device using the `open` method of the device
    object. All these steps can be implemented as Python code, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the device''s connection is available, we can call methods such as `get_interfaces_ip`
    (equivalent to the `show interfaces` CLI command) or `get_facts` (equivalent to
    the `show version` CLI command). The complete code for using these two methods
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The most interesting fact is that the output of this program is in JSON format
    by default. NAPALM converts the CLI command''s output into a dictionary by default
    that is easy to consume in Python. An excerpt of the output for the previous code
    example is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Configuring a network device
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the following code example, we are using the NAPALM library to add or update
    the `description` attribute for an existing IP interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The key points of this code example are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To configure the IP interface, we must use the `load_merge_candidate` method
    and pass the same set of CLI commands to this method as we did for the interface
    configuration with Netmiko.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we compared the configs before our commands and after the commands using
    the `compare_config` method. This indicates what new configuration has been added
    and what has been removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We applied a commit to all the changes using the `commit_config` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this example code, the output will show the delta of changes, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, the line that starts with `-` is a configuration to be removed; any line
    with `+` at the start is a new configuration to be added.
  prefs: []
  type: TYPE_NORMAL
- en: With these two code examples, we have showed you a basic set of NAPALM features
    for one device type. The library can be used to configure multiple devices at
    a time and can work with different sets of configurations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss interacting with network devices using
    the NETCONF protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with network devices using NETCONF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NETCONF was created for model (object)-driven network management, especially
    for network configuration. When working with a network device using NETCONF, it
    is important to understand two capabilities of the device, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can understand the YANG models of the devices you have. Having this knowledge
    is important if you wish to send the messages in the correct format. Here is an
    excellent source of YANG models from various vendors: [https://github.com/YangModels/yang](https://github.com/YangModels/yang).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can enable the NETCONF and SSH ports for the NETCONF protocol on the network
    device for your network device. In our case, we will be using a virtual device
    from Cisco IOS XR, as we did in our previous code examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before starting any network management-related activity, we must check the
    device''s NETCONF capabilities and the details of the NETCONF data source''s configuration.
    For all the code examples in this section, we will use a NETCONF client library
    for Python known as `ncclient`. This library provides convenient methods for sending
    NETCONF RPC requests. We can write a sample Python program using the `ncclient`
    library to get the device''s capabilities and the device''s full configuration,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `manager` object from the `ncclient` library is used to connect to the device
    using SSH but for NETCONF port `830` (default). First, we get a list of server
    capabilities through the connection instance and then print them in a sorted format
    for the convenience of reading. In the next part of this code example, we initiated
    a `get-config` NETCONF operation by using the `get_config` method of the `manager`
    class library. The output of this program is very long and displays all the capabilities
    and the device configuration. We leave it to you to explore the output and become
    familiar with your device's capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to understand that the scope of this section is not to explain
    NETCONF but to learn how to use Python and `ncclient` to work with NETCONF. To
    achieve this goal, we will write two code examples: one for fetching the configuration
    of device interfaces and another on how to update the description of an interface,
    which is the same as what we did for the previous Python libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting interfaces via NETCONF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we learned that our device (Cisco IOS XR) supports
    interfaces by using the **OpenConfig** implementation, which is available at [http://openconfig.net/yang/interfaces?module=openconfig-interfaces](http://openconfig.net/yang/interfaces?module=openconfig-interfaces).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also check the XML format of our interface''s configuration, which we
    received as the output of the `get_config` method. In this code example, we will
    simply pass an XML filter with interface configuration as an argument to the `get_config`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this program is a list of interfaces. We will only show an excerpt
    of the output here for illustration purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To get a selective set of interfaces, we will use an extended version of the
    XML filter based on the interface''s YANG model. For the following code example,
    we will define an XML filter with the `name` properties of the interfaces as our
    filtering criteria. Since this XML filter is more than one line, we will define
    it separately as a string object. Here is the sample code with the XML filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this program will be a single interface (as per the configuration
    in our device) and look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can define XML filters in an XML file as well and then read the file's contents
    into a string object in the Python program. Another option is to use *Jinja* templates
    if we are planning to use filters extensively.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss how to update an interface's description.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the interface's description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To configure an interface attribute such as `description`, we must use the YANG
    model available at [http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg](http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg).
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, the XML block for configuring an interface is different than the
    XML block we used for getting the interface''s configuration. For updating an
    interface, we must use the following template, which we have defined in a separate
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this template, we set the placeholders for the `name` and `description`
    properties of the interface. Next, we will write a Python program that will read
    this template and call the `edit-config` NETCONF operation by using the `edit_config`
    method of the `ncclient` library. This will push the template to the candidate
    database of the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to highlight two things here. First, the Cisco IOS XR device
    has been configured to only accept the new configuration through the candidate
    database. If we try to set the `target` attribute to `running`, it will fail.
    Second, we must call the `commit` method after the `edit-config` operation in
    the same session to make the new configuration operational. The output of this
    program will be two OK replies from the NETCONF server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This concludes our discussion of using Python for NETCONF operations. We covered
    two main operations (`get-config` and `edit-config`) of NETCONF with the `ncclient`
    library.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at integrating with network management systems
    using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with network management systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network management systems or network controllers are systems that offer network
    management applications with **graphical user interfaces** (**GUIs**). These systems
    include applications such as network inventory, network provisioning, fault management,
    and mediation with network devices. These systems communicate with network devices
    using a combination of communication protocols such as SSH/NETCONF for network
    provisioning, SNMP for alarms and device monitoring, and gRPC for telemetry data
    collection. These systems also offer automation capabilities through their scripting
    and workflow engines.
  prefs: []
  type: TYPE_NORMAL
- en: The most value-added aspect of these systems is that they aggregate the network
    device's functionality into a single system (itself) and then offer it through
    its **North Bound Interfaces** (**NBIs**), which are typically REST or RESTCONF
    interfaces. These systems also offer notifications of real-time events such as
    alarms through an event-based system such as Apache Kafka. In this section, we
    will discuss a couple of examples of using the REST API of a NMS We will explore
    how to integrate with Apache Kafka using Python in *Integrating with event driven
    systems* section.
  prefs: []
  type: TYPE_NORMAL
- en: To work with a NMS we will use a shared lab offered by Nokia's online developer
    portal ([https://network.developer.nokia.com/](https://network.developer.nokia.com/)).
    This lab has a few Nokia IP routers and an NSP. This shared lab is offered free
    of charge for a limited time (3 hours per day at the time of writing this book).
    You will be required to create an account with the developer portal free of charge.
    When you book a lab for use, you will receive an email with instructions on how
    to connect to the lab, along with the necessary VPN details. If you are a network
    engineer and you have access to any other NMS or a controller, you can use that
    system for the exercises in this section by making the appropriate adjustments.
  prefs: []
  type: TYPE_NORMAL
- en: To consume a REST API from Nokia NSP, we need to interact with the REST API
    Gateway, which manages several API endpoints for Nokia NSP. We can start working
    with the REST API Gateway by using location services, as explained next.
  prefs: []
  type: TYPE_NORMAL
- en: Using location services endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand what API endpoints are available, Nokia NSP offers a location
    services endpoint that provides a list of all API endpoints. To consume any REST
    API in this section, we will use the `requests` library from Python. The `requests`
    library is well-known for sending HTML requests to a server using the HTTP protocol,
    and we have used it in previous chapters. To get a list of API endpoints from
    the Nokia NSP system, we will use the following Python code to invoke a location
    services API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This API response will provide you with a few dozen API endpoints in JSON format.
    You can check the online documentation of Nokia NSP at [https://network.developer.nokia.com/api-documentation/](https://network.developer.nokia.com/api-documentation/)
    to understand how each API works. If we are looking for a specific API endpoint,
    we can change the value of the `url` variable in the aforementioned code example,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'By using this new API URL, we are trying to find an API endpoint for the authorization
    token (`/v1/auth/token`). The output of the code example with this new URL is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note that no authentication is required to use the location services API. However,
    we will need an authentication token to call any other API. In the next section,
    we will learn how to get an authentication token.
  prefs: []
  type: TYPE_NORMAL
- en: Getting an authentication token
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a next step, we will use `effectiveUrl` from the output of the previous
    code example to get the authentication token. This API requires that we pass the
    *base64* encoding of `username` and `password` as the `Authorization` attribute
    of the HTTP header. The Python code to call this authentication API is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a refresh token available that can be used to refresh the token
    before it expires. A best practice is to refresh your token every *30* minutes.
    We can refresh our token using the same authentication token API, but send the
    following attributes in the body of the HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Another good practice is to revoke the token when there is no further need
    for it. This can be achieved by using the following API endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Getting network devices and an interface inventory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we have received the authentication token, we can use the REST API to
    get configured data, as well as to add a new configuration. We will start with
    a simple code example that will get a list of all the network devices in a network
    that is managed by NSP. In this code example, we will use the token we have already
    retrieved using the token API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The output of this program will be a list of network devices with network device
    attributes. We skipped showing the output due to this being a large set of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code example, we will show how to get a list of device ports
    (interfaces) based on a filter. Note that we can apply filters to network devices
    as well. For this code example, we will ask the NSP API to give us a list of ports
    based on the port name (`Port 1/1/1`, in our case):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The output of this program will be a list of device ports called `Port 1/1/1`
    from all network devices. Getting ports across multiple network devices with a
    single API is the real value of working with a NMS
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss how to update a network resource using the NMS API.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the network device port
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating new objects or updating existing objects is also convenient when using
    the NMS API. We will implement a case of updating the port description, as we
    did in previous code examples, using `Netmiko`, `NAPALM`, and `ncclient`. To update
    a port or interface, we will use a different API endpoint that is available from
    the **Network Function Manager for Packet** (**NFMP**) module. NFMP is an NMS
    module for Nokia network devices under the Nokia NSP platform. Let''s look at
    the steps of updating a port description or making any change to a network resource:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To update an object or create a new object under an existing object, we will
    need the `v1/managedobjects/searchWithFilter` API with the following filter criteria:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will use a different API endpoint called `v1/managedobjects/ofn` to
    update an attribute of the network object. In our case, we are only updating the
    description attribute. For the update operation, we must set the `fullClassName`
    attribute in the payload and a new value for the description attribute. For the
    API endpoint''s URL, we will concatenate the `port_ofn` variable that we computed
    in the previous step. The sample code for this part of the program is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Network automation is the process of creating and updating many network objects
    in a specific order. For example, we can update a port before creating an IP connectivity
    service to connect two or more local area networks. This type of use case requires
    that we perform a series of tasks to update all the ports involved, as well as
    many other objects. With the NMS API, we can orchestrate all these tasks in a
    program to implement an automated process.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore how to integrate with Nokia NSP or similar
    systems for event-driven communication.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with event-driven systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we discussed how to interact with network devices
    and network management systems using the request-response model. In this model,
    a client sends a request to a server and the server sends a response as a reply
    to the request. The HTTP (REST API) and SSH protocols are based on a request-response-based
    model. This model works well for configuring a system or getting the operational
    state of the network on an ad hoc basis or periodically. But what about if something
    happens in the network that requires the operation team's attention? For example,
    let's say a hardware failure on a device or a line cable has been cut. Network
    devices typically raise alarms in such situations, and these alarms have to reach
    the operator (via an email, an SMS, or a dashboard) immediately.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the request-response model to poll the network device every second
    (or every few seconds) to check if there has been any change in the state of a
    network device or if there is a new alarm. However, this is not an efficient use
    of the network device's resources and will contribute to unnecessary traffic in
    the network. What about if the network device or NMS itself reaches out to the
    interested clients whenever there is a change in the state of critical resources,
    or an alarm is raised? This type of model is called an *event-driven* model, and
    it is a popular communication approach for sending real-time events.
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven systems can be implemented either using **webhooks**/**WebSockets**
    or using the **streaming** approach. WebSockets offers a bidirectional transport
    channel over HTTP 1.1 through a TCP/IP socket. Since this bidirectional connection
    is not using the traditional request-response model, WebSockets is an efficient
    approach when we want to establish a one-to-one connection between the two systems.
    This is one of the best options when we need real-time communication between the
    two programs. WebSockets are supported by all standard browsers, including the
    one that's available with iPhone and Android devices. It is also a popular choice
    for many social media platforms, streaming applications, and online gaming.
  prefs: []
  type: TYPE_NORMAL
- en: 'WebSockets is a lightweight solution for getting real-time events. But when
    many clients are looking to receive events from one system, using a streaming
    approach is scalable and efficient. The streaming event-based model typically
    follows a publisher-subscriber design pattern and has three main components, as
    described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Topic**: All streaming messages or event notifications are stored under a
    topic. We can think of a topic as a directory. This topic helps us subscribe to
    topics of interest to help us avoid receiving all events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Producer**: This is a program or piece of software that pushes the events
    or messages to a topic. This is also called the **publisher**. In our case, it
    will be an NSP application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consumer**: This is a program that fetches the events or messages from a
    topic. This is also called a **subscriber**. In our case, this will be a Python
    program we will write.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Event-driven systems are available for network devices, as well as network
    management systems. NMS platforms use event systems such as gRPC or SNMP to receive
    real-time events from network devices, and they offer aggregated interfaces for
    the orchestration layer or the operational or monitoring applications. For our
    example, we will interact with an event system from the Nokia NSP platform. The
    Nokia NSP system offers an event system based on Apache Kafka. Apache Kafka is
    an open source piece of software that was developed in Scala and Java, and it
    provides the implementation of a software messaging bus that is based on the **Publisher-Subscriber**
    design pattern. Before interacting with Apache Kafka, we will enumerate a list
    of key **categories** (a term used for topics in Apache Kafka) offered through
    Nokia NSP, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NSP-FAULT`: This category covers events related to faults or alarms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSP-PACKET-ALL`: This category is used for all network management events,
    including keep-alive events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSP-REAL-TIME-KPI`: This category represents events for real-time streaming
    notifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSP-PACKET-STATS`: This category is used for statistics events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A full list of categories is available in Nokia NSP documentation. All these
    categories offer additional filters for subscribing to a certain type of event.
    In the context of Nokia NSP, we will be interacting with Apache Kafka to create
    a new subscription and then process the events from the Apache Kafka system. We
    will start with subscription management.
  prefs: []
  type: TYPE_NORMAL
- en: Creating subscriptions for Apache Kafka
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before receiving any event or message from Apache Kafka, we must subscribe to
    a topic or a category. Note that one subscription is only valid for one category.
    A subscription typically expires after 1 hour, so it is recommended to renew a
    subscription 30 minutes before its expiry time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new subscription, we will use the `v1/notifications/subscriptions`
    API and the following sample code to get a new subscription:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this program will include important attributes such as `subscriptionId`
    , `topicId`, and `expiresAt`, among others, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `subscriptionId` attribute is used to renew or delete a subscription later.
    Apache Kafka will create a topic specifically for this subscription. It is provided
    to us as a `topicId` attribute. We will use this `topicId` attribute to connect
    to Apache Kafka to receive events. This explains why we call general topics categories
    in Apache Kafka. The `expiresAt` attribute indicates the time this subscription
    will expire.
  prefs: []
  type: TYPE_NORMAL
- en: Once a subscription is ready, we can connect to Apache Kafka to receive events,
    as explained in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Processing events from Apache Kafka
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Writing a basic Kafka consumer takes no more than a few lines of Python code
    with the `kafka-python` library. To create a Kafka client, we will use the `KafkaConsumer`
    class from the `kafka-python` library. We can use the following sample code to
    consume events for our subscription topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that you must use the `kafka-python` library if you
    are using Python 3.7 or later. If you are using a version of Python that's earlier
    than 3.7, you can use the `kafka` library. There are known issues with the `kafka`
    library if we use it with Python 3.7 or later. For example, there is a known issue
    that `async` has become a keyword in Python 3.7 or later releases, but it has
    been used as a variable in the `kafka` library. There are also API version issues
    when using the `kafka-python` library with Python 3.7 or later. These can be avoided
    by setting a correct API version as an argument (the `0.10.0` version, in this
    case).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we showed you a basic Kafka consumer, but you can explore a
    more sophisticated example in the source code provided with this book by going
    to [https://github.com/nokia/NSP-Integration-Bootstrap/tree/master/kafka/kafka_cmd_consumer](https://github.com/nokia/NSP-Integration-Bootstrap/tree/master/kafka/kafka_cmd_consumer).
  prefs: []
  type: TYPE_NORMAL
- en: Renewing and deleting a subscription
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can renew a subscription with the Nokia NSP Kafka system using the same
    API endpoint that we used to create a subscription. We will add the `subscriptionId`
    attribute at the end of the URL, along with the `renewals` resource, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can delete a subscription using the same API endpoint with the `subscriptionId`
    attribute at the end of the URL but using the HTTP `Delete` method. This API endpoint
    will look as follows for a delete request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, we will not send any arguments in the request body.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion on integrating with NMS and network controllers
    using both the request-response model and the event-driven model. Both these approaches
    will give you a good starting point when it comes to integrating with other management
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced network automation, along with its benefits and
    the challenges it provides for telecom service providers. We also discussed the
    key use cases of network automation. After this introduction, we discussed the
    transport protocols that are available for network automation to interact with
    network devices. Network automation can be adopted in many ways. We started by
    looking at how to directly interact with network devices using the SSH protocol
    in Python. We used the Paramiko, Netmiko, and NAPALM Python libraries to fetch
    configuration from a device and we elaborated on how to push this configuration
    to a network device. Next, we discussed how to use NETCONF with Python to interact
    with a network device. We provided code examples for working with NETCONF and
    used the ncclient library to fetch an IP interface configuration. We also used
    the same library to update an IP interface on a network device.
  prefs: []
  type: TYPE_NORMAL
- en: In the last part of this chapter, we explored how to interact with network management
    systems such as Nokia NSP. We interacted with the Nokia NSP system using Python
    as a REST API client and as a Kafka consumer. We provided a few code examples
    in terms of how to get an authentication token, and then sent a REST API to a
    NMS to retrieve configuration data and update the network configuration on devices.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter included several code examples to make you familiar with using
    Python for interacting with devices using SSH, NETCONF protocols, and using an
    NMS-level REST API. This practical knowledge is critical if you are an automation
    engineer and looking to excel in your area by using Python capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter concludes this book. We not only covered the advanced concepts
    of Python but also provided an insight into using Python in many advanced areas,
    such as data processing, serverless computing, web development, machine learning,
    and network automation.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the name of the commonly used class from the Paramiko library for making
    a connection to a device?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the four layers of NETCONF?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you push configuration directly to a `running` database in NETCONF?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is gNMI better for data collection than network configuration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does RESTCONF provide the same features as NETCONF but through REST interfaces?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are a publisher and consumer in Apache Kafka?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Mastering Python Networking*, by Eric Chou.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Practical Network Automation*, Second Edition, by Abhishek Ratan.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Network Programmability and Automation*, by Jason Edelman.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Paramiko official documentation* is available at [http://docs.paramiko.org/](http://docs.paramiko.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Netmiko official documentation* is available at [https://ktbyers.github.io/](https://ktbyers.github.io/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*NAPALM official documentation* is available at [https://napalm.readthedocs.io/](https://napalm.readthedocs.io/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ncclient official documentation* is available at [https://ncclient.readthedocs.io/](https://ncclient.readthedocs.io/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*NETCONF YANG models* can be found at [https://github.com/YangModels/yang](https://github.com/YangModels/yang).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Nokia NSP API documentation* is available at [https://network.developer.nokia.com/api-documentation/](https://network.developer.nokia.com/api-documentation/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `paramiko.SSHClient` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Content, Operations, Messages, and Transport.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a network device does not support a `candidate` database, it typically allows
    direct updates to be performed for the `running` database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: gNMI is based on gRPC, which is a protocol that was introduced by Google for
    RPC calls between mobile clients and cloud applications. The protocol has been
    optimized for data transfer, which makes it more efficient in terms of collecting
    data from network devices compared to configuring them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RESTCONF provides most of the functionality of NETCONF through REST interfaces
    but it does not expose all the operations of NETCONF.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The publisher is a client program that sends messages to a Kafka topic (category)
    as events, whereas the consumer is a client application that reads and processes
    the messages from a Kafka topic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
