- en: '*Chapter 14*: Using Python for Network Automation'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第14章*：使用Python进行网络自动化'
- en: Traditionally, networks are built and operated by network experts, and this
    is still a trend in the telecom industry. However, this manual approach of managing
    and operating a network is slow and sometimes results in costly network outages
    due to human mistakes. Additionally, to obtain a new service (such as an internet
    service), customers have to wait for days after placing a request for a new service
    before it's ready. Based on the experience of smartphones and mobile applications,
    where you can enable new services and applications with a click of a button, customers
    expect network service readiness in minutes, if not seconds. This is not possible
    with the current approach to network management. The traditional approaches are
    also sometimes a roadblock in introducing new products and services by the telecom
    service providers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，网络是由网络专家构建和运营的，这在电信行业仍然是一个趋势。然而，这种管理和运营网络的手动方法速度较慢，有时由于人为错误而导致昂贵的网络中断。此外，为了获得一项新服务（如互联网服务），客户在提交新服务请求后需要等待数天，直到服务准备就绪。基于智能手机和移动应用的经验，您只需点击一下按钮即可启用新服务和应用，客户期望网络服务在几分钟内（如果不是几秒钟内）就绪。使用当前的网络管理方法是不可能的。传统的做法有时也会成为电信服务提供商引入新产品和服务的障碍。
- en: '**Network automation** can improve these situations by offering software for
    automating the management as well as operational aspects of a network. Network
    automation helps eliminate human errors in configuring network devices and reduce
    operational costs significantly by automating repetitive tasks. Network automation
    helps accelerate service delivery and enables telecom service providers to introduce
    new services.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络自动化**可以通过提供用于自动化网络管理和操作方面的软件来改善这些情况。网络自动化有助于消除配置网络设备中的人为错误，并通过自动化重复性任务显著降低运营成本。网络自动化有助于加速服务交付，并使电信服务提供商能够引入新服务。'
- en: Python is a popular choice for network automation. In this chapter, we will
    discover Python capabilities for network automation. Python provides libraries
    such as **Paramiko**, **Netmiko**, and **NAPALM** that can be used to interact
    with network devices. If the network devices are managed by a **Network Management
    System** (**NMS**) or a network controller/orchestrator, Python can interact with
    these platforms using the **REST** or **RESTCONF** protocols. End-to-end network
    automation is not possible without listening to real-time events happening in
    the network. These real-time network events or real-time streaming data is typically
    available through systems such as **Apache Kafka**. We will also explore interaction
    with an event-driven system using Python.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python是网络自动化的流行选择。在本章中，我们将探讨Python在网络自动化方面的功能。Python提供了**Paramiko**、**Netmiko**和**NAPALM**等库，可用于与网络设备交互。如果网络设备由**网络管理系统**（**NMS**）或网络控制器/编排器管理，Python可以使用**REST**或**RESTCONF**协议与这些平台交互。没有监听网络中发生的实时事件，就无法实现端到端网络自动化。这些实时网络事件或实时流数据通常通过**Apache
    Kafka**等系统提供。我们还将探讨使用Python与事件驱动系统交互。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing network automation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍网络自动化
- en: Interacting with network devices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与网络设备交互
- en: Integrating with network management systems
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与网络管理系统集成
- en: Working with event-based systems
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与基于事件的系统协同工作
- en: After completing this chapter, you will understand how to use Python libraries
    to fetch data from a network device and to push configurational data to these
    devices. These are foundational steps for any network automation process.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将了解如何使用Python库从网络设备获取数据，并将配置数据推送到这些设备。这些是任何网络自动化过程的基础步骤。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the technical requirements for this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求如下：
- en: You need to have Python 3.7 or later installed on your computer.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要在您的计算机上安装Python 3.7或更高版本。
- en: You need to install Paramiko, Netmiko, NAPALM, ncclient, and the requests libraries
    on top of Python.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要在Python上安装Paramiko、Netmiko、NAPALM、ncclient和requests库。
- en: You need to have access to one or more network devices with the SSH protocol.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要能够访问一个或多个支持SSH协议的网络设备。
- en: You need to have access to a Nokia developer lab to be able to access Nokia's
    NMS (known as **Network Services Platform** (**NSP**)).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要能够访问诺基亚开发者实验室，以便能够访问诺基亚的NMS（称为**网络服务平台**（**NSP**））。
- en: The sample code for this chapter can be found at [https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter14](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter14).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在[https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter14](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter14)找到。
- en: Important note
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In this chapter, you will need access to physical or virtual network devices
    and network management systems to execute the code examples. This may not be possible
    for everyone. You can use any network device with similar capabilities. We will
    focus more on the Python side of the implementation and make it convenient to
    reuse the code for any other device or management system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您需要访问物理或虚拟网络设备和网络管理系统来执行代码示例。这可能对每个人来说都不可能。您可以使用任何具有类似功能的网络设备。我们将更多地关注实现的Python方面，并使其方便地重用代码以用于任何其他设备或管理系统。
- en: We will start our discussion by providing an introduction to network automation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过提供网络自动化的介绍来开始我们的讨论。
- en: Introducing network automation
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍网络自动化
- en: Network automation is the use of technology and software to automate the processes
    of managing and operationalizing networks. The keyword for network automation
    is *automating a process*, which means it is not only about deploying and configuring
    a network but also the steps that must be followed to achieve network automation.
    For example, sometimes, the automation steps involve gaining approval from different
    stakeholders before a configuration is pushed to a network. Automating such an
    approval step is part of network automation. Therefore, the network automation
    process can vary from one organization to another based on the internal processes
    each organization follows. This makes it challenging to build a single platform
    that can perform automation out of the box for many customers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 网络自动化是利用技术和软件来自动化管理和运营网络的过程。网络自动化的关键词是*自动化一个过程*，这意味着它不仅涉及部署和配置网络，还包括必须遵循的步骤以实现网络自动化。例如，有时自动化步骤包括在配置推送到网络之前从不同的利益相关者那里获得批准。自动化这样的批准步骤是网络自动化的一部分。因此，网络自动化过程可能因组织而异，取决于每个组织遵循的内部流程。这使得构建一个可以为许多客户开箱即用地执行自动化的单一平台具有挑战性。
- en: There are a significant number of ongoing efforts to provide the necessary platforms
    from the network device vendors that can help in building customized automation
    with minimal effort. A few examples of such platforms are Cisco **Network Services
    Orchestrator** (**NSO**), the **Paragon Automation** platform from Juniper Networks,
    and **NSP** from Nokia.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多正在进行中的努力，旨在从网络设备供应商那里提供必要的平台，以帮助以最小的努力构建定制自动化。这些平台的几个例子包括思科的**网络服务编排器**（**NSO**）、Juniper
    Networks的**Paragon Automation**平台和诺基亚的**NSP**。
- en: One of the challenges with these automation platforms is that they are typically
    vendor locked. This means that the vendors claim that their platform can manage
    and automate other vendors' network devices as well, but the process to achieve
    multi-vendor automation is tedious and costly. Therefore, telecom service providers
    are looking beyond the vendor's platforms for automation. **Python** and **Ansible**
    are two popular programming languages that are used for automation in the telecom
    industry. Before we jump into how Python achieves network automation, let's explore
    a few merits and challenges of network automation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些自动化平台的一个挑战是它们通常是供应商锁定。这意味着供应商声称他们的平台可以管理和自动化其他供应商的网络设备，但实现多供应商自动化的过程既繁琐又昂贵。因此，电信服务提供商正在寻找超越供应商平台以实现自动化的方法。**Python**和**Ansible**是电信行业中用于自动化的两种流行编程语言。在我们深入探讨Python如何实现网络自动化之前，让我们探讨一下网络自动化的优点和挑战。
- en: Merits and challenges of network automation
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络自动化的优点和挑战
- en: 'We have highlighted a few merits of network automation already. We can summarize
    the key merits as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经强调了网络自动化的一些优点。我们可以总结关键优点如下：
- en: '**Expedite service delivery**: Faster service delivery to new customers enables
    you to start the service billing early and have more satisfied customers.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加速服务交付**：更快地向新客户提供服务，使您能够尽早开始服务计费，并拥有更多满意的客户。'
- en: '**Reducing operational costs**: The operational costs of a network can be reduced
    by automating repetitive tasks and monitoring the network through tools and closed-loop
    automation platforms.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**降低运营成本**：通过自动化重复性任务并通过工具和闭环自动化平台监控网络，可以降低网络的运营成本。'
- en: '**Eliminate humor errors**: The majority of network outages are because of
    human errors. Network automation can eliminate this cause by configuring the networks
    using standard templates. These templates are deeply evaluated and tested before
    being put into production.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消除幽默错误**：大多数网络中断都是由于人为错误造成的。网络自动化可以通过使用标准模板配置网络来消除这一原因。这些模板在生产投入之前都经过了深入评估和测试。'
- en: '**Consistent network setup**: When humans are configuring a network, it is
    impossible to follow consistent templates and naming conventions, which are important
    for the operations team to manage the network. Network automation brings consistency
    in setting up the network as we configure the network every time using the same
    script or template.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致的网络设置**：当人类配置网络时，不可能遵循一致的模板和命名约定，这对运营团队管理网络非常重要。网络自动化通过每次使用相同的脚本或模板配置网络，带来了设置网络的统一性。'
- en: '**Network visibility**: With network automation tools and platforms, we can
    have access to performance monitoring capabilities and can visualize our network
    from end to end. Proactive network management is possible by detecting traffic
    spikes and heavy resources utilization before they cause bottlenecks for the network
    traffic.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络可见性**：通过网络自动化工具和平台，我们可以访问性能监控能力，并可以从端到端可视化我们的网络。通过在它们造成网络流量瓶颈之前检测到流量峰值和资源的高利用率，我们可以进行主动式网络管理。'
- en: 'Network automation is a must for digital transformation, but there are some
    costs and challenges to achieve it. These challenges are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 网络自动化是实现数字化转型的一个必要条件，但实现它有一些成本和挑战。这些挑战如下：
- en: '**Cost**: There is always a cost when it comes to building or customizing the
    software for network automation. Network automation is a journey and a cost budget
    must be set for it on an annual basis.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本**：在构建或定制网络自动化软件时，总是会有成本。网络自动化是一个过程，每年都必须为其设定成本预算。'
- en: '**Human resistance**: In many organizations, human resources consider network
    automation as a threat to their jobs, so they resist adopting network automation,
    especially within operation teams.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**人的抵触情绪**：在许多组织中，人力资源认为网络自动化是对他们工作的威胁，因此他们抵制采用网络自动化，尤其是在运营团队中。'
- en: '**Organizational structure**: Network automation brings a real **return on
    investment** (**ROI**) when it is used across different network layers and network
    domains such as IT and network domains. The challenge in many organizations is
    that these domains are owned by different departments and each has their own automation
    strategies and preferences regarding automation platforms.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组织结构**：当网络自动化被用于不同的网络层和网络域，如IT和网络域时，它确实可以带来真正的**投资回报率（ROI）**。在许多组织中存在的挑战是，这些域由不同的部门拥有，每个部门都有自己的自动化策略和关于自动化平台的偏好。'
- en: '**Selecting an automation platform/tool**: Selecting an automation platform
    from network equipment vendors such as Cisco or Nokia, or working with third-party
    automation platforms such as HP or Accenture, is not an easy decision. In many
    cases, the telecom service providers end up with multiple vendors for building
    their network automation, and this brings a new set of challenges to make these
    vendors work together.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择自动化平台/工具**：从思科或诺基亚等网络设备供应商中选择自动化平台，或者与惠普或埃森哲等第三方自动化平台合作，并不是一个容易的决定。在许多情况下，电信服务提供商最终会拥有多个供应商来构建他们的网络自动化，这给让这些供应商协同工作带来了一系列新的挑战。'
- en: '**Maintenance**: Maintaining automation tools and scripts is as essential as
    building them. This requires either buying essential maintenance contracts from
    automation vendors or setting an internal team to provide maintenance for such
    automation platforms.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**维护**：维护自动化工具和脚本与构建它们一样重要。这需要要么从自动化供应商那里购买必要的维护合同，要么设立一个内部团队来为这些自动化平台提供维护。'
- en: Next, we look at the use cases.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一下用例。
- en: Use cases
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: 'Several monotonous tasks regarding network management can be automated using
    Python or other tools. But the real benefits are to automate those tasks that
    are repetitive, error-prone, or tedious if done manually. From a telecom service
    provider''s point of view, the following are the main applications of network
    automation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用Python或其他工具自动执行与网络管理相关的许多单调任务。但真正的益处是自动化那些如果手动执行会重复、易出错或令人厌烦的任务。从电信服务提供商的角度来看，以下是一些网络自动化应用的主要方面：
- en: We can automate the day-to-day configuration of network devices, such as creating
    new IP interfaces and network connectivity services. It is time-consuming to do
    these tasks manually.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以自动化网络设备的日常配置，例如创建新的IP接口和网络连接服务。手动执行这些任务非常耗时。
- en: We can configure firewall rules and policies to save time. Creating firewall
    rule configurations is a tedious activity, and any mistakes can result in wasting
    time in troubleshooting the communication challenges.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以配置防火墙规则和政策来节省时间。创建防火墙规则配置是一项繁琐的活动，任何错误都可能导致在解决通信挑战时浪费时间。
- en: When we have thousands of devices in a network, upgrading their software is
    a big challenge and sometimes, it takes 1 to 2 years to achieve this. Network
    automation can expedite this activity and enforce pre- and post-upgrade checks
    conveniently for seamless upgrades.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们在网络中有成千上万的设备时，升级它们的软件是一个巨大的挑战，有时，这需要1到2年的时间才能完成。网络自动化可以加速这一活动，并方便地进行升级前后的检查，以确保无缝升级。
- en: We can use network automation to onboard new network devices in the network.
    If the device is to be installed on a customer's premises, we can save a truck
    roll by automating the device's onboarding process. This onboarding process is
    also known as **zero touch provisioning** (**ZTP**).
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用网络自动化将新的网络设备加入网络。如果设备要安装在客户的场所，我们可以通过自动化设备的加入过程来节省一次现场服务。这个过程也被称为**零接触配置**（**ZTP**）。
- en: Now that we've introduced network automation, let's explore how to interact
    with network devices using different protocols.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了网络自动化，让我们来探讨如何使用不同的协议与网络设备进行交互。
- en: Interacting with network devices
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与网络设备交互
- en: Python is a popular choice for network automation because it is easy to learn
    and can be used to integrate with network devices directly, as well as through
    NMS. In fact, many vendors, such as Nokia and Cisco, support Python runtimes on
    their network devices. The option of on-device Python runtimes is useful for automating
    tasks and activities in the context of a single device. In this section, we will
    focus on the off-device Python runtime option. This option will give us the flexibility
    to work with multiple devices at a time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是网络自动化中一个流行的选择，因为它易于学习，可以直接与网络设备集成，也可以通过 NMS 集成。实际上，许多厂商，如诺基亚和思科，在其网络设备上支持
    Python 运行时。在单个设备上下文中自动化任务和活动的设备 Python 运行时选项非常有用。在本节中，我们将重点关注设备外 Python 运行时选项。这个选项将使我们能够同时处理多个设备。
- en: Important note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: For all the code examples provided in this section, we will use a virtual network
    device from Cisco (IOS XR with release 7.1.2). For integration with the NMS we
    will use the Nokia NSP system.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节提供的所有代码示例中，我们将使用来自思科的虚拟网络设备（IOS XR 版本 7.1.2）。为了与 NMS 集成，我们将使用诺基亚 NSP 系统。
- en: Before working with Python so that we can interact with network devices, we
    will discuss the protocols that are available for communicating with network devices.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Python 与网络设备交互之前，我们将讨论可用于与网络设备通信的协议。
- en: Protocols for interacting with network devices
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与网络设备交互的协议
- en: When it comes to talking to network devices directly, there are several protocols
    we can use, such as **Secure Shell Protocol** (**SSH**), **Simple Network Management
    Protocol** (**SNMP**), and **Network Configuration** (**NETCONF**). Some of these
    protocols work on top of each other. The most commonly used protocols will be
    described next.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到直接与网络设备通信时，我们可以使用几种协议，例如 **安全外壳协议**（**SSH**）、**简单网络管理协议**（**SNMP**）和 **网络配置**（**NETCONF**）。其中一些协议是建立在其他协议之上的。接下来将描述最常用的协议。
- en: SSH
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SSH
- en: 'SSH is a network protocol for communicating between any two devices or computers
    securely. All the information between the two entities will be encrypted before
    it''s sent to a transport channel. We typically use an SSH client to connect to
    a network device using the `ssh` command. The SSH client uses the *username* of
    the logged-in operating system user with the `ssh` command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 是一种网络协议，用于在任意两个设备或计算机之间安全地通信。在信息发送到传输通道之前，两个实体之间的所有信息都将被加密。我们通常使用 SSH 客户端通过
    `ssh` 命令连接到网络设备。SSH 客户端使用 `ssh` 命令的已登录操作系统用户的 **用户名**：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To use a different user other than the logged-in user, we can specify the *username*,
    as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用除已登录用户以外的其他用户，我们可以指定**用户名**，如下所示：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once an SSH connection has been established, we can send CLI commands either
    to retrieve configuration or operational information from a device or to configure
    the device. **SSH version 2** (**SSHv2**) is a popular choice for interacting
    with devices for network management and even for automation purposes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了SSH连接，我们可以发送CLI命令，要么从设备检索配置或操作信息，要么配置设备。**SSH版本2**（**SSHv2**）是用于与设备进行网络管理和甚至自动化目的的流行选择。
- en: We will discuss how to use the SSH protocol with Python libraries such as Paramiko,
    Netmiko, and NAPALM in the *Interacting with network devices using SSH-based protocols*
    section. SSH is also a foundational transport protocol for many advanced network
    management protocols, such as NETCONF.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用基于SSH的协议与网络设备交互*这一部分，我们将讨论如何使用Python库如Paramiko、Netmiko和NAPALM来使用SSH协议。SSH也是许多高级网络管理协议的基础传输协议，如NETCONF。
- en: SNMP
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SNMP
- en: This protocol has been a de facto standard for network management for 30+ years
    and it is still used heavily for network management. However, it is being replaced
    by more advanced and scalable protocols such as NETCONF and gNMI. SNMP can be
    used both for network configuration and for network monitoring, but it is more
    popular for network monitoring. In today's world, it is considered a legacy protocol
    that was introduced in the late 1980s, purely for network management.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议已经成为了30多年来的网络管理事实上的标准，并且仍然被大量用于网络管理。然而，它正在被更先进和可扩展的协议如NETCONF和gNMI所取代。SNMP可用于网络配置和网络监控，但它更常用于网络监控。在当今世界，它被认为是一种在20世纪80年代末引入的遗留协议，纯粹用于网络管理。
- en: The SNMP protocol relies on **Management Information Base** (**MIB**), which
    is a device model. This model was built using a data modeling language called
    **Structure of Management Information** (**SMI**).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP协议依赖于**管理信息库**（**MIB**），这是一个设备模型。该模型是使用一种称为**管理信息结构**（**SMI**）的数据建模语言构建的。
- en: NETCONF
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NETCONF
- en: 'The NETCONF protocol, which was introduced by the **Internet Engineering Task
    Force** (**IETF**), is considered a successor of SNMP. NETCONF is primarily used
    for configuring network devices and is expected to be supported by all new network
    devices. NETCONF is based on four layers:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由**互联网工程任务组**（**IETF**）引入的NETCONF协议被认为是SNMP的继任者。NETCONF主要用于配置网络设备，并预期所有新的网络设备都将支持它。NETCONF基于以下四层：
- en: '**Content**: This is a data layer that relies on YANG modeling. Every device
    offers several YANG models for various modules it offers. These models can be
    explored at [https://github.com/YangModels/yang](https://github.com/YangModels/yang).'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容**：这是一个依赖于YANG建模的数据层。每个设备都为其提供的各种模块提供几个YANG模型。这些模型可以在[https://github.com/YangModels/yang](https://github.com/YangModels/yang)上探索。'
- en: '`get`, `get-config`, `edit-config`, and `delete-config`.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`、`get-config`、`edit-config`和`delete-config`。'
- en: '**Messages**: These are **Remote Procedure Call** (**RPC**) messages that are
    exchanged between the NETCONF clients and NETCONF Agent. NETCONF operations and
    data that''s encoded as XML are wrapped within the RPC messages.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息**：这些是在NETCONF客户端和NETCONF代理之间交换的**远程过程调用**（**RPC**）消息。编码为XML的NETCONF操作和数据被封装在RPC消息中。'
- en: '**Transport**: This layer provides a communication path between a client and
    a server. NETCONF messages can use NETCONF over SSH or NETCONF over TLS with the
    SSL certificate option.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输**：这一层在客户端和服务器之间提供通信路径。NETCONF消息可以使用NETCONF over SSH或使用SSL证书选项的NETCONF
    over TLS。'
- en: The NETCONF protocol is based on XML messages that have been exchanged via the
    SSH protocol using port `830` as the default port. There are typically two types
    of configuration databases that are managed by network devices. The first type
    is called the **running** database, which represents the active configuration
    on a device, including operation data. This is a mandatory database for each device.
    The second type is known as the **candidate** database, which represents the candidate
    configuration before it can be pushed to the running database. When a candidate
    database exists, configuration changes are not allowed to be made directly to
    the running database.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: NETCONF协议基于通过SSH协议交换的XML消息，默认端口为`830`。网络设备通常管理两种类型的配置数据库。第一种类型称为**运行**数据库，它表示设备上的活动配置，包括操作数据。这是每个设备的强制数据库。第二种类型称为**候选**数据库，它表示在推送到运行数据库之前可以使用的候选配置。当存在候选数据库时，不允许直接对运行数据库进行配置更改。
- en: We will discuss how to work with NETCONF using Python in the *Interacting with
    network devices using NETCONF* section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*使用NETCONF与网络设备交互*部分讨论如何使用Python与NETCONF一起工作。
- en: RESTCONF
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RESTCONF
- en: RESTCONF is another *IETF* standard that offers a subset of NETCONF functionality
    using the RESTful interface. Instead of using NETCONF RPC calls with XML encoding,
    RESTCONF offers HTTP/HTTPS-based REST calls, with the option of using XML or JSON
    messages. If network devices offer the RESTCONF interface, we can use HTTP methods
    (`GET`, `PATCH`, `PUT`, `POST`, and `DELETE`) for network management. When RESTCONF
    is used for network automation, we must understand that it provides a limited
    NETCONF functionality over HTTP/HTTPS. NETCONF operations such as commits, rollbacks,
    and configuration locking are not supported through RESTCONF.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: RESTCONF是另一个*IETF*标准，它通过RESTful接口提供NETCONF功能的一个子集。与使用XML编码的NETCONF RPC调用不同，RESTCONF提供基于HTTP/HTTPS的REST调用，可以选择使用XML或JSON消息。如果网络设备提供RESTCONF接口，我们可以使用HTTP方法（`GET`、`PATCH`、`PUT`、`POST`和`DELETE`）进行网络管理。当使用RESTCONF进行网络自动化时，我们必须理解它通过HTTP/HTTPS提供有限的NETCONF功能。NETCONF操作，如提交、回滚和配置锁定，不支持通过RESTCONF进行。
- en: gRPC/gNMI
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: gRPC/gNMI
- en: gNMI is a gRPC **Network Management Interface** (**NMI**). gRPC is a remote
    procedure call that was developed by Google for low-latency and highly scalable
    data retrieval. The gRPC protocol was developed originally for mobile clients
    that wanted to communicate with cloud servers with stringent latency requirements.
    The gRPC protocol is highly efficient for transporting structured data through
    **protocol buffers** (**Protobufs**), which is a key component of this protocol.
    By using Protobufs, the data is packed in a binary format instead of a textual
    format such as JSON or XML. This format not only reduces the size of the data
    but is very efficient for serializing and deserializing data compared to JSON
    or XML. Moreover, the data is transported using HTTP/2 instead of HTTP 1.1\. HTTP/2
    offers both the request-response model and the bidirectional communication model.
    This bidirectional communication model makes it possible for clients to open long-lived
    connections that speed up the data transfer process significantly. These two technologies
    make the gRPC protocol *7 to 10* times faster than the REST API.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: gNMI是一个用于网络管理和遥测应用的gRPC**网络管理接口**（**NMI**）。gRPC是由Google开发的一种远程过程调用，用于低延迟和高性能的数据检索。gRPC协议最初是为希望与具有严格延迟要求的云服务器通信的移动客户端开发的。gRPC协议在通过**协议缓冲区**（**Protobufs**）传输结构化数据方面非常高效，这是该协议的关键组件。通过使用Protobufs，数据以二进制格式打包，而不是JSON或XML等文本格式。这种格式不仅减少了数据的大小，而且与JSON或XML相比，在序列化和反序列化数据方面非常高效。此外，数据使用HTTP/2而不是HTTP
    1.1进行传输。HTTP/2提供了请求-响应模型和双向通信模型。这种双向通信模型使得客户端能够打开长连接，从而显著加快数据传输过程。这两种技术使得gRPC协议比REST
    API快7到10倍。
- en: gNMI is a specific implementation of the gRPC protocol for network management
    purposes and telemetry applications. It is also a YANG model-driven protocol like
    NETCONF and offers very few operations compared to NETCONF. These operations include
    `Get`, `Set`, and `Subscribe`. gNMI is getting more popular for telemetry data
    collection than for network management. The main reason for this is that it does
    not provide as much flexibility as NETCONG for network configuration, but it is
    an optimized protocol when it comes to collecting data from a remote system, especially
    in real time or near-real time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: gNMI是gRPC协议在网络管理和遥测应用中的特定实现。它也是一个YANG模型驱动的协议，与NETCONF类似，但与NETCONF相比，提供的操作非常少。这些操作包括`Get`、`Set`和`Subscribe`。gNMI在遥测数据收集方面比在网络管理方面更受欢迎。主要原因在于它不像NETCONG那样为网络配置提供足够的灵活性，但在从远程系统收集数据，尤其是在实时或近实时时，它是一个优化的协议。
- en: Next, we will discuss Python libraries for interacting with network devices.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论用于与网络设备交互的Python库。
- en: Interacting with network devices using SSH-based Python libraries
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用基于SSH的Python库与网络设备交互
- en: There are several Python libraries available for interacting with network devices
    using SSH. Paramiko, Netmiko, and NAPALM are three popular libraries that are
    available, and we will explore them in the next subsections. We will start with
    Paramiko.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个Python库可用于使用SSH与网络设备交互。Paramiko、Netmiko和NAPALM是三个可用的流行库，我们将在下一节中探讨它们。我们将从Paramiko开始。
- en: Paramiko
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Paramiko
- en: The Paramiko library is an abstraction of the SSH v2 protocol in Python and
    includes both server-side and client-side functionality. We will only focus on
    the client-side capabilities of the Paramiko library here.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Paramiko库是Python中SSH v2协议的抽象，包括服务器端和客户端功能。在这里，我们将只关注Paramiko库的客户端功能。
- en: When we interact with a network device, we either try to get configuration data,
    or we push a new configuration for certain objects. The former is achieved with
    *show* types of CLI commands, as per the operating system of the device, while
    the latter may require a special mode for executing the configuration CLI commands.
    These two types of commands are handled differently when working through Python
    libraries.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们与网络设备交互时，我们要么尝试获取配置数据，要么为某些对象推送新的配置。前者通过设备操作系统的*show*类型CLI命令实现，而后者可能需要执行配置CLI命令的特殊模式。这两种类型的命令在通过Python库工作时处理方式不同。
- en: Fetching device configuration
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取设备配置
- en: To connect to a network device (listening as an SSH server) using the Paramiko
    library, we must use an instance of the `paramiko.SSHClient` class or directly
    use a low-level `paramiko.Transport` class. The `Transport` class offers low-level
    methods that provide direct control over sockets-based communication. The `SSHClient`
    class is a wrapper class and uses the `Transport` class under the hood to manage
    a session, with an SSH server implemented on a network device.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Paramiko库连接到网络设备（作为SSH服务器），我们必须使用`paramiko.SSHClient`类的实例或直接使用低级的`paramiko.Transport`类。`Transport`类提供了低级方法，可以提供基于套接字的通信的直接控制。`SSHClient`类是一个包装类，在底层使用`Transport`类来管理会话，并在网络设备上实现SSH服务器。
- en: 'We can use the Paramiko library to establish a connection with a network device
    (Cisco IOS XR, in our case) and to run a show command (`show ip int brief`, in
    our case) like so:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Paramiko库与网络设备（在我们的例子中是Cisco IOS XR）建立连接，并运行show命令（在我们的例子中是`show ip int
    brief`）如下：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The key points of this code example are as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本代码示例的关键点如下：
- en: We created an `SSHClient` instance and opened a connection with the SSH server.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个`SSHClient`实例，并与SSH服务器建立了连接。
- en: Since we are not using the host key for our SSH connection, we applied the `set_missing_host_key_policy`
    method to avoid any warnings or errors.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们不是使用主机密钥进行我们的SSH连接，所以我们应用了`set_missing_host_key_policy`方法以避免任何警告或错误。
- en: Once the SSH connection had been established, we sent our show command, `show
    ip int brief`, to the host machine using SSH transport and received the output
    of the command as an SSH reply.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦建立了SSH连接，我们就使用SSH传输向主机机器发送了我们的show命令`show ip int brief`，并接收了命令的输出作为SSH回复。
- en: The output of this program is a tuple of `stdin`, `stdout`, and `stderr` objects.
    If our command is executed successfully, we will retrieve the output from the
    `stdout` object.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该程序的输出是一个包含`stdin`、`stdout`和`stderr`对象的元组。如果我们的命令执行成功，我们将从`stdout`对象中检索输出。
- en: 'The output of this program, when executed on a Cisco IOS XR device, is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Cisco IOS XR设备上执行此程序时，输出如下：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you are running this program on another device type, you must change the
    command that has been set as the `cmd` variable, as per your device's type.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个程序上运行其他设备类型的程序，你必须根据你的设备类型更改已设置为`cmd`变量的命令。
- en: The Paramiko library provides low-level control over network communication,
    but it can sometimes be quirky due to the non-standard or incomplete implementation
    of the SSH protocol by many network devices. If you face challenges in using Paramiko
    with some network devices, it is not you or Paramiko but the way the device expects
    you to communicate with it. A low-level transport channel can solve these issues,
    but this requires a bit of complex programming. Netmiko comes to the rescue here.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Paramiko库提供了对网络通信的低级控制，但由于许多网络设备对SSH协议的非标准或不完整实现，它有时可能会出现一些奇怪的问题。如果你在使用Paramiko与某些网络设备时遇到挑战，问题不是你或Paramiko，而是设备期望你与之通信的方式。低级传输通道可以解决这些问题，但这需要一些复杂的编程。Netmiko在这里提供了帮助。
- en: Netmiko
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Netmiko
- en: Netmiko is an abstracted library for network management that is built on top
    of the Paramiko library. It eliminates the challenges of Paramiko by treating
    every network device differently. Netmiko uses Paramiko under the hood and hides
    many device-level communication details. Netmiko supports several devices from
    different vendors, such as Cisco, Arista, Juniper, and Nokia.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Netmiko是一个基于Paramiko库构建的网络管理抽象库。它通过将每个网络设备视为不同类型来消除Paramiko的挑战。Netmiko在底层使用Paramiko，并隐藏了许多设备级通信细节。Netmiko支持来自不同厂商的多种设备，例如Cisco、Arista、Juniper和Nokia。
- en: Fetching device configuration
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取设备配置
- en: 'To connect to a network device using the show type of CLI commands, we must
    set a `device_type` definition that is used to connect with the target network
    device. This `device_type` definition is a dictionary that must include the device''s
    type, the host IP or the device''s `22`. The following code can be used to execute
    the same `show` command that we executed with the Paramiko library:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`show`类型的CLI命令连接到网络设备，我们必须设置一个`device_type`定义，该定义用于连接到目标网络设备。这个`device_type`定义是一个字典，必须包括设备的类型、主机IP或设备的`22`端口。以下代码可以用来执行我们使用Paramiko库执行的相同`show`命令：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The key points of this example code are as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例代码的关键点如下：
- en: We created a network connection using the `ConnectHandler` class using a context
    manager. The context manager will manage the life cycle of the connection.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`ConnectHandler`类和上下文管理器创建了一个网络连接。上下文管理器将管理连接的生命周期。
- en: Netmiko offers a simple method called `find_prompt` for grabbing the prompt
    of the target device, which is useful for parsing the output of many network devices.
    This is not required for the *Cisco IOS XR* network device but we used it as a
    best practice.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netmiko提供了一个名为`find_prompt`的简单方法，用于获取目标设备的提示符，这对于解析许多网络设备的输出非常有用。对于*Cisco IOS
    XR*网络设备，这并不是必需的，但我们将其作为最佳实践。
- en: Netmiko also allows us to enter *Enable* mode (it is a command-line prompt,
    `#`) for Cisco IOS devices by using the `enable` method. Again, this is not required
    for this example, but it is a best practice to use it, especially in cases where
    we are pushing CLI commands for configuration as part of the same programming
    script.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netmiko还允许我们通过使用`enable`方法进入*启用*模式（这是一个命令行提示符，`#`），用于Cisco IOS设备。再次强调，对于本示例来说，这不是必需的，但将其作为最佳实践使用，尤其是在我们作为同一编程脚本的一部分推送CLI配置命令的情况下。
- en: We executed the `show ip int brief` command using the `send_command` method
    and got the same output that we did for the `show_cisco_int_pmk.py` program.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`send_command`方法执行了`show ip int brief`命令，并得到了与`show_cisco_int_pmk.py`程序相同的输出。
- en: Based on the code example we shared for the same `show` command, we can conclude
    that working with Netmiko is much more convenient compared to Paramiko.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们分享的相同`show`命令的代码示例，我们可以得出结论，与Paramiko相比，使用Netmiko要方便得多。
- en: Important note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is very important to set the correct device type for consistent results,
    even if you are using devices from the same vendor. This is especially important
    when using commands for configuring a device. An incorrect device type can give
    inconsistent errors.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 设置正确的设备类型对于获得一致的结果非常重要，即使您使用的是同一厂商的设备也是如此。当使用配置设备的命令时，这一点尤为重要。错误的设备类型可能导致不一致的错误。
- en: 'Sometimes, we execute commands that require more time to complete than normal
    `show` commands. For example, we may want to copy a file from one location to
    the other on a device, and we know this can take a few hundred seconds for a large
    file. By default, Netmiko waits nearly *100* seconds for a command to complete.
    We can add a global delay factor as part of the device definition by adding a
    line like the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们执行的命令需要比正常的`show`命令更多的时间来完成。例如，我们可能想要将设备上的文件从一个位置复制到另一个位置，我们知道对于大文件来说，这可能需要几百秒。默认情况下，Netmiko等待命令完成的几乎为*100*秒。我们可以通过添加如下类似的行作为设备定义的一部分来添加全局延迟因子：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will increase the wait time for all the commands for this device by a
    factor of 2\. Alternatively, we can set the delay factor for an individual command
    with the `send_command` method by passing the following argument:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使该设备的所有命令的等待时间增加2倍。或者，我们可以通过`send_command`方法传递以下参数来为单个命令设置延迟因子：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We should be adding a delay factor when we expect a significant execution time.
    When we have to add a delay factor, we should also be adding another attribute
    as an argument with the `send_command` method, which will break the wait cycle
    early if we see a command prompt (for example, `#` in the case of Cisco IOS devices).
    This can be set by using the following attribute:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们预期有显著的执行时间时，我们应该添加一个延迟因子。当我们需要添加延迟因子时，我们还应该在`send_command`方法中添加另一个作为参数的属性，这样如果我们看到命令提示符（例如，Cisco
    IOS设备的`#`），就可以提前中断等待周期。这可以通过以下属性设置：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Configuring a network device
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置网络设备
- en: In the following code example, we will provide some sample code for configuration
    purposes. Configuring a device using Netmiko is similar to executing `show` commands
    as Netmiko will take care of enabling the configuration terminal (if required,
    as per the device type) and exiting out of the configuration terminal gracefully.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码示例中，我们将提供一些用于配置目的的示例代码。使用Netmiko配置设备类似于执行`show`命令，因为Netmiko将负责启用配置终端（如果需要，根据设备类型）并优雅地退出配置终端。
- en: 'For our code example, we will set a `description` of an interface using Netmiko
    with the following program:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的代码示例，我们将使用以下程序使用Netmiko设置接口的`description`：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The key points of this code example are as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例的关键点如下：
- en: For this program, we created a list of three commands (`int <interface id>`,
    `description <new description>`, and `commit`). The first two commands can be
    sent as a single command as well, but we have kept them separate for illustration
    purposes. The `commit` command is used to save changes.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于这个程序，我们创建了一个包含三个命令的列表（`int <interface id>`、`description <new description>`和`commit`）。前两个命令也可以作为一个单独的命令发送，但我们为了说明目的而将它们分开。`commit`命令用于保存更改。
- en: When we send a command to the device for configuration, we use the `send_config_set`
    method from the Netmiko library to set up a connection for configuration purposes.
    Successfully executing this step depends on the correct setting of the device
    type. This is because the device behavior varies from one device to the other
    for the configuration commands.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们向设备发送配置命令时，我们使用Netmiko库中的`send_config_set`方法来设置配置目的的连接。成功执行此步骤取决于设备类型的正确设置。这是因为配置命令的行为因设备而异。
- en: The set of three commands will add or update the `description` attribute for
    the specified interface.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这组三个命令将为指定的接口添加或更新`description`属性。
- en: 'No special output will be expected from this program, except that the device
    config prompts with our commands. The console output will look as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设备配置提示符显示我们的命令外，这个程序不会期望有特殊的输出。控制台输出将如下所示：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Netmiko offers a lot more functionality, but we will leave this for you to explore
    by reading its official documentation ([https://pypi.org/project/netmiko/](https://pypi.org/project/netmiko/)).
    The code examples we've discussed in this section have been tested with a Cisco
    network device, but the same program can be used by changing the device type and
    the commands for any other device if the device is supported by Netmiko.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Netmiko提供了更多功能，但我们将其留给你通过阅读其官方文档([https://pypi.org/project/netmiko/](https://pypi.org/project/netmiko/))来探索。本节中讨论的代码示例已在Cisco网络设备上测试过，但如果你使用的设备由Netmiko支持，可以通过更改设备类型和命令来使用相同的程序。
- en: Netmiko simplifies our code for network device interaction, but we are still
    running the CLI commands for fetching the device configuration or pushing the
    configuration toward the device. Programmability is not easily to do with Netmiko,
    but another library called NAPALM is there to help.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Netmiko简化了网络设备交互的代码，但我们仍然在运行CLI命令以获取设备配置或将配置推送到设备。使用Netmiko进行编程并不容易，但另一个名为NAPALM的库可以帮助我们。
- en: NAPALM
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NAPALM
- en: '**NAPALM** is an acronym for **Network Automation and Programmability Abstraction
    Layer with Multivendor**. This library provides the next level of abstraction
    on top of Netmiko by offering a set of functions as a unified API to interact
    with several network devices. It does not support as many devices as Netmiko.
    For release 3 of NAPALM, core drivers are available for the **Arista EOS**, **Cisco
    IOS**, **Cisco IOS-XR**, **Cisco NX-OS**, and **Juniper JunOS** network devices.
    However, there are several community-built drivers available for communicating
    with many other devices, such as **Nokia SROS**, **Aruba AOS-CX**, and **Ciena
    SAOS**.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**NAPALM** 是 **Network Automation and Programmability Abstraction Layer with
    Multivendor** 的缩写。这个库在Netmiko之上提供了更高层次的抽象，通过提供一组函数作为统一的API来与多个网络设备交互。它支持的设备数量不如Netmiko多。对于NAPALM的第三个版本，核心驱动程序适用于
    **Arista EOS**、**Cisco IOS**、**Cisco IOS-XR**、**Cisco NX-OS** 和 **Juniper JunOS**
    网络设备。然而，还有几个社区构建的驱动程序可用于与许多其他设备通信，例如 **Nokia SROS**、**Aruba AOS-CX** 和 **Ciena
    SAOS**。'
- en: As we did for Netmiko, we will build NAPALM examples for interacting with a
    network device. In the first example, we will get a list of IP interfaces, while
    for the second example, we will add or update the `description` attribute for
    an IP interface. These two code examples will perform the same operations that
    we performed using the Paramiko and Netmiko libraries.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与Netmiko一样，我们将为与网络设备交互构建NAPALM示例。在第一个示例中，我们将获取IP接口列表，而在第二个示例中，我们将为IP接口添加或更新
    `description` 属性。这两个代码示例将执行我们使用Paramiko和Netmiko库执行的操作。
- en: Fetching device configuration
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取设备配置
- en: 'To fetch a device configuration, we must set up the connection to our network
    device. We will do this in both code examples. Setting up a connection is a three-step
    process, as explained here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取设备配置，我们必须设置与我们的网络设备的连接。我们将在两个代码示例中都这样做。设置连接是一个三步过程，如下所述：
- en: To set up a connection, we must get a device driver class based on the supported
    device type. This can be achieved using the `get_network_driver` function of the
    NAPALM library.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置连接，我们必须根据支持的设备类型获取设备驱动程序类。这可以通过使用NAPALM库的 `get_network_driver` 函数来实现。
- en: Once we have a device driver class, we can create a device object by providing
    arguments such as `host id`, `username`, and `password` to the driver class constructor.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了设备驱动程序类，我们可以通过向驱动程序类的构造函数提供例如 `host id`、`username` 和 `password` 等参数来创建设备对象。
- en: 'The next step is to connect to the device using the `open` method of the device
    object. All these steps can be implemented as Python code, as shown here:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是使用设备对象的 `open` 方法连接到设备。所有这些步骤都可以像下面这样实现为Python代码：
- en: '[PRE10]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once the device''s connection is available, we can call methods such as `get_interfaces_ip`
    (equivalent to the `show interfaces` CLI command) or `get_facts` (equivalent to
    the `show version` CLI command). The complete code for using these two methods
    is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设备的连接可用，我们可以调用 `get_interfaces_ip`（相当于 `show interfaces` CLI命令）或 `get_facts`（相当于
    `show version` CLI命令）等方法。使用这两个方法的完整代码如下：
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The most interesting fact is that the output of this program is in JSON format
    by default. NAPALM converts the CLI command''s output into a dictionary by default
    that is easy to consume in Python. An excerpt of the output for the previous code
    example is shown here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的事实是，这个程序的输出默认是JSON格式。NAPALM默认将CLI命令的输出转换为Python中易于消费的字典。以下是之前代码示例输出的一部分：
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Configuring a network device
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置网络设备
- en: 'In the following code example, we are using the NAPALM library to add or update
    the `description` attribute for an existing IP interface:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码示例中，我们使用NAPALM库为现有的IP接口添加或更新 `description` 属性：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The key points of this code example are as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码示例的关键点如下：
- en: To configure the IP interface, we must use the `load_merge_candidate` method
    and pass the same set of CLI commands to this method as we did for the interface
    configuration with Netmiko.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要配置IP接口，我们必须使用 `load_merge_candidate` 方法，并将与Netmiko接口配置相同的CLI命令集传递给此方法。
- en: Next, we compared the configs before our commands and after the commands using
    the `compare_config` method. This indicates what new configuration has been added
    and what has been removed.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `compare_config` 方法比较了命令前后配置的差异。这表明了添加了哪些新配置以及删除了哪些配置。
- en: We applied a commit to all the changes using the `commit_config` method.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `commit_config` 方法提交了所有更改。
- en: 'For this example code, the output will show the delta of changes, like so:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例代码，输出将显示变化的差异，如下所示：
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, the line that starts with `-` is a configuration to be removed; any line
    with `+` at the start is a new configuration to be added.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，以`-`开头的行是要删除的配置；任何以`+`开头的行是要添加的新配置。
- en: With these two code examples, we have showed you a basic set of NAPALM features
    for one device type. The library can be used to configure multiple devices at
    a time and can work with different sets of configurations.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两个代码示例，我们已经向你展示了一个设备类型的基本NAPALM功能集。这个库可以同时配置多个设备，并且可以与不同的配置集一起工作。
- en: In the next section, we will discuss interacting with network devices using
    the NETCONF protocol.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论使用NETCONF协议与网络设备交互。
- en: Interacting with network devices using NETCONF
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用NETCONF与网络设备交互
- en: 'NETCONF was created for model (object)-driven network management, especially
    for network configuration. When working with a network device using NETCONF, it
    is important to understand two capabilities of the device, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: NETCONF是为了模型（对象）驱动的网络管理而创建的，特别是为了网络配置。在使用NETCONF与网络设备一起工作时，了解设备以下两个功能是很重要的：
- en: 'You can understand the YANG models of the devices you have. Having this knowledge
    is important if you wish to send the messages in the correct format. Here is an
    excellent source of YANG models from various vendors: [https://github.com/YangModels/yang](https://github.com/YangModels/yang).'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以理解你所拥有的设备的YANG模型。如果你希望以正确的格式发送消息，拥有这些知识是很重要的。以下是从各种供应商那里获取YANG模型的优秀来源：[https://github.com/YangModels/yang](https://github.com/YangModels/yang)。
- en: You can enable the NETCONF and SSH ports for the NETCONF protocol on the network
    device for your network device. In our case, we will be using a virtual device
    from Cisco IOS XR, as we did in our previous code examples.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以为你的网络设备上的NETCONF和SSH端口启用NETCONF协议。在我们的案例中，我们将使用Cisco IOS XR的虚拟设备，正如我们在之前的代码示例中所做的那样。
- en: 'Before starting any network management-related activity, we must check the
    device''s NETCONF capabilities and the details of the NETCONF data source''s configuration.
    For all the code examples in this section, we will use a NETCONF client library
    for Python known as `ncclient`. This library provides convenient methods for sending
    NETCONF RPC requests. We can write a sample Python program using the `ncclient`
    library to get the device''s capabilities and the device''s full configuration,
    as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始任何网络管理相关活动之前，我们必须检查设备的NETCONF功能以及NETCONF数据源配置的详细信息。在本节的所有代码示例中，我们将使用一个名为`ncclient`的Python
    NETCONF客户端库。这个库提供了发送NETCONF RPC请求的便捷方法。我们可以使用`ncclient`库编写一个示例Python程序，以获取设备的功能和设备的完整配置，如下所示：
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `manager` object from the `ncclient` library is used to connect to the device
    using SSH but for NETCONF port `830` (default). First, we get a list of server
    capabilities through the connection instance and then print them in a sorted format
    for the convenience of reading. In the next part of this code example, we initiated
    a `get-config` NETCONF operation by using the `get_config` method of the `manager`
    class library. The output of this program is very long and displays all the capabilities
    and the device configuration. We leave it to you to explore the output and become
    familiar with your device's capabilities.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`ncclient`库中的`manager`对象用于通过SSH连接到设备，但使用NETCONF端口`830`（默认）。首先，我们通过连接实例获取服务器功能列表，然后以排序格式打印它们，以便于阅读。在代码示例的下一部分，我们通过`manager`类库的`get_config`方法启动了一个`get-config`
    NETCONF操作。这个程序的输出非常长，显示了所有功能和设备配置。我们将其留给你去探索，并熟悉你设备的特性。'
- en: 'It is important to understand that the scope of this section is not to explain
    NETCONF but to learn how to use Python and `ncclient` to work with NETCONF. To
    achieve this goal, we will write two code examples: one for fetching the configuration
    of device interfaces and another on how to update the description of an interface,
    which is the same as what we did for the previous Python libraries.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解本节的范围不是解释NETCONF，而是学习如何使用Python和`ncclient`与NETCONF一起工作。为了实现这一目标，我们将编写两个代码示例：一个用于获取设备接口的配置，另一个是如何更新接口的描述，这与我们之前为Python库所做的是相同的。
- en: Getting interfaces via NETCONF
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过NETCONF获取接口
- en: In the previous section, we learned that our device (Cisco IOS XR) supports
    interfaces by using the **OpenConfig** implementation, which is available at [http://openconfig.net/yang/interfaces?module=openconfig-interfaces](http://openconfig.net/yang/interfaces?module=openconfig-interfaces).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们了解到我们的设备（Cisco IOS XR）通过**OpenConfig**实现支持接口，该实现可在[http://openconfig.net/yang/interfaces?module=openconfig-interfaces](http://openconfig.net/yang/interfaces?module=openconfig-interfaces)找到。
- en: 'We can also check the XML format of our interface''s configuration, which we
    received as the output of the `get_config` method. In this code example, we will
    simply pass an XML filter with interface configuration as an argument to the `get_config`
    method, as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查我们接口配置的XML格式，这是我们通过`get_config`方法获得的输出。在这个代码示例中，我们将简单地将一个带有接口配置的XML过滤器作为参数传递给`get_config`方法，如下所示：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of this program is a list of interfaces. We will only show an excerpt
    of the output here for illustration purposes:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的输出是一个接口列表。为了说明目的，我们在这里只展示输出的一部分：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To get a selective set of interfaces, we will use an extended version of the
    XML filter based on the interface''s YANG model. For the following code example,
    we will define an XML filter with the `name` properties of the interfaces as our
    filtering criteria. Since this XML filter is more than one line, we will define
    it separately as a string object. Here is the sample code with the XML filter:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取一组选择性的接口，我们将使用基于接口YANG模型的扩展版XML过滤器。对于下面的代码示例，我们将定义一个带有接口`name`属性的XML过滤器作为我们的过滤标准。由于这个XML过滤器是多行的，我们将单独将其定义为字符串对象。以下是带有XML过滤器的示例代码：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output of this program will be a single interface (as per the configuration
    in our device) and look as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的输出将是一个单独的接口（根据我们设备的配置），如下所示：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can define XML filters in an XML file as well and then read the file's contents
    into a string object in the Python program. Another option is to use *Jinja* templates
    if we are planning to use filters extensively.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在XML文件中定义XML过滤器，然后在Python程序中将文件内容读入字符串对象。如果我们计划广泛使用过滤器，另一个选项是使用*Jinja*模板。
- en: Next, we will discuss how to update an interface's description.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何更新接口的描述。
- en: Updating the interface's description
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新接口的描述
- en: To configure an interface attribute such as `description`, we must use the YANG
    model available at [http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg](http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置接口属性，如`description`，我们必须使用在[http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg](http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg)可用的YANG模型。
- en: 'Moreover, the XML block for configuring an interface is different than the
    XML block we used for getting the interface''s configuration. For updating an
    interface, we must use the following template, which we have defined in a separate
    file:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，配置接口的XML块与我们用于获取接口配置的XML块不同。为了更新接口，我们必须使用以下模板，我们已在单独的文件中定义：
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this template, we set the placeholders for the `name` and `description`
    properties of the interface. Next, we will write a Python program that will read
    this template and call the `edit-config` NETCONF operation by using the `edit_config`
    method of the `ncclient` library. This will push the template to the candidate
    database of the device:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模板中，我们设置了接口的`name`和`description`属性的占位符。接下来，我们将编写一个Python程序，该程序将读取这个模板并通过使用`ncclient`库的`edit_config`方法调用NETCONF的`edit-config`操作，将模板推送到设备的候选数据库：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It is important to highlight two things here. First, the Cisco IOS XR device
    has been configured to only accept the new configuration through the candidate
    database. If we try to set the `target` attribute to `running`, it will fail.
    Second, we must call the `commit` method after the `edit-config` operation in
    the same session to make the new configuration operational. The output of this
    program will be two OK replies from the NETCONF server, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，有两点很重要。首先，Cisco IOS XR设备已被配置为仅通过候选数据库接受新的配置。如果我们尝试将`target`属性设置为`running`，它将失败。其次，我们必须在相同会话中在`edit-config`操作之后调用`commit`方法，以使新的配置生效。这个程序的输出将是NETCONF服务器两个OK回复，如下所示：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This concludes our discussion of using Python for NETCONF operations. We covered
    two main operations (`get-config` and `edit-config`) of NETCONF with the `ncclient`
    library.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们使用Python进行NETCONF操作的讨论。我们使用`ncclient`库介绍了NETCONF的两个主要操作（`get-config`和`edit-config`）。
- en: In the next section, we will look at integrating with network management systems
    using Python.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用Python与网络管理系统集成。
- en: Integrating with network management systems
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与网络管理系统集成
- en: Network management systems or network controllers are systems that offer network
    management applications with **graphical user interfaces** (**GUIs**). These systems
    include applications such as network inventory, network provisioning, fault management,
    and mediation with network devices. These systems communicate with network devices
    using a combination of communication protocols such as SSH/NETCONF for network
    provisioning, SNMP for alarms and device monitoring, and gRPC for telemetry data
    collection. These systems also offer automation capabilities through their scripting
    and workflow engines.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 网络管理系统或网络控制器是提供具有**图形用户界面**（**GUIs**）的网络管理应用程序的系统。这些系统包括网络库存、网络配置、故障管理和与网络设备的调解等应用程序。这些系统使用SSH/NETCONF（用于网络配置）、SNMP（用于警报和设备监控）和gRPC（用于遥测数据收集）等通信协议的组合与网络设备通信。这些系统还通过其脚本和工作流引擎提供自动化功能。
- en: The most value-added aspect of these systems is that they aggregate the network
    device's functionality into a single system (itself) and then offer it through
    its **North Bound Interfaces** (**NBIs**), which are typically REST or RESTCONF
    interfaces. These systems also offer notifications of real-time events such as
    alarms through an event-based system such as Apache Kafka. In this section, we
    will discuss a couple of examples of using the REST API of a NMS We will explore
    how to integrate with Apache Kafka using Python in *Integrating with event driven
    systems* section.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些系统的最有价值之处在于，它们将网络设备的各项功能聚合到一个单一系统中（即自身），然后通过其**北向接口**（**NBIs**），通常是REST或RESTCONF接口提供。这些系统还通过基于事件系统的通知，如Apache
    Kafka，提供实时事件（如警报）的通知。在本节中，我们将讨论使用NMS的REST API的几个示例。在*与事件驱动系统集成*部分，我们将探讨如何使用Python与Apache
    Kafka集成。
- en: To work with a NMS we will use a shared lab offered by Nokia's online developer
    portal ([https://network.developer.nokia.com/](https://network.developer.nokia.com/)).
    This lab has a few Nokia IP routers and an NSP. This shared lab is offered free
    of charge for a limited time (3 hours per day at the time of writing this book).
    You will be required to create an account with the developer portal free of charge.
    When you book a lab for use, you will receive an email with instructions on how
    to connect to the lab, along with the necessary VPN details. If you are a network
    engineer and you have access to any other NMS or a controller, you can use that
    system for the exercises in this section by making the appropriate adjustments.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要与NMS一起工作，我们将使用诺基亚在线开发者门户提供的共享实验室([https://network.developer.nokia.com/](https://network.developer.nokia.com/))。这个实验室有几台诺基亚IP路由器和一台NSP。这个共享实验室在撰写本书时免费提供（每天3小时）。您需要免费在开发者门户中创建一个账户。当您预订实验室使用时，您将收到一封电子邮件，其中包含如何连接到实验室的说明，以及必要的VPN详细信息。如果您是网络工程师并且可以访问任何其他NMS或控制器，您可以通过进行适当的调整使用该系统来完成本节中的练习。
- en: To consume a REST API from Nokia NSP, we need to interact with the REST API
    Gateway, which manages several API endpoints for Nokia NSP. We can start working
    with the REST API Gateway by using location services, as explained next.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要从诺基亚NSP消费REST API，我们需要与REST API网关交互，该网关管理诺基亚NSP的多个API端点。我们可以通过使用位置服务开始与REST
    API网关一起工作，如以下所述。
- en: Using location services endpoints
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用位置服务端点
- en: 'To understand what API endpoints are available, Nokia NSP offers a location
    services endpoint that provides a list of all API endpoints. To consume any REST
    API in this section, we will use the `requests` library from Python. The `requests`
    library is well-known for sending HTML requests to a server using the HTTP protocol,
    and we have used it in previous chapters. To get a list of API endpoints from
    the Nokia NSP system, we will use the following Python code to invoke a location
    services API:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解可用的API端点，诺基亚NSP提供了一个位置服务端点，提供所有API端点的列表。在本节中，我们将使用Python的`requests`库来消费任何REST
    API。`requests`库因其使用HTTP协议向服务器发送HTML请求而闻名，我们已在之前的章节中使用过它。要从诺基亚NSP系统中获取API端点列表，我们将使用以下Python代码调用位置服务API：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This API response will provide you with a few dozen API endpoints in JSON format.
    You can check the online documentation of Nokia NSP at [https://network.developer.nokia.com/api-documentation/](https://network.developer.nokia.com/api-documentation/)
    to understand how each API works. If we are looking for a specific API endpoint,
    we can change the value of the `url` variable in the aforementioned code example,
    as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此API响应将为您提供几十个API端点，以JSON格式。您可以在诺基亚NSP的在线文档[https://network.developer.nokia.com/api-documentation/](https://network.developer.nokia.com/api-documentation/)中查看，了解每个API是如何工作的。如果我们正在寻找特定的API端点，我们可以在上述代码示例中更改`url`变量的值，如下所示：
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'By using this new API URL, we are trying to find an API endpoint for the authorization
    token (`/v1/auth/token`). The output of the code example with this new URL is
    as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这个新的API URL，我们试图找到一个用于授权令牌的API端点（`/v1/auth/token`）。使用这个新URL的代码示例输出如下：
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that no authentication is required to use the location services API. However,
    we will need an authentication token to call any other API. In the next section,
    we will learn how to get an authentication token.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用位置服务API不需要身份验证。但是，我们需要一个身份验证令牌来调用任何其他API。在下一节中，我们将学习如何获取身份验证令牌。
- en: Getting an authentication token
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取身份验证令牌
- en: 'As a next step, we will use `effectiveUrl` from the output of the previous
    code example to get the authentication token. This API requires that we pass the
    *base64* encoding of `username` and `password` as the `Authorization` attribute
    of the HTTP header. The Python code to call this authentication API is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，我们将使用前一个代码示例的输出中的`effectiveUrl`来获取身份验证令牌。此API要求我们将`username`和`password`的*base64*编码作为HTTP头中的`Authorization`属性传递。调用此身份验证API的Python代码如下：
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There is also a refresh token available that can be used to refresh the token
    before it expires. A best practice is to refresh your token every *30* minutes.
    We can refresh our token using the same authentication token API, but send the
    following attributes in the body of the HTTP request:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个刷新令牌可用，可以在令牌过期之前刷新令牌。一个最佳实践是每*30*分钟刷新一次令牌。我们可以使用相同的身份验证令牌API来刷新我们的令牌，但在HTTP请求体中发送以下属性：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Another good practice is to revoke the token when there is no further need
    for it. This can be achieved by using the following API endpoint:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好习惯是在不再需要令牌时撤销它。这可以通过使用以下API端点来实现：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Getting network devices and an interface inventory
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取网络设备和接口清单
- en: 'Once we have received the authentication token, we can use the REST API to
    get configured data, as well as to add a new configuration. We will start with
    a simple code example that will get a list of all the network devices in a network
    that is managed by NSP. In this code example, we will use the token we have already
    retrieved using the token API:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们收到身份验证令牌，我们就可以使用REST API获取配置数据，以及添加新的配置。我们将从一个简单的代码示例开始，该示例将获取由NSP管理的网络中所有网络设备的列表。在这个代码示例中，我们将使用通过令牌API已经检索到的令牌：
- en: '[PRE29]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The output of this program will be a list of network devices with network device
    attributes. We skipped showing the output due to this being a large set of data.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序的输出将是一个包含网络设备属性的网络设备列表。我们跳过了输出显示，因为这是一组大量数据。
- en: 'In the following code example, we will show how to get a list of device ports
    (interfaces) based on a filter. Note that we can apply filters to network devices
    as well. For this code example, we will ask the NSP API to give us a list of ports
    based on the port name (`Port 1/1/1`, in our case):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码示例中，我们将展示如何根据过滤器获取设备端口（接口）列表。请注意，我们也可以将过滤器应用于网络设备。对于本代码示例，我们将要求NSP API根据端口名称（在我们的例子中是`Port
    1/1/1`）给我们提供一个端口列表：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The output of this program will be a list of device ports called `Port 1/1/1`
    from all network devices. Getting ports across multiple network devices with a
    single API is the real value of working with a NMS
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序的输出将是从所有网络设备中调用名为`Port 1/1/1`的设备端口列表。使用单个API获取多个网络设备的端口是使用NMS的实际价值
- en: Next, we will discuss how to update a network resource using the NMS API.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何使用NMS API更新网络资源。
- en: Updating the network device port
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新网络设备端口
- en: 'Creating new objects or updating existing objects is also convenient when using
    the NMS API. We will implement a case of updating the port description, as we
    did in previous code examples, using `Netmiko`, `NAPALM`, and `ncclient`. To update
    a port or interface, we will use a different API endpoint that is available from
    the **Network Function Manager for Packet** (**NFMP**) module. NFMP is an NMS
    module for Nokia network devices under the Nokia NSP platform. Let''s look at
    the steps of updating a port description or making any change to a network resource:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NMS API 创建新对象或更新现有对象也很方便。我们将实现一个更新端口描述的案例，就像我们在之前的代码示例中所做的那样，使用 `Netmiko`、`NAPALM`
    和 `ncclient`。要更新端口或接口，我们将使用一个不同的 API 端点，该端点来自 **网络功能管理器包**（**NFMP**）模块。NFMP 是诺基亚网络设备在诺基亚
    NSP 平台下的 NMS 模块。让我们看看更新端口描述或对网络资源进行任何更改的步骤：
- en: 'To update an object or create a new object under an existing object, we will
    need the `v1/managedobjects/searchWithFilter` API with the following filter criteria:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要更新对象或在一个现有对象下创建新对象，我们需要使用具有以下筛选标准的 `v1/managedobjects/searchWithFilter` API：
- en: '[PRE31]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we will use a different API endpoint called `v1/managedobjects/ofn` to
    update an attribute of the network object. In our case, we are only updating the
    description attribute. For the update operation, we must set the `fullClassName`
    attribute in the payload and a new value for the description attribute. For the
    API endpoint''s URL, we will concatenate the `port_ofn` variable that we computed
    in the previous step. The sample code for this part of the program is as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用一个名为 `v1/managedobjects/ofn` 的不同 API 端点来更新网络对象的属性。在我们的例子中，我们只更新描述属性。对于更新操作，我们必须在有效载荷中设置
    `fullClassName` 属性以及描述属性的新值。对于 API 端点的 URL，我们将连接我们在上一步计算的 `port_ofn` 变量。该程序这部分内容的示例代码如下：
- en: '[PRE32]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Network automation is the process of creating and updating many network objects
    in a specific order. For example, we can update a port before creating an IP connectivity
    service to connect two or more local area networks. This type of use case requires
    that we perform a series of tasks to update all the ports involved, as well as
    many other objects. With the NMS API, we can orchestrate all these tasks in a
    program to implement an automated process.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 网络自动化是指按照特定顺序创建和更新许多网络对象的过程。例如，我们可以在创建 IP 连接服务以连接两个或更多局域网之前更新一个端口。这类用例要求我们执行一系列任务来更新所有涉及的端口，以及许多其他对象。使用
    NMS API，我们可以在程序中编排所有这些任务以实现自动化流程。
- en: In the next section, we will explore how to integrate with Nokia NSP or similar
    systems for event-driven communication.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何集成诺基亚 NSP 或类似系统以实现事件驱动通信。
- en: Integrating with event-driven systems
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成事件驱动系统
- en: In the previous sections, we discussed how to interact with network devices
    and network management systems using the request-response model. In this model,
    a client sends a request to a server and the server sends a response as a reply
    to the request. The HTTP (REST API) and SSH protocols are based on a request-response-based
    model. This model works well for configuring a system or getting the operational
    state of the network on an ad hoc basis or periodically. But what about if something
    happens in the network that requires the operation team's attention? For example,
    let's say a hardware failure on a device or a line cable has been cut. Network
    devices typically raise alarms in such situations, and these alarms have to reach
    the operator (via an email, an SMS, or a dashboard) immediately.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了如何使用请求-响应模型与网络设备和网络管理系统进行交互。在这个模型中，客户端向服务器发送请求，服务器作为对请求的回复发送响应。HTTP（REST
    API）和 SSH 协议基于请求-响应模型。这种模型在临时或定期配置系统或获取网络的操作状态时工作得很好。但是，如果网络中发生需要操作团队注意的事情怎么办？例如，假设设备上的硬件故障或线路电缆被切断。网络设备通常在这种情况下发出警报，并且这些警报必须立即通知操作员（通过电子邮件、短信或仪表板）。
- en: We can use the request-response model to poll the network device every second
    (or every few seconds) to check if there has been any change in the state of a
    network device or if there is a new alarm. However, this is not an efficient use
    of the network device's resources and will contribute to unnecessary traffic in
    the network. What about if the network device or NMS itself reaches out to the
    interested clients whenever there is a change in the state of critical resources,
    or an alarm is raised? This type of model is called an *event-driven* model, and
    it is a popular communication approach for sending real-time events.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用请求-响应模型每秒（或每隔几秒）轮询网络设备，以检查网络设备的状态是否发生变化，或者是否有新的警报。然而，这种方式并不是网络设备资源的有效利用，并且会在网络中产生不必要的流量。那么，如果网络设备或NMS本身在关键资源状态发生变化或发出警报时主动联系感兴趣的客户端，会怎样呢？这种类型的模型被称为*事件驱动*模型，它是发送实时事件的一种流行通信方式。
- en: Event-driven systems can be implemented either using **webhooks**/**WebSockets**
    or using the **streaming** approach. WebSockets offers a bidirectional transport
    channel over HTTP 1.1 through a TCP/IP socket. Since this bidirectional connection
    is not using the traditional request-response model, WebSockets is an efficient
    approach when we want to establish a one-to-one connection between the two systems.
    This is one of the best options when we need real-time communication between the
    two programs. WebSockets are supported by all standard browsers, including the
    one that's available with iPhone and Android devices. It is also a popular choice
    for many social media platforms, streaming applications, and online gaming.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动系统可以通过**webhooks**/**WebSockets**或使用**流式**方法来实现。WebSockets通过TCP/IP套接字在HTTP
    1.1上提供了一个双向传输通道。由于这种双向连接不使用传统的请求-响应模型，因此当我们需要在两个系统之间建立一对一连接时，WebSockets是一种高效的方法。当我们需要两个程序之间进行实时通信时，这是最佳选择之一。所有标准浏览器都支持WebSockets，包括iPhone和Android设备所提供的浏览器。它也是许多社交媒体平台、流媒体应用和在线游戏的流行选择。
- en: 'WebSockets is a lightweight solution for getting real-time events. But when
    many clients are looking to receive events from one system, using a streaming
    approach is scalable and efficient. The streaming event-based model typically
    follows a publisher-subscriber design pattern and has three main components, as
    described here:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets是获取实时事件的一个轻量级解决方案。但是，当许多客户端希望从一个系统中接收事件时，使用流式方法可扩展且高效。基于流的基于事件模型通常遵循发布-订阅设计模式，并具有三个主要组件，如下所述：
- en: '**Topic**: All streaming messages or event notifications are stored under a
    topic. We can think of a topic as a directory. This topic helps us subscribe to
    topics of interest to help us avoid receiving all events.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题**：所有流式消息或事件通知都存储在主题下。我们可以将主题视为一个目录。这个主题帮助我们订阅感兴趣的主题，以避免接收所有事件。'
- en: '**Producer**: This is a program or piece of software that pushes the events
    or messages to a topic. This is also called the **publisher**. In our case, it
    will be an NSP application.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产者**：这是一个将事件或消息推送到主题的程序或软件。这也被称为**发布者**。在我们的案例中，它将是一个NSP应用。'
- en: '**Consumer**: This is a program that fetches the events or messages from a
    topic. This is also called a **subscriber**. In our case, this will be a Python
    program we will write.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消费者**：这是一个从主题中获取事件或消息的程序。这也被称为**订阅者**。在我们的案例中，这将是我们将要编写的Python程序。'
- en: 'Event-driven systems are available for network devices, as well as network
    management systems. NMS platforms use event systems such as gRPC or SNMP to receive
    real-time events from network devices, and they offer aggregated interfaces for
    the orchestration layer or the operational or monitoring applications. For our
    example, we will interact with an event system from the Nokia NSP platform. The
    Nokia NSP system offers an event system based on Apache Kafka. Apache Kafka is
    an open source piece of software that was developed in Scala and Java, and it
    provides the implementation of a software messaging bus that is based on the **Publisher-Subscriber**
    design pattern. Before interacting with Apache Kafka, we will enumerate a list
    of key **categories** (a term used for topics in Apache Kafka) offered through
    Nokia NSP, as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动系统适用于网络设备以及网络管理系统。NMS平台使用gRPC或SNMP等事件系统从网络设备接收实时事件，并为编排层或操作或监控应用程序提供聚合接口。在我们的示例中，我们将与诺基亚NSP平台的事件系统交互。诺基亚NSP系统提供了一个基于Apache
    Kafka的事件系统。Apache Kafka是一个开源软件，用Scala和Java开发，它提供了一个基于**发布-订阅**设计模式的软件消息总线实现。在与Apache
    Kafka交互之前，我们将列举通过诺基亚NSP提供的以下关键**类别**（在Apache Kafka中用于主题的术语）列表：
- en: '`NSP-FAULT`: This category covers events related to faults or alarms.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSP-FAULT`：这个类别涵盖了与故障或警报相关的事件。'
- en: '`NSP-PACKET-ALL`: This category is used for all network management events,
    including keep-alive events.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSP-PACKET-ALL`：这个类别用于所有网络管理事件，包括心跳事件。'
- en: '`NSP-REAL-TIME-KPI`: This category represents events for real-time streaming
    notifications.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSP-REAL-TIME-KPI`：这个类别代表实时流通知的事件。'
- en: '`NSP-PACKET-STATS`: This category is used for statistics events.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSP-PACKET-STATS`：这个类别用于统计事件。'
- en: A full list of categories is available in Nokia NSP documentation. All these
    categories offer additional filters for subscribing to a certain type of event.
    In the context of Nokia NSP, we will be interacting with Apache Kafka to create
    a new subscription and then process the events from the Apache Kafka system. We
    will start with subscription management.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在诺基亚NSP文档中可以找到完整的类别列表。所有这些类别都提供了订阅特定类型事件的附加过滤器。在诺基亚NSP的上下文中，我们将与Apache Kafka交互以创建新的订阅，然后处理来自Apache
    Kafka系统的事件。我们将从订阅管理开始。
- en: Creating subscriptions for Apache Kafka
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Apache Kafka创建订阅
- en: Before receiving any event or message from Apache Kafka, we must subscribe to
    a topic or a category. Note that one subscription is only valid for one category.
    A subscription typically expires after 1 hour, so it is recommended to renew a
    subscription 30 minutes before its expiry time.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在从Apache Kafka接收任何事件或消息之前，我们必须订阅一个主题或类别。请注意，一个订阅仅对一类有效。订阅通常在1小时后过期，因此建议在过期前30分钟更新订阅。
- en: 'To create a new subscription, we will use the `v1/notifications/subscriptions`
    API and the following sample code to get a new subscription:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的订阅，我们将使用`v1/notifications/subscriptions` API和以下示例代码来获取新的订阅：
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output of this program will include important attributes such as `subscriptionId`
    , `topicId`, and `expiresAt`, among others, as shown here:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的输出将包括重要的属性，如`subscriptionId`、`topicId`和`expiresAt`等，如下所示：
- en: '[PRE34]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `subscriptionId` attribute is used to renew or delete a subscription later.
    Apache Kafka will create a topic specifically for this subscription. It is provided
    to us as a `topicId` attribute. We will use this `topicId` attribute to connect
    to Apache Kafka to receive events. This explains why we call general topics categories
    in Apache Kafka. The `expiresAt` attribute indicates the time this subscription
    will expire.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscriptionId`属性用于稍后更新或删除订阅。Apache Kafka将为该订阅创建一个特定的主题。它作为`topicId`属性提供给我们。我们将使用这个`topicId`属性来连接到Apache
    Kafka以接收事件。这就是为什么我们称Apache Kafka中的通用主题为类别。`expiresAt`属性表示此订阅将过期的时间。'
- en: Once a subscription is ready, we can connect to Apache Kafka to receive events,
    as explained in the next subsection.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦订阅准备就绪，我们就可以连接到Apache Kafka以接收事件，如下一小节所述。
- en: Processing events from Apache Kafka
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理来自Apache Kafka的事件
- en: 'Writing a basic Kafka consumer takes no more than a few lines of Python code
    with the `kafka-python` library. To create a Kafka client, we will use the `KafkaConsumer`
    class from the `kafka-python` library. We can use the following sample code to
    consume events for our subscription topic:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kafka-python`库，编写一个基本的Kafka消费者只需要几行Python代码。要创建一个Kafka客户端，我们将使用`kafka-python`库中的`KafkaConsumer`类。我们可以使用以下示例代码来消费订阅主题的事件：
- en: '[PRE35]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It is important to note that you must use the `kafka-python` library if you
    are using Python 3.7 or later. If you are using a version of Python that's earlier
    than 3.7, you can use the `kafka` library. There are known issues with the `kafka`
    library if we use it with Python 3.7 or later. For example, there is a known issue
    that `async` has become a keyword in Python 3.7 or later releases, but it has
    been used as a variable in the `kafka` library. There are also API version issues
    when using the `kafka-python` library with Python 3.7 or later. These can be avoided
    by setting a correct API version as an argument (the `0.10.0` version, in this
    case).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：如果您使用的是Python 3.7或更高版本，则必须使用`kafka-python`库。如果您使用的是低于3.7版本的Python，则可以使用`kafka`库。如果我们在Python
    3.7或更高版本中使用`kafka`库，已知存在一些问题。例如，已知`async`在Python 3.7或更高版本中已成为关键字，但在`kafka`库中已被用作变量。当使用`kafka-python`库与Python
    3.7或更高版本一起使用时，也存在API版本问题。这些问题可以通过设置正确的API版本作为参数（在这种情况下为`0.10.0`版本）来避免。
- en: In this section, we showed you a basic Kafka consumer, but you can explore a
    more sophisticated example in the source code provided with this book by going
    to [https://github.com/nokia/NSP-Integration-Bootstrap/tree/master/kafka/kafka_cmd_consumer](https://github.com/nokia/NSP-Integration-Bootstrap/tree/master/kafka/kafka_cmd_consumer).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们向您展示了一个基本的Kafka消费者，但您可以通过访问本书提供的源代码中的更复杂示例来探索：[https://github.com/nokia/NSP-Integration-Bootstrap/tree/master/kafka/kafka_cmd_consumer](https://github.com/nokia/NSP-Integration-Bootstrap/tree/master/kafka/kafka_cmd_consumer)。
- en: Renewing and deleting a subscription
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 续订和删除订阅
- en: 'We can renew a subscription with the Nokia NSP Kafka system using the same
    API endpoint that we used to create a subscription. We will add the `subscriptionId`
    attribute at the end of the URL, along with the `renewals` resource, as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与创建订阅相同的API端点来使用Nokia NSP Kafka系统续订订阅。我们将在URL末尾添加`subscriptionId`属性，以及`renewals`资源，如下所示：
- en: '[PRE36]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can delete a subscription using the same API endpoint with the `subscriptionId`
    attribute at the end of the URL but using the HTTP `Delete` method. This API endpoint
    will look as follows for a delete request:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相同的API端点，通过在URL末尾添加`subscriptionId`属性，并使用HTTP的`Delete`方法来删除订阅。以下是一个删除请求的API端点示例：
- en: '[PRE37]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In both cases, we will not send any arguments in the request body.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们都不会在请求体中发送任何参数。
- en: This concludes our discussion on integrating with NMS and network controllers
    using both the request-response model and the event-driven model. Both these approaches
    will give you a good starting point when it comes to integrating with other management
    systems.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们关于使用请求-响应模型和事件驱动模型与NMS和网络控制器集成的讨论。这两种方法在与其他管理系统集成时都将为你提供一个良好的起点。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced network automation, along with its benefits and
    the challenges it provides for telecom service providers. We also discussed the
    key use cases of network automation. After this introduction, we discussed the
    transport protocols that are available for network automation to interact with
    network devices. Network automation can be adopted in many ways. We started by
    looking at how to directly interact with network devices using the SSH protocol
    in Python. We used the Paramiko, Netmiko, and NAPALM Python libraries to fetch
    configuration from a device and we elaborated on how to push this configuration
    to a network device. Next, we discussed how to use NETCONF with Python to interact
    with a network device. We provided code examples for working with NETCONF and
    used the ncclient library to fetch an IP interface configuration. We also used
    the same library to update an IP interface on a network device.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了网络自动化，包括其优势和它为电信服务提供商带来的挑战。我们还讨论了网络自动化的关键用例。在介绍之后，我们讨论了网络自动化与网络设备交互时可用的传输协议。网络自动化可以以多种方式采用。我们首先探讨了如何使用
    Python 中的 SSH 协议直接与网络设备交互。我们使用了 Paramiko、Netmiko 和 NAPALM Python 库从设备获取配置，并详细说明了如何将此配置推送到网络设备。接下来，我们讨论了如何使用
    Python 中的 NETCONF 与网络设备交互。我们提供了与 NETCONF 一起工作的代码示例，并使用 ncclient 库获取 IP 接口配置。我们还使用相同的库更新了网络设备上的
    IP 接口。
- en: In the last part of this chapter, we explored how to interact with network management
    systems such as Nokia NSP. We interacted with the Nokia NSP system using Python
    as a REST API client and as a Kafka consumer. We provided a few code examples
    in terms of how to get an authentication token, and then sent a REST API to a
    NMS to retrieve configuration data and update the network configuration on devices.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们探讨了如何与网络管理系统，如诺基亚 NSP 进行交互。我们使用 Python 作为 REST API 客户端和 Kafka 消费者与诺基亚
    NSP 系统进行交互。我们提供了一些代码示例，说明了如何获取认证令牌，然后向 NMS 发送 REST API 以检索配置数据并更新设备上的网络配置。
- en: This chapter included several code examples to make you familiar with using
    Python for interacting with devices using SSH, NETCONF protocols, and using an
    NMS-level REST API. This practical knowledge is critical if you are an automation
    engineer and looking to excel in your area by using Python capabilities.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含了一些代码示例，使您熟悉使用 Python 通过 SSH、NETCONF 协议以及使用 NMS 级 REST API 与设备交互。如果您是自动化工程师，并希望利用
    Python 功能在您的领域脱颖而出，这种实际知识至关重要。
- en: This chapter concludes this book. We not only covered the advanced concepts
    of Python but also provided an insight into using Python in many advanced areas,
    such as data processing, serverless computing, web development, machine learning,
    and network automation.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 本章总结了本书的内容。我们不仅涵盖了 Python 的高级概念，还提供了在许多高级领域使用 Python 的见解，例如数据处理、无服务器计算、Web 开发、机器学习和网络自动化。
- en: Questions
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the name of the commonly used class from the Paramiko library for making
    a connection to a device?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Paramiko 库中用于连接设备的常用类叫什么名字？
- en: What are the four layers of NETCONF?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NETCONF 有哪四层？
- en: Can you push configuration directly to a `running` database in NETCONF?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以直接将配置推送到 NETCONF 中的 `running` 数据库吗？
- en: Why is gNMI better for data collection than network configuration?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么 gNMI 在数据收集方面比网络配置更好？
- en: Does RESTCONF provide the same features as NETCONF but through REST interfaces?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RESTCONF 是否提供与 NETCONF 相同的功能，但通过 REST 接口提供？
- en: What are a publisher and consumer in Apache Kafka?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Apache Kafka 中的发布者和消费者是什么？
- en: Further reading
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Mastering Python Networking*, by Eric Chou.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*精通 Python 网络*》，作者 Eric Chou。
- en: '*Practical Network Automation*, Second Edition, by Abhishek Ratan.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*实用网络自动化* 第二版》，作者 Abhishek Ratan。
- en: '*Network Programmability and Automation*, by Jason Edelman.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*网络可编程性和自动化*》，作者 Jason Edelman。
- en: '*Paramiko official documentation* is available at [http://docs.paramiko.org/](http://docs.paramiko.org/).'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*Paramiko 官方文档*》可在 [http://docs.paramiko.org/](http://docs.paramiko.org/) 查找。
- en: '*Netmiko official documentation* is available at [https://ktbyers.github.io/](https://ktbyers.github.io/).'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*Netmiko 官方文档*》可在 [https://ktbyers.github.io/](https://ktbyers.github.io/)
    查找。
- en: '*NAPALM official documentation* is available at [https://napalm.readthedocs.io/](https://napalm.readthedocs.io/).'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*NAPALM 官方文档*》可在 [https://napalm.readthedocs.io/](https://napalm.readthedocs.io/)
    查找。
- en: '*ncclient official documentation* is available at [https://ncclient.readthedocs.io/](https://ncclient.readthedocs.io/).'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*ncclient 官方文档*》可在 [https://ncclient.readthedocs.io/](https://ncclient.readthedocs.io/)
    查找。
- en: '*NETCONF YANG models* can be found at [https://github.com/YangModels/yang](https://github.com/YangModels/yang).'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NETCONF YANG模型* 可以在 [https://github.com/YangModels/yang](https://github.com/YangModels/yang)
    找到。'
- en: '*Nokia NSP API documentation* is available at [https://network.developer.nokia.com/api-documentation/](https://network.developer.nokia.com/api-documentation/).'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*诺基亚NSP API文档* 可在 [https://network.developer.nokia.com/api-documentation/](https://network.developer.nokia.com/api-documentation/)
    找到。'
- en: Answers
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The `paramiko.SSHClient` class.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`paramiko.SSHClient`类。'
- en: Content, Operations, Messages, and Transport.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内容、操作、消息和传输。
- en: If a network device does not support a `candidate` database, it typically allows
    direct updates to be performed for the `running` database.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果网络设备不支持`candidate`数据库，它通常允许直接更新`running`数据库。
- en: gNMI is based on gRPC, which is a protocol that was introduced by Google for
    RPC calls between mobile clients and cloud applications. The protocol has been
    optimized for data transfer, which makes it more efficient in terms of collecting
    data from network devices compared to configuring them.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: gNMI基于gRPC，这是一个由谷歌引入的用于移动客户端和云应用之间RPC调用的协议。该协议针对数据传输进行了优化，这使得它在从网络设备收集数据方面比配置它们更有效率。
- en: RESTCONF provides most of the functionality of NETCONF through REST interfaces
    but it does not expose all the operations of NETCONF.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RESTCONF通过REST接口提供了NETCONF的大部分功能，但它并没有暴露NETCONF的所有操作。
- en: The publisher is a client program that sends messages to a Kafka topic (category)
    as events, whereas the consumer is a client application that reads and processes
    the messages from a Kafka topic.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布者是发送消息到Kafka主题（类别）作为事件的客户端程序，而消费者是读取并处理从Kafka主题消息的客户端应用程序。
