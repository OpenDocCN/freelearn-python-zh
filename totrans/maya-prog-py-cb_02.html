<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Creating User Interfaces"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Creating User Interfaces</h1></div></div></div><p>In this chapter, we'll be taking a guided tour through Maya's collection of user interface elements and learning how to use them to create interfaces that you and your teammates will love to use. The following topics will be covered:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Making a basic window</li><li class="listitem" style="list-style-type: disc">Simple controls – making a button</li><li class="listitem" style="list-style-type: disc">Retrieving input from controls</li><li class="listitem" style="list-style-type: disc">Using classes to organize UI logic</li><li class="listitem" style="list-style-type: disc">Using nested layouts</li><li class="listitem" style="list-style-type: disc">Using tabs and scrolling</li><li class="listitem" style="list-style-type: disc">Adding menu to your UIs</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Introduction</h1></div></div></div><p>While it is by no <a id="id38" class="indexterm"/>means required to create a graphical user interface (GUI) for your scripts, you're likely to want one in almost all cases. Very often, you'll find yourself creating scripts that are meant to be used by your teammates, some of whom may be less comfortable with command-line tools.</p><p>In this chapter, we'll be looking at how to create windows, fill them with interface elements, and link those elements up to other functionality within Maya.</p></div></div>
<div class="section" title="Making a basic window"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Making a basic window</h1></div></div></div><p>All great <a id="id39" class="indexterm"/>user interfaces start with window. In this <a id="id40" class="indexterm"/>example, we'll be creating a simple window and using the text label control to add a simple message.</p><p>We'll end up with something like the following:</p><div class="mediaobject"><img src="graphics/4657_02_01.jpg" alt="Making a basic window"/></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec41"/>How to do it...</h2></div></div></div><p>Start by<a id="id41" class="indexterm"/> creating a new file in your scripts directory <a id="id42" class="indexterm"/>and naming it basic <code class="literal">Window.py</code>.</p><p>Add the following code:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds

def showUI():
    myWin = cmds.window(title="Simple Window", widthHeight=(300, 200))
    cmds.columnLayout()
    cmds.text(label="Hello, Maya!")

    cmds.showWindow(myWin)

showUI()</pre></div><p>If you run the script, you should see a small window containing the text <span class="strong"><strong>Hello, Maya!</strong></span>.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec42"/>How it works...</h2></div></div></div><p>To create a window, you'll need to use the window command.</p><div class="informalexample"><pre class="programlisting">myWin = cmds.window(title="Simple Window", widthHeight=(300, 200))</pre></div><p>While all of the arguments are optional, there are a few that you'll generally want to include by default. Here, we're setting the title to "Simple Window" and the size of the window to 300 pixels wide by 200 pixels tall. Also note that we save the result of the command to a variable, <code class="literal">myWin</code>. This is necessary in order to use the <code class="literal">showWindow</code> command. More on that in a bit.</p><p>There is also one <a id="id43" class="indexterm"/>more requirement, that is, in order to add an element to a window, you must first specify a layout. Layouts are responsible for arranging items within a given area (either a window or another layout). If you fail to provide Maya with a layout, it won't be able to properly position any controls you add, and your script will error out. In this example, we're using a <code class="literal">columnLayout</code>, which will arrange all the controls we add in a single vertical column. We add a layout to the window with the following:</p><div class="informalexample"><pre class="programlisting">cmds.columnLayout()</pre></div><p>Once<a id="id44" class="indexterm"/> we've created a window and specified a layout, we can start adding controls. In this case, we're using the text control that merely adds some text to the window. While you won't generally use text controls by themselves (it's far more common to use them next to other controls to provide labels or descriptive text), it serves as a good example of a typical, albeit simple, control.</p><div class="informalexample"><pre class="programlisting">cmds.text(label="Hello, Maya!")</pre></div><p>At this point, we're done with our interface, but creating a window will not actually show anything in Maya. To have it shown up in Maya's interface, we'll also need to explicitly show it using the <code class="literal">showWindow</code> command. The reason for this is that you generally don't want to show a window until it has all of the controls and other UI elements you want it to have. However, in order to create a control, you must first have a window to add them to. Maya solves this by having you:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create the window.</li><li class="listitem">Add your controls.</li><li class="listitem">Show the window once all of the controls have been added.</li></ol></div><p>This is why, it was important to save the result of the <code class="literal">window()</code> command to a variable, so that we can tell Maya which window it should show to the user. Putting that together gives us the last line of our showUI function:</p><div class="informalexample"><pre class="programlisting">cmds.showWindow(myWin)</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec43"/>There's more...</h2></div></div></div><p>Note that once a layout is created, it becomes the active context in order to add controls. You can certainly have multiple layouts in a single window (and even nest them within each other), but there is always exactly one current layout to which Maya will insert newly created controls.</p><p>One problem with this example is that running the script multiple times will result in multiple copies of the window, which is usually not what you want. For most purposes, you'll want to ensure that there is only ever a single instance of your UI open at any one time.</p><p>To do this, we'll need to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Choose a unique name for our window</li><li class="listitem" style="list-style-type: disc">Before creating the window, check to see whether one already exists with that name</li><li class="listitem" style="list-style-type: disc">If there's already a window by that name, delete it</li><li class="listitem" style="list-style-type: disc">Create the window using the window command, passing in the name</li></ul></div><p>When <a id="id45" class="indexterm"/>choosing a name, make sure that it's something that is unlikely to conflict with other scripts the user might be using. Generic names such as <code class="literal">"MyWindow"</code> or <code class="literal">"MainWindow"</code> are likely to cause conflicts; it is much better to have something unique like <code class="literal">"CharacterRigControl"</code>. To make it even better, add your initials, or the initials of your company to the start of the name (<code class="literal">"ahCharacterRig"</code>, for example). Note that the name (which is not shown to the user) is distinct from the title (which is), so it's perfectly fine to have a long or unwieldy name. Just make sure that it's unique.</p><p>Once you <a id="id46" class="indexterm"/>have a name, we'll want to start off by testing to see if a window by that name exists. We can do that with the window command and the <code class="literal">exists</code> flag. If we <span class="emphasis"><em>do</em></span> find that a window of that name exists, we'll want to get rid of it with the <code class="literal">deleteUI</code> command:</p><div class="informalexample"><pre class="programlisting">    if (cmds.window("ahExampleWindow", exists=True)):
        cmds.deleteUI("ahExampleWindow")</pre></div><p>Finally, when we create a new window, we'll make sure to pass in our desired name as the first argument, which will give the window the desired name.</p><div class="informalexample"><pre class="programlisting">myWin = cmds.window("ahExampleWindow", title="Simple Window", widthHeight=(300, 200))</pre></div><p>Alternatively, we could just stop the script if there's already a window with the given name, but the previously mentioned approach is more common. If the user invokes your script, they likely want to start with a fresh slate, so replacing the old window is often the best option.</p></div></div>
<div class="section" title="Simple controls &#x2013; making a button"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Simple controls – making a button</h1></div></div></div><p>Creating a <a id="id47" class="indexterm"/>window is only the beginning. In order to create a <a id="id48" class="indexterm"/>proper interface, we'll need to both add controls, and tie them to functionality. In this example, we'll be revisiting our good friend, the <code class="literal">polyCube</code> command, and tying it to a button press.</p><p>The resulting UI (and its output) will look similar to the following:</p><div class="mediaobject"><img src="graphics/4657_02_02.jpg" alt="Simple controls – making a button"/></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec44"/>How to do it...</h2></div></div></div><p>Create a <a id="id49" class="indexterm"/>new script and name it <code class="literal">buttonExample.py</code>. Add<a id="id50" class="indexterm"/> the following code:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds
def buttonFunction(args):
    cmds.polyCube()

def showUI():
    myWin = cmds.window(title="Button Example", widthHeight=(200, 200))
    cmds.columnLayout()
    cmds.button(label="Make Cube", command=buttonFunction)
    cmds.showWindow(myWin)
showUI()</pre></div><p>Run the script, and you should see a 200 by 200 pixel window with a single button inside it. Pushing the button will create a polygonal cube with the default parameters.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec45"/>How it works...</h2></div></div></div><p>In order to trigger functionality from our UI, we'll first need to create a function to contain the functionality we want to trigger. We do that in our <code class="literal">buttonFunction</code> function:</p><div class="informalexample"><pre class="programlisting">def buttonFunction(*args):
    cmds.polyCube()</pre></div><p>In this<a id="id51" class="indexterm"/> case, all we're doing is creating a polygonal cube. Note that the function accepts arguments, even<a id="id52" class="indexterm"/> though we aren't making use of them. That's actually necessary, since when Maya triggers a function from a control, it passes information to the respective function. Assume that we write the function without arguments, as follows:</p><div class="informalexample"><pre class="programlisting">def buttonFunction():
    cmds.polyCube()</pre></div><p>We would get the following error when we attempted to run our script: </p><div class="informalexample"><pre class="programlisting"># Error: buttonFunction() takes no arguments (1 given)</pre></div><p>There are situations where we'll want to make use of the information that gets passed in, but even if we fully intend to ignore it, we <span class="emphasis"><em>must</em></span> write our UI-driven functions to accept arguments.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>The <code class="literal">*args</code> syntax is a bit of handy Python that allows for a variable number of arguments to be passed in. Technically, all that really matters is the <code class="literal">*</code>; <code class="literal">*myEpicCollectionOfArguments</code> would work just as well, but <code class="literal">*args</code> is the general convention.</p></div></div><p>Once we have the function we want to trigger, we set up a window in the conventional way, creating it and adding a <code class="literal">columnLayout</code>:</p><div class="informalexample"><pre class="programlisting">def showUI():
    myWin = cmds.window(title="Button Example", widthHeight=(200, 200))
    cmds.columnLayout()</pre></div><p>Next, we add the button itself with:</p><div class="informalexample"><pre class="programlisting">    cmds.button(label="Make Cube", command=buttonFunction)</pre></div><p>This is pretty straightforward—we set the text that appears within the button with the <code class="literal">label</code> argument, and we set the command to execute when it is pressed with the <code class="literal">command</code> (or "c") argument. Note that there are no parentheses after the name of the function. That's because we're not actually invoking the function; we're just passing the function itself in as the value for the command flag. We include parentheses, as in:</p><div class="informalexample"><pre class="programlisting">    cmds.button(label="Make Cube", command=buttonFunction())    # (usually) a bad idea</pre></div><p>This would result in the function being invoked, and its return value (rather than the function itself) being used as the value of the flag. That's almost certainly not what you want. The only <a id="id53" class="indexterm"/>exception is if you happen to have a function that creates a function and returns it, which can be useful in some situations.</p><p>All that's left is to show our window in the normal way with:</p><div class="informalexample"><pre class="programlisting">    cmds.showWindow(myWin)</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec46"/>There's more...</h2></div></div></div><p>While this is <a id="id54" class="indexterm"/>the most common way to use buttons, there are a few other options that can be useful in specific circumstances.</p><p>For example, the <code class="literal">enable</code> flag can be a great way to prevent the user from taking action that they shouldn't be able to  and to provide feedback. Let's say that we've created a button, but it shouldn't be active until the user takes some other action. If we set the enable flag to False, the button will appear grayed out and will not respond to the user input:</p><div class="informalexample"><pre class="programlisting">myButton = cmds.button(label="Not Yet", enable=False)</pre></div><p>Later, you can make the button (or other control) active by using the edit mode to set the enable flag to True, as in the following:</p><div class="informalexample"><pre class="programlisting">cmds.button(myButton, edit=True, enable=True)</pre></div><p>Keeping controls inactive, until it's appropriate to call them, can be a great way to make your scripts a bit more robust and easier to use.</p></div></div>
<div class="section" title="Retrieving input from controls"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Retrieving input from controls</h1></div></div></div><p>While <a id="id55" class="indexterm"/>you will often need to add one-way controls (such as buttons) that trigger functions upon user input, you will also often need to<a id="id56" class="indexterm"/> retrieve information from the user before taking an action. In this example, we'll be looking at how to grab input from field controls, in both integer and float varieties.</p><p>The finished script will create a given number of polygonal spheres, each with a given radius. The resulting UI will look like the following:</p><div class="mediaobject"><img src="graphics/4657_02_03.jpg" alt="Retrieving input from controls"/></div><p>Pressing<a id="id57" class="indexterm"/> the <span class="strong"><strong>Make Spheres</strong></span> button with the <a id="id58" class="indexterm"/>previously mentioned settings of 4 spheres at a radius of 0.5 units each will result in a line of spheres along the x-axis:</p><div class="mediaobject"><img src="graphics/4657_02_04.jpg" alt="Retrieving input from controls"/></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec47"/>How to do it...</h2></div></div></div><p>Create a new script and name it <code class="literal">makeSpheres.py</code>. Add the following code:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds

global sphereCountField
global sphereRadiusField

def showUI():
    global sphereCountField
    global sphereRadiusField

    myWin = cmds.window(title="Make Spheres", widthHeight=(300, 200))
    cmds.columnLayout()
    sphereCountField = cmds.intField(minValue=1)
    sphereRadiusField = cmds.floatField(minValue=0.5)
    cmds.button(label="Make Spheres", command=makeSpheres)
    cmds.showWindow(myWin)

def makeSpheres(*args):
    global sphereCountField
    global sphereRadiusField

    numSpheres = cmds.intField(sphereCountField, query=True, value=True)
    myRadius = cmds.floatField(sphereRadiusField, query=True, value=True)

    for i in range(numSpheres):
        cmds.polySphere(radius=myRadius)
        cmds.move((i * myRadius * 2.2), 0, 0)

showUI()</pre></div><p>Run the <a id="id59" class="indexterm"/>script, enter some values into the <a id="id60" class="indexterm"/>two fields, and click on the button. You should see a nice orderly line of polygonal spheres running along the x-axis.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec48"/>How it works...</h2></div></div></div><p>There are a few different things going on here, all of which are needed to grab information from the user. First, we create two variables to hold global references to our controls.</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds

sphereCountField
sphereRadiusField</pre></div><p>We need variables for the fields since we'll need to call the corresponding functions twice—once <a id="id61" class="indexterm"/>in the create mode (to make the control) and again in the query mode to determine what the current value is. We'll also want to make those variables global in scope so that we can have separate functions to create UI and actually perform the action.</p><p>The "scope" of a <a id="id62" class="indexterm"/>variable or a function refers to the context in which it is defined. If a variable is defined outside of any function, it is <span class="emphasis"><em>global</em></span> in scope, meaning that it is always accessible. Variables defined within a function, however, are <span class="emphasis"><em>local</em></span>, meaning that they only exist within the function in which they are defined. Since we need to refer to our controls from two different functions, we'll need to make sure that they are global in scope.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>It isn't strictly necessary to have the variables declared at the top of the script as I've done here. We <span class="emphasis"><em>could</em></span> just refer to them in the individual functions, and as long as we're careful to include the global keyword, it would still work.</p><p>However, I think that it makes things much easier to understand if we declare all our global variables at the start.</p></div></div><p>Next, we set up UI for the window. Note that we repeat the lines that we used to declare the global variables. This is necessary to tell Python that we want to use the global scope variables:</p><div class="informalexample"><pre class="programlisting">def showUI():
    global sphereCountField
    global sphereRadiusField</pre></div><p>If we left out the <code class="literal">global sphereCountField</code>, we would still end up with a variable named <code class="literal">sphereCountField</code> set to the output of the intField command. However, that variable would be of local scope and only available from within the <code class="literal">showUI()</code> function.</p><p>In this case, <code class="literal">global sphereCountField</code> can almost be thought of as an import statement because it brings the global variable into the scope of the showUI function. We do the same thing in the <code class="literal">makeSpheres</code> function to make sure that we use the same variable.</p><p>Next, we set up a window as we've done in the past, with the <code class="literal">window()</code> and <code class="literal">columnLayout()</code> commands:</p><div class="informalexample"><pre class="programlisting">    myWin = cmds.window(title="Make Spheres", widthHeight=(300, 200))
    cmds.columnLayout()</pre></div><p>Once we've done this, we can use two fields to collect input from the user. Since the number of spheres should always be a whole number value, and we should always make at least one sphere, we use an <code class="literal">intField</code> and set the minimum value to 1:</p><div class="informalexample"><pre class="programlisting">    sphereCountField = cmds.intField(minValue=1)</pre></div><p>For the<a id="id63" class="indexterm"/> radius of the spheres, we'll want to allow <a id="id64" class="indexterm"/>for non-integer values, but we likely want to ensure a reasonable minimum size. To do this, we create a <code class="literal">floatField</code> with a minimum value of 0.5. We have the following code:</p><div class="informalexample"><pre class="programlisting">sphereRadiusField = cmds.floatField(minValue=0.5)</pre></div><p>Finally, we add a button to trigger the creation of the spheres and show the window with the <code class="literal">showWindow()</code> command.</p><p>Moving to the function to create the spheres, we start by (once again) telling Python that we want to make use of our two global variables, as follows:</p><div class="informalexample"><pre class="programlisting">def makeSpheres(*args):
    global sphereCountField
    global sphereRadiusField</pre></div><p>Once we've done this, we retrieve the current values of the <code class="literal">intField</code> and <code class="literal">floatField</code>. In both cases, we do that by rerunning the same command that we used to create the control, but with the following differences:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We pass the name of the control (saved when we created it) as the first argument.</li><li class="listitem">We set <code class="literal">query=True</code> to indicate to Maya that we want to retrieve information about the control.</li><li class="listitem">We set <code class="literal">value=True</code> to indicate that the specific attribute that we want to retrieve is the control's value.</li></ol></div><p>Putting that all together give us the following:</p><div class="informalexample"><pre class="programlisting">numSpheres = cmds.intField(sphereCountField, query=True, value=True)
myRadius = cmds.floatField(sphereRadiusField, query=True, value=True)</pre></div><p>It may seem better to combine the two lines into the following:</p><div class="informalexample"><pre class="programlisting">global numSpheres = cmds.intField(sphereCountField, query=True, value=True)</pre></div><p>However, that doesn't actually work, owing to the way that Python works with global variables. Python requires that the declaration of a global variable remains separate from any commands that set the value of the variable.</p><p>Once we know how many spheres to create and how big to make each of them, we use a for loop to make and position them:</p><div class="informalexample"><pre class="programlisting">    for i in range(numSpheres):
        cmds.polySphere(radius=myRadius)
        cmds.move((i * myRadius * 2.2), 0, 0)</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>For loops allow you to repeat the same code multiple times. Python implements them slightly differently than most other languages in which they always iterate over a list of some kind. This means that if we want to do something X times, we have to have a list of X items. For this, we'll want the built-in <code class="literal">range()</code> function. By passing <code class="literal">numSpheres</code> into <code class="literal">range()</code>, we are asking Python to create a list of numbers that starts at 0 and goes up to (numSpheres-1). We can then use that list with the for keyword to set our index variable (i) to each of the values in our list, which in this case means stepping from 0 to (numSpheres-1).</p></div></div><p>Note<a id="id65" class="indexterm"/> that we set the radius of each sphere with the radius flag. We also use the move function to separate each sphere from its neighbors<a id="id66" class="indexterm"/> by slightly more than their diameters (myRadius * 2.2). By default, the move command will affect the currently selected object (or objects). Since the <code class="literal">polySphere</code> command leaves the created sphere as the only selected object, that's what we'll move.</p><p>By default, the move command will accept three numbers for the amount by which to move the selected object(s)—one for each of the axes. There are a number of other ways that the move command can be used; be sure to check the documentation for details.</p></div></div>
<div class="section" title="Using classes to organize UI logic"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Using classes to organize UI logic</h1></div></div></div><p>Using <a id="id67" class="indexterm"/>global variables is one way to allow the different parts of your script communicate with each other, but there's a better way. Instead of using globals, you can organize your script using custom class.</p><p>Creating a <a id="id68" class="indexterm"/>class for your script will not only allow you to easily access UI elements from various functions, but it will also make it easy to neatly contain other kinds of data, useful in more advanced scripts.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec49"/>How to do it...</h2></div></div></div><p>Create a new script and name it <code class="literal">SpheresClass.py</code>. Add the following code:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds

class SpheresClass:

    def __init__(self):
        self.win = cmds.window(title="Make Spheres", widthHeight=(300,200))
        cmds.columnLayout()
        self.numSpheres = cmds.intField(minValue=1)
        cmds.button(label="Make Spheres", command=self.makeSpheres)
        cmds.showWindow(self.win)

    def makeSpheres(self, *args):
        number = cmds.intField(self.numSpheres, query=True, value=True)
        for i in range(0,number):
            cmds.polySphere()
            cmds.move(i*2.2, 0, 0)

SpheresClass()</pre></div><p>Run the <a id="id69" class="indexterm"/>script, and you should get a window <a id="id70" class="indexterm"/>that allows you to create a line of polygonal spheres along the x-axis.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec50"/>How it works...</h2></div></div></div><p>The overall layout of the script is similar to what we've done before, in that we have one function to set up the interface and another function to actually perform the work. However, in this case, we wrap everything in a class, with:</p><div class="informalexample"><pre class="programlisting">class SpheresClass:</pre></div><p>Note that the name of the class has been capitalized, which may seem odd, given that all of our functions have been lowercase so far. Although that's by no means required, it's generally common practice to capitalize class names, as it helps to distinguish classes from functions. Otherwise, invoking a function can look very similar to instantiating a class, leading to confusion. We have the following code:</p><div class="informalexample"><pre class="programlisting">myResult = myFunction()   # run a function and store the result in myResult
myInstance = MyClass()	#   create a new instance of the MyClass class and name it
# myInstance</pre></div><p>Instantiating a class means that you create a brand new copy of that class, and the new copy is referred to as an "instance" of the class. Defining a class and instantiating it are two separate actions. The entire block of code that starts with the "class" keyword makes up the class definition and defines all of the attributes and capabilities of a class. It can be thought of as the blueprint for that class. However, to actually make use of a class, we have to actually create one. Once you've defined a class, you can make as many instances as you want, each with their own properties. The class definition is like the CAD files for a product, whereas the instance is like the actual physical product that rolls off the assembly line.</p><p>Once we have a class, we can add functionality to it by adding functions. We have to at least create a function named <code class="literal">__init__</code> that will be responsible for initializing each class instance. This <a id="id71" class="indexterm"/>function will be called automatically each time an instance of the class is called.</p><p>Note that<a id="id72" class="indexterm"/> the <code class="literal">__init__</code> function takes one argument, which we've labeled "self". When Python instantiates a class, it always passes a reference to the instance itself to all of the member functions. We could call it anything we want, but "self" is the convention and one that we'll adhere to.</p><p>In the <code class="literal">__init__</code> function, we'll do everything we need to do to set up out UI. In this case, we'll create one field and one button. We store references to the field in an instance variable as properties of the self-object (which remember, is just the class instance itself). Doing this will allow us to retrieve the values of the controls later in the script:</p><div class="informalexample"><pre class="programlisting">        self.numSpheres = cmds.intField(minValue=1)</pre></div><p>Similarly, when we want to tie our controls to actual functionality, we'll need to preface our functions with "self." to refer to the method of our class. We do this with the button code in the next line:</p><div class="informalexample"><pre class="programlisting">cmds.button(label="Make Spheres", command=self.makeSpheres)</pre></div><p>Setting variables as properties of the class via self will make them accessible to other functions within the class. Note that we stored a reference to the field, but not to the button; this is because we're not likely to want to query anything about the button or to change anything about it after it's been created. In such cases, it's fine to just use local variables or to not store the results at all.</p><p>Once we have both our field and our button, we show the window. Now we're ready to add the <code class="literal">makeSpheres</code> function:</p><div class="informalexample"><pre class="programlisting">    def makeSpheres(self, *args):</pre></div><p>Note that the function signature includes "self" as the first argument and has "*args", our catch-all for any passed values as the second argument. This is another example of how Python passes the class instance into all of its member functions each time they are called.</p><p>The rest of the code for the <code class="literal">makeSpheres</code> function is very similar to what we wrote in the non-class-based example. We use the query mode to retrieve the number in the <code class="literal">intField</code>, then we make that many spheres, moving each one by the corresponding multiple of the radius to space them out nicely.</p><div class="informalexample"><pre class="programlisting">number = cmds.intField(self.numSpheres, query=True, value=True)
for i in range(0,number):
    cmds.polySphere()
    cmds.move(i*2.2, 0, 0)</pre></div><p>And with<a id="id73" class="indexterm"/> this, we're done defining our class. However, we also need to actually create an instance of it in order to see anything happen. The last line of the script does exactly this: </p><div class="informalexample"><pre class="programlisting">SpheresClass()</pre></div><p>This creates a <a id="id74" class="indexterm"/>new instance of our <code class="literal">SpheresClass</code> class and, in so doing, runs the <code class="literal">__init__</code> function, which in turn, sets up our UI and shows it to the user.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec51"/>There's more...</h2></div></div></div><p>
<span class="strong"><strong>Object-oriented programming</strong></span> (<span class="strong"><strong>OOP</strong></span>) is<a id="id75" class="indexterm"/> a huge topic, and a full treatment of all of the ins and outs is beyond the scope of this book. It's also something you're likely to be familiar with if you've been using Python (or any other object-oriented language) for any length of time.</p><p>If this is the first time you're seeing it, be sure to read through the Python documentation on classes. OOP practices may seem like a lot of unnecessary overhead at first, but they ultimately make it much easier to tackle complex problems.</p></div></div>
<div class="section" title="Using nested layouts"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Using nested layouts</h1></div></div></div><p>Very<a id="id76" class="indexterm"/> often, the<a id="id77" class="indexterm"/> interfaces that you'll want to create cannot be implemented with a single layout. In those cases, you'll need to nest layouts inside each other.</p><p>In this example, we'll create <code class="literal">rowLayouts</code> within a single columnLayout. Each <code class="literal">rowLayout</code> will allow us to have two controls (in this case, some text and <code class="literal">intField</code>) next to each other horizontally, and the parent <code class="literal">columnLayout</code> will stack the combined text/field pairs on top of each other vertically.</p><p>The end result will be something like this:</p><div class="mediaobject"><img src="graphics/4657_02_05.jpg" alt="Using nested layouts"/></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec52"/>How to do it...</h2></div></div></div><p>Make a<a id="id78" class="indexterm"/> new<a id="id79" class="indexterm"/> script and name it <code class="literal">nestedLayouts.py</code>. Add the following code:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds

class NestedLayouts:

    def __init__(self):
        self.win = cmds.window(title="Nested Layouts", widthHeight=(300,200))
        cmds.columnLayout()
        
        cmds.rowLayout(numberOfColumns=2)
        cmds.text(label="Input One:")
        self.inputOne = cmds.intField()
        cmds.setParent("..")
        
        cmds.rowLayout(numberOfColumns=2)
        cmds.text(label="Input Two:")
        self.inputTwo = cmds.intField()
        cmds.setParent("..")
        
        cmds.showWindow(self.win)

NestedLayouts()</pre></div><p>Run the script, and you should see two rows, each with a bit of text and an <code class="literal">intField</code>.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec53"/>How it works...</h2></div></div></div><p>In this <a id="id80" class="indexterm"/>example, we start out by creating a <code class="literal">columnLayout</code>, just as we've done in other examples so far. Then, we immediately create another layout, and this time, it is a rowLayout:</p><div class="informalexample"><pre class="programlisting">    cmds.columnLayout()
    
    cmds.rowLayout(numberOfColumns=2)</pre></div><p>When you <a id="id81" class="indexterm"/>create a layout, it immediately becomes the default parent for any other elements (either controls or other layouts) that you create. So, in this case, we have a columnLayout that contains a two-column rowLayout.</p><p>Once we've done this, we can add elements to our rowLayout, which we do with the following lines:</p><div class="informalexample"><pre class="programlisting">        cmds.text(label="Input One:")
        self.inputOne = cmds.intField()</pre></div><p>At this point, our first rowLayout is filled because we created it with two columns and we've added two controls to it. If we attempt to add another control, we'll get an error similar to the following:</p><div class="informalexample"><pre class="programlisting"># Error: RuntimeError: file /nestedLayouts.py line 13: Too many children in layout: rowLayout21</pre></div><p>In order to continue to add elements to our UI, we'll need to jump up a level back to the <code class="literal">columnLayout</code>. At any given moment, there is exactly one and only one default parent to which Maya will add controls to. Every time you create a new layout, it becomes the default parent automatically. Sometimes, you'll need to change the default parent directly, which can be accomplished with the <code class="literal">setParent</code> command, as in the following:</p><div class="informalexample"><pre class="programlisting">        cmds.setParent("..")</pre></div><p>Using <code class="literal">setParent</code> and passing <code class="literal">".."</code> as the argument will move up a single level in the hierarchy of layouts. In this case, it means that we move up from the rowLayout back to the columnLayout. Once we've done this, we can create the second rowLayout, again with two columns. We are then free to add a second group of a text field and an int field:</p><div class="informalexample"><pre class="programlisting">cmds.setParent("..") # move one level up the UI hierarchy

cmds.rowLayout(numberOfColumns=2)  # add a second rowLayout
cmds.text(label="Input Two:")      # add a text control to the row
self.inputTwo = cmds.intField()    # add an intField to the row</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec54"/>There's more...</h2></div></div></div><p>Jumping<a id="id82" class="indexterm"/> around the hierarchy can get a bit tedious. If <a id="id83" class="indexterm"/>you're going to have a number of controls that you want to add label text to, it might be best to create a helper function to your script's class to add a new control.</p><p>Here's an example of what that might look like:</p><div class="informalexample"><pre class="programlisting">    def addLabeledIntField(self, labelText):
        cmds.rowLayout(numberOfColumns=2)
        cmds.text(label=labelText)
        newField = cmds.intField()
        cmds.setParent("..")
        return newField</pre></div><p>Here, we take in the text to use for the label, and we return a reference to the newly created intField. Rewriting our example using the above would give us something like the following:</p><div class="informalexample"><pre class="programlisting">    def __init__(self):
        self.win = cmds.window(title="Nested Layouts", widthHeight=(300,200))
        cmds.columnLayout()

        self.inputThree = self.addLabeledIntField("Input Three")
        self.inputFour = self.addLabeledIntField("Input Four")

        cmds.showWindow(self.win)</pre></div><p>This is quite a bit neater, indeed.</p><p>Note that our addLabeledIntField accepts two arguments, but we only pass a single one to it when we call it. This is due to the way that Python handles classes; every class method <span class="emphasis"><em>always</em></span> receives a reference to the class itself. So, any arguments that we want to make use of start at the second one.</p></div></div>
<div class="section" title="Using tabs and scrolling"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Using tabs and scrolling</h1></div></div></div><p>In this<a id="id84" class="indexterm"/> example, we'll be looking at how to create UIs that contain tabs and how to provide scrollable containers.</p><p>Our<a id="id85" class="indexterm"/> UI will <a id="id86" class="indexterm"/>contain two tabs arranged<a id="id87" class="indexterm"/> horizontally, with each tab containing a scrollable column of 20 buttons. The final result will look something like this:</p><div class="mediaobject"><img src="graphics/4657_02_06.jpg" alt="Using tabs and scrolling"/></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec55"/>How to do it...</h2></div></div></div><p>Create <a id="id88" class="indexterm"/>a <a id="id89" class="indexterm"/>new script, name it <code class="literal">tabExample.py</code> and add<a id="id90" class="indexterm"/> the <a id="id91" class="indexterm"/>following code:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds

class TabExample:

    def __init__(self):
        self.win = cmds.window(title="Tabbed Layout", widthHeight=(300, 300))

        self.tabs = cmds.tabLayout()

        # add first tab
        firstTab = cmds.columnLayout()
        cmds.tabLayout(self.tabs, edit=True, tabLabel=[firstTab, 'Simple Tab'])
        cmds.button(label="Button")
        cmds.setParent("..")

        # add second tab, and setup scrolling
        newLayout = cmds.scrollLayout()
        cmds.tabLayout(self.tabs, edit=True, tabLabel=[newLayout, 'Scrolling Tab'])
        cmds.columnLayout()

        for i in range(20):
            cmds.button(label="Button " + str(i+1))

        cmds.setParent("..")
        cmds.setParent("..")

        cmds.showWindow(self.win)

TabExample()</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec56"/>How it works...</h2></div></div></div><p>Creating a<a id="id92" class="indexterm"/> tab layout is quite easy; all that's required is a call to the <code class="literal">tabLayout</code> function.</p><div class="informalexample"><pre class="programlisting">self.tabs = cmds.tabLayout()</pre></div><p>Note that we <a id="id93" class="indexterm"/>save the output of the <code class="literal">tabLayout</code> command to an instance variable, and we'll need that later. So now we have the tab layout, but we're still not ready to add any controls just yet. That's because the tab layout cannot actually contain controls directly; it is only meant to hold other layouts.</p><p>For the first tab, we'll keep it simple and just add a <code class="literal">columnLayout</code>:</p><div class="informalexample"><pre class="programlisting">firstTab = cmds.columnLayout()</pre></div><p>Note that we <a id="id94" class="indexterm"/>also store the output, which in this case is the name of the column layout (something like "columnLayout17" or similar). Now we can start adding controls if we want, but there's one more thing we'll want to do first.</p><p>By default, the <a id="id95" class="indexterm"/>text that is displayed in the actual tab of the tabbed layout will be the name of the child layout. This will almost never be what you want; you'll generally want to give your tabs nice, sensible labels instead of leaving them with names like "columnLayout23" and "scrollLayout19".</p><p>To do this, we'll need to edit our tab layout and use the <code class="literal">tabLabel</code> argument. The <code class="literal">tabLabel</code> argument expects a two-element array of strings, where the first string is the name of a child of the tab layout (in this case, our column layout), and the second is the text you want to display. Putting this all together gives us the following:</p><div class="informalexample"><pre class="programlisting">cmds.tabLayout(self.tabs, edit=True, tabLabel=[firstTab, 'Simple Tab'])</pre></div><p>We invoke the tabLayout command in the edit mode, direct it at our tab layout (which we stored in the <code class="literal">self.tabs</code> variable) and set the input to tabLabel such that we give our columnLayout the label of "Simple Tab".</p><p>Next, we add a single button, just so that we have something inside the tab:</p><div class="informalexample"><pre class="programlisting">cmds.button(label="Button")</pre></div><p>At this point, we're done with the first tab and ready to start on the second tab. But before we can do this, we need to jump up a level in the hierarchy so that we can add new content to the tab layout, rather than continuing to add to the column layout we created within it. We do this with the <code class="literal">setParent</code> command:</p><div class="informalexample"><pre class="programlisting">cmds.setParent("..")</pre></div><p>Now we're <a id="id96" class="indexterm"/>ready to start on our second tab. This time, we'll add a scroll layout as follows:</p><div class="informalexample"><pre class="programlisting">newLayout = cmds.scrollLayout()</pre></div><p>Once again, we'll <a id="id97" class="indexterm"/>edit the original tab layout so that the second tab has a proper name.</p><div class="informalexample"><pre class="programlisting">cmds.tabLayout(self.tabs, edit=True, tabLabel=[newLayout, 'Scrolling Tab'])</pre></div><p>To finish <a id="id98" class="indexterm"/>things off, we'll create a column layout within the scroll layout and add some buttons.</p><div class="informalexample"><pre class="programlisting">    cmds.columnLayout()

    for i in range(20):
        cmds.button(label="Button " + str(i+1))</pre></div><p>Finally, we'll use setParent twice (once for the column layout and again for the scroll layout) to move back up the hierarchy to the tab layout:</p><div class="informalexample"><pre class="programlisting">    cmds.setParent("..")
    cmds.setParent("..")</pre></div><p>We're now ready to add more tabs, if we want.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec57"/>There's more...</h2></div></div></div><p>If you ever need <a id="id99" class="indexterm"/>to know which tab is currently selected, you can find out via the <code class="literal">selectTabIndex</code> or sti flag. One gotcha to be aware of is that the number returned is indexed based on 1, rather than 0 as you might expect. If you <span class="emphasis"><em>do</em></span> receive zero, it means that the tab layout in question doesn't have any children:</p><div class="informalexample"><pre class="programlisting">currTab = cmds.tabLayout(self.tabs, query=True, selectTabIndex=True)</pre></div><p>You can also use the <code class="literal">selectTabIndex</code> to set which tab is currently active. For example, if we wanted to ensure that our example started out with the second tab selected, we could add the following line to our <code class="literal">__init__</code> function:</p><div class="informalexample"><pre class="programlisting">cmds.tabLayout(self.tabs, edit=True, selectTabIndex=2)</pre></div><p>When building complex UIs, having the ability to change behavior based on what part of the interface is currently active, or to start the script with a different part showing, can be a great way to make your scripts more responsive and easier to use.</p></div></div>
<div class="section" title="Adding menus to your UIs"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Adding menus to your UIs</h1></div></div></div><p>For more<a id="id100" class="indexterm"/> complex scripts, it can be helpful to add a drop-down menu to the top of your window. For example, you might want to have your script support <a id="id101" class="indexterm"/>custom configuration files and allow users to both save the current settings to disk, or to load previously saved settings. In that case, implementing the <span class="strong"><strong>File</strong></span> menu with suboptions for <span class="strong"><strong>Save</strong></span> and <span class="strong"><strong>Load</strong></span> could be a very user-friendly option.</p><p>In this example, we'll be creating a window with its own menu, as well as looking at how to offer the user additional options via an option box, just like Maya's built-in menus.</p><div class="mediaobject"><img src="graphics/4657_02_07.jpg" alt="Adding menus to your UIs"/></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec58"/>How to do it...</h2></div></div></div><p>Create a new script and name it <code class="literal">customMenu.py</code>. Once again, we'll be creating a custom class to handle both our UI creation and functionality:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds

class CustomMenu:

    def __init__(self):
        self.win = cmds.window(title="Menu Example", menuBar=True, widthHeight=(300,200))

        fileMenu = cmds.menu(label="File")
        loadOption = cmds.menuItem(label="Load")
        saveOption = cmds.menuItem(label="Save")
        cmds.setParent("..")

        objectsMenu = cmds.menu(label="Objects")
        sphereOption = cmds.menuItem(label="Make Sphere")
        cubeOption = cmds.menuItem(label="Make Cube")
        cmds.setParent("..")

        cmds.columnLayout()
        cmds.text(label="Put the rest of your interface here")

        cmds.showWindow(self.win)

CustomMenu()</pre></div><p>If you run this <a id="id102" class="indexterm"/>code, you'll get a window with a two-item menu (<span class="strong"><strong>File</strong></span> and <span class="strong"><strong>Objects</strong></span>), each one of which provides two options.</p><p>To actually<a id="id103" class="indexterm"/> have something happen when the user selects an option, we'll need to provide a value for the command flag for one or more of our menuItem controls, as in the following (some of the preceding code has been removed to make the example shorter):</p><div class="informalexample"><pre class="programlisting">    def __init__(self):

        # set up the window and add any additional menu items
        # before the Objects menu 

        objectsMenu = cmds.menu(label="Objects")
        sphereOption = cmds.menuItem(label="Make Sphere", command=self.makeSphere)
        cubeOption = cmds.menuItem(label="Make Cube", command=self.makeCube)
        cmds.setParent("..")

        # continue with the rest of the interface, and end with
        # cmds.showWindow()

    def makeSphere(self, *args):
        cmds.polySphere()

    def makeCube(self, *args):
        cmds.polyCube()</pre></div><p>This would <a id="id104" class="indexterm"/>enable both of the <span class="strong"><strong>Make Sphere</strong></span> and <span class="strong"><strong>Make Cube</strong></span> menu items to create the respective polygonal geometry.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec59"/>How it works...</h2></div></div></div><p>Creating menus is pretty easy, and it is mainly just required that you:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Include the <code class="literal">menuBare=True</code> option when creating the initial window.</li><li class="listitem">Add one or more menus with the <code class="literal">menu()</code> command.</li><li class="listitem">For each menu, add one or more menuItem controls, providing a command for each.</li></ol></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec60"/>There's more...</h2></div></div></div><p>Many of <a id="id105" class="indexterm"/>Maya's commands offer the user two ways to trigger them—the default way and via the command's corresponding option box, which offers the user additional options for the command. You can do the same thing with your own menus by adding the second menuItem directly after the one to which you want to add an option box and setting the second menuItem's <code class="literal">optionBox</code> flag to true.</p><p>Let's say that we want to offer a command to create a polygonal sphere. We want the default radius to be 1 unit, but we also want to provide an option box, which when selected, will allow the user to specify a custom radius. To do this, we would want to add something like the following to our script:</p><div class="informalexample"><pre class="programlisting">        self.menu = cmds.menu(label="Objects")
        sphereCommandMI = cmds.menuItem(label="Make a Sphere", command=self.myCommand)
        sphereCommandMIOption = cmds.menuItem(optionBox=True, command=self.myCommandOptions)</pre></div><p>Even though we're creating two menuItem controls, they would be presented to the user as a single entry in the <code class="literal">"Objects"</code> menu though one with an option box. When you add the <code class="literal">optionBox=True</code> flag to a menuItem control, Maya will add an option to the most recently created menuItem. Creating menuItem and setting <code class="literal">optionBox=True</code> without first creating a normal menuItem will leave Maya without anything to add the option box to and will result in an error.</p><p>This may seem a bit odd, but it makes a bit of sense since the default command and the option box are two separate clickable areas, so it's not totally unreasonable to implement them as separate controls.</p><p>Once we've set up the two controls, we'll want to make sure that they both do similar things, but one of them (the option box) provides additional input. An easy way to do it is with the <code class="literal">promptDialog</code> command, which provides an easy way to get a single value from the user. To ask the user to input a value for the sphere's radius, we could do the following:</p><div class="informalexample"><pre class="programlisting">promptInput = cmds.promptDialog(title="Sphere Radius",   message='Specify Radius:', button=['OK', 'CANCEL'], defaultButton='OK', cancelButton='CANCEL', dismissString='CANCEL')</pre></div><p>The preceding <a id="id106" class="indexterm"/>code would result in a new popup window with a single field and two buttons labeled <span class="strong"><strong>OK</strong></span> and <span class="strong"><strong>CANCEL</strong></span>. You'll note that we're storing the result of the promptDialog to a variable named promptInput.</p><p>You <a id="id107" class="indexterm"/>might think that this variable would hold the value that the user has entered, but that would be incorrect. Instead, it holds the value of the button that they pressed to dismiss the dialog. That probably seems strange, but it's necessary so that we can determine if the user has actually finalized the command or if they are decided to be canceled.</p><p>To actually make use of the input, we'll want to start by checking to see whether the user did, in fact, press the <span class="strong"><strong>OK</strong></span> button. The promptDialog will return one of the two values:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">If the user pressed one of the buttons, the return value will be the text associated with that button.</li><li class="listitem">If the dialog was dismissed in some other way (like by clicking the X), whatever was provided as the dismissString will be returned.</li></ol></div><p>In our example, if the user pressed one of the buttons, we will have either <span class="strong"><strong>OK</strong></span> or <span class="strong"><strong>CANCEL</strong></span> as the return value. Notice that we've also set the dismissString to <span class="strong"><strong>CANCEL</strong></span> as well. So, all we have to do is to check to see whether <span class="strong"><strong>OK</strong></span> was returned, as in:</p><div class="informalexample"><pre class="programlisting">if (promptInput == 'OK'):</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>Note that there are <code class="literal">two</code> equals signs, not one. This is a common source of error when people are new to Python. The key thing to remember is that a single equals sign always results in an <code class="literal">assignment</code>, and that you need to use two equals signs to perform a check for equality. This is true in many languages (not just Python) and stems from the fact that setting a variable to a given value is a very different operation than checking two values against each other. Since they are two different actions, Python (and most other languages) signifies each in a different way—one equals for assignment and two for comparison.</p></div></div><p>If that check passes, then we know that the user pressed <span class="strong"><strong>OK</strong></span> and that we should grab the input value. We'll have to do that in a slightly different way than we have previously though. In the other examples, we've saved a reference to the created control and used that to specify the control when using the query mode to grab the value.</p><p>In this case, however, the <code class="literal">promptDialog</code> command returns the button pressed, rather than a reference to its field. So how are we to refer to the proper control?</p><p>As it turns out, we <a id="id108" class="indexterm"/>can just use the <code class="literal">promptDialog</code> command the second time, but in the query mode. Even though we don't specify the specific <code class="literal">promptDialog</code> to query, it will still work since Maya will default to the one that was most recently created. Since we're grabbing the value immediately after creating the dialog, this will work just fine. Putting that all together, gives us the following:</p><div class="informalexample"><pre class="programlisting">        if (promptInput == 'OK'):
            radiusInput = cmds.promptDialog(query=True, text=True)
            self.makeSphere(radiusInput)</pre></div><p>Note that we<a id="id109" class="indexterm"/> have to query "text" rather than "value". Also note that once we have the input, it gets passed to a separate function to actually do the work. This's important so that we can ensure that the exactly same code is triggered by both the default (non-option box) and option box versions of our menu item.</p><p>This may seem redundant here because we're just creating a sphere, but it's still a good idea. Don't duplicate code!</p><p>We would end up with three functions—first, to actually perform the work (in this case, creating a sphere), second, to call that function with default values (for the base menuItem), and third, to call that function after retrieving some additional information from the user. Putting all that together would give us something like this (the <code class="literal">__init__</code> method omitted for brevity):</p><div class="informalexample"><pre class="programlisting">    def myCommand(self, *args):
        self.makeSphere(1)

    def myCommandOptions(self, *args):
        promptInput = cmds.promptDialog(title="Sphere Radius", message='Specify Radius:', button=['OK', 'CANCEL'], defaultButton='OK', cancelButton='CANCEL', dismissString='CANCEL')

        if (promptInput == 'OK'):
            radiusInput = cmds.promptDialog(query=True, text=True)
            self.makeSphere(radiusInput)

    def makeSphere(self, sphereRadius):
        cmds.polySphere(radius=sphereRadius)</pre></div></div></div></body></html>