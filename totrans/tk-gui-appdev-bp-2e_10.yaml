- en: Miscellaneous Tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have reached the final chapter of this book. Let's end our discussion on
    Tkinter by looking at some concepts that, though very common in many **graphical
    user interface** (**GUI**) programs, did not appear in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Tracing Tkinter variables and attaching callbacks that are triggered when the
    value of a variable changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the default keyboard widget traversal rules to provide a consistent
    user experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating user inputs using built-in Tkinter mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting a widget's content as the user interacts with the widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how Tkinter handles fonts and the best practices involved in using
    custom fonts in Tkinter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirecting the command-line output to Tkinter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking a look at the source code of Tkinter to understand class hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highlighting some current best practices involved in program design and implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting an insight into code cleanup and program optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributing Tkinter applications as standalone programs to end users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the limitations of Tkinter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring alternatives to Tkinter and understanding when it is better to use them
    instead of Tkinter and the tradeoffs involved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backporting Tkinter programs are written in Python 3.x versions to older Python 2.x
    versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: Tracing Tkinter variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you specify a Tkinter variable, such as `textvariable`, for a widget (`textvariable
    = myvar`), the widget automatically gets updated whenever the value of the variable
    changes. However, there might be times when, in addition to updating the widget,
    you need to do some extra processing at the time of reading or writing (or modifying)
    the variable.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter provides a method to attach a callback method that will be triggered
    every time the value of a variable is accessed. Thus, the callback acts as a variable
    observer.
  prefs: []
  type: TYPE_NORMAL
- en: The callback creation method is named `trace_variable(self, mode, callback)` or
    simply `trace(self, mode, callback)`.
  prefs: []
  type: TYPE_NORMAL
- en: The mode argument can take a value of `r`, `w`, or `u`, which stand for *read*,
    *write*, or *undefined*. Depending upon the mode specifications, the callback
    method is triggered when the variable is read or written.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the callback method gets three arguments. The arguments, in order of
    their position, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the Tkinter variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The index of the variable in case the Tkinter variable is an array, otherwise,
    it's an empty string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The access modes (`r`, `w`, or `u`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the triggered callback function may also modify the value of the variable. However,
    this modification does not trigger additional callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of variable tracing in Tkinter. Take a look at how
    a change in a traced Tkinter variable triggers a callback (see code `10.01_trace_variable.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line of code attaches a callback to `trace` the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, every time you write in the entry widget, it modifies the value of `my_variable`. Because
    we have set a `trace` on `my_variable`, it triggers the callback method that, in
    our example, simply prints the new value into the console, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b57b5fec-2dd6-4a17-a180-4754bf9b2bc5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `trace` on a variable is active until it is explicitly deleted. You can
    delete a `trace` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `trace` method returns the ID and name of the callback method. This can
    be used to get the name of the callback method that needs to be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Widget traversal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a GUI has more than one widget, a given widget can come under focus when
    you explicitly click on the widget. Alternatively, the focus can be shifted to
    other widgets in the order that the widgets were created in the program by pressing
    the *Tab* key on the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it is vital to create widgets in the order that we want the user
    to traverse through them. Otherwise, the user will have a tough time navigating
    between the widgets using the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Different widgets are designed to behave differently to different keyboard strokes.
    Therefore, let's spend some time trying to understand the rules of traversing
    through widgets using the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the `10.02_widget_traversal.py` file to understand the keyboard
    traversal behavior for different widgets. The code displays a window like the
    one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b8bc194-c422-40b9-afb6-d83a68737de3.png)'
  prefs: []
  type: TYPE_IMG
- en: The code will not be given here as it is very simple (see the `10.02_widget_traversal.py` code).
    It simply adds an entry widget, a few buttons, a few radio buttons, a text widget,
    a label widget, and a scale widget.
  prefs: []
  type: TYPE_NORMAL
- en: The code demonstrates the default keyboard traversal behaviors for these widgets in
    Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a few important points that you should note:'
  prefs: []
  type: TYPE_NORMAL
- en: The *Tab* key can be used to traverse forward, and *Shift* + *Tab* can be used
    to traverse backward.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user can traverse through the widgets in the order that they were created. A
    parent widget is visited first (unless it is excluded using `takefocus = 0`), followed
    by all of its children widgets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use `widget.focus_force()` to force the input focus on a widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot traverse a text widget by using the *Tab* key because the text widget
    can contain tab characters as its content. Instead, the text widget can be traversed
    by using *Ctrl* + *Tab*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buttons on the widget can be pressed using the spacebar. Similarly, check buttons
    and radio buttons can also be traversed using the spacebar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can go up and down the items in a Listbox widget by using the up and down
    arrows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Scale widget responds to the left and right arrow keys and the up and down
    arrow keys. Similarly, the Scrollbar widget responds to the left/right or up/down
    arrow keys, depending on their orientation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, most of the widgets (except Frame, Label, and Menus) get an outline
    when they have the focus set on them. This outline is normally displayed as a
    thin black border around the widget. You can even set the Frame and Label widgets
    to show this outline by setting the `highlightthickness` option to a nonzero integer
    value for these widgets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can change the color of the outline by using `highlightcolor= 'red'` in the
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frame, Label, and Menu are not included in the tab's navigation path. However,
    they can be included in the navigation path by using the `takefocus = 1` option.
    You can explicitly exclude a widget from the tab's navigation path by using the
    `takefocus = 0` option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's discuss input data validation in Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the applications that we have developed in our book are point-and-click-based
    (the drum machine, the chess game, and the drawing application), where a validation
    of user input is not required. However, data validation is a must in programs
    such as the phone book application, where a user enters some data and we store
    it in a database.
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring user input validation can be dangerous in such applications because
    input data can be misused for SQL injection. In general, an application in which
    a user can enter textual data is a good candidate for the validation of user input.
    In fact, not trusting user inputs is almost considered a maxim.
  prefs: []
  type: TYPE_NORMAL
- en: Wrong user inputs may be intentional or accidental. In either case, if you fail
    to validate or sanitize data, unexpected errors may occur in your program. In
    a worst-case scenario, user input can be used to inject harmful code that may
    be capable of crashing a program or wiping out an entire database.
  prefs: []
  type: TYPE_NORMAL
- en: Widgets, such as Listbox, Combobox, and Radiobuttons, allow limited input options and
    hence, they normally cannot be misused to input wrong data. On the other hand, widgets
    such as the Entry widget, the Spinbox widget, and the Text widget allow a large
    possibility of user inputs, and hence, they need to be validated for correctness.
  prefs: []
  type: TYPE_NORMAL
- en: To enable validation on a widget, you need to specify an additional option of
    the `validate = 'validationmode'` form to the widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you want to enable validation on an Entry widget, you begin
    by specifying the validate option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Entry( root, validate="all", validatecommand=vcmd)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Validation can occur in one of the following validation modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Validation Mode** | **Explanation** |'
  prefs: []
  type: TYPE_TB
- en: '| `none` | This is the default mode. No validation occurs if `validate` is
    set to `none`. |'
  prefs: []
  type: TYPE_TB
- en: '| `focus` | When validate is set to focus, the `validate` command is called twice—once
    when the widget receives focus, and once when the focus is lost. |'
  prefs: []
  type: TYPE_TB
- en: '| `focusin` | The `validate` command is called when the widget receives focus.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `focusout` | The `validate` command is called when the widget loses focus.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `key` | The `validate` command is called when the entry is edited. |'
  prefs: []
  type: TYPE_TB
- en: '| `all` | The `validate` command is called in all the aforementioned cases.
    |'
  prefs: []
  type: TYPE_TB
- en: The `10.03_validation_mode_demo.py` code file demonstrates all of these validation modes
    by attaching them to a single `validation` method. In the code, note the different
    ways in which different Entry widgets respond to different events. Some Entry
    widgets call the `validation` method on the focus events, others call the `validation`
    method at the time of entering keystrokes into a widget, and still others use
    a combination of the focus and key events.
  prefs: []
  type: TYPE_NORMAL
- en: Although we did set the validation mode to trigger the `validate` method, we
    need some data to validate against the rules. This is passed to the `validate`
    method using percent substitution. For instance, we passed the mode as an argument
    to the
  prefs: []
  type: TYPE_NORMAL
- en: '`validate` method by performing a percent substitution on the `validate` command, as
    demonstrated in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This was followed by passing the value of `v` as an argument to the `validate`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to `%V`, Tkinter recognizes the following percent substitutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Percent substitutions** | **Explanation** |'
  prefs: []
  type: TYPE_TB
- en: '| `%d` | The type of action that is performed on a widget (`1` for insert,
    `0` for delete, and `-1` for a focus, forced, or `textvariable` validation). |'
  prefs: []
  type: TYPE_TB
- en: '| `%i` | The index of the char string that is inserted or deleted, if any. Otherwise,
    it will be `-1`. |'
  prefs: []
  type: TYPE_TB
- en: '| `%P` | The value of the entry in case the edit is allowed. If you are configuring the
    Entry widget to have a new `textvariable`, this will be the value of that `textvariable`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `%s` | The current value of the entry prior to editing. |'
  prefs: []
  type: TYPE_TB
- en: '| `%S` | The text string being inserted or deleted if any. Otherwise, `{}`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `%v` | The type of validation that has been currently set. |'
  prefs: []
  type: TYPE_TB
- en: '| `%V` | The type of validation that triggers the callback method (`key`, `focusin`, `focusout`,
    and forced). |'
  prefs: []
  type: TYPE_TB
- en: '| `%W` | The name of the Entry widget. |'
  prefs: []
  type: TYPE_TB
- en: These substitution values provide us with the necessary data to validate the
    input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s pass all of these values and just print them through a dummy `validate`
    method just to see what kind of data that we can expect to get on carrying out
    the validations (see the `10.04_percent_substitutions_demo.py` code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note the line where we register a `validate` method by passing all the possible percent
    substitutions to the callback.
  prefs: []
  type: TYPE_NORMAL
- en: Take particular note of the data returned by `%P` and `%s` because they pertain
    to the actual data entered by the user in the Entry widget. In most cases, you
    will be checking either of these two data sources against the validation rules.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a background of rules for data validation, let's have a look
    at two practical examples that demonstrate input validation.
  prefs: []
  type: TYPE_NORMAL
- en: Key validation mode demo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume that we have a form that asks for a username. We want users to
    input only alphabetical or space characters in the name. Thus, a number of special
    characters should not be allowed, as shown in the following screenshot of the
    widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa7793c5-9426-4a2f-9ffe-4c604b640392.png)'
  prefs: []
  type: TYPE_IMG
- en: This is clearly a case for the `key` validation mode because we want to check whether
    an entry is valid after every keypress. The percent substitution that we need
    to check is `%S` because it yields the text string being inserted or deleted in
  prefs: []
  type: TYPE_NORMAL
- en: 'the Entry widget. Therefore, the code that validates the Entry widget is as
    follows (see the `10.05_key_validation.py` code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We first register two options, namely `validatecommand ( vcmd )` and `invalidcommand
    ( invcmd )`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the example, `validatecommand` is registered to call the `validate_data` method,
    and the `invalidcommand` option is registered to call another method named `invalid_name`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `validatecommand` option specifies a method that needs to be evaluated,
    which will validate the input. The validation method must return a Boolean value,
    where `True` signifies that the data entered is valid, and a `False` return value
    signifies that the data is invalid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case the validate method returns `False` (invalid data), no data is added
    to the Entry widget and the script registered for `invalidcommand` is evaluated.
    In our case, a False validation will call the `invalid_name ` method. The `invalidcommand`
    method is generally responsible for displaying error messages or setting back
    the focus to the Entry widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Focus-out validation mode demo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous example demonstrated validation in the `key` mode. This means that the
    validation method was called after every keypress to check whether an entry was
    valid.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are situations where you might want to check the entire string entered
    into the widget rather than checking individual keystroke entries.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when an Entry widget accepts a valid email address, we would ideally like
    to check the validity after the user has entered the entire email address and
    not after every keystroke entry. This will qualify for a validation in the `focusout`
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out `10.06_focus_out_validation.py` for a demonstration of email validation
    in the `focusout` mode, which gives us the following GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f2093f9-0445-426e-9b5d-a8d863daa7e5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code for the aforementioned demo is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This code has a lot of similarities to the previous validation example. However,
    note the following differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The validate mode is set to `focusout` in contrast to the `key` mode in the previous
    example. This means that the validation will be done only when the Entry widget
    loses focus. The validation occurs when you hit the *Tab* key. Thus, the input
    box does not lose its focus in case the input is invalid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This program uses data provided by the `%P` percentage substitution, while the
    previous example used `%S`. This is understandable because `%P` provides the value
    entered in the Entry widget, but `%S` provides the value of the last keystroke.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This program uses regular expressions to check whether the entered value corresponds
    to a valid email format. Validation usually relies on regular expressions. A whole
    lot of explanation is required to cover this topic, but that is beyond the scope
    of this book. For more information on regular expression modules, visit [http://docs.python.org/3.6/library/re.html](http://docs.python.org/3.6/library/re.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concludes our discussion on input validation in Tkinter. Hopefully, you
    should now be able to implement input validation to suit your custom needs.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting widget data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Input data such as date, time, phone number, credit card number, website URL,
    and IP number, have an associated display format. For instance, the date can be better
    represented in a `MM/DD/YYYY` format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, it is easy to format data in the required format as the user enters
    it in the widget, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68a447d2-d557-46b9-b123-df47959e326c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `10.07_formatting_entry_widget_to_display_date.py` code automatically formats
    user input to insert forward slashes at the required places to display the date
    entered by a user in the `MM/DD/YYYY` format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The Entry widget is bound to the keypress event, where every new keypress calls
    the related `format_date_entry_widget` callback method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, the `format_date_entry_widget` method breaks down the entered text into
    an equivalent list named `entry_list` and ignores the slash/symbol that may have
    been entered by a user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then iterates through the `self.slash_positions` list and inserts the slash symbol
    at all the required positions in `entry_list`. The net result of this is a list
    that has slashes inserted at all the right places.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next line converts this list into an equivalent string using `join()` and then
    sets the value of the Entry widget to this string. This ensures that the Entry
    widget text is formatted into the aforementioned date format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remaining pieces of code simply control the cursor to ensure that the cursor
    advances by one position whenever it encounters the slash symbol. It also ensures
    that keypresses, such as *Backspace*, right, left, up, and down are handled properly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that this method does not validate the date value, and users may add an
    invalid date. The method defined here will simply format it by adding a forward
    slash at the third and sixth positions. Adding date validation to this example
    is left as an exercise for you to complete.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our brief discussion on formatting data within widgets. Hopefully, you
    should now be able to create formatted widgets for a wide variety of input data
    that can be better displayed in a given format.
  prefs: []
  type: TYPE_NORMAL
- en: More on fonts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many Tkinter widgets let you specify custom font specifications either at the
    time of widget creation or later by using the `configure()` option. For most cases, default
    fonts provide a standard look and feel. However, if you want to change font specifications,
    Tkinter lets you do so. There is one caveat, though.
  prefs: []
  type: TYPE_NORMAL
- en: When you specify your own font, you need to make sure that it looks good on
    all the platforms where your program is intended to be deployed because a font
    might look good on a particular platform, but it may look awful on another platform.
    Unless you know what you are doing, it is always advisable to stick to Tkinter's
    default fonts.
  prefs: []
  type: TYPE_NORMAL
- en: Most platforms have their own set of standard fonts that are used by the platform's native
    widgets. So, rather than trying to reinvent the wheel on what looks good on a
    given platform or what would be available for a given platform, Tkinter assigns these
    standard platform-specific fonts to its widget, thus providing a native look and
    feel on every platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tkinter assigns nine fonts to nine different names; you can use these fonts
    in your programs. The font names are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TkDefaultFont`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TkTextFont`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TkFixedFont`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TkMenuFont`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TkHeadingFont`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TkCaptionFont`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TkSmallCaptionFont`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TkIconFont`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TkTooltipFont`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Accordingly, you can use them in your programs in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using these kinds of fonts markups, you can rest assured that your font will
    look native across all platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Finer control over font
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the aforementioned method of handling fonts, Tkinter provides
    a separate `Font` class implementation. The source code for this class is located
    in the same folder as the source code for Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: On my Linux machine, the source code is located in `/usr/local/lib/python3.6/tkinter/font.py`.
    On Windows (with a default Python 3.6 install) the location is `C:\Program Files
    (x86)\Python36-32\Lib\tkinter\font.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this module, you need to import fonts into your namespace, as follows (see
    the `10.08_font_demo.py` code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output of this program on my terminal is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `font` module provides much better fine-grained control
    over various aspects of fonts that are otherwise inaccessible.
  prefs: []
  type: TYPE_NORMAL
- en: Building a font selector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have seen the basic features that are available in Tkinter''s `font`
    module, let''s implement a font selector like the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cedda725-82e3-4356-8031-95999711f122.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The key to building the font selector shown in the preceding screenshot is
    to fetch a list of all the fonts installed on a system. A call to the `families()`
    method from the `font` module fetches a tuple of all the fonts available on a
    system. Accordingly, when you run the following code, a tuple of all the fonts
    available on the system gets printed (see the `10.09_all_fonts_on_a_system.py` code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that since `font` is a submodule of Tkinter, it needs an instance of `Tk()`,
    which loads the Tcl interpreter, before it can fetch the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a tuple of all the fonts available on a system, we just need
    to create the GUI shown in the preceding screenshot and attach relevant callbacks to
    all the widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will not discuss the code that creates the GUI shown in the preceding screenshot. Check
    out `10.10_font_selector.py` for the complete code. However, note that the code
    attaches the following callback to all the widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `fontspecs` is a custom tag that we attached to the sample text in the
    text widget, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This concludes our brief discussion on playing with fonts in Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting the command-line output to Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may occasionally need to redirect the output of a command line to a GUI
    such as Tkinter. The ability to pass outputs from the command line to Tkinter
    opens a large pool of possibilities for using the inherent powers of the shell
    on Unix and Linux operating systems and the Windows shell on a Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: We will demonstrate this by using the `subprocess` Python module, which lets
    us spawn new processes, connect to the input, output, and error pipes of this
    new process, and obtain the return codes from the programs.
  prefs: []
  type: TYPE_NORMAL
- en: A detailed discussion on the `subprocess` module can be found at [https://docs.python.org/3/library/subprocess.html](https://docs.python.org/3/library/subprocess.html).
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `Popen` class from the `subprocess` module to create a new process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Popen` class provides a cross-platform way to create new processes, and
    it has the following long signature to handle most of the common and esoteric
    use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a simple program that shows how we can redirect the output of the `ls` Bash
    shell command to Tkinter''s text widget. As a reminder, the `ls` command in the
    Bash scripting language returns a list of all files and directories (see the `10.11_reading_from_command_line.py` code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Windows users should note that you will have to replace `ls` with `dir` in the highlighted
    part of the preceding code to get an equivalent result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, note that you can pass extra arguments to `Popen` by using the following
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Even better, you can pass the name of the script file that needs to be executed
    in the new process. The code used to run a script file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: However, the script file that needs to be executed must include a proper shebang declaration
    to let the program choose a proper executing environment for your script. For
    instance, if you intend to run a Python script, your script must begin with the
    shebang of the `#!/usr/bin/env python3` form. Similarly, you need to include `#!/bin/sh`
    to run a Bourne-compatible shell script. A shebang isn't necessary on Windows.
    It is also not required for binary executables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the preceding program produces a window, and a listing of all the files
    from the current directory are added to the text widget, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05fe7cb1-51dd-4408-9e44-c07536d40593.png)'
  prefs: []
  type: TYPE_IMG
- en: While the preceding program is simple, this technique can have a lot of practical uses.
    For instance, you may recall that we built a chat server in the previous chapter. Every
    time a new client connected to the server, it printed the client details to the terminal.
    We could have easily redirected that output into a new Tkinter app. This would
    enable us to create a dashboard for the server; from there, we could have monitored
    all the incoming connections to the server.
  prefs: []
  type: TYPE_NORMAL
- en: This opens the door for us to reuse any command-line script written in any other
    programming language, such as Perl or Bash, and directly integrate it with a Tkinter
    program.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the brief section on the redirection of command-line outputs
    into Tkinter programs.
  prefs: []
  type: TYPE_NORMAL
- en: The class hierarchy of Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As programmers, we hardly need to understand the class hierarchy of Tkinter.
    After all, we have been able to code all the applications so far without bothering
    with the overall class hierarchy. However, knowing the class hierarchy enables
    us to `trace` the origin of a method within the source code or source documentation
    of a method.
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand the class hierarchy of Tkinter, let's take a look at
    the source code of Tkinter. On the Windows installation, the source code of Tkinter
    is located at `path\of\Python\Installation\Lib\tkinter\`. On my Linux machine,
    the
  prefs: []
  type: TYPE_NORMAL
- en: source code is located at `/usr/lib/python3.6/tkinter/` .
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open the `__init__.py` file from this folder in a code editor and look
    at its list of class definitions in Tkinter, you will see the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4c1654f-080d-44b9-93cf-14ed4a8c5b10.png)'
  prefs: []
  type: TYPE_IMG
- en: So, what can you see here? We have class definitions for each core Tkinter widget.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, we have class definitions for different geometry managers
    and variable types defined within Tkinter. These class definitions are what you
    would normally expect to be there.
  prefs: []
  type: TYPE_NORMAL
- en: However, in addition to these, you will see some more class names, such as `BaseWidget,
    Misc`, `Tk`, `Toplevel`, `Widget`, and `Wm`. All of these classes are circled
    in the preceding screenshot. So, what services do these classes provide, and where
    do they fit in the larger scheme of things?
  prefs: []
  type: TYPE_NORMAL
- en: Let's use the `inspect` module to look at the class hierarchy of Tkinter. We
    will first inspect the class hierarchy of the Frame widget as a representation
    of class hierarchies for all the other widgets. We will also look at the class
    hierarchy of
  prefs: []
  type: TYPE_NORMAL
- en: 'the `Tk` and `Toplevel` classes to estimate their role in the overall class
    hierarchy of Tkinter (`10.12_tkinter_class_hierarchy.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `getmro`(`classname`) function from the `inspect` module returns a tuple consisting
    of all the ancestors of `classname` in the order specified by the **method resolution
    order** (**MRO**). MRO refers to the order in which base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: classes are searched when looking for a given method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By inspecting the MRO and the source code, you will come to know that the `Frame`
    class inherits from the `Widget` class, which in turn inherits from the `BaseWidget`
    class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Widget` class is an empty class with the following class definition: `class
    Widget(BaseWidget, Pack, Place, Grid)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, this is how methods defined in the geometry manager (the pack,
    place, and grid mix-ins) are made available to all the widgets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `BaseWidget` class has the following class definition: `class BaseWidget(Misc)`.
    This class exposes the destroy method that can be used by programmers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the utility methods defined in the `Misc` class are made available to the
    widgets at this hierarchy level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Misc` class is a generic mix-in that provides a lot of functionality that
    we have used in our applications. Some of the methods that we have used in our programs,
    as defined within the `Misc` class, are `after()`, `bbox()`, `bind_all()`, `bind_tag()`,
    `focus_set()`, `mainloop()`, `update()`, `update_idletask()`, and `winfo_children()`.
    For a complete list of functionalities provided by the `Misc` class, run the following
    commands in the Python interactive shell:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at the `Tk` and `Toplevel` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Tk` class returns a new `Toplevel` widget on the screen. The `__init__` method
    of the `Tk` class is responsible for the creation of a new Tcl interpreter by
    calling a method named `loadtk()`. The class defines a method named `report_callback_exception()`,
    which is responsible for the reporting of errors and exceptions on `sys.stderr`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__init__` method of the `Toplevel` class of Tkinter is responsible for
    the creation of the main window of an application. The constructor of the class
    takes various optional arguments such as `bg`, `background`, `bd`, `borderwidth`,
    `class`, `height`, `highlightbackground`, `highlightcolor`, `highlightthickness`,
    `menu`, and `relief`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To obtain a list of all the methods provided by the `Toplevel` and `Tk` classes,
    run the following command in the Python interactive shell:  `help(tkinter.Toplevel);
    help(tkinter.Tk)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to inheriting from the `Misc` mixin class, the `Toplevel` and `Tk`
    classes also inherit methods from the `Wm` mixin class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Wm` (short for the Window manager) `mixin` class provides many methods
    to let us communicate with the window manager. Some commonly used methods from
    this class include `wm_iconify, wm_deiconify`, `wm_overrideredirect`, `title`,
    `wm_withdraw`, `wm_transient`, and `wm_resizable`. For a complete list of functions
    provided by the `Wm` class, run the following command in the Python interactive
    shell: `help(tkinter.Wm)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After translating the class hierarchy, as obtained from the previous program
    and by inspecting the source code, we get a hierarchy structure of Tkinter, as
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13641faf-5200-45c6-914e-dd14ae9821b1.png)'
  prefs: []
  type: TYPE_IMG
- en: In addition to the normal inheritance relation, which is shown in the preceding diagram
    with the help of unbroken lines, Tkinter provides a list of mixins (or helper classes).
  prefs: []
  type: TYPE_NORMAL
- en: A `mixin` is a class that is designed not to be used directly, but to be combined with
    other classes using multiple inheritances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tkinter mixins can be broadly classified into the following two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Geometry mixins: These include the `Grid`, `Pack`, and `Place` classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implementation mixins: These include the following classes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Misc` class, which is used by the root window and `widget` classes,  provides
    several Tk and window-related services
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Wm` class, which is used by the root window and the Toplevel widget, provides
    several window manager services
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This concludes our brief under-the-hood tour of Tkinter. Hopefully, this should
    give you some insight into the inner workings of Tkinter. If you ever have a doubt
    about the documentation of any given method, you can take a peek directly into
    the actual implementation of the method.
  prefs: []
  type: TYPE_NORMAL
- en: Tips for program design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at a few generic tips for program design.
  prefs: []
  type: TYPE_NORMAL
- en: The model-first policy versus the code-first policy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A well-designed model is half the work done. That said, the model is sometimes
    not very evident when you start writing the program. In such cases, you can break the
    rules and try out the code-first philosophy. The idea is to build your program
    incrementally from the ground up, refactor your code, and model, as your vision
    for the program becomes clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Separating the model from the view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The need to separate the model or data structure from the view is the key to
    building scalable applications. While it is possible to intermix the two components,
    you will soon find your program getting messy and difficult to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the right data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selecting the right data structure can have a profound impact on the performance
    of a program. If your program requires you to spend considerable time on lookups,
    use a dictionary, if feasible. When all that you need is to traverse over a collection,
    prefer lists over dictionaries because dictionaries take up more space. When your
    data is immutable, prefer tuples over lists because tuples can be traversed faster
    than lists.
  prefs: []
  type: TYPE_NORMAL
- en: Naming variables and methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use meaningful and self-documenting names for your variables and methods. The name
    should leave no scope for confusion about the intent of the variable or the method.
    Use plural names for collections and singular names otherwise. Methods that return
    Boolean values should be appended with words such as *is* or *has*. Stick to the
    style guidelines, but you should also know when to break them.
  prefs: []
  type: TYPE_NORMAL
- en: The Single Responsibility Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Single Responsibility Principle suggests that a function/class/method should do
    only one thing and that it should do it all and do it well. This means that we should
    not try to handle multiple things from within a function.
  prefs: []
  type: TYPE_NORMAL
- en: Loose coupling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever possible, reduce coupling or dependence in your program. The following is
    a famous quote on this subject:'
  prefs: []
  type: TYPE_NORMAL
- en: All problems in computer science can be solved by another level of indirection.
  prefs: []
  type: TYPE_NORMAL
- en: – David Wheeler
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose that your program has a play button. An immediate impulse may
    be to link it to the `play` method of your program. However, you can further break
    it up into two methods. You could probably link the play button to a method named `on_play_button_clicked`,
    which in turn calls the actual `play` method. The advantage of this is that you
    may want to handle additional things when the play button is clicked, such as
    displaying the current track information somewhere in your program.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, you can now use the `on_play_button_clicked` method to decouple the click event
    from the actual play method and then handle calls to multiple methods.
  prefs: []
  type: TYPE_NORMAL
- en: However, you must resist the temptation of adding too many levels of indirection,
    as your program may quickly start getting messy and it may get out of control.
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors and exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python follows the **EAFP** (short for **easier to ask for forgiveness than
    permission**) style of coding as opposed to the **LBYL** (**look before you leap**)
    style that is followed by most programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, handling exceptions in a way that is similar to the following one
    is normally cleaner in Python than checking conditions using the if-then block.
  prefs: []
  type: TYPE_NORMAL
- en: 'So when coding in Python, rather than using the following style in coding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider using this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Handling cross-platform differences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though Tkinter is a cross-platform module, you might come across occasions
    when code written for one operating system might not work as expected on other
    operating systems.  We already saw one such example in the case of getting command-line
    results in the previous Redirecting the command-line output to Tkinter*.* In such
    cases, you can overcome these cross-platform discrepancies by first identifying
    the operating system on which the program is being run and then using a conditional
    statement to run different lines of code for different operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a brief snippet that demonstrates this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The particular problem here is that the mouse wheel event is denoted by the `<MouseWheel>` event
    name on Windows and macOS, but as `<Button-4>` and `<Button-5>` on Linux distributions.  The
    preceding code uses the platform module of Python to identify the operating system
    and follows a different line of code for different operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Tips for program optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, let's take a look at some generic tips to optimize your programs.
  prefs: []
  type: TYPE_NORMAL
- en: Using filter and map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python provides two built-in functions, named `filter` and `map`, to manipulate collections
    directly rather than having to iterate over each item in the collection. The `filter`,
    `map`, and `reduce` functions are faster than loops because a lot of the work is
    done by the underlying code written in C.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `filter(function, list)` function returns a list (iterators in Python 3.x) that
    contains all the items for which the function returns a true value. The following
    command is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is faster than running a conditional if-then check against the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `map(function_name, list)` function applies `function_name` to each item
    in the list and returns the values in a new list (returns iterators instead of
    lists in Python 3.x). The following command is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is faster than running the list through a loop and adding `5` to each element.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The way you select variables in your program can considerably affect the speed of
    the execution of your program. For instance, if you do not need to change the content
    or attributes of a widget after its instantiation, do not create a class-wide instance
    of the widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if a Label widget needs to remain static, use `Label(root, text=''Name'').pack(side=LEFT)`
    instead of using the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, do not create local variables if you are not going to use them more
    than once. For example, use `mylabel.config (text= event.keysym)` instead of first creating
    a local variable named key and then using it only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If the local variable needs to be used more than once, it may make sense to
    create a local variable.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling your program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Profiling involves generating detailed statistics to show how often and for
    how long various routines of a program execute. This helps you isolate the offending
    parts of a program, and those parts probably need redesigning.
  prefs: []
  type: TYPE_NORMAL
- en: Python provides a built-in module named `cProfile`, which enables the generation
    of detailed statistics pertaining to a program. The module gives details such
    as the total program running time, the time taken to run each function, and the
    number of times each function is called. These statistics make it easy to determine
    the parts of the code that need optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, `cProfile` provides the following data for a function or script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ncalls`: This indicates the number of times a function is called'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tottime`: This indicates the time spent on a function, which excludes the
    time spent on calling other functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`percall`: This is `tottime` divided by `ncalls`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cumtime`: This indicates the time spent on a function, including calls to other
    functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`percall`: This is `cumtime` divided by `tottime `'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To profile a function named `spam()`, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then view the results of profiling by using another module called `pstats`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'More importantly, you can profile an entire script. Let''s assume that you
    want to profile a script named `myscript.py`. You can simply navigate to the directory
    of the script using a command-line tool and then type and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a partial output from running the preceding command on the `8.08_vornoi_diagram`
    code from [Chapter 8](7f88607b-582a-4f9e-a922-7cd9333d320e.xhtml), *Fun With Canvas*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: I specifically chose to profile this program because it takes a long time to
    execute. In this case, it took ~110 seconds to run and most of the time was spent
    running the `create_vornoi_diagram` function (~95 seconds). So now this function
    is a perfect candidate for optimization.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the `cProfile` module, there are other modules, such as `PyCallGraph` and
    `objgraph`, and they provide visual graphs for the profile data.
  prefs: []
  type: TYPE_NORMAL
- en: Other optimization tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optimization is a vast topic, and there is a lot that you can do. If you are
    interested in knowing more about code optimization, you can start with the official
    Python optimization tips that are available at [http://wiki.python.org/moin/PythonSpeed/PerformanceTips](http://wiki.python.org/moin/PythonSpeed/PerformanceTips).
  prefs: []
  type: TYPE_NORMAL
- en: Distributing a Tkinter application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, you have your new application ready and want to share it with the rest of
    the world. How do you do that?
  prefs: []
  type: TYPE_NORMAL
- en: You, of course, need Python installed for your programs to run. Windows does
    not have Python preinstalled. Most modern Linux distributions and macOS have Python
    preinstalled, but you don't need just any version of Python. You need a version
    of Python that is compatible with the version on which the program was originally
    written.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, if your program uses third-party modules, you need the appropriate module
    installed for the required Python version. This surely is too much diversity to
    handle.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we have tools, such as Freeze tools, that allow us to distribute
    Python programs as standalone applications.
  prefs: []
  type: TYPE_NORMAL
- en: Given the diversity of platforms that need to be handled, there are a large
    number of Freeze tool options from which you can choose. Therefore, a detailed
    discussion on any one of these tools is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: We will list some of the most evolved freezing tools in the following sections.
    If you find a tool that fits into your distribution requirements, you can look
    at its documentation for more information.
  prefs: []
  type: TYPE_NORMAL
- en: py2exe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you only need to distribute your Python application on Windows, py2exe is perhaps
    the most hardened tool. It converts Python programs into executable Windows programs
    that can run without requiring a Python installation.
  prefs: []
  type: TYPE_NORMAL
- en: More information, a download link, and tutorials on this are available at [http://www.py2exe.org/](http://www.py2exe.org/).
  prefs: []
  type: TYPE_NORMAL
- en: py2app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The py2app performs the same tasks in macOS that py2exe does for Windows. If
    you just need to distribute your Python application on macOS, py2app is a time-tested tool.
    More information is available at [https://pythonhosted.org/py2app/](https://pythonhosted.org/py2app/).
  prefs: []
  type: TYPE_NORMAL
- en: PyInstaller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PyInstaller has gained popularity as a freezing tool in the last few years because
    it supports a wide variety of platforms, such as Windows, Linux, macOS X, Solaris, and
    AIX.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, executables created using PyInstaller claim to take up less space than
    other freezing tools because it uses transparent compression. Another important feature
    of PyInstaller is its out-of-the-box compatibility with a large number of third-party
    packages. The full list of features, downloads, and documentation can be viewed
    by visiting [http://www.pyinstaller.org/](http://www.pyinstaller.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Other freezing tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are a few other freezing tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Freeze**: This tool is shipped with the standard Python distribution. Freeze
    can only be used to compile executables on Unix systems.  However, the program
    is overly simplistic, as it fails to handle even the common third-party libraries.
    More information on this is available at [http://wiki.python.org/moin/Freeze](http://wiki.python.org/moin/Freeze).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**cx_Freeze**: This tool is similar to py2exe and py2app, but it claims to
    be portable across all platforms on which Python works. More information on this
    is available at [http://cx-freeze.sourceforge.net/index.html](http://cx-freeze.sourceforge.net/index.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're distributing a small program, a freezing tool might be just what you
    need.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you have a large program, say, with lots of external third-party library
    dependencies, or dependencies that are not supported by any existing freezing
    tool, your application might be the right candidate for bundling the
  prefs: []
  type: TYPE_NORMAL
- en: Python interpreter with your application.
  prefs: []
  type: TYPE_NORMAL
- en: The limitations of Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already explored the power of Tkinter. Perhaps the greatest power of Tkinter
    lies in its ease of use and lightweight footprint. Tkinter exposes a very powerful
    API, especially with the Text widget and the Canvas widget.
  prefs: []
  type: TYPE_NORMAL
- en: However, its ease of use and the fact that it is lightweight also result in
    some limitations.
  prefs: []
  type: TYPE_NORMAL
- en: A limited number of core widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tkinter provides only a small number of basic widgets and lacks a collection
    of modern widgets. It needs Ttk, Pmw, TIX, and other extensions to provide some
    really useful widgets. Even with these extensions, Tkinter fails to match the
    range of widgets provided by other GUI tools, such as the advanced wxPython widget
    set and PyQt.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, wxPython's HtmlWindow widget lets users display HTML content with
    ease. There have been attempts to provide similar extensions in Tkinter, but they
    are far from satisfactory. Similarly, there are other widgets from the Advanced User
    Interface Library and mixins in wxPython, such as floating/docking frames and perspective
    loading and saving; Tkinter users can only hope that these widgets will be included
    in future releases.
  prefs: []
  type: TYPE_NORMAL
- en: Non-Python objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tkinter widgets are not first-class Python objects. Thus, we have to use workarounds such
    as `Intvar`, `StringVar`, and `BooleanVar` to handle variables in Tkinter. This adds
    a small layer of complexity, as error messages returned by the Tcl interpreter are
    not very Python-friendly, which makes it harder to debug.
  prefs: []
  type: TYPE_NORMAL
- en: No support for printing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tkinter is rightly criticized for not providing any support for printing features.
  prefs: []
  type: TYPE_NORMAL
- en: The Canvas widget allows for limited printing support in the PostScript format.
    The PostScript format is too limited in what it can be used for. Compare this
    to wxPython, which provides a complete printing solution in the form of a printing
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: No support for newer image formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tkinter does not natively support image formats such as JPEG and PNG. The `PhotoImage`
    class of Tkinter can read images only in the GIF and PGM/PPM formats. Although
    there are workarounds, such as using the `ImageTk` and `Image` submodules from
    the `PIL` module, it would have been better if Tkinter natively supported popular
    image formats.
  prefs: []
  type: TYPE_NORMAL
- en: Inactive development community
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tkinter is often criticized for having a relatively inactive development community. This
    is true to a large extent. The documentation for Tkinter has remained a work in progress
    for many years now.
  prefs: []
  type: TYPE_NORMAL
- en: A large number of Tkinter extensions have appeared over the years, but most
    of them have not been under active development for a long time.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter supporters refute this with the argument that Tkinter is a stable and mature
    technology that does not need frequent revisions, unlike some other GUI modules
    that are still being developed.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a program can be written in Tkinter, this is probably the best way to go
    in terms of simplicity and maintainability. However, in case the aforementioned
    limitations get in your way, you can explore some other alternatives to Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to Tkinter, there are several other popular Python GUI toolkits.
    The most popular ones include wxPython, PyQt, PySide, and PyGTK. Here's a brief
    discussion of these toolkits.
  prefs: []
  type: TYPE_NORMAL
- en: wxPython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: wxPython is a Python interface for `wxWidgets`, a popular open source GUI library.
    The code written in wxPython is portable across most major platforms, such as
    Windows, Linux, and macOS.
  prefs: []
  type: TYPE_NORMAL
- en: The wxPython interface is generally considered to be better than Tkinter at
    building complex GUIs, primarily because it has a large base of natively supported
    widgets. However, Tkinter supporters do contest this claim.
  prefs: []
  type: TYPE_NORMAL
- en: The `wxWidgets` interface was originally written in the C++ programming language.
    Hence, wxPython inherits a large portion of the complexity that is typical of
    C++ programs. wxPython provides a very large base of classes, and it often takes
    more code to produce the same interface than it would take in Tkinter. However,
    in exchange for this complexity, wxPython provides a larger base of built-in widgets than
    Tkinter offers.
  prefs: []
  type: TYPE_NORMAL
- en: Owing to its inherent complexity, wxPython has seen the emergence of several
    GUI builder toolkits, such as **wxGlade, wxFormBuilder,** and **wxDesigner.**
    The wxPython installation comes with demo programs that can help you quickly get
    started with the toolkit. To download the toolkit, or for more information on
    wxPython, visit [http://wxpython.org/](http://wxpython.org/).
  prefs: []
  type: TYPE_NORMAL
- en: PyQt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PyQt is a Python interface for a cross-platform GUI toolkit named Qt, a project currently
    developed and maintained by a British firm named Riverbank Computing.
  prefs: []
  type: TYPE_NORMAL
- en: PyQt, with several hundred classes and thousands of functions, is perhaps the most
    fully featured GUI library currently available for GUI programming in Python.
    However, this feature load brings in a lot of complexity and a steep learning
    curve.
  prefs: []
  type: TYPE_NORMAL
- en: Qt, and hence pyQt, has a very rich set of supported widgets. In addition to
    this, it includes built-in support for network programming, SQL databases, threads, multimedia
    frameworks, regular expressions, XML, SVG, and much more. The designer feature
    of Qtletsus generates GUI code from a **WYSIWYG** (**what you see is what you
    get**) interface.
  prefs: []
  type: TYPE_NORMAL
- en: PyQt is available under a variety of licenses, including GNU, **General Public
    License** (**GPL**), and a commercial license. However, its greatest disadvantage
    is that unlike Qt, it is unavailable under the **Lesser General Public License**
    (**LGPL**).
  prefs: []
  type: TYPE_NORMAL
- en: PySide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are looking for an LGPL Version of Qt bindings for Python, you may want
    to explore PySide. PySide was originally released under the LGPL in August 2009
    by Nokia, the former owners of the Qt Toolkit. It is now owned by Digia. More
    information on PySide can be obtained by visiting [http://qt-project.org/wiki/PySide](http://qt-project.org/wiki/PySide).
  prefs: []
  type: TYPE_NORMAL
- en: PyGTK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PyGTK is a collection of Python bindings for the GTK + GUI library. PyGTK applications
    are cross-platform and can run on Windows, Linux, macOS, and others. PyGTK is
    free and is licensed under the LGPL. Therefore, you can use, modify, and distribute
    it with very few restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: More information about PyGTK can be obtained by visiting [http://www.pygtk.org/](http://www.pygtk.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Other options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides these popular toolkits, there are a range of toolkits available for
    GUI programming in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Java programmers who are comfortable with Java GUI libraries, such as Swing and
    AWT, can seamlessly access these libraries by using **Jython.** Similarly, C# programmers
    can use **IronPython** to access GUI construction features from the **.NET** framework.
  prefs: []
  type: TYPE_NORMAL
- en: For a comprehensive list of other GUI tools that are available to a Python developer, visit
    [http://wiki.python.org/moin/GuiProgramming](http://wiki.python.org/moin/GuiProgramming).
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter in Python 2.x
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2008, Guido van Rossum, the author of Python, forked the language into two branches—2.x
    and 3.x. This was done to clean up the language and make it more consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.x broke backward compatibility with Python 2.x. For example, the print statement
    in Python 2.x was replaced by the `print()` function that would now take arguments
    as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: We coded all the Tkinter programs in Python Version 3.x. However, in case you
    need to maintain or write new Tkinter programs in Python 2.x, the transition should
    not be very difficult.
  prefs: []
  type: TYPE_NORMAL
- en: The core functionality of Tkinter remains the same between 2.x and 3.x. The
    only significant change to Tkinter when moving from Python 2.x to Python 3.x involves changing
    the way the Tkinter modules are imported.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter has been renamed as `tkinter` in Python 3.x (capitalization has been
    removed).
  prefs: []
  type: TYPE_NORMAL
- en: Note that in 3.x, the `lib-tk` directory was renamed to `tkinter`. Inside this
    directory, the `Tkinter.py` file was renamed to `__init__.py`, thus making `tkinter`
    an importable module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, the biggest difference lies in the way you import the `tkinter`
    module into your current namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore, note the following changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note how the Python 3 version is cleaner, more elegant, and more systematic
    in its naming conventions regarding the use of lowercase names for its modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Python 3** | **Python 2** |'
  prefs: []
  type: TYPE_TB
- en: '| `import tkinter.ttk `     OR`from tkinter import ttk` | `import ttk` |'
  prefs: []
  type: TYPE_TB
- en: '| `import tkinter.messagebox` | `import tkMessageBox` |'
  prefs: []
  type: TYPE_TB
- en: '| `import tkinter.colorchooser` | `import tkColorChooser` |'
  prefs: []
  type: TYPE_TB
- en: '| `import tkinter.filedialog` | `import tkFileDialog` |'
  prefs: []
  type: TYPE_TB
- en: '| `import tkinter.simpledialog` | `import tkSimpleDialog` |'
  prefs: []
  type: TYPE_TB
- en: '| `import tkinter.commondialog` | `import tkCommonDialog` |'
  prefs: []
  type: TYPE_TB
- en: '| `import tkinter.font` | `import tkFont` |'
  prefs: []
  type: TYPE_TB
- en: '| `import tkinter.scrolledtext` | `import ScrolledText` |'
  prefs: []
  type: TYPE_TB
- en: '| `import tkinter.tix` | `import Tix` |'
  prefs: []
  type: TYPE_TB
- en: 'The following version will work for both cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To conclude the book, let's summarize some of the key steps involved in designing
    an application. Depending on what you want to design, choose a suitable data structure to
    represent your needs logically. If required, combine primitive data structures
    to form complex structures such as, say, a list or a tuple of dictionaries. Create
    classes for objects that constitute your application. Add attributes that need
    to be manipulated and methods to manipulate these attributes. Manipulate attributes
    by using a different API provided by a rich set of Python-standard and external
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: We tried to build several applications in this book. Then, we had a look at
    an explanation for the code. However, when you try to explain a software development process
    in a sequential text, you sometimes mislead your readers by implying that
  prefs: []
  type: TYPE_NORMAL
- en: the development of software programs is a linear process. This is hardly true.
  prefs: []
  type: TYPE_NORMAL
- en: Actual programming doesn't usually work this way. In fact, small- to medium-sized
    programs are normally written in an incremental trial-and-error process, where
    assumptions get changed and structures are modified throughout the course of application
    development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how you would develop a small- to a medium-sized application:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with a simple script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set a small achievable goal, implement it, and then think of adding the next feature
    to your program in an incremental fashion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may or may not introduce a class structure initially. If you are clear about
    the problem domain, you may introduce the class structure from the very beginning.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are not initially sure about the class structure, start with simple procedural
    code. As your program starts to grow, you will probably start getting a lot of
    global variables. It is here that you will start getting an idea of the structural
    dimensions of your program. It is now time to refactor and restructure your program
    to introduce a class structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Harden your program against unanticipated runtime failures and edge cases to
    make it ready for production use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That concludes the book. If you have any suggestions or feedback, please leave
    us a comment. If you found this book helpful, please rate it online and help us
    spread the word.
  prefs: []
  type: TYPE_NORMAL
- en: QA section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few questions to reflect upon:'
  prefs: []
  type: TYPE_NORMAL
- en: How can we handle cross-platform differences in Tkinter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the advantages and limitations of using Tkinter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are some of the common alternatives to Tkinter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the various modes of validation in Tkinter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is program profiling? How do we profile a program in Python?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
