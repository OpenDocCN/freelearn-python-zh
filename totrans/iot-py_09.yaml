- en: Chapter 9. Working with the Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will take advantage of many cloud services to publish and
    visualize data collected for sensors and to establish bi-directional communications
    between Internet-connected things. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Publishing data to the cloud with dweepy and `dweet.io`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a web-based dashboard with freeboard.io
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending and receiving data in real time through Internet with PubNub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing messages with commands through the PubNub cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with bi-directional communications between IoT devices and other devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing messages to the cloud with a Python PubNub client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the MQTT protocol with Mosquitto and Eclipse Paho
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing messages to a Mosquitto broker with a Python client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing data to the cloud with dweepy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 8](ch08.html "Chapter 8. Displaying Information and Performing
    Actions"), *Displaying Information and Performing Actions*, we worked with a digital
    temperature and humidity sensor combined with displays and a servo. Now, we want
    to take advantage of two cloud services to build a real time and interactive web-based
    dashboard that allows us to watch gauges with the following information in a web
    browser:'
  prefs: []
  type: TYPE_NORMAL
- en: Ambient temperature measured in degrees Fahrenheit (ºF)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ambient temperature measured in degrees Celsius (ºC)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ambient humidity level expressed in percentage (%)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, we will take advantage of `dweet.io` to publish the data retrieved from
    the sensors and make it available to different computers and devices all over
    the world. The `dweet.io` data sharing utility allows us to easily publish data
    or messages and alerts from IoT devices and then use other devices to subscribe
    to this data. The `dweet.io` data sharing utility defines itself as something
    similar to Twitter for social machines. You can read more about `dweet.io` in
    its Webpage: [http://dweet.io](http://dweet.io).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our example, we will take advantage of the free services offered by `dweet.io`
    and we won't use some advanced features that provide privacy for our data but
    also require a paid subscription. Our data will be available to anyone that can
    access the `dweet.io` web page because we are not working with locked dweets.
  prefs: []
  type: TYPE_NORMAL
- en: The `dweet.io` data sharing utility provides a Web api that we can send data
    from our IoT device, known as *thing* in `dweet.io` documentation. First, we have
    to chose a unique name for our thing. It is convenient to combine a string with
    a **GUID** (short for **Global Unique Identifier**). Another option is to click
    on the **Try It Now** button on the main `dweet.io` web page and grab the name
    that the web page chooses for our thing. This way, we are sure that the name is
    unique and nobody else is using this name for another thing to publish data with
    `dweet.io`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have chosen a unique name for our thing, we can start publishing data,
    a process known as `dweeting`. We just need to compose a POST HTTP verb with the
    desired JSON data in the body and with the following request URL: `https://dweet.io/dweet/for/my-thing-name`.
    We must replace `my-thing-name` with the name we have chosen for our thing. In
    our examples, we will use `iot_python_chapter_09_01_gaston_hillar` to name our
    IoT device that will publish temperature and humidity values, that is, the thing
    that will dweet. Thus, we have to compose a POST HTTP verb with the desired JSON
    data in the body and with the following request URL: `https://dweet.io/dweet/for/iot_python_chapter_09_01_gaston_hillar`.
    Make sure you replace the name with the name you have chosen for your thing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dweepy is a simple Python client for `dweet.io` that allows us to easily publish
    data to `dweet.io` with Python. Instead of manually building and sending an HTTP
    request to a specific URL with Python, we can use the methods provided by this
    useful module. The following is the Web page for the Dweepy module: [https://pypi.python.org/pypi/dweepy/0.2.0](https://pypi.python.org/pypi/dweepy/0.2.0).
    Under the hoods, Dweepy uses the popular features provided by the popular `requests`
    module to build and send the HTTP requests.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the nice things of working with Python as our main programming language
    for IoT is that there is always a package that makes things easy for us in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 2](ch02.html "Chapter 2. Working with Python on Intel Galileo Gen
    2"), *Working with Python on Intel Galileo Gen 2*, we installed `pip` installer
    to easily install additional Python 2.7.3 packages in the Yocto Linux that we
    are running on the board. Now, we will use `pip` installer to install Dweepy 0.2.0\.
    We just need to run the following command in the SSH terminal to install the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines for the output will indicate that the `dweepy` package has been
    successfully installed. Don''t worry about the error messages related to building
    wheel and the insecure platform warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We will take the code we wrote in the previous chapter when we read temperature
    and humidity values from the sensor and we will use this code as a baseline to
    add the new features. The code file for the sample was `iot_python_chapter_08_03.py`.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the recently installed `dweepy` module to publish data to `dweet.io`
    and make it available as a data source for another cloud service that will allow
    us to build a web-based dashboard. We will add the necessary lines to our loop
    and it will publish the measured values every 10 seconds. The code file for the
    sample is `iot_python_chapter_09_01.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines show the changes made to the `__main__` method compared
    with the previous version. The first highlighted line creates a local variable
    named `thing_name` that saves a string with the name we have chosen for our thing
    to use with `dweet.io`. Remember that you have to replace the string with the
    name you have chosen for your thing before running the sample code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the code runs a loop forever and the first highlighted line creates a
    dictionary and saves it in the `dweet` local variable. The dictionary defines
    the key-value pairs that we want to send as JSON data to `dweet.io` for our thing.
    The following are the keys the code will send:'
  prefs: []
  type: TYPE_NORMAL
- en: '`temperature_celsius`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`temperature_fahrenheit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`humidity_level_percentage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The values for the previously enumerated keys are the values retrieved by the
    sensor converted to strings. Once the dictionary with the desired JSON data is
    built, the code calls the `dweepy.dweet_for` method with `thing_name` and `dweet`
    as arguments, that is, the thing name and the JSON data we want to publish for
    the specified thing name. Under the hoods, the `dweepy.dweet_for` method uses
    the `requests` module to compose a POST HTTP verb with the `dweet` dictionary
    as the desired JSON data in the body and with the following request URL: `https://dweet.io/dweet/for/`
    followed by the thing name specified in the `thing_name` local variable. This
    way, the code dweets the temperature and humidity values retrieved from the sensor
    in different units.'
  prefs: []
  type: TYPE_NORMAL
- en: The following line will start the example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After you run the example, turn on an air conditioner or a heating system, to
    generate a change in the ambient temperature and humidity. This way, we will notice
    changes in the data that is being published every 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait around 20 seconds and open the following URL in any Web browser: `http://dweet.io/follow/iot_python_chapter_09_01_gaston_hillar`.
    Don''t forget to replace `iot_python_chapter_09_01_gaston_hillar` with the name
    you have chosen for your thing. In this case, we can enter the URL in any device
    connected to the Internet. We don''t need the device to be in the same LAN than
    the board because the values are published with `dweet.io` and they are available
    everywhere.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Visual** view will display a line graph with the humidity level and the
    temperature values as they were changing over time. The right-hand side will display
    the latest value that was published. The view will be refreshed automatically
    when the Python code dweets new values. The following picture shows a screenshot
    with the **Visual** view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Publishing data to the cloud with dweepy](img/B05042_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the **Raw** view and the page will display the latest JSON data that
    the Python code running on the board has published and received by `dweet.io`
    for our thing. The following lines show an example of the latest JSON data that
    was received and that was shown in the previous picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 4](ch04.html "Chapter 4. Working with a RESTful API and Pulse Width
    Modulation"), *Working with a RESTful API and Pulse Width Modulation*, we installed
    HTTPie, a command-line HTTP client written in Python that makes is easy to send
    HTTP requests and uses a syntax that is easier than curl (also known as cURL).
    We can run the following HTTPie command in any computer or device to retrieve
    the latest dweet made for our thing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send the following HTTP request: `GET
    https://dweet.io:443/get/latest/dweet/for/iot_python_chapter_09_01_gaston_hillar`.
    The `dweet.io` API will return the latest dweet for the specified thing. The following
    lines show a sample response from `dweet.io`. The JSON data is included in the
    value for the `content` key.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can run the following HTTPie command in any computer or device to retrieve
    all of the saved dweets for our thing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send the following HTTP request: `GET
    https://dweet.io:443/get/ dweets/for/iot_python_chapter_09_01_gaston_hillar`.
    The `dweet.io` API will return the saved dweets from its long term storage for
    the specified thing. The following lines show a sample response from `dweet.io`.
    Notice that there are limitations in the number of dweets stored in the long term
    storage and in the returned values.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Building a web-based dashboard with Freeboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `dweet.io` data sharing utility allowed us to easily publish data to the
    cloud with just a few lines of code. Now, we are ready to use `dweet.io` and our
    thing name as a data source to build a real-time web-based dashboard. We will
    take advantage of freeboard.io to visualize the data collected with the sensor
    and published to `dweet.io` in many gauges and make the dashboard available to
    different computers and devices all over the world. Freeboard.io allows us to
    build a dashboard by selecting data sources and dragging and dropping customizable
    widgets. Freeboard.io defines itself as a cloud-based service that allows us to
    visualize the Internet of Things. You can read more about freeboard.io in its
    Webpage: [http://freeboard.io](http://freeboard.io).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our example, we will take advantage of the free services offered by freeboard.io
    and we won't use some advanced features that provide privacy for our dashboards
    but also require a paid subscription. Our dashboard will be available to anyone
    that has the unique URL for it because we are not working with private dashboards.
  prefs: []
  type: TYPE_NORMAL
- en: Freeboard requires us to sign up and create an account with a valid e-mail and
    a password before we can build a web-based dashboard. We aren't required to enter
    any credit card or payment information. If you already have an account at freeboard.io,
    you can skip the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Go to [http://freeboard.io](http://freeboard.io) in your Web browser and click
    **Start Now**. You can achieve the same goal by visiting [https://freeboard.io/signup](https://freeboard.io/signup).
    Enter your desired user name in **Pick a Username**, your e-mail in **Enter Your
    Email** and the desired password in **Create a Password**. Once you have filled
    up all the fields, click **Create My Account**.
  prefs: []
  type: TYPE_NORMAL
- en: Once you created your account, you can go to [http://freeboard.io](http://freeboard.io)
    in your Web browser and click **Login**. You can achieve the same goal by visiting
    [https://freeboard.io/login](https://freeboard.io/login). Then, enter your user
    name or e-mail and password, and click **Sign In**. Freeboard will display your
    freeboards, also known as dashboards.
  prefs: []
  type: TYPE_NORMAL
- en: Enter `Ambient temperature and humidity` in the **enter a name** textbox at
    the left hand side of the **Create New** button and then click on this button.
    Freeboard.io will display an empty dashboard with many buttons that allow us to
    add panes and data sources, among other things. The following picture shows a
    screenshot with the empty dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a web-based dashboard with Freeboard](img/B05042_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on **Add** below **Datasources** and the Website will open the **Datasource**
    dialog box. Select **Dweet.io** in the **Type** dropdown and the dialog box will
    display the fields required to define a `dweet.io` datasource.
  prefs: []
  type: TYPE_NORMAL
- en: Enter `Ambient temperature and humidity` in **Name** and the thing name we have
    been using for `dweet.io` in **Thing Name**. Remember that we were using `iot_python_chapter_09_01_gaston_hillar`
    to name our IoT device but you had replaced it with a different name. If the name
    you enter doesn't match the name you used when working with `dweet.io`, the datasource
    won't have the appropriate data. The following picture shows a screenshot with
    the configuration for the `dweet.io` datasource that uses the sample thing name.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a web-based dashboard with Freeboard](img/B05042_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click **Save** and the datasource will appear listed below **Datasources**.
    As the board is running the Python code that is dweeting, the time shown below
    **Last Updated** will change every 10 seconds. If the time doesn't change every
    10 seconds, it means that the datasource has a wrong configuration or that the
    board is not running the Python code that is dweeting anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Add pane** to add a new empty pane to the dashboard. Then, click
    on the plus sign (**+**) at the upper right corner of the new empty pane and Freeboard
    will display the **Widget** dialog box.
  prefs: []
  type: TYPE_NORMAL
- en: Select **Gauge** in the **Type** dropdown and the dialog box will display the
    fields required to add a gauge widget to the pane within the dashboard. Enter
    `Temperature in degrees Fahrenheit` in **Title**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **+ Datasource** at the right-hand side of the **Value** textbox, select
    **Ambient Temperature and humidity** and then select **temperature_fahrenheit**.
    After you make the selections the following text will appear in the **Value**
    textbox: `datasources ["Ambient temperature and humidity"] ["temperature_fahrenheit"]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Enter `ºF` in **Units**, `-30` in **Minimum** and `130` in **Maximum**. Then,
    click **Save** and Freeboard will close the dialog box and add the new gauge to
    the previously created pane within the dashboard. The gauge will display the latest
    value that the code running in the board dweeted for the ambient temperature in
    degrees Fahrenheit, that is, the value for the `temperature_fahrenheit` key in
    the JSON data that the code has published for the last time to `dweet.io`. The
    following picture shows the **Ambient temperature and humidity** datasource displaying
    the last updated time and the gauge showing the latest value for the ambient temperature
    measured in degrees Fahrenheit.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a web-based dashboard with Freeboard](img/B05042_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on **Add pane** to add another new empty pane to the dashboard. Then,
    click on the plus sign (**+**) at the upper right corner of the new empty pane
    and Freeboard will display the **Widget** dialog box.
  prefs: []
  type: TYPE_NORMAL
- en: Select **Gauge** in the **Type** dropdown and the dialog box will display the
    fields required to add a gauge widget to the pane within the dashboard. Enter
    `Humidity level in percentage` in **Title**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **+ Datasource** at the right-hand side of the **Value** textbox, select
    **Ambient Temperature and humidity** and then select **humidity_level_percentage**.
    After you make the selections the following text will appear in the **Value**
    textbox: `datasources ["Ambient temperature and humidity"] ["humidity_level_percentage"]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Enter `%` in **Units**, `0` in **Minimum** and `100` in **Maximum**. Then, click
    **Save** and Freeboard will close the dialog box and add the new gauge to the
    previously created pane within the dashboard. The gauge will display the latest
    value that the code running in the board dweeted for the ambient humidity level
    in percentage, that is, the value for the `humidity_level_percentage` key in the
    JSON data that the code has published for the last time to `dweet.io`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, click on the plus sign (**+**) at the upper right corner of the pane that
    is displaying the temperature in degrees Fahrenheit and Freeboard will display
    the **Widget** dialog box.
  prefs: []
  type: TYPE_NORMAL
- en: Select **Gauge** in the **Type** dropdown and the dialog box will display the
    fields required to add a gauge widget to the pane within the dashboard. Enter
    `Temperature in degrees Celsius` in **Title**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **+ Datasource** at the right-hand side of the **Value** textbox, select
    **Ambient Temperature and humidity** and then select **temperature_celsius**.
    After you make the selections the following text will appear in the **Value**
    textbox: `datasources ["Ambient temperature and humidity"] ["temperature_celsius"]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Enter `ºC` in **Units**, `-40` in **Minimum** and `55` in **Maximum**. Then,
    click **Save** and Freeboard will close the dialog box and add the new gauge to
    the previously existing pane within the dashboard. This way, the pane will display
    two gauges, with the temperature expressed in two different units. The new gauge
    will display the latest value that the code running in the board dweeted for the
    ambient temperature in degrees Celsius, that is, the value for the `temperature_celsius`
    key in the JSON data that the code has published for the last time to `dweet.io`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, click on the configuration icon at the right-hand side of the **+** button
    of the pane that displays both temperatures. Freeboard will display the **Pane**
    dialog box. Enter `Temperature` in **Title** and click **Save**.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the configuration icon at the right-hand side of the **+** button of
    the pane that displays the humidity level. Freeboard will display the **Pane**
    dialog box. Enter `Humidity` in **Title** and click **Save**.
  prefs: []
  type: TYPE_NORMAL
- en: Drag and drop the panes to locate the **Humidity** pane at the left-hand side
    of the **Temperature** pane. The following picture shows the dashboard we built,
    with two panes and three gauges that refresh the data automatically when the code
    running on the Intel Galileo Gen 2 board dweets new data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a web-based dashboard with Freeboard](img/B05042_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can access the recently built dashboard in any device by entering the URL
    that our Web browser is displaying at the time we are working with the dashboard.
    The URL is composed of the `https://freeboard.io/board/` prefix followed by letters
    and numbers. For example, in case the URL is `https://freeboard.io/board/EXAMPLE`,
    we just need to enter it in any Web browser running on any device or computer
    connected to the Internet and we can watch the gauges and they will be refreshed
    as new data is being publishes from our Intel Galileo Gen 2 board to `dweet.io`.
  prefs: []
  type: TYPE_NORMAL
- en: The combination of `dweet.io` as our datasource and freeboard.io as our web-based
    dashboard made it easy for us to monitor the data retrieved from the sensor wired
    to our Intel Galileo Gen 2 board with any device that provides a Web browser.
    The combination of these two cloud-based services for IoT is just one example
    of how we can easily combine different services. There is an increase in the number
    of IoT cloud-based services, which can be used in our solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Sending and receiving data in real-time through Internet with PubNub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.html "Chapter 4. Working with a RESTful API and Pulse Width
    Modulation"), *Working with a RESTful API and Pulse Width Modulation*, we developed
    and consumed a RETful API that allows us to control electronic components connected
    to our Intel Galileo Gen 2 board through HTTP requests. Now, we want to send and
    receive data in real-time through the Internet and a RESTful API is not the most
    appropriate option to do this. Instead, we will work with a publish/subscribe
    model based on a protocol that is lighter than the HTTP protocol. Specifically,
    we will use a service based on the **MQTT** (short for **MQ Telemetry Transport**)
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MQTT protocol is a **machine-to-machine** (short for **M2M**) and Internet
    of Things connectivity protocol. MQTT is a lightweight messaging protocol that
    runs on top of the TCP/IP protocol and works with a publish-subscribe mechanism.
    It is possible for any device to subscribe to a specific channel (also known as
    topic) and it will receive all the messages published to this channel. In addition,
    the device can publish message to this or other channel. The protocol is becoming
    very popular in IoT and M2M projects. You can read more about the MQTT protocol
    in the following Webpage: [http://mqtt.org](http://mqtt.org).'
  prefs: []
  type: TYPE_NORMAL
- en: 'PubNub provides many cloud-based services and one of them allows us to easily
    stream data and signal any device in real-time, working with the MQTT protocol
    under the hoods. We will take advantage of this PubNub service to send and receive
    data in real-time through Internet and make it easy to control our Intel Galileo
    Gen 2 board through the Internet. As PubNub provides a Python API with high quality
    documentation and examples, it is extremely easy to use the service in Python.
    PubNub defines itself as the global data stream network for IoT, Mobile and Web
    applications. You can read more about PubNub in its Webpage: [http://www.pubnub.com](http://www.pubnub.com).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our example, we will take advantage of the free services offered by PubNub
    and we won't use some advanced features and additional services that might empower
    our IoT project connectivity requirements but also require a paid subscription.
  prefs: []
  type: TYPE_NORMAL
- en: PubNub requires us to sign up and create an account with a valid e-mail and
    a password before we can create an application within PubNub that allows us to
    start using their free services. We aren't required to enter any credit card or
    payment information. If you already have an account at PubNub, you can skip the
    next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you created your account PubNub will redirect you to the **Admin Portal**
    that lists your PubNub applications. It is necessary to generate your PubNub publish
    and subscribe keys in order to send and receive messages in the network. A new
    pane will represent the application in the Admin portal. The following screenshot
    shows the Temperature Control application pane in the PubNub Admin portal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending and receiving data in real-time through Internet with PubNub](img/B05042_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the **Temperature Control** pane and PubNub will display the **Demo
    Keyset** pane that has been automatically generated for the application. Click
    on this pane and PubNub will display the publish, subscribe, and secret keys.
    We must copy and paste each of these keys to use them in our code that will publish
    messages and subscribe to them. The following screenshot shows the prefixes for
    the keys and the remaining characters have been erased in the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending and receiving data in real-time through Internet with PubNub](img/B05042_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In order to copy the secret key, you must click on the eye icon at the right-hand
    side of the key and PubNub will make all the characters visible.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. Working with Python on Intel Galileo Gen
    2"), *Working with Python on Intel Galileo Gen 2*, we installed `pip` installer
    to easily install additional Python 2.7.3 packages in the Yocto Linux that we
    are running on the board. Now, we will use `pip` installer to install PubNub Python
    SDK 3.7.6\. We just need to run the following command in the SSH terminal to install
    the package. Notice that it can take a few minutes to complete the installation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The last lines for the output will indicate that the `pubnub` package has been
    successfully installed. Don't worry about the error messages related to building
    wheel and the insecure platform warning.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will take the code we wrote in the previous chapter when we read temperature
    and humidity values from the sensor, we printed the values in an OLED matrix and
    rotated a servo''s shaft to display the measured temperature expressed in degrees
    Fahrenheit with the shaft. The code file for the sample was `iot_python_chapter_08_03.py`.
    We will use this code as a baseline to add new features that will allow us to
    perform the following actions with PubNub messages sent to a specific channel
    from any device that has a Web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: Rotate the servo's shaft to display a temperature value in degrees Fahrenheit
    received as part of the message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display a line of text received as part of the message at the bottom of the
    OLED matrix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use the recently installed `pubnub` module to subscribe to a specific
    channel and run code when we receive messages in the channel. We will create a
    `MessageChannel` class to represent the communications channel, configure the
    PubNub subscription and declare the code for the callbacks that are going to be
    executed when certain events are fired. The code file for the sample is `iot_python_chapter_09_02.py`.
    Remember that we use the code file `iot_python_chapter_08_03.py` as a baseline,
    and therefore, we will add the class to the existing code in this file and we
    will create a new Python file. Don't forget to replace the strings assigned to
    the `publish_key` and `subscribe_key` local variables in the `__init__` method
    with the values you have retrieved from the previously explained PubNub key generation
    process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `MessageChannel` class declares the `command_key` class attribute that defines
    the key string that defines what the code will understand as the command. Whenever
    we receive a message that includes the specified key string, we know that the
    value associated to this key in the dictionary will indicate the command that
    the message wants the code running in the board to be processed. Each command
    requires additional key-value pairs that provide the necessary information to
    execute the command.
  prefs: []
  type: TYPE_NORMAL
- en: We have to specify the PubNub channel name, the `TemperatureServo` instance
    the `Oled` instance in the `channel`, `temperature_servo`, and `oled` required
    arguments. The constructor, that is, the `__init__` method, saves the received
    arguments in three attributes with the same names. The `channel` argument specifies
    the PubNub channel to which we are going to subscribe to listen to the messages
    that other devices send to this channel. We will also publish messages to this
    channel, and therefore, we will be both a subscriber and a publisher for this
    channel.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case, we will only subscribe to one channel. However, it is very important
    to know that we are not limited to subscribe to a single channel, we might subscribe
    to many channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the constructor declares two local variables: `publish_key` and `subscribe_key`.
    These local variables save the publish and subscribe keys that we had generated
    with the PubNub Admin portal. Then, the code creates a new `Pubnub` instance with
    `publish_key` and `subscribe_key` as the arguments, and saves the reference for
    the new instance in the `pubnub` attribute. Finally, the code calls the `subscribe`
    method for the new instance to subscribe to data on the channel saved in the `channel`
    attribute. Under the hoods, the `subscribe` method makes the client create an
    open TCP socket to the PubNub network that includes an MQTT broker and starts
    listening to messages on the specified channel. The call to this method specifies
    many methods declared in the `MessageChannel` class for the following named arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`callback`: Specifies the function that will be called when there is a new
    message received from the channel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`: Specifies the function that will be called on an error event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`connect`: Specifies the function that will be called when a successful connection
    is established with the PubNub cloud'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reconnect`: Specifies the function that will be called when a successful re-connection
    is completed with the PubNub cloud'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disconnect`: Specifies the function that will be called when the client disconnects
    from the PubNub cloud'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This way, whenever one of the previously enumerated events occur, the specified
    method will be executed. The `callback` method receives two arguments: `message`
    and `channel`. First, the method checks whether the received `channel` matches
    the value in the `channel` attribute. In this case, whenever the `callback` method
    is executed, the value in the `channel` argument will always match the value in
    the `channel` attribute because we just subscribed to one channel. However, in
    case we subscribe to more than one channel, is is always necessary to check which
    is the channel in which the message was sent and in which we are receiving the
    message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the code checks whether the `command_key` class attribute is included
    in the `message` dictionary. If the expression evaluates to `True`, it means that
    the message includes a command that we have to process. However, before we can
    process the command, we have to check which is the command, and therefore, it
    is necessary to retrieve the value associated with the key equivalent to the `command_key`
    class attribute. The code is capable of running code when the value is any of
    the following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`print_temperature_fahrenheit`: The command must specify the temperature value
    expressed in degrees Fahrenheit in the value of the `temperature_fahrenheit` key.
    The code calls the `self.temperature_servo.print_temperature` method with the
    temperature value retrieved from the dictionary as an argument. This way, the
    code moves the servo''s shaft based on the specified temperature value in the
    message that includes the command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print_information_message`: The command must specify the line of text that
    has to be displayed at the bottom of the OLED matrix in the value of the `print_information_message`
    key. The code calls the `self.oled.print_line` method with `11` and the text value
    retrieved from the dictionary as arguments. This way, the code displays the text
    received in the message that includes the command at the bottom of the OLED matrix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No matter whether the message included a valid command or not, the method prints
    the raw message that it received in the console output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `connect` method prints a message indicating that a connection has been
    established with the channel. Then, the method prints the results of calling the
    `self.pubnub.publish` method that publishes a message in the channel name saved
    in `self.channel` with the following message: `"Listening to messages in the Intel
    Galileo Gen 2 board"`. In this case, the call to this method runs with a synchronous
    execution. We will work with asynchronous execution for this method in our next
    example.'
  prefs: []
  type: TYPE_NORMAL
- en: At this time, we are already subscribed to this channel, and therefore, we will
    receive the previously published message and the callback method will be executed
    with this message as an argument. However, as the message doesn't include the
    key that identifies a command, the code in the callback method will just display
    the received message and it won't process any of the previously analyzed commands.
  prefs: []
  type: TYPE_NORMAL
- en: The other methods declared in the `MessageChannel` class just display information
    to the console output about the event that has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will use the previously coded `MessageChannel` class to create a new
    version of the `__main__` method that uses the PubNub cloud to receive and process
    commands. The new version doesn't rotate the servo's shaft when the ambient temperature
    changes, instead, it will do this when it receives the appropriate command from
    any device connected to PubNub cloud. The following lines show the new version
    of the `__main__` method. The code file for the sample is `iot_python_chapter_09_02.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted line creates an instance of the previously coded `MessageChannel`
    class with `"temperature"`, `temperature_servo`, and `oled` as the arguments.
    The constructor will subscribe to the `temperature` channel in the PubNub cloud,
    and therefore, we must send the messages to this channel in order to send the
    commands that the code will process with an asynchronous execution. The loop will
    read the values from the sensor and print the values to the console as in the
    previous version of the code, and therefore, we will have code running in the
    loop and we will also have code listening to the messages in the `temperature`
    channel in the PubNub cloud. We will start the example later because we want to
    subscribe to the channel in the PubNub debug console before we run the code in
    the board.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing messages with commands through the PubNub cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will take advantage of the PubNub console to send messages with commands
    to the `temperature` channel and make the Python code running on the board process
    these commands. In case you have logged out of PubNub, login again and click on
    the **Temperature Control** pane in the **Admin Portal**. PubNub will display
    the **Demo Keyset** pane.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Demo Keyset** pane and PubNub will display the publish, subscribe,
    and secret keys. This way, we select the keyset that we want to use for our PubNub
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Debug Console** on the sidebar located the left-hand side of the
    screen. PubNub will create a client for a default channel and subscribe to this
    channel using the secret keys we have selected in the previous step. We want to
    subscribe to the `temperature` channel, and therefore, enter `temperature` in
    the **Default Channel** textbox within a pane that includes the **Add client**
    button at the bottom. Then, click on **Add client** and PubNub will add a new
    pane with a random client name as a title and the channel name, `temperature`,
    in the second line. PubNub makes the client subscribe to this channel and we will
    be able to receive messages published to this channel and send messages to this
    channel. The following picture shows the pane for the generated client named **Client-ot7pi**,
    subscribed to the `temperature` channel. Notice that the client name will be different
    when you follow the explained steps.
  prefs: []
  type: TYPE_NORMAL
- en: '![Publishing messages with commands through the PubNub cloud](img/B05042_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The client pane displays the output generated when PubNub subscribed the client
    to the channel. PubNub returns a formatted response for each command. In this
    case, it indicates that the status is equal to `Subscribed` and the channel name
    is `temperature`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it is time to start running the example in the Intel Galileo Gen 2 board.
    The following line will start the example in the SSH console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After you run the example, go to the Web browser in which you are working with
    the PubNub debug console. You will see the following message listed in the previously
    created client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The Python code running in the board published this message, specifically, the
    `connect` method in the `MessageChannel` class sent this message after the application
    established a connection with the PubNub cloud. The following picture shows the
    message listed in the previously created client. Notice that the icon at the left-hand
    side of the text indicates it is a message. The other message was a debug message
    with the results of subscribing to the channel.
  prefs: []
  type: TYPE_NORMAL
- en: '![Publishing messages with commands through the PubNub cloud](img/B05042_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At the bottom of the client pane, you will see the following text and the **Send**
    button at the right-hand side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will replace the previously shown text with a message. Enter the following
    JSON code and click **Send**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The text editor where you enter the message has some issues in certain browsers.
    Thus, it is convenient to use your favorite text editor to enter the JSON code,
    copy it and then past it to replace the text that is included by default in the
    text for the message to be sent.
  prefs: []
  type: TYPE_NORMAL
- en: After you click **Send**, the following lines will appear in the client log.
    The first line is a debug message with the results of publishing the message and
    indicates that the message has been sent. The formatted response includes a number
    (`1` message), the status (`Sent`) and a time token. The second line is the message
    that arrives to the channel because we are subscribed to the `temperature` channel,
    that is, we also receive the message we sent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following picture shows the messages and debug messages log for the PubNub
    client after we clicked the **Send** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Publishing messages with commands through the PubNub cloud](img/B05042_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After you publish the previous message, you will see the following output in
    the SSH console for the Intel Galileo Gen 2 board. You will notice the servo's
    shaft rotates to 50 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, enter the following JSON code and click **Send**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: After you click **Send**, the following lines will appear in the client log.
    The first line is a debug message with the previously explained formatted response
    with the results of publishing the message and indicates that the message has
    been sent. The second line is the message that arrives to the channel because
    we are subscribed to the `temperature` channel, that is, we also receive the message
    we sent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The following picture shows the messages and debug messages log for the PubNub
    client after we clicked the **Send** button.
  prefs: []
  type: TYPE_NORMAL
- en: '![Publishing messages with commands through the PubNub cloud](img/B05042_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After you publish the previous message, you will see the following output in
    the SSH console for the Intel Galileo Gen 2 board. You will see the following
    text displayed at the bottom of the OLED matrix: `Client ready`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When we published the two messages with the commands, we have definitely noticed
    a problem. We don't know whether the command was processed or not in the code
    that is running on the IoT device, that is, in the Intel Galileo Gen 2 board.
    We know that the board started listening messages in the temperature channel,
    but we don't receive any kind of response from the IoT device after the command
    has been processed.
  prefs: []
  type: TYPE_NORMAL
- en: Working with bi-directional communications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can easily add a few lines of code to publish a message to the same channel
    in which we are receiving messages to indicate that the command has been successfully
    processed. We will use our previous example as a baseline and we will create a
    new version of the `MessageChannel` class. The code file was `iot_python_chapter_09_02.py`.
    Don't forget to replace the strings assigned to the `publish_key` and `subscribe_key`
    local variables in the `__init__` method with the values you have retrieved from
    the previously explained PubNub key generation process. The following lines show
    the new version of the `MessageChannel` class that publishes a message after a
    command has been successfully processed. The code file for the sample is `iot_python_chapter_09_03.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines in the previous code for the new version of the `MessageChannel`
    class show the changes we made in the code. First, the code declares the `successfully_processed_command_key`
    class attribute that defines the key string that defines what the code will use
    as a successfully processed command key in a response message published to the
    channel. Whenever we publish a message that includes the specified key string,
    we know that the value associated to this key in the dictionary will indicate
    the command that the board has successfully processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code declares the following three new methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`callback_response_message`: This method will be used as the callback that
    will be executed when a successfully processed command response message is published
    to the channel. The method just prints the formatted response that PubNub returns
    when a message has been successfully published in the channel. In this case, the
    `message` argument doesn''t hold the original message that has been published,
    it holds the formatted response. We use `message` for the argument name to keep
    consistency with the PubNub API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error_response_message`: This method will be used as the callback that will
    be executed when an error occurs when trying to publish a successfully processed
    command response message to the channel. The method just prints the error message
    that PubNub returns when a message hasn''t been successfully published in the
    channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`publish_response_message`: This method receives the message with the command
    that was successfully processed in the `message` argument. The code creates a
    `response_message` dictionary with the `successfully_processed_command_key` class
    attribute as the key and the value of the key specified in the `command_key` class
    attribute for the message dictionary as the value. Then, the code calls the `self.pubnub.publish`
    method to publish the `response_message` dictionary to the channel saved in the
    `channel` attribute. The call to this method specifies `self.callback_response_message`
    as the callback to be executed when the message is successfully published and
    `self.error_response_message` as the callback to be executed when an error occurred
    during the publishing process. When we specify a callback, the publish method
    works with an asynchronous execution, and therefore, the execution is non-blocking.
    The publication of the message and the callbacks that are specified will run in
    a different thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, the `callback` method defined in the `MessageChannel` class adds a call
    to the `publish_response_message` method with the message that included the command
    that has been successfully processed (`message`) as an argument. As previously
    explained, the `publish_response_message` method is non-blocking and will return
    immediately while the successfully processed message is published in another thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is time to start running the example in the Intel Galileo Gen 2 board.
    The following line will start the example in the SSH console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After you run the example, go to the Web browser in which you are working with
    the PubNub debug console. You will see the following message listed in the previously
    created client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following JSON code and click **Send**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: After you click **Send**, the following lines will appear in the client log.
    The last message has been published by the board to the channel and indicates
    that the `print_temperature_fahrenheit` command has been successfully processed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following picture shows the messages and debug messages log for the PubNub
    client after we clicked the **Send** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with bi-directional communications](img/B05042_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After you publish the previous message, you will see the following output in
    the SSH console for the Intel Galileo Gen 2 board. You will notice the servo's
    shaft rotates to 90 degrees. The board also receives the successfully processed
    command message because it is subscribed to the channel in which the message has
    been published.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, enter the following JSON code and click **Send**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: After you click **Send**, the following lines will appear in the client log.
    The last message has been published by the board to the channel and indicates
    that the `print_information_message` command has been successfully processed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The following picture shows the messages and debug messages log for the PubNub
    client after we clicked the **Send** button.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with bi-directional communications](img/B05042_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After you publish the previous message, you will see the following output in
    the SSH console for the Intel Galileo Gen 2 board. You will see the following
    text displayed at the bottom of the OLED matrix: `2nd message`. The board also
    receives the successfully processed command message because it is subscribed to
    the channel in which the message has been published.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We can work with the different SDKs provided by PubNub to subscribe and publish
    to a channel. We can also make different IoT devices talk to themselves by publishing
    messages to channels and processing them. In this case, we just created a few
    commands and we didn't add detailed information about the device that has to process
    the command or the device that has generated a specific message. A more complex
    API would require commands that include more information and security.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing messages to the cloud with a Python PubNub client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been using the PubNub debug console to publish messages to the
    `temperature` channel and make the Python code running in the Intel Galileo Gen
    2 board process them. Now, we are going to code a Python client that will publish
    messages to the `temperature` channel. This way, we will be able to design applications
    that can talk to IoT devices with Python code in the publisher and in the subscriber
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: We can run the Python client on another Intel Galileo Gen 2 board or in any
    device that has Python 2.7.x installed. In addition, the code will run with Python
    3.x. For example, we can run the Python client in our computer. We just need to
    make sure that we install the `pubnub` module we have previously installed with
    pip in the Python version that is running in the Yocto Linux for the board.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a `Client` class to represent a PubNub client, configure the
    PubNub subscription, make it easy to publish a message with a command and the
    required values for the command and declare the code for the callbacks that are
    going to be executed when certain events are fired. The code file for the sample
    is `iot_python_chapter_09_04.py`. Don''t forget to replace the strings assigned
    to the `publish_key` and `subscribe_key` local variables in the `__init__` method
    with the values you have retrieved from the previously explained PubNub key generation
    process. The following lines show the code for the `Client` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `Client` class declares the `command_key` class attribute that defines the
    key string that defines what the code understands as a command in the messages.
    Our main goal is to build and publish command messages to a specified channel.
    We have to specify the PubNub channel name in the `channel` required argument.
    The constructor, that is, the `__init__` method, saves the received argument in
    an attribute with the same name. We will be both a subscriber and a publisher
    for this channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the constructor declares two local variables: `publish_key` and `subscribe_key`.
    These local variables save the publish and subscribe keys we had generated with
    the PubNub Admin portal. Then, the code creates a new `Pubnub` instance with `publish_key`
    and `subscribe_key` as the arguments, and saves the reference for the new instance
    in the `pubnub` attribute. Finally, the code calls the `subscribe` method for
    the new instance to subscribe to data on the channel saved in the `channel` attribute.
    The call to this method specifies many methods declared in the `Client` class
    as we did for our previous examples.'
  prefs: []
  type: TYPE_NORMAL
- en: The `publish_command` method receives a command name, the key and the value
    that provide the necessary information to execute the command in the `command_name`,
    `key` and `value` required arguments. In this case, we don't target the command
    to a specific IoT device and all the devices that subscribe to the channel and
    run the code in our previous example will process the commands that we publish.
    We can use the code as a baseline to work with more complex examples in which
    we have to generate commands that target specific IoT devices. Obviously, it is
    also necessary to improve the security.
  prefs: []
  type: TYPE_NORMAL
- en: The method creates a dictionary and saves it in the `command_message` local
    variable. The `command_key` class attribute is the first key for the dictionary
    and the `command_name` received as an argument, the value that composes the first
    key-value pair. Then, the code calls the `self.pubnub.publish` method to publish
    the `command_message` dictionary to the channel saved in the `channel` attribute.
    The call to this method specifies `self.callback_command_message` as the callback
    to be executed when the message is successfully published and `self.error_command_message`
    as the callback to be executed when an error occurred during the publishing process.
    As happened in our previous example, when we specify a callback, the `publish`
    method works with an asynchronous execution.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will use the previously coded `Client` class to write a `__main__` method
    that uses the PubNub cloud to publish two commands that our board will process.
    The following lines show the code for the `__main__` method. The code file for
    the sample is `iot_python_chapter_09_04.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The code in the `__main__` method is very easy to understand. The code creates
    an instance of the `Client` class with `"temperature"` as an argument to become
    both a subscriber and a publisher for this channel in the PubNub cloud. The code
    saves the new instances in the `client` local variable.
  prefs: []
  type: TYPE_NORMAL
- en: The code calls the `publish_command` method with the necessary arguments to
    build and publish the `print_temperature_fahrenheit` command with a temperature
    value of `45`. The method will publish the command with an asynchronous execution.
    Then, the code calls the `publish_command` method again with the necessary arguments
    to build and publish the `print_information_message` command with a text value
    of `"Python IoT"`. The method will publish the second command with an asynchronous
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the code sleeps for 1 minute (60 seconds) in order to make it possible
    for the asynchronous executions to successfully publish the commands. The different
    callbacks defined in the `Client` class will be executed as the different events
    fire. As we are also subscribed to the channel, we will also receive the messages
    we publish in the `temperature` channel.
  prefs: []
  type: TYPE_NORMAL
- en: Keep the Python code we have executed in our previous example running on the
    board. We want the board to process our commands. In addition, keep the Web browser
    in which you are working with the PubNub debug console opened because we also
    want to see all the messages in the log.
  prefs: []
  type: TYPE_NORMAL
- en: The following line will start the example for the Python client in any computer
    or device that you want to use as a client. It is possible to run the code in
    another SSH terminal in case you want to use the same board as a client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: After you run the example, you will see the following output in the Python console
    that runs the Python client, that is, the `iot_python_chapter_09_04.py` Python
    script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The code used the PubNub Python SDK to build and publish the following two
    command messages in the `temperature` channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As we are also subscribed to the temperature channel, we receive the messages
    we sent with an asynchronous execution. Then, we received the successfully processed
    command messages for the two command messages. The board has processed the commands
    and published the messages to the `temperature` channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you run the example, go to the Web browser in which you are working with
    the PubNub debug console. You will see the following messages listed in the previously
    created client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following picture shows the last messages displayed in the log for the
    PubNub client after we run the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Publishing messages to the cloud with a Python PubNub client](img/B05042_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will see the following text displayed at the bottom of the OLED matrix:
    `Python IoT`. In addition, the servo''s shaft will rotate to 45 degrees.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use the PubNub SDKs available in different programming languages to create
    applications and apps that publish and receive messages in the PubNub cloud and
    interact with IoT devices. In this case, we worked with the Python SDK to create
    a client that publishes commands. It is possible to create mobile apps that publish
    commands and easily build an app that can interact with our IoT device.
  prefs: []
  type: TYPE_NORMAL
- en: Using MQTT with Mosquitto and Eclipse Paho
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mosquitto is an open source message broker that implements the versions 3.1
    and 3.1.1 of the MQTT protocol, and therefore, allows us to work with messages
    using the publish/subscribe model. Mosquitto is an iot.eclipse.org project and
    is provided with the Eclipse Public Project (EPL)/EDL license. The following is
    the Web page for Mosquitto: [http://mosquitto.org](http://mosquitto.org).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Eclipse Paho project provides an open source client implementation of MQTT.
    The project includes a Python client, also known as the Paho Python Client or
    Eclipse Paho MQTT Python client library. This Python client has been contributed
    from the Mosquitto project and was originally the Mosquitto Python Client. The
    following is the Web page for the Eclipse Paho project: [http://www.eclipse.org/paho](http://www.eclipse.org/paho).
    The following is the Web page for the Eclipse Paho MQTT Python client library,
    that is, the paho-mqtt module: [https://pypi.python.org/pypi/paho-mqtt/1.1](https://pypi.python.org/pypi/paho-mqtt/1.1).'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. Working with Python on Intel Galileo Gen
    2"), *Working* *with Python on Intel Galileo Gen 2*, we installed `pip` installer
    to easily install additional Python 2.7.3 packages in the Yocto Linux that we
    are running on the board. Now, we will use `pip` installer to install paho-mqtt
    1.1\. We just need to run the following command in the SSH terminal to install
    the package.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The last lines for the output will indicate that the `paho-mqtt` package has
    been successfully installed. Don't worry about the error messages related to building
    wheel and the insecure platform warning.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Eclipse allows us to use a publically accessible sandbox server for the Eclipse
    IoT projects at [iot.eclipse.org](http://iot.eclipse.org), port 1883\. In the
    following examples, we will use this sandbox server as our Mosquitto message broker.
    This way, we don't have to setup a Mosquitto message broker to test the examples
    and learn how to work with the Paho Python Client. However, in a real-life application,
    we should setup a Mosquitto message broker and use it for our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will take the code we wrote in the previous chapter when we read temperature
    and humidity values from the sensor, we printed the values in an OLED matrix and
    rotated a servo''s shaft to display the measured temperature expressed in degrees
    Fahrenheit with the shaft. The code file for the sample was `iot_python_chapter_08_03.py`.
    We will use this code as a baseline to add the same features that we added when
    we worked with the PubNub cloud. However, in this case, we will use the Paho Python
    Client and the publically accessible sandbox server that provides us with a Mosquitto
    message broker. We will be able to perform the following actions with MQTT messages
    sent to a specific topic from any device that can publish MQTT messages in the
    topic to which we are subscribed:'
  prefs: []
  type: TYPE_NORMAL
- en: Rotate the servo's shaft to display a temperature value in degrees Fahrenheit
    received as part of the message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display a line of text received as part of the message at the bottom of the
    OLED matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Paho Python Client uses the topic name instead of channel. You can think
    of a topic as a channel.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the recently installed `paho-mqtt` module to subscribe to a specific
    topic and run code when we receive messages in the topic. We will create a `MessageTopic`
    class to represent the communications topic, configure the MQTT client, the subscription
    to the client and declare the code for the callbacks that are going to be executed
    when certain events are fired. The code file for the sample is `iot_python_chapter_09_05.py`.
    Remember that we use the code file `iot_python_chapter_08_03.py` as a baseline,
    and therefore, we will add the class to the existing code in this file and we
    will create a new Python file. Don't forget to replace the strings assigned to
    the `topic` class attribute with your unique topic name. As the Mosquitto broker
    we are using is public, you should use a unique topic to make sure you only receive
    the messages you publish.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `MessageTopic` class declares the `command_key` class attribute that defines
    the key string that defines what the code will understand as the command. Whenever
    we receive a message that includes the specified key string, we know that the
    value associated to this key in the dictionary will indicate the command that
    the message wants the code running in the board to be processed. In this case,
    we don't receive messages as dictionaries, and therefore, it is necessary to convert
    them from strings to dictionaries when they are not just a string.
  prefs: []
  type: TYPE_NORMAL
- en: The code declares the `successfully_processed_command_key` class attribute that
    defines the key string that defines what the code will use as a successfully processed
    command key in a response message published to the topic. Whenever we publish
    a message that includes the specified key string, we know that the value associated
    to this key in the dictionary will indicate the command that the board has successfully
    processed.
  prefs: []
  type: TYPE_NORMAL
- en: We have to specify the `TemperatureServo` instance and the `Oled` instance in
    the `temperature_servo` and `oled` required arguments. The constructor, that is,
    the `__init__` method, saves the received arguments in two attributes with the
    same names. The `topic` class attribute argument specifies the Mosquitto topic
    to which we are going to subscribe to listen to the messages that other devices
    send to this topic. We will also publish messages to this topic, and therefore,
    we will be both a subscriber and a publisher for this channel.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the constructor creates an instance of the `mqtt.Client` class that represents
    an MQTT client and we will use to communicate with an MQTT broker. As we create
    the instance with the default parameters, we will create an instance of `paho.mqtt.client.MQTTv31`
    and we will work with MQTT version 3.1.
  prefs: []
  type: TYPE_NORMAL
- en: The code also saves a reference to this instance in the `active_instance` class
    attribute because we have to access the instance in static methods that we will
    be specified as callbacks for the different events that the MQTT client fires.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code assigns the `self.client.on_connect` attribute to the `on_connect`
    static method and the `self.client.on_message` attribute to the `on_message` static
    method. Static methods do not receive either `self` of `cls` as the first argument,
    and therefore, we can use them as callbacks with the required number of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the constructor calls the `self.client.connect` method and specifies
    the publically accessible sandbox server for the Eclipse IoT projects at iot.eclipse.org,
    port 1883, in the arguments. This way, the code asks the MQTT client to establish
    a connection to the specified MQTT broker. In case you decide to use your own
    Mosquitto broker, you just need to change the values for the `host` and `port`
    arguments, according to the configuration for the Mosquitto broker. The `connect`
    method runs with an asynchronous execution, and therefore, it is a non-blocking
    call.
  prefs: []
  type: TYPE_NORMAL
- en: After a connection has been successfully established with the MQTT broker, the
    specified callback in the `self.client.on_connect` attribute will be executed,
    that is, the `on_connect` static method (marked with the `@staticmethod` decorator).
    This static method receives the `mqtt.Client` instance that established the connection
    with the MQTT broker in the `client` argument. The code calls the `client.subscribe`
    method with `MessageTopic.topic` as an argument to subscribe to the topic specified
    in the `topic` class attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case, we will only subscribe to one topic. However, it is very important
    to know that we are not limited to subscribe to a single topic, we might subscribe
    to many topics with a single call to the `subscribe` method.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the code calls the `client.publish` method with `MessageTopic.topic`
    as the `topic` argument and a message string in the `payload` argument. This way,
    we publish a string message that says `"Listening to messages in the Intel Galileo
    Gen 2 board"` to the topic specified in the `topic` class attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever there is a new message received in the topic to which we have subscribed,
    the specified callback in the `self.client.on_messsage` attribute will be executed,
    that is, the `on_message` static method (marked with the `@staticmethod` decorator).
    This static method receives the `mqtt.Client` instance that established the connection
    with the MQTT broker in the `client` argument and an `mqtt.MQTTMessage` instance
    in the `msg` argument. The `mqtt.MQTTMessage` class describes an incoming message.
    First, the static method checks whether the `msg.topic` attribute, that indicates
    the topic in which the message has been received, matches the value in the `topic`
    class attribute. In this case, whenever the `on_message` method is executed, the
    value in `msg.topic` will always match the value in the `topic` class attribute
    because we just subscribed to one topic. However, in case we subscribe to more
    than one topic, is is always necessary to check which is the topic in which the
    message was sent and in which we are receiving the message.
  prefs: []
  type: TYPE_NORMAL
- en: The code prints the message that has been received, that is, the `msg.payload`
    attribute. Then, the code assigns the result of the `json.loads` function to deserialize
    `msg.payload` to a Python object and assigns the results to the `message_dictionary`
    local variable. In case the contents of `msg.payload` are not JSON, a `ValueError`
    exception will be captured and no more code will be executed in the method. In
    case the contents of `msg.payload` are JSON, we will have a dictionary in the
    `message_dictionary` local variable.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code checks whether the `command_key` class attribute is included
    in the `message_dictionary` dictionary. If the expression evaluates to `True`,
    it means that the JSON message converted to a dictionary includes a command that
    we have to process. However, before we can process the command, we have to check
    which is the command, and therefore, it is necessary to retrieve the value associated
    with the key equivalent to the `command_key` class attribute. The code is capable
    of running specific code when the value is any of the two commands that we used
    in our previous example when we worked with the PubNub cloud.
  prefs: []
  type: TYPE_NORMAL
- en: The code uses the `active_instance` class attribute that has a reference to
    the active `MessageTopic` instance to call the necessary methods for either the
    `temperature_servo` or the `oled` attribute based on the command that has to be
    processed. We had to declare the callbacks as static methods, and therefore, we
    use this class attribute to access the active instance.
  prefs: []
  type: TYPE_NORMAL
- en: Once the command has been successfully processed, the code calls the `publish_response_message`
    for the `MessageTopic` instance saved in the `active_instance` class attribute.
    This method receives the message dictionary that has been received with the command
    in the `message` argument. The method calls the `json.dumps` function to serialize
    a dictionary to a JSON formatted string with the response message that indicates
    the command has been successfully processed. Finally, the code calls the `client.publish`
    method with the `topic` class attribute as the `topic` argument and the JSON formatted
    string (`response_message`) in the `payload` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case, we are not evaluating the response from the `publish` method.
    In addition, we are using the default value for the `qos` argument that specifies
    the desired quality of service. In more advanced scenarios, we should add code
    to check the results of the method and probably adding code on the `on_publish`
    callback that is fired when a message is successfully published.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will use the previously coded `MessageTopic` class to create a new version
    of the `__main__` method that uses the Mosquitto broker and the MQTT client to
    receive and process commands. The new version doesn't rotate the servo's shaft
    when the ambient temperature changes, instead, it will do this when it receives
    the appropriate command from any device connected to the Mosquitto broker. The
    following lines show the new version of the `__main__` method. The code file for
    the sample is `iot_python_chapter_09_05.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted line creates an instance of the previously coded `MessageTopic`
    class with `temperature_servo` and `oled` as the arguments. The constructor will
    subscribe to the `"iot-python-gaston-hillar/temperature"` topic in the Mosquitto
    broker, and therefore, we must publish messages to this topic in order to send
    the commands that the code will process. The loop will read the values from the
    sensor and print the values to the console as in the previous version of the code,
    and therefore, we will have code running in the loop and we will also have code
    listening to the messages in the `"iot-python-gaston-hillar/temperature"` topic
    in the Mosquitto broker. The last lines of the loop call the `message_channel.loop`
    method 10 times and sleep 1 second each time between the calls. The `loop` method
    calls the loop method for the MQTT client to and ensures communication with the
    broker is carried out. Think about the call to the loop method as synchronizing
    your mailbox. Any pending messages to the published in the outgoing box will be
    sent and any incoming messages will arrive to the inbox and the events that we
    have previously analyzed will be fired.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is also a threaded interface that we can run by calling the `loop_start`
    method for the MQTT client. This way, we can avoid multiple calls to the `loop`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The following line will start the example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Keep the code running in the board. We will start receiving messages later because
    we have to write the code that will publish messages to this topic and send the
    commands to be processed.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing messages to a Mosquitto broker with a Python client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have the code that is going to be running in the Intel Galileo Gen 2 board
    to process the command messages received from the Mosquitto message broker. Now,
    we are going to code a Python client that will publish messages to the `"iot-python-gaston-hillar/temperature"`
    channel. This way, we will be able to design applications that can talk to IoT
    devices with MQTT messages. Specifically, the applications will be able to communicate
    through a Mosquitto message broker with Python code in the publisher and in the
    subscriber devices.
  prefs: []
  type: TYPE_NORMAL
- en: We can run the Python client on another Intel Galileo Gen 2 board or in any
    device that has Python 2.7.x installed. In addition, the code will run with Python
    3.x. For example, we can run the Python client in our computer. We just need to
    make sure that we install the `pubnub` module we have previously installed with
    pip in the Python version that is running in the Yocto Linux for the board.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create many functions that we will assign as the callbacks to the events
    in the MQTT client. In addition, we will declare variables and a helper function
    to make it easy to publish a message with a command and the required values for
    the command. The code file for the sample is `iot_python_chapter_09_06.py`. Don''t
    forget to replace the string assigned to the `topic` variable with the topic name
    you have specified in the previous code. The following lines show the code that
    defines the variables and the functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The code declares the `command_key` variable that defines the key string that
    indicates what the code understands as a command in the messages. Our main goal
    is to build and publish command messages to the topic specified in the `topic`
    variable. We will be both a subscriber and a publisher for this topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `on_connect` function is the callback that will be executed once a successful
    connection has been established with the Mosquitto MQTT broker. The code calls
    the `subscribe` method for the MQTT client received in the `client` argument and
    then calls the `publish` method to send the following string message to the topic:
    `"Listening to messages in the Paho Python Client"`'
  prefs: []
  type: TYPE_NORMAL
- en: The code calls the `publish_command` function with the necessary arguments to
    build and publish the `print_temperature_fahrenheit` command with a temperature
    value of 45\. Finally, the code calls the `publish_command` function again with
    the necessary arguments to build and publish the `print_information_message` command
    with a text value of `"Python IoT"`.
  prefs: []
  type: TYPE_NORMAL
- en: The `publish_command` function receives the MQTT client, the topic, the command
    name, the key and the value that provide the necessary information to execute
    the command in the `client`, `topic`, `command_name`, `key` and `value` required
    arguments. In this case, we don't target the command to a specific IoT device
    and all the devices that subscribe to the topic and run the code in our previous
    example will process the commands that we publish. We can use the code as a baseline
    to work with more complex examples in which we have to generate commands that
    target specific IoT devices. As happened in our previous examples, it is also
    necessary to improve the security.
  prefs: []
  type: TYPE_NORMAL
- en: The function creates a dictionary and saves the results of serializing the dictionary
    to a JSON formatted string in the `command_message` local variable. The `command_key`
    variable is the first key for the dictionary and the `command_name` received as
    an argument, the value that composes the first key-value pair. Then, the code
    calls the `client.publish` method to publish the `command_message` JSON formatted
    string to the topic received as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: The `on_message` function will be executed each time a new message arrives to
    the topic to which we have subscribed. The function just prints the raw string
    with the payload of the received message.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will use the previously coded `functions` to write a `__main__` method
    that publishes the two commands included in MQTT messages that our board will
    process. The following lines show the code for the `__main__` method. The code
    file for the sample is `iot_python_chapter_09_06.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The code in the `__main__` method is very easy to understand. The code creates
    an instance of the `mqtt.Client` class that represents an MQTT client and we will
    use it to communicate with an MQTT broker. As we create the instance with the
    default parameters, we will create an instance of `paho.mqtt.client.MQTTv31` and
    we will work with MQTT version 3.1.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code assigns the `client.on_connect` attribute to the previously coded
    `on_connect` function and the `client.on_message` attribute to the `on_message`
    function. The code calls the `client.connect` method and specifies the publically
    accessible sandbox server for the Eclipse IoT projects at iot.eclipse.org, port
    1883, in the arguments. This way, the code asks the MQTT client to establish a
    connection to the specified MQTT broker. In case you decide to use your own Mosquitto
    broker, you just need to change the values for the `host` and `port` arguments,
    according to the configuration for the Mosquitto broker. Remember that the `connect`
    method runs with an asynchronous execution, and therefore, it is a non-blocking
    call.
  prefs: []
  type: TYPE_NORMAL
- en: After a connection has been successfully established with the MQTT broker, the
    specified callback in the `client.on_connect` attribute will be executed, that
    is, the `on_connect` function. The function receives the `mqtt.Client` instance
    that established the connection with the MQTT broker in the `client` argument.
    As previously explained, the function subscribes to a topic and schedules the
    publication of three messages to it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the code calls the `client.loop_forever` method that calls the loop
    method for us in an infinite blocking loop. At this point, we only want to run
    the MQTT client loop in our program. The scheduled messages will be published
    and we will receive the messages with the successfully executed command details
    after the board processes the commands.
  prefs: []
  type: TYPE_NORMAL
- en: Keep the Python code we have executed in our previous example running on the
    board. We want the board to process our commands. The following line will start
    the example for the Python client in any computer or device that you want to use
    as a client. It is possible to run the code in another SSH terminal in case you
    want to use the same board as a client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: After you run the example, you will see the following output in the Python console
    that runs the Python client, that is, the `iot_python_chapter_09_06.py` Python
    script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The code used the Eclipse Paho MQTT Python client library to build and publish
    the following two command messages in the `"iot-python-gaston-hillar/temperature"`
    topic in the Mosquitto broker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As we are also subscribed to the `"iot-python-gaston-hillar/temperature"` topic,
    we receive the messages we sent. Then, we received the successfully processed
    command messages for the two command messages. The board has processed the commands
    and published the messages to the `"iot-python-gaston-hillar/temperature"` topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the following messages in the output for the SSH terminal that
    is running the code for the board that processes the commands, that is, the `iot_python_chapter_09_05.py`
    Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following text displayed at the bottom of the OLED matrix:
    `Python IoT`. In addition, the servo''s shaft will rotate to 45 degrees.'
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MQTT is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A heavyweight messaging protocol that runs on top of the TCP/IP protocol and
    works with a publish-subscribe mechanism.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A lightweight messaging protocol that runs on top of the TCP/IP protocol and
    works with a publish-subscribe mechanism.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An equivalent to HTTP.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Mosquitto is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An open source message broker that implements the versions 3.1 and 3.1.1 of
    the MQTT protocol.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A closed source message broker that implements the versions 3.1 and 3.1.1 of
    the MQTT protocol.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An open source message broker that implements a RESTful API.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Eclipse Paho project provides:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An open source client implementation of HTTP.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An open source client implementation of `dweet.io`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An open source client implementation of MQTT.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following Python modules is the Paho Python Client?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: paho-client-pip.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: paho-mqtt.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: paho-http.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Dweepy is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A simple Python client for `dweet.io` that allows us to easily publish data
    to `dweet.io` with Python.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A simple Python client for Mosquitto that allows us to easily publish messages
    to a Mosquitto message broker.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A simple Python client for PubNub cloud that allows us to easily publish messages
    to the PubNub cloud.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we combined many cloud-based services that allowed us to easily
    publish data collected from sensors and visualize it in a web-based dashboard.
    We realized that there is always a Python API, and therefore, it is easy to write
    Python code that interacts with popular cloud-based services.
  prefs: []
  type: TYPE_NORMAL
- en: We worked with the MQTT protocol and its publish/subscribe model to process
    commands in our board and indicate when the commands were successfully processed
    through messages. First, we worked with the PubNub cloud that works with the MQTT
    protocol under the hoods. Then, we developed the same example with Mosquitto and
    Eclipse Paho. Now, we know how we can write applications that can establish bi-directional
    communications with our IoT devices. In addition, we know how we can make IoT
    devices communicate with other IoT devices.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are able to take advantage of many cloud services and we worked
    with the MQTT protocol, we will learn how to analyze huge amounts of data, which
    is the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
