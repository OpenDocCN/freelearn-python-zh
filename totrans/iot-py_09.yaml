- en: Chapter 9. Working with the Cloud
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will take advantage of many cloud services to publish and
    visualize data collected for sensors and to establish bi-directional communications
    between Internet-connected things. We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Publishing data to the cloud with dweepy and `dweet.io`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a web-based dashboard with freeboard.io
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending and receiving data in real time through Internet with PubNub
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing messages with commands through the PubNub cloud
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with bi-directional communications between IoT devices and other devices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing messages to the cloud with a Python PubNub client
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the MQTT protocol with Mosquitto and Eclipse Paho
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing messages to a Mosquitto broker with a Python client
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing data to the cloud with dweepy
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 8](ch08.html "Chapter 8. Displaying Information and Performing
    Actions"), *Displaying Information and Performing Actions*, we worked with a digital
    temperature and humidity sensor combined with displays and a servo. Now, we want
    to take advantage of two cloud services to build a real time and interactive web-based
    dashboard that allows us to watch gauges with the following information in a web
    browser:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Ambient temperature measured in degrees Fahrenheit (ºF)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ambient temperature measured in degrees Celsius (ºC)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ambient humidity level expressed in percentage (%)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, we will take advantage of `dweet.io` to publish the data retrieved from
    the sensors and make it available to different computers and devices all over
    the world. The `dweet.io` data sharing utility allows us to easily publish data
    or messages and alerts from IoT devices and then use other devices to subscribe
    to this data. The `dweet.io` data sharing utility defines itself as something
    similar to Twitter for social machines. You can read more about `dweet.io` in
    its Webpage: [http://dweet.io](http://dweet.io).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our example, we will take advantage of the free services offered by `dweet.io`
    and we won't use some advanced features that provide privacy for our data but
    also require a paid subscription. Our data will be available to anyone that can
    access the `dweet.io` web page because we are not working with locked dweets.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The `dweet.io` data sharing utility provides a Web api that we can send data
    from our IoT device, known as *thing* in `dweet.io` documentation. First, we have
    to chose a unique name for our thing. It is convenient to combine a string with
    a **GUID** (short for **Global Unique Identifier**). Another option is to click
    on the **Try It Now** button on the main `dweet.io` web page and grab the name
    that the web page chooses for our thing. This way, we are sure that the name is
    unique and nobody else is using this name for another thing to publish data with
    `dweet.io`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have chosen a unique name for our thing, we can start publishing data,
    a process known as `dweeting`. We just need to compose a POST HTTP verb with the
    desired JSON data in the body and with the following request URL: `https://dweet.io/dweet/for/my-thing-name`.
    We must replace `my-thing-name` with the name we have chosen for our thing. In
    our examples, we will use `iot_python_chapter_09_01_gaston_hillar` to name our
    IoT device that will publish temperature and humidity values, that is, the thing
    that will dweet. Thus, we have to compose a POST HTTP verb with the desired JSON
    data in the body and with the following request URL: `https://dweet.io/dweet/for/iot_python_chapter_09_01_gaston_hillar`.
    Make sure you replace the name with the name you have chosen for your thing.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为我们的设备选择了一个独特的名称，我们就可以开始发布数据，这个过程被称为 `dweeting`。我们只需要在请求 URL `https://dweet.io/dweet/for/my-thing-name`
    中组合一个 POST HTTP 动词，并在正文中包含所需的 JSON 数据。我们必须将 `my-thing-name` 替换为我们为设备选择的名称。在我们的示例中，我们将使用
    `iot_python_chapter_09_01_gaston_hillar` 来命名我们的 IoT 设备，该设备将发布温度和湿度值，即将要 dweet
    的设备。因此，我们必须在请求 URL `https://dweet.io/dweet/for/iot_python_chapter_09_01_gaston_hillar`
    中组合一个 POST HTTP 动词，并在正文中包含所需的 JSON 数据。确保将名称替换为您为设备选择的名称。
- en: 'Dweepy is a simple Python client for `dweet.io` that allows us to easily publish
    data to `dweet.io` with Python. Instead of manually building and sending an HTTP
    request to a specific URL with Python, we can use the methods provided by this
    useful module. The following is the Web page for the Dweepy module: [https://pypi.python.org/pypi/dweepy/0.2.0](https://pypi.python.org/pypi/dweepy/0.2.0).
    Under the hoods, Dweepy uses the popular features provided by the popular `requests`
    module to build and send the HTTP requests.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Dweepy 是一个简单的 Python 客户端，用于 `dweet.io`，它允许我们使用 Python 容易地发布数据到 `dweet.io`。我们不需要手动使用
    Python 构建并发送一个特定的 URL 的 HTTP 请求，而是可以使用这个有用模块提供的方法。以下是为 Dweepy 模块提供的网页：[https://pypi.python.org/pypi/dweepy/0.2.0](https://pypi.python.org/pypi/dweepy/0.2.0)。在内部，Dweepy
    使用流行的 `requests` 模块提供的流行功能来构建和发送 HTTP 请求。
- en: Tip
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: One of the nice things of working with Python as our main programming language
    for IoT is that there is always a package that makes things easy for us in Python.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在物联网中作为我们的主要编程语言使用 Python 的一个好处是，总有软件包让事情变得简单。
- en: 'In [Chapter 2](ch02.html "Chapter 2. Working with Python on Intel Galileo Gen
    2"), *Working with Python on Intel Galileo Gen 2*, we installed `pip` installer
    to easily install additional Python 2.7.3 packages in the Yocto Linux that we
    are running on the board. Now, we will use `pip` installer to install Dweepy 0.2.0\.
    We just need to run the following command in the SSH terminal to install the package:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](ch02.html "第 2 章。在英特尔 Galileo Gen 2 上使用 Python")，*在英特尔 Galileo Gen
    2 上使用 Python* 中，我们安装了 `pip` 安装程序，以便在板上的 Yocto Linux 中轻松安装额外的 Python 2.7.3 软件包。现在，我们将使用
    `pip` 安装程序安装 Dweepy 0.2.0。我们只需要在 SSH 终端中运行以下命令来安装软件包：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The last lines for the output will indicate that the `dweepy` package has been
    successfully installed. Don''t worry about the error messages related to building
    wheel and the insecure platform warning:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示 `dweepy` 软件包已成功安装。不要担心与构建 wheel 相关的错误消息和不安全平台警告：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will take the code we wrote in the previous chapter when we read temperature
    and humidity values from the sensor and we will use this code as a baseline to
    add the new features. The code file for the sample was `iot_python_chapter_08_03.py`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从传感器读取温度和湿度值时，我们将使用上一章编写的代码，并将此代码作为添加新功能的基线。示例代码文件为 `iot_python_chapter_08_03.py`。
- en: We will use the recently installed `dweepy` module to publish data to `dweet.io`
    and make it available as a data source for another cloud service that will allow
    us to build a web-based dashboard. We will add the necessary lines to our loop
    and it will publish the measured values every 10 seconds. The code file for the
    sample is `iot_python_chapter_09_01.py`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用最近安装的 `dweepy` 模块将数据发布到 `dweet.io`，并使其作为另一个云服务的数据源，该云服务将允许我们构建基于 Web 的仪表板。我们将在循环中添加必要的行，并且它将每
    10 秒发布一次测量的值。示例代码文件为 `iot_python_chapter_09_01.py`。
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The highlighted lines show the changes made to the `__main__` method compared
    with the previous version. The first highlighted line creates a local variable
    named `thing_name` that saves a string with the name we have chosen for our thing
    to use with `dweet.io`. Remember that you have to replace the string with the
    name you have chosen for your thing before running the sample code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮行显示了与上一个版本相比对`__main__`方法所做的更改。第一条高亮行创建了一个名为`thing_name`的局部变量，该变量保存了一个字符串，其中包含我们为我们的设备选择的名字，以便与`dweet.io`一起使用。记住，在运行示例代码之前，你必须将字符串替换为你为设备选择的名字。
- en: 'Then, the code runs a loop forever and the first highlighted line creates a
    dictionary and saves it in the `dweet` local variable. The dictionary defines
    the key-value pairs that we want to send as JSON data to `dweet.io` for our thing.
    The following are the keys the code will send:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码将无限循环运行，第一条高亮行创建一个字典并将其保存在`dweet`局部变量中。该字典定义了我们想要作为JSON数据发送到`dweet.io`的键值对。以下是要发送的键：
- en: '`temperature_celsius`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`temperature_celsius`'
- en: '`temperature_fahrenheit`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`temperature_fahrenheit`'
- en: '`humidity_level_percentage`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`humidity_level_percentage`'
- en: 'The values for the previously enumerated keys are the values retrieved by the
    sensor converted to strings. Once the dictionary with the desired JSON data is
    built, the code calls the `dweepy.dweet_for` method with `thing_name` and `dweet`
    as arguments, that is, the thing name and the JSON data we want to publish for
    the specified thing name. Under the hoods, the `dweepy.dweet_for` method uses
    the `requests` module to compose a POST HTTP verb with the `dweet` dictionary
    as the desired JSON data in the body and with the following request URL: `https://dweet.io/dweet/for/`
    followed by the thing name specified in the `thing_name` local variable. This
    way, the code dweets the temperature and humidity values retrieved from the sensor
    in different units.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 之前列举的键的值是由传感器获取的值转换为字符串。一旦构建了包含所需JSON数据的字典，代码将调用`dweepy.dweet_for`方法，并将`thing_name`和`dweet`作为参数，即设备名称和我们要为指定设备名称发布的JSON数据。在幕后，`dweepy.dweet_for`方法使用`requests`模块来组合一个POST
    HTTP动词，将`dweet`字典作为正文中的所需JSON数据，并且以下请求URL：`https://dweet.io/dweet/for/`后跟在`thing_name`局部变量中指定的设备名称。这样，代码将传感器获取的温度和湿度值以不同的单位dweet。
- en: The following line will start the example.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将开始示例。
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After you run the example, turn on an air conditioner or a heating system, to
    generate a change in the ambient temperature and humidity. This way, we will notice
    changes in the data that is being published every 10 seconds.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行示例后，打开空调或加热系统，以产生环境温度和湿度的变化。这样，我们将注意到每10秒发布的数据中的变化。
- en: 'Wait around 20 seconds and open the following URL in any Web browser: `http://dweet.io/follow/iot_python_chapter_09_01_gaston_hillar`.
    Don''t forget to replace `iot_python_chapter_09_01_gaston_hillar` with the name
    you have chosen for your thing. In this case, we can enter the URL in any device
    connected to the Internet. We don''t need the device to be in the same LAN than
    the board because the values are published with `dweet.io` and they are available
    everywhere.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 等待大约20秒，然后在任何网络浏览器中打开以下URL：`http://dweet.io/follow/iot_python_chapter_09_01_gaston_hillar`。别忘了将`iot_python_chapter_09_01_gaston_hillar`替换为你为你的设备选择的名字。在这种情况下，我们可以在任何连接到互联网的设备上输入此URL。我们不需要设备与板子处于同一局域网中，因为值是通过`dweet.io`发布的，并且可以在任何地方访问。
- en: 'The **Visual** view will display a line graph with the humidity level and the
    temperature values as they were changing over time. The right-hand side will display
    the latest value that was published. The view will be refreshed automatically
    when the Python code dweets new values. The following picture shows a screenshot
    with the **Visual** view:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**视觉**视图将显示一条线形图，显示湿度水平和温度值随时间的变化。右侧将显示最新发布的值。当Python代码dweets新值时，视图将自动刷新。以下图片显示了带有**视觉**视图的屏幕截图：'
- en: '![Publishing data to the cloud with dweepy](img/B05042_09_01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![使用dweepy将数据发布到云中](img/B05042_09_01.jpg)'
- en: 'Click on the **Raw** view and the page will display the latest JSON data that
    the Python code running on the board has published and received by `dweet.io`
    for our thing. The following lines show an example of the latest JSON data that
    was received and that was shown in the previous picture:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**原始**视图，页面将显示板子上运行的Python代码通过`dweet.io`为我们的设备发布的最新JSON数据。以下行显示了之前图片中显示的接收到的最新JSON数据示例：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In [Chapter 4](ch04.html "Chapter 4. Working with a RESTful API and Pulse Width
    Modulation"), *Working with a RESTful API and Pulse Width Modulation*, we installed
    HTTPie, a command-line HTTP client written in Python that makes is easy to send
    HTTP requests and uses a syntax that is easier than curl (also known as cURL).
    We can run the following HTTPie command in any computer or device to retrieve
    the latest dweet made for our thing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 4 章](ch04.html "第 4 章。使用 RESTful API 和脉冲宽度调制") 中，*使用 RESTful API 和脉冲宽度调制*，我们安装了
    HTTPie，这是一个用 Python 编写的命令行 HTTP 客户端，它使得发送 HTTP 请求变得容易，并且使用的语法比 curl（也称为 cURL）更容易。我们可以在任何计算机或设备上运行以下
    HTTPie 命令来检索为我们的事物创建的最新 dweet。
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The previous command will compose and send the following HTTP request: `GET
    https://dweet.io:443/get/latest/dweet/for/iot_python_chapter_09_01_gaston_hillar`.
    The `dweet.io` API will return the latest dweet for the specified thing. The following
    lines show a sample response from `dweet.io`. The JSON data is included in the
    value for the `content` key.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组成并发送以下 HTTP 请求：`GET https://dweet.io:443/get/latest/dweet/for/iot_python_chapter_09_01_gaston_hillar`。`dweet.io`
    API 将返回指定事物的最新 dweet。以下几行显示了 `dweet.io` 的一个示例响应。JSON 数据包含在 `content` 键的值中。
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can run the following HTTPie command in any computer or device to retrieve
    all of the saved dweets for our thing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何计算机或设备上运行以下 HTTPie 命令来检索我们事物的所有已保存 dweets。
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The previous command will compose and send the following HTTP request: `GET
    https://dweet.io:443/get/ dweets/for/iot_python_chapter_09_01_gaston_hillar`.
    The `dweet.io` API will return the saved dweets from its long term storage for
    the specified thing. The following lines show a sample response from `dweet.io`.
    Notice that there are limitations in the number of dweets stored in the long term
    storage and in the returned values.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组成并发送以下 HTTP 请求：`GET https://dweet.io:443/get/dweets/for/iot_python_chapter_09_01_gaston_hillar`。`dweet.io`
    API 将返回指定事物的长期存储中保存的 dweets。以下几行显示了 `dweet.io` 的一个示例响应。请注意，长期存储中存储的 dweets 数量和返回的值都有限制。
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Building a web-based dashboard with Freeboard
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Freeboard 构建 Web 仪表板
- en: 'The `dweet.io` data sharing utility allowed us to easily publish data to the
    cloud with just a few lines of code. Now, we are ready to use `dweet.io` and our
    thing name as a data source to build a real-time web-based dashboard. We will
    take advantage of freeboard.io to visualize the data collected with the sensor
    and published to `dweet.io` in many gauges and make the dashboard available to
    different computers and devices all over the world. Freeboard.io allows us to
    build a dashboard by selecting data sources and dragging and dropping customizable
    widgets. Freeboard.io defines itself as a cloud-based service that allows us to
    visualize the Internet of Things. You can read more about freeboard.io in its
    Webpage: [http://freeboard.io](http://freeboard.io).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`dweet.io` 数据共享工具使我们能够仅用几行代码轻松地将数据发布到云端。现在，我们准备使用 `dweet.io` 和我们的设备名称作为数据源来构建一个实时基于网页的仪表板。我们将利用
    freeboard.io 来可视化通过传感器收集并发布到 `dweet.io` 的数据，并在许多仪表中展示仪表板，使其可供世界各地的不同计算机和设备使用。Freeboard.io
    将自己定义为一种基于云的服务，允许我们可视化物联网。您可以在其网页上了解更多关于 freeboard.io 的信息：[http://freeboard.io](http://freeboard.io)。'
- en: Tip
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In our example, we will take advantage of the free services offered by freeboard.io
    and we won't use some advanced features that provide privacy for our dashboards
    but also require a paid subscription. Our dashboard will be available to anyone
    that has the unique URL for it because we are not working with private dashboards.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将利用 freeboard.io 提供的免费服务，而不会使用一些提供隐私但需要付费订阅的高级功能。由于我们不处理私有仪表板，因此任何拥有其唯一
    URL 的人都可以访问我们的仪表板。
- en: Freeboard requires us to sign up and create an account with a valid e-mail and
    a password before we can build a web-based dashboard. We aren't required to enter
    any credit card or payment information. If you already have an account at freeboard.io,
    you can skip the next step.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Freeboard 要求我们在构建基于网页的仪表板之前注册并使用有效的电子邮件地址和密码创建一个账户。我们不需要输入任何信用卡或支付信息。如果您已经在
    freeboard.io 上有账户，您可以跳过下一步。
- en: Go to [http://freeboard.io](http://freeboard.io) in your Web browser and click
    **Start Now**. You can achieve the same goal by visiting [https://freeboard.io/signup](https://freeboard.io/signup).
    Enter your desired user name in **Pick a Username**, your e-mail in **Enter Your
    Email** and the desired password in **Create a Password**. Once you have filled
    up all the fields, click **Create My Account**.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中访问[http://freeboard.io](http://freeboard.io)并点击**立即开始**。您也可以通过访问[https://freeboard.io/signup](https://freeboard.io/signup)达到相同的目的。在**选择用户名**中输入您想要的用户名，在**输入您的电子邮件**中输入您的电子邮件，在**创建密码**中输入您想要的密码。一旦填写完所有字段，点击**创建我的账户**。
- en: Once you created your account, you can go to [http://freeboard.io](http://freeboard.io)
    in your Web browser and click **Login**. You can achieve the same goal by visiting
    [https://freeboard.io/login](https://freeboard.io/login). Then, enter your user
    name or e-mail and password, and click **Sign In**. Freeboard will display your
    freeboards, also known as dashboards.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 创建账户后，您可以在网络浏览器中访问[http://freeboard.io](http://freeboard.io)并点击**登录**。您也可以通过访问[https://freeboard.io/login](https://freeboard.io/login)达到相同的目的。然后，输入您的用户名或电子邮件和密码，并点击**登录**。Freeboard将显示您的免费板，也称为仪表板。
- en: Enter `Ambient temperature and humidity` in the **enter a name** textbox at
    the left hand side of the **Create New** button and then click on this button.
    Freeboard.io will display an empty dashboard with many buttons that allow us to
    add panes and data sources, among other things. The following picture shows a
    screenshot with the empty dashboard.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在**创建新**按钮左侧的**输入名称**文本框中输入`环境温度和湿度`，然后点击此按钮。Freeboard.io将显示一个空白的仪表板，其中包含许多按钮，允许我们添加面板和数据源等。以下图片显示了空白的仪表板截图。
- en: '![Building a web-based dashboard with Freeboard](img/B05042_09_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![使用Freeboard构建基于Web的仪表板](img/B05042_09_02.jpg)'
- en: Click on **Add** below **Datasources** and the Website will open the **Datasource**
    dialog box. Select **Dweet.io** in the **Type** dropdown and the dialog box will
    display the fields required to define a `dweet.io` datasource.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**数据源**下方的**添加**，网站将打开**数据源**对话框。在**类型**下拉菜单中选择**Dweet.io**，对话框将显示定义`dweet.io`数据源所需的字段。
- en: Enter `Ambient temperature and humidity` in **Name** and the thing name we have
    been using for `dweet.io` in **Thing Name**. Remember that we were using `iot_python_chapter_09_01_gaston_hillar`
    to name our IoT device but you had replaced it with a different name. If the name
    you enter doesn't match the name you used when working with `dweet.io`, the datasource
    won't have the appropriate data. The following picture shows a screenshot with
    the configuration for the `dweet.io` datasource that uses the sample thing name.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在**名称**中输入`环境温度和湿度`，在**设备名称**中输入我们之前用于`dweet.io`的设备名称。请记住，我们曾使用`iot_python_chapter_09_01_gaston_hillar`来命名我们的物联网设备，但您已将其替换为不同的名称。如果您输入的名称与您在处理`dweet.io`时使用的名称不匹配，数据源将不会显示适当的数据。以下图片显示了使用示例设备名称的`dweet.io`数据源配置的截图。
- en: '![Building a web-based dashboard with Freeboard](img/B05042_09_03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![使用Freeboard构建基于Web的仪表板](img/B05042_09_03.jpg)'
- en: Click **Save** and the datasource will appear listed below **Datasources**.
    As the board is running the Python code that is dweeting, the time shown below
    **Last Updated** will change every 10 seconds. If the time doesn't change every
    10 seconds, it means that the datasource has a wrong configuration or that the
    board is not running the Python code that is dweeting anymore.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**保存**，数据源将出现在**数据源**下方的列表中。由于仪表板正在运行dweeting的Python代码，因此**最后更新**下显示的时间将每10秒更改一次。如果时间每10秒不更改，则意味着数据源配置错误或仪表板不再运行dweeting的Python代码。
- en: Click on **Add pane** to add a new empty pane to the dashboard. Then, click
    on the plus sign (**+**) at the upper right corner of the new empty pane and Freeboard
    will display the **Widget** dialog box.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**添加面板**以向仪表板添加一个新的空白面板。然后，点击新空白面板右上角的加号（**+**），Freeboard将显示**小部件**对话框。
- en: Select **Gauge** in the **Type** dropdown and the dialog box will display the
    fields required to add a gauge widget to the pane within the dashboard. Enter
    `Temperature in degrees Fahrenheit` in **Title**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在**类型**下拉菜单中选择**量规**，对话框将显示添加量规小部件到仪表板面板中所需的字段。在**标题**中输入`华氏温度`。
- en: 'Click **+ Datasource** at the right-hand side of the **Value** textbox, select
    **Ambient Temperature and humidity** and then select **temperature_fahrenheit**.
    After you make the selections the following text will appear in the **Value**
    textbox: `datasources ["Ambient temperature and humidity"] ["temperature_fahrenheit"]`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在**值**文本框的右侧点击**+ 数据源**，选择**环境温度和湿度**，然后选择**temperature_fahrenheit**。在您做出选择后，以下文本将出现在**值**文本框中：`datasources
    ["Ambient temperature and humidity"] ["temperature_fahrenheit"]`。
- en: Enter `ºF` in **Units**, `-30` in **Minimum** and `130` in **Maximum**. Then,
    click **Save** and Freeboard will close the dialog box and add the new gauge to
    the previously created pane within the dashboard. The gauge will display the latest
    value that the code running in the board dweeted for the ambient temperature in
    degrees Fahrenheit, that is, the value for the `temperature_fahrenheit` key in
    the JSON data that the code has published for the last time to `dweet.io`. The
    following picture shows the **Ambient temperature and humidity** datasource displaying
    the last updated time and the gauge showing the latest value for the ambient temperature
    measured in degrees Fahrenheit.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在**单位**中输入`ºF`，在**最小值**中输入`-30`，在**最大值**中输入`130`。然后，点击**保存**，Freeboard将关闭对话框并将新的仪表添加到之前创建的仪表板窗格中。仪表将显示代码在板上最后一次dweet的环境温度的最新值，即代码最后发布到`dweet.io`的JSON数据中`temperature_fahrenheit`键的值。以下图片显示了**环境温度和湿度**数据源显示的最后更新时间和显示华氏度测量的环境温度的最新值的仪表。
- en: '![Building a web-based dashboard with Freeboard](img/B05042_09_04.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![使用Freeboard构建基于Web的仪表板](img/B05042_09_04.jpg)'
- en: Click on **Add pane** to add another new empty pane to the dashboard. Then,
    click on the plus sign (**+**) at the upper right corner of the new empty pane
    and Freeboard will display the **Widget** dialog box.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**添加窗格**以向仪表板添加另一个新的空窗格。然后，点击新空窗格右上角的加号（**+**），Freeboard将显示**小部件**对话框。
- en: Select **Gauge** in the **Type** dropdown and the dialog box will display the
    fields required to add a gauge widget to the pane within the dashboard. Enter
    `Humidity level in percentage` in **Title**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在**类型**下拉菜单中选择**仪表**，对话框将显示添加仪表小部件到仪表板窗格所需的字段。在**标题**中输入`Humidity level in percentage`。
- en: 'Click **+ Datasource** at the right-hand side of the **Value** textbox, select
    **Ambient Temperature and humidity** and then select **humidity_level_percentage**.
    After you make the selections the following text will appear in the **Value**
    textbox: `datasources ["Ambient temperature and humidity"] ["humidity_level_percentage"]`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在**值**文本框的右侧点击**+ 数据源**，选择**环境温度和湿度**，然后选择**humidity_level_percentage**。在您做出选择后，以下文本将出现在**值**文本框中：`datasources
    ["Ambient temperature and humidity"] ["humidity_level_percentage"]`。
- en: Enter `%` in **Units**, `0` in **Minimum** and `100` in **Maximum**. Then, click
    **Save** and Freeboard will close the dialog box and add the new gauge to the
    previously created pane within the dashboard. The gauge will display the latest
    value that the code running in the board dweeted for the ambient humidity level
    in percentage, that is, the value for the `humidity_level_percentage` key in the
    JSON data that the code has published for the last time to `dweet.io`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在**单位**中输入`%`，在**最小值**中输入`0`，在**最大值**中输入`100`。然后，点击**保存**，Freeboard将关闭对话框并将新的仪表添加到之前创建的仪表板窗格中。仪表将显示代码在板上最后一次dweet的周围湿度水平的最新值，即代码最后发布到`dweet.io`的JSON数据中`humidity_level_percentage`键的值。以下图片显示了**环境温度和湿度**数据源显示的最后更新时间和显示华氏度测量的环境温度的最新值的仪表。
- en: Now, click on the plus sign (**+**) at the upper right corner of the pane that
    is displaying the temperature in degrees Fahrenheit and Freeboard will display
    the **Widget** dialog box.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击显示华氏度和Freeboard的窗格右上角的加号（**+**），Freeboard将显示**小部件**对话框。
- en: Select **Gauge** in the **Type** dropdown and the dialog box will display the
    fields required to add a gauge widget to the pane within the dashboard. Enter
    `Temperature in degrees Celsius` in **Title**.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在**类型**下拉菜单中选择**仪表**，对话框将显示添加仪表小部件到仪表板窗格所需的字段。在**标题**中输入`Temperature in degrees
    Celsius`。
- en: 'Click **+ Datasource** at the right-hand side of the **Value** textbox, select
    **Ambient Temperature and humidity** and then select **temperature_celsius**.
    After you make the selections the following text will appear in the **Value**
    textbox: `datasources ["Ambient temperature and humidity"] ["temperature_celsius"]`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**值**文本框右侧的**+ Datasource**，选择**环境温度和湿度**，然后选择**temperature_celsius**。在做出选择后，以下文本将出现在**值**文本框中：`datasources
    ["Ambient temperature and humidity"] ["temperature_celsius"]`。
- en: Enter `ºC` in **Units**, `-40` in **Minimum** and `55` in **Maximum**. Then,
    click **Save** and Freeboard will close the dialog box and add the new gauge to
    the previously existing pane within the dashboard. This way, the pane will display
    two gauges, with the temperature expressed in two different units. The new gauge
    will display the latest value that the code running in the board dweeted for the
    ambient temperature in degrees Celsius, that is, the value for the `temperature_celsius`
    key in the JSON data that the code has published for the last time to `dweet.io`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在**单位**中输入`ºC`，在**最小值**中输入`-40`，在**最大值**中输入`55`。然后，点击**保存**，Freeboard 将关闭对话框并将新的仪表添加到仪表板中之前存在的窗格内。这样，窗格将显示两个仪表，温度以两种不同的单位表示。新的仪表将显示代码在板上
    dweeted 的最新值，即环境温度的值，即代码在最后一次发布到 `dweet.io` 的 JSON 数据中的 `temperature_celsius`
    键的值。
- en: Now, click on the configuration icon at the right-hand side of the **+** button
    of the pane that displays both temperatures. Freeboard will display the **Pane**
    dialog box. Enter `Temperature` in **Title** and click **Save**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击显示两个温度的窗格右侧的**+**按钮旁边的配置图标。Freeboard 将显示**窗格**对话框。在**标题**中输入`Temperature`，然后点击**保存**。
- en: Click on the configuration icon at the right-hand side of the **+** button of
    the pane that displays the humidity level. Freeboard will display the **Pane**
    dialog box. Enter `Humidity` in **Title** and click **Save**.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 点击显示湿度水平的窗格右侧的**+**按钮旁边的配置图标。Freeboard 将显示**窗格**对话框。在**标题**中输入`Humidity`，然后点击**保存**。
- en: Drag and drop the panes to locate the **Humidity** pane at the left-hand side
    of the **Temperature** pane. The following picture shows the dashboard we built,
    with two panes and three gauges that refresh the data automatically when the code
    running on the Intel Galileo Gen 2 board dweets new data.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将窗格拖放到位置，将**湿度**窗格放置在**温度**窗格的左侧。以下图片显示了我们所构建的仪表板，其中包含两个窗格和三个仪表，当在英特尔 Galileo
    Gen 2 板上运行的代码 dweets 新数据时，这些仪表会自动刷新数据。
- en: '![Building a web-based dashboard with Freeboard](img/B05042_09_05.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Freeboard 构建基于网页的仪表板](img/B05042_09_05.jpg)'
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We can access the recently built dashboard in any device by entering the URL
    that our Web browser is displaying at the time we are working with the dashboard.
    The URL is composed of the `https://freeboard.io/board/` prefix followed by letters
    and numbers. For example, in case the URL is `https://freeboard.io/board/EXAMPLE`,
    we just need to enter it in any Web browser running on any device or computer
    connected to the Internet and we can watch the gauges and they will be refreshed
    as new data is being publishes from our Intel Galileo Gen 2 board to `dweet.io`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过输入我们在与仪表板一起工作时网页浏览器显示的 URL 来在任何设备上访问最近构建的仪表板。URL 由 `https://freeboard.io/board/`
    前缀后跟字母和数字组成。例如，如果 URL 是 `https://freeboard.io/board/EXAMPLE`，我们只需将其输入到任何设备或计算机上运行的任何网页浏览器中，我们就可以查看仪表，并且当从我们的英特尔
    Galileo Gen 2 板向 `dweet.io` 发布新数据时，它们会刷新。
- en: The combination of `dweet.io` as our datasource and freeboard.io as our web-based
    dashboard made it easy for us to monitor the data retrieved from the sensor wired
    to our Intel Galileo Gen 2 board with any device that provides a Web browser.
    The combination of these two cloud-based services for IoT is just one example
    of how we can easily combine different services. There is an increase in the number
    of IoT cloud-based services, which can be used in our solutions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `dweet.io` 作为我们的数据源和 freeboard.io 作为我们的基于网页的仪表板结合起来，使我们能够轻松地使用任何提供网页浏览器的设备来监控连接到我们的英特尔
    Galileo Gen 2 板的传感器获取的数据。这两个基于云的物联网服务的结合只是我们如何轻松结合不同服务的一个例子。物联网云服务的数量正在增加，这些服务可以用于我们的解决方案中。
- en: Sending and receiving data in real-time through Internet with PubNub
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 PubNub 在互联网上实时发送和接收数据
- en: In [Chapter 4](ch04.html "Chapter 4. Working with a RESTful API and Pulse Width
    Modulation"), *Working with a RESTful API and Pulse Width Modulation*, we developed
    and consumed a RETful API that allows us to control electronic components connected
    to our Intel Galileo Gen 2 board through HTTP requests. Now, we want to send and
    receive data in real-time through the Internet and a RESTful API is not the most
    appropriate option to do this. Instead, we will work with a publish/subscribe
    model based on a protocol that is lighter than the HTTP protocol. Specifically,
    we will use a service based on the **MQTT** (short for **MQ Telemetry Transport**)
    protocol.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。使用RESTful API和脉冲宽度调制")中，*使用RESTful API和脉冲宽度调制*，我们开发和使用了RETful
    API，它允许我们通过HTTP请求控制连接到我们的Intel Galileo Gen 2板上的电子组件。现在，我们希望通过互联网实时发送和接收数据，而RESTful
    API并不是做这件事的最合适选项。相反，我们将使用基于比HTTP协议更轻量级的协议的发布/订阅模型。具体来说，我们将使用基于**MQTT**（即**MQ Telemetry
    Transport**）协议的服务。
- en: 'The MQTT protocol is a **machine-to-machine** (short for **M2M**) and Internet
    of Things connectivity protocol. MQTT is a lightweight messaging protocol that
    runs on top of the TCP/IP protocol and works with a publish-subscribe mechanism.
    It is possible for any device to subscribe to a specific channel (also known as
    topic) and it will receive all the messages published to this channel. In addition,
    the device can publish message to this or other channel. The protocol is becoming
    very popular in IoT and M2M projects. You can read more about the MQTT protocol
    in the following Webpage: [http://mqtt.org](http://mqtt.org).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT协议是一种**机器到机器**（简称**M2M**）和物联网连接协议。MQTT是一个轻量级消息协议，它运行在TCP/IP协议之上，并使用发布/订阅机制。任何设备都可以订阅特定的频道（也称为主题），并会接收到发布到该频道的所有消息。此外，设备可以向该频道或其他频道发布消息。该协议在物联网和M2M项目中变得越来越受欢迎。你可以在以下网页上了解更多关于MQTT协议的信息：[http://mqtt.org](http://mqtt.org)。
- en: 'PubNub provides many cloud-based services and one of them allows us to easily
    stream data and signal any device in real-time, working with the MQTT protocol
    under the hoods. We will take advantage of this PubNub service to send and receive
    data in real-time through Internet and make it easy to control our Intel Galileo
    Gen 2 board through the Internet. As PubNub provides a Python API with high quality
    documentation and examples, it is extremely easy to use the service in Python.
    PubNub defines itself as the global data stream network for IoT, Mobile and Web
    applications. You can read more about PubNub in its Webpage: [http://www.pubnub.com](http://www.pubnub.com).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: PubNub提供了许多基于云的服务，其中之一允许我们轻松地实时流数据和向任何设备发送信号，在底层使用MQTT协议。我们将利用这个PubNub服务通过互联网实时发送和接收数据，并使通过互联网控制我们的Intel
    Galileo Gen 2板变得容易。由于PubNub提供了一个具有高质量文档和示例的Python API，因此使用Python来使用该服务非常简单。PubNub将自己定义为物联网、移动和Web应用的全球数据流网络。你可以在其网页上了解更多关于PubNub的信息：[http://www.pubnub.com](http://www.pubnub.com)。
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In our example, we will take advantage of the free services offered by PubNub
    and we won't use some advanced features and additional services that might empower
    our IoT project connectivity requirements but also require a paid subscription.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将利用PubNub提供的免费服务，而不会使用一些可能增强我们的物联网项目连接需求但需要付费订阅的高级功能和附加服务。
- en: PubNub requires us to sign up and create an account with a valid e-mail and
    a password before we can create an application within PubNub that allows us to
    start using their free services. We aren't required to enter any credit card or
    payment information. If you already have an account at PubNub, you can skip the
    next step.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: PubNub要求我们在创建应用程序之前先注册并使用有效的电子邮件和密码创建一个账户，该应用程序允许我们开始使用他们的免费服务。我们不需要输入任何信用卡或支付信息。如果你已经在PubNub有账户，你可以跳过下一步。
- en: 'Once you created your account PubNub will redirect you to the **Admin Portal**
    that lists your PubNub applications. It is necessary to generate your PubNub publish
    and subscribe keys in order to send and receive messages in the network. A new
    pane will represent the application in the Admin portal. The following screenshot
    shows the Temperature Control application pane in the PubNub Admin portal:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了账户，PubNub将把你重定向到**管理门户**，该门户列出了你的PubNub应用程序。为了在网络上发送和接收消息，你需要生成你的PubNub发布和订阅密钥。管理门户中的一个新面板将代表应用程序。以下截图显示了PubNub管理门户中的温度控制应用程序面板：
- en: '![Sending and receiving data in real-time through Internet with PubNub](img/B05042_09_06.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: 'Click on the **Temperature Control** pane and PubNub will display the **Demo
    Keyset** pane that has been automatically generated for the application. Click
    on this pane and PubNub will display the publish, subscribe, and secret keys.
    We must copy and paste each of these keys to use them in our code that will publish
    messages and subscribe to them. The following screenshot shows the prefixes for
    the keys and the remaining characters have been erased in the image:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending and receiving data in real-time through Internet with PubNub](img/B05042_09_07.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: In order to copy the secret key, you must click on the eye icon at the right-hand
    side of the key and PubNub will make all the characters visible.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. Working with Python on Intel Galileo Gen
    2"), *Working with Python on Intel Galileo Gen 2*, we installed `pip` installer
    to easily install additional Python 2.7.3 packages in the Yocto Linux that we
    are running on the board. Now, we will use `pip` installer to install PubNub Python
    SDK 3.7.6\. We just need to run the following command in the SSH terminal to install
    the package. Notice that it can take a few minutes to complete the installation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The last lines for the output will indicate that the `pubnub` package has been
    successfully installed. Don't worry about the error messages related to building
    wheel and the insecure platform warning.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will take the code we wrote in the previous chapter when we read temperature
    and humidity values from the sensor, we printed the values in an OLED matrix and
    rotated a servo''s shaft to display the measured temperature expressed in degrees
    Fahrenheit with the shaft. The code file for the sample was `iot_python_chapter_08_03.py`.
    We will use this code as a baseline to add new features that will allow us to
    perform the following actions with PubNub messages sent to a specific channel
    from any device that has a Web browser:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Rotate the servo's shaft to display a temperature value in degrees Fahrenheit
    received as part of the message.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display a line of text received as part of the message at the bottom of the
    OLED matrix.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use the recently installed `pubnub` module to subscribe to a specific
    channel and run code when we receive messages in the channel. We will create a
    `MessageChannel` class to represent the communications channel, configure the
    PubNub subscription and declare the code for the callbacks that are going to be
    executed when certain events are fired. The code file for the sample is `iot_python_chapter_09_02.py`.
    Remember that we use the code file `iot_python_chapter_08_03.py` as a baseline,
    and therefore, we will add the class to the existing code in this file and we
    will create a new Python file. Don't forget to replace the strings assigned to
    the `publish_key` and `subscribe_key` local variables in the `__init__` method
    with the values you have retrieved from the previously explained PubNub key generation
    process.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `MessageChannel` class declares the `command_key` class attribute that defines
    the key string that defines what the code will understand as the command. Whenever
    we receive a message that includes the specified key string, we know that the
    value associated to this key in the dictionary will indicate the command that
    the message wants the code running in the board to be processed. Each command
    requires additional key-value pairs that provide the necessary information to
    execute the command.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: We have to specify the PubNub channel name, the `TemperatureServo` instance
    the `Oled` instance in the `channel`, `temperature_servo`, and `oled` required
    arguments. The constructor, that is, the `__init__` method, saves the received
    arguments in three attributes with the same names. The `channel` argument specifies
    the PubNub channel to which we are going to subscribe to listen to the messages
    that other devices send to this channel. We will also publish messages to this
    channel, and therefore, we will be both a subscriber and a publisher for this
    channel.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case, we will only subscribe to one channel. However, it is very important
    to know that we are not limited to subscribe to a single channel, we might subscribe
    to many channels.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the constructor declares two local variables: `publish_key` and `subscribe_key`.
    These local variables save the publish and subscribe keys that we had generated
    with the PubNub Admin portal. Then, the code creates a new `Pubnub` instance with
    `publish_key` and `subscribe_key` as the arguments, and saves the reference for
    the new instance in the `pubnub` attribute. Finally, the code calls the `subscribe`
    method for the new instance to subscribe to data on the channel saved in the `channel`
    attribute. Under the hoods, the `subscribe` method makes the client create an
    open TCP socket to the PubNub network that includes an MQTT broker and starts
    listening to messages on the specified channel. The call to this method specifies
    many methods declared in the `MessageChannel` class for the following named arguments:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '`callback`: Specifies the function that will be called when there is a new
    message received from the channel'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`: Specifies the function that will be called on an error event'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`connect`: Specifies the function that will be called when a successful connection
    is established with the PubNub cloud'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reconnect`: Specifies the function that will be called when a successful re-connection
    is completed with the PubNub cloud'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disconnect`: Specifies the function that will be called when the client disconnects
    from the PubNub cloud'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This way, whenever one of the previously enumerated events occur, the specified
    method will be executed. The `callback` method receives two arguments: `message`
    and `channel`. First, the method checks whether the received `channel` matches
    the value in the `channel` attribute. In this case, whenever the `callback` method
    is executed, the value in the `channel` argument will always match the value in
    the `channel` attribute because we just subscribed to one channel. However, in
    case we subscribe to more than one channel, is is always necessary to check which
    is the channel in which the message was sent and in which we are receiving the
    message.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the code checks whether the `command_key` class attribute is included
    in the `message` dictionary. If the expression evaluates to `True`, it means that
    the message includes a command that we have to process. However, before we can
    process the command, we have to check which is the command, and therefore, it
    is necessary to retrieve the value associated with the key equivalent to the `command_key`
    class attribute. The code is capable of running code when the value is any of
    the following two commands:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '`print_temperature_fahrenheit`: The command must specify the temperature value
    expressed in degrees Fahrenheit in the value of the `temperature_fahrenheit` key.
    The code calls the `self.temperature_servo.print_temperature` method with the
    temperature value retrieved from the dictionary as an argument. This way, the
    code moves the servo''s shaft based on the specified temperature value in the
    message that includes the command.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print_information_message`: The command must specify the line of text that
    has to be displayed at the bottom of the OLED matrix in the value of the `print_information_message`
    key. The code calls the `self.oled.print_line` method with `11` and the text value
    retrieved from the dictionary as arguments. This way, the code displays the text
    received in the message that includes the command at the bottom of the OLED matrix.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No matter whether the message included a valid command or not, the method prints
    the raw message that it received in the console output.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'The `connect` method prints a message indicating that a connection has been
    established with the channel. Then, the method prints the results of calling the
    `self.pubnub.publish` method that publishes a message in the channel name saved
    in `self.channel` with the following message: `"Listening to messages in the Intel
    Galileo Gen 2 board"`. In this case, the call to this method runs with a synchronous
    execution. We will work with asynchronous execution for this method in our next
    example.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: At this time, we are already subscribed to this channel, and therefore, we will
    receive the previously published message and the callback method will be executed
    with this message as an argument. However, as the message doesn't include the
    key that identifies a command, the code in the callback method will just display
    the received message and it won't process any of the previously analyzed commands.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The other methods declared in the `MessageChannel` class just display information
    to the console output about the event that has occurred.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will use the previously coded `MessageChannel` class to create a new
    version of the `__main__` method that uses the PubNub cloud to receive and process
    commands. The new version doesn't rotate the servo's shaft when the ambient temperature
    changes, instead, it will do this when it receives the appropriate command from
    any device connected to PubNub cloud. The following lines show the new version
    of the `__main__` method. The code file for the sample is `iot_python_chapter_09_02.py`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The highlighted line creates an instance of the previously coded `MessageChannel`
    class with `"temperature"`, `temperature_servo`, and `oled` as the arguments.
    The constructor will subscribe to the `temperature` channel in the PubNub cloud,
    and therefore, we must send the messages to this channel in order to send the
    commands that the code will process with an asynchronous execution. The loop will
    read the values from the sensor and print the values to the console as in the
    previous version of the code, and therefore, we will have code running in the
    loop and we will also have code listening to the messages in the `temperature`
    channel in the PubNub cloud. We will start the example later because we want to
    subscribe to the channel in the PubNub debug console before we run the code in
    the board.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Publishing messages with commands through the PubNub cloud
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will take advantage of the PubNub console to send messages with commands
    to the `temperature` channel and make the Python code running on the board process
    these commands. In case you have logged out of PubNub, login again and click on
    the **Temperature Control** pane in the **Admin Portal**. PubNub will display
    the **Demo Keyset** pane.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Demo Keyset** pane and PubNub will display the publish, subscribe,
    and secret keys. This way, we select the keyset that we want to use for our PubNub
    application.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Debug Console** on the sidebar located the left-hand side of the
    screen. PubNub will create a client for a default channel and subscribe to this
    channel using the secret keys we have selected in the previous step. We want to
    subscribe to the `temperature` channel, and therefore, enter `temperature` in
    the **Default Channel** textbox within a pane that includes the **Add client**
    button at the bottom. Then, click on **Add client** and PubNub will add a new
    pane with a random client name as a title and the channel name, `temperature`,
    in the second line. PubNub makes the client subscribe to this channel and we will
    be able to receive messages published to this channel and send messages to this
    channel. The following picture shows the pane for the generated client named **Client-ot7pi**,
    subscribed to the `temperature` channel. Notice that the client name will be different
    when you follow the explained steps.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![Publishing messages with commands through the PubNub cloud](img/B05042_09_08.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: The client pane displays the output generated when PubNub subscribed the client
    to the channel. PubNub returns a formatted response for each command. In this
    case, it indicates that the status is equal to `Subscribed` and the channel name
    is `temperature`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, it is time to start running the example in the Intel Galileo Gen 2 board.
    The following line will start the example in the SSH console:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After you run the example, go to the Web browser in which you are working with
    the PubNub debug console. You will see the following message listed in the previously
    created client:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The Python code running in the board published this message, specifically, the
    `connect` method in the `MessageChannel` class sent this message after the application
    established a connection with the PubNub cloud. The following picture shows the
    message listed in the previously created client. Notice that the icon at the left-hand
    side of the text indicates it is a message. The other message was a debug message
    with the results of subscribing to the channel.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![Publishing messages with commands through the PubNub cloud](img/B05042_09_09.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: 'At the bottom of the client pane, you will see the following text and the **Send**
    button at the right-hand side:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we will replace the previously shown text with a message. Enter the following
    JSON code and click **Send**:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The text editor where you enter the message has some issues in certain browsers.
    Thus, it is convenient to use your favorite text editor to enter the JSON code,
    copy it and then past it to replace the text that is included by default in the
    text for the message to be sent.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: After you click **Send**, the following lines will appear in the client log.
    The first line is a debug message with the results of publishing the message and
    indicates that the message has been sent. The formatted response includes a number
    (`1` message), the status (`Sent`) and a time token. The second line is the message
    that arrives to the channel because we are subscribed to the `temperature` channel,
    that is, we also receive the message we sent.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following picture shows the messages and debug messages log for the PubNub
    client after we clicked the **Send** button:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![Publishing messages with commands through the PubNub cloud](img/B05042_09_10.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: After you publish the previous message, you will see the following output in
    the SSH console for the Intel Galileo Gen 2 board. You will notice the servo's
    shaft rotates to 50 degrees.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, enter the following JSON code and click **Send**:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After you click **Send**, the following lines will appear in the client log.
    The first line is a debug message with the previously explained formatted response
    with the results of publishing the message and indicates that the message has
    been sent. The second line is the message that arrives to the channel because
    we are subscribed to the `temperature` channel, that is, we also receive the message
    we sent.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The following picture shows the messages and debug messages log for the PubNub
    client after we clicked the **Send** button.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![Publishing messages with commands through the PubNub cloud](img/B05042_09_11.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: 'After you publish the previous message, you will see the following output in
    the SSH console for the Intel Galileo Gen 2 board. You will see the following
    text displayed at the bottom of the OLED matrix: `Client ready`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When we published the two messages with the commands, we have definitely noticed
    a problem. We don't know whether the command was processed or not in the code
    that is running on the IoT device, that is, in the Intel Galileo Gen 2 board.
    We know that the board started listening messages in the temperature channel,
    but we don't receive any kind of response from the IoT device after the command
    has been processed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Working with bi-directional communications
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can easily add a few lines of code to publish a message to the same channel
    in which we are receiving messages to indicate that the command has been successfully
    processed. We will use our previous example as a baseline and we will create a
    new version of the `MessageChannel` class. The code file was `iot_python_chapter_09_02.py`.
    Don't forget to replace the strings assigned to the `publish_key` and `subscribe_key`
    local variables in the `__init__` method with the values you have retrieved from
    the previously explained PubNub key generation process. The following lines show
    the new version of the `MessageChannel` class that publishes a message after a
    command has been successfully processed. The code file for the sample is `iot_python_chapter_09_03.py`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The highlighted lines in the previous code for the new version of the `MessageChannel`
    class show the changes we made in the code. First, the code declares the `successfully_processed_command_key`
    class attribute that defines the key string that defines what the code will use
    as a successfully processed command key in a response message published to the
    channel. Whenever we publish a message that includes the specified key string,
    we know that the value associated to this key in the dictionary will indicate
    the command that the board has successfully processed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'The code declares the following three new methods:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '`callback_response_message`: This method will be used as the callback that
    will be executed when a successfully processed command response message is published
    to the channel. The method just prints the formatted response that PubNub returns
    when a message has been successfully published in the channel. In this case, the
    `message` argument doesn''t hold the original message that has been published,
    it holds the formatted response. We use `message` for the argument name to keep
    consistency with the PubNub API.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error_response_message`: This method will be used as the callback that will
    be executed when an error occurs when trying to publish a successfully processed
    command response message to the channel. The method just prints the error message
    that PubNub returns when a message hasn''t been successfully published in the
    channel.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`publish_response_message`: This method receives the message with the command
    that was successfully processed in the `message` argument. The code creates a
    `response_message` dictionary with the `successfully_processed_command_key` class
    attribute as the key and the value of the key specified in the `command_key` class
    attribute for the message dictionary as the value. Then, the code calls the `self.pubnub.publish`
    method to publish the `response_message` dictionary to the channel saved in the
    `channel` attribute. The call to this method specifies `self.callback_response_message`
    as the callback to be executed when the message is successfully published and
    `self.error_response_message` as the callback to be executed when an error occurred
    during the publishing process. When we specify a callback, the publish method
    works with an asynchronous execution, and therefore, the execution is non-blocking.
    The publication of the message and the callbacks that are specified will run in
    a different thread.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, the `callback` method defined in the `MessageChannel` class adds a call
    to the `publish_response_message` method with the message that included the command
    that has been successfully processed (`message`) as an argument. As previously
    explained, the `publish_response_message` method is non-blocking and will return
    immediately while the successfully processed message is published in another thread.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is time to start running the example in the Intel Galileo Gen 2 board.
    The following line will start the example in the SSH console:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After you run the example, go to the Web browser in which you are working with
    the PubNub debug console. You will see the following message listed in the previously
    created client:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Enter the following JSON code and click **Send**:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After you click **Send**, the following lines will appear in the client log.
    The last message has been published by the board to the channel and indicates
    that the `print_temperature_fahrenheit` command has been successfully processed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following picture shows the messages and debug messages log for the PubNub
    client after we clicked the **Send** button:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with bi-directional communications](img/B05042_09_12.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: After you publish the previous message, you will see the following output in
    the SSH console for the Intel Galileo Gen 2 board. You will notice the servo's
    shaft rotates to 90 degrees. The board also receives the successfully processed
    command message because it is subscribed to the channel in which the message has
    been published.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, enter the following JSON code and click **Send**:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After you click **Send**, the following lines will appear in the client log.
    The last message has been published by the board to the channel and indicates
    that the `print_information_message` command has been successfully processed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The following picture shows the messages and debug messages log for the PubNub
    client after we clicked the **Send** button.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with bi-directional communications](img/B05042_09_13.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: 'After you publish the previous message, you will see the following output in
    the SSH console for the Intel Galileo Gen 2 board. You will see the following
    text displayed at the bottom of the OLED matrix: `2nd message`. The board also
    receives the successfully processed command message because it is subscribed to
    the channel in which the message has been published.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can work with the different SDKs provided by PubNub to subscribe and publish
    to a channel. We can also make different IoT devices talk to themselves by publishing
    messages to channels and processing them. In this case, we just created a few
    commands and we didn't add detailed information about the device that has to process
    the command or the device that has generated a specific message. A more complex
    API would require commands that include more information and security.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Publishing messages to the cloud with a Python PubNub client
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been using the PubNub debug console to publish messages to the
    `temperature` channel and make the Python code running in the Intel Galileo Gen
    2 board process them. Now, we are going to code a Python client that will publish
    messages to the `temperature` channel. This way, we will be able to design applications
    that can talk to IoT devices with Python code in the publisher and in the subscriber
    devices.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: We can run the Python client on another Intel Galileo Gen 2 board or in any
    device that has Python 2.7.x installed. In addition, the code will run with Python
    3.x. For example, we can run the Python client in our computer. We just need to
    make sure that we install the `pubnub` module we have previously installed with
    pip in the Python version that is running in the Yocto Linux for the board.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a `Client` class to represent a PubNub client, configure the
    PubNub subscription, make it easy to publish a message with a command and the
    required values for the command and declare the code for the callbacks that are
    going to be executed when certain events are fired. The code file for the sample
    is `iot_python_chapter_09_04.py`. Don''t forget to replace the strings assigned
    to the `publish_key` and `subscribe_key` local variables in the `__init__` method
    with the values you have retrieved from the previously explained PubNub key generation
    process. The following lines show the code for the `Client` class:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `Client` class declares the `command_key` class attribute that defines the
    key string that defines what the code understands as a command in the messages.
    Our main goal is to build and publish command messages to a specified channel.
    We have to specify the PubNub channel name in the `channel` required argument.
    The constructor, that is, the `__init__` method, saves the received argument in
    an attribute with the same name. We will be both a subscriber and a publisher
    for this channel.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the constructor declares two local variables: `publish_key` and `subscribe_key`.
    These local variables save the publish and subscribe keys we had generated with
    the PubNub Admin portal. Then, the code creates a new `Pubnub` instance with `publish_key`
    and `subscribe_key` as the arguments, and saves the reference for the new instance
    in the `pubnub` attribute. Finally, the code calls the `subscribe` method for
    the new instance to subscribe to data on the channel saved in the `channel` attribute.
    The call to this method specifies many methods declared in the `Client` class
    as we did for our previous examples.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The `publish_command` method receives a command name, the key and the value
    that provide the necessary information to execute the command in the `command_name`,
    `key` and `value` required arguments. In this case, we don't target the command
    to a specific IoT device and all the devices that subscribe to the channel and
    run the code in our previous example will process the commands that we publish.
    We can use the code as a baseline to work with more complex examples in which
    we have to generate commands that target specific IoT devices. Obviously, it is
    also necessary to improve the security.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The method creates a dictionary and saves it in the `command_message` local
    variable. The `command_key` class attribute is the first key for the dictionary
    and the `command_name` received as an argument, the value that composes the first
    key-value pair. Then, the code calls the `self.pubnub.publish` method to publish
    the `command_message` dictionary to the channel saved in the `channel` attribute.
    The call to this method specifies `self.callback_command_message` as the callback
    to be executed when the message is successfully published and `self.error_command_message`
    as the callback to be executed when an error occurred during the publishing process.
    As happened in our previous example, when we specify a callback, the `publish`
    method works with an asynchronous execution.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will use the previously coded `Client` class to write a `__main__` method
    that uses the PubNub cloud to publish two commands that our board will process.
    The following lines show the code for the `__main__` method. The code file for
    the sample is `iot_python_chapter_09_04.py`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The code in the `__main__` method is very easy to understand. The code creates
    an instance of the `Client` class with `"temperature"` as an argument to become
    both a subscriber and a publisher for this channel in the PubNub cloud. The code
    saves the new instances in the `client` local variable.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The code calls the `publish_command` method with the necessary arguments to
    build and publish the `print_temperature_fahrenheit` command with a temperature
    value of `45`. The method will publish the command with an asynchronous execution.
    Then, the code calls the `publish_command` method again with the necessary arguments
    to build and publish the `print_information_message` command with a text value
    of `"Python IoT"`. The method will publish the second command with an asynchronous
    execution.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the code sleeps for 1 minute (60 seconds) in order to make it possible
    for the asynchronous executions to successfully publish the commands. The different
    callbacks defined in the `Client` class will be executed as the different events
    fire. As we are also subscribed to the channel, we will also receive the messages
    we publish in the `temperature` channel.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Keep the Python code we have executed in our previous example running on the
    board. We want the board to process our commands. In addition, keep the Web browser
    in which you are working with the PubNub debug console opened because we also
    want to see all the messages in the log.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: The following line will start the example for the Python client in any computer
    or device that you want to use as a client. It is possible to run the code in
    another SSH terminal in case you want to use the same board as a client.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After you run the example, you will see the following output in the Python console
    that runs the Python client, that is, the `iot_python_chapter_09_04.py` Python
    script.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The code used the PubNub Python SDK to build and publish the following two
    command messages in the `temperature` channel:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As we are also subscribed to the temperature channel, we receive the messages
    we sent with an asynchronous execution. Then, we received the successfully processed
    command messages for the two command messages. The board has processed the commands
    and published the messages to the `temperature` channel.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'After you run the example, go to the Web browser in which you are working with
    the PubNub debug console. You will see the following messages listed in the previously
    created client:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following picture shows the last messages displayed in the log for the
    PubNub client after we run the previous example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![Publishing messages to the cloud with a Python PubNub client](img/B05042_09_14.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: 'You will see the following text displayed at the bottom of the OLED matrix:
    `Python IoT`. In addition, the servo''s shaft will rotate to 45 degrees.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use the PubNub SDKs available in different programming languages to create
    applications and apps that publish and receive messages in the PubNub cloud and
    interact with IoT devices. In this case, we worked with the Python SDK to create
    a client that publishes commands. It is possible to create mobile apps that publish
    commands and easily build an app that can interact with our IoT device.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Using MQTT with Mosquitto and Eclipse Paho
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mosquitto is an open source message broker that implements the versions 3.1
    and 3.1.1 of the MQTT protocol, and therefore, allows us to work with messages
    using the publish/subscribe model. Mosquitto is an iot.eclipse.org project and
    is provided with the Eclipse Public Project (EPL)/EDL license. The following is
    the Web page for Mosquitto: [http://mosquitto.org](http://mosquitto.org).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'The Eclipse Paho project provides an open source client implementation of MQTT.
    The project includes a Python client, also known as the Paho Python Client or
    Eclipse Paho MQTT Python client library. This Python client has been contributed
    from the Mosquitto project and was originally the Mosquitto Python Client. The
    following is the Web page for the Eclipse Paho project: [http://www.eclipse.org/paho](http://www.eclipse.org/paho).
    The following is the Web page for the Eclipse Paho MQTT Python client library,
    that is, the paho-mqtt module: [https://pypi.python.org/pypi/paho-mqtt/1.1](https://pypi.python.org/pypi/paho-mqtt/1.1).'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. Working with Python on Intel Galileo Gen
    2"), *Working* *with Python on Intel Galileo Gen 2*, we installed `pip` installer
    to easily install additional Python 2.7.3 packages in the Yocto Linux that we
    are running on the board. Now, we will use `pip` installer to install paho-mqtt
    1.1\. We just need to run the following command in the SSH terminal to install
    the package.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The last lines for the output will indicate that the `paho-mqtt` package has
    been successfully installed. Don't worry about the error messages related to building
    wheel and the insecure platform warning.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Tip
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Eclipse allows us to use a publically accessible sandbox server for the Eclipse
    IoT projects at [iot.eclipse.org](http://iot.eclipse.org), port 1883\. In the
    following examples, we will use this sandbox server as our Mosquitto message broker.
    This way, we don't have to setup a Mosquitto message broker to test the examples
    and learn how to work with the Paho Python Client. However, in a real-life application,
    we should setup a Mosquitto message broker and use it for our project.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'We will take the code we wrote in the previous chapter when we read temperature
    and humidity values from the sensor, we printed the values in an OLED matrix and
    rotated a servo''s shaft to display the measured temperature expressed in degrees
    Fahrenheit with the shaft. The code file for the sample was `iot_python_chapter_08_03.py`.
    We will use this code as a baseline to add the same features that we added when
    we worked with the PubNub cloud. However, in this case, we will use the Paho Python
    Client and the publically accessible sandbox server that provides us with a Mosquitto
    message broker. We will be able to perform the following actions with MQTT messages
    sent to a specific topic from any device that can publish MQTT messages in the
    topic to which we are subscribed:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Rotate the servo's shaft to display a temperature value in degrees Fahrenheit
    received as part of the message
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display a line of text received as part of the message at the bottom of the
    OLED matrix
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Paho Python Client uses the topic name instead of channel. You can think
    of a topic as a channel.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: We will use the recently installed `paho-mqtt` module to subscribe to a specific
    topic and run code when we receive messages in the topic. We will create a `MessageTopic`
    class to represent the communications topic, configure the MQTT client, the subscription
    to the client and declare the code for the callbacks that are going to be executed
    when certain events are fired. The code file for the sample is `iot_python_chapter_09_05.py`.
    Remember that we use the code file `iot_python_chapter_08_03.py` as a baseline,
    and therefore, we will add the class to the existing code in this file and we
    will create a new Python file. Don't forget to replace the strings assigned to
    the `topic` class attribute with your unique topic name. As the Mosquitto broker
    we are using is public, you should use a unique topic to make sure you only receive
    the messages you publish.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `MessageTopic` class declares the `command_key` class attribute that defines
    the key string that defines what the code will understand as the command. Whenever
    we receive a message that includes the specified key string, we know that the
    value associated to this key in the dictionary will indicate the command that
    the message wants the code running in the board to be processed. In this case,
    we don't receive messages as dictionaries, and therefore, it is necessary to convert
    them from strings to dictionaries when they are not just a string.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The code declares the `successfully_processed_command_key` class attribute that
    defines the key string that defines what the code will use as a successfully processed
    command key in a response message published to the topic. Whenever we publish
    a message that includes the specified key string, we know that the value associated
    to this key in the dictionary will indicate the command that the board has successfully
    processed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: We have to specify the `TemperatureServo` instance and the `Oled` instance in
    the `temperature_servo` and `oled` required arguments. The constructor, that is,
    the `__init__` method, saves the received arguments in two attributes with the
    same names. The `topic` class attribute argument specifies the Mosquitto topic
    to which we are going to subscribe to listen to the messages that other devices
    send to this topic. We will also publish messages to this topic, and therefore,
    we will be both a subscriber and a publisher for this channel.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Then, the constructor creates an instance of the `mqtt.Client` class that represents
    an MQTT client and we will use to communicate with an MQTT broker. As we create
    the instance with the default parameters, we will create an instance of `paho.mqtt.client.MQTTv31`
    and we will work with MQTT version 3.1.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: The code also saves a reference to this instance in the `active_instance` class
    attribute because we have to access the instance in static methods that we will
    be specified as callbacks for the different events that the MQTT client fires.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code assigns the `self.client.on_connect` attribute to the `on_connect`
    static method and the `self.client.on_message` attribute to the `on_message` static
    method. Static methods do not receive either `self` of `cls` as the first argument,
    and therefore, we can use them as callbacks with the required number of arguments.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the constructor calls the `self.client.connect` method and specifies
    the publically accessible sandbox server for the Eclipse IoT projects at iot.eclipse.org,
    port 1883, in the arguments. This way, the code asks the MQTT client to establish
    a connection to the specified MQTT broker. In case you decide to use your own
    Mosquitto broker, you just need to change the values for the `host` and `port`
    arguments, according to the configuration for the Mosquitto broker. The `connect`
    method runs with an asynchronous execution, and therefore, it is a non-blocking
    call.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: After a connection has been successfully established with the MQTT broker, the
    specified callback in the `self.client.on_connect` attribute will be executed,
    that is, the `on_connect` static method (marked with the `@staticmethod` decorator).
    This static method receives the `mqtt.Client` instance that established the connection
    with the MQTT broker in the `client` argument. The code calls the `client.subscribe`
    method with `MessageTopic.topic` as an argument to subscribe to the topic specified
    in the `topic` class attribute.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case, we will only subscribe to one topic. However, it is very important
    to know that we are not limited to subscribe to a single topic, we might subscribe
    to many topics with a single call to the `subscribe` method.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the code calls the `client.publish` method with `MessageTopic.topic`
    as the `topic` argument and a message string in the `payload` argument. This way,
    we publish a string message that says `"Listening to messages in the Intel Galileo
    Gen 2 board"` to the topic specified in the `topic` class attribute.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Whenever there is a new message received in the topic to which we have subscribed,
    the specified callback in the `self.client.on_messsage` attribute will be executed,
    that is, the `on_message` static method (marked with the `@staticmethod` decorator).
    This static method receives the `mqtt.Client` instance that established the connection
    with the MQTT broker in the `client` argument and an `mqtt.MQTTMessage` instance
    in the `msg` argument. The `mqtt.MQTTMessage` class describes an incoming message.
    First, the static method checks whether the `msg.topic` attribute, that indicates
    the topic in which the message has been received, matches the value in the `topic`
    class attribute. In this case, whenever the `on_message` method is executed, the
    value in `msg.topic` will always match the value in the `topic` class attribute
    because we just subscribed to one topic. However, in case we subscribe to more
    than one topic, is is always necessary to check which is the topic in which the
    message was sent and in which we are receiving the message.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: The code prints the message that has been received, that is, the `msg.payload`
    attribute. Then, the code assigns the result of the `json.loads` function to deserialize
    `msg.payload` to a Python object and assigns the results to the `message_dictionary`
    local variable. In case the contents of `msg.payload` are not JSON, a `ValueError`
    exception will be captured and no more code will be executed in the method. In
    case the contents of `msg.payload` are JSON, we will have a dictionary in the
    `message_dictionary` local variable.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code checks whether the `command_key` class attribute is included
    in the `message_dictionary` dictionary. If the expression evaluates to `True`,
    it means that the JSON message converted to a dictionary includes a command that
    we have to process. However, before we can process the command, we have to check
    which is the command, and therefore, it is necessary to retrieve the value associated
    with the key equivalent to the `command_key` class attribute. The code is capable
    of running specific code when the value is any of the two commands that we used
    in our previous example when we worked with the PubNub cloud.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: The code uses the `active_instance` class attribute that has a reference to
    the active `MessageTopic` instance to call the necessary methods for either the
    `temperature_servo` or the `oled` attribute based on the command that has to be
    processed. We had to declare the callbacks as static methods, and therefore, we
    use this class attribute to access the active instance.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Once the command has been successfully processed, the code calls the `publish_response_message`
    for the `MessageTopic` instance saved in the `active_instance` class attribute.
    This method receives the message dictionary that has been received with the command
    in the `message` argument. The method calls the `json.dumps` function to serialize
    a dictionary to a JSON formatted string with the response message that indicates
    the command has been successfully processed. Finally, the code calls the `client.publish`
    method with the `topic` class attribute as the `topic` argument and the JSON formatted
    string (`response_message`) in the `payload` argument.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case, we are not evaluating the response from the `publish` method.
    In addition, we are using the default value for the `qos` argument that specifies
    the desired quality of service. In more advanced scenarios, we should add code
    to check the results of the method and probably adding code on the `on_publish`
    callback that is fired when a message is successfully published.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will use the previously coded `MessageTopic` class to create a new version
    of the `__main__` method that uses the Mosquitto broker and the MQTT client to
    receive and process commands. The new version doesn't rotate the servo's shaft
    when the ambient temperature changes, instead, it will do this when it receives
    the appropriate command from any device connected to the Mosquitto broker. The
    following lines show the new version of the `__main__` method. The code file for
    the sample is `iot_python_chapter_09_05.py`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The highlighted line creates an instance of the previously coded `MessageTopic`
    class with `temperature_servo` and `oled` as the arguments. The constructor will
    subscribe to the `"iot-python-gaston-hillar/temperature"` topic in the Mosquitto
    broker, and therefore, we must publish messages to this topic in order to send
    the commands that the code will process. The loop will read the values from the
    sensor and print the values to the console as in the previous version of the code,
    and therefore, we will have code running in the loop and we will also have code
    listening to the messages in the `"iot-python-gaston-hillar/temperature"` topic
    in the Mosquitto broker. The last lines of the loop call the `message_channel.loop`
    method 10 times and sleep 1 second each time between the calls. The `loop` method
    calls the loop method for the MQTT client to and ensures communication with the
    broker is carried out. Think about the call to the loop method as synchronizing
    your mailbox. Any pending messages to the published in the outgoing box will be
    sent and any incoming messages will arrive to the inbox and the events that we
    have previously analyzed will be fired.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is also a threaded interface that we can run by calling the `loop_start`
    method for the MQTT client. This way, we can avoid multiple calls to the `loop`
    method.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: The following line will start the example.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Keep the code running in the board. We will start receiving messages later because
    we have to write the code that will publish messages to this topic and send the
    commands to be processed.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Publishing messages to a Mosquitto broker with a Python client
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have the code that is going to be running in the Intel Galileo Gen 2 board
    to process the command messages received from the Mosquitto message broker. Now,
    we are going to code a Python client that will publish messages to the `"iot-python-gaston-hillar/temperature"`
    channel. This way, we will be able to design applications that can talk to IoT
    devices with MQTT messages. Specifically, the applications will be able to communicate
    through a Mosquitto message broker with Python code in the publisher and in the
    subscriber devices.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: We can run the Python client on another Intel Galileo Gen 2 board or in any
    device that has Python 2.7.x installed. In addition, the code will run with Python
    3.x. For example, we can run the Python client in our computer. We just need to
    make sure that we install the `pubnub` module we have previously installed with
    pip in the Python version that is running in the Yocto Linux for the board.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create many functions that we will assign as the callbacks to the events
    in the MQTT client. In addition, we will declare variables and a helper function
    to make it easy to publish a message with a command and the required values for
    the command. The code file for the sample is `iot_python_chapter_09_06.py`. Don''t
    forget to replace the string assigned to the `topic` variable with the topic name
    you have specified in the previous code. The following lines show the code that
    defines the variables and the functions:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The code declares the `command_key` variable that defines the key string that
    indicates what the code understands as a command in the messages. Our main goal
    is to build and publish command messages to the topic specified in the `topic`
    variable. We will be both a subscriber and a publisher for this topic.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'The `on_connect` function is the callback that will be executed once a successful
    connection has been established with the Mosquitto MQTT broker. The code calls
    the `subscribe` method for the MQTT client received in the `client` argument and
    then calls the `publish` method to send the following string message to the topic:
    `"Listening to messages in the Paho Python Client"`'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: The code calls the `publish_command` function with the necessary arguments to
    build and publish the `print_temperature_fahrenheit` command with a temperature
    value of 45\. Finally, the code calls the `publish_command` function again with
    the necessary arguments to build and publish the `print_information_message` command
    with a text value of `"Python IoT"`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: The `publish_command` function receives the MQTT client, the topic, the command
    name, the key and the value that provide the necessary information to execute
    the command in the `client`, `topic`, `command_name`, `key` and `value` required
    arguments. In this case, we don't target the command to a specific IoT device
    and all the devices that subscribe to the topic and run the code in our previous
    example will process the commands that we publish. We can use the code as a baseline
    to work with more complex examples in which we have to generate commands that
    target specific IoT devices. As happened in our previous examples, it is also
    necessary to improve the security.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: The function creates a dictionary and saves the results of serializing the dictionary
    to a JSON formatted string in the `command_message` local variable. The `command_key`
    variable is the first key for the dictionary and the `command_name` received as
    an argument, the value that composes the first key-value pair. Then, the code
    calls the `client.publish` method to publish the `command_message` JSON formatted
    string to the topic received as an argument.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: The `on_message` function will be executed each time a new message arrives to
    the topic to which we have subscribed. The function just prints the raw string
    with the payload of the received message.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will use the previously coded `functions` to write a `__main__` method
    that publishes the two commands included in MQTT messages that our board will
    process. The following lines show the code for the `__main__` method. The code
    file for the sample is `iot_python_chapter_09_06.py`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The code in the `__main__` method is very easy to understand. The code creates
    an instance of the `mqtt.Client` class that represents an MQTT client and we will
    use it to communicate with an MQTT broker. As we create the instance with the
    default parameters, we will create an instance of `paho.mqtt.client.MQTTv31` and
    we will work with MQTT version 3.1.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code assigns the `client.on_connect` attribute to the previously coded
    `on_connect` function and the `client.on_message` attribute to the `on_message`
    function. The code calls the `client.connect` method and specifies the publically
    accessible sandbox server for the Eclipse IoT projects at iot.eclipse.org, port
    1883, in the arguments. This way, the code asks the MQTT client to establish a
    connection to the specified MQTT broker. In case you decide to use your own Mosquitto
    broker, you just need to change the values for the `host` and `port` arguments,
    according to the configuration for the Mosquitto broker. Remember that the `connect`
    method runs with an asynchronous execution, and therefore, it is a non-blocking
    call.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: After a connection has been successfully established with the MQTT broker, the
    specified callback in the `client.on_connect` attribute will be executed, that
    is, the `on_connect` function. The function receives the `mqtt.Client` instance
    that established the connection with the MQTT broker in the `client` argument.
    As previously explained, the function subscribes to a topic and schedules the
    publication of three messages to it.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the code calls the `client.loop_forever` method that calls the loop
    method for us in an infinite blocking loop. At this point, we only want to run
    the MQTT client loop in our program. The scheduled messages will be published
    and we will receive the messages with the successfully executed command details
    after the board processes the commands.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Keep the Python code we have executed in our previous example running on the
    board. We want the board to process our commands. The following line will start
    the example for the Python client in any computer or device that you want to use
    as a client. It is possible to run the code in another SSH terminal in case you
    want to use the same board as a client.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: After you run the example, you will see the following output in the Python console
    that runs the Python client, that is, the `iot_python_chapter_09_06.py` Python
    script.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The code used the Eclipse Paho MQTT Python client library to build and publish
    the following two command messages in the `"iot-python-gaston-hillar/temperature"`
    topic in the Mosquitto broker:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As we are also subscribed to the `"iot-python-gaston-hillar/temperature"` topic,
    we receive the messages we sent. Then, we received the successfully processed
    command messages for the two command messages. The board has processed the commands
    and published the messages to the `"iot-python-gaston-hillar/temperature"` topic.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the following messages in the output for the SSH terminal that
    is running the code for the board that processes the commands, that is, the `iot_python_chapter_09_05.py`
    Python script:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You will see the following text displayed at the bottom of the OLED matrix:
    `Python IoT`. In addition, the servo''s shaft will rotate to 45 degrees.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MQTT is:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A heavyweight messaging protocol that runs on top of the TCP/IP protocol and
    works with a publish-subscribe mechanism.
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A lightweight messaging protocol that runs on top of the TCP/IP protocol and
    works with a publish-subscribe mechanism.
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An equivalent to HTTP.
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Mosquitto is:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An open source message broker that implements the versions 3.1 and 3.1.1 of
    the MQTT protocol.
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A closed source message broker that implements the versions 3.1 and 3.1.1 of
    the MQTT protocol.
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An open source message broker that implements a RESTful API.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Eclipse Paho project provides:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An open source client implementation of HTTP.
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An open source client implementation of `dweet.io`.
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An open source client implementation of MQTT.
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following Python modules is the Paho Python Client?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: paho-client-pip.
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: paho-mqtt.
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: paho-http.
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Dweepy is:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A simple Python client for `dweet.io` that allows us to easily publish data
    to `dweet.io` with Python.
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A simple Python client for Mosquitto that allows us to easily publish messages
    to a Mosquitto message broker.
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A simple Python client for PubNub cloud that allows us to easily publish messages
    to the PubNub cloud.
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we combined many cloud-based services that allowed us to easily
    publish data collected from sensors and visualize it in a web-based dashboard.
    We realized that there is always a Python API, and therefore, it is easy to write
    Python code that interacts with popular cloud-based services.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: We worked with the MQTT protocol and its publish/subscribe model to process
    commands in our board and indicate when the commands were successfully processed
    through messages. First, we worked with the PubNub cloud that works with the MQTT
    protocol under the hoods. Then, we developed the same example with Mosquitto and
    Eclipse Paho. Now, we know how we can write applications that can establish bi-directional
    communications with our IoT devices. In addition, we know how we can make IoT
    devices communicate with other IoT devices.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are able to take advantage of many cloud services and we worked
    with the MQTT protocol, we will learn how to analyze huge amounts of data, which
    is the topic of the next chapter.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
