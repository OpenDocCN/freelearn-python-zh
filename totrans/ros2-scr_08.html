<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-138"><a id="_idTextAnchor282" class="pcalibre calibre4 pcalibre1"/>6</h1>
			<h1 id="_idParaDest-139" class="calibre6"><a id="_idTextAnchor283" class="pcalibre calibre4 pcalibre1"/>Services – Client/Server Interaction between Nodes</h1>
			<p class="calibre3">Nodes can communicate with each other using one of three communication types. You discovered topics in the previous chapter. Now is the time to switch to the second most used communication: ROS 2 services.</p>
			<p class="calibre3">As we did for topics, we will first understand services with the help of a real-life analogy. I will also share more thoughts on when to use topics versus services. After that, you will dive into the code and write a service server and client inside nodes using custom service interfaces. You will also explore additional tools to handle services from the Terminal.</p>
			<p class="calibre3">All the code we’ll write in this chapter starts from the final code of the previous chapter. We will improve the number application to learn how to use services, and then work on the turtle controller application with an additional challenge. If you want to have the same starting point as me, you can download the code from GitHub (<a href="https://github.com/PacktPublishing/ROS-2-from-Scratch" class="pcalibre calibre4 pcalibre1">https://github.com/PacktPublishing/ROS-2-from-Scratch</a>), in the <strong class="source-inline1">ch5</strong> folder, and use it as a starting point. The final code can be found in the <strong class="source-inline1">ch6</strong> folder.</p>
			<p class="calibre3">By the end of this chapter, you will understand how services work, and you will be able to create your own service interfaces, service servers, and service clients.</p>
			<p class="calibre3">Becoming confident with topics and services is one of the most important things when starting with ROS 2. With this, you will be able to write custom code for your projects and interact with most of the existing ROS 2 applications.</p>
			<p class="calibre3">In this chapter, we will cover the following topics:</p>
			<ul class="calibre9">
				<li class="calibre10">What is a ROS 2 service?</li>
				<li class="calibre10">Creating a custom service interface</li>
				<li class="calibre10">Writing a service server</li>
				<li class="calibre10">Writing a service client</li>
				<li class="calibre10">Additional tools to handle services</li>
				<li class="calibre10">Service challenge – client and server</li>
			</ul>
			<h1 id="_idParaDest-140" class="calibre6"><a id="_idTextAnchor284" class="pcalibre calibre4 pcalibre1"/>What is a ROS 2 service?</h1>
			<p class="calibre3">You discovered the concept of ROS 2 services in <a href="B22403_03.xhtml#_idTextAnchor092" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 3</em></a>, in the <em class="italic">Services</em> section, where you <a id="_idIndexMarker347" class="pcalibre calibre4 pcalibre1"/>ran your first service server and client to get an intuition of how they work. You also became familiar with the <strong class="source-inline1">ros2</strong> command-line tool for handling services from the Terminal.</p>
			<p class="calibre3">From here, I will start from scratch again and explain what services are, using a real-life analogy. We will build an example, step by step, and then recap the most important points.<a id="_idTextAnchor285" class="pcalibre calibre4 pcalibre1"/></p>
			<h2 id="_idParaDest-141" class="calibre6"><a id="_idTextAnchor286" class="pcalibre calibre4 pcalibre1"/>A server and a client</h2>
			<p class="calibre3">To start, I will use an online weather service as an analogy.</p>
			<p class="calibre3">This online <a id="_idIndexMarker348" class="pcalibre calibre4 pcalibre1"/>weather service can tell us the local weather after we send our location. To get the weather report for your city, you will need to interact with this service. You can use your computer to send a web request with the URL provided by the service.</p>
			<p class="calibre3">What’s going <a id="_idIndexMarker349" class="pcalibre calibre4 pcalibre1"/>to happen? First, your computer will send a request to the weather service. The request contains your location. The service will receive the request, process it, and if the location is valid, it will return the weather for that location. Your computer then receives a response containing the weather information. That’s the end of the communication. Here’s an illustration of this process:</p>
			<div><div><img alt="Figure 6.1 – Client/server interaction" src="img/B22403_06_1.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Client/server interaction</p>
			<p class="calibre3">This is basically how a ROS 2 service works. On one side, you have a <strong class="bold">service server</strong> inside a node, and <a id="_idIndexMarker350" class="pcalibre calibre4 pcalibre1"/>on the other side, you have a <strong class="bold">service client</strong> inside <a id="_idIndexMarker351" class="pcalibre calibre4 pcalibre1"/>another node.</p>
			<p class="calibre3">To start the communication, the service <strong class="bold">Client</strong> needs to send a <strong class="bold">request</strong> to the <strong class="bold">Server</strong>. The <strong class="bold">Server</strong> will then process the request, do any appropriate actions or computations, and return a <strong class="bold">response</strong> to the <strong class="bold">Client</strong>.</p>
			<p class="calibre3">As you <a id="_idIndexMarker352" class="pcalibre calibre4 pcalibre1"/>can see, a service, just like for topics, has a name and an interface. The interface is not just one message, it’s a pair of messages: a request and a <a id="_idIndexMarker353" class="pcalibre calibre4 pcalibre1"/>response. Both the client and server must use the same name and interface to successfully communicate with each other.</p>
			<p class="calibre3">With this example, the HTTP URL is the service name, and the pair (location, weather) is the service interface (request, respo<a id="_idTextAnchor287" class="pcalibre calibre4 pcalibre1"/>nse).</p>
			<h2 id="_idParaDest-142" class="calibre6"><a id="_idTextAnchor288" class="pcalibre calibre4 pcalibre1"/>Multiple clients for one service</h2>
			<p class="calibre3">In real life, many people will try to get the weather from this online service (at different times or at the same time). That’s not a problem: each client will send a request with a location <a id="_idIndexMarker354" class="pcalibre calibre4 pcalibre1"/>to the server through the HTTP URL. The server will process each request individually and return the appropriate weather information to each client.</p>
			<p class="calibre3">Now, this is very important: there can be only one server. One URL only goes to one server, just like one physical mail address is unique. Imagine if you send a package to someone and there are two places with the same address. How can the mail delivery person know where to deliver the package?</p>
			<p class="calibre3">This will be the same for ROS 2 services. You can have several clients send a request to the same service. However, for one service, only one server can exist. See the following figure:</p>
			<div><div><img alt="Figure 6.2 – Service server with multiple clients" src="img/B22403_06_2.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Service server with multiple clients</p>
			<p class="calibre3">Here, you can see some boxes, each box representing a node. Thus, we have four nodes. Three nodes contain a service <strong class="bold">Client</strong> and talk to the <strong class="bold">Weather service</strong> node, which contains a service <strong class="bold">Server</strong>.</p>
			<p class="calibre3">One thing <a id="_idIndexMarker355" class="pcalibre calibre4 pcalibre1"/>to note here is that the clients don’t know exactly which node to communicate with. They must go through the URL (service name). In this example, the clients aren’t aware of the IP address of the server—they just know they have to use the URL to connect to the server.</p>
			<p class="calibre3">Also, no client is aware of the other clients. When you try to get the weather information from this service, you don’t know who is also trying to access the service, or even how many people are sending a re<a id="_idTextAnchor289" class="pcalibre calibre4 pcalibre1"/>quest.</p>
			<h2 id="_idParaDest-143" class="calibre6"><a id="_idTextAnchor290" class="pcalibre calibre4 pcalibre1"/>Another service example with robotics</h2>
			<p class="calibre3">Let’s use <a id="_idIndexMarker356" class="pcalibre calibre4 pcalibre1"/>another example that could be part of a ROS application.</p>
			<p class="calibre3">Imagine that you have a node responsible for controlling an LED panel (three LEDs). This node could contain a service server that allows other nodes to request turning an LED on or off.</p>
			<p class="calibre3">You also have a node monitoring a battery. In your application, what you want to do is turn on one LED when the battery is low, and then turn it off when the battery is high again.</p>
			<p class="calibre3">You can do that using a ROS 2 service. The LED panel node would contain a service server named <strong class="source-inline1">set_led</strong>. To send a request to this server, you must provide the LED number and the state of that LED (on or off). Then, you receive a response containing a boolean value to see if the request was successfully processed by the server.</p>
			<p class="calibre3">So, the battery is now running low. Here’s what’s going to happen:</p>
			<div><div><img alt="Figure 6.3 – Client asking to turn on LED number 3" src="img/B22403_06_3.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Client asking to turn on LED number 3</p>
			<p class="calibre3">Here, <strong class="bold">Battery node</strong> will send a <strong class="bold">Request</strong> to the <strong class="source-inline1">set_led</strong> service. The <strong class="bold">Request</strong> contains the <strong class="bold">LED number 3</strong> and <strong class="bold">state on</strong> details so that it can turn on LED <strong class="bold">3</strong> of the panel.</p>
			<p class="calibre3">The <strong class="bold">Service</strong> server, in the <strong class="bold">LED panel node</strong>, receives the <strong class="bold">Request</strong>. The server may decide to <a id="_idIndexMarker357" class="pcalibre calibre4 pcalibre1"/>validate the <strong class="bold">Request</strong> (for example, if the LED number is 4, this is not valid) and process it. Processing the <strong class="bold">Request</strong> here means turning on the third LED. After that, the server sends a <strong class="bold">Response</strong> back to the <strong class="bold">Client</strong>, with a boolean flag. The <strong class="bold">Client</strong> receives this <strong class="bold">Response</strong>, and the communication ends.</p>
			<p class="calibre3">Then, when the battery is fully charged, the <strong class="bold">Battery node</strong> sends another <strong class="bold">Request</strong> this time to turn off <strong class="bold">LED 3</strong>:</p>
			<div><div><img alt="Figure 6.4 – Client asking to turn off LED number 3" src="img/B22403_06_4.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Client asking to turn off LED number 3</p>
			<p class="calibre3">The process is the same. The <strong class="bold">Client</strong> sends a <strong class="bold">Request</strong>, this time with <strong class="bold">state off</strong> for <strong class="bold">LED 3</strong>. The <strong class="bold">Server</strong>, inside the <strong class="bold">LED panel node</strong>, receives that <strong class="bold">Request</strong> and turns off the third LED. Then, the <strong class="bold">Server</strong> sends a <strong class="bold">Response</strong> back to the <strong class="bold">C<a id="_idTextAnchor291" class="pcalibre calibre4 pcalibre1"/>lient</strong>.</p>
			<h2 id="_idParaDest-144" class="calibre6"><a id="_idTextAnchor292" class="pcalibre calibre4 pcalibre1"/>Wrapping things up</h2>
			<p class="calibre3">On top of topics, ROS 2 nodes can use services to communicate with each other.</p>
			<p class="calibre3">When should <a id="_idIndexMarker358" class="pcalibre calibre4 pcalibre1"/>you use topics versus services? You should use topics to publish unidirectional data streams and services when you want to have a client/server type of communication.</p>
			<p class="calibre3">For example, if you want to continuously send a velocity command to a robot 10 times per second, or send the data you read from a sensor, you will use topics. If you want to have a node perform quick computations or do some actions on demand (enabling/disabling a motor, starting/stopping a robot), then you would use services.</p>
			<p class="calibre3">It can be hard to give a definitive answer to that question. Each application is different. Most of the time, the choice will be obvious, but sometimes, you have to go one way only to realize that that was the wrong way. The more experience you get with ROS 2, the more you will be able to make the best design decisions.</p>
			<p class="calibre3">Here are some important points about how services work:</p>
			<ul class="calibre9">
				<li class="calibre10">A service is defined by a name and an interface.</li>
				<li class="calibre10">The name of a service follows the same rules as for topics. It must start with a letter and can be followed by other letters, numbers, underscores, tildes, and slashes.</li>
				<li class="calibre10">The interface contains two things: a request and a response. Both the client and server must use the same interface to be able to communicate with each other.</li>
				<li class="calibre10">A service server can only exist once but can have multiple clients.</li>
				<li class="calibre10">Service clients are not aware of each other and are not aware of the server node. To reach the server, they just know that they must use the service name and provide the correct interface.</li>
				<li class="calibre10">One node can contain multiple service servers and clients, each with a different service name.</li>
			</ul>
			<p class="calibre3">Now, how can you write a service client and server?</p>
			<p class="calibre3">Just as for nodes and topics, you will find everything you need in the <strong class="source-inline1">rclpy</strong> and <strong class="source-inline1">rclcpp</strong> libraries. With those libraries, you can write a service server and client inside nodes. That’s what we are going to do now.</p>
			<p class="calibre3">As we can’t <a id="_idIndexMarker359" class="pcalibre calibre4 pcalibre1"/>test a client without a server, let’s start with the server side. But before we even start writing the server, what interface will we need to use for the <a id="_idTextAnchor293" class="pcalibre calibre4 pcalibre1"/>service?</p>
			<h1 id="_idParaDest-145" class="calibre6"><a id="_idTextAnchor294" class="pcalibre calibre4 pcalibre1"/>Creating a custom service interface</h1>
			<p class="calibre3">In <a href="B22403_05.xhtml#_idTextAnchor211" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 5</em></a>, when we created the ROS 2 application with the <strong class="source-inline1">number_publisher</strong> and <strong class="source-inline1">number_counter</strong> nodes, we used an existing interface for the <strong class="source-inline1">number</strong> topic. Since we <a id="_idIndexMarker360" class="pcalibre calibre4 pcalibre1"/>wanted to publish an integer number, the <strong class="source-inline1">example_interfaces/msg/Int64</strong> interface seemed to be exactly what we needed. At this point, you know that you must avoid using the <strong class="source-inline1">example_interfaces</strong> package for real applications, but for a first test, that wasn’t a problem.</p>
			<p class="calibre3">We’re going to continue working on this application and add more functionalities so that we can practice with services. Here, we will focus on the <strong class="source-inline1">number_counter</strong> node. For now now, in this node, every time we receive a message from the <strong class="source-inline1">number</strong> topic, we’ll add this number to a counter and print the counter.</p>
			<p class="calibre3">What we want to do is allow the <strong class="source-inline1">number_counter</strong> node to reset the counter to a given number when we ask it to. For that, we will add a service server inside the node. Then, any other node can send a request, specifying the reset value for the counter. For example, let’s say the counter is currently at 76, and you send a request to reset it to 20. If the request is accepted by the service server, the counter will now become 20 and continue to increment from that value.</p>
			<p class="calibre3">Great—we know what we must do. Now, which interface should we use? Can we find an existing interface for what we need, or will we have to create a custom one? As per the title of this section, you can already guess the answer to that question. Nonetheless, let’s see what we could find if we were looking at existing in<a id="_idTextAnchor295" class="pcalibre calibre4 pcalibre1"/>terfaces.</p>
			<h2 id="_idParaDest-146" class="calibre6"><a id="_idTextAnchor296" class="pcalibre calibre4 pcalibre1"/>Finding an existing interface for our service</h2>
			<p class="calibre3">When it comes to a service interface, we need to think about two things: the request and the response.</p>
			<p class="calibre3">In our <a id="_idIndexMarker361" class="pcalibre calibre4 pcalibre1"/>application, the request, which is sent from the client to the server, should contain an integer number. This is the reset value for the counter.</p>
			<p class="calibre3">For the response, which is sent from the server to the client, we can decide to use a boolean flag, to specify whether we were able to perform the request, and a message to explain what went wrong if something went wrong.</p>
			<p class="calibre3">The question is, will we find an existing interface that matches our needs? Unfortunately, this time, it seems that there is no matching interface. We can check the <strong class="source-inline1">example_interfaces</strong> package:</p>
			<pre class="console">
$ ros2 interface list | grep example_interfaces/srv
example_interfaces/srv/AddTwoInts
example_interfaces/srv/SetBool
example_interfaces/srv/Trigger</pre>			<p class="calibre3">We can even check the <strong class="source-inline1">std_srvs</strong> package:</p>
			<pre class="console">
$ ros2 interface list | grep std_srvs/srv
std_srvs/srv/Empty
std_srvs/srv/SetBool
std_srvs/srv/Trigger</pre>			<p class="callout-heading">Note</p>
			<p class="callout">As you can see, service interfaces are placed inside a <code>srv</code> folder, inside the package. For topics, we had a <code>msg</code> folder. This is a good way to differentiate both types of interfaces easily.</p>
			<p class="calibre3">If you look more closely at those interfaces, especially <strong class="source-inline1">SetBool</strong> and <strong class="source-inline1">Trigger</strong>, you’ll see that there is no way to send an integer number in the request. Here’s an example where we’re trying to use <strong class="source-inline1">SetBool</strong>:</p>
			<pre class="console">
$ ros2 interface show example_interfaces/srv/SetBool
# some comments
bool data # e.g. for hardware enabling / disabling
---
bool success   # indicate successful run of triggered service
string message # informational, e.g. for error messages</pre>			<p class="calibre3">When <a id="_idIndexMarker362" class="pcalibre calibre4 pcalibre1"/>looking at the interface definition, you can see that the request and response are separated by three dashes (<strong class="source-inline1">---</strong>). In the response, we can find a boolean and a string, which is what we want. However, the request only contains a boolean, not an integer.</p>
			<p class="calibre3">You could have a look at other interfaces in the common interfaces GitHub repository (<a href="https://github.com/ros2/common_interfaces" class="pcalibre calibre4 pcalibre1">https://github.com/ros2/common_interfaces</a>) but you won’t find exactly what we are looking for.</p>
			<p class="calibre3">Thus, we will create our own service interface before writing the code for the service. For the <strong class="source-inline1">number</strong> topic, we were lucky enough to find an interface that we could directly use in the code (even though for real applications, the best practice is to avoid using <strong class="source-inline1">example_interfaces</strong> and <strong class="source-inline1">std_srvs</strong> anyway). Here, we need to create the inter<a id="_idTextAnchor297" class="pcalibre calibre4 pcalibre1"/>face first.</p>
			<h2 id="_idParaDest-147" class="calibre6"><a id="_idTextAnchor298" class="pcalibre calibre4 pcalibre1"/>Creating a new service interface</h2>
			<p class="calibre3">To create <a id="_idIndexMarker363" class="pcalibre calibre4 pcalibre1"/>a service interface, just like for a topic interface, you need to create and configure a package dedicated to interfaces.</p>
			<p class="calibre3">Good news: we did that in <a href="B22403_05.xhtml#_idTextAnchor211" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 5</em></a> in the <em class="italic">Creating a custom interface for a topic</em> section. Since we’re working on the same application, we will put all the topic and service interfaces in the same package: <strong class="source-inline1">my_robot_interfaces</strong> (if you don’t already have this package, go back to the previous chapter and set it up).</p>
			<p class="calibre3">We can create a new service interface inside that package directly; there’s nothing else to do. So, the process will be quite quick.</p>
			<p class="calibre3">First, navigate inside the <strong class="source-inline1">my_robot_interfaces</strong> package (where you already have a <strong class="source-inline1">msg</strong> folder) and create a new <strong class="source-inline1">srv</strong> folder:</p>
			<pre class="console">
$ cd ~/ros2_ws/src/my_robot_interfaces/
$ mkdir srv</pre>			<p class="calibre3">In this new folder, you will put all the service interfaces that are specific to your application (or robot).</p>
			<p class="calibre3">Now, create a <a id="_idIndexMarker364" class="pcalibre calibre4 pcalibre1"/>new file for a service. Here are the rules to follow regarding the filename:</p>
			<ul class="calibre9">
				<li class="calibre10">Use UpperCamelCase (PascalCase)—for example, <code>ActivateMotor</code>.</li>
				<li class="calibre10">Don’t write <code>Srv</code> or <code>Interface</code> in the name as this would add unnecessary redundancy.</li>
				<li class="calibre10">Use <code>.srv</code> for the file extension.</li>
				<li class="calibre10">As a best practice, use a verb in the interface name—for example, <code>TriggerSomething</code>, <code>ActivateMotor</code>, or <code>ComputeDistance</code>. Services are about doing an action or computation, so by using a verb, you make it very clear what the service is doing.</li>
			</ul>
			<p class="calibre3">Since we want to reset the counter, let’s simply call the interface <strong class="source-inline1">ResetCounter</strong>:</p>
			<pre class="console">
$ cd ~/ros2_ws/src/my_robot_interfaces/srv/
$ touch ResetCounter.srv</pre>			<p class="calibre3">Open this file and write the definition for the service interface. One very important thing to do here is add three dashes (<strong class="source-inline1">---</strong>) and put the request definition on top, and then the response definition below the dashes.</p>
			<p class="calibre3">For the request and response, you can use the following:</p>
			<ul class="calibre9">
				<li class="calibre10">Built-in types (<code>bool</code>, <code>byte</code>, <code>int64</code>, and so on).</li>
				<li class="calibre10">Existing message interfaces. For example, the request of the service could contain <code>geometry_msgs/Twist</code>.</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">You can’t include a service definition inside another service definition. You can only include a message (topic definition) inside the request or the response of the service. The request and response can be seen as two independent messages.</p>
			<p class="calibre3">Let’s write <a id="_idIndexMarker365" class="pcalibre calibre4 pcalibre1"/>our service interface. As it’s not too complex, we can use simple built-in types:</p>
			<pre class="source-code">
int64 reset_value
---
bool success
string message</pre>			<p class="calibre3">With this, the client will send a request with one integer value, and the response will contain a boolean flag as well as a string. All the fields inside the definition must follow the snake_case convention (use underscores between words, all letters lowercase, and no space).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Make sure you always have three dashes in all your service definitions, even if the request or the response is empty.</p>
			<p class="calibre3">Now that we’ve written our interface, we need to build it so that we can use it in our code.</p>
			<p class="calibre3">Go back to the <strong class="source-inline1">CMakeLists.txt</strong> of <strong class="source-inline1">my_robot_interfaces</strong> package. Since the package has already been configured, we just need to add one line. Add the relative path to the interface on a new line inside the <strong class="source-inline1">rosidl_generate_interfaces()</strong> function. Don’t use any commas between the lines:</p>
			<pre class="source-code">
rosidl_generate_interfaces(${PROJECT_NAME}
  "msg/HardwareStatus.msg"
<strong class="bold1">  "srv/ResetCounter.srv"</strong>
)</pre>			<p class="calibre3">After this, save all files and build the <strong class="source-inline1">my_robot_interfaces</strong> package:</p>
			<pre class="console">
$ colcon build --packages-select my_robot_interfaces</pre>			<p class="calibre3">Once built, source the environment. You should be able to find your new interface:</p>
			<pre class="console">
$ ros2 interface show my_robot_interfaces/srv/ResetCounter
int64 reset_value
---
bool success
string message</pre>			<p class="calibre3">If you <a id="_idIndexMarker366" class="pcalibre calibre4 pcalibre1"/>see that, you know that the service interface has been built successfully, and you can use it in your code. So, let’s do that and write a <a id="_idTextAnchor299" class="pcalibre calibre4 pcalibre1"/>service server.</p>
			<h1 id="_idParaDest-148" class="calibre6"><a id="_idTextAnchor300" class="pcalibre calibre4 pcalibre1"/>Writing a service server</h1>
			<p class="calibre3">You will now write your first service server. As mentioned previously, we will continue with the <a id="_idIndexMarker367" class="pcalibre calibre4 pcalibre1"/>number application we started in the previous chapter. What we want to do here is allow <strong class="source-inline1">number_counter</strong> to reset the counter to a given number when we ask it to do so. This is a perfect example of when to use a service.</p>
			<p class="calibre3">The first thing to think about when creating a new service is what service interface you need. We’ve just done that, so we can now focus on the code.</p>
			<p class="calibre3">To write a service server, you will need to import the interface and then create a new service in the node’s constructor. You will also need to add a callback to be able to process the request, do the required action or computation, and return a response to the client.</p>
			<p class="calibre3">As always, let’s start with a fully detailed explanation with Python, after which we will see how to do th<a id="_idTextAnchor301" class="pcalibre calibre4 pcalibre1"/>e same with C++.</p>
			<h2 id="_idParaDest-149" class="calibre6"><a id="_idTextAnchor302" class="pcalibre calibre4 pcalibre1"/>Writing a Python service server</h2>
			<p class="calibre3">To write <a id="_idIndexMarker368" class="pcalibre calibre4 pcalibre1"/>a Python service server, we first need to have a Python node. We won’t create a new node here since we’re adding functionality to an existing one (<strong class="source-inline1">number_counter</strong>).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can have any number of publishers, subscribers, and services inside a node. So long as you keep things clean, that will not be a problem.</p>
			<p class="calibre3">Let’s get started. As always, you can find the complete code in this book’s GitHub repository. I will not display the full code for the node here, just the new lines that are required for the servi<a id="_idTextAnchor303" class="pcalibre calibre4 pcalibre1"/>ce we are adding.</p>
			<h3 class="calibre8">Importing a service interface</h3>
			<p class="calibre3">The first <a id="_idIndexMarker369" class="pcalibre calibre4 pcalibre1"/>big part of creating a service is to find an existing interface or create a new one. That’s what we just did, so let’s use the <strong class="source-inline1">ResetCounter</strong> interface from the <strong class="source-inline1">my_robot_interfaces</strong> package.</p>
			<p class="calibre3">First, we need to add the dependency to this interface package inside the package where we write the node with the service. Open the <strong class="source-inline1">package.xml</strong> file from <strong class="source-inline1">my_py_pkg</strong> and add the new dependency:</p>
			<pre class="source-code">
&lt;depend&gt;rclpy&lt;/depend&gt;
&lt;depend&gt;example_interfaces&lt;/depend&gt;
<strong class="bold1">&lt;depend&gt;my_robot_interfaces&lt;/depend&gt;</strong></pre>			<p class="calibre3">This will ensure that the interfaces package is installed when you build the <strong class="source-inline1">my_py_pkg</strong> package with <strong class="source-inline1">colcon</strong>. Now, import the dependency into your code (<strong class="source-inline1">number_counter.py</strong>):</p>
			<pre class="source-code">
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from example_interfaces.msg import Int64
<strong class="bold1">from my_robot_interfaces.srv import ResetCounter</strong></pre>			<p class="calibre3">To import a service, we must specify the package name (<strong class="source-inline1">my_robot_interfaces</strong>), followed <a id="_idIndexMarker370" class="pcalibre calibre4 pcalibre1"/>by the folder name for services (<strong class="source-inline1">srv</strong>), and finally the class for the interface (<strong class="source-inline1">ResetCounter</strong>).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">I’ve already mentioned this, but if you’re using VS Code and auto-completion doesn’t work, or the service isn’t recognized (import error), follow the process below.</p>
			<p class="callout">Close VS code. Then, open a new Terminal, make sure the environment is correctly sourced, and find the interface (<code>ros2 interface show &lt;interface_name&gt;</code>). After, navigate to the <code>src</code> directory of the ROS 2 workspace and open<a id="_idTextAnchor304" class="pcalibre calibre4 pcalibre1"/> VS Code with:</p>
			<p class="callout"><strong class="bold">$ </strong><strong class="bold">code .</strong></p>
			<h3 class="calibre8">Adding a service server to the node</h3>
			<p class="calibre3">Now that you’ve correctly imported the service interface, you can create the service server.</p>
			<p class="calibre3">As you <a id="_idIndexMarker371" class="pcalibre calibre4 pcalibre1"/>did for publishers and subscribers, you will add your service servers to the node’s constructor.</p>
			<p class="calibre3">Here’s the constructor of the <strong class="source-inline1">NumberCounterNode</strong> class, which contains the previously created subscriber and the new service server:</p>
			<pre class="source-code">
def __init__(self):
    super().__init__("number_counter")
    self.counter_ = 0
    self.number_subscriber_ = self.create_subscription(Int64, "number", self.callback_number, 10)
<strong class="bold1">    self.reset_counter_service_ = self.create_service(ResetCounter, "reset_counter", self.callback_reset_counter)</strong>
    self.get_logger().info("Number Counter has been started.")</pre>			<p class="calibre3">We add the service server at the same time as the number subscriber and just before the ending log.</p>
			<p class="calibre3">To create <a id="_idIndexMarker372" class="pcalibre calibre4 pcalibre1"/>the service server, we use the <strong class="source-inline1">create_service()</strong> method from the <strong class="source-inline1">Node</strong> class. Once again, you can see that by inheriting from this class, we get access to all ROS 2 functionalities easily. In this method, you must provide three arguments:</p>
			<ul class="calibre9">
				<li class="calibre10"><code>ResetCounter</code> class we have imported.</li>
				<li class="calibre10"><code>reset_counter</code>.</li>
				<li class="calibre10"><strong class="bold">Service callback</strong>: The service server, as its name suggests, is a server. This means <a id="_idIndexMarker375" class="pcalibre calibre4 pcalibre1"/>that it won’t do anything by itself. You will need to have a client send a request so that the server does something. So, while the node is spinning, the server will be in “waiting mode.” Upon reception of a request, the service callback will be triggered, and the request will be passed to this callback.</li>
			</ul>
			<p class="calibre3">Now, we need to implement this callback. First, let’s write a minimal code example:</p>
			<pre class="source-code">
def callback_reset_counter(self, request: ResetCounter.Request, response: ResetCounter.Response):
    self.counter_ = request.reset_value
    self.get_logger().info("Reset counter to " + str(self.counter_))
    response.success = True
    response.message = "Success"
    return response</pre>			<p class="calibre3">In a service callback, we receive two things: an object for the request and an object for the response. The request object contains all the data sent by the client. The response object is empty, and we will need to fill it, as well as return it.</p>
			<p class="calibre3">To name the callback, I usually write <strong class="source-inline1">callback_</strong> followed by the service name. This makes it easier to recognize in the code and will prevent future mistakes as you want to make sure <a id="_idIndexMarker376" class="pcalibre calibre4 pcalibre1"/>you don’t call this method directly. It should only be called while the node is spinning and when a client sends a request from another node.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In the method’s arguments, I have also specified the type for the two arguments. This way, we make the code more robust, and we can use auto-completion features from IDEs such as VS Code.</p>
			<p class="callout">When you create an interface for a topic, you only get one class for that interface (for example, <code>Int64</code>). As you can see, in a service, we get two classes: one for the request (<code>Interface.Request</code>) and one for the response (<code>Interface.Response</code>).</p>
			<p class="calibre3">In this callback, we get <strong class="source-inline1">reset_value</strong> from the request and modify the <strong class="source-inline1">counter_</strong> variable accordingly. Then, we fill the success and message fields from the response and return the response.</p>
			<p class="calibre3">This is a very minimal piece of code for a service server. In real life, you’ll probably want to check if the request is valid before you use the values from it. For example, if you have a service that will modify the maximum velocity of a mobile robot, you might want to be sure the value you receive is not too high, to prevent the robot from becoming uncontrolled and damaging itself or the environment.</p>
			<p class="calibre3">Let’s improve the callback so that we can validate <strong class="source-inline1">reset_value</strong> before we modi<a id="_idTextAnchor305" class="pcalibre calibre4 pcalibre1"/>fy the <strong class="source-inline1">counter_</strong> variable.</p>
			<h3 class="calibre8">Validating the request</h3>
			<p class="calibre3">Let’s say <a id="_idIndexMarker377" class="pcalibre calibre4 pcalibre1"/>we want to add those two validation rules: the reset value must be a positive number, and it cannot be higher than the current counter value.</p>
			<p class="calibre3">Modify the code in the <strong class="source-inline1">callback_reset_counter</strong> method, like so:</p>
			<pre class="source-code">
def callback_reset_counter(self, request: ResetCounter.Request, response: ResetCounter.Response):
    if request.reset_value &lt; 0:
        response.success = False
        response.message = "Cannot reset counter to a negative value"
    elif request.reset_value &gt; self.counter_:
        response.success = False
        response.message = "Reset value must be lower than current counter value"
    else:
        self.counter_ = request.reset_value
        self.get_logger().info("Reset counter to " + str(self.counter_))
        response.success = True
        response.message = "Success"
    return response</pre>			<p class="calibre3">First, we check <a id="_idIndexMarker378" class="pcalibre calibre4 pcalibre1"/>if the value is negative. If so, we don’t do anything with the <strong class="source-inline1">counter_</strong> variable. We set the boolean flag to <strong class="source-inline1">False</strong> and provide an appropriate error message.</p>
			<p class="calibre3">Then, we check if the value is greater than the current <strong class="source-inline1">counter_</strong> value. If that’s the case, we do the same thing as before, with a different error message.</p>
			<p class="calibre3">Finally, if none of those conditions are true (which means we’ve validated the request), then we process the request and modify the <strong class="source-inline1">counter_</strong> variable.</p>
			<p class="calibre3">Here’s a recap of the steps for a service server callback:</p>
			<ol class="calibre11">
				<li class="calibre10">(Optional but recommended) Validate the request, or validate that external conditions are met for the callback to be processed. For example, if the service is about activating a motor, but the communication with the motor hasn’t been started yet, then you can’t activate the motor.</li>
				<li class="calibre10">Process the action or computation using the data from the request if needed.</li>
				<li class="calibre10">Fill in the appropriate field for the response. It’s not mandatory to fill in all the fields. If you omit some of them, default values will be used (<code>0</code> for numbers and <code>""</code> for strings).</li>
				<li class="calibre10">Return the response. This is quite an important step that many people forget at the beginning. If you don’t return the response, you will get an error at runtime.</li>
			</ol>
			<p class="calibre3">All you <a id="_idIndexMarker379" class="pcalibre calibre4 pcalibre1"/>must do now is build your package where the node is, source, and run the node.</p>
			<p class="calibre3">When you run the <strong class="source-inline1">number_counter</strong> node, you’ll see the following:</p>
			<pre class="console">
$ ros2 run my_py_pkg number_counter
[INFO] [1712647809.789229368] [number_counter]: Number Counter has been started.</pre>			<p class="calibre3">The service server has been started within the node, but of course, nothing will happen as you need to send a request from a client to try the server.</p>
			<p class="calibre3">That’s what we will do in a minute, but before that, let’s learn how to write the service server in C++. If you don’t want to learn ROS 2 with C++ for now, you can skip this and go to the n<a id="_idTextAnchor306" class="pcalibre calibre4 pcalibre1"/>ext section in this chapter.</p>
			<h2 id="_idParaDest-150" class="calibre6"><a id="_idTextAnchor307" class="pcalibre calibre4 pcalibre1"/>Writing a C++ service server</h2>
			<p class="calibre3">Let’s add <a id="_idIndexMarker380" class="pcalibre calibre4 pcalibre1"/>a service server inside our C++ <strong class="source-inline1">number_counter</strong> node using the same name and interface that we used for the one we created with Python. The process is the same: import the interface, create a service server, and add a callback function.</p>
			<p class="calibre3">As mentioned previously in this book, make sure you follow all C++ explanations while keeping the <a id="_idTextAnchor308" class="pcalibre calibre4 pcalibre1"/>GitHub code open on the side.</p>
			<h3 class="calibre8">Importing a service interface</h3>
			<p class="calibre3">First, since <a id="_idIndexMarker381" class="pcalibre calibre4 pcalibre1"/>we’ll have a dependency on <strong class="source-inline1">my_robot_interfaces</strong>, open the <strong class="source-inline1">package.xml</strong> file of the <strong class="source-inline1">my</strong><strong class="source-inline1">_cpp_pkg</strong> package and add the following one line:</p>
			<pre class="source-code">
&lt;depend&gt;rclcpp&lt;/depend&gt;
&lt;depend&gt;example_interfaces&lt;/depend&gt;
<strong class="bold1">&lt;depend&gt;my_robot_interfaces&lt;/depend&gt;</strong></pre>			<p class="calibre3">Then, open the <strong class="source-inline1">number_counter.cpp</strong> file and include the <strong class="source-inline1">ResetCounter</strong> interface:</p>
			<pre class="source-code">
#include "rclcpp/rclcpp.hpp"
#include "example_interfaces/msg/int64.hpp"
<strong class="bold1">#include "my_robot_interfaces/srv/reset_counter.hpp"</strong></pre>			<p class="calibre3">To import a service interface in C++, you must use <strong class="source-inline1">#</strong><strong class="source-inline1">include "&lt;package_name&gt;/srv/&lt;service_name&gt;.hpp"</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">As a reminder, for this <code>include</code> to be recognized by VS Code, make sure you add the following to the <code>c_cpp_properties.json</code> file, in the <code>.vscode</code> folder that was generated when you opened VS Code: <code>"/home/&lt;user&gt;/ros2_ws/install/my_robot_interfaces/include/**"</code>.</p>
			<p class="calibre3">After this, I added an extra line with the <strong class="source-inline1">using</strong> keyword so that we can just write <strong class="source-inline1">ResetCounter</strong> in the code, instead of <strong class="source-inline1">my_robot_interfaces::srv::ResetCounter</strong>:</p>
			<pre class="source-code">
using ResetCounter = my_robot_interfaces::srv::ResetCounter;</pre>			<p class="calibre3">This will help us make the code more readable. With C++, you can quickly end up with very long types that almost take more than one line to write. Since we will need to use the service interface quite often, adding this <strong class="source-inline1">using</strong> line is a best practice to keep things simple.</p>
			<p class="calibre3">I didn’t do it previously with <strong class="source-inline1">example_interfaces::msg::Int64</strong> when we worked on topics, but if you want, you can also write <strong class="source-inline1">using Int64 = example_interfaces::msg::Int64;</strong> and then reduc<a id="_idTextAnchor309" class="pcalibre calibre4 pcalibre1"/>e the code for the subscriber.</p>
			<h3 class="calibre8">Adding a service server to the node</h3>
			<p class="calibre3">Now that <a id="_idIndexMarker382" class="pcalibre calibre4 pcalibre1"/>we’ve included the interface, let’s create the service server. We will store it as a private attribute in the class:</p>
			<pre class="source-code">
rclcpp::Service&lt;ResetCounter&gt;::SharedPtr reset_counter_service_;</pre>			<p class="calibre3">As you can see, we use the <strong class="source-inline1">rclcpp::Service</strong> class, and then, as always, we make it a shared pointer with <strong class="source-inline1">::SharedPtr</strong>.</p>
			<p class="calibre3">Now, we can initialize the service in the constructor:</p>
			<pre class="source-code">
reset_counter_service_ = this-&gt;create_service&lt;ResetCounter&gt;("reset_counter",  std::bind(&amp;NumberCounterNode::callbackResetCounter, this, _1, _2));</pre>			<p class="calibre3">To create the service, we must use the <strong class="source-inline1">create_service()</strong> method from the <strong class="source-inline1">rclcpp::Node</strong> class. As for Python, we need to provide the service interface, the service name, and a callback to process the incoming requests. For <strong class="source-inline1">_1</strong> and <strong class="source-inline1">_2</strong> to work, don’t forget to add <strong class="source-inline1">using namespace </strong><strong class="source-inline1">std::placeholders;</strong> beforehand.</p>
			<p class="calibre3">Here’s the callback method, including the code to validate the request:</p>
			<pre class="source-code">
void callbackResetCounter(const ResetCounter::Request::SharedPtr request, const ResetCounter::Response::SharedPtr response)
{
    if (request-&gt;reset_value &lt; 0) {
        response-&gt;success = false;
        response-&gt;message = "Cannot reset counter to a negative value";
    }
    else if (request-&gt;reset_value &gt; counter_) {
        response-&gt;success = false;
        response-&gt;message = "Reset value must be lower than current counter value";
    }
    else {
        counter_ = request-&gt;reset_value;
        RCLCPP_INFO(this-&gt;get_logger(), "Reset counter to %d", counter_);
        response-&gt;success = true;
        response-&gt;message = "Success";
    }
}</pre>			<p class="calibre3">In the <a id="_idIndexMarker383" class="pcalibre calibre4 pcalibre1"/>callback, we receive two arguments—the request and the response. Both are <strong class="source-inline1">const</strong> shared pointers.</p>
			<p class="calibre3">What we do in this callback is the same as for Python. The biggest difference here is that we don’t return anything (in Python, we had to return the response) as the return type for the callback is <strong class="source-inline1">void</strong>.</p>
			<p class="calibre3">Now, we can build the package to compile and install the node. However, before we run <strong class="source-inline1">colcon build</strong>, we have to modify the <strong class="source-inline1">CMakeLists.txt</strong> file of the <strong class="source-inline1">my_cpp_pkg</strong> package. Since we have a new dependency on <strong class="source-inline1">my_robot_interfaces</strong>, we need to link the <strong class="source-inline1">number_counter</strong> executable with that dependency.</p>
			<p class="calibre3">First, add a line under all the <strong class="source-inline1">find_package()</strong> lines:</p>
			<pre class="source-code">
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(example_interfaces REQUIRED)
<strong class="bold1">find_package(my_robot_interfaces REQUIRED)</strong></pre>			<p class="calibre3">Then, add <strong class="source-inline1">my_robot_interfaces</strong> to the <strong class="source-inline1">ament_target_dependencies()</strong> function, for the <strong class="source-inline1">number_counter</strong> executable:</p>
			<pre class="source-code">
add_executable(number_counter src/number_counter.cpp)
ament_target_dependencies(number_counter rclcpp example_interfaces <strong class="bold1">my_robot_interfaces</strong>)</pre>			<p class="calibre3">For every <a id="_idIndexMarker384" class="pcalibre calibre4 pcalibre1"/>new dependency you’re using in this executable, you will have to link to it before you build.</p>
			<p class="calibre3">If you forget about this, then you will get this kind of error when you run <strong class="source-inline1">colcon build</strong>:</p>
			<pre class="console">
fatal error: my_robot_interfaces/srv/reset_counter.hpp: No such file or directory
Failed   &lt;&lt;&lt; my_cpp_pkg [1.49s, exited with code 2]</pre>			<p class="calibre3">Now you can build the C++ package, source, and run the <strong class="source-inline1">number_counter</strong> node.</p>
			<pre class="console">
$ ros2 run my_cpp_pkg number_counter
[INFO] [1712726520.316615636] [number_counter]: Number Counter has been started.</pre>			<p class="calibre3">We are now at the same point as when we finished the Python service server. The next step is to try the service server. To d<a id="_idTextAnchor310" class="pcalibre calibre4 pcalibre1"/>o that, we need a service client.</p>
			<h1 id="_idParaDest-151" class="calibre6"><a id="_idTextAnchor311" class="pcalibre calibre4 pcalibre1"/>Writing a service client</h1>
			<p class="calibre3">For service <a id="_idIndexMarker385" class="pcalibre calibre4 pcalibre1"/>communication to work, you need a service server and a service client. As a reminder, you can only have one service server but multiple clients.</p>
			<p class="calibre3">So far, we’ve finished our service server inside the <strong class="source-inline1">number_counter</strong> node. Now, let’s create a service client inside another node so that you can try the service.</p>
			<p class="calibre3">Where will you write the code for the client? In a real application, you will create a service client in a node that needs to call the service. In terms of the battery and LED example from the beginning of this chapter, the LED panel node contains a service server. The battery node, which is responsible for monitoring the battery state, contains a service client that can send some requests to the server.</p>
			<p class="calibre3">Then, when to send a request depends on the application. With the previous example, we decided that when the battery gets full or empty, we use the service client inside the node to send a request to the server so that we can turn an LED on/off.</p>
			<p class="calibre3">To keep things <a id="_idIndexMarker386" class="pcalibre calibre4 pcalibre1"/>simple for now, we will create a new node named <strong class="source-inline1">reset_counter_client</strong>. This node will only do one thing: send a request to the service server and get the response. With this, we will be able to focus only on writing the service client. As usual, we’ll start with Python<a id="_idTextAnchor312" class="pcalibre calibre4 pcalibre1"/> and then see the C++ code as well.</p>
			<h2 id="_idParaDest-152" class="calibre6"><a id="_idTextAnchor313" class="pcalibre calibre4 pcalibre1"/>Writing a Python service client</h2>
			<p class="calibre3">Create a new file, named <strong class="source-inline1">reset_counter_client.py</strong>, inside the <strong class="source-inline1">my_py_pkg</strong> package. Make <a id="_idIndexMarker387" class="pcalibre calibre4 pcalibre1"/>this file executable. The file should be placed with all the other Python files you created previously.</p>
			<p class="calibre3">Open the file and start by importing the interface:</p>
			<pre class="source-code">
from my_robot_interfaces.srv import ResetCounter</pre>			<p class="calibre3">In the node’s constructor, create a service client:</p>
			<pre class="source-code">
def __init__(self):
    super().__init__("reset_counter_client")
    self.client_ = self.create_client(ResetCounter, "reset_counter")</pre>			<p class="calibre3">To create a service client, we use the <strong class="source-inline1">create_client()</strong> method from the <strong class="source-inline1">Node</strong> class. We need to provide the service interface and service name. Make sure you use the same name and interface you defined in the server.</p>
			<p class="calibre3">Then, to call the service, we create a new method:</p>
			<pre class="source-code">
def call_reset_counter(self, value):
    while not self.client_.wait_for_service(1.0):
        self.get_logger().warn("Waiting for service...")
    request = ResetCounter.Request()
    request.reset_value = value
    future = self.client_.call_async(request)
    future.add_done_callback(
        self.callback_reset_counter_response)</pre>			<p class="calibre3">Here are the steps to make a service call:</p>
			<ol class="calibre11">
				<li class="calibre10">Make sure <a id="_idIndexMarker388" class="pcalibre calibre4 pcalibre1"/>the service is up and running with <code>wait_for_service()</code>. This function will return <code>True</code> as soon as the service has been found, or return <code>False</code> after the provided timeout, which is <code>1.0</code> seconds here.</li>
				<li class="calibre10">Create a request object from the service interface.</li>
				<li class="calibre10">Fill in the request fields.</li>
				<li class="calibre10">Send the request with <code>call_async()</code>. This will give you a Python <code>Future</code> object.</li>
				<li class="calibre10">Register a callback for when the node receives the response from the server.</li>
			</ol>
			<p class="calibre3">To process the response from the service, add a callback method:</p>
			<pre class="source-code">
def callback_reset_counter_response(self, future):
    response = future.result()
    self.get_logger().info("Success flag: " + str(response.success))
    self.get_logger().info("Message: " + str(response.message))</pre>			<p class="calibre3">In the callback, we get the response with <strong class="source-inline1">future.result()</strong>, and we can access each field of the response. In this example, we simply print the response with a log.</p>
			<p class="calibre3">So, what’s going to happen? After you send the request with <strong class="source-inline1">call_async()</strong>, the server will receive and process the request. Upon completion of the task, the server will return a response to the node where the client is. When the client node receives the response, it will process it in the callback that you’ve written.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You might be wondering, why do we need a callback? Why can’t we just wait for the response in the same method where we send the request? That’s because if you block this method (or in other words, this thread), then the node won’t be able to spin. If the spin is blocked, then any response you get for this node won’t be processed, and you have what is called a deadlock.</p>
			<p class="calibre3">The only thing left to do is call the <strong class="source-inline1">call_reset_counter()</strong> method. If we don’t call it, nothing <a id="_idIndexMarker389" class="pcalibre calibre4 pcalibre1"/>will happen. In a real application, you would call this method whenever you need it (it could be from a timer callback, a subscriber callback, and so on). Here, to make a test, we just call the method after creating the node, and before spinning, in the <strong class="source-inline1">main()</strong> function:</p>
			<pre class="source-code">
node = ResetCounterClientNode()
node.call_reset_counter(20)
rclpy.spin(node)</pre>			<p class="calibre3">The service client will send a request and register a callback for the response. After that, the <strong class="source-inline1">call_reset_counter()</strong> method exits, and the node starts to spin.</p>
			<p class="calibre3">That’s it for the code. You can use this structure for the client (one method to send the request and one callback to process the response) in any other node.</p>
			<p class="calibre3">Now, let’s<a id="_idTextAnchor314" class="pcalibre calibre4 pcalibre1"/> test the client/server communication.</p>
			<h2 id="_idParaDest-153" class="calibre6"><a id="_idTextAnchor315" class="pcalibre calibre4 pcalibre1"/>Running the client and server nodes together</h2>
			<p class="calibre3">Create an <a id="_idIndexMarker390" class="pcalibre calibre4 pcalibre1"/>executable in the <strong class="source-inline1">setup.py</strong> file named <strong class="source-inline1">reset_counter_client</strong>, for example.</p>
			<p class="calibre3">Then, build the workspace and open three Terminals. In Terminals 1 and 2, start <strong class="source-inline1">number_publisher</strong> and <strong class="source-inline1">number_counter</strong>. The latter will start the <strong class="source-inline1">reset_counter</strong> service server.</p>
			<p class="calibre3">In Terminal 3, start the <strong class="source-inline1">reset_counter_client</strong> node. Since we want to reset the counter to 20, if the counter inside the <strong class="source-inline1">number_counter</strong> node is less than 20 at the moment of sending the request, you will get the following response:</p>
			<pre class="console">
$ ros2 run my_py_pkg reset_counter_client
[INFO] [1713082991.940407360] [reset_counter_client]: Success flag: False
[INFO] [1713082991.940899261] [reset_counter_client]: Message: Reset value must be lower than current counter value</pre>			<p class="calibre3">If the counter is 20 or more, you will get the following response instead:</p>
			<pre class="console">
$ ros2 run my_py_pkg reset_counter_client
[INFO] [1713082968.101789868] [reset_counter_client]: Success flag: True
[INFO] [1713082968.102277613] [reset_counter_client]: Message: Success</pre>			<p class="calibre3">Also, just after <a id="_idIndexMarker391" class="pcalibre calibre4 pcalibre1"/>you start the node, the client sometimes needs a bit of time to find the service. In this case, you might see this log as well:</p>
			<pre class="console">
[WARN] [1713082991.437932627] [reset_counter_client]: Waiting for service...</pre>			<p class="calibre3">On the server side (the <strong class="source-inline1">number_counter</strong> node), if the counter is being reset, you will see this log:</p>
			<pre class="console">
[INFO] [1713083108.125753986] [number_counter]: Reset counter to 20</pre>			<p class="calibre3">With that, we have tested two cases: when the counter is less than the requested reset value and when the counter is more than the requested reset value. If you want, you can also test the third case: when the requested reset value is lower than 0.</p>
			<p class="calibre3">Now that we’ve finalized the client/server communication bet<a id="_idTextAnchor316" class="pcalibre calibre4 pcalibre1"/>ween the two nodes, let’s switch to C++.</p>
			<h2 id="_idParaDest-154" class="calibre6"><a id="_idTextAnchor317" class="pcalibre calibre4 pcalibre1"/>Writing a C++ service client</h2>
			<p class="calibre3">The C++ <a id="_idIndexMarker392" class="pcalibre calibre4 pcalibre1"/>code follows the same logic as the Python code.</p>
			<p class="calibre3">First, we include the interface:</p>
			<pre class="source-code">
#include "my_robot_interfaces/srv/reset_counter.hpp"</pre>			<p class="calibre3">Then, we add a few <strong class="source-inline1">using</strong> lines to reduce the code later:</p>
			<pre class="source-code">
using ResetCounter = my_robot_interfaces::srv::ResetCounter;
using namespace std::chrono_literals;
using namespace std::placeholders;</pre>			<p class="calibre3">Next, we declare the service client as a private attribute in the class:</p>
			<pre class="source-code">
rclcpp::Client&lt;ResetCounter&gt;::SharedPtr client_;</pre>			<p class="calibre3">After, we initialize <a id="_idIndexMarker393" class="pcalibre calibre4 pcalibre1"/>the client in the constructor:</p>
			<pre class="source-code">
ResetCounterClientNode() : Node("reset_counter_client")
{
    client_ = this-&gt;create_client&lt;ResetCounter&gt;("reset_counter");
}</pre>			<p class="calibre3">Then, as we did for Python, we add a method to call the service:</p>
			<pre class="source-code">
void callResetCounter(int value)
{
    while (!client_-&gt;wait_for_service(1s)) {
        RCLCPP_WARN(this-&gt;get_logger(), "Waiting for the server...");
    }
    auto request = std::make_shared&lt;ResetCounter::Request&gt;();
    request-&gt;reset_value = value;
    client_-&gt;async_send_request(request, std::bind(&amp;ResetCounterClientNode::callbackResetCounterResponse, this, _1));
}</pre>			<p class="calibre3">In this method, we wait for the service (don’t forget the exclamation mark in front of <strong class="source-inline1">client-&gt;wait_for_service(1s)</strong>), create a request, fill in the request, and send it with <strong class="source-inline1">async_send_request()</strong>. We pass the callback method as an argument, which will register the callback when the node is spinning.</p>
			<p class="calibre3">Here’s the <a id="_idIndexMarker394" class="pcalibre calibre4 pcalibre1"/>callback method for the response:</p>
			<pre class="source-code">
void callbackResetCounterResponse(
    rclcpp::Client&lt;ResetCounter&gt;::SharedFuture future)
{
    auto response = future.get();
    RCLCPP_INFO(this-&gt;get_logger(), "Success flag: %d, Message: %s", (int)response-&gt;success, response-&gt;message.c_str());
}</pre>			<p class="calibre3">Finally, to be able to send a request, we call the <strong class="source-inline1">callResetCounter()</strong> method just after creating the node, and before spinning:</p>
			<pre class="source-code">
auto node = std::make_shared&lt;ResetCounterClientNode&gt;();
node-&gt;callResetCounter(20);
rclcpp::spin(node);</pre>			<p class="calibre3">Now, create a new executable in <strong class="source-inline1">CMakeLists.txt</strong>. Build the package, open a few Terminals, and start the <strong class="source-inline1">number_publisher</strong> and <strong class="source-inline1">number_counter</strong> nodes. Then, start the <strong class="source-inline1">reset_counter_client</strong> node to try the service communication.</p>
			<p class="calibre3">Now that you’ve written the code for both the service server and client, let’s explore what you can do with the ROS 2 tools. For services with a simple interface, you will be able to test them directly from the Terminal,<a id="_idTextAnchor318" class="pcalibre calibre4 pcalibre1"/> even before writing the code for a client.</p>
			<h1 id="_idParaDest-155" class="calibre6"><a id="_idTextAnchor319" class="pcalibre calibre4 pcalibre1"/>Additional tools to handle services</h1>
			<p class="calibre3">We’ve already <a id="_idIndexMarker395" class="pcalibre calibre4 pcalibre1"/>used the <strong class="source-inline1">ros2</strong> command-line tool a lot in this book. With this tool, each core ROS 2 concept gets additional functionalities in the Terminal. This is no exception for services.</p>
			<p class="calibre3">We’re now going to explore <strong class="source-inline1">ros2 service</strong> a bit more so that we can introspect services and send a request from the Terminal. We will also learn how to change a service name at runtime (<strong class="source-inline1">ros2 run</strong>).</p>
			<p class="calibre3">To see all comman<a id="_idTextAnchor320" class="pcalibre calibre4 pcalibre1"/>ds for ROS 2 services, type <strong class="source-inline1">ros2 </strong><strong class="source-inline1">service -h</strong>.</p>
			<h2 id="_idParaDest-156" class="calibre6"><a id="_idTextAnchor321" class="pcalibre calibre4 pcalibre1"/>Listing and introspecting services</h2>
			<p class="calibre3">First, <strong class="source-inline1">rqt_graph</strong> does not <a id="_idIndexMarker396" class="pcalibre calibre4 pcalibre1"/>support services (yet—there are plans to maybe add this in a future ROS 2 distribution), so we won’t <a id="_idIndexMarker397" class="pcalibre calibre4 pcalibre1"/>use it here. We will only use the <strong class="source-inline1">ros2</strong> command-line tool.</p>
			<p class="calibre3">Stop all nodes and start the <strong class="source-inline1">number_counter</strong> node. Then, to list all services, run the following command:</p>
			<pre class="console">
$ ros2 service list
/number_counter/describe_parameters
/number_counter/get_parameter_types
/number_counter/get_parameters
/number_publisher/get_type_description
/number_counter/list_parameters
/number_counter/set_parameters
/number_counter/set_parameters_atomically
/reset_counter</pre>			<p class="calibre3">For each node you start, you will get seven additional services, mostly related to parameters. You can ignore those. If you look at the list, apart from those seven services, we can retrieve our <strong class="source-inline1">/</strong><strong class="source-inline1">reset_counter</strong> service.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Note that there is an additional leading slash in front of the service name. Service names follow the same rules as nodes and topics. If you don’t provide any namespace (for example, <code>/abc/reset_counter</code>), you’re in the “global” namespace, and a slash is added at the beginning.</p>
			<p class="calibre3">Once you have the service name you want, you can get the service interface with <strong class="source-inline1">ros2 service </strong><strong class="source-inline1">type &lt;service_name&gt;</strong>:</p>
			<pre class="console">
$ ros2 service type /reset_counter
my_robot_interfaces/srv/ResetCounter</pre>			<p class="calibre3">From this, you <a id="_idIndexMarker398" class="pcalibre calibre4 pcalibre1"/>can see the details inside the interface:</p>
			<pre class="console">
$ ros2 interface show my_robot_interfaces/srv/ResetCounter
int64 reset_value
---
bool success
string message</pre>			<p class="calibre3">This process <a id="_idIndexMarker399" class="pcalibre calibre4 pcalibre1"/>is extremely useful when you need to create a service client for an existing server. There’s no need to even read the server code—you can get<a id="_idTextAnchor322" class="pcalibre calibre4 pcalibre1"/> all the information you need from the Terminal.</p>
			<h2 id="_idParaDest-157" class="calibre6"><a id="_idTextAnchor323" class="pcalibre calibre4 pcalibre1"/>Sending a service request</h2>
			<p class="calibre3">To test a service server, you usually have to write a service client.</p>
			<p class="calibre3">Good news: instead <a id="_idIndexMarker400" class="pcalibre calibre4 pcalibre1"/>of writing a client, you can call the service from the Terminal directly. This can save you some development time.</p>
			<p class="calibre3">First, you must know the service name and interface. Then, use the <strong class="source-inline1">ros2 call &lt;service_name&gt; &lt;interface_name&gt; "&lt;request_in_json&gt;"</strong> command. Let’s try this with our <strong class="source-inline1">reset_counter</strong> service:</p>
			<pre class="console">
$ ros2 service call /reset_counter \ my_robot_interfaces/srv/ResetCounter {reset_value: 7}"
waiting for service to become available...
requester: making request: my_robot_interfaces.srv.ResetCounter_Request(reset_value=7)
response:
my_robot_interfaces.srv.ResetCounter_Response(success=True, message='Success')</pre>			<p class="calibre3">You can see the request being sent, followed by the response. Then, the command exits. This is practical and in this case, we save a lot of time.</p>
			<p class="calibre3">We can <a id="_idIndexMarker401" class="pcalibre calibre4 pcalibre1"/>also easily test the different cases. For example, let’s send a negative value for the reset number:</p>
			<pre class="console">
$ ros2 service call /reset_counter \my_robot_interfaces/srv/ResetCounter "{reset_value: -7}"
waiting for service to become available...
requester: making request: my_robot_interfaces.srv.ResetCounter_Request(reset_value=-7)
response:
my_robot_interfaces.srv.ResetCounter_Response(success=False, message='Cannot reset counter to a negative value')</pre>			<p class="calibre3">With this example, it’s quite easy as the request is very simple (only one integer number). For more complex service requests that contain lots of nested fields and arrays, writing the full request in the Terminal can become quite cumbersome, and you will spend a lot of time trying to get it right.</p>
			<p class="calibre3">So, for simple interfaces, use <strong class="source-inline1">ros2 service call</strong> to try the service first. For more complex interfaces, you’ll have to write a client code first. This isn’t really a problem: you can use the code we used for <strong class="source-inline1">ResetCounterClientNode</strong> as a template for any other client. In the end, both methods<a id="_idTextAnchor324" class="pcalibre calibre4 pcalibre1"/> allow you to test a service server quite quickly.</p>
			<h2 id="_idParaDest-158" class="calibre6"><a id="_idTextAnchor325" class="pcalibre calibre4 pcalibre1"/>Changing a service name at runtime</h2>
			<p class="calibre3">When <a id="_idIndexMarker402" class="pcalibre calibre4 pcalibre1"/>you start a node with <strong class="source-inline1">ros2 run</strong>, you can change the node name and any topic name inside the node. You can do the same for services.</p>
			<p class="calibre3">As a reminder, for any additional argument you pass after <strong class="source-inline1">ros2 run</strong>, add <strong class="source-inline1">--ros-args</strong>, but only once.</p>
			<p class="calibre3">Then, to rename a service, add <strong class="source-inline1">-r</strong> followed by <strong class="source-inline1">&lt;service_name&gt;:=&lt;new_service_name&gt;</strong>.</p>
			<p class="calibre3">For example, let’s rename the <strong class="source-inline1">reset_counter</strong> service to <strong class="source-inline1">reset_counter1</strong> when we start the <strong class="source-inline1">number_counter</strong> node:</p>
			<pre class="console">
$ ros2 run my_py_pkg number_counter --ros-args -r \ reset_counter:=reset_counter1</pre>			<p class="calibre3">Now, let’s verify this with <strong class="source-inline1">ros2 </strong><strong class="source-inline1">service list</strong>:</p>
			<pre class="console">
$ ros2 service list
# Some other services
/reset_counter1</pre>			<p class="calibre3">The service name is now <strong class="source-inline1">/reset_counter1</strong>. If we start a node with a service client, we need to modify the name as well; otherwise, the nodes won’t be able to communicate with each other:</p>
			<pre class="console">
$ ros2 run my_py_pkg reset_counter_client --ros-args -r \ reset_counter:=reset_counter1</pre>			<p class="calibre3">Doing this is quite useful, especially when you want to run several nodes (written by yourself or others) that use a slightly different service name, or that are in different namespaces.</p>
			<p class="calibre3">You are now able to write a service server/client and introspect/test them from the Terminal. Before moving on to the next chapter<a id="_idTextAnchor326" class="pcalibre calibre4 pcalibre1"/>, let’s practice more with an additional challenge.</p>
			<h1 id="_idParaDest-159" class="calibre6"><a id="_idTextAnchor327" class="pcalibre calibre4 pcalibre1"/>Service challenge – client and server</h1>
			<p class="calibre3">With this new challenge, you will practice everything that was covered in this chapter: custom service interfaces, service servers, and service clients.</p>
			<p class="calibre3">We will use the <strong class="source-inline1">turtle_controller</strong> node we wrote in the previous chapter’s challenge as a starting point. We won’t create a new node here; instead, we will improve the existing code. You can either start from the code you wrote or from the code I provided in the <strong class="source-inline1">ch5</strong> folder of this book’s GitHub repository.</p>
			<p class="calibre3">As always, I will explain what you need to do to complete the challenge, and then detail the most important points for the Python solution. You can find the comple<a id="_idTextAnchor328" class="pcalibre calibre4 pcalibre1"/>te solution code on GitHub for both Python and C++.</p>
			<h2 id="_idParaDest-160" class="calibre6"><a id="_idTextAnchor329" class="pcalibre calibre4 pcalibre1"/>Challenge</h2>
			<p class="calibre3">This challenge is divided<a id="_idTextAnchor330" class="pcalibre calibre4 pcalibre1"/> into two parts. I suggest following them in order.</p>
			<h3 class="calibre8">Challenge 1 – service client</h3>
			<p class="calibre3">So far, our <strong class="source-inline1">turtle_controller</strong> node is subscribing to the <strong class="source-inline1">/turtle1/pose</strong> topic. In the <a id="_idIndexMarker403" class="pcalibre calibre4 pcalibre1"/>subscriber callback, we send a velocity command to the <strong class="source-inline1">/</strong><strong class="source-inline1">turtle1/cmd_vel</strong> topic.</p>
			<p class="calibre3">The result of this is the turtle drawing a circle on the screen, with a different velocity depending on if it is on the right or left of the screen.</p>
			<p class="calibre3">What we want to do now is change the color of the pen, depending on where the turtle is. If the turtle is on the right of the screen, we want the pen color to be red. On the left, the color should be green.</p>
			<p class="calibre3">To do that, we will need to add a service client in the node so that we can call the service to change the pen’s color in the <strong class="source-inline1">turtlesim</strong> node (I won’t give you the service name—that’s part of the challenge).</p>
			<p class="calibre3">Here are the steps you can take to get started:</p>
			<ol class="calibre11">
				<li class="calibre10">Start the <code>turtlesim</code> node and use the <code>ros2 service</code> command line to find which service to call, as well as what interface to import (optional: at that point, you can also test the service with <code>ros2 service call</code>, directly from the Terminal).</li>
				<li class="calibre10">In the <code>turtle_controller</code> node, add a service client for that service.</li>
				<li class="calibre10">Create a method that will call the service.</li>
				<li class="calibre10">Call this <a id="_idIndexMarker404" class="pcalibre calibre4 pcalibre1"/>method from the existing subscriber callback. After you publish the new command velocity, check whether the turtle is on the right or left of the screen. When the turtle switches to a dif<a id="_idTextAnchor331" class="pcalibre calibre4 pcalibre1"/>ferent side, call the service with the updated color.</li>
			</ol>
			<h3 class="calibre8">Challenge 2 – custom interface and service server</h3>
			<p class="calibre3">Once you’re <a id="_idIndexMarker405" class="pcalibre calibre4 pcalibre1"/>done with the first challenge, try this one. This time, you’ll practice on the server side of services.</p>
			<p class="calibre3">Here, we want <a id="_idIndexMarker406" class="pcalibre calibre4 pcalibre1"/>to allow the <strong class="source-inline1">turtle_controller</strong> node to activate or deactivate the turtle (meaning to start or stop the turtle), depending on an external request. For that, we will create a service server.</p>
			<p class="calibre3">Here are the steps you can take to get started:</p>
			<ol class="calibre11">
				<li class="calibre10">Define a service name and interface for that service.</li>
				<li class="calibre10">If no existing interface matches your needs, you will need to create and build a new one (hint: that’s what we will do here).</li>
				<li class="calibre10">In the <code>turtle_controller</code> node, add a service server and a callback, in which you activate or deactivate the turtle. Tip: you can use a simple boolean attribute in the class to store the activated state for the turtle.</li>
				<li class="calibre10">If the turtle is activated, then in the subscriber callback, you can keep sending additional velocity commands. If it is not activated, you don’t send any commands.</li>
			</ol>
			<p class="calibre3">With those instructions, you should be able to get started. Taking the time to do this exercise is probabl<a id="_idTextAnchor332" class="pcalibre calibre4 pcalibre1"/>y the best investment you can make to learn ROS<a id="_idTextAnchor333" class="pcalibre calibre4 pcalibre1"/> faster.</p>
			<h2 id="_idParaDest-161" class="calibre6"><a id="_idTextAnchor334" class="pcalibre calibre4 pcalibre1"/>Solution</h2>
			<p class="calibre3">Let’s start with the first challenge.</p>
			<h3 class="calibre8">Challenge 1</h3>
			<p class="calibre3">For this challenge, we are on the client side, which means that we need to find out which service <a id="_idIndexMarker407" class="pcalibre calibre4 pcalibre1"/>we need to call. I will do a quick recap of the steps for finding the service name and interface.</p>
			<p class="calibre3">Start the <strong class="source-inline1">turtlesim</strong> node and list all services. You should see a <strong class="source-inline1">/turtle1/set_pen</strong> service with <strong class="source-inline1">ros2 </strong><strong class="source-inline1">service list</strong>.</p>
			<p class="calibre3">Now, get the type for this service and see what’s inside the interface:</p>
			<pre class="console">
$ ros2 service type /turtle1/set_pen
turtlesim/srv/SetPen
$ ros2 interface show turtlesim/srv/SetPen
uint8 r
uint8 g
uint8 b
uint8 width
uint8 off
---</pre>			<p class="calibre3">In the service request, we can send an (<strong class="source-inline1">r</strong>,<strong class="source-inline1">g</strong>,<strong class="source-inline1">b</strong>) value (red, green, blue). There are also <strong class="source-inline1">width</strong> and <strong class="source-inline1">off</strong> attributes, but we won’t use them.</p>
			<p class="calibre3">At this point, before you even write the code for the client, you can try the service from the Terminal:</p>
			<pre class="console">
$ ros2 service call /turtle1/set_pen turtlesim/srv/SetPen \ "{r: 255, g: 0, b: 0}"</pre>			<p class="calibre3">Then, execute <strong class="source-inline1">ros2 run turtlesim turtle_teleop_key</strong> and move the turtle around. You’ll see that the pen is now using a red color.</p>
			<p class="calibre3">Back to the code, inside the <strong class="source-inline1">turtle_controller.py</strong> file, import the interface:</p>
			<pre class="source-code">
from turtlesim.srv import SetPen</pre>			<p class="calibre3">Since we’ve already added the dependency for <strong class="source-inline1">turtlesim</strong> in the <strong class="source-inline1">package.xml</strong> file of the <strong class="source-inline1">turtle_controller</strong> package (in the previous chapter), there’s no need to do it again.</p>
			<p class="calibre3">Then, create the service client in the constructor:</p>
			<pre class="source-code">
self.set_pen_client_ = self.create_client(SetPen, "/turtle1/set_pen")</pre>			<p class="calibre3">Write the <a id="_idIndexMarker408" class="pcalibre calibre4 pcalibre1"/>method that will call the service, as well as the callback for the response:</p>
			<pre class="source-code">
def call_set_pen(self, r, g, b):
    while not self.set_pen_client_.wait_for_service(1.0):
        self.get_logger().warn("Waiting for service...")
    request = SetPen.Request()
    request.r = r
    request.g = g
    request.b = b
    future = self.set_pen_client_.call_async(request)
    future.add_done_callback(
self.callback_set_pen_response)
def callback_set_pen_response(self, future):
    self.get_logger().info("Successfully changed pen color")</pre>			<p class="calibre3">We only send the <strong class="source-inline1">r</strong>, <strong class="source-inline1">g</strong>, and <strong class="source-inline1">b</strong> parts of the request. The other values (<strong class="source-inline1">width</strong> and <strong class="source-inline1">off</strong>) will be kept as-is.</p>
			<p class="calibre3">As you can see, in the callback for the response, we don’t check what’s inside the response since the response is empty (it exists but it doesn’t contain a field).</p>
			<p class="calibre3">The only thing we need <a id="_idIndexMarker409" class="pcalibre calibre4 pcalibre1"/>to do now is call this new <strong class="source-inline1">call_set_pen()</strong> method. We will do that from within the subscriber callback since this is where we have access to the <em class="italic">X</em> position of the turtle.</p>
			<p class="calibre3">Inside <a id="_idIndexMarker410" class="pcalibre calibre4 pcalibre1"/>the <strong class="source-inline1">callback_pose()</strong> method, and after the code to publish on the topic, add the <a id="_idIndexMarker411" class="pcalibre calibre4 pcalibre1"/>code to handle the pen color:</p>
			<pre class="source-code">
if pose.x &gt; 5.5 and self.previous_x_ &lt;= 5.5:
    self.previous_x_ = pose.x
    self.get_logger().info("Set color to red.")
    self.call_set_pen(255, 0, 0)
elif pose.x &lt;= 5.5 and self.previous_x_ &gt; 5.5:
    self.previous_x_ = pose.x
    self.get_logger().info("Set color to green.")
    self.call_set_pen(0, 255, 0)</pre>			<p class="calibre3">If the turtle is on the right, we set the color to red (<strong class="source-inline1">255, 0, 0</strong>), and if it’s on the left, we set the color to green (<strong class="source-inline1">0, </strong><strong class="source-inline1">255, 0</strong>).</p>
			<p class="calibre3">On top of that, we also define a new attribute in the constructor so that we can keep track of the previous <em class="italic">X</em> coordinate:</p>
			<pre class="source-code">
self.previous_x_ = 0.0</pre>			<p class="calibre3">We use this to only call the service when the turtle switches from one side to the other. Why do we do that? We could send a service request every time, even if the color would be the same as the previous one. Why “optimize” the code?</p>
			<p class="calibre3">The reason is that the <strong class="source-inline1">callback_pose()</strong> method will be called a lot. Check the frequency for the <strong class="source-inline1">/turtle1/pose</strong> topic in the Terminal:</p>
			<pre class="console">
$ ros2 topic hz /turtle1/pose
average rate: 62.515</pre>			<p class="calibre3">This means that we execute <strong class="source-inline1">callback_pose()</strong> about 62 times per second. This is not really a problem. We also publish on the <strong class="source-inline1">/turtle1/cmd_vel</strong> topic at 62 Hz. Again, that’s not a problem. Publishers and subscribers can sustain a high frequency (with a bigger message size, this could become complicated, but here, the messages are really small).</p>
			<p class="calibre3">Now, what if we send a request to a service 62 times per second? This is where the problem is. Services are not made for high-frequency requests, and this could seriously affect the performance of the application. Also, if you find yourself having to call a service at 62 Hz, then you probably have a design problem, and you either need to modify your code to reduce the frequency or use a publish/subscribe mechanism instead.</p>
			<p class="calibre3">So, what we <a id="_idIndexMarker412" class="pcalibre calibre4 pcalibre1"/>do in the code is make sure we only call the service when it’s needed—that is, when the turtle switches from one side to the other.</p>
			<p class="calibre3">The code is now complete! At this point, you can build your <strong class="source-inline1">turtle_controller</strong> package again (unless you have already built it with <strong class="source-inline1">--symlink-install</strong>), source the environment, and then start both<a id="_idTextAnchor335" class="pcalibre calibre4 pcalibre1"/> the <strong class="source-inline1">turtlesim</strong> and <strong class="source-inline1">turtle_controller</strong> nodes to see the result.</p>
			<h3 class="calibre8">Challenge 2</h3>
			<p class="calibre3">Now, we want <a id="_idIndexMarker413" class="pcalibre calibre4 pcalibre1"/>to add a service server inside our node so that we can activate or deactivate the turtle. Since we’re defining the server, we need to come up with a name and an interface:</p>
			<ul class="calibre9">
				<li class="calibre10"><code>activate_turtle</code>. We’ll start with a verb and try to make the name as explicit as possible.</li>
				<li class="calibre10"><code>SetBool</code> service from <code>example_interfaces</code>. It contains a boolean in the request and a string in the response. However, as stated previously, the best practice is to avoid using the <code>std_srvs</code> and <code>example_interfaces</code> packages if your application is any serious. So, in this case, we’ll create our own interface.</li>
			</ul>
			<p class="calibre3">Let’s create a new interface for our service. This will be quite quick and easy as we already have the <strong class="source-inline1">my_robot_interfaces</strong> package fully configured.</p>
			<p class="calibre3">Inside the <strong class="source-inline1">srv</strong> folder of the <strong class="source-inline1">my_robot_interfaces</strong> package, create a new service file named <strong class="source-inline1">ActivateTurtle.srv</strong>. In this file, write the service definition:</p>
			<pre class="source-code">
bool activate
---
string message</pre>			<p class="calibre3">This is all we need in the request: a boolean to activate or deactivate the turtle. We also added a string in the response so that we get to know what happened, but you could also decide to have an empty response.</p>
			<p class="calibre3">After this, add the interface to the <strong class="source-inline1">CMakeLists.txt</strong> file of the <strong class="source-inline1">my_robot_interfaces</strong> package, and build the package. Source the environment, and make sure you can see the interface with:</p>
			<pre class="console">
ros2 interface show my_robot_interfaces/srv/ActivateTurtle</pre>			<p class="calibre3">Now, let’s go back to the <strong class="source-inline1">turtle_controller</strong> package.</p>
			<p class="calibre3">Since we will <a id="_idIndexMarker414" class="pcalibre calibre4 pcalibre1"/>have a dependency on <strong class="source-inline1">my_robot_interfaces</strong>, add a new line to the <strong class="source-inline1">package.xml</strong> file of the <strong class="source-inline1">turtle_controller</strong> package:</p>
			<pre class="source-code">
&lt;depend&gt;my_robot_interfaces&lt;/depend&gt;</pre>			<p class="calibre3">Now, it’s time to write the code inside <strong class="source-inline1">turtle_controller.py</strong>. Import the interface:</p>
			<pre class="source-code">
from my_robot_interfaces.srv import ActivateTurtle</pre>			<p class="calibre3">In the constructor, add a boolean flag to keep track of the activated status for the turtle, and create a new service server:</p>
			<pre class="source-code">
self.is_active_ = True
self.activate_turtle_service_ = self.create_service(ActivateTurtle, "activate_turtle", self.callback_activate_turtle)</pre>			<p class="calibre3">Implement the callback method for that service:</p>
			<pre class="source-code">
def callback_activate_turtle(self, request: ActivateTurtle.Request, response: ActivateTurtle.Response):
    self.is_active_ = request.activate
    if request.activate:
        response.message = "Starting the turtle"
    else:
        response.message = "Stopping the turtle"
    return response</pre>			<p class="calibre3">What we do is simple—we just set the <strong class="source-inline1">is_active_</strong> boolean with the value we get from the boolean in the request. Now, whenever you call this service, the <strong class="source-inline1">is_active_</strong> boolean will be updated with the value you send.</p>
			<p class="calibre3">The last step, to make the turtle start or stop when activated or deactivated, is to modify the <a id="_idIndexMarker415" class="pcalibre calibre4 pcalibre1"/>code inside the <strong class="source-inline1">callback_pose()</strong> method:</p>
			<pre class="source-code">
def callback_pose(self, pose: Pose):
    if self.is_active_:
        # Entire code for the callback, inside the "if"</pre>			<p class="calibre3">This way, we only publish a new command velocity if the turtle is activated. If not, we publish nothing. Also, the service request will only work when the turtle is activated.</p>
			<p class="calibre3">To try this new service, start the <strong class="source-inline1">turtlesim</strong> node and <strong class="source-inline1">turtle_controller</strong> nodes. In a third Terminal, send a service request with the <strong class="source-inline1">ros2</strong> command-line tool. Here’s an example:</p>
			<pre class="console">
$ ros2 service call /activate_turtle \
my_robot_interfaces/srv/ActivateTurtle "{activate: false}"</pre>			<p class="calibre3">This should make the turtle stop. You can send a request again, this time with <strong class="source-inline1">"{activate: true}"</strong>, which should make the turtle move again.</p>
			<p class="calibre3">That’s the end of this challenge on services. If you managed to finish this challenge by yourself, you have a good understanding of services. No worries if you couldn’t do it without having to look at the solution. Come back t<a id="_idTextAnchor336" class="pcalibre calibre4 pcalibre1"/>o it in a few days and see if you can solve the challenge again.</p>
			<h1 id="_idParaDest-162" class="calibre6"><a id="_idTextAnchor337" class="pcalibre calibre4 pcalibre1"/>Summary</h1>
			<p class="calibre3">In this chapter, you worked on ROS 2 services, which is another ROS 2 communication you can use alongside topics.</p>
			<p class="calibre3">With services, nodes can talk to each other using a client/server type of communication. Only one server can exist for a service, but you can send multiple requests from several clients.</p>
			<p class="calibre3">You can implement service servers and clients directly in your nodes using <strong class="source-inline1">rclpy</strong> for Python and <strong class="source-inline1">rclcpp</strong> for C++.</p>
			<p class="calibre3">To write a service server, you must do the following:</p>
			<ol class="calibre11">
				<li class="calibre10">As the name and interface are defined by the server, you have to choose them here. As a best practice, use a verb as the first word in the name.</li>
				<li class="calibre10">Import the interface in your code and create the service server in the constructor.</li>
				<li class="calibre10">Add a callback method to process any received request.</li>
			</ol>
			<p class="calibre3">When choosing a service interface, if you can’t find an existing one that perfectly matches what you need, then you have to create and build your own. To do that, you must do the following:</p>
			<ol class="calibre11">
				<li class="calibre10">Create and set up a package dedicated to interfaces. If you already have one for your application, use it.</li>
				<li class="calibre10">Add the new service interface to the package and build it.</li>
				<li class="calibre10">Now, you can use this interface in your service server.</li>
			</ol>
			<p class="calibre3">To write a service client, do the following:</p>
			<ol class="calibre11">
				<li class="calibre10">If you’re writing a client, it means that there is an existing server on the other side. Find which name and interface you need to use.</li>
				<li class="calibre10">Import the interface into your code and create the service client in the constructor.</li>
				<li class="calibre10">Create a method to call the service. In this method, you send the request asynchronously, and then register a callback to process the response.</li>
				<li class="calibre10">You can call the service from anywhere in your code.</li>
			</ol>
			<p class="calibre3">With the <strong class="source-inline1">ros2 service</strong> command line, you can introspect the services in your nodes and see what interface they’re using.</p>
			<p class="calibre3">To try a service server, you can either write a corresponding service client inside another node or, if the request is simple, call the service directly from the Terminal with <strong class="source-inline1">ros2 </strong><strong class="source-inline1">service call</strong>.</p>
			<p class="calibre3">You have now seen the two most common ROS 2 communication types: topics and services. In the next chapter, we will work with the third and last one: actions.</p>
		</div>
	</body></html>