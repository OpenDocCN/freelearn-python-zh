- en: '1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '1'
- en: Understanding Functional Programming
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 理解函数式编程
- en: Functional programming defines a computation using expressions and evaluation;
    often, they are encapsulated in function definitions. It de-emphasizes or avoids
    the complexity of state change and mutable objects. This tends to create programs
    that are more succinct and expressive. In this chapter, we’ll introduce some of
    the techniques that characterize functional programming. We’ll identify some of
    the ways to map these features to Python. Finally, we’ll also address some ways
    in which the benefits of functional programming accrue when we use these design
    patterns to build Python applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程使用表达式和评估来定义计算；通常，它们封装在函数定义中。它弱化或避免状态变化和可变对象的复杂性。这往往会产生更简洁、更易于表达的程序。在本章中，我们将介绍一些表征函数式编程的技术。我们将确定一些将这些特性映射到Python的方法。最后，我们还将讨论使用这些设计模式构建Python应用程序时，函数式编程的好处是如何积累的。
- en: This book doesn’t contain a tutorial introduction to the Python language. We
    assume the reader knows some Python. In many cases, if the reader knows a functional
    programming language, then that knowledge can be applied to Python via the examples
    in this book. For background information on Python, see Python in a Nutshell,
    4th Edition, or any of the Python introductions from Packt Publishing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书不包含Python语言的教程介绍。我们假设读者已经了解一些Python。在许多情况下，如果读者了解函数式编程语言，那么这些知识可以通过本书中的示例应用到Python上。有关Python的背景信息，请参阅《Python速查手册》第4版或Packt
    Publishing出版的任何Python入门书籍。
- en: Python has a broad variety of programming features, including numerous ways
    to support functional programming. As we will see throughout this book, Python
    is not a purely functional programming language; instead, it relies on a mixture
    of features. We’ll see that the language offers enough of the right kinds of features
    to provide the benefits of functional programming. It also retains all the optimization
    power of an imperative programming language. Further, we can mix the object-oriented
    and functional features to make use of the best aspects of both paradigms.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Python拥有广泛的编程特性，包括许多支持函数式编程的方法。正如我们将在本书中看到的那样，Python不是一种纯粹的函数式编程语言；相反，它依赖于一系列特性的混合。我们将看到，该语言提供了足够正确的特性来提供函数式编程的好处。它还保留了命令式编程语言的全部优化能力。此外，我们可以混合面向对象和函数式特性，以利用两种范例的最佳方面。
- en: We’ll also look at a problem domain that we’ll use for many of the examples
    in this book. We’ll try to stick closely to Exploratory Data Analysis (EDA). For
    more information, see [https://www.itl.nist.gov/div898/handbook/eda/eda.htm](https://www.itl.nist.gov/div898/handbook/eda/eda.htm).
    The idea of ”exploratory” means doing data collection followed by analysis, with
    a goal of inferring what model would be appropriate to describe the data. This
    is a helpful domain because many of the algorithms are good examples of functional
    programming. Furthermore, the benefits of functional programming accrue rapidly
    when exploring data to locate trends and relationships.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨一个我们将用于本书许多示例的问题域。我们将尽量紧密地遵循探索性数据分析（EDA）。有关更多信息，请参阅[https://www.itl.nist.gov/div898/handbook/eda/eda.htm](https://www.itl.nist.gov/div898/handbook/eda/eda.htm)。"探索"这一概念意味着在数据收集之后进行数据分析，目标是推断出描述数据的适当模型。这是一个有用的领域，因为许多算法都是函数式编程的良好示例。此外，在探索数据以定位趋势和关系时，函数式编程的好处会迅速积累。
- en: Our goal is to establish some essential principles of functional programming.
    The more serious Python code will begin in [Chapter 2](Chapter_02.xhtml#x1-340002),
    [Introducing Essential Functional Concepts](Chapter_02.xhtml#x1-340002).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是确立函数式编程的一些基本原理。更严肃的Python代码将从[第2章](Chapter_02.xhtml#x1-340002)，[介绍基本函数式概念](Chapter_02.xhtml#x1-340002)开始。
- en: 'In this chapter, we’ll focus on the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注以下主题：
- en: Comparing and contrasting the functional paradigm with other ways of designing
    software. We’ll look at how Python’s approach can be called a ”hybrid” between
    functional programming and object-oriented programming.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较和对比函数范式与其他软件设计方法。我们将探讨Python的方法如何被称为函数式编程和面向对象编程之间的“混合”。
- en: We’ll look in depth at a specific example extracted from the functional programming
    literature.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将深入探讨一个从函数式编程文献中提取的具体示例。
- en: We’ll conclude with an overview of EDA and why this discipline seems to provide
    numerous examples of functional programming.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将以EDA的概述和为什么这个学科似乎提供了许多函数式编程的示例作为结束。
- en: We’ll focus on Python 3.10 features in this book. This includes the new `match`
    statement.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将重点关注Python 3.10的特性。这包括新的`match`语句。
- en: Throughout this book, we’ll include Python 3 type hints in the examples. Type
    hints can help a reader visualize the essential purpose behind a function definition.
    Type hints are analyzed with the mypy tool. As with unit testing, mypy can be
    part of a tool chain to produce high-quality software.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们将在示例中包含Python 3类型提示。类型提示可以帮助读者可视化函数定义背后的基本目的。类型提示通过mypy工具进行分析。与单元测试一样，mypy可以是工具链的一部分，以产生高质量的软件。
- en: 1.1 The functional style of programming
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1 编程的函数式风格
- en: We’ll define functional programming through a series of examples. The distinguishing
    feature between these examples is the concept of state, specifically the state
    of the computation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一系列示例来定义函数式编程。这些示例之间的区别特征是状态的概念，特别是计算的状态。
- en: Python’s strong imperative traits mean that the state of a computation is defined
    by the values of the variables in the various namespaces. Some kinds of statements
    make a well-defined change to the state by adding, changing, or removing a variable.
    We call this imperative because specific kinds of statements change the state.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Python的强命令式特性意味着计算的状状态由各个命名空间中变量的值定义。某些类型的语句通过添加、更改或删除变量来对状态进行明确的更改。我们称之为命令式，因为特定类型的语句会改变状态。
- en: In Python, the assignment statement is the primary way to change the state.
    Python has other statements, such as `global` or `nonlocal`, which modify the
    rules for variables in a particular namespace. Statements such as `def`, `class`,
    and `import` change the processing context. The bulk of the remaining statements
    provide ways to choose which assignment statements get executed. The focus of
    all these various statement types, however, is on changing the state of the variables.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，赋值语句是改变状态的主要方式。Python还有其他语句，如`global`或`nonlocal`，它们修改特定命名空间中变量的规则。`def`、`class`和`import`等语句改变处理上下文。剩余的大部分语句提供了选择哪些赋值语句被执行的方法。然而，所有这些不同类型的语句的焦点都是改变变量的状态。
- en: In a functional language, we replace the state—the changing values of variables—with
    a simpler notion of evaluating functions. Each function evaluation creates a new
    object or objects from existing objects. Since a functional program is a composition
    of functions, we can design lower-level functions that are easy to understand,
    and then create compositions of functions that can also be easier to visualize
    than a complex sequence of statements.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式语言中，我们用评估函数的更简单概念来替换状态——变量的变化值。每次函数评估都从现有对象创建新的对象或对象。由于函数式程序是函数的组合，我们可以设计易于理解的底层函数，然后创建函数的组合，这些组合比复杂的语句序列更容易可视化。
- en: Function evaluation more closely parallels mathematical formalisms. Because
    of this, we can often use simple algebra to design an algorithm that clearly handles
    the edge cases and boundary conditions. This makes us more confident that the
    functions work. It also makes it easy to locate test cases for formal unit testing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 函数评估更接近数学形式化。正因为如此，我们通常可以使用简单的代数来设计一个算法，该算法可以清楚地处理边缘情况和边界条件。这使得我们更有信心函数是有效的。这也使得定位形式化单元测试的测试用例变得容易。
- en: It’s important to note that functional programs tend to be relatively succinct,
    expressive, and efficient compared to imperative (object-oriented or procedural)
    programs. The benefit isn’t automatic; it requires careful design. This design
    effort for functional programming is often smaller than for procedural programming.
    Some developers experienced in imperative and object-oriented styles may find
    it a challenge to shift their focus from stateful designs to functional designs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，与命令式（面向对象或过程式）程序相比，函数式程序通常相对简洁、表达性强且效率高。这种好处不是自动的；它需要仔细的设计。对于函数式编程的设计工作通常比过程式编程小。一些有命令式和面向对象风格经验的开发者可能发现，从有状态的设计转向函数式设计是一个挑战。
- en: 1.2 Comparing and contrasting procedural and functional styles
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2 比较和对比过程式和函数式风格
- en: We’ll use a tiny example program to illustrate a non-functional, or procedural,
    style of programming. This example computes a sum of a sequence of numbers. Each
    of the numbers has a specific property that makes it part of the sequence.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个小型示例程序来展示非函数式，或过程式，的编程风格。此示例计算一系列数字的总和。每个数字都有特定的属性，使其成为序列的一部分。
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The sum computed by this function includes only numbers that are multiples of
    3 or 5\. We’ve made this program strictly procedural, avoiding any explicit use
    of Python’s object features. The function’s state is defined by the values of
    the variables `s` and `n`. The variable `n` takes on values such that 1 ≤ n <
    10\. As the iteration involves an ordered exploration of values for the `n` variable,
    we can prove that it will terminate when the value of `n` is equal to the value
    of `limit`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数计算的总和只包括3或5的倍数。我们使这个程序严格遵循过程式，避免任何显式使用Python的对象特性。函数的状态由变量`s`和`n`的值定义。变量`n`取值范围为1
    ≤ n < 10。由于迭代涉及对`n`变量值的有序探索，我们可以证明当`n`的值等于`limit`的值时，迭代将终止。
- en: There are two explicit assignment statements, both setting values for the `s`
    variable. These state changes are visible. The value of `n` is set implicitly
    by the `for` statement. The state change in the `s` variable is an essential element
    of the state of the computation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个显式赋值语句，都用于设置`s`变量的值。这些状态变化是可见的。`n`的值由`for`语句隐式设置。`s`变量中的状态变化是计算状态的一个基本元素。
- en: Now let’s look at this again from a purely functional perspective. Then, we’ll
    examine a more Pythonic perspective that retains the essence of a functional approach
    while leveraging a number of Python’s features.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从纯粹的功能角度再次审视这个问题。然后，我们将从更Pythonic的角度来审视，它保留了函数式方法的核心，同时利用了Python的一些特性。
- en: 1.2.1 Using the functional paradigm
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.1 使用函数式范式
- en: 'In a functional sense, the sum of the multiples of 3 and 5 can be decomposed
    into two parts:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式意义上，3和5的倍数之和可以分解为两部分：
- en: The sum of a sequence of numbers
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字序列的总和
- en: A sequence of values that pass a simple test condition, for example, being multiples
    of 3 and 5
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列通过简单测试条件的值，例如，是3和5的倍数
- en: 'To be super formal, we can define the sum as a function using simpler language
    components. The sum of a sequence has a recursive definition:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了非常正式，我们可以使用更简单的语言组件定义总和作为一个函数。序列的总和有一个递归定义：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We’ve defined the sum in two cases. The base case states that the sum of a zero-length
    sequence is 0\. The recursive case states that the sum of a sequence is the first
    value plus the sum of the rest of the sequence. Since the recursive definition
    depends on a shorter sequence, we can be sure that it will (eventually) devolve
    to the base case.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在两种情况下定义了总和。基本案例指出，零长度序列的总和是0。递归案例指出，序列的总和是第一个值加上序列剩余部分的总和。由于递归定义依赖于较短的序列，我们可以确信它最终会退化到基本案例。
- en: 'Here are some examples of how this function works:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是此函数工作的一些示例：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first example computes the sum of a list with multiple items. The second
    example shows how the recursion rule works by adding the first item, `seq[0]`,
    to the sum of the remaining items, `sumr(seq[1:])`. Eventually, the computation
    of the result involves the sum of an empty list, which is defined as 0.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子计算了一个包含多个项目的列表的总和。第二个例子通过将第一个项目`seq[0]`加到剩余项目的总和`sumr(seq[1:])`来展示递归规则的工作方式。最终，结果的计算涉及到一个空列表的总和，它被定义为0。
- en: 'The `+` operator on the last line of the `sumr` function and the initial value
    of 0 in the base case characterize the equation as a sum. Consider what would
    happen if we changed the operator to `*` and the initial value to 1: this new
    expression would compute a product. We’ll return to this simple idea of generalization
    in the following chapters.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`sumr`函数最后一行的`+`运算符和基本案例中的初始值0将方程定义为总和。考虑如果我们把运算符改为`*`并将初始值改为1会发生什么：这个新表达式将计算乘积。我们将在接下来的章节中回到这个简单的泛化思想。'
- en: 'Similarly, generating a sequence of values with a given property can have a
    recursive definition, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，生成具有给定属性的值序列可以有一个递归定义，如下所示：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this function, we’ve compared a given value, `v`, against the upper bound,
    `limit`. If `v` has reached the upper bound, the resulting list must be empty.
    This is the base case for the given recursion.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们比较了给定的值`v`与上限`limit`。如果`v`达到了上限，那么结果列表必须是空的。这是给定递归的基本案例。
- en: There are two more cases defined by an externally defined `filter_func()` function.
    The value of `v` is passed by the `filter_func()` function; if this returns a
    very small list, containing one element, this can be concatenated with any remaining
    values computed by the `until()` function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个更多的情况是由一个外部定义的`filter_func()`函数定义的。`v`的值是通过`filter_func()`函数传递的；如果这个函数返回一个非常短的列表，包含一个元素，这个元素可以与`until()`函数计算出的任何剩余值连接起来。
- en: If the value of `v` is rejected by the `filter_func()` function, this value
    is ignored and the result is simply defined by any remaining values computed by
    the `until()` function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`v`的值被`filter_func()`函数拒绝，这个值将被忽略，结果简单地由`until()`函数计算出的任何剩余值定义。
- en: We can see that the value of `v` will increase from an initial value until it
    reaches `limit`, assuring us that we’ll reach the base case.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`v`的值将从初始值增加到`limit`，这确保我们将达到基本情况。
- en: 'Before we can see how to use the `until()` function, we’ll define a small function
    to filter values that are multiples of 3 or 5:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够看到如何使用`until()`函数之前，我们将定义一个小函数来过滤出3或5的倍数：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We could also have defined this as a lambda object to emphasize succinct definitions
    of simple functions. Anything more complex than a one-line expression requires
    the `def` statement.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将其定义为lambda对象，以强调简单函数的简洁定义。任何超过一行表达式的复杂度都需要`def`语句。
- en: 'This function can be combined with the `until()` function to generate a sequence
    of values, which are multiples of 3 and 5\. Here’s an example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以与`until()`函数结合生成一个值序列，这些值是3和5的倍数。以下是一个示例：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Looking back at the decomposition at the top of this section, we now have a
    way to compute sums and a way to compute the sequence of values.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾本节顶部的分解，我们现在有了一种计算总和的方法，也有了一种计算值序列的方法。
- en: 'We can combine the `sumr()` and `until()` functions to compute a sum of values.
    Here’s the resulting code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`sumr()`和`until()`函数结合起来计算值的总和。以下是生成的代码：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This small application to compute a sum doesn’t make use of the assignment statement
    to set the values of variables. It is a purely functional, recursive definition
    that matches the mathematical abstractions, making it easier to reason about.
    We can be confident each piece works separately, giving confidence in the whole.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用于计算总和的小程序没有使用赋值语句来设置变量的值。这是一个纯粹的函数式、递归定义，与数学抽象相匹配，这使得推理更容易。我们可以确信每个部分都能单独工作，从而对整体有信心。
- en: As a practical matter, we’ll use a number of Python features to simplify creating
    functional programs. We’ll take a look at a number of these optimizations in the
    next version of this example.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实际操作，我们将使用许多Python特性来简化创建函数式程序。我们将在本例的下一个版本中查看这些优化的一些例子。
- en: 1.2.2 Using a functional hybrid
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.2 使用函数式混合
- en: 'We’ll continue this example with a mostly functional version of the previous
    example to compute the sum of multiples of 3 and 5\. Our hybrid functional version
    might look like the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用前一个例子的一个主要函数式版本来计算3和5的倍数的和。我们的混合函数式版本可能看起来像以下这样：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We’ve used a generator expression to iterate through a collection of values
    and compute the sum of these values. The `range(1,`` 10)` object is an iterable;
    it generates a sequence of values {n∣1 ≤ n < 10}, often summarized as “values
    of n such that 1 is less than or equal to n and n is less than 10.” The more complex
    expression `n`` for`` n`` in`` range(1,`` 10)`` if`` n`` %`` 3`` ==`` 0`` or`` n`
    `%`` 5`` ==`` 0` is also a generator. It produces a set of values, {n∣1 ≤ n <
    10 ∧ (n ≡ 0 mod 3 ∨n ≡ 0 mod 5)}; something we can describe as “values of n such
    that 1 is less than or equal to n and n is less than 10 and n is equivalent to
    0 modulo 3 or n is equivalent to 0 modulo 5.” These are multiples of 3 and 5 taken
    from the set of values between 1 and 10\. The variable `n` is bound, in turn,
    to each of the values provided by the `range` object. The `sum()` function consumes
    the iterable values, creating a final object, 23.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用生成器表达式遍历值集合并计算这些值的总和。`range(1, 10)`对象是一个可迭代对象；它生成一个值序列{n∣1 ≤ n < 10}，通常总结为“n的值，其中1小于或等于n且n小于10。”更复杂的表达式`n
    for n in range(1, 10) if n % 3 == 0 or n % 5 == 0`也是一个生成器。它生成一组值，{n∣1 ≤ n < 10
    ∧ (n ≡ 0 mod 3 ∨ n ≡ 0 mod 5)}；我们可以描述为“n的值，其中1小于或等于n且n小于10，且n与3同余0或n与5同余0。”这些是从1到10的集合中取出的3和5的倍数。变量`n`依次绑定到`range`对象提供的每个值。`sum()`函数消耗可迭代的值，创建一个最终对象，23。
- en: The bound variable, `n`, doesn’t exist outside the generator expression. The
    variable `n` isn’t visible elsewhere in the program.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定的变量`n`在生成器表达式之外不存在。变量`n`在程序的其他地方是不可见的。
- en: 'The variable `n` in this example isn’t directly comparable to the variable
    `n` in the first two imperative examples. A `for` statement (outside a generator
    expression) creates a proper variable in the local namespace. The generator expression
    does not create a variable in the same way that a `for` statement does:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，变量`n`与前面两个命令式示例中的变量`n`并不直接可比。一个`for`语句（在生成器表达式之外）在局部命名空间中创建了一个正确的变量。生成器表达式不会以与`for`语句相同的方式创建变量：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The generator expression doesn’t pollute the namespace with variables, like
    `n`, which aren’t relevant outside the very narrow context of the expression.
    This is a pleasant feature that ensures we won’t be confused by the values of
    variables that don’t have a meaning outside a single expression.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式不会像变量`n`那样污染命名空间，因为`n`在表达式的非常狭窄的上下文中之外没有相关性。这是一个令人愉快的特性，确保我们不会因为那些在单个表达式之外没有意义的变量的值而感到困惑。
- en: 1.2.3 The stack of turtles
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.3 乌龟堆栈
- en: When we use Python for functional programming, we embark down a path that will
    involve a hybrid that’s not strictly functional. Python is not Haskell, OCaml,
    or Erlang. For that matter, our underlying processor hardware is not functional;
    it’s not even strictly object-oriented, as CPUs are generally procedural.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用Python进行函数式编程时，我们将踏上一条涉及非严格函数式混合的道路。Python不是Haskell、OCaml或Erlang。就底层处理器硬件而言，它也不是函数式的；它甚至不是严格面向对象的，因为CPU通常是过程式的。
- en: '*All programming languages rest on abstractions, libraries, frameworks and
    virtual machines. These abstractions, in turn, may rely on other abstractions,
    libraries, frameworks and virtual machines. The most apt metaphor is this: the
    world is carried on the back of a giant turtle. The turtle stands on the back
    of another giant turtle. And that turtle, in turn, is standing on the back of
    yet another turtle.*'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*所有编程语言都建立在抽象、库、框架和虚拟机之上。这些抽象反过来可能依赖于其他抽象、库、框架和虚拟机。最恰当的隐喻是这样的：世界是建立在一只巨大的乌龟背上的。这只乌龟站在另一只巨大的乌龟背上。而这只乌龟，又站在另一只乌龟的背上.*'
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*It’s turtles all the way down.*'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*一切皆由乌龟组成。*'
- en: ''
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*— Anonymous*'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*—— 匿名*'
- en: There’s no practical end to the layers of abstractions. Even something as concrete
    as circuits and electronics may be an abstraction to help designers summarize
    the details of quantum electrodynamics.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 层层抽象没有实际的上限。即使是像电路和电子这样的具体事物，也可能是为了帮助设计者总结量子电动力学的细节而进行的抽象。
- en: More importantly, the presence of abstractions and virtual machines doesn’t
    materially change our approach to designing software to exploit the functional
    programming features of Python.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，抽象和虚拟机的存在并没有实质性地改变我们设计软件以利用Python函数式编程特性的方法。
- en: Even within the functional programming community, there are both purer and less
    pure functional programming languages. Some languages make extensive use of monads
    to handle stateful things such as file system input and output. Other languages
    rely on a hybridized environment that’s similar to the way we use Python. In Python,
    software can be generally functional, with carefully chosen procedural exceptions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在函数式编程社区内部，也存在更纯粹和不太纯粹的函数式编程语言。有些语言广泛使用单子来处理诸如文件系统输入输出这样的有状态事物。其他语言则依赖于类似于我们使用Python的混合环境。在Python中，软件可以一般是函数式的，同时精心选择过程式异常。
- en: 'Our functional Python programs will rely on the following three stacks of abstractions:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数式Python程序将依赖于以下三个抽象堆栈：
- en: Our applications will be functions—all the way down—until we hit the objects;
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的应用程序将一直是以函数的形式存在，直到我们触及到对象；
- en: The underlying Python runtime environment that supports our functional programming
    is objects—all the way down—until we hit the libraries;
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持我们函数式编程的底层Python运行时环境也是以对象的形式存在，直到我们触及到库；
- en: The libraries that support Python are a turtle on which Python stands.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持Python的库就像是Python站立在上的乌龟。
- en: The operating system and hardware form their own stack of turtles. These details
    aren’t relevant to the problems we’re going to solve.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统和硬件形成它们自己的乌龟堆栈。这些细节与我们即将解决的问题无关。
- en: 1.3 A classic example of functional programming
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3 函数式编程的经典示例
- en: As part of our introduction, we’ll look at a classic example of functional programming.
    This is based on the paper Why Functional Programming Matters by John Hughes.
    The article appeared in a paper called Research Topics in Functional Programming,
    edited by D. Turner, published by Addison-Wesley in 1990.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们介绍的一部分，我们将查看一个函数式编程的经典示例。这是基于John Hughes的论文《Why Functional Programming Matters》。这篇文章发表在由D.
    Turner编辑的《Research Topics in Functional Programming》论文集中，由Addison-Wesley于1990年出版。
- en: 'Here’s a link to one of the papers in Research Topics in Functional Programming,
    “Why Functional Programming Matters”: [http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf](http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个链接到《Research Topics in Functional Programming》中的一篇论文，“Why Functional Programming
    Matters”：[http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf](http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf)
- en: 'This paper is a profound discussion of functional programming. There are several
    examples given. We’ll look at just one: the Newton-Raphson algorithm for locating
    any roots of a function. In this case, we’ll define a function that will compute
    a square root of a number.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇论文对函数式编程进行了深刻的讨论。给出了几个示例。我们将只看其中一个：用于寻找函数任何根的牛顿-拉夫森算法。在这种情况下，我们将定义一个计算数字平方根的函数。
- en: It’s important because many versions of this algorithm rely on the explicit
    state managed via loops. Indeed, the Hughes paper provides a snippet of the Fortran
    code that emphasizes stateful, imperative processing.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为许多这个算法的版本依赖于通过循环显式管理的状态。确实，休斯论文提供了一个Fortran代码片段，强调了有状态、命令式的处理。
- en: 'The backbone of this approximation is the calculation of the next approximation
    from the current approximation. The `next_()` function takes `x`, an approximation
    to the `sqrt(n)` value, and calculates a next value that brackets the proper root.
    Take a look at the following example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个近似的骨架是从当前近似计算下一个近似值。`next_()`函数接受`x`，即`sqrt(n)`值的近似，并计算一个包围正确根的下一个值。请看以下示例：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function computes a series of values that will quickly converge on some
    value x such that x = ![n x](img/file4.jpg), which means x = ![√-- n](img/file5.jpg).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数计算一系列值，这些值将迅速收敛到某个值x，使得x = ![n x](img/file4.jpg)，这意味着x = ![√-- n](img/file5.jpg)。
- en: Note that the name `next()` would collide with a built-in function. Calling
    it `next_()` lets us follow the original presentation as closely as possible,
    using Pythonic names.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`next()`这个名字会与内置函数冲突。将其命名为`next_()`让我们尽可能接近原始演示，使用Pythonic的名字。
- en: 'Here’s how the function looks when used in Python’s interactive REPL:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何在Python的交互式REPL中使用该函数的示例：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We defined the `f()` function as a lambda that will converge on ![√ -- n](img/file6.jpg)
    where n = 2\. We started with 1.0 as the initial value for a[0]. Then we evaluated
    a sequence of recursive evaluations: a[1] = f(a[0]), a[2] = f(f(a[0])), and so
    on. We evaluated these functions using a generator expression so that we could
    round each value to four decimal places. This makes the output easier to read
    and easier to use with `doctest`. The sequence appears to converge rapidly on
    ![√-- 2](img/file7.jpg). To get a more precise answer, we must continue to perform
    the series of steps after the first four shown above.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`f()`函数定义为lambda，它将收敛到![√ -- n](img/file6.jpg)（其中n = 2）。我们以1.0作为a[0]的初始值。然后我们评估了一系列递归评估：a[1]
    = f(a[0])，a[2] = f(f(a[0]))，依此类推。我们使用生成器表达式评估这些函数，以便将每个值四舍五入到四位小数。这使得输出更容易阅读，并且更容易与`doctest`一起使用。这个序列似乎迅速收敛到![√--
    2](img/file7.jpg)。为了得到更精确的答案，我们必须继续执行上述四个步骤之后的步骤。
- en: 'We can write a function that will (in principle) generate an infinite sequence
    of a[i] values. This series will converge on the proper square root:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个函数，理论上可以生成一个无限序列的a[i]值。这个序列将收敛到正确的平方根：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function will generate a sequence of approximations using a function, `f()`,
    and an initial value, `a`. If we provide the `next_()` function defined earlier,
    we’ll get a sequence of approximations to the square root of the `n` argument.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将使用函数`f()`和一个初始值`a`生成一系列近似值。如果我们提供前面定义的`next_()`函数，我们将得到一系列对`n`参数平方根的近似值。
- en: The `repeat()` function expects the `f()` function to have a single argument;
    however, our `next_()` function has two arguments. We’ve used a lambda object,
    `lambda`` x:`` next_(n,`` x)`, to create a partial version of the `next_()` function
    with one of two variables bound.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat()`函数期望`f()`函数有一个参数；然而，我们的`next_()`函数有两个参数。我们使用lambda对象`lambda x: next_(n,
    x)`创建了一个部分版本的`next_()`函数，其中一个变量被绑定。'
- en: The Python generator functions can’t be trivially recursive; they must explicitly
    iterate over the recursive results, yielding them individually.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Python的生成器函数不能简单地递归；它们必须显式地迭代递归结果，并单独产生它们。
- en: Attempting to use a simple `return`` repeat(f,`` f(a))` will end the iteration,
    returning a generator expression instead of yielding values.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用简单的`return` `repeat(f, f(a))`将结束迭代，返回一个生成器表达式而不是产生值。
- en: 'There are two ways to return all the values instead of returning a generator
    expression, which are as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以返回所有值而不是返回一个生成器表达式，如下所示：
- en: 'We can write an explicit `for` statement to yield values as follows:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以编写一个显式的`for`语句来产生值，如下所示：
- en: '[PRE12]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can use the `yield`` from` expression as follows:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用以下方式使用`yield from`表达式：
- en: '[PRE13]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Both techniques of yielding the values of a recursive generator function are
    will have similar results. We’ll try to emphasize `yield`` from`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种产生递归生成函数值的技巧将会有类似的结果。我们将尝试强调`yield from`。
- en: 'It turns out that `yield` and `yield`` from` are a bit more sophisticated than
    we’ve shown here. For our purposes, we’ll limit ourselves to working with recursive
    results. For more information on the full feature set for `yield` and `yield`` from`,
    see PEP 342 and PEP 380: [https://peps.python.org/pep-0342/](https://peps.python.org/pep-0342/)
    and [https://peps.python.org/pep-0380/](https://peps.python.org/pep-0380/).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明`yield`和`yield from`比我们在这里展示的要复杂一些。为了我们的目的，我们将限制自己处理递归结果。有关`yield`和`yield
    from`的完整功能集的更多信息，请参阅PEP 342和PEP 380：[https://peps.python.org/pep-0342/](https://peps.python.org/pep-0342/)
    和 [https://peps.python.org/pep-0380/](https://peps.python.org/pep-0380/)。
- en: Of course, we don’t want the entire infinite sequence created by the `repeat()`
    function. It’s essential to stop generating values when we’ve found the square
    root we’re looking for. The common symbol for the limit we can consider “close
    enough” is the Greek letter epsilon, 𝜖.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不想创建由`repeat()`函数生成的整个无限序列。当我们找到所需的平方根时，停止生成值是至关重要的。我们可以考虑的“足够接近”的极限的常见符号是希腊字母epsilon，𝜖。
- en: 'In Python, we have to be a little clever when taking items from an infinite
    sequence one at a time. It works out well to use a simple interface function that
    wraps a slightly more complex recursion. Take a look at the following code snippet:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，当我们一次从无限序列中取出一个元素时，我们必须稍微聪明一点。使用一个简单的接口函数来包装稍微复杂一些的递归是一个很好的解决方案。请看以下代码片段：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We’ve defined an internal function, `head_tail()`, which accepts the tolerance,
    𝜖, an item from the iterable sequence, `a`, and the rest of the iterable sequence,
    `iterable`. The first item from the iterable, extracted with the `next()` function,
    is bound to a name, `b`. If |a − b|≤ 𝜖, the two values of `a` and `b` are close
    enough to call the value of `b` the square root; the difference is less than or
    equal to the very small value of 𝜖. Otherwise, we use the `b` value in a recursive
    invocation of the `head_tail()` function to examine the next pair of values.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个内部函数`head_tail()`，它接受容差值𝜖、可迭代序列中的一个元素`a`以及可迭代序列的其余部分`iterable`。使用`next()`函数从可迭代序列中提取的第一个元素绑定到名称`b`。如果|a
    − b|≤ 𝜖，则`a`和`b`的值足够接近，可以将`b`的值称为平方根；差异小于或等于非常小的值𝜖。否则，我们使用`b`值在`head_tail()`函数的递归调用中检查下一对值。
- en: Our `within()` function properly initializes the internal `head_tail()` function
    with the first value from the `iterable` parameter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`within()`函数正确地初始化了内部`head_tail()`函数，使用`iterable`参数的第一个值。
- en: 'We can use the three functions, `next_()`, `repeat()`, and `within()`, to create
    a square root function, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用三个函数`next_()`、`repeat()`和`within()`来创建一个平方根函数，如下所示：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We’ve used the `repeat()` function to generate a (potentially) infinite sequence
    of values based on the `next_(n,x)` function. Our `within()` function will stop
    generating values in the sequence when it locates two values with a difference
    less than 𝜖.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`repeat()`函数根据`next_(n,x)`函数生成一个（可能）无限值的序列。我们的`within()`函数将在找到两个差异小于𝜖的值时停止生成序列中的值。
- en: This definition of the `sqrt()` function provides useful default values to the
    underlying `within()` function. It provides an 𝜖 value of 0.0001 and an initial
    a[0] value of 1.0.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `sqrt()` 函数的定义为底层的 `within()` 函数提供了有用的默认值。它提供了一个 𝜖 值为 0.0001 和一个初始 a[0] 值为
    1.0。
- en: A more advanced version could use default parameter values to make changes possible.
    As an exercise, the definition of `sqrt()` can be rewritten so an expression such
    as `sqrt(1.0,`` 0.000_01,`` 3)` will start with an approximation of 1.0 and compute
    the value of ![√ -- 3](img/file8.jpg) to within 0.00001\. For most applications,
    the initial a[0] value can be 1.0\. However, the closer it is to the actual square
    root, the more rapidly this algorithm converges.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的版本可以使用默认参数值来使更改成为可能。作为一个练习，`sqrt()` 的定义可以被重写，以便像 `sqrt(1.0, 0.000_01, 3)`
    这样的表达式将以 1.0 的近似值开始，并计算 ![√ -- 3](img/file8.jpg) 的值，精确到 0.00001。对于大多数应用，初始 a[0]
    值可以是 1.0。然而，它越接近实际的平方根，这个算法的收敛速度就越快。
- en: The original example of this approximation algorithm was shown in the Miranda
    language. It’s easy to see there are some profound differences between Miranda
    and Python. In spite of the differences, the similarities give us confidence that
    many kinds of functional programming can be easily implemented in Python.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个近似算法的原始示例是在 Miranda 语言中展示的。很容易看出 Miranda 和 Python 之间存在一些深刻的差异。尽管有差异，但相似之处让我们有信心认为许多类型的函数式编程可以很容易地在
    Python 中实现。
- en: The `within` function shown here is written to match the original article’s
    function definition. Python’s `itertools` library provides a `takewhile()` function
    that might be better for this application than the `within()` function. Similarly,
    the `math.isclose()` function may be better than the `abs(a-b)`` <=`𝜖 expression
    used here. Python offers a great many pre-built functional programming features;
    we’ll look closely at these functions in [Chapter 8](Chapter_08.xhtml#x1-1700008),
    [The Itertools Module](Chapter_08.xhtml#x1-1700008) and [Chapter 9](Chapter_09.xhtml#x1-1990009),
    [Itertools for Combinatorics – Permutations and Combinations](Chapter_09.xhtml#x1-1990009).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的 `within` 函数是按照原始文章的函数定义编写的。Python 的 `itertools` 库提供了一个 `takewhile()` 函数，可能比这里的
    `within()` 函数更适合这个应用。同样，`math.isclose()` 函数可能比这里使用的 `abs(a-b) <= 𝜖` 表达式更好。Python
    提供了大量的预构建函数式编程特性；我们将在第 8 章（[Chapter 08.xhtml#x1-1700008](Chapter_08.xhtml#x1-1700008)）、[The
    Itertools Module](Chapter_08.xhtml#x1-1700008) 和第 9 章（[Chapter_09.xhtml#x1-1990009](Chapter_09.xhtml#x1-1990009)）、[Itertools
    for Combinatorics – Permutations and Combinations](Chapter_09.xhtml#x1-1990009)
    中仔细研究这些函数。
- en: 1.4 Exploratory data analysis
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4 探索性数据分析
- en: Later in this book, we’ll use the field of exploratory data analysis as a source
    for concrete examples of functional programming. This field is rich with algorithms
    and approaches to working with complex datasets; functional programming is often
    a very good fit between the problem domain and automated solutions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，我们将使用探索性数据分析领域作为函数式编程具体示例的来源。这个领域充满了处理复杂数据集的算法和方法；函数式编程通常在问题域和自动化解决方案之间非常匹配。
- en: 'While details vary from author to author, there are several widely accepted
    stages of EDA. These include the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然细节因作者而异，但EDA（探索性数据分析）有几个被广泛接受的阶段。这些包括以下内容：
- en: 'Data preparation: This might involve extraction and transformation for source
    applications. It might involve parsing a source data format and doing some kind
    of data scrubbing to remove unusable or invalid data. This is an excellent application
    of functional design techniques.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据准备：这可能涉及源应用程序的提取和转换。它可能涉及解析源数据格式，并进行某种数据清理以删除不可用或无效的数据。这是功能设计技术的优秀应用。
- en: David Mertz’s superb book Cleaning Data for Effective Data Science( [https://www.packtpub.com/product/cleaning-data-for-effective-data-science/9781801071291](https://www.packtpub.com/product/cleaning-data-for-effective-data-science/9781801071291))
    provides additional information on data cleaning. This is a crucial subject for
    all data science and analytical work.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: David Mertz 的杰出著作《为高效数据科学清理数据》（[https://www.packtpub.com/product/cleaning-data-for-effective-data-science/9781801071291](https://www.packtpub.com/product/cleaning-data-for-effective-data-science/9781801071291)）提供了有关数据清理的更多信息。这对于所有数据科学和分析工作都是一个关键主题。
- en: 'Data exploration: This is a description of the available data. This usually
    involves the essential statistical functions. This is another excellent place
    to explore functional programming. We can describe our focus as univariate and
    bivariate statistics, but that sounds too daunting and complex. What this really
    means is that we’ll focus on mean, median, mode, and other related descriptive
    statistics. Data exploration may also involve data visualization. We’ll skirt
    this issue because it doesn’t involve very much functional programming.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据探索：这是对可用数据的描述。这通常涉及基本统计函数。这是探索函数式编程的另一个绝佳场所。我们可以将我们的重点描述为单变量和双变量统计，但这听起来过于令人畏惧和复杂。这实际上意味着我们将关注均值、中位数、众数和其他相关描述性统计。数据探索还可能涉及数据可视化。我们将绕过这个问题，因为它不涉及很多函数式编程。
- en: For more information on Python visualization, see Interactive Data Visualization
    with Python, [https://www.packtpub.com/product/interactive-data-visualization-with-python-second-edition/9781800200944](https://www.packtpub.com/product/interactive-data-visualization-with-python-second-edition/9781800200944).
    See [https://www.projectpro.io/article/python-data-visualization-libraries/543](https://www.projectpro.io/article/python-data-visualization-libraries/543)
    for some additional visualization libraries.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Python可视化的更多信息，请参阅《Python交互式数据可视化》，[https://www.packtpub.com/product/interactive-data-visualization-with-python-second-edition/9781800200944](https://www.packtpub.com/product/interactive-data-visualization-with-python-second-edition/9781800200944)。有关一些额外的可视化库，请参阅[https://www.projectpro.io/article/python-data-visualization-libraries/543](https://www.projectpro.io/article/python-data-visualization-libraries/543)。
- en: 'Data modeling and machine learning: This tends to be prescriptive as it involves
    extending a model to new data. We’re going to skirt around this because some of
    the models can become mathematically complex. If we spend too much time on these
    topics, we won’t be able to focus on functional programming.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据建模和机器学习：这通常具有规范性，因为它涉及将模型扩展到新数据。我们将绕过这个问题，因为一些模型可能会变得数学上复杂。如果我们在这上面花费太多时间，我们就无法专注于函数式编程。
- en: 'Evaluation and comparison: When there are alternative models, each must be
    evaluated to determine which is a better fit for the available data. This can
    involve ordinary descriptive statistics of model outputs, which can benefit from
    functional design techniques.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估和比较：当存在替代模型时，每个模型都必须被评估以确定哪个更适合现有数据。这可能涉及模型输出的普通描述性统计，这些统计可以受益于功能设计技术。
- en: One goal of EDA is often to create a model that can be deployed as a decision
    support application. In many cases, a model might be a simple function. A functional
    programming approach can apply the model to new data and display results for human
    consumption.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: EDA的一个目标通常是创建一个可以作为决策支持应用程序部署的模型。在许多情况下，模型可能是一个简单的函数。函数式编程方法可以将模型应用于新数据，并显示供人类消费的结果。
- en: 1.5 Summary
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5 摘要
- en: In this chapter, we’ve looked at programming paradigms with an eye toward distinguishing
    the functional paradigm from the imperative paradigm. For our purposes, object-oriented
    programming is a kind of imperative programming; it relies on explicit state changes.
    Our objective in this book is to explore the functional programming features of
    Python. We’ve noted that some parts of Python don’t allow purely functional programming;
    we’ll be using some hybrid techniques that meld the good features of succinct,
    expressive functional programming with some high-performance optimizations in
    Python.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们着眼于区分函数式范式和命令式范式，以探讨编程范式。就我们的目的而言，面向对象编程是一种命令式编程；它依赖于显式的状态变化。本书的目标是探索Python的函数式编程特性。我们注意到Python的一些部分不允许纯函数式编程；我们将使用一些混合技术，这些技术将简洁、表达性强的函数式编程的优点与Python中的一些高性能优化相结合。
- en: In the next chapter, we’ll look at five specific functional programming techniques
    in detail. These techniques will form the essential foundation for our hybridized
    functional programming in Python.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将详细探讨五种特定的函数式编程技术。这些技术将构成我们Python混合函数式编程的基础。
- en: 1.6 Exercises
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6 练习
- en: The exercises in this book are based on code available from Packt Publishing
    on GitHub. See [https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的练习基于GitHub上Packt Publishing提供的代码。请参阅[https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition)。
- en: In some cases, the reader will notice that the code provided on GitHub includes
    partial solutions to some of the exercises. These serve as hints, allowing the
    reader to explore alternative solutions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，读者会注意到 GitHub 上提供的代码包含了一些练习的部分解决方案。这些作为提示，允许读者探索其他解决方案。
- en: In many cases, exercises will need unit test cases to confirm they actually
    solve the problem. These are often identical to the unit test cases already provided
    in the GitHub repository. The reader will need to replace the book’s example function
    name with their own solution to confirm that it works.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，练习将需要单元测试用例来确认它们确实解决了问题。这些通常与 GitHub 仓库中已提供的单元测试用例相同。读者需要将书籍中的示例函数名替换为自己的解决方案以确认其工作。
- en: 1.6.1 Convert an imperative algorithm to functional code
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.6.1 将命令式算法转换为函数式代码
- en: The following algorithm is stated as imperative assignment statements and a
    while construct to indicate processing something iteratively.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法被表述为命令式赋值语句和 while 构造来指示迭代处理。
- en: '![Algorithm 1: Imperative iteration ](img/Algo_1.1.JPG)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![算法 1：命令式迭代](img/Algo_1.1.JPG)'
- en: 'Algorithm 1: Imperative iteration'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 算法 1：命令式迭代
- en: What does this appear to compute? Given Python built-in functions like `sum`,
    can this be simplified?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来是在计算什么？给定像 `sum` 这样的 Python 内置函数，这能简化吗？
- en: It helps to write this in Python and refactor the code to be sure that correct
    answers are created.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将其用 Python 编写并重构代码以确保生成正确答案。
- en: 'A test case is the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一个测试用例如下：
- en: '![V ← {7.46,6.77,12.74,7.11,7.81,8.84,6.08,5.39,8.15,6.42,5.73} ](img/file10.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![V ← {7.46,6.77,12.74,7.11,7.81,8.84,6.08,5.39,8.15,6.42,5.73}](img/file10.jpg)'
- en: The computed value for m is approximately `7.5`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: m 的计算值大约为 `7.5`。
- en: 1.6.2 Convert step-wise computation to functional code
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.6.2 将逐步计算转换为函数式代码
- en: The following algorithm is stated as a long series of single assignment statements.
    The rad(x) function converts degrees to radians, rad(d) = π ×![1d80](img/file11.jpg).
    See the `math` module for an implementation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法被表述为一系列的单个赋值语句。`rad(x)` 函数将度转换为弧度，`rad(d) = π × ![1d80](img/file11.jpg)`。请参阅
    `math` 模块以获取实现。
- en: '![Algorithm 2: Imperative computation ](img/Algo_1.2.JPG)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![算法 2：命令式计算](img/Algo_1.2.JPG)'
- en: 'Algorithm 2: Imperative computation'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 算法 2：命令式计算
- en: Is this code easy to understand? Can you summarize this computation as a short
    mathematical-looking formula?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是否容易理解？你能将这个计算总结为一个简短的类似数学公式的表达式吗？
- en: Breaking it down into sections, lines 1 to 8 seem to be focused on some conversions,
    differences, and mid-point computations. Lines 9 to 12 compute two values, x and
    y. Can these be summarized or simplified? The final four lines do a relatively
    direct computation of d. Can this be summarized or simplified? As a hint, look
    at `math.hypot()` for a function that might be applicable in this case.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将其分解为部分，第 1 到 8 行似乎专注于一些转换、差异和中点计算。第 9 到 12 行计算两个值，x 和 y。这些能否总结或简化？最后的四行进行相对直接的
    d 的计算。这些能否总结或简化？作为一个提示，看看 `math.hypot()` 函数，这个函数可能适用于这种情况。
- en: It helps to write this in Python and refactor the code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将其用 Python 编写并重构代码会有所帮助。
- en: 'A test case is the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一个测试用例如下：
- en: lat[1] ← 32.82950
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: lat[1] ← 32.82950
- en: lon[1] ←−79.93021
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: lon[1] ←−79.93021
- en: lat[2] ← 32.74412
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: lat[2] ← 32.74412
- en: lon[2] ←−79.85226
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: lon[2] ←−79.85226
- en: The computed value for d is approximately `6.4577`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: d 的计算值大约为 `6.4577`。
- en: Refactoring the code can help to confirm your understanding.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 重构代码可以帮助你确认你的理解。
- en: 1.6.3 Revise the sqrt() function
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.6.3 修改 sqrt() 函数
- en: The `sqrt()` function defined in the A classic example of functional programming
    section has only a single parameter value, `n`. Rewrite this to create a more
    advanced version using default parameter values to make changes possible. An expression
    such as `sqrt(1.0,`` 0.000_01,`` 3)` will start with an approximation of 1.0 and
    compute the value to a precision of 0.00001\. The final parameter value, `3`,
    is the value of n, the number we need to compute the square root of.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在“经典函数式编程示例”中定义的 `sqrt()` 函数只有一个参数值，`n`。重写它以创建一个更高级的版本，使用默认参数值来使更改成为可能。例如，表达式
    `sqrt(1.0, `` 0.000_01, `` 3)` 将从 1.0 的近似值开始，并计算到 0.00001 的精度。最后一个参数值 `3` 是 n
    的值，我们需要计算其平方根的数字。
- en: 1.6.4 Data cleansing steps
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.6.4 数据清洗步骤
- en: A file of source data has US ZIP codes in a variety of formats. This problem
    often arises when spreadsheet software is used to collect or transform data.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 源数据文件包含各种格式的美国 ZIP 码。当使用电子表格软件收集或转换数据时，这个问题经常出现。
- en: Some ZIP codes were processed as numbers. This doesn’t work out well for places
    in New England, where ZIP codes have a leading zero. For example, one of Portsmouth,
    New Hampshire’s codes should be stated as `03801`. In the source file, it is `3801`.
    For the most part, these numbers will have five or nine digits, but some codes
    in New England will be four or eight digits when a single leading zero was dropped.
    For Puerto Rico, there may be two leading zeroes.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些ZIP代码被处理为数字。这对于新英格兰地区来说并不理想，因为那里的ZIP代码以零开头。例如，新罕布什尔州朴次茅斯的代码应该是`03801`。在源文件中，它是`3801`。大多数情况下，这些数字将具有五位或九位数字，但新英格兰的一些代码在去掉单个前导零后将是四位或八位数字。对于波多黎各，可能会有两个前导零。
- en: Some ZIP codes are stored as strings, 12345−0100, where a four-digit extension
    for a post-office box has been appended to the base five-digit code.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些ZIP代码以字符串形式存储，例如12345−0100，其中附加了一个四位邮政信箱扩展到基本五位代码。
- en: A CSV-format file has only text values. However, when data in the file has been
    processed by a spreadsheet, problems can arise. Because a ZIP code has only digits,
    it can be treated as numeric data. This means the original data values will have
    been converted to a number, and then back to a text representation. These conversions
    will drop the leading zeroes. There are a number of workarounds in various spreadsheet
    applications to prevent this problem. If they’re not used, the data can have anomalous
    values that can be cleansed to restore the original representation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: CSV格式的文件只有文本值。然而，当文件中的数据经过电子表格处理时，可能会出现问题。因为ZIP代码只有数字，它可以被视为数值数据。这意味着原始数据值已经被转换为数字，然后再转换回文本表示。这些转换将删除前导零。在各种电子表格应用程序中存在许多解决方案来防止这个问题。如果不使用它们，数据可能会出现异常值，这些异常值可以被清理以恢复原始表示。
- en: 'The objective of the exercise is to compute a histogram of the most popular
    ZIP codes in the source data file. The data must be cleansed to have the following
    two ZIP formats:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 练习的目标是计算源数据文件中最受欢迎的ZIP代码的直方图。数据必须经过清理，以具有以下两种ZIP格式：
- en: Five characters with no post-office box, for example `03801`
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有邮政信箱的五位字符，例如`03801`
- en: Ten characters with a hyphen, for example `03899-9876`
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，带有连字符的十个字符，例如`03899-9876`
- en: The essential histogram can be done with a `collections.Counter` object as follows.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的直方图可以使用`collections.Counter`对象完成如下。
- en: '[PRE16]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This makes use of imperative processing features to read a file. The overall
    design, using a `for` statement to process rows of a file, is an essential Pythonic
    feature that we can preserve.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这利用了命令式处理功能来读取文件。使用`for`语句处理文件行，这种整体设计是Python的一个基本特性，我们可以保留它。
- en: On the other hand, the processing of the `text_zip` and `missing_zeroes` variables
    through a number of state changes seems like it’s a potential source for confusion.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，通过一系列状态变化处理`text_zip`和`missing_zeroes`变量似乎是一个潜在的混淆来源。
- en: 'This can be refactored through several rewrites:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过几次重写进行重构：
- en: 'Decompose the `main()` function into two parts. A new `zip_histogram()` function
    should be written to contain much of the processing detail. This function will
    process the opened file, and return a `Counter` object. A suggested signature
    is the following:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`main()`函数分解为两部分。应该编写一个新的`zip_histogram()`函数来包含大部分处理细节。这个函数将处理打开的文件，并返回一个`Counter`对象。建议的签名如下：
- en: '[PRE17]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `main()` function is left with the responsibility to open the file, create
    the `csv.DictReader` instance, evaluate `zip_histogram()`, and print the histogram.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`main()`函数负责打开文件，创建`csv.DictReader`实例，评估`zip_histogram()`，并打印直方图。'
- en: Once the `zip_histogram()` function has been defined, the cleansing of the `ZIP`
    attribute can be refactored into a separate function, with a name like `zip_cleanse()`.
    Rather than setting the value of the `text_zip` variable, this function can return
    the cleansed result. This can be tested separately to be sure the various cases
    are handled gracefully.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦定义了`zip_histogram()`函数，`ZIP`属性的清理可以重构为一个单独的函数，例如命名为`zip_cleanse()`。这个函数而不是设置`text_zip`变量的值，可以返回清理后的结果。这可以单独测试以确保各种情况都能优雅地处理。
- en: The distinction between long ZIP codes with a hyphen and without a hyphen is
    something that should be fixed. Once the `zip_cleanse()` works in general, add
    a new function to inject hyphens into ZIP codes with only digits. This should
    transform `38011234` to `03801-1234`. Note that short, five-digit ZIP codes do
    not need to have a hyphen added; this additional transformation only applies to
    nine-digit codes to make them into ten-position strings.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 带有连字符和不带连字符的长 ZIP 码之间的区别是应该修复的问题。一旦 `zip_cleanse()` 在一般情况下工作，添加一个新函数来在只有数字的
    ZIP 码中注入连字符。这应该将 `38011234` 转换为 `03801-1234`。注意，短的五位 ZIP 码不需要添加连字符；这种额外的转换仅适用于九位代码，使其成为十位字符串。
- en: 'The final `zip_histogram()` function should look something like the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的 `zip_histogram()` 函数应该看起来像以下这样：
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This provides a framework for performing a focused data cleanup in the given
    column. It allows us to distinguish between CSV and file processing features,
    and the details of how to clean up a specific column of data.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这为在给定列中进行专注的数据清理提供了一个框架。它使我们能够区分 CSV 和文件处理功能，以及如何清理特定列数据的细节。
- en: 1.6.5 (Advanced) Optimize this functional code
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.6.5（高级）优化此功能代码
- en: The following algorithm is stated as a single ”step” that has been decomposed
    into three separate formulae. The decomposition is more a concession to the need
    to fit the expression into the limits of a printed page than a useful optimization.
    The rad(x) function converts degrees to radians, rad(d) = π ×![-d- 180](img/file13.jpg).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法被表述为一个单独的“步骤”，该步骤已被分解为三个独立的公式。这种分解更多的是为了满足将表达式放入印刷页面限制的需要，而不是一种有用的优化。rad(x)
    函数将度转换为弧度，rad(d) = π ×![-d- 180](img/file13.jpg)。
- en: '![Algorithm 3: Redundant expressions ](img/Algo_1.3.JPG)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![算法 3：冗余表达式](img/Algo_1.3.JPG)'
- en: 'Algorithm 3: Redundant expressions'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 算法 3：冗余表达式
- en: There are a number of redundant expressions, like rad(lat[1]) and rad(lat[2]).
    If these are assigned to local variables, can the expression be simplified?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多冗余表达式，例如 rad(lat[1]) 和 rad(lat[2])。如果这些被分配给局部变量，表达式能否简化？
- en: The final computation of d does not match the conventional understanding of
    computing a hypotenuse, ![∘ ------- x2 + y2](img/file15.jpg). Should the code
    be refactored to match the definition in `math.hypot`?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: d 的最终计算结果与计算斜边传统的理解不符，![∘ ------- x2 + y2](img/file15.jpg)。代码应该重构以匹配 `math.hypot`
    中的定义吗？
- en: It helps to start by writing this in Python and then refactoring the code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从用 Python 编写这个开始，然后重构代码是一个好方法。
- en: 'A test case is the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个测试用例：
- en: lat[1] ← 32.82950
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: lat[1] ← 32.82950
- en: lon[1] ←−79.93021
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: lon[1] ←−79.93021
- en: lat[2] ← 32.74412
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: lat[2] ← 32.74412
- en: lon[2] ←−79.85226
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: lon[2] ←−79.85226
- en: The computed value for d is approximately `6.4577`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: d 的计算值大约为 `6.4577`。
- en: Refactoring the code can help to confirm your understanding of what this code
    really does.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重构可以帮助你确认你对这段代码真正功能的理解。
- en: Join our community Discord space
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区空间
- en: 'Join our Python Discord workspace to discuss and know more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Python Discord 工作空间，讨论并了解更多关于这本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file1.png)'
