- en: '1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '1'
- en: Understanding Functional Programming
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ç†è§£å‡½æ•°å¼ç¼–ç¨‹
- en: Functional programming defines a computation using expressions and evaluation;
    often, they are encapsulated in function definitions. It de-emphasizes or avoids
    the complexity of state change and mutable objects. This tends to create programs
    that are more succinct and expressive. In this chapter, weâ€™ll introduce some of
    the techniques that characterize functional programming. Weâ€™ll identify some of
    the ways to map these features to Python. Finally, weâ€™ll also address some ways
    in which the benefits of functional programming accrue when we use these design
    patterns to build Python applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: å‡½æ•°å¼ç¼–ç¨‹ä½¿ç”¨è¡¨è¾¾å¼å’Œè¯„ä¼°æ¥å®šä¹‰è®¡ç®—ï¼›é€šå¸¸ï¼Œå®ƒä»¬å°è£…åœ¨å‡½æ•°å®šä¹‰ä¸­ã€‚å®ƒå¼±åŒ–æˆ–é¿å…çŠ¶æ€å˜åŒ–å’Œå¯å˜å¯¹è±¡çš„å¤æ‚æ€§ã€‚è¿™å¾€å¾€ä¼šäº§ç”Ÿæ›´ç®€æ´ã€æ›´æ˜“äºè¡¨è¾¾çš„ç¨‹åºã€‚åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†ä»‹ç»ä¸€äº›è¡¨å¾å‡½æ•°å¼ç¼–ç¨‹çš„æŠ€æœ¯ã€‚æˆ‘ä»¬å°†ç¡®å®šä¸€äº›å°†è¿™äº›ç‰¹æ€§æ˜ å°„åˆ°Pythonçš„æ–¹æ³•ã€‚æœ€åï¼Œæˆ‘ä»¬è¿˜å°†è®¨è®ºä½¿ç”¨è¿™äº›è®¾è®¡æ¨¡å¼æ„å»ºPythonåº”ç”¨ç¨‹åºæ—¶ï¼Œå‡½æ•°å¼ç¼–ç¨‹çš„å¥½å¤„æ˜¯å¦‚ä½•ç§¯ç´¯çš„ã€‚
- en: This book doesnâ€™t contain a tutorial introduction to the Python language. We
    assume the reader knows some Python. In many cases, if the reader knows a functional
    programming language, then that knowledge can be applied to Python via the examples
    in this book. For background information on Python, see Python in a Nutshell,
    4th Edition, or any of the Python introductions from Packt Publishing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æœ¬ä¹¦ä¸åŒ…å«Pythonè¯­è¨€çš„æ•™ç¨‹ä»‹ç»ã€‚æˆ‘ä»¬å‡è®¾è¯»è€…å·²ç»äº†è§£ä¸€äº›Pythonã€‚åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼Œå¦‚æœè¯»è€…äº†è§£å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ï¼Œé‚£ä¹ˆè¿™äº›çŸ¥è¯†å¯ä»¥é€šè¿‡æœ¬ä¹¦ä¸­çš„ç¤ºä¾‹åº”ç”¨åˆ°Pythonä¸Šã€‚æœ‰å…³Pythonçš„èƒŒæ™¯ä¿¡æ¯ï¼Œè¯·å‚é˜…ã€ŠPythoné€ŸæŸ¥æ‰‹å†Œã€‹ç¬¬4ç‰ˆæˆ–Packt
    Publishingå‡ºç‰ˆçš„ä»»ä½•Pythonå…¥é—¨ä¹¦ç±ã€‚
- en: Python has a broad variety of programming features, including numerous ways
    to support functional programming. As we will see throughout this book, Python
    is not a purely functional programming language; instead, it relies on a mixture
    of features. Weâ€™ll see that the language offers enough of the right kinds of features
    to provide the benefits of functional programming. It also retains all the optimization
    power of an imperative programming language. Further, we can mix the object-oriented
    and functional features to make use of the best aspects of both paradigms.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Pythonæ‹¥æœ‰å¹¿æ³›çš„ç¼–ç¨‹ç‰¹æ€§ï¼ŒåŒ…æ‹¬è®¸å¤šæ”¯æŒå‡½æ•°å¼ç¼–ç¨‹çš„æ–¹æ³•ã€‚æ­£å¦‚æˆ‘ä»¬å°†åœ¨æœ¬ä¹¦ä¸­çœ‹åˆ°çš„é‚£æ ·ï¼ŒPythonä¸æ˜¯ä¸€ç§çº¯ç²¹çš„å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ï¼›ç›¸åï¼Œå®ƒä¾èµ–äºä¸€ç³»åˆ—ç‰¹æ€§çš„æ··åˆã€‚æˆ‘ä»¬å°†çœ‹åˆ°ï¼Œè¯¥è¯­è¨€æä¾›äº†è¶³å¤Ÿæ­£ç¡®çš„ç‰¹æ€§æ¥æä¾›å‡½æ•°å¼ç¼–ç¨‹çš„å¥½å¤„ã€‚å®ƒè¿˜ä¿ç•™äº†å‘½ä»¤å¼ç¼–ç¨‹è¯­è¨€çš„å…¨éƒ¨ä¼˜åŒ–èƒ½åŠ›ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬å¯ä»¥æ··åˆé¢å‘å¯¹è±¡å’Œå‡½æ•°å¼ç‰¹æ€§ï¼Œä»¥åˆ©ç”¨ä¸¤ç§èŒƒä¾‹çš„æœ€ä½³æ–¹é¢ã€‚
- en: Weâ€™ll also look at a problem domain that weâ€™ll use for many of the examples
    in this book. Weâ€™ll try to stick closely to Exploratory Data Analysis (EDA). For
    more information, see [https://www.itl.nist.gov/div898/handbook/eda/eda.htm](https://www.itl.nist.gov/div898/handbook/eda/eda.htm).
    The idea of â€exploratoryâ€ means doing data collection followed by analysis, with
    a goal of inferring what model would be appropriate to describe the data. This
    is a helpful domain because many of the algorithms are good examples of functional
    programming. Furthermore, the benefits of functional programming accrue rapidly
    when exploring data to locate trends and relationships.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å°†æ¢è®¨ä¸€ä¸ªæˆ‘ä»¬å°†ç”¨äºæœ¬ä¹¦è®¸å¤šç¤ºä¾‹çš„é—®é¢˜åŸŸã€‚æˆ‘ä»¬å°†å°½é‡ç´§å¯†åœ°éµå¾ªæ¢ç´¢æ€§æ•°æ®åˆ†æï¼ˆEDAï¼‰ã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…[https://www.itl.nist.gov/div898/handbook/eda/eda.htm](https://www.itl.nist.gov/div898/handbook/eda/eda.htm)ã€‚"æ¢ç´¢"è¿™ä¸€æ¦‚å¿µæ„å‘³ç€åœ¨æ•°æ®æ”¶é›†ä¹‹åè¿›è¡Œæ•°æ®åˆ†æï¼Œç›®æ ‡æ˜¯æ¨æ–­å‡ºæè¿°æ•°æ®çš„é€‚å½“æ¨¡å‹ã€‚è¿™æ˜¯ä¸€ä¸ªæœ‰ç”¨çš„é¢†åŸŸï¼Œå› ä¸ºè®¸å¤šç®—æ³•éƒ½æ˜¯å‡½æ•°å¼ç¼–ç¨‹çš„è‰¯å¥½ç¤ºä¾‹ã€‚æ­¤å¤–ï¼Œåœ¨æ¢ç´¢æ•°æ®ä»¥å®šä½è¶‹åŠ¿å’Œå…³ç³»æ—¶ï¼Œå‡½æ•°å¼ç¼–ç¨‹çš„å¥½å¤„ä¼šè¿…é€Ÿç§¯ç´¯ã€‚
- en: Our goal is to establish some essential principles of functional programming.
    The more serious Python code will begin in [ChapterÂ 2](Chapter_02.xhtml#x1-340002),
    [Introducing Essential Functional Concepts](Chapter_02.xhtml#x1-340002).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„ç›®æ ‡æ˜¯ç¡®ç«‹å‡½æ•°å¼ç¼–ç¨‹çš„ä¸€äº›åŸºæœ¬åŸç†ã€‚æ›´ä¸¥è‚ƒçš„Pythonä»£ç å°†ä»[ç¬¬2ç« ](Chapter_02.xhtml#x1-340002)ï¼Œ[ä»‹ç»åŸºæœ¬å‡½æ•°å¼æ¦‚å¿µ](Chapter_02.xhtml#x1-340002)å¼€å§‹ã€‚
- en: 'In this chapter, weâ€™ll focus on the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†å…³æ³¨ä»¥ä¸‹ä¸»é¢˜ï¼š
- en: Comparing and contrasting the functional paradigm with other ways of designing
    software. Weâ€™ll look at how Pythonâ€™s approach can be called a â€hybridâ€ between
    functional programming and object-oriented programming.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¯”è¾ƒå’Œå¯¹æ¯”å‡½æ•°èŒƒå¼ä¸å…¶ä»–è½¯ä»¶è®¾è®¡æ–¹æ³•ã€‚æˆ‘ä»¬å°†æ¢è®¨Pythonçš„æ–¹æ³•å¦‚ä½•è¢«ç§°ä¸ºå‡½æ•°å¼ç¼–ç¨‹å’Œé¢å‘å¯¹è±¡ç¼–ç¨‹ä¹‹é—´çš„â€œæ··åˆâ€ã€‚
- en: Weâ€™ll look in depth at a specific example extracted from the functional programming
    literature.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†æ·±å…¥æ¢è®¨ä¸€ä¸ªä»å‡½æ•°å¼ç¼–ç¨‹æ–‡çŒ®ä¸­æå–çš„å…·ä½“ç¤ºä¾‹ã€‚
- en: Weâ€™ll conclude with an overview of EDA and why this discipline seems to provide
    numerous examples of functional programming.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†ä»¥EDAçš„æ¦‚è¿°å’Œä¸ºä»€ä¹ˆè¿™ä¸ªå­¦ç§‘ä¼¼ä¹æä¾›äº†è®¸å¤šå‡½æ•°å¼ç¼–ç¨‹çš„ç¤ºä¾‹ä½œä¸ºç»“æŸã€‚
- en: Weâ€™ll focus on Python 3.10 features in this book. This includes the new `match`
    statement.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ä¹¦å°†é‡ç‚¹å…³æ³¨Python 3.10çš„ç‰¹æ€§ã€‚è¿™åŒ…æ‹¬æ–°çš„`match`è¯­å¥ã€‚
- en: Throughout this book, weâ€™ll include Python 3 type hints in the examples. Type
    hints can help a reader visualize the essential purpose behind a function definition.
    Type hints are analyzed with the mypy tool. As with unit testing, mypy can be
    part of a tool chain to produce high-quality software.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬ä¹¦çš„æ•´ä¸ªè¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†åœ¨ç¤ºä¾‹ä¸­åŒ…å«Python 3ç±»å‹æç¤ºã€‚ç±»å‹æç¤ºå¯ä»¥å¸®åŠ©è¯»è€…å¯è§†åŒ–å‡½æ•°å®šä¹‰èƒŒåçš„åŸºæœ¬ç›®çš„ã€‚ç±»å‹æç¤ºé€šè¿‡mypyå·¥å…·è¿›è¡Œåˆ†æã€‚ä¸å•å…ƒæµ‹è¯•ä¸€æ ·ï¼Œmypyå¯ä»¥æ˜¯å·¥å…·é“¾çš„ä¸€éƒ¨åˆ†ï¼Œä»¥äº§ç”Ÿé«˜è´¨é‡çš„è½¯ä»¶ã€‚
- en: 1.1 The functional style of programming
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1 ç¼–ç¨‹çš„å‡½æ•°å¼é£æ ¼
- en: Weâ€™ll define functional programming through a series of examples. The distinguishing
    feature between these examples is the concept of state, specifically the state
    of the computation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†é€šè¿‡ä¸€ç³»åˆ—ç¤ºä¾‹æ¥å®šä¹‰å‡½æ•°å¼ç¼–ç¨‹ã€‚è¿™äº›ç¤ºä¾‹ä¹‹é—´çš„åŒºåˆ«ç‰¹å¾æ˜¯çŠ¶æ€çš„æ¦‚å¿µï¼Œç‰¹åˆ«æ˜¯è®¡ç®—çš„çŠ¶æ€ã€‚
- en: Pythonâ€™s strong imperative traits mean that the state of a computation is defined
    by the values of the variables in the various namespaces. Some kinds of statements
    make a well-defined change to the state by adding, changing, or removing a variable.
    We call this imperative because specific kinds of statements change the state.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Pythonçš„å¼ºå‘½ä»¤å¼ç‰¹æ€§æ„å‘³ç€è®¡ç®—çš„çŠ¶çŠ¶æ€ç”±å„ä¸ªå‘½åç©ºé—´ä¸­å˜é‡çš„å€¼å®šä¹‰ã€‚æŸäº›ç±»å‹çš„è¯­å¥é€šè¿‡æ·»åŠ ã€æ›´æ”¹æˆ–åˆ é™¤å˜é‡æ¥å¯¹çŠ¶æ€è¿›è¡Œæ˜ç¡®çš„æ›´æ”¹ã€‚æˆ‘ä»¬ç§°ä¹‹ä¸ºå‘½ä»¤å¼ï¼Œå› ä¸ºç‰¹å®šç±»å‹çš„è¯­å¥ä¼šæ”¹å˜çŠ¶æ€ã€‚
- en: In Python, the assignment statement is the primary way to change the state.
    Python has other statements, such as `global` or `nonlocal`, which modify the
    rules for variables in a particular namespace. Statements such as `def`, `class`,
    and `import` change the processing context. The bulk of the remaining statements
    provide ways to choose which assignment statements get executed. The focus of
    all these various statement types, however, is on changing the state of the variables.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Pythonä¸­ï¼Œèµ‹å€¼è¯­å¥æ˜¯æ”¹å˜çŠ¶æ€çš„ä¸»è¦æ–¹å¼ã€‚Pythonè¿˜æœ‰å…¶ä»–è¯­å¥ï¼Œå¦‚`global`æˆ–`nonlocal`ï¼Œå®ƒä»¬ä¿®æ”¹ç‰¹å®šå‘½åç©ºé—´ä¸­å˜é‡çš„è§„åˆ™ã€‚`def`ã€`class`å’Œ`import`ç­‰è¯­å¥æ”¹å˜å¤„ç†ä¸Šä¸‹æ–‡ã€‚å‰©ä½™çš„å¤§éƒ¨åˆ†è¯­å¥æä¾›äº†é€‰æ‹©å“ªäº›èµ‹å€¼è¯­å¥è¢«æ‰§è¡Œçš„æ–¹æ³•ã€‚ç„¶è€Œï¼Œæ‰€æœ‰è¿™äº›ä¸åŒç±»å‹çš„è¯­å¥çš„ç„¦ç‚¹éƒ½æ˜¯æ”¹å˜å˜é‡çš„çŠ¶æ€ã€‚
- en: In a functional language, we replace the stateâ€”the changing values of variablesâ€”with
    a simpler notion of evaluating functions. Each function evaluation creates a new
    object or objects from existing objects. Since a functional program is a composition
    of functions, we can design lower-level functions that are easy to understand,
    and then create compositions of functions that can also be easier to visualize
    than a complex sequence of statements.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å‡½æ•°å¼è¯­è¨€ä¸­ï¼Œæˆ‘ä»¬ç”¨è¯„ä¼°å‡½æ•°çš„æ›´ç®€å•æ¦‚å¿µæ¥æ›¿æ¢çŠ¶æ€â€”â€”å˜é‡çš„å˜åŒ–å€¼ã€‚æ¯æ¬¡å‡½æ•°è¯„ä¼°éƒ½ä»ç°æœ‰å¯¹è±¡åˆ›å»ºæ–°çš„å¯¹è±¡æˆ–å¯¹è±¡ã€‚ç”±äºå‡½æ•°å¼ç¨‹åºæ˜¯å‡½æ•°çš„ç»„åˆï¼Œæˆ‘ä»¬å¯ä»¥è®¾è®¡æ˜“äºç†è§£çš„åº•å±‚å‡½æ•°ï¼Œç„¶ååˆ›å»ºå‡½æ•°çš„ç»„åˆï¼Œè¿™äº›ç»„åˆæ¯”å¤æ‚çš„è¯­å¥åºåˆ—æ›´å®¹æ˜“å¯è§†åŒ–ã€‚
- en: Function evaluation more closely parallels mathematical formalisms. Because
    of this, we can often use simple algebra to design an algorithm that clearly handles
    the edge cases and boundary conditions. This makes us more confident that the
    functions work. It also makes it easy to locate test cases for formal unit testing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: å‡½æ•°è¯„ä¼°æ›´æ¥è¿‘æ•°å­¦å½¢å¼åŒ–ã€‚æ­£å› ä¸ºå¦‚æ­¤ï¼Œæˆ‘ä»¬é€šå¸¸å¯ä»¥ä½¿ç”¨ç®€å•çš„ä»£æ•°æ¥è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œè¯¥ç®—æ³•å¯ä»¥æ¸…æ¥šåœ°å¤„ç†è¾¹ç¼˜æƒ…å†µå’Œè¾¹ç•Œæ¡ä»¶ã€‚è¿™ä½¿å¾—æˆ‘ä»¬æ›´æœ‰ä¿¡å¿ƒå‡½æ•°æ˜¯æœ‰æ•ˆçš„ã€‚è¿™ä¹Ÿä½¿å¾—å®šä½å½¢å¼åŒ–å•å…ƒæµ‹è¯•çš„æµ‹è¯•ç”¨ä¾‹å˜å¾—å®¹æ˜“ã€‚
- en: Itâ€™s important to note that functional programs tend to be relatively succinct,
    expressive, and efficient compared to imperative (object-oriented or procedural)
    programs. The benefit isnâ€™t automatic; it requires careful design. This design
    effort for functional programming is often smaller than for procedural programming.
    Some developers experienced in imperative and object-oriented styles may find
    it a challenge to shift their focus from stateful designs to functional designs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: é‡è¦çš„æ˜¯è¦æ³¨æ„ï¼Œä¸å‘½ä»¤å¼ï¼ˆé¢å‘å¯¹è±¡æˆ–è¿‡ç¨‹å¼ï¼‰ç¨‹åºç›¸æ¯”ï¼Œå‡½æ•°å¼ç¨‹åºé€šå¸¸ç›¸å¯¹ç®€æ´ã€è¡¨è¾¾æ€§å¼ºä¸”æ•ˆç‡é«˜ã€‚è¿™ç§å¥½å¤„ä¸æ˜¯è‡ªåŠ¨çš„ï¼›å®ƒéœ€è¦ä»”ç»†çš„è®¾è®¡ã€‚å¯¹äºå‡½æ•°å¼ç¼–ç¨‹çš„è®¾è®¡å·¥ä½œé€šå¸¸æ¯”è¿‡ç¨‹å¼ç¼–ç¨‹å°ã€‚ä¸€äº›æœ‰å‘½ä»¤å¼å’Œé¢å‘å¯¹è±¡é£æ ¼ç»éªŒçš„å¼€å‘è€…å¯èƒ½å‘ç°ï¼Œä»æœ‰çŠ¶æ€çš„è®¾è®¡è½¬å‘å‡½æ•°å¼è®¾è®¡æ˜¯ä¸€ä¸ªæŒ‘æˆ˜ã€‚
- en: 1.2 Comparing and contrasting procedural and functional styles
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2 æ¯”è¾ƒå’Œå¯¹æ¯”è¿‡ç¨‹å¼å’Œå‡½æ•°å¼é£æ ¼
- en: Weâ€™ll use a tiny example program to illustrate a non-functional, or procedural,
    style of programming. This example computes a sum of a sequence of numbers. Each
    of the numbers has a specific property that makes it part of the sequence.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†ä½¿ç”¨ä¸€ä¸ªå°å‹ç¤ºä¾‹ç¨‹åºæ¥å±•ç¤ºéå‡½æ•°å¼ï¼Œæˆ–è¿‡ç¨‹å¼ï¼Œçš„ç¼–ç¨‹é£æ ¼ã€‚æ­¤ç¤ºä¾‹è®¡ç®—ä¸€ç³»åˆ—æ•°å­—çš„æ€»å’Œã€‚æ¯ä¸ªæ•°å­—éƒ½æœ‰ç‰¹å®šçš„å±æ€§ï¼Œä½¿å…¶æˆä¸ºåºåˆ—çš„ä¸€éƒ¨åˆ†ã€‚
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The sum computed by this function includes only numbers that are multiples of
    3 or 5\. Weâ€™ve made this program strictly procedural, avoiding any explicit use
    of Pythonâ€™s object features. The functionâ€™s state is defined by the values of
    the variables `s` and `n`. The variable `n` takes on values such that 1 â‰¤ n <
    10\. As the iteration involves an ordered exploration of values for the `n` variable,
    we can prove that it will terminate when the value of `n` is equal to the value
    of `limit`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªå‡½æ•°è®¡ç®—çš„æ€»å’ŒåªåŒ…æ‹¬3æˆ–5çš„å€æ•°ã€‚æˆ‘ä»¬ä½¿è¿™ä¸ªç¨‹åºä¸¥æ ¼éµå¾ªè¿‡ç¨‹å¼ï¼Œé¿å…ä»»ä½•æ˜¾å¼ä½¿ç”¨Pythonçš„å¯¹è±¡ç‰¹æ€§ã€‚å‡½æ•°çš„çŠ¶æ€ç”±å˜é‡`s`å’Œ`n`çš„å€¼å®šä¹‰ã€‚å˜é‡`n`å–å€¼èŒƒå›´ä¸º1
    â‰¤ n < 10ã€‚ç”±äºè¿­ä»£æ¶‰åŠå¯¹`n`å˜é‡å€¼çš„æœ‰åºæ¢ç´¢ï¼Œæˆ‘ä»¬å¯ä»¥è¯æ˜å½“`n`çš„å€¼ç­‰äº`limit`çš„å€¼æ—¶ï¼Œè¿­ä»£å°†ç»ˆæ­¢ã€‚
- en: There are two explicit assignment statements, both setting values for the `s`
    variable. These state changes are visible. The value of `n` is set implicitly
    by the `for` statement. The state change in the `s` variable is an essential element
    of the state of the computation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰ä¸¤ä¸ªæ˜¾å¼èµ‹å€¼è¯­å¥ï¼Œéƒ½ç”¨äºè®¾ç½®`s`å˜é‡çš„å€¼ã€‚è¿™äº›çŠ¶æ€å˜åŒ–æ˜¯å¯è§çš„ã€‚`n`çš„å€¼ç”±`for`è¯­å¥éšå¼è®¾ç½®ã€‚`s`å˜é‡ä¸­çš„çŠ¶æ€å˜åŒ–æ˜¯è®¡ç®—çŠ¶æ€çš„ä¸€ä¸ªåŸºæœ¬å…ƒç´ ã€‚
- en: Now letâ€™s look at this again from a purely functional perspective. Then, weâ€™ll
    examine a more Pythonic perspective that retains the essence of a functional approach
    while leveraging a number of Pythonâ€™s features.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬ä»çº¯ç²¹çš„åŠŸèƒ½è§’åº¦å†æ¬¡å®¡è§†è¿™ä¸ªé—®é¢˜ã€‚ç„¶åï¼Œæˆ‘ä»¬å°†ä»æ›´Pythonicçš„è§’åº¦æ¥å®¡è§†ï¼Œå®ƒä¿ç•™äº†å‡½æ•°å¼æ–¹æ³•çš„æ ¸å¿ƒï¼ŒåŒæ—¶åˆ©ç”¨äº†Pythonçš„ä¸€äº›ç‰¹æ€§ã€‚
- en: 1.2.1 Using the functional paradigm
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.1 ä½¿ç”¨å‡½æ•°å¼èŒƒå¼
- en: 'In a functional sense, the sum of the multiples of 3 and 5 can be decomposed
    into two parts:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å‡½æ•°å¼æ„ä¹‰ä¸Šï¼Œ3å’Œ5çš„å€æ•°ä¹‹å’Œå¯ä»¥åˆ†è§£ä¸ºä¸¤éƒ¨åˆ†ï¼š
- en: The sum of a sequence of numbers
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ•°å­—åºåˆ—çš„æ€»å’Œ
- en: A sequence of values that pass a simple test condition, for example, being multiples
    of 3 and 5
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ç³»åˆ—é€šè¿‡ç®€å•æµ‹è¯•æ¡ä»¶çš„å€¼ï¼Œä¾‹å¦‚ï¼Œæ˜¯3å’Œ5çš„å€æ•°
- en: 'To be super formal, we can define the sum as a function using simpler language
    components. The sum of a sequence has a recursive definition:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†éå¸¸æ­£å¼ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ›´ç®€å•çš„è¯­è¨€ç»„ä»¶å®šä¹‰æ€»å’Œä½œä¸ºä¸€ä¸ªå‡½æ•°ã€‚åºåˆ—çš„æ€»å’Œæœ‰ä¸€ä¸ªé€’å½’å®šä¹‰ï¼š
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Weâ€™ve defined the sum in two cases. The base case states that the sum of a zero-length
    sequence is 0\. The recursive case states that the sum of a sequence is the first
    value plus the sum of the rest of the sequence. Since the recursive definition
    depends on a shorter sequence, we can be sure that it will (eventually) devolve
    to the base case.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨ä¸¤ç§æƒ…å†µä¸‹å®šä¹‰äº†æ€»å’Œã€‚åŸºæœ¬æ¡ˆä¾‹æŒ‡å‡ºï¼Œé›¶é•¿åº¦åºåˆ—çš„æ€»å’Œæ˜¯0ã€‚é€’å½’æ¡ˆä¾‹æŒ‡å‡ºï¼Œåºåˆ—çš„æ€»å’Œæ˜¯ç¬¬ä¸€ä¸ªå€¼åŠ ä¸Šåºåˆ—å‰©ä½™éƒ¨åˆ†çš„æ€»å’Œã€‚ç”±äºé€’å½’å®šä¹‰ä¾èµ–äºè¾ƒçŸ­çš„åºåˆ—ï¼Œæˆ‘ä»¬å¯ä»¥ç¡®ä¿¡å®ƒæœ€ç»ˆä¼šé€€åŒ–åˆ°åŸºæœ¬æ¡ˆä¾‹ã€‚
- en: 'Here are some examples of how this function works:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢æ˜¯æ­¤å‡½æ•°å·¥ä½œçš„ä¸€äº›ç¤ºä¾‹ï¼š
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first example computes the sum of a list with multiple items. The second
    example shows how the recursion rule works by adding the first item, `seq[0]`,
    to the sum of the remaining items, `sumr(seq[1:])`. Eventually, the computation
    of the result involves the sum of an empty list, which is defined as 0.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ä¸ªä¾‹å­è®¡ç®—äº†ä¸€ä¸ªåŒ…å«å¤šä¸ªé¡¹ç›®çš„åˆ—è¡¨çš„æ€»å’Œã€‚ç¬¬äºŒä¸ªä¾‹å­é€šè¿‡å°†ç¬¬ä¸€ä¸ªé¡¹ç›®`seq[0]`åŠ åˆ°å‰©ä½™é¡¹ç›®çš„æ€»å’Œ`sumr(seq[1:])`æ¥å±•ç¤ºé€’å½’è§„åˆ™çš„å·¥ä½œæ–¹å¼ã€‚æœ€ç»ˆï¼Œç»“æœçš„è®¡ç®—æ¶‰åŠåˆ°ä¸€ä¸ªç©ºåˆ—è¡¨çš„æ€»å’Œï¼Œå®ƒè¢«å®šä¹‰ä¸º0ã€‚
- en: 'The `+` operator on the last line of the `sumr` function and the initial value
    of 0 in the base case characterize the equation as a sum. Consider what would
    happen if we changed the operator to `*` and the initial value to 1: this new
    expression would compute a product. Weâ€™ll return to this simple idea of generalization
    in the following chapters.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`sumr`å‡½æ•°æœ€åä¸€è¡Œçš„`+`è¿ç®—ç¬¦å’ŒåŸºæœ¬æ¡ˆä¾‹ä¸­çš„åˆå§‹å€¼0å°†æ–¹ç¨‹å®šä¹‰ä¸ºæ€»å’Œã€‚è€ƒè™‘å¦‚æœæˆ‘ä»¬æŠŠè¿ç®—ç¬¦æ”¹ä¸º`*`å¹¶å°†åˆå§‹å€¼æ”¹ä¸º1ä¼šå‘ç”Ÿä»€ä¹ˆï¼šè¿™ä¸ªæ–°è¡¨è¾¾å¼å°†è®¡ç®—ä¹˜ç§¯ã€‚æˆ‘ä»¬å°†åœ¨æ¥ä¸‹æ¥çš„ç« èŠ‚ä¸­å›åˆ°è¿™ä¸ªç®€å•çš„æ³›åŒ–æ€æƒ³ã€‚'
- en: 'Similarly, generating a sequence of values with a given property can have a
    recursive definition, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ç±»ä¼¼åœ°ï¼Œç”Ÿæˆå…·æœ‰ç»™å®šå±æ€§çš„å€¼åºåˆ—å¯ä»¥æœ‰ä¸€ä¸ªé€’å½’å®šä¹‰ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this function, weâ€™ve compared a given value, `v`, against the upper bound,
    `limit`. If `v` has reached the upper bound, the resulting list must be empty.
    This is the base case for the given recursion.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªå‡½æ•°ä¸­ï¼Œæˆ‘ä»¬æ¯”è¾ƒäº†ç»™å®šçš„å€¼`v`ä¸ä¸Šé™`limit`ã€‚å¦‚æœ`v`è¾¾åˆ°äº†ä¸Šé™ï¼Œé‚£ä¹ˆç»“æœåˆ—è¡¨å¿…é¡»æ˜¯ç©ºçš„ã€‚è¿™æ˜¯ç»™å®šé€’å½’çš„åŸºæœ¬æ¡ˆä¾‹ã€‚
- en: There are two more cases defined by an externally defined `filter_func()` function.
    The value of `v` is passed by the `filter_func()` function; if this returns a
    very small list, containing one element, this can be concatenated with any remaining
    values computed by the `until()` function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰ä¸¤ä¸ªæ›´å¤šçš„æƒ…å†µæ˜¯ç”±ä¸€ä¸ªå¤–éƒ¨å®šä¹‰çš„`filter_func()`å‡½æ•°å®šä¹‰çš„ã€‚`v`çš„å€¼æ˜¯é€šè¿‡`filter_func()`å‡½æ•°ä¼ é€’çš„ï¼›å¦‚æœè¿™ä¸ªå‡½æ•°è¿”å›ä¸€ä¸ªéå¸¸çŸ­çš„åˆ—è¡¨ï¼ŒåŒ…å«ä¸€ä¸ªå…ƒç´ ï¼Œè¿™ä¸ªå…ƒç´ å¯ä»¥ä¸`until()`å‡½æ•°è®¡ç®—å‡ºçš„ä»»ä½•å‰©ä½™å€¼è¿æ¥èµ·æ¥ã€‚
- en: If the value of `v` is rejected by the `filter_func()` function, this value
    is ignored and the result is simply defined by any remaining values computed by
    the `until()` function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœ`v`çš„å€¼è¢«`filter_func()`å‡½æ•°æ‹’ç»ï¼Œè¿™ä¸ªå€¼å°†è¢«å¿½ç•¥ï¼Œç»“æœç®€å•åœ°ç”±`until()`å‡½æ•°è®¡ç®—å‡ºçš„ä»»ä½•å‰©ä½™å€¼å®šä¹‰ã€‚
- en: We can see that the value of `v` will increase from an initial value until it
    reaches `limit`, assuring us that weâ€™ll reach the base case.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œ`v`çš„å€¼å°†ä»åˆå§‹å€¼å¢åŠ åˆ°`limit`ï¼Œè¿™ç¡®ä¿æˆ‘ä»¬å°†è¾¾åˆ°åŸºæœ¬æƒ…å†µã€‚
- en: 'Before we can see how to use the `until()` function, weâ€™ll define a small function
    to filter values that are multiples of 3 or 5:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬èƒ½å¤Ÿçœ‹åˆ°å¦‚ä½•ä½¿ç”¨`until()`å‡½æ•°ä¹‹å‰ï¼Œæˆ‘ä»¬å°†å®šä¹‰ä¸€ä¸ªå°å‡½æ•°æ¥è¿‡æ»¤å‡º3æˆ–5çš„å€æ•°ï¼š
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We could also have defined this as a lambda object to emphasize succinct definitions
    of simple functions. Anything more complex than a one-line expression requires
    the `def` statement.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¹Ÿå¯ä»¥å°†å…¶å®šä¹‰ä¸ºlambdaå¯¹è±¡ï¼Œä»¥å¼ºè°ƒç®€å•å‡½æ•°çš„ç®€æ´å®šä¹‰ã€‚ä»»ä½•è¶…è¿‡ä¸€è¡Œè¡¨è¾¾å¼çš„å¤æ‚åº¦éƒ½éœ€è¦`def`è¯­å¥ã€‚
- en: 'This function can be combined with the `until()` function to generate a sequence
    of values, which are multiples of 3 and 5\. Hereâ€™s an example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªå‡½æ•°å¯ä»¥ä¸`until()`å‡½æ•°ç»“åˆç”Ÿæˆä¸€ä¸ªå€¼åºåˆ—ï¼Œè¿™äº›å€¼æ˜¯3å’Œ5çš„å€æ•°ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼š
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Looking back at the decomposition at the top of this section, we now have a
    way to compute sums and a way to compute the sequence of values.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: å›é¡¾æœ¬èŠ‚é¡¶éƒ¨çš„åˆ†è§£ï¼Œæˆ‘ä»¬ç°åœ¨æœ‰äº†ä¸€ç§è®¡ç®—æ€»å’Œçš„æ–¹æ³•ï¼Œä¹Ÿæœ‰äº†ä¸€ç§è®¡ç®—å€¼åºåˆ—çš„æ–¹æ³•ã€‚
- en: 'We can combine the `sumr()` and `until()` functions to compute a sum of values.
    Hereâ€™s the resulting code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥å°†`sumr()`å’Œ`until()`å‡½æ•°ç»“åˆèµ·æ¥è®¡ç®—å€¼çš„æ€»å’Œã€‚ä»¥ä¸‹æ˜¯ç”Ÿæˆçš„ä»£ç ï¼š
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This small application to compute a sum doesnâ€™t make use of the assignment statement
    to set the values of variables. It is a purely functional, recursive definition
    that matches the mathematical abstractions, making it easier to reason about.
    We can be confident each piece works separately, giving confidence in the whole.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªç”¨äºè®¡ç®—æ€»å’Œçš„å°ç¨‹åºæ²¡æœ‰ä½¿ç”¨èµ‹å€¼è¯­å¥æ¥è®¾ç½®å˜é‡çš„å€¼ã€‚è¿™æ˜¯ä¸€ä¸ªçº¯ç²¹çš„å‡½æ•°å¼ã€é€’å½’å®šä¹‰ï¼Œä¸æ•°å­¦æŠ½è±¡ç›¸åŒ¹é…ï¼Œè¿™ä½¿å¾—æ¨ç†æ›´å®¹æ˜“ã€‚æˆ‘ä»¬å¯ä»¥ç¡®ä¿¡æ¯ä¸ªéƒ¨åˆ†éƒ½èƒ½å•ç‹¬å·¥ä½œï¼Œä»è€Œå¯¹æ•´ä½“æœ‰ä¿¡å¿ƒã€‚
- en: As a practical matter, weâ€™ll use a number of Python features to simplify creating
    functional programs. Weâ€™ll take a look at a number of these optimizations in the
    next version of this example.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºå®é™…æ“ä½œï¼Œæˆ‘ä»¬å°†ä½¿ç”¨è®¸å¤šPythonç‰¹æ€§æ¥ç®€åŒ–åˆ›å»ºå‡½æ•°å¼ç¨‹åºã€‚æˆ‘ä»¬å°†åœ¨æœ¬ä¾‹çš„ä¸‹ä¸€ä¸ªç‰ˆæœ¬ä¸­æŸ¥çœ‹è¿™äº›ä¼˜åŒ–çš„ä¸€äº›ä¾‹å­ã€‚
- en: 1.2.2 Using a functional hybrid
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.2 ä½¿ç”¨å‡½æ•°å¼æ··åˆ
- en: 'Weâ€™ll continue this example with a mostly functional version of the previous
    example to compute the sum of multiples of 3 and 5\. Our hybrid functional version
    might look like the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†ç»§ç»­ä½¿ç”¨å‰ä¸€ä¸ªä¾‹å­çš„ä¸€ä¸ªä¸»è¦å‡½æ•°å¼ç‰ˆæœ¬æ¥è®¡ç®—3å’Œ5çš„å€æ•°çš„å’Œã€‚æˆ‘ä»¬çš„æ··åˆå‡½æ•°å¼ç‰ˆæœ¬å¯èƒ½çœ‹èµ·æ¥åƒä»¥ä¸‹è¿™æ ·ï¼š
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Weâ€™ve used a generator expression to iterate through a collection of values
    and compute the sum of these values. The `range(1,``Â 10)` object is an iterable;
    it generates a sequence of values {nâˆ£1 â‰¤ n < 10}, often summarized as â€œvalues
    of n such that 1 is less than or equal to n and n is less than 10.â€ The more complex
    expression `n``Â for``Â n``Â in``Â range(1,``Â 10)``Â if``Â n``Â %``Â 3``Â ==``Â 0``Â or``Â n`
    `%``Â 5``Â ==``Â 0` is also a generator. It produces a set of values, {nâˆ£1 â‰¤ n <
    10 âˆ§ (n â‰¡ 0 mod 3 âˆ¨n â‰¡ 0 mod 5)}; something we can describe as â€œvalues of n such
    that 1 is less than or equal to n and n is less than 10 and n is equivalent to
    0 modulo 3 or n is equivalent to 0 modulo 5.â€ These are multiples of 3 and 5 taken
    from the set of values between 1 and 10\. The variable `n` is bound, in turn,
    to each of the values provided by the `range` object. The `sum()` function consumes
    the iterable values, creating a final object, 23.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»ä½¿ç”¨ç”Ÿæˆå™¨è¡¨è¾¾å¼éå†å€¼é›†åˆå¹¶è®¡ç®—è¿™äº›å€¼çš„æ€»å’Œã€‚`range(1, 10)`å¯¹è±¡æ˜¯ä¸€ä¸ªå¯è¿­ä»£å¯¹è±¡ï¼›å®ƒç”Ÿæˆä¸€ä¸ªå€¼åºåˆ—{nâˆ£1 â‰¤ n < 10}ï¼Œé€šå¸¸æ€»ç»“ä¸ºâ€œnçš„å€¼ï¼Œå…¶ä¸­1å°äºæˆ–ç­‰äºnä¸”nå°äº10ã€‚â€æ›´å¤æ‚çš„è¡¨è¾¾å¼`n
    for n in range(1, 10) if n % 3 == 0 or n % 5 == 0`ä¹Ÿæ˜¯ä¸€ä¸ªç”Ÿæˆå™¨ã€‚å®ƒç”Ÿæˆä¸€ç»„å€¼ï¼Œ{nâˆ£1 â‰¤ n < 10
    âˆ§ (n â‰¡ 0 mod 3 âˆ¨ n â‰¡ 0 mod 5)}ï¼›æˆ‘ä»¬å¯ä»¥æè¿°ä¸ºâ€œnçš„å€¼ï¼Œå…¶ä¸­1å°äºæˆ–ç­‰äºnä¸”nå°äº10ï¼Œä¸”nä¸3åŒä½™0æˆ–nä¸5åŒä½™0ã€‚â€è¿™äº›æ˜¯ä»1åˆ°10çš„é›†åˆä¸­å–å‡ºçš„3å’Œ5çš„å€æ•°ã€‚å˜é‡`n`ä¾æ¬¡ç»‘å®šåˆ°`range`å¯¹è±¡æä¾›çš„æ¯ä¸ªå€¼ã€‚`sum()`å‡½æ•°æ¶ˆè€—å¯è¿­ä»£çš„å€¼ï¼Œåˆ›å»ºä¸€ä¸ªæœ€ç»ˆå¯¹è±¡ï¼Œ23ã€‚
- en: The bound variable, `n`, doesnâ€™t exist outside the generator expression. The
    variable `n` isnâ€™t visible elsewhere in the program.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ç»‘å®šçš„å˜é‡`n`åœ¨ç”Ÿæˆå™¨è¡¨è¾¾å¼ä¹‹å¤–ä¸å­˜åœ¨ã€‚å˜é‡`n`åœ¨ç¨‹åºçš„å…¶ä»–åœ°æ–¹æ˜¯ä¸å¯è§çš„ã€‚
- en: 'The variable `n` in this example isnâ€™t directly comparable to the variable
    `n` in the first two imperative examples. A `for` statement (outside a generator
    expression) creates a proper variable in the local namespace. The generator expression
    does not create a variable in the same way that a `for` statement does:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œå˜é‡`n`ä¸å‰é¢ä¸¤ä¸ªå‘½ä»¤å¼ç¤ºä¾‹ä¸­çš„å˜é‡`n`å¹¶ä¸ç›´æ¥å¯æ¯”ã€‚ä¸€ä¸ª`for`è¯­å¥ï¼ˆåœ¨ç”Ÿæˆå™¨è¡¨è¾¾å¼ä¹‹å¤–ï¼‰åœ¨å±€éƒ¨å‘½åç©ºé—´ä¸­åˆ›å»ºäº†ä¸€ä¸ªæ­£ç¡®çš„å˜é‡ã€‚ç”Ÿæˆå™¨è¡¨è¾¾å¼ä¸ä¼šä»¥ä¸`for`è¯­å¥ç›¸åŒçš„æ–¹å¼åˆ›å»ºå˜é‡ï¼š
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The generator expression doesnâ€™t pollute the namespace with variables, like
    `n`, which arenâ€™t relevant outside the very narrow context of the expression.
    This is a pleasant feature that ensures we wonâ€™t be confused by the values of
    variables that donâ€™t have a meaning outside a single expression.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ç”Ÿæˆå™¨è¡¨è¾¾å¼ä¸ä¼šåƒå˜é‡`n`é‚£æ ·æ±¡æŸ“å‘½åç©ºé—´ï¼Œå› ä¸º`n`åœ¨è¡¨è¾¾å¼çš„éå¸¸ç‹­çª„çš„ä¸Šä¸‹æ–‡ä¸­ä¹‹å¤–æ²¡æœ‰ç›¸å…³æ€§ã€‚è¿™æ˜¯ä¸€ä¸ªä»¤äººæ„‰å¿«çš„ç‰¹æ€§ï¼Œç¡®ä¿æˆ‘ä»¬ä¸ä¼šå› ä¸ºé‚£äº›åœ¨å•ä¸ªè¡¨è¾¾å¼ä¹‹å¤–æ²¡æœ‰æ„ä¹‰çš„å˜é‡çš„å€¼è€Œæ„Ÿåˆ°å›°æƒ‘ã€‚
- en: 1.2.3 The stack of turtles
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.3 ä¹Œé¾Ÿå †æ ˆ
- en: When we use Python for functional programming, we embark down a path that will
    involve a hybrid thatâ€™s not strictly functional. Python is not Haskell, OCaml,
    or Erlang. For that matter, our underlying processor hardware is not functional;
    itâ€™s not even strictly object-oriented, as CPUs are generally procedural.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬ä½¿ç”¨Pythonè¿›è¡Œå‡½æ•°å¼ç¼–ç¨‹æ—¶ï¼Œæˆ‘ä»¬å°†è¸ä¸Šä¸€æ¡æ¶‰åŠéä¸¥æ ¼å‡½æ•°å¼æ··åˆçš„é“è·¯ã€‚Pythonä¸æ˜¯Haskellã€OCamlæˆ–Erlangã€‚å°±åº•å±‚å¤„ç†å™¨ç¡¬ä»¶è€Œè¨€ï¼Œå®ƒä¹Ÿä¸æ˜¯å‡½æ•°å¼çš„ï¼›å®ƒç”šè‡³ä¸æ˜¯ä¸¥æ ¼é¢å‘å¯¹è±¡çš„ï¼Œå› ä¸ºCPUé€šå¸¸æ˜¯è¿‡ç¨‹å¼çš„ã€‚
- en: '*All programming languages rest on abstractions, libraries, frameworks and
    virtual machines. These abstractions, in turn, may rely on other abstractions,
    libraries, frameworks and virtual machines. The most apt metaphor is this: the
    world is carried on the back of a giant turtle. The turtle stands on the back
    of another giant turtle. And that turtle, in turn, is standing on the back of
    yet another turtle.*'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*æ‰€æœ‰ç¼–ç¨‹è¯­è¨€éƒ½å»ºç«‹åœ¨æŠ½è±¡ã€åº“ã€æ¡†æ¶å’Œè™šæ‹Ÿæœºä¹‹ä¸Šã€‚è¿™äº›æŠ½è±¡åè¿‡æ¥å¯èƒ½ä¾èµ–äºå…¶ä»–æŠ½è±¡ã€åº“ã€æ¡†æ¶å’Œè™šæ‹Ÿæœºã€‚æœ€æ°å½“çš„éšå–»æ˜¯è¿™æ ·çš„ï¼šä¸–ç•Œæ˜¯å»ºç«‹åœ¨ä¸€åªå·¨å¤§çš„ä¹Œé¾ŸèƒŒä¸Šçš„ã€‚è¿™åªä¹Œé¾Ÿç«™åœ¨å¦ä¸€åªå·¨å¤§çš„ä¹Œé¾ŸèƒŒä¸Šã€‚è€Œè¿™åªä¹Œé¾Ÿï¼Œåˆç«™åœ¨å¦ä¸€åªä¹Œé¾Ÿçš„èƒŒä¸Š.*'
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Itâ€™s turtles all the way down.*'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*ä¸€åˆ‡çš†ç”±ä¹Œé¾Ÿç»„æˆã€‚*'
- en: ''
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*â€” Anonymous*'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*â€”â€” åŒ¿å*'
- en: Thereâ€™s no practical end to the layers of abstractions. Even something as concrete
    as circuits and electronics may be an abstraction to help designers summarize
    the details of quantum electrodynamics.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: å±‚å±‚æŠ½è±¡æ²¡æœ‰å®é™…çš„ä¸Šé™ã€‚å³ä½¿æ˜¯åƒç”µè·¯å’Œç”µå­è¿™æ ·çš„å…·ä½“äº‹ç‰©ï¼Œä¹Ÿå¯èƒ½æ˜¯ä¸ºäº†å¸®åŠ©è®¾è®¡è€…æ€»ç»“é‡å­ç”µåŠ¨åŠ›å­¦çš„ç»†èŠ‚è€Œè¿›è¡Œçš„æŠ½è±¡ã€‚
- en: More importantly, the presence of abstractions and virtual machines doesnâ€™t
    materially change our approach to designing software to exploit the functional
    programming features of Python.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: æ›´é‡è¦çš„æ˜¯ï¼ŒæŠ½è±¡å’Œè™šæ‹Ÿæœºçš„å­˜åœ¨å¹¶æ²¡æœ‰å®è´¨æ€§åœ°æ”¹å˜æˆ‘ä»¬è®¾è®¡è½¯ä»¶ä»¥åˆ©ç”¨Pythonå‡½æ•°å¼ç¼–ç¨‹ç‰¹æ€§çš„æ–¹æ³•ã€‚
- en: Even within the functional programming community, there are both purer and less
    pure functional programming languages. Some languages make extensive use of monads
    to handle stateful things such as file system input and output. Other languages
    rely on a hybridized environment thatâ€™s similar to the way we use Python. In Python,
    software can be generally functional, with carefully chosen procedural exceptions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: å³ä½¿åœ¨å‡½æ•°å¼ç¼–ç¨‹ç¤¾åŒºå†…éƒ¨ï¼Œä¹Ÿå­˜åœ¨æ›´çº¯ç²¹å’Œä¸å¤ªçº¯ç²¹çš„å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ã€‚æœ‰äº›è¯­è¨€å¹¿æ³›ä½¿ç”¨å•å­æ¥å¤„ç†è¯¸å¦‚æ–‡ä»¶ç³»ç»Ÿè¾“å…¥è¾“å‡ºè¿™æ ·çš„æœ‰çŠ¶æ€äº‹ç‰©ã€‚å…¶ä»–è¯­è¨€åˆ™ä¾èµ–äºç±»ä¼¼äºæˆ‘ä»¬ä½¿ç”¨Pythonçš„æ··åˆç¯å¢ƒã€‚åœ¨Pythonä¸­ï¼Œè½¯ä»¶å¯ä»¥ä¸€èˆ¬æ˜¯å‡½æ•°å¼çš„ï¼ŒåŒæ—¶ç²¾å¿ƒé€‰æ‹©è¿‡ç¨‹å¼å¼‚å¸¸ã€‚
- en: 'Our functional Python programs will rely on the following three stacks of abstractions:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„å‡½æ•°å¼Pythonç¨‹åºå°†ä¾èµ–äºä»¥ä¸‹ä¸‰ä¸ªæŠ½è±¡å †æ ˆï¼š
- en: Our applications will be functionsâ€”all the way downâ€”until we hit the objects;
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„åº”ç”¨ç¨‹åºå°†ä¸€ç›´æ˜¯ä»¥å‡½æ•°çš„å½¢å¼å­˜åœ¨ï¼Œç›´åˆ°æˆ‘ä»¬è§¦åŠåˆ°å¯¹è±¡ï¼›
- en: The underlying Python runtime environment that supports our functional programming
    is objectsâ€”all the way downâ€”until we hit the libraries;
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ”¯æŒæˆ‘ä»¬å‡½æ•°å¼ç¼–ç¨‹çš„åº•å±‚Pythonè¿è¡Œæ—¶ç¯å¢ƒä¹Ÿæ˜¯ä»¥å¯¹è±¡çš„å½¢å¼å­˜åœ¨ï¼Œç›´åˆ°æˆ‘ä»¬è§¦åŠåˆ°åº“ï¼›
- en: The libraries that support Python are a turtle on which Python stands.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ”¯æŒPythonçš„åº“å°±åƒæ˜¯Pythonç«™ç«‹åœ¨ä¸Šçš„ä¹Œé¾Ÿã€‚
- en: The operating system and hardware form their own stack of turtles. These details
    arenâ€™t relevant to the problems weâ€™re going to solve.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: æ“ä½œç³»ç»Ÿå’Œç¡¬ä»¶å½¢æˆå®ƒä»¬è‡ªå·±çš„ä¹Œé¾Ÿå †æ ˆã€‚è¿™äº›ç»†èŠ‚ä¸æˆ‘ä»¬å³å°†è§£å†³çš„é—®é¢˜æ— å…³ã€‚
- en: 1.3 A classic example of functional programming
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3 å‡½æ•°å¼ç¼–ç¨‹çš„ç»å…¸ç¤ºä¾‹
- en: As part of our introduction, weâ€™ll look at a classic example of functional programming.
    This is based on the paper Why Functional Programming Matters by John Hughes.
    The article appeared in a paper called Research Topics in Functional Programming,
    edited by D. Turner, published by Addison-Wesley in 1990.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºæˆ‘ä»¬ä»‹ç»çš„ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†æŸ¥çœ‹ä¸€ä¸ªå‡½æ•°å¼ç¼–ç¨‹çš„ç»å…¸ç¤ºä¾‹ã€‚è¿™æ˜¯åŸºäºJohn Hughesçš„è®ºæ–‡ã€ŠWhy Functional Programming Mattersã€‹ã€‚è¿™ç¯‡æ–‡ç« å‘è¡¨åœ¨ç”±D.
    Turnerç¼–è¾‘çš„ã€ŠResearch Topics in Functional Programmingã€‹è®ºæ–‡é›†ä¸­ï¼Œç”±Addison-Wesleyäº1990å¹´å‡ºç‰ˆã€‚
- en: 'Hereâ€™s a link to one of the papers in Research Topics in Functional Programming,
    â€œWhy Functional Programming Mattersâ€: [http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf](http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€ä¸ªé“¾æ¥åˆ°ã€ŠResearch Topics in Functional Programmingã€‹ä¸­çš„ä¸€ç¯‡è®ºæ–‡ï¼Œâ€œWhy Functional Programming
    Mattersâ€ï¼š[http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf](http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf)
- en: 'This paper is a profound discussion of functional programming. There are several
    examples given. Weâ€™ll look at just one: the Newton-Raphson algorithm for locating
    any roots of a function. In this case, weâ€™ll define a function that will compute
    a square root of a number.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç¯‡è®ºæ–‡å¯¹å‡½æ•°å¼ç¼–ç¨‹è¿›è¡Œäº†æ·±åˆ»çš„è®¨è®ºã€‚ç»™å‡ºäº†å‡ ä¸ªç¤ºä¾‹ã€‚æˆ‘ä»¬å°†åªçœ‹å…¶ä¸­ä¸€ä¸ªï¼šç”¨äºå¯»æ‰¾å‡½æ•°ä»»ä½•æ ¹çš„ç‰›é¡¿-æ‹‰å¤«æ£®ç®—æ³•ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°†å®šä¹‰ä¸€ä¸ªè®¡ç®—æ•°å­—å¹³æ–¹æ ¹çš„å‡½æ•°ã€‚
- en: Itâ€™s important because many versions of this algorithm rely on the explicit
    state managed via loops. Indeed, the Hughes paper provides a snippet of the Fortran
    code that emphasizes stateful, imperative processing.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¾ˆé‡è¦ï¼Œå› ä¸ºè®¸å¤šè¿™ä¸ªç®—æ³•çš„ç‰ˆæœ¬ä¾èµ–äºé€šè¿‡å¾ªç¯æ˜¾å¼ç®¡ç†çš„çŠ¶æ€ã€‚ç¡®å®ï¼Œä¼‘æ–¯è®ºæ–‡æä¾›äº†ä¸€ä¸ªFortranä»£ç ç‰‡æ®µï¼Œå¼ºè°ƒäº†æœ‰çŠ¶æ€ã€å‘½ä»¤å¼çš„å¤„ç†ã€‚
- en: 'The backbone of this approximation is the calculation of the next approximation
    from the current approximation. The `next_()` function takes `x`, an approximation
    to the `sqrt(n)` value, and calculates a next value that brackets the proper root.
    Take a look at the following example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªè¿‘ä¼¼çš„éª¨æ¶æ˜¯ä»å½“å‰è¿‘ä¼¼è®¡ç®—ä¸‹ä¸€ä¸ªè¿‘ä¼¼å€¼ã€‚`next_()`å‡½æ•°æ¥å—`x`ï¼Œå³`sqrt(n)`å€¼çš„è¿‘ä¼¼ï¼Œå¹¶è®¡ç®—ä¸€ä¸ªåŒ…å›´æ­£ç¡®æ ¹çš„ä¸‹ä¸€ä¸ªå€¼ã€‚è¯·çœ‹ä»¥ä¸‹ç¤ºä¾‹ï¼š
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function computes a series of values that will quickly converge on some
    value x such that x = ![n x](img/file4.jpg), which means x = ![âˆš-- n](img/file5.jpg).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤å‡½æ•°è®¡ç®—ä¸€ç³»åˆ—å€¼ï¼Œè¿™äº›å€¼å°†è¿…é€Ÿæ”¶æ•›åˆ°æŸä¸ªå€¼xï¼Œä½¿å¾—x = ![n x](img/file4.jpg)ï¼Œè¿™æ„å‘³ç€x = ![âˆš-- n](img/file5.jpg)ã€‚
- en: Note that the name `next()` would collide with a built-in function. Calling
    it `next_()` lets us follow the original presentation as closely as possible,
    using Pythonic names.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œ`next()`è¿™ä¸ªåå­—ä¼šä¸å†…ç½®å‡½æ•°å†²çªã€‚å°†å…¶å‘½åä¸º`next_()`è®©æˆ‘ä»¬å°½å¯èƒ½æ¥è¿‘åŸå§‹æ¼”ç¤ºï¼Œä½¿ç”¨Pythonicçš„åå­—ã€‚
- en: 'Hereâ€™s how the function looks when used in Pythonâ€™s interactive REPL:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯å¦‚ä½•åœ¨Pythonçš„äº¤äº’å¼REPLä¸­ä½¿ç”¨è¯¥å‡½æ•°çš„ç¤ºä¾‹ï¼š
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We defined the `f()` function as a lambda that will converge on ![âˆš -- n](img/file6.jpg)
    where n = 2\. We started with 1.0 as the initial value for a[0]. Then we evaluated
    a sequence of recursive evaluations: a[1] = f(a[0]), a[2] = f(f(a[0])), and so
    on. We evaluated these functions using a generator expression so that we could
    round each value to four decimal places. This makes the output easier to read
    and easier to use with `doctest`. The sequence appears to converge rapidly on
    ![âˆš-- 2](img/file7.jpg). To get a more precise answer, we must continue to perform
    the series of steps after the first four shown above.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†`f()`å‡½æ•°å®šä¹‰ä¸ºlambdaï¼Œå®ƒå°†æ”¶æ•›åˆ°![âˆš -- n](img/file6.jpg)ï¼ˆå…¶ä¸­n = 2ï¼‰ã€‚æˆ‘ä»¬ä»¥1.0ä½œä¸ºa[0]çš„åˆå§‹å€¼ã€‚ç„¶åæˆ‘ä»¬è¯„ä¼°äº†ä¸€ç³»åˆ—é€’å½’è¯„ä¼°ï¼ša[1]
    = f(a[0])ï¼Œa[2] = f(f(a[0]))ï¼Œä¾æ­¤ç±»æ¨ã€‚æˆ‘ä»¬ä½¿ç”¨ç”Ÿæˆå™¨è¡¨è¾¾å¼è¯„ä¼°è¿™äº›å‡½æ•°ï¼Œä»¥ä¾¿å°†æ¯ä¸ªå€¼å››èˆäº”å…¥åˆ°å››ä½å°æ•°ã€‚è¿™ä½¿å¾—è¾“å‡ºæ›´å®¹æ˜“é˜…è¯»ï¼Œå¹¶ä¸”æ›´å®¹æ˜“ä¸`doctest`ä¸€èµ·ä½¿ç”¨ã€‚è¿™ä¸ªåºåˆ—ä¼¼ä¹è¿…é€Ÿæ”¶æ•›åˆ°![âˆš--
    2](img/file7.jpg)ã€‚ä¸ºäº†å¾—åˆ°æ›´ç²¾ç¡®çš„ç­”æ¡ˆï¼Œæˆ‘ä»¬å¿…é¡»ç»§ç»­æ‰§è¡Œä¸Šè¿°å››ä¸ªæ­¥éª¤ä¹‹åçš„æ­¥éª¤ã€‚
- en: 'We can write a function that will (in principle) generate an infinite sequence
    of a[i] values. This series will converge on the proper square root:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œç†è®ºä¸Šå¯ä»¥ç”Ÿæˆä¸€ä¸ªæ— é™åºåˆ—çš„a[i]å€¼ã€‚è¿™ä¸ªåºåˆ—å°†æ”¶æ•›åˆ°æ­£ç¡®çš„å¹³æ–¹æ ¹ï¼š
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function will generate a sequence of approximations using a function, `f()`,
    and an initial value, `a`. If we provide the `next_()` function defined earlier,
    weâ€™ll get a sequence of approximations to the square root of the `n` argument.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤å‡½æ•°å°†ä½¿ç”¨å‡½æ•°`f()`å’Œä¸€ä¸ªåˆå§‹å€¼`a`ç”Ÿæˆä¸€ç³»åˆ—è¿‘ä¼¼å€¼ã€‚å¦‚æœæˆ‘ä»¬æä¾›å‰é¢å®šä¹‰çš„`next_()`å‡½æ•°ï¼Œæˆ‘ä»¬å°†å¾—åˆ°ä¸€ç³»åˆ—å¯¹`n`å‚æ•°å¹³æ–¹æ ¹çš„è¿‘ä¼¼å€¼ã€‚
- en: The `repeat()` function expects the `f()` function to have a single argument;
    however, our `next_()` function has two arguments. Weâ€™ve used a lambda object,
    `lambda``Â x:``Â next_(n,``Â x)`, to create a partial version of the `next_()` function
    with one of two variables bound.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat()`å‡½æ•°æœŸæœ›`f()`å‡½æ•°æœ‰ä¸€ä¸ªå‚æ•°ï¼›ç„¶è€Œï¼Œæˆ‘ä»¬çš„`next_()`å‡½æ•°æœ‰ä¸¤ä¸ªå‚æ•°ã€‚æˆ‘ä»¬ä½¿ç”¨lambdaå¯¹è±¡`lambda x: next_(n,
    x)`åˆ›å»ºäº†ä¸€ä¸ªéƒ¨åˆ†ç‰ˆæœ¬çš„`next_()`å‡½æ•°ï¼Œå…¶ä¸­ä¸€ä¸ªå˜é‡è¢«ç»‘å®šã€‚'
- en: The Python generator functions canâ€™t be trivially recursive; they must explicitly
    iterate over the recursive results, yielding them individually.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Pythonçš„ç”Ÿæˆå™¨å‡½æ•°ä¸èƒ½ç®€å•åœ°é€’å½’ï¼›å®ƒä»¬å¿…é¡»æ˜¾å¼åœ°è¿­ä»£é€’å½’ç»“æœï¼Œå¹¶å•ç‹¬äº§ç”Ÿå®ƒä»¬ã€‚
- en: Attempting to use a simple `return``Â repeat(f,``Â f(a))` will end the iteration,
    returning a generator expression instead of yielding values.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: å°è¯•ä½¿ç”¨ç®€å•çš„`return` `repeat(f, f(a))`å°†ç»“æŸè¿­ä»£ï¼Œè¿”å›ä¸€ä¸ªç”Ÿæˆå™¨è¡¨è¾¾å¼è€Œä¸æ˜¯äº§ç”Ÿå€¼ã€‚
- en: 'There are two ways to return all the values instead of returning a generator
    expression, which are as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥è¿”å›æ‰€æœ‰å€¼è€Œä¸æ˜¯è¿”å›ä¸€ä¸ªç”Ÿæˆå™¨è¡¨è¾¾å¼ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: 'We can write an explicit `for` statement to yield values as follows:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ç¼–å†™ä¸€ä¸ªæ˜¾å¼çš„`for`è¯­å¥æ¥äº§ç”Ÿå€¼ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE12]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can use the `yield``Â from` expression as follows:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ–¹å¼ä½¿ç”¨`yield from`è¡¨è¾¾å¼ï¼š
- en: '[PRE13]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Both techniques of yielding the values of a recursive generator function are
    will have similar results. Weâ€™ll try to emphasize `yield``Â from`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸¤ç§äº§ç”Ÿé€’å½’ç”Ÿæˆå‡½æ•°å€¼çš„æŠ€å·§å°†ä¼šæœ‰ç±»ä¼¼çš„ç»“æœã€‚æˆ‘ä»¬å°†å°è¯•å¼ºè°ƒ`yield from`ã€‚
- en: 'It turns out that `yield` and `yield``Â from` are a bit more sophisticated than
    weâ€™ve shown here. For our purposes, weâ€™ll limit ourselves to working with recursive
    results. For more information on the full feature set for `yield` and `yield``Â from`,
    see PEP 342 and PEP 380: [https://peps.python.org/pep-0342/](https://peps.python.org/pep-0342/)
    and [https://peps.python.org/pep-0380/](https://peps.python.org/pep-0380/).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æœè¡¨æ˜`yield`å’Œ`yield from`æ¯”æˆ‘ä»¬åœ¨è¿™é‡Œå±•ç¤ºçš„è¦å¤æ‚ä¸€äº›ã€‚ä¸ºäº†æˆ‘ä»¬çš„ç›®çš„ï¼Œæˆ‘ä»¬å°†é™åˆ¶è‡ªå·±å¤„ç†é€’å½’ç»“æœã€‚æœ‰å…³`yield`å’Œ`yield
    from`çš„å®Œæ•´åŠŸèƒ½é›†çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…PEP 342å’ŒPEP 380ï¼š[https://peps.python.org/pep-0342/](https://peps.python.org/pep-0342/)
    å’Œ [https://peps.python.org/pep-0380/](https://peps.python.org/pep-0380/)ã€‚
- en: Of course, we donâ€™t want the entire infinite sequence created by the `repeat()`
    function. Itâ€™s essential to stop generating values when weâ€™ve found the square
    root weâ€™re looking for. The common symbol for the limit we can consider â€œclose
    enoughâ€ is the Greek letter epsilon, ğœ–.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œæˆ‘ä»¬ä¸æƒ³åˆ›å»ºç”±`repeat()`å‡½æ•°ç”Ÿæˆçš„æ•´ä¸ªæ— é™åºåˆ—ã€‚å½“æˆ‘ä»¬æ‰¾åˆ°æ‰€éœ€çš„å¹³æ–¹æ ¹æ—¶ï¼Œåœæ­¢ç”Ÿæˆå€¼æ˜¯è‡³å…³é‡è¦çš„ã€‚æˆ‘ä»¬å¯ä»¥è€ƒè™‘çš„â€œè¶³å¤Ÿæ¥è¿‘â€çš„æé™çš„å¸¸è§ç¬¦å·æ˜¯å¸Œè…Šå­—æ¯epsilonï¼Œğœ–ã€‚
- en: 'In Python, we have to be a little clever when taking items from an infinite
    sequence one at a time. It works out well to use a simple interface function that
    wraps a slightly more complex recursion. Take a look at the following code snippet:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Pythonä¸­ï¼Œå½“æˆ‘ä»¬ä¸€æ¬¡ä»æ— é™åºåˆ—ä¸­å–å‡ºä¸€ä¸ªå…ƒç´ æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»ç¨å¾®èªæ˜ä¸€ç‚¹ã€‚ä½¿ç”¨ä¸€ä¸ªç®€å•çš„æ¥å£å‡½æ•°æ¥åŒ…è£…ç¨å¾®å¤æ‚ä¸€äº›çš„é€’å½’æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„è§£å†³æ–¹æ¡ˆã€‚è¯·çœ‹ä»¥ä¸‹ä»£ç ç‰‡æ®µï¼š
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Weâ€™ve defined an internal function, `head_tail()`, which accepts the tolerance,
    ğœ–, an item from the iterable sequence, `a`, and the rest of the iterable sequence,
    `iterable`. The first item from the iterable, extracted with the `next()` function,
    is bound to a name, `b`. If |a âˆ’ b|â‰¤ ğœ–, the two values of `a` and `b` are close
    enough to call the value of `b` the square root; the difference is less than or
    equal to the very small value of ğœ–. Otherwise, we use the `b` value in a recursive
    invocation of the `head_tail()` function to examine the next pair of values.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªå†…éƒ¨å‡½æ•°`head_tail()`ï¼Œå®ƒæ¥å—å®¹å·®å€¼ğœ–ã€å¯è¿­ä»£åºåˆ—ä¸­çš„ä¸€ä¸ªå…ƒç´ `a`ä»¥åŠå¯è¿­ä»£åºåˆ—çš„å…¶ä½™éƒ¨åˆ†`iterable`ã€‚ä½¿ç”¨`next()`å‡½æ•°ä»å¯è¿­ä»£åºåˆ—ä¸­æå–çš„ç¬¬ä¸€ä¸ªå…ƒç´ ç»‘å®šåˆ°åç§°`b`ã€‚å¦‚æœ|a
    âˆ’ b|â‰¤ ğœ–ï¼Œåˆ™`a`å’Œ`b`çš„å€¼è¶³å¤Ÿæ¥è¿‘ï¼Œå¯ä»¥å°†`b`çš„å€¼ç§°ä¸ºå¹³æ–¹æ ¹ï¼›å·®å¼‚å°äºæˆ–ç­‰äºéå¸¸å°çš„å€¼ğœ–ã€‚å¦åˆ™ï¼Œæˆ‘ä»¬ä½¿ç”¨`b`å€¼åœ¨`head_tail()`å‡½æ•°çš„é€’å½’è°ƒç”¨ä¸­æ£€æŸ¥ä¸‹ä¸€å¯¹å€¼ã€‚
- en: Our `within()` function properly initializes the internal `head_tail()` function
    with the first value from the `iterable` parameter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„`within()`å‡½æ•°æ­£ç¡®åœ°åˆå§‹åŒ–äº†å†…éƒ¨`head_tail()`å‡½æ•°ï¼Œä½¿ç”¨`iterable`å‚æ•°çš„ç¬¬ä¸€ä¸ªå€¼ã€‚
- en: 'We can use the three functions, `next_()`, `repeat()`, and `within()`, to create
    a square root function, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸‰ä¸ªå‡½æ•°`next_()`ã€`repeat()`å’Œ`within()`æ¥åˆ›å»ºä¸€ä¸ªå¹³æ–¹æ ¹å‡½æ•°ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Weâ€™ve used the `repeat()` function to generate a (potentially) infinite sequence
    of values based on the `next_(n,x)` function. Our `within()` function will stop
    generating values in the sequence when it locates two values with a difference
    less than ğœ–.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä½¿ç”¨`repeat()`å‡½æ•°æ ¹æ®`next_(n,x)`å‡½æ•°ç”Ÿæˆä¸€ä¸ªï¼ˆå¯èƒ½ï¼‰æ— é™å€¼çš„åºåˆ—ã€‚æˆ‘ä»¬çš„`within()`å‡½æ•°å°†åœ¨æ‰¾åˆ°ä¸¤ä¸ªå·®å¼‚å°äºğœ–çš„å€¼æ—¶åœæ­¢ç”Ÿæˆåºåˆ—ä¸­çš„å€¼ã€‚
- en: This definition of the `sqrt()` function provides useful default values to the
    underlying `within()` function. It provides an ğœ– value of 0.0001 and an initial
    a[0] value of 1.0.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ª `sqrt()` å‡½æ•°çš„å®šä¹‰ä¸ºåº•å±‚çš„ `within()` å‡½æ•°æä¾›äº†æœ‰ç”¨çš„é»˜è®¤å€¼ã€‚å®ƒæä¾›äº†ä¸€ä¸ª ğœ– å€¼ä¸º 0.0001 å’Œä¸€ä¸ªåˆå§‹ a[0] å€¼ä¸º
    1.0ã€‚
- en: A more advanced version could use default parameter values to make changes possible.
    As an exercise, the definition of `sqrt()` can be rewritten so an expression such
    as `sqrt(1.0,``Â 0.000_01,``Â 3)` will start with an approximation of 1.0 and compute
    the value of ![âˆš -- 3](img/file8.jpg) to within 0.00001\. For most applications,
    the initial a[0] value can be 1.0\. However, the closer it is to the actual square
    root, the more rapidly this algorithm converges.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: æ›´é«˜çº§çš„ç‰ˆæœ¬å¯ä»¥ä½¿ç”¨é»˜è®¤å‚æ•°å€¼æ¥ä½¿æ›´æ”¹æˆä¸ºå¯èƒ½ã€‚ä½œä¸ºä¸€ä¸ªç»ƒä¹ ï¼Œ`sqrt()` çš„å®šä¹‰å¯ä»¥è¢«é‡å†™ï¼Œä»¥ä¾¿åƒ `sqrt(1.0, 0.000_01, 3)`
    è¿™æ ·çš„è¡¨è¾¾å¼å°†ä»¥ 1.0 çš„è¿‘ä¼¼å€¼å¼€å§‹ï¼Œå¹¶è®¡ç®— ![âˆš -- 3](img/file8.jpg) çš„å€¼ï¼Œç²¾ç¡®åˆ° 0.00001ã€‚å¯¹äºå¤§å¤šæ•°åº”ç”¨ï¼Œåˆå§‹ a[0]
    å€¼å¯ä»¥æ˜¯ 1.0ã€‚ç„¶è€Œï¼Œå®ƒè¶Šæ¥è¿‘å®é™…çš„å¹³æ–¹æ ¹ï¼Œè¿™ä¸ªç®—æ³•çš„æ”¶æ•›é€Ÿåº¦å°±è¶Šå¿«ã€‚
- en: The original example of this approximation algorithm was shown in the Miranda
    language. Itâ€™s easy to see there are some profound differences between Miranda
    and Python. In spite of the differences, the similarities give us confidence that
    many kinds of functional programming can be easily implemented in Python.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªè¿‘ä¼¼ç®—æ³•çš„åŸå§‹ç¤ºä¾‹æ˜¯åœ¨ Miranda è¯­è¨€ä¸­å±•ç¤ºçš„ã€‚å¾ˆå®¹æ˜“çœ‹å‡º Miranda å’Œ Python ä¹‹é—´å­˜åœ¨ä¸€äº›æ·±åˆ»çš„å·®å¼‚ã€‚å°½ç®¡æœ‰å·®å¼‚ï¼Œä½†ç›¸ä¼¼ä¹‹å¤„è®©æˆ‘ä»¬æœ‰ä¿¡å¿ƒè®¤ä¸ºè®¸å¤šç±»å‹çš„å‡½æ•°å¼ç¼–ç¨‹å¯ä»¥å¾ˆå®¹æ˜“åœ°åœ¨
    Python ä¸­å®ç°ã€‚
- en: The `within` function shown here is written to match the original articleâ€™s
    function definition. Pythonâ€™s `itertools` library provides a `takewhile()` function
    that might be better for this application than the `within()` function. Similarly,
    the `math.isclose()` function may be better than the `abs(a-b)``Â <=`ğœ– expression
    used here. Python offers a great many pre-built functional programming features;
    weâ€™ll look closely at these functions in [ChapterÂ 8](Chapter_08.xhtml#x1-1700008),
    [The Itertools Module](Chapter_08.xhtml#x1-1700008) and [ChapterÂ 9](Chapter_09.xhtml#x1-1990009),
    [Itertools for Combinatorics â€“ Permutations and Combinations](Chapter_09.xhtml#x1-1990009).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œå±•ç¤ºçš„ `within` å‡½æ•°æ˜¯æŒ‰ç…§åŸå§‹æ–‡ç« çš„å‡½æ•°å®šä¹‰ç¼–å†™çš„ã€‚Python çš„ `itertools` åº“æä¾›äº†ä¸€ä¸ª `takewhile()` å‡½æ•°ï¼Œå¯èƒ½æ¯”è¿™é‡Œçš„
    `within()` å‡½æ•°æ›´é€‚åˆè¿™ä¸ªåº”ç”¨ã€‚åŒæ ·ï¼Œ`math.isclose()` å‡½æ•°å¯èƒ½æ¯”è¿™é‡Œä½¿ç”¨çš„ `abs(a-b) <= ğœ–` è¡¨è¾¾å¼æ›´å¥½ã€‚Python
    æä¾›äº†å¤§é‡çš„é¢„æ„å»ºå‡½æ•°å¼ç¼–ç¨‹ç‰¹æ€§ï¼›æˆ‘ä»¬å°†åœ¨ç¬¬ 8 ç« ï¼ˆ[ChapterÂ 08.xhtml#x1-1700008](Chapter_08.xhtml#x1-1700008)ï¼‰ã€[The
    Itertools Module](Chapter_08.xhtml#x1-1700008) å’Œç¬¬ 9 ç« ï¼ˆ[Chapter_09.xhtml#x1-1990009](Chapter_09.xhtml#x1-1990009)ï¼‰ã€[Itertools
    for Combinatorics â€“ Permutations and Combinations](Chapter_09.xhtml#x1-1990009)
    ä¸­ä»”ç»†ç ”ç©¶è¿™äº›å‡½æ•°ã€‚
- en: 1.4 Exploratory data analysis
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4 æ¢ç´¢æ€§æ•°æ®åˆ†æ
- en: Later in this book, weâ€™ll use the field of exploratory data analysis as a source
    for concrete examples of functional programming. This field is rich with algorithms
    and approaches to working with complex datasets; functional programming is often
    a very good fit between the problem domain and automated solutions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬ä¹¦çš„åé¢éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨æ¢ç´¢æ€§æ•°æ®åˆ†æé¢†åŸŸä½œä¸ºå‡½æ•°å¼ç¼–ç¨‹å…·ä½“ç¤ºä¾‹çš„æ¥æºã€‚è¿™ä¸ªé¢†åŸŸå……æ»¡äº†å¤„ç†å¤æ‚æ•°æ®é›†çš„ç®—æ³•å’Œæ–¹æ³•ï¼›å‡½æ•°å¼ç¼–ç¨‹é€šå¸¸åœ¨é—®é¢˜åŸŸå’Œè‡ªåŠ¨åŒ–è§£å†³æ–¹æ¡ˆä¹‹é—´éå¸¸åŒ¹é…ã€‚
- en: 'While details vary from author to author, there are several widely accepted
    stages of EDA. These include the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶ç»†èŠ‚å› ä½œè€…è€Œå¼‚ï¼Œä½†EDAï¼ˆæ¢ç´¢æ€§æ•°æ®åˆ†æï¼‰æœ‰å‡ ä¸ªè¢«å¹¿æ³›æ¥å—çš„é˜¶æ®µã€‚è¿™äº›åŒ…æ‹¬ä»¥ä¸‹å†…å®¹ï¼š
- en: 'Data preparation: This might involve extraction and transformation for source
    applications. It might involve parsing a source data format and doing some kind
    of data scrubbing to remove unusable or invalid data. This is an excellent application
    of functional design techniques.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ•°æ®å‡†å¤‡ï¼šè¿™å¯èƒ½æ¶‰åŠæºåº”ç”¨ç¨‹åºçš„æå–å’Œè½¬æ¢ã€‚å®ƒå¯èƒ½æ¶‰åŠè§£ææºæ•°æ®æ ¼å¼ï¼Œå¹¶è¿›è¡ŒæŸç§æ•°æ®æ¸…ç†ä»¥åˆ é™¤ä¸å¯ç”¨æˆ–æ— æ•ˆçš„æ•°æ®ã€‚è¿™æ˜¯åŠŸèƒ½è®¾è®¡æŠ€æœ¯çš„ä¼˜ç§€åº”ç”¨ã€‚
- en: David Mertzâ€™s superb book Cleaning Data for Effective Data Science( [https://www.packtpub.com/product/cleaning-data-for-effective-data-science/9781801071291](https://www.packtpub.com/product/cleaning-data-for-effective-data-science/9781801071291))
    provides additional information on data cleaning. This is a crucial subject for
    all data science and analytical work.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: David Mertz çš„æ°å‡ºè‘—ä½œã€Šä¸ºé«˜æ•ˆæ•°æ®ç§‘å­¦æ¸…ç†æ•°æ®ã€‹ï¼ˆ[https://www.packtpub.com/product/cleaning-data-for-effective-data-science/9781801071291](https://www.packtpub.com/product/cleaning-data-for-effective-data-science/9781801071291)ï¼‰æä¾›äº†æœ‰å…³æ•°æ®æ¸…ç†çš„æ›´å¤šä¿¡æ¯ã€‚è¿™å¯¹äºæ‰€æœ‰æ•°æ®ç§‘å­¦å’Œåˆ†æå·¥ä½œéƒ½æ˜¯ä¸€ä¸ªå…³é”®ä¸»é¢˜ã€‚
- en: 'Data exploration: This is a description of the available data. This usually
    involves the essential statistical functions. This is another excellent place
    to explore functional programming. We can describe our focus as univariate and
    bivariate statistics, but that sounds too daunting and complex. What this really
    means is that weâ€™ll focus on mean, median, mode, and other related descriptive
    statistics. Data exploration may also involve data visualization. Weâ€™ll skirt
    this issue because it doesnâ€™t involve very much functional programming.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ•°æ®æ¢ç´¢ï¼šè¿™æ˜¯å¯¹å¯ç”¨æ•°æ®çš„æè¿°ã€‚è¿™é€šå¸¸æ¶‰åŠåŸºæœ¬ç»Ÿè®¡å‡½æ•°ã€‚è¿™æ˜¯æ¢ç´¢å‡½æ•°å¼ç¼–ç¨‹çš„å¦ä¸€ä¸ªç»ä½³åœºæ‰€ã€‚æˆ‘ä»¬å¯ä»¥å°†æˆ‘ä»¬çš„é‡ç‚¹æè¿°ä¸ºå•å˜é‡å’ŒåŒå˜é‡ç»Ÿè®¡ï¼Œä½†è¿™å¬èµ·æ¥è¿‡äºä»¤äººç•æƒ§å’Œå¤æ‚ã€‚è¿™å®é™…ä¸Šæ„å‘³ç€æˆ‘ä»¬å°†å…³æ³¨å‡å€¼ã€ä¸­ä½æ•°ã€ä¼—æ•°å’Œå…¶ä»–ç›¸å…³æè¿°æ€§ç»Ÿè®¡ã€‚æ•°æ®æ¢ç´¢è¿˜å¯èƒ½æ¶‰åŠæ•°æ®å¯è§†åŒ–ã€‚æˆ‘ä»¬å°†ç»•è¿‡è¿™ä¸ªé—®é¢˜ï¼Œå› ä¸ºå®ƒä¸æ¶‰åŠå¾ˆå¤šå‡½æ•°å¼ç¼–ç¨‹ã€‚
- en: For more information on Python visualization, see Interactive Data Visualization
    with Python, [https://www.packtpub.com/product/interactive-data-visualization-with-python-second-edition/9781800200944](https://www.packtpub.com/product/interactive-data-visualization-with-python-second-edition/9781800200944).
    See [https://www.projectpro.io/article/python-data-visualization-libraries/543](https://www.projectpro.io/article/python-data-visualization-libraries/543)
    for some additional visualization libraries.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰å…³Pythonå¯è§†åŒ–çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…ã€ŠPythonäº¤äº’å¼æ•°æ®å¯è§†åŒ–ã€‹ï¼Œ[https://www.packtpub.com/product/interactive-data-visualization-with-python-second-edition/9781800200944](https://www.packtpub.com/product/interactive-data-visualization-with-python-second-edition/9781800200944)ã€‚æœ‰å…³ä¸€äº›é¢å¤–çš„å¯è§†åŒ–åº“ï¼Œè¯·å‚é˜…[https://www.projectpro.io/article/python-data-visualization-libraries/543](https://www.projectpro.io/article/python-data-visualization-libraries/543)ã€‚
- en: 'Data modeling and machine learning: This tends to be prescriptive as it involves
    extending a model to new data. Weâ€™re going to skirt around this because some of
    the models can become mathematically complex. If we spend too much time on these
    topics, we wonâ€™t be able to focus on functional programming.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ•°æ®å»ºæ¨¡å’Œæœºå™¨å­¦ä¹ ï¼šè¿™é€šå¸¸å…·æœ‰è§„èŒƒæ€§ï¼Œå› ä¸ºå®ƒæ¶‰åŠå°†æ¨¡å‹æ‰©å±•åˆ°æ–°æ•°æ®ã€‚æˆ‘ä»¬å°†ç»•è¿‡è¿™ä¸ªé—®é¢˜ï¼Œå› ä¸ºä¸€äº›æ¨¡å‹å¯èƒ½ä¼šå˜å¾—æ•°å­¦ä¸Šå¤æ‚ã€‚å¦‚æœæˆ‘ä»¬åœ¨è¿™ä¸Šé¢èŠ±è´¹å¤ªå¤šæ—¶é—´ï¼Œæˆ‘ä»¬å°±æ— æ³•ä¸“æ³¨äºå‡½æ•°å¼ç¼–ç¨‹ã€‚
- en: 'Evaluation and comparison: When there are alternative models, each must be
    evaluated to determine which is a better fit for the available data. This can
    involve ordinary descriptive statistics of model outputs, which can benefit from
    functional design techniques.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¯„ä¼°å’Œæ¯”è¾ƒï¼šå½“å­˜åœ¨æ›¿ä»£æ¨¡å‹æ—¶ï¼Œæ¯ä¸ªæ¨¡å‹éƒ½å¿…é¡»è¢«è¯„ä¼°ä»¥ç¡®å®šå“ªä¸ªæ›´é€‚åˆç°æœ‰æ•°æ®ã€‚è¿™å¯èƒ½æ¶‰åŠæ¨¡å‹è¾“å‡ºçš„æ™®é€šæè¿°æ€§ç»Ÿè®¡ï¼Œè¿™äº›ç»Ÿè®¡å¯ä»¥å—ç›ŠäºåŠŸèƒ½è®¾è®¡æŠ€æœ¯ã€‚
- en: One goal of EDA is often to create a model that can be deployed as a decision
    support application. In many cases, a model might be a simple function. A functional
    programming approach can apply the model to new data and display results for human
    consumption.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: EDAçš„ä¸€ä¸ªç›®æ ‡é€šå¸¸æ˜¯åˆ›å»ºä¸€ä¸ªå¯ä»¥ä½œä¸ºå†³ç­–æ”¯æŒåº”ç”¨ç¨‹åºéƒ¨ç½²çš„æ¨¡å‹ã€‚åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼Œæ¨¡å‹å¯èƒ½æ˜¯ä¸€ä¸ªç®€å•çš„å‡½æ•°ã€‚å‡½æ•°å¼ç¼–ç¨‹æ–¹æ³•å¯ä»¥å°†æ¨¡å‹åº”ç”¨äºæ–°æ•°æ®ï¼Œå¹¶æ˜¾ç¤ºä¾›äººç±»æ¶ˆè´¹çš„ç»“æœã€‚
- en: 1.5 Summary
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5 æ‘˜è¦
- en: In this chapter, weâ€™ve looked at programming paradigms with an eye toward distinguishing
    the functional paradigm from the imperative paradigm. For our purposes, object-oriented
    programming is a kind of imperative programming; it relies on explicit state changes.
    Our objective in this book is to explore the functional programming features of
    Python. Weâ€™ve noted that some parts of Python donâ€™t allow purely functional programming;
    weâ€™ll be using some hybrid techniques that meld the good features of succinct,
    expressive functional programming with some high-performance optimizations in
    Python.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬ç€çœ¼äºåŒºåˆ†å‡½æ•°å¼èŒƒå¼å’Œå‘½ä»¤å¼èŒƒå¼ï¼Œä»¥æ¢è®¨ç¼–ç¨‹èŒƒå¼ã€‚å°±æˆ‘ä»¬çš„ç›®çš„è€Œè¨€ï¼Œé¢å‘å¯¹è±¡ç¼–ç¨‹æ˜¯ä¸€ç§å‘½ä»¤å¼ç¼–ç¨‹ï¼›å®ƒä¾èµ–äºæ˜¾å¼çš„çŠ¶æ€å˜åŒ–ã€‚æœ¬ä¹¦çš„ç›®æ ‡æ˜¯æ¢ç´¢Pythonçš„å‡½æ•°å¼ç¼–ç¨‹ç‰¹æ€§ã€‚æˆ‘ä»¬æ³¨æ„åˆ°Pythonçš„ä¸€äº›éƒ¨åˆ†ä¸å…è®¸çº¯å‡½æ•°å¼ç¼–ç¨‹ï¼›æˆ‘ä»¬å°†ä½¿ç”¨ä¸€äº›æ··åˆæŠ€æœ¯ï¼Œè¿™äº›æŠ€æœ¯å°†ç®€æ´ã€è¡¨è¾¾æ€§å¼ºçš„å‡½æ•°å¼ç¼–ç¨‹çš„ä¼˜ç‚¹ä¸Pythonä¸­çš„ä¸€äº›é«˜æ€§èƒ½ä¼˜åŒ–ç›¸ç»“åˆã€‚
- en: In the next chapter, weâ€™ll look at five specific functional programming techniques
    in detail. These techniques will form the essential foundation for our hybridized
    functional programming in Python.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†è¯¦ç»†æ¢è®¨äº”ç§ç‰¹å®šçš„å‡½æ•°å¼ç¼–ç¨‹æŠ€æœ¯ã€‚è¿™äº›æŠ€æœ¯å°†æ„æˆæˆ‘ä»¬Pythonæ··åˆå‡½æ•°å¼ç¼–ç¨‹çš„åŸºç¡€ã€‚
- en: 1.6 Exercises
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6 ç»ƒä¹ 
- en: The exercises in this book are based on code available from Packt Publishing
    on GitHub. See [https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ä¹¦ä¸­çš„ç»ƒä¹ åŸºäºGitHubä¸ŠPackt Publishingæä¾›çš„ä»£ç ã€‚è¯·å‚é˜…[https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition)ã€‚
- en: In some cases, the reader will notice that the code provided on GitHub includes
    partial solutions to some of the exercises. These serve as hints, allowing the
    reader to explore alternative solutions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œè¯»è€…ä¼šæ³¨æ„åˆ° GitHub ä¸Šæä¾›çš„ä»£ç åŒ…å«äº†ä¸€äº›ç»ƒä¹ çš„éƒ¨åˆ†è§£å†³æ–¹æ¡ˆã€‚è¿™äº›ä½œä¸ºæç¤ºï¼Œå…è®¸è¯»è€…æ¢ç´¢å…¶ä»–è§£å†³æ–¹æ¡ˆã€‚
- en: In many cases, exercises will need unit test cases to confirm they actually
    solve the problem. These are often identical to the unit test cases already provided
    in the GitHub repository. The reader will need to replace the bookâ€™s example function
    name with their own solution to confirm that it works.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼Œç»ƒä¹ å°†éœ€è¦å•å…ƒæµ‹è¯•ç”¨ä¾‹æ¥ç¡®è®¤å®ƒä»¬ç¡®å®è§£å†³äº†é—®é¢˜ã€‚è¿™äº›é€šå¸¸ä¸ GitHub ä»“åº“ä¸­å·²æä¾›çš„å•å…ƒæµ‹è¯•ç”¨ä¾‹ç›¸åŒã€‚è¯»è€…éœ€è¦å°†ä¹¦ç±ä¸­çš„ç¤ºä¾‹å‡½æ•°åæ›¿æ¢ä¸ºè‡ªå·±çš„è§£å†³æ–¹æ¡ˆä»¥ç¡®è®¤å…¶å·¥ä½œã€‚
- en: 1.6.1 Convert an imperative algorithm to functional code
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.6.1 å°†å‘½ä»¤å¼ç®—æ³•è½¬æ¢ä¸ºå‡½æ•°å¼ä»£ç 
- en: The following algorithm is stated as imperative assignment statements and a
    while construct to indicate processing something iteratively.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹ç®—æ³•è¢«è¡¨è¿°ä¸ºå‘½ä»¤å¼èµ‹å€¼è¯­å¥å’Œ while æ„é€ æ¥æŒ‡ç¤ºè¿­ä»£å¤„ç†ã€‚
- en: '![Algorithm 1: Imperative iteration ](img/Algo_1.1.JPG)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![ç®—æ³• 1ï¼šå‘½ä»¤å¼è¿­ä»£](img/Algo_1.1.JPG)'
- en: 'Algorithm 1: Imperative iteration'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ç®—æ³• 1ï¼šå‘½ä»¤å¼è¿­ä»£
- en: What does this appear to compute? Given Python built-in functions like `sum`,
    can this be simplified?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™çœ‹èµ·æ¥æ˜¯åœ¨è®¡ç®—ä»€ä¹ˆï¼Ÿç»™å®šåƒ `sum` è¿™æ ·çš„ Python å†…ç½®å‡½æ•°ï¼Œè¿™èƒ½ç®€åŒ–å—ï¼Ÿ
- en: It helps to write this in Python and refactor the code to be sure that correct
    answers are created.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: å°†å…¶ç”¨ Python ç¼–å†™å¹¶é‡æ„ä»£ç ä»¥ç¡®ä¿ç”Ÿæˆæ­£ç¡®ç­”æ¡ˆã€‚
- en: 'A test case is the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹å¦‚ä¸‹ï¼š
- en: '![V â† {7.46,6.77,12.74,7.11,7.81,8.84,6.08,5.39,8.15,6.42,5.73} ](img/file10.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![V â† {7.46,6.77,12.74,7.11,7.81,8.84,6.08,5.39,8.15,6.42,5.73}](img/file10.jpg)'
- en: The computed value for m is approximately `7.5`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: m çš„è®¡ç®—å€¼å¤§çº¦ä¸º `7.5`ã€‚
- en: 1.6.2 Convert step-wise computation to functional code
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.6.2 å°†é€æ­¥è®¡ç®—è½¬æ¢ä¸ºå‡½æ•°å¼ä»£ç 
- en: The following algorithm is stated as a long series of single assignment statements.
    The rad(x) function converts degrees to radians, rad(d) = Ï€ Ã—![1d80](img/file11.jpg).
    See the `math` module for an implementation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹ç®—æ³•è¢«è¡¨è¿°ä¸ºä¸€ç³»åˆ—çš„å•ä¸ªèµ‹å€¼è¯­å¥ã€‚`rad(x)` å‡½æ•°å°†åº¦è½¬æ¢ä¸ºå¼§åº¦ï¼Œ`rad(d) = Ï€ Ã— ![1d80](img/file11.jpg)`ã€‚è¯·å‚é˜…
    `math` æ¨¡å—ä»¥è·å–å®ç°ã€‚
- en: '![Algorithm 2: Imperative computation ](img/Algo_1.2.JPG)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![ç®—æ³• 2ï¼šå‘½ä»¤å¼è®¡ç®—](img/Algo_1.2.JPG)'
- en: 'Algorithm 2: Imperative computation'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ç®—æ³• 2ï¼šå‘½ä»¤å¼è®¡ç®—
- en: Is this code easy to understand? Can you summarize this computation as a short
    mathematical-looking formula?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ®µä»£ç æ˜¯å¦å®¹æ˜“ç†è§£ï¼Ÿä½ èƒ½å°†è¿™ä¸ªè®¡ç®—æ€»ç»“ä¸ºä¸€ä¸ªç®€çŸ­çš„ç±»ä¼¼æ•°å­¦å…¬å¼çš„è¡¨è¾¾å¼å—ï¼Ÿ
- en: Breaking it down into sections, lines 1 to 8 seem to be focused on some conversions,
    differences, and mid-point computations. Lines 9 to 12 compute two values, x and
    y. Can these be summarized or simplified? The final four lines do a relatively
    direct computation of d. Can this be summarized or simplified? As a hint, look
    at `math.hypot()` for a function that might be applicable in this case.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: å°†å…¶åˆ†è§£ä¸ºéƒ¨åˆ†ï¼Œç¬¬ 1 åˆ° 8 è¡Œä¼¼ä¹ä¸“æ³¨äºä¸€äº›è½¬æ¢ã€å·®å¼‚å’Œä¸­ç‚¹è®¡ç®—ã€‚ç¬¬ 9 åˆ° 12 è¡Œè®¡ç®—ä¸¤ä¸ªå€¼ï¼Œx å’Œ yã€‚è¿™äº›èƒ½å¦æ€»ç»“æˆ–ç®€åŒ–ï¼Ÿæœ€åçš„å››è¡Œè¿›è¡Œç›¸å¯¹ç›´æ¥çš„
    d çš„è®¡ç®—ã€‚è¿™äº›èƒ½å¦æ€»ç»“æˆ–ç®€åŒ–ï¼Ÿä½œä¸ºä¸€ä¸ªæç¤ºï¼Œçœ‹çœ‹ `math.hypot()` å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°å¯èƒ½é€‚ç”¨äºè¿™ç§æƒ…å†µã€‚
- en: It helps to write this in Python and refactor the code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: å°†å…¶ç”¨ Python ç¼–å†™å¹¶é‡æ„ä»£ç ä¼šæœ‰æ‰€å¸®åŠ©ã€‚
- en: 'A test case is the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹å¦‚ä¸‹ï¼š
- en: lat[1] â† 32.82950
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: lat[1] â† 32.82950
- en: lon[1] â†âˆ’79.93021
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: lon[1] â†âˆ’79.93021
- en: lat[2] â† 32.74412
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: lat[2] â† 32.74412
- en: lon[2] â†âˆ’79.85226
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: lon[2] â†âˆ’79.85226
- en: The computed value for d is approximately `6.4577`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: d çš„è®¡ç®—å€¼å¤§çº¦ä¸º `6.4577`ã€‚
- en: Refactoring the code can help to confirm your understanding.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: é‡æ„ä»£ç å¯ä»¥å¸®åŠ©ä½ ç¡®è®¤ä½ çš„ç†è§£ã€‚
- en: 1.6.3 Revise the sqrt() function
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.6.3 ä¿®æ”¹ sqrt() å‡½æ•°
- en: The `sqrt()` function defined in the A classic example of functional programming
    section has only a single parameter value, `n`. Rewrite this to create a more
    advanced version using default parameter values to make changes possible. An expression
    such as `sqrt(1.0,``Â 0.000_01,``Â 3)` will start with an approximation of 1.0 and
    compute the value to a precision of 0.00001\. The final parameter value, `3`,
    is the value of n, the number we need to compute the square root of.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨â€œç»å…¸å‡½æ•°å¼ç¼–ç¨‹ç¤ºä¾‹â€ä¸­å®šä¹‰çš„ `sqrt()` å‡½æ•°åªæœ‰ä¸€ä¸ªå‚æ•°å€¼ï¼Œ`n`ã€‚é‡å†™å®ƒä»¥åˆ›å»ºä¸€ä¸ªæ›´é«˜çº§çš„ç‰ˆæœ¬ï¼Œä½¿ç”¨é»˜è®¤å‚æ•°å€¼æ¥ä½¿æ›´æ”¹æˆä¸ºå¯èƒ½ã€‚ä¾‹å¦‚ï¼Œè¡¨è¾¾å¼
    `sqrt(1.0, ``Â 0.000_01, ``Â 3)` å°†ä» 1.0 çš„è¿‘ä¼¼å€¼å¼€å§‹ï¼Œå¹¶è®¡ç®—åˆ° 0.00001 çš„ç²¾åº¦ã€‚æœ€åä¸€ä¸ªå‚æ•°å€¼ `3` æ˜¯ n
    çš„å€¼ï¼Œæˆ‘ä»¬éœ€è¦è®¡ç®—å…¶å¹³æ–¹æ ¹çš„æ•°å­—ã€‚
- en: 1.6.4 Data cleansing steps
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.6.4 æ•°æ®æ¸…æ´—æ­¥éª¤
- en: A file of source data has US ZIP codes in a variety of formats. This problem
    often arises when spreadsheet software is used to collect or transform data.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: æºæ•°æ®æ–‡ä»¶åŒ…å«å„ç§æ ¼å¼çš„ç¾å›½ ZIP ç ã€‚å½“ä½¿ç”¨ç”µå­è¡¨æ ¼è½¯ä»¶æ”¶é›†æˆ–è½¬æ¢æ•°æ®æ—¶ï¼Œè¿™ä¸ªé—®é¢˜ç»å¸¸å‡ºç°ã€‚
- en: Some ZIP codes were processed as numbers. This doesnâ€™t work out well for places
    in New England, where ZIP codes have a leading zero. For example, one of Portsmouth,
    New Hampshireâ€™s codes should be stated as `03801`. In the source file, it is `3801`.
    For the most part, these numbers will have five or nine digits, but some codes
    in New England will be four or eight digits when a single leading zero was dropped.
    For Puerto Rico, there may be two leading zeroes.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€äº›ZIPä»£ç è¢«å¤„ç†ä¸ºæ•°å­—ã€‚è¿™å¯¹äºæ–°è‹±æ ¼å…°åœ°åŒºæ¥è¯´å¹¶ä¸ç†æƒ³ï¼Œå› ä¸ºé‚£é‡Œçš„ZIPä»£ç ä»¥é›¶å¼€å¤´ã€‚ä¾‹å¦‚ï¼Œæ–°ç½•å¸ƒä»€å°”å·æœ´æ¬¡èŒ…æ–¯çš„ä»£ç åº”è¯¥æ˜¯`03801`ã€‚åœ¨æºæ–‡ä»¶ä¸­ï¼Œå®ƒæ˜¯`3801`ã€‚å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œè¿™äº›æ•°å­—å°†å…·æœ‰äº”ä½æˆ–ä¹ä½æ•°å­—ï¼Œä½†æ–°è‹±æ ¼å…°çš„ä¸€äº›ä»£ç åœ¨å»æ‰å•ä¸ªå‰å¯¼é›¶åå°†æ˜¯å››ä½æˆ–å…«ä½æ•°å­—ã€‚å¯¹äºæ³¢å¤šé»å„ï¼Œå¯èƒ½ä¼šæœ‰ä¸¤ä¸ªå‰å¯¼é›¶ã€‚
- en: Some ZIP codes are stored as strings, 12345âˆ’0100, where a four-digit extension
    for a post-office box has been appended to the base five-digit code.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€äº›ZIPä»£ç ä»¥å­—ç¬¦ä¸²å½¢å¼å­˜å‚¨ï¼Œä¾‹å¦‚12345âˆ’0100ï¼Œå…¶ä¸­é™„åŠ äº†ä¸€ä¸ªå››ä½é‚®æ”¿ä¿¡ç®±æ‰©å±•åˆ°åŸºæœ¬äº”ä½ä»£ç ã€‚
- en: A CSV-format file has only text values. However, when data in the file has been
    processed by a spreadsheet, problems can arise. Because a ZIP code has only digits,
    it can be treated as numeric data. This means the original data values will have
    been converted to a number, and then back to a text representation. These conversions
    will drop the leading zeroes. There are a number of workarounds in various spreadsheet
    applications to prevent this problem. If theyâ€™re not used, the data can have anomalous
    values that can be cleansed to restore the original representation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: CSVæ ¼å¼çš„æ–‡ä»¶åªæœ‰æ–‡æœ¬å€¼ã€‚ç„¶è€Œï¼Œå½“æ–‡ä»¶ä¸­çš„æ•°æ®ç»è¿‡ç”µå­è¡¨æ ¼å¤„ç†æ—¶ï¼Œå¯èƒ½ä¼šå‡ºç°é—®é¢˜ã€‚å› ä¸ºZIPä»£ç åªæœ‰æ•°å­—ï¼Œå®ƒå¯ä»¥è¢«è§†ä¸ºæ•°å€¼æ•°æ®ã€‚è¿™æ„å‘³ç€åŸå§‹æ•°æ®å€¼å·²ç»è¢«è½¬æ¢ä¸ºæ•°å­—ï¼Œç„¶åå†è½¬æ¢å›æ–‡æœ¬è¡¨ç¤ºã€‚è¿™äº›è½¬æ¢å°†åˆ é™¤å‰å¯¼é›¶ã€‚åœ¨å„ç§ç”µå­è¡¨æ ¼åº”ç”¨ç¨‹åºä¸­å­˜åœ¨è®¸å¤šè§£å†³æ–¹æ¡ˆæ¥é˜²æ­¢è¿™ä¸ªé—®é¢˜ã€‚å¦‚æœä¸ä½¿ç”¨å®ƒä»¬ï¼Œæ•°æ®å¯èƒ½ä¼šå‡ºç°å¼‚å¸¸å€¼ï¼Œè¿™äº›å¼‚å¸¸å€¼å¯ä»¥è¢«æ¸…ç†ä»¥æ¢å¤åŸå§‹è¡¨ç¤ºã€‚
- en: 'The objective of the exercise is to compute a histogram of the most popular
    ZIP codes in the source data file. The data must be cleansed to have the following
    two ZIP formats:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ç»ƒä¹ çš„ç›®æ ‡æ˜¯è®¡ç®—æºæ•°æ®æ–‡ä»¶ä¸­æœ€å—æ¬¢è¿çš„ZIPä»£ç çš„ç›´æ–¹å›¾ã€‚æ•°æ®å¿…é¡»ç»è¿‡æ¸…ç†ï¼Œä»¥å…·æœ‰ä»¥ä¸‹ä¸¤ç§ZIPæ ¼å¼ï¼š
- en: Five characters with no post-office box, for example `03801`
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ²¡æœ‰é‚®æ”¿ä¿¡ç®±çš„äº”ä½å­—ç¬¦ï¼Œä¾‹å¦‚`03801`
- en: Ten characters with a hyphen, for example `03899-9876`
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œå¸¦æœ‰è¿å­—ç¬¦çš„åä¸ªå­—ç¬¦ï¼Œä¾‹å¦‚`03899-9876`
- en: The essential histogram can be done with a `collections.Counter` object as follows.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: åŸºæœ¬çš„ç›´æ–¹å›¾å¯ä»¥ä½¿ç”¨`collections.Counter`å¯¹è±¡å®Œæˆå¦‚ä¸‹ã€‚
- en: '[PRE16]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This makes use of imperative processing features to read a file. The overall
    design, using a `for` statement to process rows of a file, is an essential Pythonic
    feature that we can preserve.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™åˆ©ç”¨äº†å‘½ä»¤å¼å¤„ç†åŠŸèƒ½æ¥è¯»å–æ–‡ä»¶ã€‚ä½¿ç”¨`for`è¯­å¥å¤„ç†æ–‡ä»¶è¡Œï¼Œè¿™ç§æ•´ä½“è®¾è®¡æ˜¯Pythonçš„ä¸€ä¸ªåŸºæœ¬ç‰¹æ€§ï¼Œæˆ‘ä»¬å¯ä»¥ä¿ç•™å®ƒã€‚
- en: On the other hand, the processing of the `text_zip` and `missing_zeroes` variables
    through a number of state changes seems like itâ€™s a potential source for confusion.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€æ–¹é¢ï¼Œé€šè¿‡ä¸€ç³»åˆ—çŠ¶æ€å˜åŒ–å¤„ç†`text_zip`å’Œ`missing_zeroes`å˜é‡ä¼¼ä¹æ˜¯ä¸€ä¸ªæ½œåœ¨çš„æ··æ·†æ¥æºã€‚
- en: 'This can be refactored through several rewrites:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯ä»¥é€šè¿‡å‡ æ¬¡é‡å†™è¿›è¡Œé‡æ„ï¼š
- en: 'Decompose the `main()` function into two parts. A new `zip_histogram()` function
    should be written to contain much of the processing detail. This function will
    process the opened file, and return a `Counter` object. A suggested signature
    is the following:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å°†`main()`å‡½æ•°åˆ†è§£ä¸ºä¸¤éƒ¨åˆ†ã€‚åº”è¯¥ç¼–å†™ä¸€ä¸ªæ–°çš„`zip_histogram()`å‡½æ•°æ¥åŒ…å«å¤§éƒ¨åˆ†å¤„ç†ç»†èŠ‚ã€‚è¿™ä¸ªå‡½æ•°å°†å¤„ç†æ‰“å¼€çš„æ–‡ä»¶ï¼Œå¹¶è¿”å›ä¸€ä¸ª`Counter`å¯¹è±¡ã€‚å»ºè®®çš„ç­¾åå¦‚ä¸‹ï¼š
- en: '[PRE17]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `main()` function is left with the responsibility to open the file, create
    the `csv.DictReader` instance, evaluate `zip_histogram()`, and print the histogram.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`main()`å‡½æ•°è´Ÿè´£æ‰“å¼€æ–‡ä»¶ï¼Œåˆ›å»º`csv.DictReader`å®ä¾‹ï¼Œè¯„ä¼°`zip_histogram()`ï¼Œå¹¶æ‰“å°ç›´æ–¹å›¾ã€‚'
- en: Once the `zip_histogram()` function has been defined, the cleansing of the `ZIP`
    attribute can be refactored into a separate function, with a name like `zip_cleanse()`.
    Rather than setting the value of the `text_zip` variable, this function can return
    the cleansed result. This can be tested separately to be sure the various cases
    are handled gracefully.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä¸€æ—¦å®šä¹‰äº†`zip_histogram()`å‡½æ•°ï¼Œ`ZIP`å±æ€§çš„æ¸…ç†å¯ä»¥é‡æ„ä¸ºä¸€ä¸ªå•ç‹¬çš„å‡½æ•°ï¼Œä¾‹å¦‚å‘½åä¸º`zip_cleanse()`ã€‚è¿™ä¸ªå‡½æ•°è€Œä¸æ˜¯è®¾ç½®`text_zip`å˜é‡çš„å€¼ï¼Œå¯ä»¥è¿”å›æ¸…ç†åçš„ç»“æœã€‚è¿™å¯ä»¥å•ç‹¬æµ‹è¯•ä»¥ç¡®ä¿å„ç§æƒ…å†µéƒ½èƒ½ä¼˜é›…åœ°å¤„ç†ã€‚
- en: The distinction between long ZIP codes with a hyphen and without a hyphen is
    something that should be fixed. Once the `zip_cleanse()` works in general, add
    a new function to inject hyphens into ZIP codes with only digits. This should
    transform `38011234` to `03801-1234`. Note that short, five-digit ZIP codes do
    not need to have a hyphen added; this additional transformation only applies to
    nine-digit codes to make them into ten-position strings.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å¸¦æœ‰è¿å­—ç¬¦å’Œä¸å¸¦è¿å­—ç¬¦çš„é•¿ ZIP ç ä¹‹é—´çš„åŒºåˆ«æ˜¯åº”è¯¥ä¿®å¤çš„é—®é¢˜ã€‚ä¸€æ—¦ `zip_cleanse()` åœ¨ä¸€èˆ¬æƒ…å†µä¸‹å·¥ä½œï¼Œæ·»åŠ ä¸€ä¸ªæ–°å‡½æ•°æ¥åœ¨åªæœ‰æ•°å­—çš„
    ZIP ç ä¸­æ³¨å…¥è¿å­—ç¬¦ã€‚è¿™åº”è¯¥å°† `38011234` è½¬æ¢ä¸º `03801-1234`ã€‚æ³¨æ„ï¼ŒçŸ­çš„äº”ä½ ZIP ç ä¸éœ€è¦æ·»åŠ è¿å­—ç¬¦ï¼›è¿™ç§é¢å¤–çš„è½¬æ¢ä»…é€‚ç”¨äºä¹ä½ä»£ç ï¼Œä½¿å…¶æˆä¸ºåä½å­—ç¬¦ä¸²ã€‚
- en: 'The final `zip_histogram()` function should look something like the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€ç»ˆçš„ `zip_histogram()` å‡½æ•°åº”è¯¥çœ‹èµ·æ¥åƒä»¥ä¸‹è¿™æ ·ï¼š
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This provides a framework for performing a focused data cleanup in the given
    column. It allows us to distinguish between CSV and file processing features,
    and the details of how to clean up a specific column of data.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ºåœ¨ç»™å®šåˆ—ä¸­è¿›è¡Œä¸“æ³¨çš„æ•°æ®æ¸…ç†æä¾›äº†ä¸€ä¸ªæ¡†æ¶ã€‚å®ƒä½¿æˆ‘ä»¬èƒ½å¤ŸåŒºåˆ† CSV å’Œæ–‡ä»¶å¤„ç†åŠŸèƒ½ï¼Œä»¥åŠå¦‚ä½•æ¸…ç†ç‰¹å®šåˆ—æ•°æ®çš„ç»†èŠ‚ã€‚
- en: 1.6.5 (Advanced) Optimize this functional code
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.6.5ï¼ˆé«˜çº§ï¼‰ä¼˜åŒ–æ­¤åŠŸèƒ½ä»£ç 
- en: The following algorithm is stated as a single â€stepâ€ that has been decomposed
    into three separate formulae. The decomposition is more a concession to the need
    to fit the expression into the limits of a printed page than a useful optimization.
    The rad(x) function converts degrees to radians, rad(d) = Ï€ Ã—![-d- 180](img/file13.jpg).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹ç®—æ³•è¢«è¡¨è¿°ä¸ºä¸€ä¸ªå•ç‹¬çš„â€œæ­¥éª¤â€ï¼Œè¯¥æ­¥éª¤å·²è¢«åˆ†è§£ä¸ºä¸‰ä¸ªç‹¬ç«‹çš„å…¬å¼ã€‚è¿™ç§åˆ†è§£æ›´å¤šçš„æ˜¯ä¸ºäº†æ»¡è¶³å°†è¡¨è¾¾å¼æ”¾å…¥å°åˆ·é¡µé¢é™åˆ¶çš„éœ€è¦ï¼Œè€Œä¸æ˜¯ä¸€ç§æœ‰ç”¨çš„ä¼˜åŒ–ã€‚rad(x)
    å‡½æ•°å°†åº¦è½¬æ¢ä¸ºå¼§åº¦ï¼Œrad(d) = Ï€ Ã—![-d- 180](img/file13.jpg)ã€‚
- en: '![Algorithm 3: Redundant expressions ](img/Algo_1.3.JPG)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![ç®—æ³• 3ï¼šå†—ä½™è¡¨è¾¾å¼](img/Algo_1.3.JPG)'
- en: 'Algorithm 3: Redundant expressions'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ç®—æ³• 3ï¼šå†—ä½™è¡¨è¾¾å¼
- en: There are a number of redundant expressions, like rad(lat[1]) and rad(lat[2]).
    If these are assigned to local variables, can the expression be simplified?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: å­˜åœ¨è®¸å¤šå†—ä½™è¡¨è¾¾å¼ï¼Œä¾‹å¦‚ rad(lat[1]) å’Œ rad(lat[2])ã€‚å¦‚æœè¿™äº›è¢«åˆ†é…ç»™å±€éƒ¨å˜é‡ï¼Œè¡¨è¾¾å¼èƒ½å¦ç®€åŒ–ï¼Ÿ
- en: The final computation of d does not match the conventional understanding of
    computing a hypotenuse, ![âˆ˜ ------- x2 + y2](img/file15.jpg). Should the code
    be refactored to match the definition in `math.hypot`?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: d çš„æœ€ç»ˆè®¡ç®—ç»“æœä¸è®¡ç®—æ–œè¾¹ä¼ ç»Ÿçš„ç†è§£ä¸ç¬¦ï¼Œ![âˆ˜ ------- x2 + y2](img/file15.jpg)ã€‚ä»£ç åº”è¯¥é‡æ„ä»¥åŒ¹é… `math.hypot`
    ä¸­çš„å®šä¹‰å—ï¼Ÿ
- en: It helps to start by writing this in Python and then refactoring the code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ä»ç”¨ Python ç¼–å†™è¿™ä¸ªå¼€å§‹ï¼Œç„¶åé‡æ„ä»£ç æ˜¯ä¸€ä¸ªå¥½æ–¹æ³•ã€‚
- en: 'A test case is the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹æ˜¯ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼š
- en: lat[1] â† 32.82950
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: lat[1] â† 32.82950
- en: lon[1] â†âˆ’79.93021
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: lon[1] â†âˆ’79.93021
- en: lat[2] â† 32.74412
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: lat[2] â† 32.74412
- en: lon[2] â†âˆ’79.85226
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: lon[2] â†âˆ’79.85226
- en: The computed value for d is approximately `6.4577`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: d çš„è®¡ç®—å€¼å¤§çº¦ä¸º `6.4577`ã€‚
- en: Refactoring the code can help to confirm your understanding of what this code
    really does.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ä»£ç é‡æ„å¯ä»¥å¸®åŠ©ä½ ç¡®è®¤ä½ å¯¹è¿™æ®µä»£ç çœŸæ­£åŠŸèƒ½çš„ç†è§£ã€‚
- en: Join our community Discord space
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: åŠ å…¥æˆ‘ä»¬çš„ Discord ç¤¾åŒºç©ºé—´
- en: 'Join our Python Discord workspace to discuss and know more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: åŠ å…¥æˆ‘ä»¬çš„ Python Discord å·¥ä½œç©ºé—´ï¼Œè®¨è®ºå¹¶äº†è§£æ›´å¤šå…³äºè¿™æœ¬ä¹¦çš„ä¿¡æ¯ï¼š[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾ç‰‡](img/file1.png)'
