- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Version Control with Git in PyCharm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Version control is an essential best practice in the field of software development.
    The mechanics of the process, though, are daunting for new developers. It is easy
    to make mistakes. As a bootcamp instructor at Southern Methodist University (Go
    Ponies!), I have seen quite a few blunders, such as accidentally adding your entire
    home folder to a Git repository, creating repositories inside of other repositories,
    and wiping out the product of hard work by pushing and pulling out of order. I
    prefer my students to master Git on the command line. In fact, it is the very
    first skill I teach, and in my opinion, it is one of the most difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a developer gains confidence with the whole Git process, it is something
    of an annoyance to have to constantly jump out of the IDE to perform four or five
    commands, then jump back into the IDE to continue work. It is true you could use
    the built-in terminal window available in PyCharm, but the IDE offers a better
    option: a built-in version control GUI.'
  prefs: []
  type: TYPE_NORMAL
- en: 'PyCharm supports a number of the major **version control systems** (**VCSs**),
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mercurial
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perforce
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft **Team** **Foundation Server**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While there are many other VCSs available, these are easily the most popular,
    and among those in this list, Git has become the de facto standard in the industry.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will first cover some basic information about version control and
    VCSs just in case you are new to the concept. Following this introduction, we
    will focus entirely on the tooling for Git, since as I just hinted, it has a capital
    lead in terms of market share.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of the chapter, you will come to understand the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The merits of using a VCS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Git to perform adding, committing, pushing, merging, and branching
    operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and maintaining a `.``gitignore` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the Git tooling in the IDE, which may be referenced from several
    vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be successful with this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working installation of Python 3.10 or later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working installation of PyCharm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git client software for your computer. Mac and Linux systems usually have this
    installed as standard. Windows users can visit [https://gitforwindows.org](https://gitforwindows.org)
    to download the free software.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A free GitHub account. Register at [https://github.com](https://github.com).
    Note that while there are paid features of GitHub, we won’t be using them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version control and Git essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Software industry icon **Joel Spolsky**, who created Stack Overflow, wrote
    a famous blog back in the year 2000\. One of his many influential posts included
    one titled *The Joel Test: 12 Steps to Better Code*. The post was designed to
    give software developers an easy assessment to rate any software development organization’s
    maturity level. He asked 12 questions, with one point per question. A good software
    development group should have a score of 11 or higher. The very first item on
    the list is the concern of this chapter: Do you use source control? If you are
    curious about the rest, there is a link to the blog post, as well as a reference
    to Mr. Spolsky’s book *Joel on Software*, in the *Further reading* section of
    this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Joel called it **source control**. I call it **version control**. The terms
    are interchangeable. I will call it *version control* in order to be consistent
    with the UI in PyCharm, which refers to the group of features we’re talking about
    as a **version control system**, or **VCS**. Strictly speaking, version control
    is a process used to track changes to the files that make up your program over
    time. The objectives of a VCS include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to revert to any previously saved version of any file in your project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to automatically merge the work of multiple developers on a team
    so long as their work does not conflict. A conflict occurs when two developers
    change the same file in the same place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide an easy means to review conflicts and resolve them through collaboration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to track which developers made each change in the code over time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a branching system to allow bug fixes, enhancements, and experimentation
    without sacrificing the stability of your production code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A VCS, then, is a software system designed to enable that process. VCSs come
    in two varieties, depending on how revisions are stored. **Centralized VCSs**
    work a little like your local public library. Your project is checked into a **repository**.
    Developers can then check out the code in order to work on creating a new revision.
    Doing so will retrieve the latest version of the project. Some systems, such as
    **Perforce**, traditionally require you to explicitly check out the files you
    want to work with just like you’d check out a book from a library. While you have
    those files checked out, nobody else is allowed to modify them until you check
    them back in with your changes. Other systems, such as **Subversion**, don’t have
    this requirement. Anybody can work on their local working copy. When work is done,
    the developer **commits** their work to the central repository. During the commit
    process, the VCS checks for **conflicts**. If no conflicts exist, the incoming
    work is **merged** and a new version is stored on the VCS server, which is then
    available for other developers through an update process. If conflicts are detected,
    the commit is rejected, and the developer must work with other developers on the
    team to resolve the conflict before the work can be merged and finally committed.
    In all centralized systems, each developer on a team has only the latest version
    of the code on their local computer.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, **distributed version control systems** (**DVCSs**) such as **Git**
    and **Mercurial** keep every revision ever performed on the project on each developer’s
    computer. The advantage here is there is no single point of failure that might
    result in a total loss of the project code. In a centralized system, if the server
    is compromised, the project’s revision history might be lost. In a distributed
    system, there isn’t a central system to store the project’s revision history.
    Every developer has the project’s entire history on their computer, so the loss
    of any one computer isn’t a big deal beyond the usual pain of replacing the equipment.
  prefs: []
  type: TYPE_NORMAL
- en: With that said, distributed systems do use a central **hub** or **remote** to
    allow easy synchronization between the working copies on each developer’s computer.
    The hub server allows additional functionality, such as managing who is allowed
    to view or change the code, as well as collaborative features such as code reviews,
    bug tracking, documentation, and discussion. A DVCS also presents an easy way
    to control the publication of new releases of web-based applications. Many continuous
    deployment systems, such as **Travis CI**, **CircleCI**, and **Beanstalk**, are
    simply leveraging features of the DVCS to control the release management process.
  prefs: []
  type: TYPE_NORMAL
- en: The most famous DVCS is Git, created by **Linus Torvalds**, who also created
    the **Linux** operating system. The most famous DVCS hub is, you guessed it, GitHub,
    which is owned by Microsoft. Many people use the terms *Git* and *GitHub* interchangeably.
    This is a mistake. GitHub is a place on the internet. The software used to access
    *GitHub* is called *Git*. Many projects that use Git as their DVCS host their
    repository hub in services other than GitHub, such as **GitLab**, **Microsoft
    Azure DevOps**, **Atlassian Bitbucket**, and **Beanstalk** ([https://beanstalkapp.com](https://beanstalkapp.com),
    not to be confused with the Beanstalk service on **Amazon Web Services**, which
    has nothing to do with version control).
  prefs: []
  type: TYPE_NORMAL
- en: As developers make changes to their working copy, they can commit changes to
    their local copy. They can later synchronize their code by pulling changes from
    the central hub, reconciling any conflicts, and then pushing their merged work.
    Again, the big difference is in a DVCS; everything happens on the developer’s
    computer versus on a server with a centralized system.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Git on your computer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whether you installed Git for Windows on your Windows computer, or you are
    working with a pre-installed Git client on your Mac or Linux computer, you need
    to perform some additional setup beyond simply installing the software. The setup
    tasks ahead include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Set your default username and email address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **Secure Shell** (**SSH**) key so you can securely communicate with
    remote hubs such as GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the SSH key to your account on GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s go through the process for each.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, you need to launch a terminal. If you are using Mac or Linux,
    you should be able to find an app on your system, simply called *Terminal*. The
    commands I’ll present are going to be using the **Bash shell**. Mac’s terminal
    program defaults to a shell called the **Z shell** (**zsh**), which is directly
    compatible with Bash. Most Linux installations default to Bash, so you are all
    set. If you are in Windows, you need to have installed the Git software from [https://gitforwindows.org](https://gitforwindows.org).
    One of the programs installed is called *gitbash*. Launching **gitbash** will
    allow us all to use the same commands regardless of which operating system we’re
    using.
  prefs: []
  type: TYPE_NORMAL
- en: Setting your default username and email address
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having launched your terminal, you need to execute the following command to
    set your default username:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Naturally, you’ll fill in your actual name. Next, fill in your email address.
    If you work for a corporation, I strongly recommend creating a separate GitHub
    account to keep your work separate from your employers to avoid any nasty intellectual
    property disputes. Keeping that in mind, use an appropriate email address for
    your work with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There are more extensive configuration options beyond using these two globals,
    but this is the most common way to set up Git, and you won’t be able to push code
    to GitHub without these settings. If you’d like more in-depth information on working
    with Git, I recommend checking out the additional reading in the *Further reading*
    section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Generating an SSH key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One objective of a remote hub is to keep your code secure from malicious tampering.
    One of the ways this happens is to ensure all communications between your computer
    and the remote are encrypted. You can work with HTTPS encryption or SSH. While
    both are valid encryption tools, SSH is considered far superior and is the mark
    of a real pro. In order to work with SSH, you need to generate a unique pair of
    encryption keys: one public key and a matching private key. I won’t go into how
    SSH works here, but if you’re curious, I’ll leave some reading suggestions in
    the *Further reading* section of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generating a key is pretty simple. Having opened a Bash session, simply type
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The key generation program will ask you some questions, such as where to store
    your key files and what to call them. By default, they are called `id_rsa` (the
    private key) and `id_rsa.pub` (the public key), both of which are stored in your
    home folder in a sub-folder called `.ssh`.
  prefs: []
  type: TYPE_NORMAL
- en: The last question asked is the passphrase for the key. You can enter a password
    for the key for extra security, or just press *Enter* for an empty passphrase.
    This is generally not advisable, since security is tighter when you create a passphrase.
    The drawback to having a passphrase is you are constantly challenged to enter
    the passphrase. An empty passphrase bypasses these interruptions but puts security
    at risk by making your key easier to compromise. I recommend entering a passphrase
    because one of the advantages of using PyCharm’s tooling is that it stores your
    passphrase in its own encrypted database. PyCharm will answer all your challenges
    for you, eliminating the inconvenience of working with a passphrase-protected
    encryption key.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the passkey is entered, you’ll get some additional feedback. You can
    check your key by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This lists (`ls`) the files in your home folder (`~/`) under the `.ssh` sub-folder
    including any hidden files (`-a` for “all files”). You should see, at a minimum,
    the `id_rsa` and `id_rsa.pub` files. You are going to need the contents of the
    `id_rsa.pub` file in just a moment as you are going to paste its contents onto
    a screen on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve come to the part in the book where I offer a fatherly lecture on security.
    Never ever, ever, ever (times infinity to the googleth power plus one) paste your
    private key into anything. Never ever (ad nauseam) allow anybody to copy your
    private key. Don’t put it on a thumb drive. Don’t copy it to a network drive or
    cloud file share for safekeeping. For the love of everything holy, never check
    it into a repository! That goes for any passwords for any system. Your repos might
    ultimately become public, if not to the whole world, then at least to the rest
    of your team.
  prefs: []
  type: TYPE_NORMAL
- en: The public key is for sharing. The private key is to be kept secret and hidden.
    If your private key is compromised, only your passphrase protects your work. If
    you left the passphrase blank, then you have no further protection!
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the contents of your public key, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The contents of your public key will appear in your terminal window. Select
    the entire key, right-click, and click **Copy**.
  prefs: []
  type: TYPE_NORMAL
- en: Adding your SSH key to your GitHub account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’m going to cover this pretty quickly since I suspect many of you have done
    this before. If you need a better tutorial on adding an SSH key to your GitHub
    account, see the *Further reading* section at the end of this chapter for an explicit
    list of steps specific to Git.
  prefs: []
  type: TYPE_NORMAL
- en: Log in to GitHub and click your face. By that, I mean the avatar on GitHub in
    the upper-right corner, assuming they haven’t re-designed their site since going
    to press. Find the option for working with your profile and find **Settings**.
    Inside your profile settings is an option to manage your SSH keys. Click that
    link, then find the option to add an SSH key. Paste in the public key you copied
    a moment ago, give it a name that is easy to remember, and click the **Add** button.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You are fully set up for secure communications between your
    computer and GitHub remotes. It is possible to reuse your SSH key between different
    computers you own. Just copy the `.ssh` folder between computers. Just be careful
    not to compromise the key by keeping it on a portable drive you might lose, or
    a cloud file share that might be compromised.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a repository manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B19644_03.xhtml#_idTextAnchor052), *Customizing Interpreters
    and Virtual Environments*, we created a virtual environment manually in order
    to become familiar with the process. We’ll do the same thing here. Let’s use the
    command line to create a repository and perform all the basic functions available
    in Git. Afterward, we’ll see where PyCharm’s tooling allows us to perform the
    same operations right from the IDE in a convenient GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t use spaces in any file or folder name
  prefs: []
  type: TYPE_NORMAL
- en: I’m going to bring this up often since I know a lot of readers skip around in
    books like this one. If you are new to software development, you may not know
    that using filenames with spaces can cause problems. Avoid using file and folder
    names with spaces, including any folders created by your operating system. Instead,
    use separators in place of spaces, such as dashes or underscores, or use camelCase
    names, which omit spaces and present word boundaries with a capital letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'With your Bash terminal session open, the first thing we’re going to do is
    create a folder for our project. We’ll do this in your home folder with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s change the directory to the newly created folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is where our code is going to live! Before we go any further though, we
    need to talk about a sensitive subject.
  prefs: []
  type: TYPE_NORMAL
- en: Master versus main branches in GitHub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the first 12 years after GitHub was established, whenever one created a
    new repository in GitHub, the tool established a default starting branch called
    *master*. In 2020, an organization called *The Software Freedom Conservancy* advised
    GitHub to change the name of the default branch from *master* to *main* owing
    to the association of the term *master* with slavery. While Git doesn’t force
    you to use any particular name, the default on GitHub has been changed to *main*.
    Since GitHub doesn’t control Git, this name change is only the default on repositories
    created by GitHub. We’ve been creating our repositories using the Git command
    line, which is leveraged by PyCharm’s Git tools. Whether you use the Git command
    or PyCharm’s integration, there’s a solid chance you’re going to get a repository
    initialized with a branch called *master*. When you create a remote on GitHub,
    that repo will be created with a default branch called *main*.
  prefs: []
  type: TYPE_NORMAL
- en: You should take care to match the names of the default branches so that when
    you perform your first push, your branches synchronize properly. You can either
    change the name in GitHub or set the Git command on your computer to use *main*
    for the default.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to change it on GitHub, you can go into your profile settings and
    click **Repositories**. You’ll find the setting at the top, as shown in *Figure
    5**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: You can set the default name of repositories in GitHub to match
    the default on your computer](img/B19644_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: You can set the default name of repositories in GitHub to match
    the default on your computer'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also set a global setting on your computer with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you intend to do a lot of work with GitHub as your remote, it is a good idea
    to synchronize the default branch name. If you don’t, the first time you try to
    push the repository you created on your computer to the remote created on GitHub,
    you’ll encounter an error. The default locally is *master*, while the default
    on the remote is *main*. The remote won’t have a branch called *master*, so you’ll
    get a message stating there is no upstream branch called *master*. You’ll have
    to do some work to get this settled. I’ll leave a link to an article on how to
    resolve this situation should you encounter it. I encourage you to just avoid
    it entirely by using the preceding Git command to set your local global setting
    to *main* so it matches GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Manually initializing the repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create our repository. It is entirely possible, and even normal, to create
    a repository after you have created a code project. However, we will start with
    the repository since this will be a very simple demonstration. To create a new
    Git repository, or repo for short, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'That was easy! It might look like nothing much happened. You’ll get a message
    stating the repository was created. Let’s look at the changes to the folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `ls` command lists all the files. The `-a` switch shows hidden files and
    folders. When you initialized the Git repository, the Git software created a folder
    called `.git`. Since the folder name starts with a period (`.`), the folder is
    hidden in Linux-like systems. If you perform these steps in Windows with PowerShell,
    you’ll be able to see the folder, but it’s hidden in the other operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: The `.git` folder is where all your revisions are stored, along with all your
    project’s settings. In general, you should never need to alter the contents of
    this folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a repository on our local computer. Let’s add a new file. Type the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This created a new file called `test.txt`. Within that file is the line `hello
    world`. What a great way to start, right? You can check the contents of the file
    by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Who needs an IDE, right? Wait, no, forget I said that. The order of the next
    few steps is important. The process is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the file(s) to the repository. The files you are adding are the files you
    have either created or modified since your last commit. We don’t have one of those
    yet. Adding your files to the repo is also called staging your files. We are making
    the repository aware of new and changed files. You shouldn’t always add every
    file to your project. There are some you should keep out of your repository. We’ll
    cover that a little later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit your files. This creates a new version of your code on your local computer.
    The commit action requires you to include a comment that explains the nature of
    the changes you’ve made. This is vital! You should endeavor to write a concise
    summary of your changes, and you should write these comments as though your most
    important customer will one day read all these comments. This is not a place to
    vent your frustrations! Trust me on this one. I’ve seen projects fall under unexpected
    audits where mean or inappropriate comments surfaced and working relationships
    were ruined. Assume everything you write will be read and judged by the whole
    world.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull changes from the remote hub. You always want to pull before you push. This
    allows you to find any conflicts between your work, and any work that might have
    been pushed by another developer on the project. This is important! If you don’t
    pull before your push, it is possible to overwrite another developer’s revision!
    This is certainly not catastrophic since all revisions are held in the repo. It
    will, however, make tomorrow’s stand-up meeting very awkward for you as the other
    developer will likely not be happy with you for making extra work for the group!
    It’s simple. Just remember to pull before you push. Do this even if you are the
    only person working on the project and just make it a habit!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assuming there are no conflicts, push your work to the remote hub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your revisions are now available to the rest of the team and stored securely
    on the remote server. Let’s go through the commands for this process.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add your new and changed files to Git. Remember, this is also called
    **staging** your files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a bunch of files in your project, it is possible to add them all
    at once with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With your latest changes staged, you can now commit them to the local repo.
    This creates a new version of your project on your computer. You need to include
    a comment that summarizes your changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `-m` switch is our comment, which is enclosed in double quotes. Just remember
    it as a *commit message* and the `-m` switch is easy to remember. Of course, by
    the end of the chapter, you won’t need to remember all this command-line stuff
    since you’ll have a nifty GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Working with remotes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is possible to work with a project entirely on your local computer. Naturally,
    you’d lose all the collaborative benefits provided by a remote hub, including
    the benefits of a remote backup of your change history. Earlier, I presented a
    four-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: Add or stage your changed files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit your changes to create a new revision.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull changes from the remote.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push your merged work to the remote.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’re halfway through the list, having completed the first two steps on our
    local copy of the repository. We must interrupt the process at this point because
    we don’t presently have a remote. We’re going to create one on GitHub, but naturally,
    you can use any compatible service.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a remote on GitHub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Log on to GitHub and find the **Add Repository** button. It is usually a very
    obvious green button. With my luck, they’ll redo the site at press time. Nevertheless,
    they usually make the **Create repository** button very obvious on the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a repository to match the one we created locally. I’ll make mine
    public, which means everybody can see it. If you’re bashful, you can make it private.
    It won’t matter for this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have created the repository, GitHub will display instructions for adding
    the GitHub version of the repo as a remote. Just copy and paste the code GitHub
    generated into your terminal, making sure that your terminal is currently in the
    repository folder as the present working directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify the remote by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The command generated by GitHub sets the name of the GitHub copy of the repo
    as *origin*. You should have one remote called *origin*, while the local version
    of the repository is referred to by the current branch, which is usually *main*,
    as described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The first push
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have a remote, you can push your local repo to the remote. Type
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This pushes your copy of the main branch to the remote and sets upstream tracking
    for the main branch. This is just a fancy way of saying both the remote and the
    local repository are aware of the main branch, and any push here will result in
    the remote main branch being updated. If the remote doesn’t have a branch called
    `main`, one will be created and everything will synchronize nicely.
  prefs: []
  type: TYPE_NORMAL
- en: Making, committing, and pushing a change
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a fully working repository, complete with a remote on GitHub,
    let’s make one full round of changes to our code. We’ll cover the four-step process
    this time without interruption. This is the process you’ll follow many times per
    day for the duration of your project.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is very important. Make this a habit!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This pulls any changes sitting on the remote and allows you to fix any conflicts
    before they go out into the world! Naturally, in this situation, there won’t be
    any conflicts since only we are working on the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s change the contents of our text file. Type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check the result with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the changed file. Now let’s do a full cycle of add, commit,
    pull, and push. Type each of the following lines, one at a time, and press *Enter*
    at the end of each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Switch to your browser where you created your repository, and refresh the page.
    You should see your code. You can click the `test.txt` file in the browser to
    verify the new contents were pushed. You should also see there are two revisions.
  prefs: []
  type: TYPE_NORMAL
- en: Your repo is set up and working properly! Let’s switch our focus from the command
    line to working in the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Git in the IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already gone through some of the Git workflows in PyCharm. In [*Chapter
    2*](B19644_02.xhtml#_idTextAnchor028), *Installation and Configuration*, we used
    PyCharm to clone the sample code repository for this book. Since we’ve covered
    cloning, we won’t do it again. Instead, let’s consider all we did manually a moment
    ago:'
  prefs: []
  type: TYPE_NORMAL
- en: We used `git init` to initialize a new local repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We made a change to our code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We used `git add` to add the changes as staged files in preparation for a commit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We committed our changes to the local repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We pulled from the remote to make sure we have the latest code on this branch
    and that no conflicts exist between what we have in our working copy and what
    exists on the remote. The remote could have recently changed owing to some other
    developer pushing their changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we pushed our changes to the remote.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This list represents the most basic workflow for capturing and managing revisions
    on a project. We can do all of this and more in PyCharm’s GUI. It is also fairly
    common to do some work in PyCharm and some in the command line. Using one or the
    other doesn’t preclude anything. For example, I often branch and merge in the
    command line because it’s quick and easy for me. If there is a conflict, I find
    resolving it in PyCharm to be superior in every way versus a manual approach.
    The GUI for this task is outstanding. We’ll get to all this in good time. For
    now, open the folder you’ve been using in PyCharm, and let’s explore what the
    IDE can do for us regarding these first steps we’ve taken manually.
  prefs: []
  type: TYPE_NORMAL
- en: Version control in PyCharm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PyCharm has several places in the UI that allow you to access your VCS, which
    for us is Git. They aren’t redundant, but instead, each area provides a visual
    tool for a particular task. The first is the main menu, as seen in *Figure 5**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: The Git menu allows you to access all the commands you might
    normally use at the command line](img/B19644_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: The Git menu allows you to access all the commands you might normally
    use at the command line'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second provides a fast and easy way to commit files. This can be found
    in the sidebar menu, as seen in *Figure 5**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: The Git commit tools can be found in the sidebar](img/B19644_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: The Git commit tools can be found in the sidebar'
  prefs: []
  type: TYPE_NORMAL
- en: The third allows visualization of the branch and commit history. This can be
    found in the tool window located at the bottom of the screen. This section of
    the screen collapses, but the tool window selector is always available at the
    bottom of the sidebar, as seen in *Figure 5**.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4: Clicking the Git tool window will open a window that shows you
    the commit history, along with all the branches](img/B19644_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Clicking the Git tool window will open a window that shows you
    the commit history, along with all the branches'
  prefs: []
  type: TYPE_NORMAL
- en: The fourth is on the top toolbar next to the main menu. This area shows you
    the branch you are currently working on and allows easy branch management. You
    can see this in *Figure 5**.5*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5: The current branch is displayed near the main menu. Clicking
    here allows you access to a few commands](img/B19644_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: The current branch is displayed near the main menu. Clicking here
    allows you access to a few commands'
  prefs: []
  type: TYPE_NORMAL
- en: The fifth is the VCS operations popup, as shown in *Figure 5**.6*. This has
    been around for quite a while and I would consider it legacy even though it’s
    still there. You can get to the popup using *Ctrl* + *`*. Please note that isn’t
    a quotation mark. The `` ` `` key, called the gravure mark, is located to the
    left of the *1* (one) key on the US keyboard layout.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6: The VCS operations pop-up window is activated with Ctrl/Cmd +
    `.](img/B19644_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: The VCS operations pop-up window is activated with Ctrl/Cmd + `.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can right-click the editor window or a tab in the editor window
    to access the same Git menu found in the main menu, as shown in *Figure 5**.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7: You can right-click in the editor window or on a tab to see the
    Git menu](img/B19644_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: You can right-click in the editor window or on a tab to see the
    Git menu'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, tooling for revision control is neatly woven into the IDE in
    an organized and intelligent fashion. Since we opened a folder that already had
    a Git repository in place, PyCharm simply recognizes that fact and presents the
    interface. When you open a folder or create a project without a GitHub repo, most
    of the tooling will still be visible, but it won’t be Git specific. Since PyCharm
    supports many VCSs, a project that hasn’t been initialized using Git or any other
    VCS will present generic tooling until such initialization is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project from scratch using VCS tooling in PyCharm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s make a new project. The code for this project is in the repo for the book,
    but you don’t really want to just open that copy because it will already be associated
    with a repository, and you won’t see everything I’m about to show you. For this
    exercise, you should create a new project from scratch as I am about to do.
  prefs: []
  type: TYPE_NORMAL
- en: Click the hamburger icon in the top-left corner of the application to activate
    the main menu, then click `project_git_demo`. I’ll leave everything else as default.
    You can see my project creation dialog in *Figure 5**.8*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8: My demo project settings](img/B19644_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.8: My demo project settings'
  prefs: []
  type: TYPE_NORMAL
- en: We now have a project with which we can work.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the local Git repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After my project has been created, I need to initialize a Git repository. Manually,
    we did this with the `git init` command. In PyCharm, we can use the main menu’s
    **VCS** option. Right now, it says **VCS** because we haven’t initialized a repository
    with any VCS yet, so the terminology in the UI is generic. As you can see in *Figure
    5**.9*, we have options for revision control in Mercurial, Git, GitHub, Perforce,
    and Subversion. There is a new option for sharing a project on JetBrains’ new
    collaboration product called **Space**, which contains a Git hosting service.
    Naturally, as the Space product grows, you can expect to see more and more integration
    appear in all the IDEs. I’m going to click **Create Git Repository…**, as shown
    in *Figure 5**.9*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9: Creating a Git repository from the PyCharm VCS menu](img/B19644_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.9: Creating a Git repository from the PyCharm VCS menu'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 5**.10*, you are next prompted to select the folder
    where you’d like to create the repository. It defaults to the current folder,
    which is correct.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10: Select the folder where you’d like to create the Git repository](img/B19644_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.10: Select the folder where you’d like to create the Git repository'
  prefs: []
  type: TYPE_NORMAL
- en: Clicking the **OK** button creates the repository in the selected folder. You
    can verify that it worked by checking whether the default branch (master) appears
    in the top toolbar with a dropdown that contains a few Git operations. Now that
    we have initialized a Git repository, the menus no longer use the term **VCS**
    but instead list options specifically for Git.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a remote on GitHub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There isn’t tooling in PyCharm for creating a remote. You need to log in to
    GitHub and create a repository just as you did earlier. *Figure 5**.11* shows
    me setting up the remote repository in my personal account. Note this is distinct
    from the book’s repository, which is meant to house all the code in the book rather
    than serve as a demonstration of creating a repository.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11: The settings for my remote](img/B19644_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.11: The settings for my remote'
  prefs: []
  type: TYPE_NORMAL
- en: Note that only the bare minimum is set. No `.gitignore` file, no README file,
    and so on. I’m going to add all those in PyCharm. When I click the **Create repository**
    button, GitHub generates the URL I need for adding the remote. I’ve pointed this
    out in *Figure 5**.12*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12: You need the URL for the remote in order to add it to your local
    repository](img/B19644_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.12: You need the URL for the remote in order to add it to your local
    repository'
  prefs: []
  type: TYPE_NORMAL
- en: Next, switch back to PyCharm and find the **git** menu within the main menu.
    Remember, a minute ago, the menu said **VCS** because we had not defined a repository,
    but now it says **git**.
  prefs: []
  type: TYPE_NORMAL
- en: Within the **git** menu, you’ll find an option called **Manage Remotes**. Click
    that and you’ll see a modal dialog, shown in *Figure 5**.13*, which allows you
    to add the remote you just created on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13: The Git Remotes dialog allows you to add the remote you created
    on GitHub](img/B19644_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.13: The Git Remotes dialog allows you to add the remote you created
    on GitHub'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **+** button to add a remote. You get yet another dialog on top of
    this one, as seen in *Figure 5**.14*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14: Add the URL you copied from the GitHub page](img/B19644_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.14: Add the URL you copied from the GitHub page'
  prefs: []
  type: TYPE_NORMAL
- en: Click `main.py` file is red.. You’ll just have to trust me. It’s red because
    it is an untracked file. We need to add our files to our repository so we can
    track them.
  prefs: []
  type: TYPE_NORMAL
- en: Adding project files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting up the project and the remote is something you generally only do once
    for the duration of the project. If you’re joining an existing team, it may have
    been done long before you joined. This next set of actions, though, is something
    you’ll work with every day.
  prefs: []
  type: TYPE_NORMAL
- en: When you are working with changes you’ve made to the project, you’ll find the
    **Commit** window very useful. Refer back to *Figure 5**.3* if you have forgotten
    how to locate the **Commit** window.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a .gitignore file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’re not familiar, a `.gitignore` file defines files and folders you don’t
    want to include in your repository. As a general rule, anything that can be generated
    from your code doesn’t need to be in your repository. When working with Python
    projects, a short list of things you don’t want in your repo might include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `venv` folder since this is generated by running `pip`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python cache folders (you’ll see them as `__pycache__` folders)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Byte-compiled DLL files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build files from distribution and packaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PyInstaller manifests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application log files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test coverage reports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is by no means an exhaustive list. The list will really depend on what
    kind of application you are building and exactly what gets generated during a
    run of your project. There are plenty of suggestions on the contents of a `.gitignore`
    file. GitHub has such a list in a gist. You can get this file at [https://githubgitm/github/gigitnore/blgitmain/Python.gitignore](https://githubgitm/github/gigitnore/blgitmain/Python.gitignore).
    It is also the `.gitignore` file in the book’s Git repository. You can use this
    `.gitignore` file if you’d like, but to keep this short and easy, I’m just going
    to include a few entries in a `.gitignore` file we will create.
  prefs: []
  type: TYPE_NORMAL
- en: Switch back to the file view, as shown in *Figure 5**.15*. You do this by clicking
    the folder icon (`project_git_demo` project title (`.gitignore`. No creativity
    is allowed here. It must be called `.gitignore`, all lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15: Switch back to the file view and create a new file called .gitignore](img/B19644_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.15: Switch back to the file view and create a new file called .gitignore'
  prefs: []
  type: TYPE_NORMAL
- en: When you create the new file, PyCharm will prompt you to add the file to Git,
    as shown in *Figure 5**.16*. If you want to add new files to become the default,
    you can click the **Don’t ask again** checkbox and all files you create will be
    added to GitHub automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16: Each time you create a file in PyCharm, you are prompted to
    add it to the repository](img/B19644_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.16: Each time you create a file in PyCharm, you are prompted to add
    it to the repository'
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of what you do with the checkbox, click the `.gitignore` file shows
    green in the project explorer since it was added and nothing has yet changed.
    Within the `.gitignore` file, add these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will exclude the entire `venv` folder and any cache folders generated by
    Python. PyCharm saves your files as we go, so let’s add this file and the `main.py`
    file to the repository. Switch to the **Commit** window and you’ll see something
    like *Figure 5**.17*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17: The commit window after we’ve added our .gitignore file](img/B19644_5_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.17: The commit window after we’ve added our .gitignore file'
  prefs: []
  type: TYPE_NORMAL
- en: Wow! Where did all that come from? We just added one file! As you can see, the
    `.gitignore` file was added in response to the dialog we saw when we created the
    file. The only other code file in the project is the `main.py` file generated
    by PyCharm when we created the project. What about the rest? Why is there a second
    `.gitignore` file listed in the unversioned files list?
  prefs: []
  type: TYPE_NORMAL
- en: 'These all come from the `.idea` folder created by PyCharm. There is some debate
    on whether this folder belongs in source control. JetBrains has a page in their
    documentation at [https://intellij-support.jetbrains.com/hc/en-us/articles/206544839](https://intellij-support.jetbrains.com/hc/en-us/articles/206544839)
    discussing their ideas on the subject. To sum up the article, JetBrains recommends
    storing the contents of the `.idea` folder pertaining to the project, but not
    any files that contain user-specific settings, which are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`workspace.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usage.statistics.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything in the `shelf` directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The article is meant to cover all `.gitignore` file. We haven’t committed anything
    yet, so add these lines to your `.``gitignore` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Let’s check all the boxes to get all those files added, as shown in *Figure
    5**.18*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18: Everything is added and we’re ready to commit](img/B19644_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.18: Everything is added and we’re ready to commit'
  prefs: []
  type: TYPE_NORMAL
- en: Add a commit message in the box. You can click the **Commit** button to commit
    to your local repository or **Commit and Push…** to send the changes straight
    to GitHub. As a general rule, you should not use the **Commit and Push…** button
    unless you are completely certain that no one could have pushed changes since
    the last push. It is probably safe because we have never pushed; however, I’m
    going to hit the **Commit** button to demonstrate the whole process laid out earlier.
    You add your changes, commit, pull, and then push. So far, we’ve added our changes,
    and now we’re committing.
  prefs: []
  type: TYPE_NORMAL
- en: If all goes well, a toast will appear in the lower-right corner of your screen
    stating that your files were successfully committed. If you didn’t set your global
    username and email address during the manual exercise, you will be prompted via
    a dialog to set them up.
  prefs: []
  type: TYPE_NORMAL
- en: Pulling and pushing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the first commit is out of the way, we are set to do the last half
    of the process. We always pull before pushing to ensure we have the latest revision
    on the current branch. This allows us a chance to resolve any conflicts that might
    have arisen since our last pull. In Git, the command we used was `pull`. There
    is a `pull` option in the Git tools, but before we go there, I will point out
    another option: **Update Project…**. This is found in the dropdown in the toolbar
    denoted by the current branch, as shown in *Figure 5**.19*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19: The Update Project… command isn’t really a Git command. It refers
    to an update strategy](img/B19644_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.19: The Update Project… command isn’t really a Git command. It refers
    to an update strategy'
  prefs: []
  type: TYPE_NORMAL
- en: When you click **Update Project…**, you’ll be asked to set your preference for
    updating your local Git repository. There are two possibilities depicted in the
    ensuing dialog box, as shown in *Figure 5**.20*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20: There are two update strategies from which to choose](img/B19644_05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.20: There are two update strategies from which to choose'
  prefs: []
  type: TYPE_NORMAL
- en: The `git pull` command we executed earlier embodies the first option. The pull
    operation will *fetch* any changes from the remote and automatically *merge* those
    changes into our local copy. The `rebase` operation is a different strategy. It
    changes the structure of your repository in order to show a cleaner timeline of
    changes. I won’t get into the arguments of which strategy to use, but I will include
    a link in the *Further reading* section of this chapter should you desire to dive
    deeper.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I prefer the first option since it is simpler and safer. I only
    have to click the **OK** button. I can click the **Don’t show again** checkbox
    if I do not want to be prompted before use. PyCharm will forevermore use the selection
    I make here and now.
  prefs: []
  type: TYPE_NORMAL
- en: If you have problems with commitment, I don’t mean generally, but technically,
    when it comes to executing `git commit`, you can skip this dialog entirely. Just
    use the **Pull…** menu item on the Git menu, as shown in *Figure 5**.21*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21: You can do a traditional Git pull from any of the Git menus](img/B19644_05_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.21: You can do a traditional Git pull from any of the Git menus'
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing left to do but push. Perhaps the quickest way was shown previously
    in *Figure 5**.19*, where we encountered the **Update** **Project…** command.
  prefs: []
  type: TYPE_NORMAL
- en: Branching and merging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have discussed the most basic functions of any VCS, which protects the project’s
    code by tracking revisions over time. A second set of very important functions
    entails segregating the project work into several copies. This practice is called
    **branching**. There are many benefits to branching; I can’t cover them all here.
    If you’d like more details on version control with Git, check out the Packt book
    *Git for Programmers* listed in the *Further reading* section of this chapter.
    However, I’ll offer what I consider to be the most important benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a typical web start-up that goes through a cycle of creating a repository
    and iterating development to its first release. The release is sitting on a production
    server somewhere in the cloud and customers have started using the app. The start-up
    company not only wants to enhance their offering with additional features, but
    they will also encounter bugs and problems that must be fixed. Let’s pretend the
    development and quality assurance teams did such an amazing job that there are
    virtually no bugs in the release. Pleased with themselves, the company wants to
    start adding new features. All work is being done in the main branch because that
    is the only one that exists. In order to add a new feature, we need to change
    something deep within the code. The moment you start the change, you need a week
    to finish it, and during that time, the development version of the product is
    very unstable.
  prefs: []
  type: TYPE_NORMAL
- en: All of a sudden, reality sets in. It is nigh impossible to have a software release
    with no bugs, unless, of course, the software was written by unicorns or Chuck
    Norris. Let’s say it’s not just a bug. It’s a bad bug. Something like someone
    forgot a `WHERE customer_id=@customerId` on a SQL statement and your app erroneously
    displays all customer data to all customers. That’s a career-ender! I’ve seen
    it happen and it isn’t pretty. You need to fix it *immediately*! Except you can’t
    without backing out all those changes you’ve made that might render the app unstable.
    That is one option. Another option is that you could revert to the code you released,
    then implement the fix and save your career. You would then spend a lot of time
    trying to cherry-pick the commits to salvage your feature work. You could also
    elect to write all of your code in Notepad using a keyboard set to the Dvorak
    layout with totally blank keys. You could do it, but it wouldn’t be a productive
    use of your time.
  prefs: []
  type: TYPE_NORMAL
- en: This is where branching comes into play. The start-up can do all its work on
    the main branch. They shouldn’t, but let’s keep the story constrained to what
    we have so far. Once the software is released, they could make a new branch and
    maybe call it *development-branch*. The name isn’t important. The branching operation
    creates a copy of what was released. It is in that branch that our intrepid development
    team starts to make changes that might have rendered the development version unstable.
  prefs: []
  type: TYPE_NORMAL
- en: Boom! The bad thing happens. You can switch from *development-branch* back to
    *main*. You now have the code that was released, and you can fix the problem.
    After the fix is in place, you can merge the fix into your development branch
    and continue working on your unstable app in *development-branch*. Keeping the
    work segregated allows you to work on new features independently of emergency
    bug fixes.
  prefs: []
  type: TYPE_NORMAL
- en: I am grossly over-simplifying the typical branching strategy used by most teams
    in this illustration. I would prefer to leave coverage of that topic to works
    dedicated to version control. I’ll leave suggestions for further reading on branching
    strategies in the *Further reading* section of this chapter. Let’s continue with
    the mechanics of working with branches. They are vital to your daily practice
    of software development.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a branch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a new branch is very easy. Click the branch menu on the top menu bar
    and click **New Branch**. You’ll see the dialog shown in *Figure 5**.22*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22: The Create New Branch dialog allows you to create a new Git
    branch](img/B19644_05_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.22: The Create New Branch dialog allows you to create a new Git branch'
  prefs: []
  type: TYPE_NORMAL
- en: Type a name for your new branch. The branch is created locally, and you are
    automatically switched to the new branch.
  prefs: []
  type: TYPE_NORMAL
- en: Switching between branches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is also very easy. Go back to the branch menu. The local branches are listed
    in the branch dropdown, as shown in *Figure 5**.23*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23: Local branches are listed in the branch menu](img/B19644_05_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.23: Local branches are listed in the branch menu'
  prefs: []
  type: TYPE_NORMAL
- en: Switching to a different branch is just a matter of clicking the desired branch
    from the list and then clicking **Checkout**. As you can see, there are other
    operations you can perform on the branch.
  prefs: []
  type: TYPE_NORMAL
- en: Merging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you’re ready to merge a branch back into main, or any other branch for
    that matter, simply switch to that branch, then use the **Merge** command in the
    branch menu, as shown in *Figure 5**.24*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24: The Merge command can be found in the branch menu](img/B19644_05_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.24: The Merge command can be found in the branch menu'
  prefs: []
  type: TYPE_NORMAL
- en: The **Merge** dialog, shown in *Figure 5**.24*, will allow you to select the
    branch you’d like to merge into the currently selected branch.
  prefs: []
  type: TYPE_NORMAL
- en: If you need something more exotic than the standard merge operation, there is
    a **Modify options** dropdown, which allows you to do the equivalent of several
    command-line switches normally employed during the manual merge process.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the branch diagram
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Git tool in the tool window provides a graphical view of the various branches
    in your repository. You can see it in *Figure 5**.25*. This can be useful when
    you need to review what has recently changed in the repository. It’s the kind
    of thing you might do first thing in the morning so you can review your team’s
    changes in the last 24 hours.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.25: The Git tool can be activated by clicking on the toolbar on
    the lower-left edge of the PyCharm window](img/B19644_05_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.25: The Git tool can be activated by clicking on the toolbar on the
    lower-left edge of the PyCharm window'
  prefs: []
  type: TYPE_NORMAL
- en: To activate it, click the Git icon in the tool window (**1**). You can search
    the revision history and filter it using the various tools on the toolbar (**2**).
    Selecting a commit (**3**) allows you to see the details of that commit (**4**)
    along with the commit message.
  prefs: []
  type: TYPE_NORMAL
- en: Diffs and conflict resolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sooner or later, you’re going to perform a pull prior to pushing some changes
    only to discover a conflict exists. This can be intimidating and stressful even
    for experienced developers because you are running the risk of breaking someone
    else’s recent contribution. Nevertheless, it happens and you need a way to deal
    with the problem. This leads us to one of my favorite features in PyCharm. In
    [*Chapter 1*](B19644_01.xhtml#_idTextAnchor014), *Introduction to PyCharm – the
    Most Popular IDE for Python*, I told you about my experience with Microsoft’s
    debugger. Having experienced it early in my career, to me, nothing else will do.
    I have the same regard for PyCharm’s merge tool. Resolving a conflicted merge
    in anything else feels painful.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is only one file in the project. By now, you’ll recognize it as the `main.py`
    file PyCharm generates with new projects. We’re going to generate a conflict using
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project in PyCharm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the contents of the `main.py` file to a single line of code to ensure
    we generate a conflict.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize a Git repository in the project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add and commit all project files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new branch called *development*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the line of code that renders the *Hello* *World* message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit the change to the branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch back to the main branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a different change to the one line of code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit the change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now try to merge the development branch into the main branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result of these 11 steps will be a conflict. Let’s resolve it!
  prefs: []
  type: TYPE_NORMAL
- en: First, create a new project called `conflict_resolution` in PyCharm, as shown
    in *Figure 5**.26*. Make sure you create the project in a location on your drive
    outside of the folder structure for the book’s repository. Remember, the book’s
    code is already in a repository. You can’t create a new repo inside another repo.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.26: My conflict_resolution project settings. They’re just defaults](img/B19644_05.26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.26: My conflict_resolution project settings. They’re just defaults'
  prefs: []
  type: TYPE_NORMAL
- en: 'PyCharm generates a project with a `main.py` file. Delete all the lines in
    `main.py` and replace them with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Just so we’re clear, your PyCharm window should look just like mine in *Figure
    5**.27*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.27: The main.py file has been reduced to one line of code](img/B19644_05_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.27: The main.py file has been reduced to one line of code'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **VCS** menu in the **File** menu and click **Create Git repository**.
    If you don’t remember where in the menu to find this, refer back to *Figure 5**.9*.
    Make note of the default branch that was created. We don’t need a remote for this
    exercise, so it doesn’t matter whether it’s *main*, *master*, or something else;
    you just need to remember its name. I’ll assume it’s called *main*.
  prefs: []
  type: TYPE_NORMAL
- en: Use the commit window to add the files for the project to the repository. *Figure
    5**.3* will remind you if you have forgotten how. Go ahead and commit the files
    by entering a commit message.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to create a branch. Click the branch dropdown and click `development`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `main.py` file. Replace the code with this one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: By limiting ourselves to a single line, we can be positive our actions will
    result in a conflict. Commit this change to the `development` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to the main branch using the branch dropdown. Change the contents
    of `main.py` to this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Commit this change to the main branch. You’ve just simulated two developers
    changing the same file, in the same area. There will be no way for Git to reconcile
    the differences. With the main branch active, click the branch dropdown, click
    the development branch, and click **Merge development into main**. You will see
    a conflict message, as shown in *Figure 5**.28*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.28: We have a conflict that needs to be resolved before we can merge](img/B19644_05_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.28: We have a conflict that needs to be resolved before we can merge'
  prefs: []
  type: TYPE_NORMAL
- en: You generally have three options when resolving a conflict. You can choose to
    ignore the incoming changes and select your local work as the correct code by
    clicking the **Accept Yours** button. Likewise, you can select the incoming code
    changes and discard your local copy by clicking **Accept Theirs**. Often, though,
    you will need to merge parts of your local revision with the incoming changes.
    For this, you will need to activate the merge tool, as shown in *Figure 5**.29*,
    by clicking the **Merge…** button.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.29: Activate the merge tool to pick parts from the incoming code
    to merge with yours](img/B19644_05_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.29: Activate the merge tool to pick parts from the incoming code to
    merge with yours'
  prefs: []
  type: TYPE_NORMAL
- en: With the merge tool active, you can see three panes. The pane on the left (**1**)
    represents the conflicting code from the main branch. The code on the right (**2**)
    is the revision coming from the development branch. The pane in the middle (**3**)
    represents the amalgamation of the two. You can pick parts of your code and parts
    of the incoming code to make the best possible combination. Experiment with the
    **>>** buttons (**4**), which copy the code into the central merged result. The
    buttons labeled **X** (**4**) will ignore the conflicted line. You can use the
    up and down arrows (**5**) to jump to the next unresolved conflict in the file.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s pretend the best resolution to my conflict is to have a line from the
    left pane and a line from the right pane together. In real life, this wouldn’t
    work because we’re going to wind up with two variable assignments next to each
    other, but it does demonstrate how the tool works. To use the line from the left
    pane, I can click the button indicated by the arrow in *Figure 5**.30*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.30: This button will move the code from the left pane into the working
    merge solution](img/B19644_05_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.30: This button will move the code from the left pane into the working
    merge solution'
  prefs: []
  type: TYPE_NORMAL
- en: Next, I’d like to place the line from the right pane below the line I just moved.
    Often, you want to use some of the code from both sides rather than it simply
    being right or wrong from one side. Click the button indicated by the arrow in
    *Figure 5**.31* to copy the code from the left pane below the current line in
    the middle pane.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.31: Clicking the double arrow copies this line below the one we
    selected from the right side](img/B19644_05_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.31: Clicking the double arrow copies this line below the one we selected
    from the right side'
  prefs: []
  type: TYPE_NORMAL
- en: Once you complete this action, you have resolved the conflict! You are rewarded
    with a nice green message telling you as much.
  prefs: []
  type: TYPE_NORMAL
- en: Your objective is to use the left and right panes to create the best version
    of the code in the middle pane, which represents the resolution of the conflict.
    When you’re finished, you can click the **Apply** button. If you have unresolved
    conflicts remaining in the file, PyCharm will tell you that. If you got them all,
    the merge you attempted is completed. If you are working with a remote, you should
    push the resulting conflict resolution once the commit is successful.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing diffs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You don’t need a conflict to use the diff window we just saw. A diff window
    is a window that shows two or more versions of code side by side. You can diff
    between branches, or between revisions. Say I make a quick change to our merged
    code by adding this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'I also take out line 2, which reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: My code is now very different. If I want to compare my new code with the latest
    in the branch, I can right-click the `main.py` tab and click **Git** | **Show
    Diff**. I’ll see a side-by-side diff of the two files, as shown in *Figure 5**.32*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.32: The diff view between what you’ve got in your editor versus
    the last committed version](img/B19644_05_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.32: The diff view between what you’ve got in your editor versus the
    last committed version'
  prefs: []
  type: TYPE_NORMAL
- en: This diff is appearing in a side-by-side format. You can change it to an in-line
    view, which is often shown on GitHub when you view commits, by changing the drop-down
    setting labeled (**1**). You can also edit the file using the same line-moving
    tools you just saw in the merge indicated by (**2**).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have covered two main topics—the idea of version control
    in application development and programming and its importance, as well as how
    to practice it using Git and GitHub within PyCharm. Specifically, we have learned
    how to carry out version control using Git and GitHub in two different ways: manually
    and with PyCharm.'
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, PyCharm users can apply version control to their own projects
    in a flexible way, skipping over the manual and tedious process in the terminal/command
    line. We see that, by offering these features, PyCharm allows us to focus on the
    actual development process in any given software engineering project.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from version control, there are other practices in application development—
    which PyCharm provides intuitive, straightforward commands to facilitate. Without
    these commands, application development be quite complex and intimidating. These
    processes are testing, debugging, and profiling, all of which will be discussed
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does the term *version control* entail, specifically in the context of
    programming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of using version control?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the basic steps to version control for your own projects with Git and
    GitHub?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is *branching* and why is it important?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the various windows and tool locations throughout PyCharm that give you
    access to Git and other VCS commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Be sure to check out the companion website for the book at [https://www.pycharm-book.com](https://www.pycharm-book.com).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Merging vs.* *Rebasing*: [https://www.atlassian.com/git/tutorials/merging-vs-rebasing](https://www.atlassian.com/git/tutorials/merging-vs-rebasing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How Secure Shell (SSH) works: [https://en.wikipedia.org/wiki/Secure_Shell](https://en.wikipedia.org/wiki/Secure_Shell)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Adding a new SSH key to your GitHub* *account*: [https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Why GitHub renamed its master branch to* *main*: [https://www.theserverside.com/feature/Why-GitHub-renamed-its-master-branch-to-main](https://www.theserverside.com/feature/Why-GitHub-renamed-its-master-branch-to-main
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Git Merge Strategy Options and* *Examples*: [https://www.atlassian.com/git/tutorials/using-branches/merge-strategy](https://www.atlassian.com/git/tutorials/using-branches/merge-strategy
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Git branching guidance: [https://learn.microsoft.com/en-us/azure/devops/repos/git/git-branching-guidance](https://learn.microsoft.com/en-us/azure/devops/repos/git/git-branching-guidance
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Git Essentials for Beginners: [https://www.packtpub.com/product/mastering-git/9781783553754](https://www.packtpub.com/product/mastering-git/9781783553754)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Liberty, J. (2021). *Git for Programmers: Master Git for effective implementation
    of version control for your programming projects*. Packt Publishing Limited.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Narebski, J. (2016). *Mastering Git*. Packt Publishing Ltd.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Joel Test: 12 Steps to Better* *Code*: [https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/](https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be sure to check out the companion website for the book at [https://www.pycharm-book.com](https://www.pycharm-book.com).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
