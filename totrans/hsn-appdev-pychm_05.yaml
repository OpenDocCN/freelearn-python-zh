- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Version Control with Git in PyCharm
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PyCharm中使用Git进行版本控制
- en: Version control is an essential best practice in the field of software development.
    The mechanics of the process, though, are daunting for new developers. It is easy
    to make mistakes. As a bootcamp instructor at Southern Methodist University (Go
    Ponies!), I have seen quite a few blunders, such as accidentally adding your entire
    home folder to a Git repository, creating repositories inside of other repositories,
    and wiping out the product of hard work by pushing and pulling out of order. I
    prefer my students to master Git on the command line. In fact, it is the very
    first skill I teach, and in my opinion, it is one of the most difficult.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制是软件开发领域的一项基本最佳实践。然而，对于新开发者来说，这个过程的技术细节可能会让人感到畏惧。犯错很容易。作为南方卫理公会大学（Go Ponies！）的训练营讲师，我亲眼目睹了许多错误，比如不小心将整个家目录添加到Git仓库中，在其他仓库内部创建仓库，以及通过错误的推送和拉取顺序抹去辛勤工作的成果。我更喜欢让学生在命令行上掌握Git。实际上，这是我最先教授的技能之一，在我看来，这也是最难的技能之一。
- en: 'After a developer gains confidence with the whole Git process, it is something
    of an annoyance to have to constantly jump out of the IDE to perform four or five
    commands, then jump back into the IDE to continue work. It is true you could use
    the built-in terminal window available in PyCharm, but the IDE offers a better
    option: a built-in version control GUI.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发者对整个Git过程有信心之后，不得不不断跳出IDE执行四到五个命令，然后再跳回IDE继续工作，这确实有些烦恼。虽然你可以使用PyCharm中可用的内置终端窗口，但IDE提供了一个更好的选择：内置的版本控制GUI。
- en: 'PyCharm supports a number of the major **version control systems** (**VCSs**),
    including the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm支持许多主要的 **版本控制系统**（**VCSs**），包括以下内容：
- en: Git
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: Mercurial
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mercurial
- en: Subversion
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Subversion
- en: Perforce
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Perforce
- en: Microsoft **Team** **Foundation Server**
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软 **团队** **基金会服务器**
- en: While there are many other VCSs available, these are easily the most popular,
    and among those in this list, Git has become the de facto standard in the industry.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有许多其他版本控制系统可用，但它们无疑是最受欢迎的，并且在这份列表中，Git已经成为行业中的事实标准。
- en: This chapter will first cover some basic information about version control and
    VCSs just in case you are new to the concept. Following this introduction, we
    will focus entirely on the tooling for Git, since as I just hinted, it has a capital
    lead in terms of market share.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将首先介绍一些关于版本控制和版本控制系统（VCSs）的基本信息，以防你对这个概念不熟悉。在介绍之后，我们将完全专注于Git的工具，因为正如我刚刚暗示的，它在市场份额方面具有领先地位。
- en: 'By the end of the chapter, you will come to understand the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将理解以下内容：
- en: The merits of using a VCS
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用版本控制系统的优点
- en: Working with Git to perform adding, committing, pushing, merging, and branching
    operations
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Git执行添加、提交、推送、合并和分支操作
- en: Creating and maintaining a `.``gitignore` file
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和维护`.gitignore`文件
- en: Working with the Git tooling in the IDE, which may be referenced from several
    vectors
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在IDE中使用Git工具，这可能从多个角度进行参考
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To be successful with this chapter, you will need the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功学习本章内容，你需要以下条件：
- en: A working installation of Python 3.10 or later.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.10或更高版本的正常安装。
- en: A working installation of PyCharm.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyCharm的正常安装。
- en: Git client software for your computer. Mac and Linux systems usually have this
    installed as standard. Windows users can visit [https://gitforwindows.org](https://gitforwindows.org)
    to download the free software.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的电脑安装Git客户端软件。Mac和Linux系统通常作为标准安装。Windows用户可以访问[https://gitforwindows.org](https://gitforwindows.org)下载免费软件。
- en: A free GitHub account. Register at [https://github.com](https://github.com).
    Note that while there are paid features of GitHub, we won’t be using them
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个免费的GitHub账户。请注册于[https://github.com](https://github.com)。请注意，尽管GitHub有付费功能，但我们不会使用它们
- en: Version control and Git essentials
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制和Git基础知识
- en: 'Software industry icon **Joel Spolsky**, who created Stack Overflow, wrote
    a famous blog back in the year 2000\. One of his many influential posts included
    one titled *The Joel Test: 12 Steps to Better Code*. The post was designed to
    give software developers an easy assessment to rate any software development organization’s
    maturity level. He asked 12 questions, with one point per question. A good software
    development group should have a score of 11 or higher. The very first item on
    the list is the concern of this chapter: Do you use source control? If you are
    curious about the rest, there is a link to the blog post, as well as a reference
    to Mr. Spolsky’s book *Joel on Software*, in the *Further reading* section of
    this chapter.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 软件行业标志性人物**乔尔·斯波尔斯基**，他创建了Stack Overflow，在2000年写了一篇著名的博客。他的许多有影响力的帖子中，有一篇标题为*《乔尔测试：12步提升代码质量》*。这篇帖子旨在为软件开发者提供一个简单的评估方法，以评估任何软件开发组织的成熟度水平。他提出了12个问题，每个问题1分。一个优秀的软件开发团队应该得到11分或更高。列表中的第一项就是本章关注的内容：你们使用源代码控制吗？如果你对其他内容感兴趣，可以在本章的*进一步阅读*部分找到博客文章的链接，以及斯波尔斯基先生的书籍*《乔尔论软件》*的引用。
- en: 'Joel called it **source control**. I call it **version control**. The terms
    are interchangeable. I will call it *version control* in order to be consistent
    with the UI in PyCharm, which refers to the group of features we’re talking about
    as a **version control system**, or **VCS**. Strictly speaking, version control
    is a process used to track changes to the files that make up your program over
    time. The objectives of a VCS include the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 乔尔称之为**源代码控制**。我称之为**版本控制**。这两个术语可以互换使用。我将使用*版本控制*来保持与PyCharm的UI一致，PyCharm将我们讨论的这一组功能称为**版本控制系统**或**VCS**。严格来说，版本控制是一个随着时间的推移跟踪组成程序的文件变更的过程。VCS的目标包括以下内容：
- en: The ability to revert to any previously saved version of any file in your project.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够恢复项目中的任何文件之前保存的版本。
- en: The ability to automatically merge the work of multiple developers on a team
    so long as their work does not conflict. A conflict occurs when two developers
    change the same file in the same place.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够自动合并团队中多个开发者的工作，只要他们的工作不冲突。冲突发生在两个开发者更改了同一文件中的同一位置。
- en: Provide an easy means to review conflicts and resolve them through collaboration.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一种简单的方法来审查冲突并通过协作解决它们。
- en: The ability to track which developers made each change in the code over time.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够跟踪随着时间的推移，哪些开发者对代码进行了每次变更。
- en: Provide a branching system to allow bug fixes, enhancements, and experimentation
    without sacrificing the stability of your production code.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个分支系统，允许修复错误、增强功能和实验，而不会牺牲生产代码的稳定性。
- en: A VCS, then, is a software system designed to enable that process. VCSs come
    in two varieties, depending on how revisions are stored. **Centralized VCSs**
    work a little like your local public library. Your project is checked into a **repository**.
    Developers can then check out the code in order to work on creating a new revision.
    Doing so will retrieve the latest version of the project. Some systems, such as
    **Perforce**, traditionally require you to explicitly check out the files you
    want to work with just like you’d check out a book from a library. While you have
    those files checked out, nobody else is allowed to modify them until you check
    them back in with your changes. Other systems, such as **Subversion**, don’t have
    this requirement. Anybody can work on their local working copy. When work is done,
    the developer **commits** their work to the central repository. During the commit
    process, the VCS checks for **conflicts**. If no conflicts exist, the incoming
    work is **merged** and a new version is stored on the VCS server, which is then
    available for other developers through an update process. If conflicts are detected,
    the commit is rejected, and the developer must work with other developers on the
    team to resolve the conflict before the work can be merged and finally committed.
    In all centralized systems, each developer on a team has only the latest version
    of the code on their local computer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，版本控制系统（VCS）是一种旨在启用该过程的软件系统。VCSs根据修订的存储方式分为两种类型。**集中式VCS**的工作方式有点像你当地的公共图书馆。你的项目被检查到一个**仓库**中。开发者可以检出代码以便进行创建新修订的工作。这样做将检索项目的最新版本。一些系统，如**Perforce**，传统上要求你明确检出你想要工作的文件，就像从图书馆借阅一本书一样。在你检出这些文件期间，不允许其他人修改它们，直到你将它们检入并带上你的更改。其他系统，如**Subversion**，没有这个要求。任何人都可以在他们本地的副本上工作。当工作完成时，开发者会将他们的工作**提交**到中央仓库。在提交过程中，VCS会检查**冲突**。如果没有冲突，传入的工作将被**合并**，并在VCS服务器上存储一个新的版本，然后通过更新过程供其他开发者使用。如果检测到冲突，提交将被拒绝，开发者必须与其他团队成员一起工作以解决冲突，然后才能合并并最终提交工作。在所有集中式系统中，团队中的每个开发者在其本地计算机上只有代码的最新版本。
- en: In contrast, **distributed version control systems** (**DVCSs**) such as **Git**
    and **Mercurial** keep every revision ever performed on the project on each developer’s
    computer. The advantage here is there is no single point of failure that might
    result in a total loss of the project code. In a centralized system, if the server
    is compromised, the project’s revision history might be lost. In a distributed
    system, there isn’t a central system to store the project’s revision history.
    Every developer has the project’s entire history on their computer, so the loss
    of any one computer isn’t a big deal beyond the usual pain of replacing the equipment.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，**分布式版本控制系统**（**DVCS**）如**Git**和**Mercurial**将项目上所执行的每个修订都保存在每个开发者的计算机上。这里的优势是没有任何单点故障可能导致项目代码的完全丢失。在集中式系统中，如果服务器被破坏，项目的修订历史可能会丢失。在分布式系统中，没有中央系统来存储项目的修订历史。每个开发者都有项目完整的历史记录在他们的计算机上，所以任何一台计算机的丢失并不会造成太大的问题，除了更换设备的常规痛苦之外。
- en: With that said, distributed systems do use a central **hub** or **remote** to
    allow easy synchronization between the working copies on each developer’s computer.
    The hub server allows additional functionality, such as managing who is allowed
    to view or change the code, as well as collaborative features such as code reviews,
    bug tracking, documentation, and discussion. A DVCS also presents an easy way
    to control the publication of new releases of web-based applications. Many continuous
    deployment systems, such as **Travis CI**, **CircleCI**, and **Beanstalk**, are
    simply leveraging features of the DVCS to control the release management process.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，分布式系统确实使用一个中央**枢纽**或**远程**，以便在每位开发者的计算机上的工作副本之间实现轻松同步。枢纽服务器允许额外的功能，例如管理谁可以查看或更改代码，以及协作功能，如代码审查、错误跟踪、文档和讨论。分布式版本控制系统（DVCS）也提供了一个轻松控制基于Web的应用程序新版本发布的方法。许多持续部署系统，如**Travis
    CI**、**CircleCI**和**Beanstalk**，只是利用DVCS的功能来控制发布管理过程。
- en: The most famous DVCS is Git, created by **Linus Torvalds**, who also created
    the **Linux** operating system. The most famous DVCS hub is, you guessed it, GitHub,
    which is owned by Microsoft. Many people use the terms *Git* and *GitHub* interchangeably.
    This is a mistake. GitHub is a place on the internet. The software used to access
    *GitHub* is called *Git*. Many projects that use Git as their DVCS host their
    repository hub in services other than GitHub, such as **GitLab**, **Microsoft
    Azure DevOps**, **Atlassian Bitbucket**, and **Beanstalk** ([https://beanstalkapp.com](https://beanstalkapp.com),
    not to be confused with the Beanstalk service on **Amazon Web Services**, which
    has nothing to do with version control).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: As developers make changes to their working copy, they can commit changes to
    their local copy. They can later synchronize their code by pulling changes from
    the central hub, reconciling any conflicts, and then pushing their merged work.
    Again, the big difference is in a DVCS; everything happens on the developer’s
    computer versus on a server with a centralized system.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Git on your computer
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whether you installed Git for Windows on your Windows computer, or you are
    working with a pre-installed Git client on your Mac or Linux computer, you need
    to perform some additional setup beyond simply installing the software. The setup
    tasks ahead include the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Set your default username and email address.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **Secure Shell** (**SSH**) key so you can securely communicate with
    remote hubs such as GitHub.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the SSH key to your account on GitHub.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s go through the process for each.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: To get started, you need to launch a terminal. If you are using Mac or Linux,
    you should be able to find an app on your system, simply called *Terminal*. The
    commands I’ll present are going to be using the **Bash shell**. Mac’s terminal
    program defaults to a shell called the **Z shell** (**zsh**), which is directly
    compatible with Bash. Most Linux installations default to Bash, so you are all
    set. If you are in Windows, you need to have installed the Git software from [https://gitforwindows.org](https://gitforwindows.org).
    One of the programs installed is called *gitbash*. Launching **gitbash** will
    allow us all to use the same commands regardless of which operating system we’re
    using.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Setting your default username and email address
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having launched your terminal, you need to execute the following command to
    set your default username:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Naturally, you’ll fill in your actual name. Next, fill in your email address.
    If you work for a corporation, I strongly recommend creating a separate GitHub
    account to keep your work separate from your employers to avoid any nasty intellectual
    property disputes. Keeping that in mind, use an appropriate email address for
    your work with the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are more extensive configuration options beyond using these two globals,
    but this is the most common way to set up Git, and you won’t be able to push code
    to GitHub without these settings. If you’d like more in-depth information on working
    with Git, I recommend checking out the additional reading in the *Further reading*
    section of this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Generating an SSH key
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One objective of a remote hub is to keep your code secure from malicious tampering.
    One of the ways this happens is to ensure all communications between your computer
    and the remote are encrypted. You can work with HTTPS encryption or SSH. While
    both are valid encryption tools, SSH is considered far superior and is the mark
    of a real pro. In order to work with SSH, you need to generate a unique pair of
    encryption keys: one public key and a matching private key. I won’t go into how
    SSH works here, but if you’re curious, I’ll leave some reading suggestions in
    the *Further reading* section of this chapter.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Generating a key is pretty simple. Having opened a Bash session, simply type
    the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The key generation program will ask you some questions, such as where to store
    your key files and what to call them. By default, they are called `id_rsa` (the
    private key) and `id_rsa.pub` (the public key), both of which are stored in your
    home folder in a sub-folder called `.ssh`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: The last question asked is the passphrase for the key. You can enter a password
    for the key for extra security, or just press *Enter* for an empty passphrase.
    This is generally not advisable, since security is tighter when you create a passphrase.
    The drawback to having a passphrase is you are constantly challenged to enter
    the passphrase. An empty passphrase bypasses these interruptions but puts security
    at risk by making your key easier to compromise. I recommend entering a passphrase
    because one of the advantages of using PyCharm’s tooling is that it stores your
    passphrase in its own encrypted database. PyCharm will answer all your challenges
    for you, eliminating the inconvenience of working with a passphrase-protected
    encryption key.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'After the passkey is entered, you’ll get some additional feedback. You can
    check your key by typing the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This lists (`ls`) the files in your home folder (`~/`) under the `.ssh` sub-folder
    including any hidden files (`-a` for “all files”). You should see, at a minimum,
    the `id_rsa` and `id_rsa.pub` files. You are going to need the contents of the
    `id_rsa.pub` file in just a moment as you are going to paste its contents onto
    a screen on GitHub.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: We’ve come to the part in the book where I offer a fatherly lecture on security.
    Never ever, ever, ever (times infinity to the googleth power plus one) paste your
    private key into anything. Never ever (ad nauseam) allow anybody to copy your
    private key. Don’t put it on a thumb drive. Don’t copy it to a network drive or
    cloud file share for safekeeping. For the love of everything holy, never check
    it into a repository! That goes for any passwords for any system. Your repos might
    ultimately become public, if not to the whole world, then at least to the rest
    of your team.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: The public key is for sharing. The private key is to be kept secret and hidden.
    If your private key is compromised, only your passphrase protects your work. If
    you left the passphrase blank, then you have no further protection!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the contents of your public key, type the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The contents of your public key will appear in your terminal window. Select
    the entire key, right-click, and click **Copy**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Adding your SSH key to your GitHub account
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’m going to cover this pretty quickly since I suspect many of you have done
    this before. If you need a better tutorial on adding an SSH key to your GitHub
    account, see the *Further reading* section at the end of this chapter for an explicit
    list of steps specific to Git.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Log in to GitHub and click your face. By that, I mean the avatar on GitHub in
    the upper-right corner, assuming they haven’t re-designed their site since going
    to press. Find the option for working with your profile and find **Settings**.
    Inside your profile settings is an option to manage your SSH keys. Click that
    link, then find the option to add an SSH key. Paste in the public key you copied
    a moment ago, give it a name that is easy to remember, and click the **Add** button.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You are fully set up for secure communications between your
    computer and GitHub remotes. It is possible to reuse your SSH key between different
    computers you own. Just copy the `.ssh` folder between computers. Just be careful
    not to compromise the key by keeping it on a portable drive you might lose, or
    a cloud file share that might be compromised.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a repository manually
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B19644_03.xhtml#_idTextAnchor052), *Customizing Interpreters
    and Virtual Environments*, we created a virtual environment manually in order
    to become familiar with the process. We’ll do the same thing here. Let’s use the
    command line to create a repository and perform all the basic functions available
    in Git. Afterward, we’ll see where PyCharm’s tooling allows us to perform the
    same operations right from the IDE in a convenient GUI.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Don’t use spaces in any file or folder name
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: I’m going to bring this up often since I know a lot of readers skip around in
    books like this one. If you are new to software development, you may not know
    that using filenames with spaces can cause problems. Avoid using file and folder
    names with spaces, including any folders created by your operating system. Instead,
    use separators in place of spaces, such as dashes or underscores, or use camelCase
    names, which omit spaces and present word boundaries with a capital letter.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我会经常提到这一点，因为我知道很多读者会跳过这类书籍。如果您是软件开发的新手，您可能不知道使用带空格的文件名可能会引起问题。请避免使用带空格的文件和文件夹名称，包括由您的操作系统创建的任何文件夹。相反，使用分隔符代替空格，例如破折号或下划线，或者使用驼峰式命名，这种命名方式省略空格，并用大写字母表示单词边界。
- en: 'With your Bash terminal session open, the first thing we’re going to do is
    create a folder for our project. We’ll do this in your home folder with this command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 Bash 终端会话打开后，我们将要做的第一件事是为我们的项目创建一个文件夹。我们将使用以下命令在您的家目录中完成此操作：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, let’s change the directory to the newly created folder:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将目录更改为新创建的文件夹：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is where our code is going to live! Before we go any further though, we
    need to talk about a sensitive subject.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的代码将要存放的地方！在继续之前，我们需要讨论一个敏感的话题。
- en: Master versus main branches in GitHub
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub 中的主分支与 main 分支
- en: For the first 12 years after GitHub was established, whenever one created a
    new repository in GitHub, the tool established a default starting branch called
    *master*. In 2020, an organization called *The Software Freedom Conservancy* advised
    GitHub to change the name of the default branch from *master* to *main* owing
    to the association of the term *master* with slavery. While Git doesn’t force
    you to use any particular name, the default on GitHub has been changed to *main*.
    Since GitHub doesn’t control Git, this name change is only the default on repositories
    created by GitHub. We’ve been creating our repositories using the Git command
    line, which is leveraged by PyCharm’s Git tools. Whether you use the Git command
    or PyCharm’s integration, there’s a solid chance you’re going to get a repository
    initialized with a branch called *master*. When you create a remote on GitHub,
    that repo will be created with a default branch called *main*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 成立后的前 12 年里，每当在 GitHub 中创建一个新的仓库时，该工具都会创建一个名为 *master* 的默认起始分支。在 2020
    年，一个名为 *The Software Freedom Conservancy* 的组织建议 GitHub 将默认分支的名称从 *master* 更改为
    *main*，因为 *master* 这个词与奴隶制有关。虽然 Git 不会强迫您使用任何特定的名称，但 GitHub 上的默认名称已被更改为 *main*。由于
    GitHub 不控制 Git，这个名称更改仅适用于 GitHub 创建的仓库。我们一直在使用 Git 命令行创建仓库，这是 PyCharm 的 Git 工具所利用的。无论您使用
    Git 命令还是 PyCharm 的集成，有很大可能性您将得到一个以 *master* 分支初始化的仓库。当您在 GitHub 上创建远程仓库时，该仓库将使用名为
    *main* 的默认分支创建。
- en: You should take care to match the names of the default branches so that when
    you perform your first push, your branches synchronize properly. You can either
    change the name in GitHub or set the Git command on your computer to use *main*
    for the default.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该注意匹配默认分支的名称，以便在您执行第一次推送时，您的分支能够正确同步。您可以在 GitHub 上更改名称，或者在您的计算机上设置 Git 命令以使用
    *main* 作为默认名称。
- en: If you want to change it on GitHub, you can go into your profile settings and
    click **Repositories**. You’ll find the setting at the top, as shown in *Figure
    5**.1*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在 GitHub 上更改它，您可以进入您的个人资料设置并点击**仓库**。您将在顶部找到该设置，如图 *图 5**.1* 所示。
- en: '![Figure 5.1: You can set the default name of repositories in GitHub to match
    the default on your computer](img/B19644_05_01.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1：您可以将 GitHub 仓库的默认名称设置为与您计算机上的默认名称匹配](img/B19644_05_01.jpg)'
- en: 'Figure 5.1: You can set the default name of repositories in GitHub to match
    the default on your computer'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：您可以将 GitHub 仓库的默认名称设置为与您计算机上的默认名称匹配
- en: 'You can also set a global setting on your computer with this command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用以下命令在您的计算机上设置全局设置：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you intend to do a lot of work with GitHub as your remote, it is a good idea
    to synchronize the default branch name. If you don’t, the first time you try to
    push the repository you created on your computer to the remote created on GitHub,
    you’ll encounter an error. The default locally is *master*, while the default
    on the remote is *main*. The remote won’t have a branch called *master*, so you’ll
    get a message stating there is no upstream branch called *master*. You’ll have
    to do some work to get this settled. I’ll leave a link to an article on how to
    resolve this situation should you encounter it. I encourage you to just avoid
    it entirely by using the preceding Git command to set your local global setting
    to *main* so it matches GitHub.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算在GitHub上做很多工作，同步默认分支名称是一个好主意。如果你不这样做，当你第一次尝试将你在计算机上创建的仓库推送到GitHub上创建的远程仓库时，你会遇到错误。本地的默认分支是*master*，而远程的默认分支是*main*。远程不会有名为*master*的分支，所以你会收到一条消息，说明没有名为*master*的上游分支。你可能需要做一些工作来解决这个问题。如果你遇到这种情况，我会留一个链接到一篇文章，告诉你如何解决这个问题。我鼓励你通过使用前面的Git命令将你的本地全局设置设置为*main*来避免这个问题，这样它就会与GitHub匹配。
- en: Manually initializing the repository
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动初始化仓库
- en: 'Let’s create our repository. It is entirely possible, and even normal, to create
    a repository after you have created a code project. However, we will start with
    the repository since this will be a very simple demonstration. To create a new
    Git repository, or repo for short, type the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的仓库。在你创建了一个代码项目之后创建一个仓库是完全可能的，甚至可以说是正常的。然而，我们将从仓库开始，因为这将会是一个非常简单的演示。要创建一个新的Git仓库，或者简称为repo，请输入以下命令：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That was easy! It might look like nothing much happened. You’ll get a message
    stating the repository was created. Let’s look at the changes to the folder:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单！看起来好像没有发生什么。你会收到一个消息，说明仓库已创建。让我们看看文件夹的变化：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `ls` command lists all the files. The `-a` switch shows hidden files and
    folders. When you initialized the Git repository, the Git software created a folder
    called `.git`. Since the folder name starts with a period (`.`), the folder is
    hidden in Linux-like systems. If you perform these steps in Windows with PowerShell,
    you’ll be able to see the folder, but it’s hidden in the other operating systems.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls`命令列出所有文件。`-a`选项显示隐藏的文件和文件夹。当你初始化Git仓库时，Git软件创建了一个名为`.git`的文件夹。由于文件夹名以点（`.`）开头，所以在类似Linux的系统中的文件夹是隐藏的。如果你在Windows上使用PowerShell执行这些步骤，你将能够看到文件夹，但在其他操作系统中它是隐藏的。'
- en: The `.git` folder is where all your revisions are stored, along with all your
    project’s settings. In general, you should never need to alter the contents of
    this folder.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`.git`文件夹是存储所有你的修订和项目设置的地方。一般来说，你不需要修改这个文件夹的内容。'
- en: 'We have a repository on our local computer. Let’s add a new file. Type the
    following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的本地计算机上有一个仓库。让我们添加一个新文件。输入以下命令：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This created a new file called `test.txt`. Within that file is the line `hello
    world`. What a great way to start, right? You can check the contents of the file
    by typing the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个名为`test.txt`的新文件。在该文件中有一行`hello world`。这是一个多么好的开始，对吧？你可以通过输入以下命令来检查文件的内容：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Who needs an IDE, right? Wait, no, forget I said that. The order of the next
    few steps is important. The process is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 谁需要集成开发环境（IDE），对吧？等等，不，别当真，我刚才那么说了。接下来的几个步骤的顺序很重要。过程如下：
- en: Add the file(s) to the repository. The files you are adding are the files you
    have either created or modified since your last commit. We don’t have one of those
    yet. Adding your files to the repo is also called staging your files. We are making
    the repository aware of new and changed files. You shouldn’t always add every
    file to your project. There are some you should keep out of your repository. We’ll
    cover that a little later.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件添加到仓库中。你添加的文件是你自上次提交以来创建或修改的文件。我们还没有这样的文件。将你的文件添加到仓库也称为暂存文件。我们正在让仓库知道新文件和已更改的文件。你不应该总是将每个文件添加到你的项目中。有些文件你应该从仓库中排除。我们稍后会讨论这一点。
- en: Commit your files. This creates a new version of your code on your local computer.
    The commit action requires you to include a comment that explains the nature of
    the changes you’ve made. This is vital! You should endeavor to write a concise
    summary of your changes, and you should write these comments as though your most
    important customer will one day read all these comments. This is not a place to
    vent your frustrations! Trust me on this one. I’ve seen projects fall under unexpected
    audits where mean or inappropriate comments surfaced and working relationships
    were ruined. Assume everything you write will be read and judged by the whole
    world.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull changes from the remote hub. You always want to pull before you push. This
    allows you to find any conflicts between your work, and any work that might have
    been pushed by another developer on the project. This is important! If you don’t
    pull before your push, it is possible to overwrite another developer’s revision!
    This is certainly not catastrophic since all revisions are held in the repo. It
    will, however, make tomorrow’s stand-up meeting very awkward for you as the other
    developer will likely not be happy with you for making extra work for the group!
    It’s simple. Just remember to pull before you push. Do this even if you are the
    only person working on the project and just make it a habit!
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assuming there are no conflicts, push your work to the remote hub.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your revisions are now available to the rest of the team and stored securely
    on the remote server. Let’s go through the commands for this process.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add your new and changed files to Git. Remember, this is also called
    **staging** your files:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you have a bunch of files in your project, it is possible to add them all
    at once with the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With your latest changes staged, you can now commit them to the local repo.
    This creates a new version of your project on your computer. You need to include
    a comment that summarizes your changes:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `-m` switch is our comment, which is enclosed in double quotes. Just remember
    it as a *commit message* and the `-m` switch is easy to remember. Of course, by
    the end of the chapter, you won’t need to remember all this command-line stuff
    since you’ll have a nifty GUI.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Working with remotes
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is possible to work with a project entirely on your local computer. Naturally,
    you’d lose all the collaborative benefits provided by a remote hub, including
    the benefits of a remote backup of your change history. Earlier, I presented a
    four-step process:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Add or stage your changed files.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit your changes to create a new revision.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull changes from the remote.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push your merged work to the remote.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’re halfway through the list, having completed the first two steps on our
    local copy of the repository. We must interrupt the process at this point because
    we don’t presently have a remote. We’re going to create one on GitHub, but naturally,
    you can use any compatible service.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Adding a remote on GitHub
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Log on to GitHub and find the **Add Repository** button. It is usually a very
    obvious green button. With my luck, they’ll redo the site at press time. Nevertheless,
    they usually make the **Create repository** button very obvious on the UI.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a repository to match the one we created locally. I’ll make mine
    public, which means everybody can see it. If you’re bashful, you can make it private.
    It won’t matter for this exercise.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Once you have created the repository, GitHub will display instructions for adding
    the GitHub version of the repo as a remote. Just copy and paste the code GitHub
    generated into your terminal, making sure that your terminal is currently in the
    repository folder as the present working directory.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify the remote by typing the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The command generated by GitHub sets the name of the GitHub copy of the repo
    as *origin*. You should have one remote called *origin*, while the local version
    of the repository is referred to by the current branch, which is usually *main*,
    as described earlier.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The first push
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have a remote, you can push your local repo to the remote. Type
    the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This pushes your copy of the main branch to the remote and sets upstream tracking
    for the main branch. This is just a fancy way of saying both the remote and the
    local repository are aware of the main branch, and any push here will result in
    the remote main branch being updated. If the remote doesn’t have a branch called
    `main`, one will be created and everything will synchronize nicely.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Making, committing, and pushing a change
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a fully working repository, complete with a remote on GitHub,
    let’s make one full round of changes to our code. We’ll cover the four-step process
    this time without interruption. This is the process you’ll follow many times per
    day for the duration of your project.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The next step is very important. Make this a habit!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This pulls any changes sitting on the remote and allows you to fix any conflicts
    before they go out into the world! Naturally, in this situation, there won’t be
    any conflicts since only we are working on the project.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s change the contents of our text file. Type the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can check the result with the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should see the changed file. Now let’s do a full cycle of add, commit,
    pull, and push. Type each of the following lines, one at a time, and press *Enter*
    at the end of each one:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Switch to your browser where you created your repository, and refresh the page.
    You should see your code. You can click the `test.txt` file in the browser to
    verify the new contents were pushed. You should also see there are two revisions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Your repo is set up and working properly! Let’s switch our focus from the command
    line to working in the IDE.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Working with Git in the IDE
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already gone through some of the Git workflows in PyCharm. In [*Chapter
    2*](B19644_02.xhtml#_idTextAnchor028), *Installation and Configuration*, we used
    PyCharm to clone the sample code repository for this book. Since we’ve covered
    cloning, we won’t do it again. Instead, let’s consider all we did manually a moment
    ago:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: We used `git init` to initialize a new local repository.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We made a change to our code.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We used `git add` to add the changes as staged files in preparation for a commit.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We committed our changes to the local repository.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We pulled from the remote to make sure we have the latest code on this branch
    and that no conflicts exist between what we have in our working copy and what
    exists on the remote. The remote could have recently changed owing to some other
    developer pushing their changes.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we pushed our changes to the remote.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This list represents the most basic workflow for capturing and managing revisions
    on a project. We can do all of this and more in PyCharm’s GUI. It is also fairly
    common to do some work in PyCharm and some in the command line. Using one or the
    other doesn’t preclude anything. For example, I often branch and merge in the
    command line because it’s quick and easy for me. If there is a conflict, I find
    resolving it in PyCharm to be superior in every way versus a manual approach.
    The GUI for this task is outstanding. We’ll get to all this in good time. For
    now, open the folder you’ve been using in PyCharm, and let’s explore what the
    IDE can do for us regarding these first steps we’ve taken manually.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Version control in PyCharm
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PyCharm has several places in the UI that allow you to access your VCS, which
    for us is Git. They aren’t redundant, but instead, each area provides a visual
    tool for a particular task. The first is the main menu, as seen in *Figure 5**.2*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: The Git menu allows you to access all the commands you might
    normally use at the command line](img/B19644_05_02.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: The Git menu allows you to access all the commands you might normally
    use at the command line'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'The second provides a fast and easy way to commit files. This can be found
    in the sidebar menu, as seen in *Figure 5**.3*:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: The Git commit tools can be found in the sidebar](img/B19644_05_03.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: The Git commit tools can be found in the sidebar'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The third allows visualization of the branch and commit history. This can be
    found in the tool window located at the bottom of the screen. This section of
    the screen collapses, but the tool window selector is always available at the
    bottom of the sidebar, as seen in *Figure 5**.4*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4: Clicking the Git tool window will open a window that shows you
    the commit history, along with all the branches](img/B19644_05_04.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Clicking the Git tool window will open a window that shows you
    the commit history, along with all the branches'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: The fourth is on the top toolbar next to the main menu. This area shows you
    the branch you are currently working on and allows easy branch management. You
    can see this in *Figure 5**.5*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5: The current branch is displayed near the main menu. Clicking
    here allows you access to a few commands](img/B19644_05_05.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: The current branch is displayed near the main menu. Clicking here
    allows you access to a few commands'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The fifth is the VCS operations popup, as shown in *Figure 5**.6*. This has
    been around for quite a while and I would consider it legacy even though it’s
    still there. You can get to the popup using *Ctrl* + *`*. Please note that isn’t
    a quotation mark. The `` ` `` key, called the gravure mark, is located to the
    left of the *1* (one) key on the US keyboard layout.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6: The VCS operations pop-up window is activated with Ctrl/Cmd +
    `.](img/B19644_05_06.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: The VCS operations pop-up window is activated with Ctrl/Cmd + `.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can right-click the editor window or a tab in the editor window
    to access the same Git menu found in the main menu, as shown in *Figure 5**.7*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7: You can right-click in the editor window or on a tab to see the
    Git menu](img/B19644_05_07.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: You can right-click in the editor window or on a tab to see the
    Git menu'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, tooling for revision control is neatly woven into the IDE in
    an organized and intelligent fashion. Since we opened a folder that already had
    a Git repository in place, PyCharm simply recognizes that fact and presents the
    interface. When you open a folder or create a project without a GitHub repo, most
    of the tooling will still be visible, but it won’t be Git specific. Since PyCharm
    supports many VCSs, a project that hasn’t been initialized using Git or any other
    VCS will present generic tooling until such initialization is complete.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project from scratch using VCS tooling in PyCharm
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s make a new project. The code for this project is in the repo for the book,
    but you don’t really want to just open that copy because it will already be associated
    with a repository, and you won’t see everything I’m about to show you. For this
    exercise, you should create a new project from scratch as I am about to do.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Click the hamburger icon in the top-left corner of the application to activate
    the main menu, then click `project_git_demo`. I’ll leave everything else as default.
    You can see my project creation dialog in *Figure 5**.8*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8: My demo project settings](img/B19644_05_08.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.8: My demo project settings'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: We now have a project with which we can work.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the local Git repository
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After my project has been created, I need to initialize a Git repository. Manually,
    we did this with the `git init` command. In PyCharm, we can use the main menu’s
    **VCS** option. Right now, it says **VCS** because we haven’t initialized a repository
    with any VCS yet, so the terminology in the UI is generic. As you can see in *Figure
    5**.9*, we have options for revision control in Mercurial, Git, GitHub, Perforce,
    and Subversion. There is a new option for sharing a project on JetBrains’ new
    collaboration product called **Space**, which contains a Git hosting service.
    Naturally, as the Space product grows, you can expect to see more and more integration
    appear in all the IDEs. I’m going to click **Create Git Repository…**, as shown
    in *Figure 5**.9*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9: Creating a Git repository from the PyCharm VCS menu](img/B19644_05_09.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.9: Creating a Git repository from the PyCharm VCS menu'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 5**.10*, you are next prompted to select the folder
    where you’d like to create the repository. It defaults to the current folder,
    which is correct.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10: Select the folder where you’d like to create the Git repository](img/B19644_05_10.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.10: Select the folder where you’d like to create the Git repository'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Clicking the **OK** button creates the repository in the selected folder. You
    can verify that it worked by checking whether the default branch (master) appears
    in the top toolbar with a dropdown that contains a few Git operations. Now that
    we have initialized a Git repository, the menus no longer use the term **VCS**
    but instead list options specifically for Git.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Adding a remote on GitHub
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There isn’t tooling in PyCharm for creating a remote. You need to log in to
    GitHub and create a repository just as you did earlier. *Figure 5**.11* shows
    me setting up the remote repository in my personal account. Note this is distinct
    from the book’s repository, which is meant to house all the code in the book rather
    than serve as a demonstration of creating a repository.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11: The settings for my remote](img/B19644_05_11.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.11: The settings for my remote'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Note that only the bare minimum is set. No `.gitignore` file, no README file,
    and so on. I’m going to add all those in PyCharm. When I click the **Create repository**
    button, GitHub generates the URL I need for adding the remote. I’ve pointed this
    out in *Figure 5**.12*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12: You need the URL for the remote in order to add it to your local
    repository](img/B19644_05_12.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.12: You need the URL for the remote in order to add it to your local
    repository'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Next, switch back to PyCharm and find the **git** menu within the main menu.
    Remember, a minute ago, the menu said **VCS** because we had not defined a repository,
    but now it says **git**.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Within the **git** menu, you’ll find an option called **Manage Remotes**. Click
    that and you’ll see a modal dialog, shown in *Figure 5**.13*, which allows you
    to add the remote you just created on GitHub.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13: The Git Remotes dialog allows you to add the remote you created
    on GitHub](img/B19644_05_13.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.13: The Git Remotes dialog allows you to add the remote you created
    on GitHub'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Click the **+** button to add a remote. You get yet another dialog on top of
    this one, as seen in *Figure 5**.14*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14: Add the URL you copied from the GitHub page](img/B19644_05_14.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.14: Add the URL you copied from the GitHub page'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Click `main.py` file is red.. You’ll just have to trust me. It’s red because
    it is an untracked file. We need to add our files to our repository so we can
    track them.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Adding project files
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting up the project and the remote is something you generally only do once
    for the duration of the project. If you’re joining an existing team, it may have
    been done long before you joined. This next set of actions, though, is something
    you’ll work with every day.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: When you are working with changes you’ve made to the project, you’ll find the
    **Commit** window very useful. Refer back to *Figure 5**.3* if you have forgotten
    how to locate the **Commit** window.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Adding a .gitignore file
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’re not familiar, a `.gitignore` file defines files and folders you don’t
    want to include in your repository. As a general rule, anything that can be generated
    from your code doesn’t need to be in your repository. When working with Python
    projects, a short list of things you don’t want in your repo might include the
    following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The `venv` folder since this is generated by running `pip`
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python cache folders (you’ll see them as `__pycache__` folders)
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Byte-compiled DLL files
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C extensions
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build files from distribution and packaging
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PyInstaller manifests
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application log files
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test coverage reports
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is by no means an exhaustive list. The list will really depend on what
    kind of application you are building and exactly what gets generated during a
    run of your project. There are plenty of suggestions on the contents of a `.gitignore`
    file. GitHub has such a list in a gist. You can get this file at [https://githubgitm/github/gigitnore/blgitmain/Python.gitignore](https://githubgitm/github/gigitnore/blgitmain/Python.gitignore).
    It is also the `.gitignore` file in the book’s Git repository. You can use this
    `.gitignore` file if you’d like, but to keep this short and easy, I’m just going
    to include a few entries in a `.gitignore` file we will create.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Switch back to the file view, as shown in *Figure 5**.15*. You do this by clicking
    the folder icon (`project_git_demo` project title (`.gitignore`. No creativity
    is allowed here. It must be called `.gitignore`, all lowercase.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15: Switch back to the file view and create a new file called .gitignore](img/B19644_05_15.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.15: Switch back to the file view and create a new file called .gitignore'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: When you create the new file, PyCharm will prompt you to add the file to Git,
    as shown in *Figure 5**.16*. If you want to add new files to become the default,
    you can click the **Don’t ask again** checkbox and all files you create will be
    added to GitHub automatically.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16: Each time you create a file in PyCharm, you are prompted to
    add it to the repository](img/B19644_05_16.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.16: Each time you create a file in PyCharm, you are prompted to add
    it to the repository'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of what you do with the checkbox, click the `.gitignore` file shows
    green in the project explorer since it was added and nothing has yet changed.
    Within the `.gitignore` file, add these lines:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will exclude the entire `venv` folder and any cache folders generated by
    Python. PyCharm saves your files as we go, so let’s add this file and the `main.py`
    file to the repository. Switch to the **Commit** window and you’ll see something
    like *Figure 5**.17*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17: The commit window after we’ve added our .gitignore file](img/B19644_5_17.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.17: The commit window after we’ve added our .gitignore file'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Wow! Where did all that come from? We just added one file! As you can see, the
    `.gitignore` file was added in response to the dialog we saw when we created the
    file. The only other code file in the project is the `main.py` file generated
    by PyCharm when we created the project. What about the rest? Why is there a second
    `.gitignore` file listed in the unversioned files list?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'These all come from the `.idea` folder created by PyCharm. There is some debate
    on whether this folder belongs in source control. JetBrains has a page in their
    documentation at [https://intellij-support.jetbrains.com/hc/en-us/articles/206544839](https://intellij-support.jetbrains.com/hc/en-us/articles/206544839)
    discussing their ideas on the subject. To sum up the article, JetBrains recommends
    storing the contents of the `.idea` folder pertaining to the project, but not
    any files that contain user-specific settings, which are the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '`workspace.xml`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usage.statistics.xml`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything in the `shelf` directory
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The article is meant to cover all `.gitignore` file. We haven’t committed anything
    yet, so add these lines to your `.``gitignore` file:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let’s check all the boxes to get all those files added, as shown in *Figure
    5**.18*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18: Everything is added and we’re ready to commit](img/B19644_05_18.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.18: Everything is added and we’re ready to commit'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Add a commit message in the box. You can click the **Commit** button to commit
    to your local repository or **Commit and Push…** to send the changes straight
    to GitHub. As a general rule, you should not use the **Commit and Push…** button
    unless you are completely certain that no one could have pushed changes since
    the last push. It is probably safe because we have never pushed; however, I’m
    going to hit the **Commit** button to demonstrate the whole process laid out earlier.
    You add your changes, commit, pull, and then push. So far, we’ve added our changes,
    and now we’re committing.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: If all goes well, a toast will appear in the lower-right corner of your screen
    stating that your files were successfully committed. If you didn’t set your global
    username and email address during the manual exercise, you will be prompted via
    a dialog to set them up.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Pulling and pushing
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the first commit is out of the way, we are set to do the last half
    of the process. We always pull before pushing to ensure we have the latest revision
    on the current branch. This allows us a chance to resolve any conflicts that might
    have arisen since our last pull. In Git, the command we used was `pull`. There
    is a `pull` option in the Git tools, but before we go there, I will point out
    another option: **Update Project…**. This is found in the dropdown in the toolbar
    denoted by the current branch, as shown in *Figure 5**.19*.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19: The Update Project… command isn’t really a Git command. It refers
    to an update strategy](img/B19644_05_19.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.19: The Update Project… command isn’t really a Git command. It refers
    to an update strategy'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: When you click **Update Project…**, you’ll be asked to set your preference for
    updating your local Git repository. There are two possibilities depicted in the
    ensuing dialog box, as shown in *Figure 5**.20*.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20: There are two update strategies from which to choose](img/B19644_05_20.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.20: There are two update strategies from which to choose'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: The `git pull` command we executed earlier embodies the first option. The pull
    operation will *fetch* any changes from the remote and automatically *merge* those
    changes into our local copy. The `rebase` operation is a different strategy. It
    changes the structure of your repository in order to show a cleaner timeline of
    changes. I won’t get into the arguments of which strategy to use, but I will include
    a link in the *Further reading* section of this chapter should you desire to dive
    deeper.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I prefer the first option since it is simpler and safer. I only
    have to click the **OK** button. I can click the **Don’t show again** checkbox
    if I do not want to be prompted before use. PyCharm will forevermore use the selection
    I make here and now.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: If you have problems with commitment, I don’t mean generally, but technically,
    when it comes to executing `git commit`, you can skip this dialog entirely. Just
    use the **Pull…** menu item on the Git menu, as shown in *Figure 5**.21*.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21: You can do a traditional Git pull from any of the Git menus](img/B19644_05_21.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.21: You can do a traditional Git pull from any of the Git menus'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing left to do but push. Perhaps the quickest way was shown previously
    in *Figure 5**.19*, where we encountered the **Update** **Project…** command.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Branching and merging
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have discussed the most basic functions of any VCS, which protects the project’s
    code by tracking revisions over time. A second set of very important functions
    entails segregating the project work into several copies. This practice is called
    **branching**. There are many benefits to branching; I can’t cover them all here.
    If you’d like more details on version control with Git, check out the Packt book
    *Git for Programmers* listed in the *Further reading* section of this chapter.
    However, I’ll offer what I consider to be the most important benefits.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Consider a typical web start-up that goes through a cycle of creating a repository
    and iterating development to its first release. The release is sitting on a production
    server somewhere in the cloud and customers have started using the app. The start-up
    company not only wants to enhance their offering with additional features, but
    they will also encounter bugs and problems that must be fixed. Let’s pretend the
    development and quality assurance teams did such an amazing job that there are
    virtually no bugs in the release. Pleased with themselves, the company wants to
    start adding new features. All work is being done in the main branch because that
    is the only one that exists. In order to add a new feature, we need to change
    something deep within the code. The moment you start the change, you need a week
    to finish it, and during that time, the development version of the product is
    very unstable.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: All of a sudden, reality sets in. It is nigh impossible to have a software release
    with no bugs, unless, of course, the software was written by unicorns or Chuck
    Norris. Let’s say it’s not just a bug. It’s a bad bug. Something like someone
    forgot a `WHERE customer_id=@customerId` on a SQL statement and your app erroneously
    displays all customer data to all customers. That’s a career-ender! I’ve seen
    it happen and it isn’t pretty. You need to fix it *immediately*! Except you can’t
    without backing out all those changes you’ve made that might render the app unstable.
    That is one option. Another option is that you could revert to the code you released,
    then implement the fix and save your career. You would then spend a lot of time
    trying to cherry-pick the commits to salvage your feature work. You could also
    elect to write all of your code in Notepad using a keyboard set to the Dvorak
    layout with totally blank keys. You could do it, but it wouldn’t be a productive
    use of your time.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: This is where branching comes into play. The start-up can do all its work on
    the main branch. They shouldn’t, but let’s keep the story constrained to what
    we have so far. Once the software is released, they could make a new branch and
    maybe call it *development-branch*. The name isn’t important. The branching operation
    creates a copy of what was released. It is in that branch that our intrepid development
    team starts to make changes that might have rendered the development version unstable.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Boom! The bad thing happens. You can switch from *development-branch* back to
    *main*. You now have the code that was released, and you can fix the problem.
    After the fix is in place, you can merge the fix into your development branch
    and continue working on your unstable app in *development-branch*. Keeping the
    work segregated allows you to work on new features independently of emergency
    bug fixes.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: I am grossly over-simplifying the typical branching strategy used by most teams
    in this illustration. I would prefer to leave coverage of that topic to works
    dedicated to version control. I’ll leave suggestions for further reading on branching
    strategies in the *Further reading* section of this chapter. Let’s continue with
    the mechanics of working with branches. They are vital to your daily practice
    of software development.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Creating a branch
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a new branch is very easy. Click the branch menu on the top menu bar
    and click **New Branch**. You’ll see the dialog shown in *Figure 5**.22*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22: The Create New Branch dialog allows you to create a new Git
    branch](img/B19644_05_22.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.22: The Create New Branch dialog allows you to create a new Git branch'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Type a name for your new branch. The branch is created locally, and you are
    automatically switched to the new branch.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Switching between branches
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is also very easy. Go back to the branch menu. The local branches are listed
    in the branch dropdown, as shown in *Figure 5**.23*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23: Local branches are listed in the branch menu](img/B19644_05_23.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.23: Local branches are listed in the branch menu'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Switching to a different branch is just a matter of clicking the desired branch
    from the list and then clicking **Checkout**. As you can see, there are other
    operations you can perform on the branch.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Merging
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you’re ready to merge a branch back into main, or any other branch for
    that matter, simply switch to that branch, then use the **Merge** command in the
    branch menu, as shown in *Figure 5**.24*.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24: The Merge command can be found in the branch menu](img/B19644_05_24.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.24: The Merge command can be found in the branch menu'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: The **Merge** dialog, shown in *Figure 5**.24*, will allow you to select the
    branch you’d like to merge into the currently selected branch.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: If you need something more exotic than the standard merge operation, there is
    a **Modify options** dropdown, which allows you to do the equivalent of several
    command-line switches normally employed during the manual merge process.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the branch diagram
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Git tool in the tool window provides a graphical view of the various branches
    in your repository. You can see it in *Figure 5**.25*. This can be useful when
    you need to review what has recently changed in the repository. It’s the kind
    of thing you might do first thing in the morning so you can review your team’s
    changes in the last 24 hours.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.25: The Git tool can be activated by clicking on the toolbar on
    the lower-left edge of the PyCharm window](img/B19644_05_25.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.25: The Git tool can be activated by clicking on the toolbar on the
    lower-left edge of the PyCharm window'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: To activate it, click the Git icon in the tool window (**1**). You can search
    the revision history and filter it using the various tools on the toolbar (**2**).
    Selecting a commit (**3**) allows you to see the details of that commit (**4**)
    along with the commit message.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Diffs and conflict resolution
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sooner or later, you’re going to perform a pull prior to pushing some changes
    only to discover a conflict exists. This can be intimidating and stressful even
    for experienced developers because you are running the risk of breaking someone
    else’s recent contribution. Nevertheless, it happens and you need a way to deal
    with the problem. This leads us to one of my favorite features in PyCharm. In
    [*Chapter 1*](B19644_01.xhtml#_idTextAnchor014), *Introduction to PyCharm – the
    Most Popular IDE for Python*, I told you about my experience with Microsoft’s
    debugger. Having experienced it early in my career, to me, nothing else will do.
    I have the same regard for PyCharm’s merge tool. Resolving a conflicted merge
    in anything else feels painful.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'There is only one file in the project. By now, you’ll recognize it as the `main.py`
    file PyCharm generates with new projects. We’re going to generate a conflict using
    the following steps:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project in PyCharm.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the contents of the `main.py` file to a single line of code to ensure
    we generate a conflict.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize a Git repository in the project folder.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add and commit all project files.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new branch called *development*.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the line of code that renders the *Hello* *World* message.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit the change to the branch.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch back to the main branch.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a different change to the one line of code.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit the change.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now try to merge the development branch into the main branch.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result of these 11 steps will be a conflict. Let’s resolve it!
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: First, create a new project called `conflict_resolution` in PyCharm, as shown
    in *Figure 5**.26*. Make sure you create the project in a location on your drive
    outside of the folder structure for the book’s repository. Remember, the book’s
    code is already in a repository. You can’t create a new repo inside another repo.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.26: My conflict_resolution project settings. They’re just defaults](img/B19644_05.26.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.26: My conflict_resolution project settings. They’re just defaults'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'PyCharm generates a project with a `main.py` file. Delete all the lines in
    `main.py` and replace them with this code:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Just so we’re clear, your PyCharm window should look just like mine in *Figure
    5**.27*.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.27: The main.py file has been reduced to one line of code](img/B19644_05_27.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.27: The main.py file has been reduced to one line of code'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Click the **VCS** menu in the **File** menu and click **Create Git repository**.
    If you don’t remember where in the menu to find this, refer back to *Figure 5**.9*.
    Make note of the default branch that was created. We don’t need a remote for this
    exercise, so it doesn’t matter whether it’s *main*, *master*, or something else;
    you just need to remember its name. I’ll assume it’s called *main*.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Use the commit window to add the files for the project to the repository. *Figure
    5**.3* will remind you if you have forgotten how. Go ahead and commit the files
    by entering a commit message.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to create a branch. Click the branch dropdown and click `development`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `main.py` file. Replace the code with this one line:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: By limiting ourselves to a single line, we can be positive our actions will
    result in a conflict. Commit this change to the `development` branch.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to the main branch using the branch dropdown. Change the contents
    of `main.py` to this code:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Commit this change to the main branch. You’ve just simulated two developers
    changing the same file, in the same area. There will be no way for Git to reconcile
    the differences. With the main branch active, click the branch dropdown, click
    the development branch, and click **Merge development into main**. You will see
    a conflict message, as shown in *Figure 5**.28*.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.28: We have a conflict that needs to be resolved before we can merge](img/B19644_05_28.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.28: We have a conflict that needs to be resolved before we can merge'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: You generally have three options when resolving a conflict. You can choose to
    ignore the incoming changes and select your local work as the correct code by
    clicking the **Accept Yours** button. Likewise, you can select the incoming code
    changes and discard your local copy by clicking **Accept Theirs**. Often, though,
    you will need to merge parts of your local revision with the incoming changes.
    For this, you will need to activate the merge tool, as shown in *Figure 5**.29*,
    by clicking the **Merge…** button.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.29: Activate the merge tool to pick parts from the incoming code
    to merge with yours](img/B19644_05_29.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.29: Activate the merge tool to pick parts from the incoming code to
    merge with yours'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: With the merge tool active, you can see three panes. The pane on the left (**1**)
    represents the conflicting code from the main branch. The code on the right (**2**)
    is the revision coming from the development branch. The pane in the middle (**3**)
    represents the amalgamation of the two. You can pick parts of your code and parts
    of the incoming code to make the best possible combination. Experiment with the
    **>>** buttons (**4**), which copy the code into the central merged result. The
    buttons labeled **X** (**4**) will ignore the conflicted line. You can use the
    up and down arrows (**5**) to jump to the next unresolved conflict in the file.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Let’s pretend the best resolution to my conflict is to have a line from the
    left pane and a line from the right pane together. In real life, this wouldn’t
    work because we’re going to wind up with two variable assignments next to each
    other, but it does demonstrate how the tool works. To use the line from the left
    pane, I can click the button indicated by the arrow in *Figure 5**.30*.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.30: This button will move the code from the left pane into the working
    merge solution](img/B19644_05_30.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.30: This button will move the code from the left pane into the working
    merge solution'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Next, I’d like to place the line from the right pane below the line I just moved.
    Often, you want to use some of the code from both sides rather than it simply
    being right or wrong from one side. Click the button indicated by the arrow in
    *Figure 5**.31* to copy the code from the left pane below the current line in
    the middle pane.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.31: Clicking the double arrow copies this line below the one we
    selected from the right side](img/B19644_05_31.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.31: Clicking the double arrow copies this line below the one we selected
    from the right side'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Once you complete this action, you have resolved the conflict! You are rewarded
    with a nice green message telling you as much.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Your objective is to use the left and right panes to create the best version
    of the code in the middle pane, which represents the resolution of the conflict.
    When you’re finished, you can click the **Apply** button. If you have unresolved
    conflicts remaining in the file, PyCharm will tell you that. If you got them all,
    the merge you attempted is completed. If you are working with a remote, you should
    push the resulting conflict resolution once the commit is successful.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Viewing diffs
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You don’t need a conflict to use the diff window we just saw. A diff window
    is a window that shows two or more versions of code side by side. You can diff
    between branches, or between revisions. Say I make a quick change to our merged
    code by adding this line:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'I also take out line 2, which reads as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: My code is now very different. If I want to compare my new code with the latest
    in the branch, I can right-click the `main.py` tab and click **Git** | **Show
    Diff**. I’ll see a side-by-side diff of the two files, as shown in *Figure 5**.32*.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.32: The diff view between what you’ve got in your editor versus
    the last committed version](img/B19644_05_32.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.32: The diff view between what you’ve got in your editor versus the
    last committed version'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: This diff is appearing in a side-by-side format. You can change it to an in-line
    view, which is often shown on GitHub when you view commits, by changing the drop-down
    setting labeled (**1**). You can also edit the file using the same line-moving
    tools you just saw in the merge indicated by (**2**).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have covered two main topics—the idea of version control
    in application development and programming and its importance, as well as how
    to practice it using Git and GitHub within PyCharm. Specifically, we have learned
    how to carry out version control using Git and GitHub in two different ways: manually
    and with PyCharm.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, PyCharm users can apply version control to their own projects
    in a flexible way, skipping over the manual and tedious process in the terminal/command
    line. We see that, by offering these features, PyCharm allows us to focus on the
    actual development process in any given software engineering project.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Aside from version control, there are other practices in application development—
    which PyCharm provides intuitive, straightforward commands to facilitate. Without
    these commands, application development be quite complex and intimidating. These
    processes are testing, debugging, and profiling, all of which will be discussed
    in the next chapter.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does the term *version control* entail, specifically in the context of
    programming?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of using version control?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the basic steps to version control for your own projects with Git and
    GitHub?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is *branching* and why is it important?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the various windows and tool locations throughout PyCharm that give you
    access to Git and other VCS commands.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Be sure to check out the companion website for the book at [https://www.pycharm-book.com](https://www.pycharm-book.com).
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Merging vs.* *Rebasing*: [https://www.atlassian.com/git/tutorials/merging-vs-rebasing](https://www.atlassian.com/git/tutorials/merging-vs-rebasing)'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How Secure Shell (SSH) works: [https://en.wikipedia.org/wiki/Secure_Shell](https://en.wikipedia.org/wiki/Secure_Shell)'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Adding a new SSH key to your GitHub* *account*: [https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account
    )'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Why GitHub renamed its master branch to* *main*: [https://www.theserverside.com/feature/Why-GitHub-renamed-its-master-branch-to-main](https://www.theserverside.com/feature/Why-GitHub-renamed-its-master-branch-to-main
    )'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Git Merge Strategy Options and* *Examples*: [https://www.atlassian.com/git/tutorials/using-branches/merge-strategy](https://www.atlassian.com/git/tutorials/using-branches/merge-strategy
    )'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Git branching guidance: [https://learn.microsoft.com/en-us/azure/devops/repos/git/git-branching-guidance](https://learn.microsoft.com/en-us/azure/devops/repos/git/git-branching-guidance
    )'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Git Essentials for Beginners: [https://www.packtpub.com/product/mastering-git/9781783553754](https://www.packtpub.com/product/mastering-git/9781783553754)'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Liberty, J. (2021). *Git for Programmers: Master Git for effective implementation
    of version control for your programming projects*. Packt Publishing Limited.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Narebski, J. (2016). *Mastering Git*. Packt Publishing Ltd.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Joel Test: 12 Steps to Better* *Code*: [https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/](https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/)'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be sure to check out the companion website for the book at [https://www.pycharm-book.com](https://www.pycharm-book.com).
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
