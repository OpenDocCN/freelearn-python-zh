- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Version Control with Git in PyCharm
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PyCharm中使用Git进行版本控制
- en: Version control is an essential best practice in the field of software development.
    The mechanics of the process, though, are daunting for new developers. It is easy
    to make mistakes. As a bootcamp instructor at Southern Methodist University (Go
    Ponies!), I have seen quite a few blunders, such as accidentally adding your entire
    home folder to a Git repository, creating repositories inside of other repositories,
    and wiping out the product of hard work by pushing and pulling out of order. I
    prefer my students to master Git on the command line. In fact, it is the very
    first skill I teach, and in my opinion, it is one of the most difficult.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制是软件开发领域的一项基本最佳实践。然而，对于新开发者来说，这个过程的技术细节可能会让人感到畏惧。犯错很容易。作为南方卫理公会大学（Go Ponies！）的训练营讲师，我亲眼目睹了许多错误，比如不小心将整个家目录添加到Git仓库中，在其他仓库内部创建仓库，以及通过错误的推送和拉取顺序抹去辛勤工作的成果。我更喜欢让学生在命令行上掌握Git。实际上，这是我最先教授的技能之一，在我看来，这也是最难的技能之一。
- en: 'After a developer gains confidence with the whole Git process, it is something
    of an annoyance to have to constantly jump out of the IDE to perform four or five
    commands, then jump back into the IDE to continue work. It is true you could use
    the built-in terminal window available in PyCharm, but the IDE offers a better
    option: a built-in version control GUI.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发者对整个Git过程有信心之后，不得不不断跳出IDE执行四到五个命令，然后再跳回IDE继续工作，这确实有些烦恼。虽然你可以使用PyCharm中可用的内置终端窗口，但IDE提供了一个更好的选择：内置的版本控制GUI。
- en: 'PyCharm supports a number of the major **version control systems** (**VCSs**),
    including the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm支持许多主要的 **版本控制系统**（**VCSs**），包括以下内容：
- en: Git
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: Mercurial
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mercurial
- en: Subversion
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Subversion
- en: Perforce
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Perforce
- en: Microsoft **Team** **Foundation Server**
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软 **团队** **基金会服务器**
- en: While there are many other VCSs available, these are easily the most popular,
    and among those in this list, Git has become the de facto standard in the industry.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有许多其他版本控制系统可用，但它们无疑是最受欢迎的，并且在这份列表中，Git已经成为行业中的事实标准。
- en: This chapter will first cover some basic information about version control and
    VCSs just in case you are new to the concept. Following this introduction, we
    will focus entirely on the tooling for Git, since as I just hinted, it has a capital
    lead in terms of market share.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将首先介绍一些关于版本控制和版本控制系统（VCSs）的基本信息，以防你对这个概念不熟悉。在介绍之后，我们将完全专注于Git的工具，因为正如我刚刚暗示的，它在市场份额方面具有领先地位。
- en: 'By the end of the chapter, you will come to understand the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将理解以下内容：
- en: The merits of using a VCS
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用版本控制系统的优点
- en: Working with Git to perform adding, committing, pushing, merging, and branching
    operations
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Git执行添加、提交、推送、合并和分支操作
- en: Creating and maintaining a `.``gitignore` file
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和维护`.gitignore`文件
- en: Working with the Git tooling in the IDE, which may be referenced from several
    vectors
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在IDE中使用Git工具，这可能从多个角度进行参考
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To be successful with this chapter, you will need the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功学习本章内容，你需要以下条件：
- en: A working installation of Python 3.10 or later.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.10或更高版本的正常安装。
- en: A working installation of PyCharm.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyCharm的正常安装。
- en: Git client software for your computer. Mac and Linux systems usually have this
    installed as standard. Windows users can visit [https://gitforwindows.org](https://gitforwindows.org)
    to download the free software.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的电脑安装Git客户端软件。Mac和Linux系统通常作为标准安装。Windows用户可以访问[https://gitforwindows.org](https://gitforwindows.org)下载免费软件。
- en: A free GitHub account. Register at [https://github.com](https://github.com).
    Note that while there are paid features of GitHub, we won’t be using them
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个免费的GitHub账户。请注册于[https://github.com](https://github.com)。请注意，尽管GitHub有付费功能，但我们不会使用它们
- en: Version control and Git essentials
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制和Git基础知识
- en: 'Software industry icon **Joel Spolsky**, who created Stack Overflow, wrote
    a famous blog back in the year 2000\. One of his many influential posts included
    one titled *The Joel Test: 12 Steps to Better Code*. The post was designed to
    give software developers an easy assessment to rate any software development organization’s
    maturity level. He asked 12 questions, with one point per question. A good software
    development group should have a score of 11 or higher. The very first item on
    the list is the concern of this chapter: Do you use source control? If you are
    curious about the rest, there is a link to the blog post, as well as a reference
    to Mr. Spolsky’s book *Joel on Software*, in the *Further reading* section of
    this chapter.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 软件行业标志性人物**乔尔·斯波尔斯基**，他创建了Stack Overflow，在2000年写了一篇著名的博客。他的许多有影响力的帖子中，有一篇标题为*《乔尔测试：12步提升代码质量》*。这篇帖子旨在为软件开发者提供一个简单的评估方法，以评估任何软件开发组织的成熟度水平。他提出了12个问题，每个问题1分。一个优秀的软件开发团队应该得到11分或更高。列表中的第一项就是本章关注的内容：你们使用源代码控制吗？如果你对其他内容感兴趣，可以在本章的*进一步阅读*部分找到博客文章的链接，以及斯波尔斯基先生的书籍*《乔尔论软件》*的引用。
- en: 'Joel called it **source control**. I call it **version control**. The terms
    are interchangeable. I will call it *version control* in order to be consistent
    with the UI in PyCharm, which refers to the group of features we’re talking about
    as a **version control system**, or **VCS**. Strictly speaking, version control
    is a process used to track changes to the files that make up your program over
    time. The objectives of a VCS include the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 乔尔称之为**源代码控制**。我称之为**版本控制**。这两个术语可以互换使用。我将使用*版本控制*来保持与PyCharm的UI一致，PyCharm将我们讨论的这一组功能称为**版本控制系统**或**VCS**。严格来说，版本控制是一个随着时间的推移跟踪组成程序的文件变更的过程。VCS的目标包括以下内容：
- en: The ability to revert to any previously saved version of any file in your project.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够恢复项目中的任何文件之前保存的版本。
- en: The ability to automatically merge the work of multiple developers on a team
    so long as their work does not conflict. A conflict occurs when two developers
    change the same file in the same place.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够自动合并团队中多个开发者的工作，只要他们的工作不冲突。冲突发生在两个开发者更改了同一文件中的同一位置。
- en: Provide an easy means to review conflicts and resolve them through collaboration.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一种简单的方法来审查冲突并通过协作解决它们。
- en: The ability to track which developers made each change in the code over time.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够跟踪随着时间的推移，哪些开发者对代码进行了每次变更。
- en: Provide a branching system to allow bug fixes, enhancements, and experimentation
    without sacrificing the stability of your production code.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个分支系统，允许修复错误、增强功能和实验，而不会牺牲生产代码的稳定性。
- en: A VCS, then, is a software system designed to enable that process. VCSs come
    in two varieties, depending on how revisions are stored. **Centralized VCSs**
    work a little like your local public library. Your project is checked into a **repository**.
    Developers can then check out the code in order to work on creating a new revision.
    Doing so will retrieve the latest version of the project. Some systems, such as
    **Perforce**, traditionally require you to explicitly check out the files you
    want to work with just like you’d check out a book from a library. While you have
    those files checked out, nobody else is allowed to modify them until you check
    them back in with your changes. Other systems, such as **Subversion**, don’t have
    this requirement. Anybody can work on their local working copy. When work is done,
    the developer **commits** their work to the central repository. During the commit
    process, the VCS checks for **conflicts**. If no conflicts exist, the incoming
    work is **merged** and a new version is stored on the VCS server, which is then
    available for other developers through an update process. If conflicts are detected,
    the commit is rejected, and the developer must work with other developers on the
    team to resolve the conflict before the work can be merged and finally committed.
    In all centralized systems, each developer on a team has only the latest version
    of the code on their local computer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，版本控制系统（VCS）是一种旨在启用该过程的软件系统。VCSs根据修订的存储方式分为两种类型。**集中式VCS**的工作方式有点像你当地的公共图书馆。你的项目被检查到一个**仓库**中。开发者可以检出代码以便进行创建新修订的工作。这样做将检索项目的最新版本。一些系统，如**Perforce**，传统上要求你明确检出你想要工作的文件，就像从图书馆借阅一本书一样。在你检出这些文件期间，不允许其他人修改它们，直到你将它们检入并带上你的更改。其他系统，如**Subversion**，没有这个要求。任何人都可以在他们本地的副本上工作。当工作完成时，开发者会将他们的工作**提交**到中央仓库。在提交过程中，VCS会检查**冲突**。如果没有冲突，传入的工作将被**合并**，并在VCS服务器上存储一个新的版本，然后通过更新过程供其他开发者使用。如果检测到冲突，提交将被拒绝，开发者必须与其他团队成员一起工作以解决冲突，然后才能合并并最终提交工作。在所有集中式系统中，团队中的每个开发者在其本地计算机上只有代码的最新版本。
- en: In contrast, **distributed version control systems** (**DVCSs**) such as **Git**
    and **Mercurial** keep every revision ever performed on the project on each developer’s
    computer. The advantage here is there is no single point of failure that might
    result in a total loss of the project code. In a centralized system, if the server
    is compromised, the project’s revision history might be lost. In a distributed
    system, there isn’t a central system to store the project’s revision history.
    Every developer has the project’s entire history on their computer, so the loss
    of any one computer isn’t a big deal beyond the usual pain of replacing the equipment.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，**分布式版本控制系统**（**DVCS**）如**Git**和**Mercurial**将项目上所执行的每个修订都保存在每个开发者的计算机上。这里的优势是没有任何单点故障可能导致项目代码的完全丢失。在集中式系统中，如果服务器被破坏，项目的修订历史可能会丢失。在分布式系统中，没有中央系统来存储项目的修订历史。每个开发者都有项目完整的历史记录在他们的计算机上，所以任何一台计算机的丢失并不会造成太大的问题，除了更换设备的常规痛苦之外。
- en: With that said, distributed systems do use a central **hub** or **remote** to
    allow easy synchronization between the working copies on each developer’s computer.
    The hub server allows additional functionality, such as managing who is allowed
    to view or change the code, as well as collaborative features such as code reviews,
    bug tracking, documentation, and discussion. A DVCS also presents an easy way
    to control the publication of new releases of web-based applications. Many continuous
    deployment systems, such as **Travis CI**, **CircleCI**, and **Beanstalk**, are
    simply leveraging features of the DVCS to control the release management process.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，分布式系统确实使用一个中央**枢纽**或**远程**，以便在每位开发者的计算机上的工作副本之间实现轻松同步。枢纽服务器允许额外的功能，例如管理谁可以查看或更改代码，以及协作功能，如代码审查、错误跟踪、文档和讨论。分布式版本控制系统（DVCS）也提供了一个轻松控制基于Web的应用程序新版本发布的方法。许多持续部署系统，如**Travis
    CI**、**CircleCI**和**Beanstalk**，只是利用DVCS的功能来控制发布管理过程。
- en: The most famous DVCS is Git, created by **Linus Torvalds**, who also created
    the **Linux** operating system. The most famous DVCS hub is, you guessed it, GitHub,
    which is owned by Microsoft. Many people use the terms *Git* and *GitHub* interchangeably.
    This is a mistake. GitHub is a place on the internet. The software used to access
    *GitHub* is called *Git*. Many projects that use Git as their DVCS host their
    repository hub in services other than GitHub, such as **GitLab**, **Microsoft
    Azure DevOps**, **Atlassian Bitbucket**, and **Beanstalk** ([https://beanstalkapp.com](https://beanstalkapp.com),
    not to be confused with the Beanstalk service on **Amazon Web Services**, which
    has nothing to do with version control).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的分布式版本控制系统（DVCS）是Git，由**林纳斯·托瓦兹**（Linus Torvalds）创建，他同样创建了**Linux**操作系统。最著名的DVCS中心是GitHub，它由微软拥有。许多人将*Git*和*GitHub*互换使用。这是一个错误。GitHub是互联网上的一个地方。用于访问*GitHub*的软件称为*Git*。许多使用Git作为其DVCS主机的项目将他们的仓库中心托管在GitHub之外的服务上，例如**GitLab**、**Microsoft
    Azure DevOps**、**Atlassian Bitbucket**和**Beanstalk**（[https://beanstalkapp.com](https://beanstalkapp.com)，不要与**Amazon
    Web Services**上的Beanstalk服务混淆，它与版本控制无关）。
- en: As developers make changes to their working copy, they can commit changes to
    their local copy. They can later synchronize their code by pulling changes from
    the central hub, reconciling any conflicts, and then pushing their merged work.
    Again, the big difference is in a DVCS; everything happens on the developer’s
    computer versus on a server with a centralized system.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者对其工作副本进行更改时，他们可以将更改提交到本地副本。他们可以在稍后通过从中央中心拉取更改、解决任何冲突，然后将合并的工作推送到中央中心。再次强调，在DVCS中，所有操作都在开发者的计算机上完成，而不是在具有集中式系统的服务器上。
- en: Setting up Git on your computer
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的计算机上设置Git
- en: 'Whether you installed Git for Windows on your Windows computer, or you are
    working with a pre-installed Git client on your Mac or Linux computer, you need
    to perform some additional setup beyond simply installing the software. The setup
    tasks ahead include the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是在Windows计算机上安装了Git for Windows，还是在使用Mac或Linux计算机上的预安装Git客户端，您都需要执行一些额外的设置，而不仅仅是安装软件。接下来的设置任务包括以下内容：
- en: Set your default username and email address.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置默认用户名和电子邮件地址。
- en: Create a **Secure Shell** (**SSH**) key so you can securely communicate with
    remote hubs such as GitHub.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**安全外壳**（**SSH**）密钥，以便您能够安全地与远程中心（如GitHub）通信。
- en: Add the SSH key to your account on GitHub.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将SSH密钥添加到您的GitHub账户。
- en: Let’s go through the process for each.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一介绍这个过程。
- en: To get started, you need to launch a terminal. If you are using Mac or Linux,
    you should be able to find an app on your system, simply called *Terminal*. The
    commands I’ll present are going to be using the **Bash shell**. Mac’s terminal
    program defaults to a shell called the **Z shell** (**zsh**), which is directly
    compatible with Bash. Most Linux installations default to Bash, so you are all
    set. If you are in Windows, you need to have installed the Git software from [https://gitforwindows.org](https://gitforwindows.org).
    One of the programs installed is called *gitbash*. Launching **gitbash** will
    allow us all to use the same commands regardless of which operating system we’re
    using.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，您需要启动一个终端。如果您使用Mac或Linux，您应该能够在系统上找到一个名为*Terminal*的应用程序。我将展示的命令将使用**Bash
    shell**。Mac的终端程序默认使用一个名为**Z shell**（**zsh**）的shell，它与Bash直接兼容。大多数Linux安装默认使用Bash，所以您已经准备好了。如果您使用Windows，您需要从[https://gitforwindows.org](https://gitforwindows.org)安装Git软件。安装的程序之一是*gitbash*。启动**gitbash**将允许我们无论使用哪种操作系统都能使用相同的命令。
- en: Setting your default username and email address
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置默认用户名和电子邮件地址
- en: 'Having launched your terminal, you need to execute the following command to
    set your default username:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 启动您的终端后，您需要执行以下命令来设置默认用户名：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Naturally, you’ll fill in your actual name. Next, fill in your email address.
    If you work for a corporation, I strongly recommend creating a separate GitHub
    account to keep your work separate from your employers to avoid any nasty intellectual
    property disputes. Keeping that in mind, use an appropriate email address for
    your work with the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，您将填写您的真实姓名。接下来，填写您的电子邮件地址。如果您在一家公司工作，我强烈建议您创建一个单独的GitHub账户，以保持您的工作与雇主分开，避免任何不愉快的知识产权纠纷。考虑到这一点，使用以下命令为您的办公工作指定适当的电子邮件地址：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are more extensive configuration options beyond using these two globals,
    but this is the most common way to set up Git, and you won’t be able to push code
    to GitHub without these settings. If you’d like more in-depth information on working
    with Git, I recommend checking out the additional reading in the *Further reading*
    section of this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用这两个全局变量之外，还有更多广泛的配置选项，但这是设置 Git 最常见的方式，没有这些设置，你将无法将代码推送到 GitHub。如果你想要更多关于使用
    Git 的深入信息，我建议查看本章“进一步阅读”部分中的附加阅读材料。
- en: Generating an SSH key
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成 SSH 密钥
- en: 'One objective of a remote hub is to keep your code secure from malicious tampering.
    One of the ways this happens is to ensure all communications between your computer
    and the remote are encrypted. You can work with HTTPS encryption or SSH. While
    both are valid encryption tools, SSH is considered far superior and is the mark
    of a real pro. In order to work with SSH, you need to generate a unique pair of
    encryption keys: one public key and a matching private key. I won’t go into how
    SSH works here, but if you’re curious, I’ll leave some reading suggestions in
    the *Further reading* section of this chapter.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 远程中心的一个目标是为了确保你的代码免受恶意篡改。实现这一目标的一种方式是确保你电脑和远程之间的所有通信都是加密的。你可以使用 HTTPS 加密或 SSH。虽然两者都是有效的加密工具，但
    SSH 被认为远优于其他工具，是真正专业人士的标志。为了使用 SSH，你需要生成一个唯一的密钥对：一个公钥和一个匹配的私钥。在这里我不会深入解释 SSH 的工作原理，但如果你对它感兴趣，我会在本章“进一步阅读”部分提供一些阅读建议。
- en: 'Generating a key is pretty simple. Having opened a Bash session, simply type
    the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 生成密钥相当简单。在打开 Bash 会话后，只需输入以下命令：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The key generation program will ask you some questions, such as where to store
    your key files and what to call them. By default, they are called `id_rsa` (the
    private key) and `id_rsa.pub` (the public key), both of which are stored in your
    home folder in a sub-folder called `.ssh`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥生成程序会询问你一些问题，例如在哪里存储你的密钥文件以及如何命名它们。默认情况下，它们被命名为 `id_rsa`（私钥）和 `id_rsa.pub`（公钥），这两个文件都存储在你主目录下的
    `.ssh` 子目录中。
- en: The last question asked is the passphrase for the key. You can enter a password
    for the key for extra security, or just press *Enter* for an empty passphrase.
    This is generally not advisable, since security is tighter when you create a passphrase.
    The drawback to having a passphrase is you are constantly challenged to enter
    the passphrase. An empty passphrase bypasses these interruptions but puts security
    at risk by making your key easier to compromise. I recommend entering a passphrase
    because one of the advantages of using PyCharm’s tooling is that it stores your
    passphrase in its own encrypted database. PyCharm will answer all your challenges
    for you, eliminating the inconvenience of working with a passphrase-protected
    encryption key.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个问题是要输入密钥的密码。你可以为密钥设置一个密码以增加安全性，或者直接按 *Enter* 键以使用空密码。这通常是不推荐的，因为创建密码时的安全性更高。拥有密码的缺点是你需要不断输入密码。使用空密码可以避免这些中断，但同时也增加了密钥被破解的风险。我建议输入密码，因为使用
    PyCharm 的工具的一个优点是它会将其存储在其自己的加密数据库中。PyCharm 将会为你回答所有挑战，从而消除了使用受密码保护的加密密钥的不便。
- en: 'After the passkey is entered, you’ll get some additional feedback. You can
    check your key by typing the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 passkey 后，你会得到一些额外的反馈。你可以通过输入以下命令来检查你的密钥：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This lists (`ls`) the files in your home folder (`~/`) under the `.ssh` sub-folder
    including any hidden files (`-a` for “all files”). You should see, at a minimum,
    the `id_rsa` and `id_rsa.pub` files. You are going to need the contents of the
    `id_rsa.pub` file in just a moment as you are going to paste its contents onto
    a screen on GitHub.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这列出了（`ls`）你主目录（`~/`）下 `.ssh` 子目录中的文件，包括任何隐藏文件（`-a` 表示“所有文件”）。至少你应该能看到 `id_rsa`
    和 `id_rsa.pub` 文件。你很快就需要 `id_rsa.pub` 文件的内容，因为你将要把其内容粘贴到 GitHub 的屏幕上。
- en: We’ve come to the part in the book where I offer a fatherly lecture on security.
    Never ever, ever, ever (times infinity to the googleth power plus one) paste your
    private key into anything. Never ever (ad nauseam) allow anybody to copy your
    private key. Don’t put it on a thumb drive. Don’t copy it to a network drive or
    cloud file share for safekeeping. For the love of everything holy, never check
    it into a repository! That goes for any passwords for any system. Your repos might
    ultimately become public, if not to the whole world, then at least to the rest
    of your team.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: The public key is for sharing. The private key is to be kept secret and hidden.
    If your private key is compromised, only your passphrase protects your work. If
    you left the passphrase blank, then you have no further protection!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the contents of your public key, type the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The contents of your public key will appear in your terminal window. Select
    the entire key, right-click, and click **Copy**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Adding your SSH key to your GitHub account
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’m going to cover this pretty quickly since I suspect many of you have done
    this before. If you need a better tutorial on adding an SSH key to your GitHub
    account, see the *Further reading* section at the end of this chapter for an explicit
    list of steps specific to Git.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Log in to GitHub and click your face. By that, I mean the avatar on GitHub in
    the upper-right corner, assuming they haven’t re-designed their site since going
    to press. Find the option for working with your profile and find **Settings**.
    Inside your profile settings is an option to manage your SSH keys. Click that
    link, then find the option to add an SSH key. Paste in the public key you copied
    a moment ago, give it a name that is easy to remember, and click the **Add** button.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You are fully set up for secure communications between your
    computer and GitHub remotes. It is possible to reuse your SSH key between different
    computers you own. Just copy the `.ssh` folder between computers. Just be careful
    not to compromise the key by keeping it on a portable drive you might lose, or
    a cloud file share that might be compromised.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a repository manually
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B19644_03.xhtml#_idTextAnchor052), *Customizing Interpreters
    and Virtual Environments*, we created a virtual environment manually in order
    to become familiar with the process. We’ll do the same thing here. Let’s use the
    command line to create a repository and perform all the basic functions available
    in Git. Afterward, we’ll see where PyCharm’s tooling allows us to perform the
    same operations right from the IDE in a convenient GUI.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Don’t use spaces in any file or folder name
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: I’m going to bring this up often since I know a lot of readers skip around in
    books like this one. If you are new to software development, you may not know
    that using filenames with spaces can cause problems. Avoid using file and folder
    names with spaces, including any folders created by your operating system. Instead,
    use separators in place of spaces, such as dashes or underscores, or use camelCase
    names, which omit spaces and present word boundaries with a capital letter.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我会经常提到这一点，因为我知道很多读者会跳过这类书籍。如果您是软件开发的新手，您可能不知道使用带空格的文件名可能会引起问题。请避免使用带空格的文件和文件夹名称，包括由您的操作系统创建的任何文件夹。相反，使用分隔符代替空格，例如破折号或下划线，或者使用驼峰式命名，这种命名方式省略空格，并用大写字母表示单词边界。
- en: 'With your Bash terminal session open, the first thing we’re going to do is
    create a folder for our project. We’ll do this in your home folder with this command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 Bash 终端会话打开后，我们将要做的第一件事是为我们的项目创建一个文件夹。我们将使用以下命令在您的家目录中完成此操作：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, let’s change the directory to the newly created folder:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将目录更改为新创建的文件夹：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is where our code is going to live! Before we go any further though, we
    need to talk about a sensitive subject.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的代码将要存放的地方！在继续之前，我们需要讨论一个敏感的话题。
- en: Master versus main branches in GitHub
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub 中的主分支与 main 分支
- en: For the first 12 years after GitHub was established, whenever one created a
    new repository in GitHub, the tool established a default starting branch called
    *master*. In 2020, an organization called *The Software Freedom Conservancy* advised
    GitHub to change the name of the default branch from *master* to *main* owing
    to the association of the term *master* with slavery. While Git doesn’t force
    you to use any particular name, the default on GitHub has been changed to *main*.
    Since GitHub doesn’t control Git, this name change is only the default on repositories
    created by GitHub. We’ve been creating our repositories using the Git command
    line, which is leveraged by PyCharm’s Git tools. Whether you use the Git command
    or PyCharm’s integration, there’s a solid chance you’re going to get a repository
    initialized with a branch called *master*. When you create a remote on GitHub,
    that repo will be created with a default branch called *main*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 成立后的前 12 年里，每当在 GitHub 中创建一个新的仓库时，该工具都会创建一个名为 *master* 的默认起始分支。在 2020
    年，一个名为 *The Software Freedom Conservancy* 的组织建议 GitHub 将默认分支的名称从 *master* 更改为
    *main*，因为 *master* 这个词与奴隶制有关。虽然 Git 不会强迫您使用任何特定的名称，但 GitHub 上的默认名称已被更改为 *main*。由于
    GitHub 不控制 Git，这个名称更改仅适用于 GitHub 创建的仓库。我们一直在使用 Git 命令行创建仓库，这是 PyCharm 的 Git 工具所利用的。无论您使用
    Git 命令还是 PyCharm 的集成，有很大可能性您将得到一个以 *master* 分支初始化的仓库。当您在 GitHub 上创建远程仓库时，该仓库将使用名为
    *main* 的默认分支创建。
- en: You should take care to match the names of the default branches so that when
    you perform your first push, your branches synchronize properly. You can either
    change the name in GitHub or set the Git command on your computer to use *main*
    for the default.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该注意匹配默认分支的名称，以便在您执行第一次推送时，您的分支能够正确同步。您可以在 GitHub 上更改名称，或者在您的计算机上设置 Git 命令以使用
    *main* 作为默认名称。
- en: If you want to change it on GitHub, you can go into your profile settings and
    click **Repositories**. You’ll find the setting at the top, as shown in *Figure
    5**.1*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在 GitHub 上更改它，您可以进入您的个人资料设置并点击**仓库**。您将在顶部找到该设置，如图 *图 5**.1* 所示。
- en: '![Figure 5.1: You can set the default name of repositories in GitHub to match
    the default on your computer](img/B19644_05_01.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1：您可以将 GitHub 仓库的默认名称设置为与您计算机上的默认名称匹配](img/B19644_05_01.jpg)'
- en: 'Figure 5.1: You can set the default name of repositories in GitHub to match
    the default on your computer'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：您可以将 GitHub 仓库的默认名称设置为与您计算机上的默认名称匹配
- en: 'You can also set a global setting on your computer with this command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用以下命令在您的计算机上设置全局设置：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you intend to do a lot of work with GitHub as your remote, it is a good idea
    to synchronize the default branch name. If you don’t, the first time you try to
    push the repository you created on your computer to the remote created on GitHub,
    you’ll encounter an error. The default locally is *master*, while the default
    on the remote is *main*. The remote won’t have a branch called *master*, so you’ll
    get a message stating there is no upstream branch called *master*. You’ll have
    to do some work to get this settled. I’ll leave a link to an article on how to
    resolve this situation should you encounter it. I encourage you to just avoid
    it entirely by using the preceding Git command to set your local global setting
    to *main* so it matches GitHub.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算在GitHub上做很多工作，同步默认分支名称是一个好主意。如果你不这样做，当你第一次尝试将你在计算机上创建的仓库推送到GitHub上创建的远程仓库时，你会遇到错误。本地的默认分支是*master*，而远程的默认分支是*main*。远程不会有名为*master*的分支，所以你会收到一条消息，说明没有名为*master*的上游分支。你可能需要做一些工作来解决这个问题。如果你遇到这种情况，我会留一个链接到一篇文章，告诉你如何解决这个问题。我鼓励你通过使用前面的Git命令将你的本地全局设置设置为*main*来避免这个问题，这样它就会与GitHub匹配。
- en: Manually initializing the repository
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动初始化仓库
- en: 'Let’s create our repository. It is entirely possible, and even normal, to create
    a repository after you have created a code project. However, we will start with
    the repository since this will be a very simple demonstration. To create a new
    Git repository, or repo for short, type the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的仓库。在你创建了一个代码项目之后创建一个仓库是完全可能的，甚至可以说是正常的。然而，我们将从仓库开始，因为这将会是一个非常简单的演示。要创建一个新的Git仓库，或者简称为repo，请输入以下命令：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That was easy! It might look like nothing much happened. You’ll get a message
    stating the repository was created. Let’s look at the changes to the folder:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单！看起来好像没有发生什么。你会收到一个消息，说明仓库已创建。让我们看看文件夹的变化：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `ls` command lists all the files. The `-a` switch shows hidden files and
    folders. When you initialized the Git repository, the Git software created a folder
    called `.git`. Since the folder name starts with a period (`.`), the folder is
    hidden in Linux-like systems. If you perform these steps in Windows with PowerShell,
    you’ll be able to see the folder, but it’s hidden in the other operating systems.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls`命令列出所有文件。`-a`选项显示隐藏的文件和文件夹。当你初始化Git仓库时，Git软件创建了一个名为`.git`的文件夹。由于文件夹名以点（`.`）开头，所以在类似Linux的系统中的文件夹是隐藏的。如果你在Windows上使用PowerShell执行这些步骤，你将能够看到文件夹，但在其他操作系统中它是隐藏的。'
- en: The `.git` folder is where all your revisions are stored, along with all your
    project’s settings. In general, you should never need to alter the contents of
    this folder.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`.git`文件夹是存储所有你的修订和项目设置的地方。一般来说，你不需要修改这个文件夹的内容。'
- en: 'We have a repository on our local computer. Let’s add a new file. Type the
    following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的本地计算机上有一个仓库。让我们添加一个新文件。输入以下命令：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This created a new file called `test.txt`. Within that file is the line `hello
    world`. What a great way to start, right? You can check the contents of the file
    by typing the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个名为`test.txt`的新文件。在该文件中有一行`hello world`。这是一个多么好的开始，对吧？你可以通过输入以下命令来检查文件的内容：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Who needs an IDE, right? Wait, no, forget I said that. The order of the next
    few steps is important. The process is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 谁需要集成开发环境（IDE），对吧？等等，不，别当真，我刚才那么说了。接下来的几个步骤的顺序很重要。过程如下：
- en: Add the file(s) to the repository. The files you are adding are the files you
    have either created or modified since your last commit. We don’t have one of those
    yet. Adding your files to the repo is also called staging your files. We are making
    the repository aware of new and changed files. You shouldn’t always add every
    file to your project. There are some you should keep out of your repository. We’ll
    cover that a little later.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件添加到仓库中。你添加的文件是你自上次提交以来创建或修改的文件。我们还没有这样的文件。将你的文件添加到仓库也称为暂存文件。我们正在让仓库知道新文件和已更改的文件。你不应该总是将每个文件添加到你的项目中。有些文件你应该从仓库中排除。我们稍后会讨论这一点。
- en: Commit your files. This creates a new version of your code on your local computer.
    The commit action requires you to include a comment that explains the nature of
    the changes you’ve made. This is vital! You should endeavor to write a concise
    summary of your changes, and you should write these comments as though your most
    important customer will one day read all these comments. This is not a place to
    vent your frustrations! Trust me on this one. I’ve seen projects fall under unexpected
    audits where mean or inappropriate comments surfaced and working relationships
    were ruined. Assume everything you write will be read and judged by the whole
    world.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交您的文件。这将在您的本地计算机上创建代码的新版本。提交操作要求您包含一个注释，说明您所做的更改的性质。这是至关重要的！您应该努力编写您更改的简洁摘要，并且您应该像假设您最重要的客户有一天会阅读所有这些注释一样编写这些注释。这不是发泄您挫折的地方！请相信我。我见过项目在意外审计中失败，其中不友好或不适当的评论出现，工作关系被破坏。假设您所写的一切都将被全世界阅读和评判。
- en: Pull changes from the remote hub. You always want to pull before you push. This
    allows you to find any conflicts between your work, and any work that might have
    been pushed by another developer on the project. This is important! If you don’t
    pull before your push, it is possible to overwrite another developer’s revision!
    This is certainly not catastrophic since all revisions are held in the repo. It
    will, however, make tomorrow’s stand-up meeting very awkward for you as the other
    developer will likely not be happy with you for making extra work for the group!
    It’s simple. Just remember to pull before you push. Do this even if you are the
    only person working on the project and just make it a habit!
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从远程中心拉取更改。您总是在推送之前拉取。这允许您找到您的工作中可能存在的任何冲突，以及可能由项目中的另一位开发者推送的任何工作。这很重要！如果您在推送之前不拉取，可能会覆盖另一位开发者的修订版本！这当然不是灾难性的，因为所有修订版本都保存在仓库中。然而，这会让您作为其他开发者在明天的站立会议中感到非常尴尬，因为其他开发者可能不会因为您为团队增加了额外的工作而高兴！这很简单。只需记住在推送之前先拉取。即使您是唯一一个在项目上工作的人，也要养成这个习惯！
- en: Assuming there are no conflicts, push your work to the remote hub.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设没有冲突，将您的工作推送到远程中心。
- en: Your revisions are now available to the rest of the team and stored securely
    on the remote server. Let’s go through the commands for this process.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您的修订版本现在可供团队中的其他人使用，并安全地存储在远程服务器上。让我们来回顾一下这个过程的命令。
- en: 'First, add your new and changed files to Git. Remember, this is also called
    **staging** your files:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将您的新文件和更改的文件添加到Git中。记住，这也被称为**暂存**您的文件：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you have a bunch of files in your project, it is possible to add them all
    at once with the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的项目中有很多文件，可以使用以下方法一次性添加它们：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With your latest changes staged, you can now commit them to the local repo.
    This creates a new version of your project on your computer. You need to include
    a comment that summarizes your changes:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在将最新的更改暂存后，您现在可以将它们提交到本地仓库。这将在您的计算机上创建项目的新版本。您需要包含一个总结您更改的注释：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `-m` switch is our comment, which is enclosed in double quotes. Just remember
    it as a *commit message* and the `-m` switch is easy to remember. Of course, by
    the end of the chapter, you won’t need to remember all this command-line stuff
    since you’ll have a nifty GUI.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`-m` 开关是我们的注释，用双引号括起来。只需将其记住为**提交信息**，`-m` 开关很容易记住。当然，到本章结束时，您不需要记住所有这些命令行内容，因为您将有一个便捷的图形用户界面。'
- en: Working with remotes
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与远程服务器协同工作
- en: 'It is possible to work with a project entirely on your local computer. Naturally,
    you’d lose all the collaborative benefits provided by a remote hub, including
    the benefits of a remote backup of your change history. Earlier, I presented a
    four-step process:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本地计算机上完全处理一个项目。自然地，您会失去由远程中心提供的所有协作优势，包括更改历史记录的远程备份优势。之前，我介绍了一个四步过程：
- en: Add or stage your changed files.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加或暂存您的更改文件。
- en: Commit your changes to create a new revision.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的更改提交以创建一个新的修订版本。
- en: Pull changes from the remote.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从远程服务器拉取更改。
- en: Push your merged work to the remote.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将合并后的工作推送到远程服务器。
- en: We’re halfway through the list, having completed the first two steps on our
    local copy of the repository. We must interrupt the process at this point because
    we don’t presently have a remote. We’re going to create one on GitHub, but naturally,
    you can use any compatible service.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了列表的前两步，在我们的本地仓库副本上完成了。我们必须在此处中断流程，因为我们目前没有远程服务器。我们将在GitHub上创建一个，但当然，您可以使用任何兼容的服务。
- en: Adding a remote on GitHub
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在GitHub上添加远程服务器
- en: Log on to GitHub and find the **Add Repository** button. It is usually a very
    obvious green button. With my luck, they’ll redo the site at press time. Nevertheless,
    they usually make the **Create repository** button very obvious on the UI.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 登录GitHub并找到**添加仓库**按钮。它通常是一个非常明显的绿色按钮。以我的运气，他们会在出版时重新设计网站。不过，他们通常会在用户界面(UI)上非常明显地放置**创建仓库**按钮。
- en: Let’s create a repository to match the one we created locally. I’ll make mine
    public, which means everybody can see it. If you’re bashful, you can make it private.
    It won’t matter for this exercise.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个与本地创建的仓库相匹配的仓库。我会将其设置为公开，这意味着每个人都可以看到它。如果你比较害羞，你可以将其设置为私有。对于这个练习来说，这不会有什么影响。
- en: Once you have created the repository, GitHub will display instructions for adding
    the GitHub version of the repo as a remote. Just copy and paste the code GitHub
    generated into your terminal, making sure that your terminal is currently in the
    repository folder as the present working directory.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了仓库，GitHub将显示如何将GitHub版本的仓库添加为远程仓库的说明。只需将GitHub生成的代码复制并粘贴到你的终端中，确保你的终端当前位于仓库文件夹中，作为当前工作目录。
- en: 'You can verify the remote by typing the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入以下内容来验证远程仓库：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The command generated by GitHub sets the name of the GitHub copy of the repo
    as *origin*. You should have one remote called *origin*, while the local version
    of the repository is referred to by the current branch, which is usually *main*,
    as described earlier.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub生成的命令将仓库的GitHub副本名称设置为*origin*。你应该有一个名为*origin*的远程仓库，而本地仓库的版本则通过当前分支来引用，通常如前所述是*main*。
- en: The first push
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一次推送
- en: 'Now that you have a remote, you can push your local repo to the remote. Type
    the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了远程仓库，你可以将你的本地仓库推送到远程。输入以下内容：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This pushes your copy of the main branch to the remote and sets upstream tracking
    for the main branch. This is just a fancy way of saying both the remote and the
    local repository are aware of the main branch, and any push here will result in
    the remote main branch being updated. If the remote doesn’t have a branch called
    `main`, one will be created and everything will synchronize nicely.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将你的主分支副本推送到远程，并为主分支设置上游跟踪。这仅仅是一个花哨的说法，意思是远程和本地仓库都知道主分支，任何推送到这里的更改都将导致远程主分支被更新。如果远程没有名为`main`的分支，将会创建一个，并且所有内容都将同步得很好。
- en: Making, committing, and pushing a change
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建、提交和推送更改
- en: Now that we have a fully working repository, complete with a remote on GitHub,
    let’s make one full round of changes to our code. We’ll cover the four-step process
    this time without interruption. This is the process you’ll follow many times per
    day for the duration of your project.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个完全工作的仓库，包括GitHub上的远程仓库，让我们对我们的代码进行一次完整的更改。这次我们将不中断地介绍四个步骤的过程。这是你将在项目期间每天多次遵循的过程。
- en: The next step is very important. Make this a habit!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步非常重要。养成这个习惯！
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This pulls any changes sitting on the remote and allows you to fix any conflicts
    before they go out into the world! Naturally, in this situation, there won’t be
    any conflicts since only we are working on the project.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这会拉取远程上的任何更改，并允许你在它们进入世界之前解决任何冲突！当然，在这种情况下，由于只有我们在这个项目上工作，所以自然不会有任何冲突。
- en: 'Next, let’s change the contents of our text file. Type the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更改文本文件的内容。输入以下内容：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can check the result with the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下方法来检查结果：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should see the changed file. Now let’s do a full cycle of add, commit,
    pull, and push. Type each of the following lines, one at a time, and press *Enter*
    at the end of each one:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到更改后的文件。现在让我们进行一次完整的添加、提交、拉取和推送循环。逐行输入以下内容，每输入一行后按*Enter*键：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Switch to your browser where you created your repository, and refresh the page.
    You should see your code. You can click the `test.txt` file in the browser to
    verify the new contents were pushed. You should also see there are two revisions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到你在其中创建了仓库的浏览器，并刷新页面。你应该能看到你的代码。你可以在浏览器中点击`test.txt`文件来验证新内容是否已推送。你也应该看到有两个版本。
- en: Your repo is set up and working properly! Let’s switch our focus from the command
    line to working in the IDE.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你的仓库已正确设置并运行！让我们将我们的注意力从命令行转移到在IDE中工作。
- en: Working with Git in the IDE
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在IDE中使用Git
- en: 'We have already gone through some of the Git workflows in PyCharm. In [*Chapter
    2*](B19644_02.xhtml#_idTextAnchor028), *Installation and Configuration*, we used
    PyCharm to clone the sample code repository for this book. Since we’ve covered
    cloning, we won’t do it again. Instead, let’s consider all we did manually a moment
    ago:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了PyCharm中的一些Git工作流程。在[*第2章*](B19644_02.xhtml#_idTextAnchor028)“安装和配置”中，我们使用PyCharm克隆了本书的示例代码仓库。由于我们已经介绍了克隆，我们不会再次进行操作。相反，让我们考虑我们刚才手动做的一切：
- en: We used `git init` to initialize a new local repository.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`git init`初始化一个新的本地仓库。
- en: We made a change to our code.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对代码进行了更改。
- en: We used `git add` to add the changes as staged files in preparation for a commit.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`git add`将更改添加为待提交的文件，以准备提交。
- en: We committed our changes to the local repository.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已将更改提交到本地仓库。
- en: We pulled from the remote to make sure we have the latest code on this branch
    and that no conflicts exist between what we have in our working copy and what
    exists on the remote. The remote could have recently changed owing to some other
    developer pushing their changes.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从远程拉取，以确保我们在这个分支上有最新的代码，并且我们的工作副本和远程之间的代码不存在冲突。远程可能由于其他开发者推送了他们的更改而最近发生了变化。
- en: Finally, we pushed our changes to the remote.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将更改推送到远程。
- en: This list represents the most basic workflow for capturing and managing revisions
    on a project. We can do all of this and more in PyCharm’s GUI. It is also fairly
    common to do some work in PyCharm and some in the command line. Using one or the
    other doesn’t preclude anything. For example, I often branch and merge in the
    command line because it’s quick and easy for me. If there is a conflict, I find
    resolving it in PyCharm to be superior in every way versus a manual approach.
    The GUI for this task is outstanding. We’ll get to all this in good time. For
    now, open the folder you’ve been using in PyCharm, and let’s explore what the
    IDE can do for us regarding these first steps we’ve taken manually.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表代表了在项目中捕获和管理修订的最基本工作流程。我们可以在PyCharm的GUI中完成所有这些以及更多。在PyCharm中做一些工作，在命令行中做一些工作也是相当常见的。使用一个或另一个不会排除任何事情。例如，我经常在命令行中分支和合并，因为这对我来说既快又简单。如果有冲突，我发现使用PyCharm手动解决它比手动方法更优越。这个任务的GUI非常出色。我们将在适当的时候讨论所有这些。现在，打开你在PyCharm中使用的文件夹，让我们探索IDE能为我们手动采取的这些第一步做些什么。
- en: Version control in PyCharm
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyCharm中的版本控制
- en: PyCharm has several places in the UI that allow you to access your VCS, which
    for us is Git. They aren’t redundant, but instead, each area provides a visual
    tool for a particular task. The first is the main menu, as seen in *Figure 5**.2*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm在UI中有几个地方允许您访问您的VCS，对我们来说就是Git。它们不是重复的，而是每个区域都为特定任务提供了一个视觉工具。第一个是主菜单，如*图5.2*所示。
- en: '![Figure 5.2: The Git menu allows you to access all the commands you might
    normally use at the command line](img/B19644_05_02.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2：Git菜单允许您访问您通常在命令行中使用的所有命令](img/B19644_05_02.jpg)'
- en: 'Figure 5.2: The Git menu allows you to access all the commands you might normally
    use at the command line'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：Git菜单允许您访问您通常在命令行中使用的所有命令
- en: 'The second provides a fast and easy way to commit files. This can be found
    in the sidebar menu, as seen in *Figure 5**.3*:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个提供了快速且简单的方式来提交文件。这可以在侧边栏菜单中找到，如*图5.3*所示：
- en: '![Figure 5.3: The Git commit tools can be found in the sidebar](img/B19644_05_03.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3：Git提交工具可以在侧边栏中找到](img/B19644_05_03.jpg)'
- en: 'Figure 5.3: The Git commit tools can be found in the sidebar'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：Git提交工具可以在侧边栏中找到
- en: The third allows visualization of the branch and commit history. This can be
    found in the tool window located at the bottom of the screen. This section of
    the screen collapses, but the tool window selector is always available at the
    bottom of the sidebar, as seen in *Figure 5**.4*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个允许可视化分支和提交历史。这可以在屏幕底部的工具窗口中找到。屏幕的这一部分可以折叠，但工具窗口选择器始终在侧边栏的底部可用，如*图5.4*所示。
- en: '![Figure 5.4: Clicking the Git tool window will open a window that shows you
    the commit history, along with all the branches](img/B19644_05_04.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4：点击Git工具窗口将打开一个窗口，显示提交历史，以及所有分支](img/B19644_05_04.jpg)'
- en: 'Figure 5.4: Clicking the Git tool window will open a window that shows you
    the commit history, along with all the branches'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：点击Git工具窗口将打开一个窗口，显示提交历史，以及所有分支
- en: The fourth is on the top toolbar next to the main menu. This area shows you
    the branch you are currently working on and allows easy branch management. You
    can see this in *Figure 5**.5*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个位于主菜单旁边的顶部工具栏上。这个区域显示你当前正在工作的分支，并允许轻松管理分支。你可以在 *图 5*.* 中看到这一点。
- en: '![Figure 5.5: The current branch is displayed near the main menu. Clicking
    here allows you access to a few commands](img/B19644_05_05.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5：当前分支显示在主菜单附近。点击此处可以访问一些命令](img/B19644_05_05.jpg)'
- en: 'Figure 5.5: The current branch is displayed near the main menu. Clicking here
    allows you access to a few commands'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5：当前分支显示在主菜单附近。点击此处可以访问一些命令。
- en: The fifth is the VCS operations popup, as shown in *Figure 5**.6*. This has
    been around for quite a while and I would consider it legacy even though it’s
    still there. You can get to the popup using *Ctrl* + *`*. Please note that isn’t
    a quotation mark. The `` ` `` key, called the gravure mark, is located to the
    left of the *1* (one) key on the US keyboard layout.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第五个是 VCS 操作弹出窗口，如图 *图 5*.* 所示。这已经存在一段时间了，尽管它还在那里，但我认为它已经过时了。你可以使用 *Ctrl* + *`*
    来访问弹出窗口。请注意，这不是引号。`` ` `` 键，称为压痕标记，位于美国键盘布局中 *1*（一个）键的左侧。
- en: '![Figure 5.6: The VCS operations pop-up window is activated with Ctrl/Cmd +
    `.](img/B19644_05_06.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6：使用 Ctrl/Cmd + `. 激活 VCS 操作弹出窗口。](img/B19644_05_06.jpg)'
- en: 'Figure 5.6: The VCS operations pop-up window is activated with Ctrl/Cmd + `.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：使用 Ctrl/Cmd + ` 激活 VCS 操作弹出窗口。
- en: Finally, you can right-click the editor window or a tab in the editor window
    to access the same Git menu found in the main menu, as shown in *Figure 5**.7*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以在编辑器窗口或编辑器窗口中的标签上右键单击以访问主菜单中找到的相同 Git 菜单，如图 *图 5*.* 所示。
- en: '![Figure 5.7: You can right-click in the editor window or on a tab to see the
    Git menu](img/B19644_05_07.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7：你可以在编辑器窗口或标签上右键单击以查看 Git 菜单](img/B19644_05_07.jpg)'
- en: 'Figure 5.7: You can right-click in the editor window or on a tab to see the
    Git menu'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：你可以在编辑器窗口或标签上右键单击以查看 Git 菜单。
- en: As you can see, tooling for revision control is neatly woven into the IDE in
    an organized and intelligent fashion. Since we opened a folder that already had
    a Git repository in place, PyCharm simply recognizes that fact and presents the
    interface. When you open a folder or create a project without a GitHub repo, most
    of the tooling will still be visible, but it won’t be Git specific. Since PyCharm
    supports many VCSs, a project that hasn’t been initialized using Git or any other
    VCS will present generic tooling until such initialization is complete.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，修订控制工具已经以有组织和智能的方式巧妙地编织到 IDE 中。由于我们打开了一个已经包含 Git 仓库的文件夹，PyCharm 简单地识别这一事实并呈现界面。当你打开一个文件夹或创建一个没有
    GitHub 仓库的项目时，大部分工具仍然可见，但它不会是 Git 特定的。由于 PyCharm 支持许多 VCS，尚未使用 Git 或任何其他 VCS 初始化的项目将呈现通用的工具，直到初始化完成。
- en: Creating a new project from scratch using VCS tooling in PyCharm
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PyCharm 中的 VCS 工具从头创建新项目。
- en: Let’s make a new project. The code for this project is in the repo for the book,
    but you don’t really want to just open that copy because it will already be associated
    with a repository, and you won’t see everything I’m about to show you. For this
    exercise, you should create a new project from scratch as I am about to do.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的项目。这个项目的代码在书的仓库中，但你真的不想只打开那个副本，因为它已经与一个仓库相关联，你将看不到我即将展示的所有内容。为此练习，你应该从头开始创建一个新的项目，就像我即将做的那样。
- en: Click the hamburger icon in the top-left corner of the application to activate
    the main menu, then click `project_git_demo`. I’ll leave everything else as default.
    You can see my project creation dialog in *Figure 5**.8*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 点击应用程序左上角的三明治图标以激活主菜单，然后点击 `project_git_demo`。我将保留其他所有默认设置。你可以在 *图 5*.* 中看到我的项目创建对话框。
- en: '![Figure 5.8: My demo project settings](img/B19644_05_08.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8：我的演示项目设置](img/B19644_05_08.jpg)'
- en: 'Figure 5.8: My demo project settings'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8：我的演示项目设置。
- en: We now have a project with which we can work.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以工作的项目。
- en: Initializing the local Git repository
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化本地 Git 仓库。
- en: After my project has been created, I need to initialize a Git repository. Manually,
    we did this with the `git init` command. In PyCharm, we can use the main menu’s
    **VCS** option. Right now, it says **VCS** because we haven’t initialized a repository
    with any VCS yet, so the terminology in the UI is generic. As you can see in *Figure
    5**.9*, we have options for revision control in Mercurial, Git, GitHub, Perforce,
    and Subversion. There is a new option for sharing a project on JetBrains’ new
    collaboration product called **Space**, which contains a Git hosting service.
    Naturally, as the Space product grows, you can expect to see more and more integration
    appear in all the IDEs. I’m going to click **Create Git Repository…**, as shown
    in *Figure 5**.9*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的项目创建后，我需要初始化一个 Git 仓库。手动操作时，我们使用 `git init` 命令来完成。在 PyCharm 中，我们可以使用主菜单的
    **VCS** 选项。目前，它显示为 **VCS**，因为我们还没有使用任何 VCS 初始化仓库，所以 UI 中的术语是通用的。如 *图 5.9* 所示，我们有
    Mercurial、Git、GitHub、Perforce 和 Subversion 的版本控制选项。还有一个新的选项，用于在 JetBrains 的新协作产品
    Space 中共享项目，Space 包含 Git 托管服务。随着 Space 产品的不断发展，您可以在所有 IDE 中期待看到越来越多的集成。我将点击 *图
    5.9* 中所示的 **创建 Git 仓库…**。
- en: '![Figure 5.9: Creating a Git repository from the PyCharm VCS menu](img/B19644_05_09.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9：从 PyCharm VCS 菜单创建 Git 仓库](img/B19644_05_09.jpg)'
- en: 'Figure 5.9: Creating a Git repository from the PyCharm VCS menu'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9：从 PyCharm VCS 菜单创建 Git 仓库
- en: As you can see in *Figure 5**.10*, you are next prompted to select the folder
    where you’d like to create the repository. It defaults to the current folder,
    which is correct.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 5.10* 所示，您接下来会被提示选择您想要创建仓库的文件夹。默认情况下是当前文件夹，这是正确的。
- en: '![Figure 5.10: Select the folder where you’d like to create the Git repository](img/B19644_05_10.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10：选择您想要创建 Git 仓库的文件夹](img/B19644_05_10.jpg)'
- en: 'Figure 5.10: Select the folder where you’d like to create the Git repository'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10：选择您想要创建 Git 仓库的文件夹
- en: Clicking the **OK** button creates the repository in the selected folder. You
    can verify that it worked by checking whether the default branch (master) appears
    in the top toolbar with a dropdown that contains a few Git operations. Now that
    we have initialized a Git repository, the menus no longer use the term **VCS**
    but instead list options specifically for Git.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **确定** 按钮将在所选文件夹中创建仓库。您可以通过检查默认分支（master）是否出现在顶部工具栏的下拉菜单中，其中包含一些 Git 操作来验证是否成功。现在我们已经初始化了一个
    Git 仓库，菜单不再使用 **VCS** 这个术语，而是列出专门针对 Git 的选项。
- en: Adding a remote on GitHub
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 GitHub 上添加远程仓库
- en: There isn’t tooling in PyCharm for creating a remote. You need to log in to
    GitHub and create a repository just as you did earlier. *Figure 5**.11* shows
    me setting up the remote repository in my personal account. Note this is distinct
    from the book’s repository, which is meant to house all the code in the book rather
    than serve as a demonstration of creating a repository.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 中没有创建远程仓库的工具。您需要登录到 GitHub，并像之前一样创建一个仓库。*图 5.11* 展示了我在我个人账户中设置远程仓库的过程。请注意，这与书中仓库是不同的，书中仓库的目的是存放所有代码，而不是作为创建仓库的演示。
- en: '![Figure 5.11: The settings for my remote](img/B19644_05_11.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11：我的远程设置](img/B19644_05_11.jpg)'
- en: 'Figure 5.11: The settings for my remote'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11：我的远程设置
- en: Note that only the bare minimum is set. No `.gitignore` file, no README file,
    and so on. I’m going to add all those in PyCharm. When I click the **Create repository**
    button, GitHub generates the URL I need for adding the remote. I’ve pointed this
    out in *Figure 5**.12*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里只设置了最基本的内容。没有 `.gitignore` 文件，没有 README 文件等等。我将在 PyCharm 中添加所有这些。当我点击 **创建仓库**
    按钮时，GitHub 会生成我需要用于添加远程仓库的 URL。我在 *图 5.12* 中指出了这一点。
- en: '![Figure 5.12: You need the URL for the remote in order to add it to your local
    repository](img/B19644_05_12.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12：您需要远程仓库的 URL 才能将其添加到本地仓库](img/B19644_05_12.jpg)'
- en: 'Figure 5.12: You need the URL for the remote in order to add it to your local
    repository'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12：您需要远程仓库的 URL 才能将其添加到本地仓库
- en: Next, switch back to PyCharm and find the **git** menu within the main menu.
    Remember, a minute ago, the menu said **VCS** because we had not defined a repository,
    but now it says **git**.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，切换回 PyCharm 并在主菜单中找到 **git** 菜单。记住，一分钟前，菜单显示为 **VCS**，因为我们还没有定义仓库，但现在它显示为
    **git**。
- en: Within the **git** menu, you’ll find an option called **Manage Remotes**. Click
    that and you’ll see a modal dialog, shown in *Figure 5**.13*, which allows you
    to add the remote you just created on GitHub.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **git** 菜单中，您会找到一个名为 **管理远程** 的选项。点击它，您将看到一个模态对话框，如 *图 5.13* 所示，它允许您添加您刚刚在
    GitHub 上创建的远程。
- en: '![Figure 5.13: The Git Remotes dialog allows you to add the remote you created
    on GitHub](img/B19644_05_13.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.13：Git 远程对话框允许您添加您在 GitHub 上创建的远程](img/B19644_05_13.jpg)'
- en: 'Figure 5.13: The Git Remotes dialog allows you to add the remote you created
    on GitHub'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13：Git 远程对话框允许您添加您在 GitHub 上创建的远程
- en: Click the **+** button to add a remote. You get yet another dialog on top of
    this one, as seen in *Figure 5**.14*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **+** 按钮添加远程。您会在上面再看到一个对话框，如 *图 5.14* 所示。
- en: '![Figure 5.14: Add the URL you copied from the GitHub page](img/B19644_05_14.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.14：添加您从 GitHub 页面复制的 URL](img/B19644_05_14.jpg)'
- en: 'Figure 5.14: Add the URL you copied from the GitHub page'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14：添加您从 GitHub 页面复制的 URL
- en: Click `main.py` file is red.. You’ll just have to trust me. It’s red because
    it is an untracked file. We need to add our files to our repository so we can
    track them.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 `main.py` 文件是红色的。您只需相信我。它是红色的，因为它是一个未跟踪的文件。我们需要将我们的文件添加到我们的仓库中，这样我们就可以跟踪它们。
- en: Adding project files
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加项目文件
- en: Setting up the project and the remote is something you generally only do once
    for the duration of the project. If you’re joining an existing team, it may have
    been done long before you joined. This next set of actions, though, is something
    you’ll work with every day.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 设置项目和远程通常只在项目期间进行一次。如果您是加入一个现有的团队，它可能是在您加入之前很久就完成了。然而，接下来的这一系列操作是您将每天都会使用的。
- en: When you are working with changes you’ve made to the project, you’ll find the
    **Commit** window very useful. Refer back to *Figure 5**.3* if you have forgotten
    how to locate the **Commit** window.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当您正在处理对项目的更改时，您会发现 **提交** 窗口非常有用。如果您忘记了如何定位 **提交** 窗口，请参考 *图 5.3*。
- en: Adding a .gitignore file
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 .gitignore 文件
- en: 'If you’re not familiar, a `.gitignore` file defines files and folders you don’t
    want to include in your repository. As a general rule, anything that can be generated
    from your code doesn’t need to be in your repository. When working with Python
    projects, a short list of things you don’t want in your repo might include the
    following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉，`.gitignore` 文件定义了您不想包含在您的仓库中的文件和文件夹。作为一个一般规则，任何可以从您的代码生成的文件都不需要包含在您的仓库中。当与
    Python 项目一起工作时，您不想在您的仓库中的东西可能包括以下列表：
- en: The `venv` folder since this is generated by running `pip`
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`venv` 文件夹，因为这个文件夹是通过运行 `pip` 生成的'
- en: Python cache folders (you’ll see them as `__pycache__` folders)
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 缓存文件夹（您会看到它们作为 `__pycache__` 文件夹）
- en: Byte-compiled DLL files
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字节编译的 DLL 文件
- en: C extensions
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C 扩展
- en: Build files from distribution and packaging
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从发行和打包中构建文件
- en: PyInstaller manifests
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyInstaller 清单
- en: Application log files
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序日志文件
- en: Test coverage reports
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试覆盖率报告
- en: This is by no means an exhaustive list. The list will really depend on what
    kind of application you are building and exactly what gets generated during a
    run of your project. There are plenty of suggestions on the contents of a `.gitignore`
    file. GitHub has such a list in a gist. You can get this file at [https://githubgitm/github/gigitnore/blgitmain/Python.gitignore](https://githubgitm/github/gigitnore/blgitmain/Python.gitignore).
    It is also the `.gitignore` file in the book’s Git repository. You can use this
    `.gitignore` file if you’d like, but to keep this short and easy, I’m just going
    to include a few entries in a `.gitignore` file we will create.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对不是一份详尽的列表。列表将真正取决于您正在构建的应用程序类型以及项目运行期间确切生成的内容。关于 `.gitignore` 文件的内容有很多建议。GitHub
    在一个 gist 中有一个这样的列表。您可以在 [https://githubgitm/github/gigitnore/blgitmain/Python.gitignore](https://githubgitm/github/gigitnore/blgitmain/Python.gitignore)
    获取此文件。它也是本书 Git 仓库中的 `.gitignore` 文件。如果您愿意，可以使用这个 `.gitignore` 文件，但为了保持简短和简单，我只是在我们将要创建的
    `.gitignore` 文件中包含了一些条目。
- en: Switch back to the file view, as shown in *Figure 5**.15*. You do this by clicking
    the folder icon (`project_git_demo` project title (`.gitignore`. No creativity
    is allowed here. It must be called `.gitignore`, all lowercase.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回文件视图，如 *图 5.15* 所示。您可以通过点击文件夹图标（`project_git_demo` 项目标题（`.gitignore`。这里不允许有创意。它必须称为
    `.gitignore`，全部小写。
- en: '![Figure 5.15: Switch back to the file view and create a new file called .gitignore](img/B19644_05_15.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.15：切换回文件视图并创建一个名为 .gitignore 的新文件](img/B19644_05_15.jpg)'
- en: 'Figure 5.15: Switch back to the file view and create a new file called .gitignore'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15：切换回文件视图，创建一个名为 .gitignore 的新文件
- en: When you create the new file, PyCharm will prompt you to add the file to Git,
    as shown in *Figure 5**.16*. If you want to add new files to become the default,
    you can click the **Don’t ask again** checkbox and all files you create will be
    added to GitHub automatically.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建新文件时，PyCharm 会提示你将文件添加到 Git，如图 *图 5**.16* 所示。如果你想将新文件添加为默认，你可以点击 **不再询问**
    复选框，你创建的所有文件都将自动添加到 GitHub。
- en: '![Figure 5.16: Each time you create a file in PyCharm, you are prompted to
    add it to the repository](img/B19644_05_16.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.16：每次你在 PyCharm 中创建文件时，都会提示你将其添加到存储库](img/B19644_05_16.jpg)'
- en: 'Figure 5.16: Each time you create a file in PyCharm, you are prompted to add
    it to the repository'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16：每次你在 PyCharm 中创建文件时，都会提示你将其添加到存储库
- en: 'Regardless of what you do with the checkbox, click the `.gitignore` file shows
    green in the project explorer since it was added and nothing has yet changed.
    Within the `.gitignore` file, add these lines:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你对复选框做什么，`.gitignore` 文件在项目资源管理器中显示为绿色，因为它已被添加，而且还没有任何变化。在 `.gitignore` 文件中，添加以下行：
- en: '[PRE21]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will exclude the entire `venv` folder and any cache folders generated by
    Python. PyCharm saves your files as we go, so let’s add this file and the `main.py`
    file to the repository. Switch to the **Commit** window and you’ll see something
    like *Figure 5**.17*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这将排除整个 `venv` 文件夹和 Python 生成的任何缓存文件夹。PyCharm 在我们保存文件时保存文件，所以让我们将这个文件和 `main.py`
    文件添加到存储库中。切换到 **提交** 窗口，你会看到类似 *图 5**.17* 的内容。
- en: '![Figure 5.17: The commit window after we’ve added our .gitignore file](img/B19644_5_17.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.17：添加我们的 .gitignore 文件后的提交窗口](img/B19644_5_17.jpg)'
- en: 'Figure 5.17: The commit window after we’ve added our .gitignore file'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17：添加我们的 .gitignore 文件后的提交窗口
- en: Wow! Where did all that come from? We just added one file! As you can see, the
    `.gitignore` file was added in response to the dialog we saw when we created the
    file. The only other code file in the project is the `main.py` file generated
    by PyCharm when we created the project. What about the rest? Why is there a second
    `.gitignore` file listed in the unversioned files list?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这一切都是从哪里来的？我们只是添加了一个文件！正如你所见，`.gitignore` 文件是在我们创建文件时看到的对话框的响应下添加的。项目中唯一的其他代码文件是我们创建项目时
    PyCharm 生成的 `main.py` 文件。那么其他文件呢？为什么在未版本化的文件列表中列出了第二个 `.gitignore` 文件？
- en: 'These all come from the `.idea` folder created by PyCharm. There is some debate
    on whether this folder belongs in source control. JetBrains has a page in their
    documentation at [https://intellij-support.jetbrains.com/hc/en-us/articles/206544839](https://intellij-support.jetbrains.com/hc/en-us/articles/206544839)
    discussing their ideas on the subject. To sum up the article, JetBrains recommends
    storing the contents of the `.idea` folder pertaining to the project, but not
    any files that contain user-specific settings, which are the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都来自 PyCharm 创建的 `.idea` 文件夹。关于这个文件夹是否应该归入源控制，有一些争议。JetBrains 在他们的文档中有一个页面，讨论了他们对这个问题的看法。[https://intellij-support.jetbrains.com/hc/en-us/articles/206544839](https://intellij-support.jetbrains.com/hc/en-us/articles/206544839)。总结本文，JetBrains
    建议存储与项目相关的 `.idea` 文件夹内容，但不包括包含用户特定设置的任何文件，以下是一些例子：
- en: '`workspace.xml`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`workspace.xml`'
- en: '`usage.statistics.xml`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usage.statistics.xml`'
- en: Anything in the `shelf` directory
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shelf` 目录中的任何内容'
- en: 'The article is meant to cover all `.gitignore` file. We haven’t committed anything
    yet, so add these lines to your `.``gitignore` file:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 本文旨在涵盖所有 `.gitignore` 文件。我们还没有提交任何内容，所以将这些行添加到你的 `.gitignore` 文件中：
- en: '[PRE22]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let’s check all the boxes to get all those files added, as shown in *Figure
    5**.18*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查所有复选框，以便添加所有这些文件，如图 *图 5**.18* 所示。
- en: '![Figure 5.18: Everything is added and we’re ready to commit](img/B19644_05_18.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.18：所有文件都已添加，我们准备提交](img/B19644_05_18.jpg)'
- en: 'Figure 5.18: Everything is added and we’re ready to commit'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18：所有文件都已添加，我们准备提交
- en: Add a commit message in the box. You can click the **Commit** button to commit
    to your local repository or **Commit and Push…** to send the changes straight
    to GitHub. As a general rule, you should not use the **Commit and Push…** button
    unless you are completely certain that no one could have pushed changes since
    the last push. It is probably safe because we have never pushed; however, I’m
    going to hit the **Commit** button to demonstrate the whole process laid out earlier.
    You add your changes, commit, pull, and then push. So far, we’ve added our changes,
    and now we’re committing.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在框中添加提交信息。你可以点击**提交**按钮将更改提交到本地仓库，或者点击**提交并推送…**将更改直接发送到 GitHub。一般来说，除非你完全确定自上次推送以来没有人推送过更改，否则不应使用**提交并推送…**按钮。由于我们从未推送过，所以这可能是安全的；然而，我将点击**提交**按钮来演示之前安排好的整个过程。你添加更改，提交，拉取，然后推送。到目前为止，我们已经添加了更改，现在正在提交。
- en: If all goes well, a toast will appear in the lower-right corner of your screen
    stating that your files were successfully committed. If you didn’t set your global
    username and email address during the manual exercise, you will be prompted via
    a dialog to set them up.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，屏幕右下角会出现一个提示，说明你的文件已成功提交。如果你在手动练习期间没有设置全局用户名和电子邮件地址，系统将通过对话框提示你设置它们。
- en: Pulling and pushing
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拉取和推送
- en: 'Now that the first commit is out of the way, we are set to do the last half
    of the process. We always pull before pushing to ensure we have the latest revision
    on the current branch. This allows us a chance to resolve any conflicts that might
    have arisen since our last pull. In Git, the command we used was `pull`. There
    is a `pull` option in the Git tools, but before we go there, I will point out
    another option: **Update Project…**. This is found in the dropdown in the toolbar
    denoted by the current branch, as shown in *Figure 5**.19*.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在第一个提交已经完成，我们可以进行过程的最后半部分。我们总是在推送之前拉取，以确保我们在当前分支上有最新的修订版。这给了我们机会解决自上次拉取以来可能出现的任何冲突。在
    Git 中，我们使用的命令是`pull`。Git 工具中有一个`pull`选项，但在我们前往那里之前，我要指出另一个选项：**更新项目…**。这可以在工具栏的当前分支下拉菜单中找到，如*图
    5.19*所示。
- en: '![Figure 5.19: The Update Project… command isn’t really a Git command. It refers
    to an update strategy](img/B19644_05_19.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.19："更新项目… "命令实际上不是一个 Git 命令。它指的是一个更新策略](img/B19644_05_19.jpg)'
- en: 'Figure 5.19: The Update Project… command isn’t really a Git command. It refers
    to an update strategy'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.19："更新项目… "命令实际上不是一个 Git 命令。它指的是一个更新策略
- en: When you click **Update Project…**, you’ll be asked to set your preference for
    updating your local Git repository. There are two possibilities depicted in the
    ensuing dialog box, as shown in *Figure 5**.20*.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击**更新项目…**时，系统会要求你设置更新本地 Git 仓库的首选项。接下来的对话框中展示了两种可能性，如*图 5.20*所示。
- en: '![Figure 5.20: There are two update strategies from which to choose](img/B19644_05_20.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.20：你可以从两种更新策略中选择](img/B19644_05_20.jpg)'
- en: 'Figure 5.20: There are two update strategies from which to choose'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.20：你可以从两种更新策略中选择
- en: The `git pull` command we executed earlier embodies the first option. The pull
    operation will *fetch* any changes from the remote and automatically *merge* those
    changes into our local copy. The `rebase` operation is a different strategy. It
    changes the structure of your repository in order to show a cleaner timeline of
    changes. I won’t get into the arguments of which strategy to use, but I will include
    a link in the *Further reading* section of this chapter should you desire to dive
    deeper.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前执行的`git pull`命令体现了第一种选项。拉取操作将从远程获取任何更改，并自动将这些更改合并到我们的本地副本中。`rebase`操作是一种不同的策略。它改变仓库的结构，以显示更清晰的更改时间线。我不会深入讨论使用哪种策略的争论，但如果你想要深入了解，我将在本章的*进一步阅读*部分包含一个链接。
- en: Personally, I prefer the first option since it is simpler and safer. I only
    have to click the **OK** button. I can click the **Don’t show again** checkbox
    if I do not want to be prompted before use. PyCharm will forevermore use the selection
    I make here and now.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我更喜欢第一种选项，因为它更简单、更安全。我只需点击**确定**按钮。如果我不想在使用前被提示，可以点击**不再显示**复选框。PyCharm
    将永远使用我现在做出的选择。
- en: If you have problems with commitment, I don’t mean generally, but technically,
    when it comes to executing `git commit`, you can skip this dialog entirely. Just
    use the **Pull…** menu item on the Git menu, as shown in *Figure 5**.21*.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在提交方面遇到问题，我并不是指一般意义上的，而是指在执行 `git commit` 时，您完全可以跳过这个对话框。只需使用 Git 菜单上的 **“拉取...”**
    菜单项，如图 *图 5**.21* 所示。
- en: '![Figure 5.21: You can do a traditional Git pull from any of the Git menus](img/B19644_05_21.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.21：您可以从任何 Git 菜单中执行传统的 Git pull 操作](img/B19644_05_21.jpg)'
- en: 'Figure 5.21: You can do a traditional Git pull from any of the Git menus'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.21：您可以从任何 Git 菜单中执行传统的 Git pull 操作
- en: There is nothing left to do but push. Perhaps the quickest way was shown previously
    in *Figure 5**.19*, where we encountered the **Update** **Project…** command.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 除了推送之外，没有其他事情可做。也许之前在 *图 5**.19* 中展示的快速方法已经显示了，在那里我们遇到了 **“更新项目...”** 命令。
- en: Branching and merging
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分支和合并
- en: We have discussed the most basic functions of any VCS, which protects the project’s
    code by tracking revisions over time. A second set of very important functions
    entails segregating the project work into several copies. This practice is called
    **branching**. There are many benefits to branching; I can’t cover them all here.
    If you’d like more details on version control with Git, check out the Packt book
    *Git for Programmers* listed in the *Further reading* section of this chapter.
    However, I’ll offer what I consider to be the most important benefits.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了任何版本控制系统最基本的功能，这些功能通过跟踪随时间推移的修订版来保护项目的代码。另一组非常重要的功能包括将项目工作分割成几个副本。这种做法被称为
    **“分支”**。分支有许多好处；我无法在这里全部涵盖。如果您想了解更多关于 Git 的版本控制细节，请参阅本章 *“进一步阅读”* 部分中列出的 Packt
    书籍 *《程序员 Git》*。然而，我将提供我认为最重要的好处。
- en: Consider a typical web start-up that goes through a cycle of creating a repository
    and iterating development to its first release. The release is sitting on a production
    server somewhere in the cloud and customers have started using the app. The start-up
    company not only wants to enhance their offering with additional features, but
    they will also encounter bugs and problems that must be fixed. Let’s pretend the
    development and quality assurance teams did such an amazing job that there are
    virtually no bugs in the release. Pleased with themselves, the company wants to
    start adding new features. All work is being done in the main branch because that
    is the only one that exists. In order to add a new feature, we need to change
    something deep within the code. The moment you start the change, you need a week
    to finish it, and during that time, the development version of the product is
    very unstable.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个典型的网络初创公司，它经历了一个从创建仓库到迭代开发至首次发布的周期。该发布版本位于云中的某个生产服务器上，并且客户已经开始使用该应用程序。初创公司不仅希望通过添加额外功能来增强其产品，而且还会遇到需要修复的bug和问题。让我们假设开发和质量保证团队的工作非常出色，以至于发布版本中几乎没有任何bug。公司对自己感到满意，想要开始添加新功能。所有工作都在主分支上进行，因为这是唯一存在的分支。为了添加新功能，我们需要在代码深处进行一些更改。一旦开始更改，可能需要一周时间才能完成，在这段时间里，产品的开发版本非常不稳定。
- en: All of a sudden, reality sets in. It is nigh impossible to have a software release
    with no bugs, unless, of course, the software was written by unicorns or Chuck
    Norris. Let’s say it’s not just a bug. It’s a bad bug. Something like someone
    forgot a `WHERE customer_id=@customerId` on a SQL statement and your app erroneously
    displays all customer data to all customers. That’s a career-ender! I’ve seen
    it happen and it isn’t pretty. You need to fix it *immediately*! Except you can’t
    without backing out all those changes you’ve made that might render the app unstable.
    That is one option. Another option is that you could revert to the code you released,
    then implement the fix and save your career. You would then spend a lot of time
    trying to cherry-pick the commits to salvage your feature work. You could also
    elect to write all of your code in Notepad using a keyboard set to the Dvorak
    layout with totally blank keys. You could do it, but it wouldn’t be a productive
    use of your time.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 突然，现实降临。除非软件是由独角兽或Chuck Norris编写的，否则几乎不可能有一个没有错误的软件发布。让我们假设这不仅仅是一个错误。这是一个严重的错误。比如有人忘记在
    SQL 语句中添加 `WHERE customer_id=@customerId`，您的应用程序错误地向所有客户显示所有客户数据。这是一个职业生涯的终结！我见过这种情况，它并不好看。您需要立即修复它！但是，如果没有撤销可能使应用程序不稳定的所有更改，您就无法修复。这是一个选择。另一个选择是，您可以回滚到您发布的代码，然后实施修复并保住您的职业生涯。然后，您将花费大量时间尝试挑选提交以挽救您的功能工作。您还可以选择使用
    Dvorak 布局和完全空白的键盘在记事本中编写所有代码。您可以做到，但这不会是您时间的高效利用。
- en: This is where branching comes into play. The start-up can do all its work on
    the main branch. They shouldn’t, but let’s keep the story constrained to what
    we have so far. Once the software is released, they could make a new branch and
    maybe call it *development-branch*. The name isn’t important. The branching operation
    creates a copy of what was released. It is in that branch that our intrepid development
    team starts to make changes that might have rendered the development version unstable.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是分支发挥作用的地方。启动阶段可以在主分支上完成所有工作。他们不应该这样做，但让我们将故事限制在我们目前所拥有的内容。一旦软件发布，他们可以创建一个新的分支，也许会称之为
    *development-branch*。名称并不重要。分支操作创建了已发布内容的副本。正是在这个分支上，我们勇敢的开发团队开始进行可能使开发版本不稳定的变化。
- en: Boom! The bad thing happens. You can switch from *development-branch* back to
    *main*. You now have the code that was released, and you can fix the problem.
    After the fix is in place, you can merge the fix into your development branch
    and continue working on your unstable app in *development-branch*. Keeping the
    work segregated allows you to work on new features independently of emergency
    bug fixes.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 咔嚓！坏事情发生了。您可以从 *development-branch* 切换回 *main*。现在您有了发布时的代码，您可以修复问题。修复到位后，您可以将修复合并到您的开发分支，并在
    *development-branch* 上继续工作不稳定的应用程序。保持工作分离，让您可以独立于紧急错误修复工作在新功能上工作。
- en: I am grossly over-simplifying the typical branching strategy used by most teams
    in this illustration. I would prefer to leave coverage of that topic to works
    dedicated to version control. I’ll leave suggestions for further reading on branching
    strategies in the *Further reading* section of this chapter. Let’s continue with
    the mechanics of working with branches. They are vital to your daily practice
    of software development.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我在图中过分简化了大多数团队使用的典型分支策略。我更愿意将这一主题的覆盖留给专门针对版本控制的著作。我将在本章的 *进一步阅读* 部分留下关于分支策略的建议。让我们继续讨论与分支一起工作的机制。这对您日常的软件开发实践至关重要。
- en: Creating a branch
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建分支
- en: Creating a new branch is very easy. Click the branch menu on the top menu bar
    and click **New Branch**. You’ll see the dialog shown in *Figure 5**.22*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的分支非常简单。点击顶部菜单栏上的分支菜单，然后点击 **新分支**。您将看到 *图 5.22* 中所示的对话框。
- en: '![Figure 5.22: The Create New Branch dialog allows you to create a new Git
    branch](img/B19644_05_22.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.22：创建新分支对话框允许您创建一个新的 Git 分支](img/B19644_05_22.jpg)'
- en: 'Figure 5.22: The Create New Branch dialog allows you to create a new Git branch'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.22：创建新分支对话框允许您创建一个新的 Git 分支
- en: Type a name for your new branch. The branch is created locally, and you are
    automatically switched to the new branch.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的新分支输入一个名称。分支在本地创建，并且您将自动切换到新分支。
- en: Switching between branches
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在分支之间切换
- en: This is also very easy. Go back to the branch menu. The local branches are listed
    in the branch dropdown, as shown in *Figure 5**.23*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这也很简单。回到分支菜单。本地分支列在分支下拉菜单中，如图 *图 5.23* 所示。
- en: '![Figure 5.23: Local branches are listed in the branch menu](img/B19644_05_23.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.23：本地分支列在分支菜单中](img/B19644_05_23.jpg)'
- en: 'Figure 5.23: Local branches are listed in the branch menu'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.23：本地分支列在分支菜单中
- en: Switching to a different branch is just a matter of clicking the desired branch
    from the list and then clicking **Checkout**. As you can see, there are other
    operations you can perform on the branch.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到不同的分支只需从列表中选择所需的分支，然后点击 **检出**。如您所见，您还可以在分支上执行其他操作。
- en: Merging
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并
- en: When you’re ready to merge a branch back into main, or any other branch for
    that matter, simply switch to that branch, then use the **Merge** command in the
    branch menu, as shown in *Figure 5**.24*.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当您准备好将分支合并回主分支或其他任何分支时，只需切换到该分支，然后在分支菜单中使用 **合并** 命令，如图 *图 5**.24* 所示。
- en: '![Figure 5.24: The Merge command can be found in the branch menu](img/B19644_05_24.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.24：合并命令可以在分支菜单中找到](img/B19644_05_24.jpg)'
- en: 'Figure 5.24: The Merge command can be found in the branch menu'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.24：合并命令可以在分支菜单中找到
- en: The **Merge** dialog, shown in *Figure 5**.24*, will allow you to select the
    branch you’d like to merge into the currently selected branch.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 5**.24* 所示的 **合并** 对话框，将允许您选择要合并到当前选中分支的分支。
- en: If you need something more exotic than the standard merge operation, there is
    a **Modify options** dropdown, which allows you to do the equivalent of several
    command-line switches normally employed during the manual merge process.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要比标准合并操作更复杂的功能，有一个 **修改选项** 下拉菜单，允许您执行在手动合并过程中通常使用的几个命令行开关的等效操作。
- en: Viewing the branch diagram
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看分支图
- en: The Git tool in the tool window provides a graphical view of the various branches
    in your repository. You can see it in *Figure 5**.25*. This can be useful when
    you need to review what has recently changed in the repository. It’s the kind
    of thing you might do first thing in the morning so you can review your team’s
    changes in the last 24 hours.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 工具窗口中的 Git 工具提供了您仓库中各种分支的图形视图。您可以在 *图 5**.25* 中看到它。当您需要查看仓库中最近发生了什么更改时，这可能很有用。这是您可能早上第一件事就会做的事情，以便您可以审查过去
    24 小时内团队所做的更改。
- en: '![Figure 5.25: The Git tool can be activated by clicking on the toolbar on
    the lower-left edge of the PyCharm window](img/B19644_05_25.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.25：通过点击 PyCharm 窗口左下角的工具栏可以激活 Git 工具](img/B19644_05_25.jpg)'
- en: 'Figure 5.25: The Git tool can be activated by clicking on the toolbar on the
    lower-left edge of the PyCharm window'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.25：通过点击 PyCharm 窗口左下角的工具栏可以激活 Git 工具
- en: To activate it, click the Git icon in the tool window (**1**). You can search
    the revision history and filter it using the various tools on the toolbar (**2**).
    Selecting a commit (**3**) allows you to see the details of that commit (**4**)
    along with the commit message.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活它，请点击工具窗口中的 Git 图标（**1**）。您可以使用工具栏上的各种工具搜索修订历史记录并对其进行过滤（**2**）。选择一个提交（**3**）允许您查看该提交的详细信息（**4**）以及提交信息。
- en: Diffs and conflict resolution
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 差异和冲突解决
- en: Sooner or later, you’re going to perform a pull prior to pushing some changes
    only to discover a conflict exists. This can be intimidating and stressful even
    for experienced developers because you are running the risk of breaking someone
    else’s recent contribution. Nevertheless, it happens and you need a way to deal
    with the problem. This leads us to one of my favorite features in PyCharm. In
    [*Chapter 1*](B19644_01.xhtml#_idTextAnchor014), *Introduction to PyCharm – the
    Most Popular IDE for Python*, I told you about my experience with Microsoft’s
    debugger. Having experienced it early in my career, to me, nothing else will do.
    I have the same regard for PyCharm’s merge tool. Resolving a conflicted merge
    in anything else feels painful.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 总有一天，您在推送更改之前执行拉取操作，会发现存在冲突。即使对于经验丰富的开发者来说，这也可能令人畏惧和压力重重，因为您冒着破坏他人最近贡献的风险。尽管如此，这种情况总会发生，您需要一种处理问题的方法。这让我们想到了
    PyCharm 中我最喜欢的功能之一。在 [*第 1 章*](B19644_01.xhtml#_idTextAnchor014)，“PyCharm 简介——最受欢迎的
    Python IDE”，我向您讲述了我在微软调试器方面的经验。在我职业生涯的早期就体验过它，对我来说，其他任何东西都无法替代。我对 PyCharm 的合并工具也有同样的敬意。在其他任何地方解决冲突合并都感觉痛苦。
- en: 'There is only one file in the project. By now, you’ll recognize it as the `main.py`
    file PyCharm generates with new projects. We’re going to generate a conflict using
    the following steps:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 项目中只有一个文件。到现在为止，您会认出它是 PyCharm 为新项目生成的 `main.py` 文件。我们将通过以下步骤生成冲突：
- en: Create a new project in PyCharm.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PyCharm 中创建一个新的项目。
- en: Change the contents of the `main.py` file to a single line of code to ensure
    we generate a conflict.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `main.py` 文件的内容更改为单行代码以确保我们生成冲突。
- en: Initialize a Git repository in the project folder.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件夹中初始化 Git 仓库。
- en: Add and commit all project files.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加并提交所有项目文件。
- en: Create a new branch called *development*.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 *development* 的新分支。
- en: Change the line of code that renders the *Hello* *World* message.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改显示 *Hello* *World* 消息的代码行。
- en: Commit the change to the branch.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将更改提交到分支。
- en: Switch back to the main branch.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换回主分支。
- en: Make a different change to the one line of code.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对这一行代码进行不同的更改。
- en: Commit the change.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交更改。
- en: Now try to merge the development branch into the main branch.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试将 development 分支合并到主分支。
- en: The result of these 11 steps will be a conflict. Let’s resolve it!
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这 11 个步骤的结果将是一个冲突。让我们来解决它！
- en: First, create a new project called `conflict_resolution` in PyCharm, as shown
    in *Figure 5**.26*. Make sure you create the project in a location on your drive
    outside of the folder structure for the book’s repository. Remember, the book’s
    code is already in a repository. You can’t create a new repo inside another repo.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 PyCharm 中创建一个名为 `conflict_resolution` 的新项目，如图 5.26 所示。确保你在驱动器上创建项目时，位置不在书籍仓库的文件夹结构内。记住，书籍的代码已经在仓库中了。你无法在另一个仓库内创建新的仓库。
- en: '![Figure 5.26: My conflict_resolution project settings. They’re just defaults](img/B19644_05.26.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.26：我的 conflict_resolution 项目设置。它们只是默认值](img/B19644_05.26.jpg)'
- en: 'Figure 5.26: My conflict_resolution project settings. They’re just defaults'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.26：我的 conflict_resolution 项目设置。它们只是默认值
- en: 'PyCharm generates a project with a `main.py` file. Delete all the lines in
    `main.py` and replace them with this code:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 生成一个包含 `main.py` 文件的项目。删除 `main.py` 中的所有行，并用以下代码替换它们：
- en: '[PRE23]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Just so we’re clear, your PyCharm window should look just like mine in *Figure
    5**.27*.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保清晰，你的 PyCharm 窗口应该看起来就像图 5.27 中的我的窗口一样。
- en: '![Figure 5.27: The main.py file has been reduced to one line of code](img/B19644_05_27.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.27：main.py 文件已被缩减为一行代码](img/B19644_05_27.jpg)'
- en: 'Figure 5.27: The main.py file has been reduced to one line of code'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.27：main.py 文件已被缩减为一行代码
- en: Click the **VCS** menu in the **File** menu and click **Create Git repository**.
    If you don’t remember where in the menu to find this, refer back to *Figure 5**.9*.
    Make note of the default branch that was created. We don’t need a remote for this
    exercise, so it doesn’t matter whether it’s *main*, *master*, or something else;
    you just need to remember its name. I’ll assume it’s called *main*.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **文件** 菜单中点击 **VCS** 菜单，然后点击 **创建 Git 仓库**。如果你不记得在哪里找到这个菜单项，请参考图 5.9。注意创建的默认分支。对于这个练习，我们不需要远程仓库，所以它是否是
    *main*、*master* 或其他都无关紧要；你只需要记住它的名字。我将假设它被称为 *main*。
- en: Use the commit window to add the files for the project to the repository. *Figure
    5**.3* will remind you if you have forgotten how. Go ahead and commit the files
    by entering a commit message.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用提交窗口将项目文件添加到仓库中。图 5.3 将提醒你如何操作。输入提交信息，继续提交文件。
- en: Next, we need to create a branch. Click the branch dropdown and click `development`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个分支。点击分支下拉菜单，然后点击 `development`。
- en: 'Open the `main.py` file. Replace the code with this one line:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `main.py` 文件。将代码替换为这一行：
- en: '[PRE24]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: By limiting ourselves to a single line, we can be positive our actions will
    result in a conflict. Commit this change to the `development` branch.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 通过限制自己只做一行操作，我们可以确保我们的操作将导致冲突。将此更改提交到 `development` 分支。
- en: 'Switch back to the main branch using the branch dropdown. Change the contents
    of `main.py` to this code:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分支下拉菜单切换回主分支。将 `main.py` 的内容更改为以下代码：
- en: '[PRE25]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Commit this change to the main branch. You’ve just simulated two developers
    changing the same file, in the same area. There will be no way for Git to reconcile
    the differences. With the main branch active, click the branch dropdown, click
    the development branch, and click **Merge development into main**. You will see
    a conflict message, as shown in *Figure 5**.28*.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 将此更改提交到主分支。你刚刚模拟了两个开发者在同一区域更改同一文件的情况。Git 将无法解决这些差异。当主分支处于活动状态时，点击分支下拉菜单，点击 development
    分支，然后点击 **将 development 合并到 main**。你将看到一个冲突消息，如图 5.28 所示。
- en: '![Figure 5.28: We have a conflict that needs to be resolved before we can merge](img/B19644_05_28.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.28：在我们合并之前，有一个冲突需要解决](img/B19644_05_28.jpg)'
- en: 'Figure 5.28: We have a conflict that needs to be resolved before we can merge'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.28：在我们合并之前，有一个冲突需要解决
- en: You generally have three options when resolving a conflict. You can choose to
    ignore the incoming changes and select your local work as the correct code by
    clicking the **Accept Yours** button. Likewise, you can select the incoming code
    changes and discard your local copy by clicking **Accept Theirs**. Often, though,
    you will need to merge parts of your local revision with the incoming changes.
    For this, you will need to activate the merge tool, as shown in *Figure 5**.29*,
    by clicking the **Merge…** button.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决冲突时，你通常有三个选项。你可以选择忽略接收到的更改，并通过点击**接受你的**按钮将你的本地工作作为正确代码。同样，你可以选择接收代码更改并丢弃你的本地副本，通过点击**接受他们的**。然而，通常你需要将你的本地修订的一部分与接收到的更改合并。为此，你需要激活合并工具，如*图
    5**.29*所示，通过点击**合并…**按钮。
- en: '![Figure 5.29: Activate the merge tool to pick parts from the incoming code
    to merge with yours](img/B19644_05_29.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.29：激活合并工具以从接收到的代码中选择部分与你的代码合并](img/B19644_05_29.jpg)'
- en: 'Figure 5.29: Activate the merge tool to pick parts from the incoming code to
    merge with yours'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.29：激活合并工具以从接收到的代码中选择部分与你的代码合并
- en: With the merge tool active, you can see three panes. The pane on the left (**1**)
    represents the conflicting code from the main branch. The code on the right (**2**)
    is the revision coming from the development branch. The pane in the middle (**3**)
    represents the amalgamation of the two. You can pick parts of your code and parts
    of the incoming code to make the best possible combination. Experiment with the
    **>>** buttons (**4**), which copy the code into the central merged result. The
    buttons labeled **X** (**4**) will ignore the conflicted line. You can use the
    up and down arrows (**5**) to jump to the next unresolved conflict in the file.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当合并工具处于激活状态时，你可以看到三个面板。左侧的面板（**1**）表示来自主分支的冲突代码。右侧的代码（**2**）是来自开发分支的修订。中间的面板（**3**）表示两者的合并。你可以选择你代码的一部分和接收代码的一部分，以制作出最佳组合。通过实验**>>**按钮（**4**），可以将代码复制到中央合并结果中。标有**X**（**4**）的按钮将忽略冲突的行。你可以使用上下箭头（**5**）跳转到文件中的下一个未解决冲突。
- en: Let’s pretend the best resolution to my conflict is to have a line from the
    left pane and a line from the right pane together. In real life, this wouldn’t
    work because we’re going to wind up with two variable assignments next to each
    other, but it does demonstrate how the tool works. To use the line from the left
    pane, I can click the button indicated by the arrow in *Figure 5**.30*.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设解决我的冲突的最佳方案是将左侧面板和右侧面板的行放在一起。在现实生活中，这不会起作用，因为我们最终会在相邻的位置得到两个变量赋值，但这确实展示了工具的工作方式。要使用左侧面板的行，我可以点击*图
    5**.30*中箭头指示的按钮。
- en: '![Figure 5.30: This button will move the code from the left pane into the working
    merge solution](img/B19644_05_30.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.30：此按钮将代码从左侧面板移动到工作合并解决方案中](img/B19644_05_30.jpg)'
- en: 'Figure 5.30: This button will move the code from the left pane into the working
    merge solution'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.30：此按钮将代码从左侧面板移动到工作合并解决方案中
- en: Next, I’d like to place the line from the right pane below the line I just moved.
    Often, you want to use some of the code from both sides rather than it simply
    being right or wrong from one side. Click the button indicated by the arrow in
    *Figure 5**.31* to copy the code from the left pane below the current line in
    the middle pane.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我想将右侧面板的行放在我刚刚移动的行下方。通常，你希望使用来自两边的代码，而不仅仅是单方面的对或错。点击*图 5**.31*中箭头指示的按钮，将代码从左侧面板复制到中间面板当前行的下方。
- en: '![Figure 5.31: Clicking the double arrow copies this line below the one we
    selected from the right side](img/B19644_05_31.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.31：点击双箭头将此行复制到我们从右侧选择的行下方](img/B19644_05_31.jpg)'
- en: 'Figure 5.31: Clicking the double arrow copies this line below the one we selected
    from the right side'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.31：点击双箭头将此行复制到我们从右侧选择的行下方
- en: Once you complete this action, you have resolved the conflict! You are rewarded
    with a nice green message telling you as much.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成此操作，你就解决了冲突！你会得到一条漂亮的绿色消息告诉你这一点。
- en: Your objective is to use the left and right panes to create the best version
    of the code in the middle pane, which represents the resolution of the conflict.
    When you’re finished, you can click the **Apply** button. If you have unresolved
    conflicts remaining in the file, PyCharm will tell you that. If you got them all,
    the merge you attempted is completed. If you are working with a remote, you should
    push the resulting conflict resolution once the commit is successful.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 您的目标是使用左侧和右侧的窗格创建中间窗格中代码的最佳版本，这代表着冲突的解决。完成之后，您可以点击**应用**按钮。如果您在文件中还有未解决的冲突，PyCharm会告诉您。如果您都解决了，您尝试的合并就完成了。如果您正在与远程仓库一起工作，一旦提交成功，您应该推送结果冲突解决方案。
- en: Viewing diffs
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看差异
- en: 'You don’t need a conflict to use the diff window we just saw. A diff window
    is a window that shows two or more versions of code side by side. You can diff
    between branches, or between revisions. Say I make a quick change to our merged
    code by adding this line:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要冲突就可以使用我们刚才看到的差异窗口。差异窗口是一个显示两个或多个代码版本的并排窗口。您可以在分支之间或修订之间进行差异比较。比如说，我通过添加这一行快速更改了我们的合并代码：
- en: '[PRE26]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'I also take out line 2, which reads as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我还删除了第2行，内容如下：
- en: '[PRE27]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: My code is now very different. If I want to compare my new code with the latest
    in the branch, I can right-click the `main.py` tab and click **Git** | **Show
    Diff**. I’ll see a side-by-side diff of the two files, as shown in *Figure 5**.32*.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我的代码现在非常不同。如果我想将我的新代码与分支中的最新版本进行比较，我可以右键单击`main.py`标签并点击**Git** | **显示差异**。我将看到两个文件的并排差异，如图*图5.32*所示。
- en: '![Figure 5.32: The diff view between what you’ve got in your editor versus
    the last committed version](img/B19644_05_32.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图5.32：编辑器中的内容与最后提交版本之间的差异视图](img/B19644_05_32.jpg)'
- en: 'Figure 5.32: The diff view between what you’ve got in your editor versus the
    last committed version'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.32：编辑器中的内容与最后提交版本之间的差异视图
- en: This diff is appearing in a side-by-side format. You can change it to an in-line
    view, which is often shown on GitHub when you view commits, by changing the drop-down
    setting labeled (**1**). You can also edit the file using the same line-moving
    tools you just saw in the merge indicated by (**2**).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这个差异现在以并排格式显示。您可以通过更改标记为（**1**）的下拉设置将其更改为内联视图，这在GitHub上查看提交时通常显示。您还可以使用您刚才在合并中看到的相同行移动工具编辑文件。（**2**）。
- en: Summary
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have covered two main topics—the idea of version control
    in application development and programming and its importance, as well as how
    to practice it using Git and GitHub within PyCharm. Specifically, we have learned
    how to carry out version control using Git and GitHub in two different ways: manually
    and with PyCharm.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了两个主要主题——应用开发和编程中版本控制的概念及其重要性，以及如何在PyCharm中使用Git和GitHub来实践它。具体来说，我们学习了如何以两种不同的方式使用Git和GitHub进行版本控制：手动和通过PyCharm。
- en: With this knowledge, PyCharm users can apply version control to their own projects
    in a flexible way, skipping over the manual and tedious process in the terminal/command
    line. We see that, by offering these features, PyCharm allows us to focus on the
    actual development process in any given software engineering project.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，PyCharm用户可以以灵活的方式将版本控制应用于自己的项目，跳过终端/命令行中的手动和繁琐过程。我们看到，通过提供这些功能，PyCharm允许我们在任何软件工程项目中专注于实际的开发过程。
- en: Aside from version control, there are other practices in application development—
    which PyCharm provides intuitive, straightforward commands to facilitate. Without
    these commands, application development be quite complex and intimidating. These
    processes are testing, debugging, and profiling, all of which will be discussed
    in the next chapter.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 除了版本控制之外，在应用开发中还有其他实践——PyCharm提供了直观、直接的命令来简化这些过程。没有这些命令，应用开发可能会相当复杂和令人畏惧。这些过程包括测试、调试和性能分析，所有这些内容将在下一章中讨论。
- en: Questions
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What does the term *version control* entail, specifically in the context of
    programming?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 术语*版本控制*在编程的上下文中具体指什么？
- en: What are the benefits of using version control?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用版本控制有哪些好处？
- en: What are the basic steps to version control for your own projects with Git and
    GitHub?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Git和GitHub对您自己的项目进行版本控制的基本步骤是什么？
- en: What is *branching* and why is it important?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是*分支*，为什么它很重要？
- en: Name the various windows and tool locations throughout PyCharm that give you
    access to Git and other VCS commands.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出PyCharm中提供访问Git和其他VCS命令的各种窗口和工具位置。
- en: Further reading
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Be sure to check out the companion website for the book at [https://www.pycharm-book.com](https://www.pycharm-book.com).
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一定要查看本书的配套网站：[https://www.pycharm-book.com](https://www.pycharm-book.com).
- en: '*Merging vs.* *Rebasing*: [https://www.atlassian.com/git/tutorials/merging-vs-rebasing](https://www.atlassian.com/git/tutorials/merging-vs-rebasing)'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*合并与* *变基*：[https://www.atlassian.com/git/tutorials/merging-vs-rebasing](https://www.atlassian.com/git/tutorials/merging-vs-rebasing)'
- en: 'How Secure Shell (SSH) works: [https://en.wikipedia.org/wiki/Secure_Shell](https://en.wikipedia.org/wiki/Secure_Shell)'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何 Secure Shell (SSH) 工作：[https://en.wikipedia.org/wiki/Secure_Shell](https://en.wikipedia.org/wiki/Secure_Shell)
- en: '*Adding a new SSH key to your GitHub* *account*: [https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account
    )'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将新的 SSH 密钥添加到您的 GitHub* *账户*：[https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account)'
- en: '*Why GitHub renamed its master branch to* *main*: [https://www.theserverside.com/feature/Why-GitHub-renamed-its-master-branch-to-main](https://www.theserverside.com/feature/Why-GitHub-renamed-its-master-branch-to-main
    )'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为什么 GitHub 将其 master 分支重命名为* *main*：[https://www.theserverside.com/feature/Why-GitHub-renamed-its-master-branch-to-main](https://www.theserverside.com/feature/Why-GitHub-renamed-its-master-branch-to-main)'
- en: '*Git Merge Strategy Options and* *Examples*: [https://www.atlassian.com/git/tutorials/using-branches/merge-strategy](https://www.atlassian.com/git/tutorials/using-branches/merge-strategy
    )'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Git 合并策略选项和* *示例*：[https://www.atlassian.com/git/tutorials/using-branches/merge-strategy](https://www.atlassian.com/git/tutorials/using-branches/merge-strategy)'
- en: 'Git branching guidance: [https://learn.microsoft.com/en-us/azure/devops/repos/git/git-branching-guidance](https://learn.microsoft.com/en-us/azure/devops/repos/git/git-branching-guidance
    )'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 分支指南：[https://learn.microsoft.com/en-us/azure/devops/repos/git/git-branching-guidance](https://learn.microsoft.com/en-us/azure/devops/repos/git/git-branching-guidance)
- en: 'Git Essentials for Beginners: [https://www.packtpub.com/product/mastering-git/9781783553754](https://www.packtpub.com/product/mastering-git/9781783553754)'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 初学者必备：[https://www.packtpub.com/product/mastering-git/9781783553754](https://www.packtpub.com/product/mastering-git/9781783553754)
- en: 'Liberty, J. (2021). *Git for Programmers: Master Git for effective implementation
    of version control for your programming projects*. Packt Publishing Limited.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Liberty, J. (2021). *程序员必备 Git：掌握 Git 以有效实施版本控制，适用于您的编程项目*. Packt Publishing
    Limited.
- en: Narebski, J. (2016). *Mastering Git*. Packt Publishing Ltd.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Narebski, J. (2016). *精通 Git*. Packt Publishing Ltd.
- en: '*The Joel Test: 12 Steps to Better* *Code*: [https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/](https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/)'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《乔尔测试：提升代码质量的12步》*：[https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/](https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/)'
- en: Be sure to check out the companion website for the book at [https://www.pycharm-book.com](https://www.pycharm-book.com).
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一定要查看本书的配套网站：[https://www.pycharm-book.com](https://www.pycharm-book.com).
