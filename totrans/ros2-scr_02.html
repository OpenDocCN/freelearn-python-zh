<html><head></head><body>
		<div id="_idContainer008" class="calibre2">
			<h1 class="chapter-number" id="_idParaDest-15"><a id="_idTextAnchor015" class="pcalibre calibre4 pcalibre1"/>1</h1>
			<h1 id="_idParaDest-16" class="calibre6"><a id="_idTextAnchor016" class="pcalibre calibre4 pcalibre1"/>Introduction to ROS 2 – What Is ROS 2?</h1>
			<p class="calibre3"><strong class="bold">Robot Operating System</strong> (<strong class="bold">ROS</strong>) can <a id="_idIndexMarker000" class="pcalibre calibre4 pcalibre1"/>be confusing, as evidenced by its name. It’s difficult to know what it is exactly, what it contains, and what it does. Also, why do you even need ROS, and when should you <span>use it?</span></p>
			<p class="calibre3">Before getting started, it is okay to be confused—most people are. Although ROS is one of the best tools to learn and develop robotics applications, it also comes with a steep learning curve, with the first roadblock being understanding what <span>it is.</span></p>
			<p class="calibre3">In this quick first chapter, I will explain the terminology we will use throughout this book. You will then see why ROS exists, and what problems it can solve for you. After that, we will dive a bit deeper into the four pillars of ROS to understand what it is. You will also see a few examples of when and when not to <span>use it.</span></p>
			<p class="calibre3">By the end of this chapter, you will have a better understanding of the global picture behind ROS and be clear of the most common confusions. You will also understand what prerequisites you need before you get started with ROS, as well as how to follow this book to get the most out of it. This will help you get started on the <span>right foot.</span></p>
			<p class="calibre3">In this chapter, we are going to cover the <span>following topics:</span></p>
			<ul class="calibre9">
				<li class="calibre10"><span>Terminology</span></li>
				<li class="calibre10">What is ROS, when should we use it, <span>and why?</span></li>
				<li class="calibre10">ROS 1 versus <span>ROS 2</span></li>
				<li class="calibre10">Prerequisites for starting with <span>ROS 2</span></li>
				<li class="calibre10">How to follow <span>this book</span><a id="_idTextAnchor017" class="pcalibre calibre4 pcalibre1"/></li>
			</ul>
			<h1 id="_idParaDest-17" class="calibre6"><a id="_idTextAnchor018" class="pcalibre calibre4 pcalibre1"/>Terminology</h1>
			<p class="calibre3">You might have seen the terms ROS, ROS 1, ROS 2, and other kinds of variations (with or without a space), which can <span>be confusing.</span></p>
			<p class="calibre3">Let’s clear this <span>up now:</span></p>
			<ul class="calibre9">
				<li class="calibre10">ROS 1 is (was) the first version <span>of ROS</span></li>
				<li class="calibre10">ROS 2 is the second and newer version of ROS and will be the focus of <span>this book</span></li>
			</ul>
			<p class="calibre3">In this book, I will use the <span>following convention:</span></p>
			<ul class="calibre9">
				<li class="calibre10"><strong class="bold">ROS</strong>: When talking about general ROS concepts, philosophy, and <span>so on</span></li>
				<li class="calibre10"><strong class="bold">ROS 1</strong>: When talking specifically about the first version of ROS. However, this will be quite rare since the focus here is on <span>ROS 2</span></li>
				<li class="calibre10"><strong class="bold">ROS 2</strong>: When talking about the second version <span>of ROS</span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">I may sometimes write <em class="italic">ROS</em> or <em class="italic">ROS 2</em> interchangeably since we won’t be focusing on ROS <span>1 here.</span></p>
			<p class="callout">It’s not impossible that, in the future (when ROS 1 has completely disappeared), the name ROS 2 becomes ROS again. If you’ve heard about Angular, it started as AngularJS, after which they released Angular2, and then a few years later, it simply became Angular. I guess that something similar will happen with ROS, although this is only a theory of mine <span>for now.</span><a id="_idTextAnchor019" class="pcalibre calibre4 pcalibre1"/></p>
			<h1 id="_idParaDest-18" class="calibre6"><a id="_idTextAnchor020" class="pcalibre calibre4 pcalibre1"/>What is ROS, when should we use it, and why?</h1>
			<p class="calibre3">Before we<a id="_idIndexMarker001" class="pcalibre calibre4 pcalibre1"/> start understanding what ROS is, let’s understand why we would <span>need it<a id="_idTextAnchor021" class="pcalibre calibre4 pcalibre1"/>.</span></p>
			<h2 id="_idParaDest-19" class="calibre6"><a id="_idTextAnchor022" class="pcalibre calibre4 pcalibre1"/>Why ROS?</h2>
			<p class="calibre3">Let’s start with a<a id="_idIndexMarker002" class="pcalibre calibre4 pcalibre1"/> big problem that occurs often <span>in robotics.</span></p>
			<p class="calibre3">Imagine that you just got a new project at your job, and you have to develop a robotics application, or you are doing a new research thesis. One very important thing to take into account is that in real life, any project or thesis will have a specific duration, from a few months to a <span>few years.</span></p>
			<p class="calibre3">Now, what <span>will happen?</span></p>
			<p class="calibre3">You start to design the robotics system you need for your project and soon realize that it will take a lot of time to develop the robot because all the existing solutions you found don’t match what you need. After a few weeks, you finalize the specifications, and you start building your robot. A few months in, you’re still developing the basic software for wheel control and navigation. You underestimated how much time it would take you to just get the robot running. After 1 or 2 years, you realize that all you’ve done for now is build a robotics system, and you still haven’t started the core functionality of your application or research. Now is the time <span>to hurry.</span></p>
			<p class="calibre3">You finish the robot as well as you can, make some shortcuts, and publish your paper or present that prototype. In the best-case scenario, you could also share your code with an open-source license so that other people can use it, but probably not directly as it’s just code for your own need, not a complete framework or library with modular components, documentation, and <span>so on.</span></p>
			<p class="calibre3">Then, you move on to a new project, new job, and new research. Somebody else will take your place, read your code, and realize that it doesn’t help them build their application. Hence, they have to start <span>from scratch.</span></p>
			<p class="calibre3">What just happened here is that you reinvented the wheel. The next person will repeat the same circle. And this is much more common than you think. People keep reinventing the wheel over and over again. This is the number one reason why ROS was created: to stop you from reinventing the wheel anytime you need to create a robot. Just like you have open-source frameworks, tools, and environments to develop websites or mobile applications, why not do the same for robotics? This is the philosophy behind ROS: to provide a <em class="italic">standard</em> for robotics applications that you can use<a id="_idIndexMarker003" class="pcalibre calibre4 pcalibre1"/> on <span><em class="italic">any robot</em></span><span>.</span></p>
			<p class="calibre3">After you learn ROS, you can spend less time on the basics and focus on the key functionalities you want to add instead. You can program new robots in no time, join existing projects, and easily collaborate with <span>a te<a id="_idTextAnchor023" class="pcalibre calibre4 pcalibre1"/>am.</span></p>
			<h2 id="_idParaDest-20" class="calibre6"><a id="_idTextAnchor024" class="pcalibre calibre4 pcalibre1"/>What is ROS?</h2>
			<p class="calibre3">ROS is<a id="_idIndexMarker004" class="pcalibre calibre4 pcalibre1"/> hard to define because it’s not just one thing. And to be honest, I don’t think you can truly understand what it is until you start to understand how to write code <span>with it.</span></p>
			<p class="calibre3">One thing we can start with is what ROS <span>is not.</span></p>
			<p class="calibre3">ROS is not an operating system. It’s a combination of four <span>main parts:</span></p>
			<ul class="calibre9">
				<li class="calibre10"><span>Framework</span></li>
				<li class="calibre10">Set <span>of tools</span></li>
				<li class="calibre10"><span>Plug-and-play plugins</span></li>
				<li class="calibre10">An <span>online community</span></li>
			</ul>
			<p class="calibre3">Let’s dive a bit more into each of <span>these pa<a id="_idTextAnchor025" class="pcalibre calibre4 pcalibre1"/>rts.</span></p>
			<h3 class="calibre8">ROS is a framework with plumbing</h3>
			<p class="calibre3">ROS comes<a id="_idIndexMarker005" class="pcalibre calibre4 pcalibre1"/> with a set of rules on how to build an application. As we will see in this book, you will need to create packages, and then write programs inside those packages (nodes). There is a specific way to create and write them, as well as create tools to build and <span>use them.</span></p>
			<p class="calibre3">Any framework comes with a specific set of rules. The remarkable thing about this is that after you’ve created a few projects, any new project is going to be easier and faster to set up. Also, as everyone is following the same set of rules, you can more easily work in a team or understand and use the code written <span>by others.</span></p>
			<p class="calibre3">As a direct consequence of using this framework, you get access to what is often referred to as <strong class="bold">plumbing</strong>, which <a id="_idIndexMarker006" class="pcalibre calibre4 pcalibre1"/>means that the underlying communication between the nodes is managed for you. Imagine that you’re building a house, and the plumbing or electrical system is already done for you. This will save you a lot of development time, and you also don’t need to learn how to do it yourself (and thus, reinvent <span>the wheel).</span></p>
			<p class="calibre3">To sum it up, with ROS, you can easily separate your application into different sub-programs (called <strong class="bold">nodes</strong>). The <a id="_idIndexMarker007" class="pcalibre calibre4 pcalibre1"/>communication between nodes is handled for you. You can easily test one component, and if this component fails, it will not affect the other running components. ROS is a <span>modular fra<a id="_idTextAnchor026" class="pcalibre calibre4 pcalibre1"/>mework.</span></p>
			<h3 class="calibre8">A set of tools</h3>
			<p class="calibre3">ROS comes <a id="_idIndexMarker008" class="pcalibre calibre4 pcalibre1"/>with a set of tools that allow you to develop faster. Among them, you can find command-line tools to build the application, introspection tools to monitor the flow of communication, logging functionalities, plots, <span>and more.</span></p>
			<p class="calibre3">You also get 3D visualization<a id="_idIndexMarker009" class="pcalibre calibre4 pcalibre1"/> tools to see what your robot is doing, and even a complete simulator using real physics, named <strong class="bold">Gazebo</strong>, so that you can work on a realistic simulation before trying out <span>your robot.</span></p>
			<p class="calibre3">There are quite a lot of available tools, and we’ll discover many of them throughout this book. As an example of how useful it can be, there is one (called <strong class="bold">bags</strong>) that allows you to save communication streams so that they can be replayed later. Let’s say you build a mobile robot, and you need to test the robot outside when it’s raining, then continue to develop the software while taking the rain into account. You probably won’t have rain every day, or you won’t even have access to the robot any time you want. With this tool, you can run the experiment once, save the data, and replay it later to develop your application for a specific set <span>of conditions.</span></p>
			<h3 class="calibre8">Capabilities – plug-and-play plugins and stacks</h3>
			<p class="calibre3">This is <a id="_idIndexMarker010" class="pcalibre calibre4 pcalibre1"/>probably where you will save hundreds of hours. Imagine two <span>common scenarios:</span></p>
			<ul class="calibre9">
				<li class="calibre10">You develop a mobile robot and need the robot to navigate autonomously in a <span>dynamic environment.</span></li>
				<li class="calibre10">You develop a six-axis robotic arm and want to create motion planning to perform a smooth movement on <span>all axes.</span></li>
			</ul>
			<p class="calibre3">This looks quite complex and involves understanding and implementing several algorithms, as well as writing well-optimized and efficient code. This is where you would probably have to reinvent the wheel and waste lots of <span>precious time.</span></p>
			<p class="calibre3">For those two scenarios, you can find existing plugins that do the job for you. All you need to do is install the plugins and configure your robot to make it compatible. Of course, this is easier said than done, but the workload can be counted in days/weeks, not months/years. And once again, once you know how to use those plugins, your next project will take much <span>less time.</span></p>
			<p class="calibre3">There are many plugins that you can use. Some are quite simple, while others involve a collection of plugins and are also called frameworks or stacks. Your job as a ROS developer <a id="_idIndexMarker011" class="pcalibre calibre4 pcalibre1"/>is to <em class="italic">glue</em> all those components together, and maybe create new components for functionalities that are not <span>dev<a id="_idTextAnchor027" class="pcalibre calibre4 pcalibre1"/>eloped yet.</span></p>
			<h3 class="calibre8">Online community</h3>
			<p class="calibre3">This is <a id="_idIndexMarker012" class="pcalibre calibre4 pcalibre1"/>the fourth pillar of ROS, and it’s quite an important one: the community. ROS is an open-source project with a permissive license. I can’t give you any legal advice on licensing, but you can use ROS in a commercial product without having to redistribute <span>your code.</span></p>
			<p class="calibre3">You can find all the ROS code online, as well as the code for the plug-and-play plugins. Everything is easily accessible <span>on GitHub.</span></p>
			<p class="calibre3">The ROS project is also backed by an online community that you can most commonly find in the <span>following areas:</span></p>
			<ul class="calibre9">
				<li class="calibre10"><strong class="bold">Robotics Stack Exchange</strong> (<a href="https://robotics.stackexchange.com/" class="pcalibre calibre4 pcalibre1">https://robotics.stackexchange.com/</a>): You can use this to <a id="_idIndexMarker013" class="pcalibre calibre4 pcalibre1"/>ask technical questions. If you know Stack Overflow, as most developers do, well, this is Stack Overflow <span>for robotics.</span></li>
				<li class="calibre10"><strong class="bold">ROS Discourse forums</strong> (<a href="https://discourse.ros.org/" class="pcalibre calibre4 pcalibre1">https://discourse.ros.org/</a>): Here, you can get informed <a id="_idIndexMarker014" class="pcalibre calibre4 pcalibre1"/>about the latest developments, jobs, community projects, new ideas, and more. I recommend checking this website often to stay up to date with where<a id="_idTextAnchor028" class="pcalibre calibre4 pcalibre1"/> ROS <span>is going.</span></li>
			</ul>
			<h2 id="_idParaDest-21" class="calibre6"><a id="_idTextAnchor029" class="pcalibre calibre4 pcalibre1"/>When to use ROS</h2>
			<p class="calibre3">Now that you<a id="_idIndexMarker015" class="pcalibre calibre4 pcalibre1"/> understand a bit more what ROS is, should you use ROS whenever your project has something 'robotics' in it? In this section, I will give you some hints on when using ROS makes sense, backed by some examples to give you a <span>better idea.</span></p>
			<p class="calibre3">First, if you’re reading this book because you need to learn ROS for your work/university, then the question is easily answered: yes, you will use ROS for <span>your project.</span></p>
			<p class="calibre3">But if you must make the decision yourself, what should <span>you do?</span></p>
			<p class="calibre3">Let’s simplify robotics and say that a robotics system contains three categories of things: actuators, sensors, <span>and controllers.</span></p>
			<p class="calibre3">An <strong class="bold">actuator</strong> is something <a id="_idIndexMarker016" class="pcalibre calibre4 pcalibre1"/>that creates movement (for example, a motor to rotate a wheel). A <strong class="bold">sensor</strong> will <a id="_idIndexMarker017" class="pcalibre calibre4 pcalibre1"/>read data from the environment (for example, a camera, laser scan, or temperature sensor). A <strong class="bold">controller</strong> is something that is in between: it <a id="_idIndexMarker018" class="pcalibre calibre4 pcalibre1"/>takes the data available from one or multiple sensors (input) and, through an algorithm, creates a command for the actuators of the robot (output). In a way, the controller is the <em class="italic">brain</em> or one of the brains of <span>the robot.</span></p>
			<p class="calibre3">For very simple applications, when you just have a few sensors and actuators, you might not <span>need ROS.</span></p>
			<p class="calibre3">Here are a<a id="_idIndexMarker019" class="pcalibre calibre4 pcalibre1"/> few examples where ROS <span>isn’t needed:</span></p>
			<ul class="calibre9">
				<li class="calibre10">You just need to take a picture from a camera when a user presses a button, using a Raspberry Pi board, and send this picture to a web server. There’s no need to use ROS—you can just combine a few Python libraries in a script, and you’re done. Using ROS here would be a good example of over-engineering (unless you do this for <span>learning purposes).</span></li>
				<li class="calibre10">You have to use a servo motor to open/close a door when a movement is detected, using an infrared sensor. This is a very simple application that can easily be programmed using a basic microcontroller board—and you can do a quick prototype with a board such <span>as Arduino.</span></li>
				<li class="calibre10">You have built a simple robot with two wheels and an infrared sensor, and you want to make the robot follow a line. This is a typical project that’s given to students in engineering school, and a simple algorithm on an Arduino board <span>will do.</span></li>
			</ul>
			<p class="calibre3">Now, let’s consider some examples where ROS <span>is needed:</span></p>
			<ul class="calibre9">
				<li class="calibre10">You have a new mobile robot with two wheels and a laser scan, and you want to read data from the laser scan, map the environment, make the robot move autonomously, and control the two wheels accordingly. On top of that, you want to simulate the robot in 3D with real physical properties. This is when ROS is going to become very handy. Not only will it help you to make all the components work together, but you can also use existing algorithms for path planning (through a ROS plugin) <span>and simulation.</span></li>
				<li class="calibre10">You need to create a system that contains a six-axis robotic arm, or even multiple robotic arms working together, along with conveyor belts and <span>mobile robots.</span></li>
				<li class="calibre10">Your robotics<a id="_idIndexMarker020" class="pcalibre calibre4 pcalibre1"/> application (not necessarily just one robot) contains lots of sensors and actuators that you want to develop separately and add them in a <span>modular way.</span></li>
				<li class="calibre10">You want to create a hardware driver for a component and make this component easy to use by other robotics developers. By making the component <em class="italic">ROS-compatible</em>, anybody who knows ROS can integrate it into their application with <span>low effort.</span></li>
			</ul>
			<p class="calibre3">As you can see from the former examples, ROS is not always needed whenever you need to program hardware or create a robotics system. Of course, you could use it for any application, but it’s like if you were to use a complete web framework (for example, Django) for a single static <span>web page.</span></p>
			<p class="calibre3">With the latter examples, you can see that if your system becomes more complex, if you want to easily collaborate with other developers, or if you realize that one big part of your system can be solved with one of the plug-and-play plugins, ROS may be <span>the solution.</span></p>
			<p class="calibre3">Of course, it takes time to learn it and your first project will take longer to complete, but then, with more experience, you will go <span>much faster.</span></p>
			<p class="calibre3">As an example, it could take less than a week for a senior ROS developer to write custom code for a robotic arm (including robot model, motion planning, and hardware control) and the same for a mobile robot with navigation capabilities (provided that the hardware already has a ROS driver). Less than a week and you get a working<a id="_idTextAnchor030" class="pcalibre calibre4 pcalibre1"/> <span>software prototype.</span></p>
			<h1 id="_idParaDest-22" class="calibre6"><a id="_idTextAnchor031" class="pcalibre calibre4 pcalibre1"/>ROS 1 versus ROS 2</h1>
			<p class="calibre3">To be clear, this<a id="_idIndexMarker021" class="pcalibre calibre4 pcalibre1"/> book is all about ROS 2, not ROS 1. You will start learning ROS 2 from zero experience. This section is probably the only time I will be talking t<a id="_idTextAnchor032" class="pcalibre calibre4 pcalibre1"/>hat much about <span>ROS 1.</span></p>
			<h2 id="_idParaDest-23" class="calibre6"><a id="_idTextAnchor033" class="pcalibre calibre4 pcalibre1"/>A quick story of ROS, and how we got to ROS 2</h2>
			<p class="calibre3">ROS 1 (originally called ROS) was first developed in 2007. It quickly gained popularity and grew exponentially in the <span>following years.</span></p>
			<p class="calibre3">In 2014, the ROS 2 project was announced. Simply put, ROS 1 was a bit too limited for industrial applications (lack of real-time support, safety, and so on) and was only used in research/education. To solve this problem, the developers decided to make ROS more “industrial friendly,” as well as make it better, thanks to all the lessons learned from the beginning <span>of ROS.</span></p>
			<p class="calibre3">Now, why create ROS 2 and not just continue ROS with some new changes? Well, the changes were too big, and they would have completely broken compatibility with older versions. Thus, it was decided to create a completely new ROS <a id="_idTextAnchor034" class="pcalibre calibre4 pcalibre1"/>from scratch and name it ROS 2. In 2014, ROS 2 was officially announced, and the development of the <span>project started.</span></p>
			<p class="calibre3">In December 2017, the first ROS 2 distribution was released, which meant that ROS 1 and ROS 2 started to co-exist. At this point, ROS 2 was lacking many core functionalities and plugins, making it unsuitable for serious projects. Most ROS developers were still using <span>ROS 1.</span></p>
			<p class="calibre3">Years passed by and ROS 2 got more development, plugins, and more. Its popularity started <span>to grow.</span></p>
			<p class="calibre3">I would say it was worth it to use ROS 2 (compared to ROS 1) starting from 2022. This is probably more of a personal opinion and some people might disagree, but from 2022 and the release <a id="_idIndexMarker022" class="pcalibre calibre4 pcalibre1"/>of <strong class="bold">ROS 2 Humble</strong> (more on distributions in <a href="B22403_02.xhtml#_idTextAnchor048" class="pcalibre calibre4 pcalibre1"><span><em class="italic">Chapter 2</em></span></a>), we had access to a long-term release that was stable, with all the major plugins and stacks working correctly, which is what you need to program <span>a robot.</span></p>
			<p class="calibre3">In the meantime, it was announced that ROS 1 would end in May 2025. After this date, ROS 1 would still exist, but it wouldn’t be <span>supported anymore.</span></p>
			<p class="calibre3">2023 was the year with the most significant shift from ROS 1 to ROS 2 among the ROS community. It is now safe to say that ROS 2 is the way to go when developing new <span>ROS applications.</span></p>
			<p class="calibre3">So, if you had previously heard about ROS 1 and ROS 2, now you know that ROS 2 is what you need to learn, and we can say that ROS 1 is a dead proj<a id="_idTextAnchor035" class="pcalibre calibre4 pcalibre1"/>ect. But is <span>that true?</span></p>
			<h2 id="_idParaDest-24" class="calibre6"><a id="_idTextAnchor036" class="pcalibre calibre4 pcalibre1"/>Is ROS 1 dead already?</h2>
			<p class="calibre3">In theory, yes, but <a id="_idIndexMarker023" class="pcalibre calibre4 pcalibre1"/>in practice, it’s (always) a bit different. As you probably know, several companies are using obsolete and legacy technologies. The reason is that updating software to a new version is often quite expensive and can also be risky. That’s why you still see job offers from banking systems requiring skills in Cobol, a programming language from the 1960s that no one <span>uses anymore.</span></p>
			<p class="calibre3">In robotics, things are a bit similar. Some companies have released robots with a specific version of ROS 1, and while the robot is still on the market, the company will not upgrade and still use and maintain the previous version, also called <em class="italic">legacy</em>. Thus, the definitive transition in 2025 is going to take a few <span>more years.</span></p>
			<p class="calibre3">Why am I writing this? Simply to let you know that if you happen to get a job in a robotics company that has been using ROS already, yo<a id="_idTextAnchor037" class="pcalibre calibre4 pcalibre1"/>u migh<a id="_idTextAnchor038" class="pcalibre calibre4 pcalibre1"/>t encounter a few ROS 1 projects, even after ROS 1 is officially finished. However, be assured that all the ROS 2 knowledge you have can easily be ported to ROS 1 as the core concepts are <span>the same.</span></p>
			<p class="calibre3">To conclude, for all new learnings, projects, studies, teaching, and startups, ROS 2 is what you need. I will now close this chapter of ROS 1 and focus on ROS 2. As mentioned previously, I might write <em class="italic">ROS</em> or <em class="italic">ROS 2</em> interchangeably as we aren’<a id="_idTextAnchor039" class="pcalibre calibre4 pcalibre1"/>t targeting ROS <span>1 here.</span></p>
			<h1 id="_idParaDest-25" class="calibre6"><a id="_idTextAnchor040" class="pcalibre calibre4 pcalibre1"/>Prerequisites for starting with ROS 2</h1>
			<p class="calibre3">To get started with ROS <a id="_idIndexMarker024" class="pcalibre calibre4 pcalibre1"/>and this book, there are a few <a id="_idTextAnchor041" class="pcalibre calibre4 pcalibre1"/>things you need <span>to know.</span></p>
			<h2 id="_idParaDest-26" class="calibre6"><a id="_idTextAnchor042" class="pcalibre calibre4 pcalibre1"/>Knowledge prerequisites</h2>
			<p class="calibre3">It is best<a id="_idIndexMarker025" class="pcalibre calibre4 pcalibre1"/> that you have some knowledge of <span>the following:</span></p>
			<ul class="calibre9">
				<li class="calibre10"><strong class="bold">Linux command line</strong>: Since <a id="_idIndexMarker026" class="pcalibre calibre4 pcalibre1"/>we’ll be using <strong class="bold">Ubuntu</strong>, being familiar<a id="_idIndexMarker027" class="pcalibre calibre4 pcalibre1"/> with Linux is mandatory. You don’t need to be an expert—you just need to know the basics. Many tools in ROS 2 involve the command line, so knowing how to open a Terminal and write basic commands will help <span>you tremendously.</span></li>
				<li class="calibre10"><strong class="bold">Python programming</strong>: The<a id="_idIndexMarker028" class="pcalibre calibre4 pcalibre1"/> two most common languages for ROS <a id="_idIndexMarker029" class="pcalibre calibre4 pcalibre1"/>are <strong class="bold">Python</strong> and C++. Python is easier to get started with <a id="_idIndexMarker030" class="pcalibre calibre4 pcalibre1"/>and allows you to prototype things faster. Hence, this is the language we will use for all detailed explanations. You need to know Python basics, and <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) is a good plus as ROS 2 is heavily<a id="_idIndexMarker031" class="pcalibre calibre4 pcalibre1"/> using <span>OOP everywhere.</span></li>
				<li class="calibre10"><strong class="bold">Optional</strong>: <strong class="bold">C++</strong> programming. Even if the focus of the book is on Python, I still wanted to include C++ code for everything we do. If you only want to learn Python, you can ignore the C++ code, but of course, if you want to follow C++ instructions, you need C++ basics (better <span>with OOP).</span></li>
			</ul>
			<p class="calibre3">I want to emphasize <a id="_idIndexMarker032" class="pcalibre calibre4 pcalibre1"/>that it will be much, much easier for you to learn ROS 2 if you have good programming and Linux basics. Learning ROS is already quite challenging (though with this book, the goal is to reduce the learning curve), so if you’re starting ROS, Linux, and Python from scratch, this could <span>be overwhelming.</span></p>
			<p class="calibre3">If you’re reading these lines and you don’t know how to write a Python function or navigate to a directory in the Terminal, then I really recommend that you pause here, take some time to learn Python and Linux basics, and come back to this book. There’s no need to spend hundreds of hours doing this but investing some time to get the basics right will help yo<a id="_idTextAnchor043" class="pcalibre calibre4 pcalibre1"/>u finish this ROS 2 <span>book faster.</span></p>
			<h2 id="_idParaDest-27" class="calibre6"><a id="_idTextAnchor044" class="pcalibre calibre4 pcalibre1"/>Hardware and software</h2>
			<p class="calibre3">You’ll <a id="_idIndexMarker033" class="pcalibre calibre4 pcalibre1"/>need to have a computer to follow this book. Regarding the specifications, you don’t need anything fancy to get started with ROS 2. If you can open a web browser with a few tabs and have a smooth experience, I would say that your computer is good enough to <span>get started.</span></p>
			<p class="calibre3">Then, later, depending on what you want to do with ROS, you might need a better machine (for example, if you want to simulate multiple robots using lots of sensor and image processing). However, it’s probably better to wait until you need the extra power to upgrade. For now, the most important thing to do is start <span>learning ROS.</span></p>
			<p class="calibre3">For software <a id="_idIndexMarker034" class="pcalibre calibre4 pcalibre1"/>requirements, I will give you the necessary installation instructions throughout this book. All the software we will be using is free to use and <span>open source.</span></p>
			<p class="calibre3">We will also use Ubuntu 24.04, in which we will run ROS 2. Having Ubuntu installed is a requirement, but I w<a id="_idTextAnchor045" class="pcalibre calibre4 pcalibre1"/>ill give you a recap in <a href="B22403_02.xhtml#_idTextAnchor048" class="pcalibre calibre4 pcalibre1"><span><em class="italic">Chapter 2</em></span></a><span>.</span></p>
			<h1 id="_idParaDest-28" class="calibre6"><a id="_idTextAnchor046" class="pcalibre calibre4 pcalibre1"/>How to follow this book</h1>
			<p class="calibre3">The book is divided into three parts, including <span>14 chapters.</span></p>
			<p class="calibre3">Each chapter can be followed individually, although for one chapter, you need the knowledge from all <span>previous chapters.</span></p>
			<p class="calibre3">If you got this book because you just want to get started from scratch, then it’s simple: follow the book in the order it’s been written. I have designed it specifically so that you learn the concepts one step at a time without having to think about what directions you <span>should take.</span></p>
			<p class="calibre3">Then, as you progress, feel free to come back to any chapter to clear up doubts. I encourage you to do that. The first time you learn about a concept, you don’t necessarily grasp all the subtleties. As you continue with this book and use the concept along with other new concepts, you often have ‘epiphany moments’, when everything <span>clicks together.</span></p>
			<p class="calibre3">If you already know some ROS 2 basics (or you’ve already read this book), then feel free to jump to any chapter. If a chapter starts from a code base that we developed in previous chapters, then you will be able to download the code and start <span>from there.</span></p>
			<p class="calibre3">There is a GitHub repository you can use to follow this book: <a href="https://github.com/PacktPublishing/ROS-2-from-Scratch" class="pcalibre calibre4 pcalibre1">https://github.com/PacktPublishing/ROS-2-from-Scratch</a>. All the code we’ll write is hosted there, so be sure to use this GitHub repository closely while following along. I will explain how to use this repository a bit later in <span>this book.</span></p>
			<h1 id="_idParaDest-29" class="calibre6"><a id="_idTextAnchor047" class="pcalibre calibre4 pcalibre1"/>Summary</h1>
			<p class="calibre3">In this introductory chapter, we cleared up some of the most common confusion points regarding ROS: its name, what it is and isn’t, when to use it, and why. You also learned more about the different ROS versions (ROS 1 and ROS 2), and you learned what kind of prerequisites you need to get started with <span>ROS 2.</span></p>
			<p class="calibre3">You should now have a better understanding of the big picture, and even if everything still seems a bit confusing, don’t worry too much—it will all make sense when you use the ROS 2 concepts and code <span>with them.</span></p>
			<p class="calibre3">Now, to be able to use ROS 2, we need to install it. This will be the focus of the next chapter and will help you get your environment 100% ready for <span>ROS 2.</span></p>
		</div>
	</body></html>