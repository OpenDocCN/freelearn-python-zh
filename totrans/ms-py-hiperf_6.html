<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Generic Optimization Options"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Generic Optimization Options</h1></div></div></div><p>In the never-ending road to mastering optimization, we started by covering some tips and tricks in <a class="link" href="ch04.html" title="Chapter 4. Optimize Everything">Chapter 4</a>, <span class="emphasis"><em>Optimize Everything</em></span>. In <a class="link" href="ch05.html" title="Chapter 5. Multithreading versus Multiprocessing">Chapter 5</a>, <span class="emphasis"><em>Multithreading versus Multiprocessing</em></span>, we went over two major optimization strategies: multithreading and multiprocessing. We saw how they help us and when to use them.</p><p>Finally, we will deal with one of the many implementations of the Python language (CPython). This implies that there are other alternatives to CPython. In this chapter, we'll cover two of them:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We'll cover PyPy, an alternative to the standard Python interpreter we've been using throughout the book. This one is written in Python and has some benefits over the standard version.</li><li class="listitem" style="list-style-type: disc">We will talk about Cython, an optimizing static compiler, which will allow us to write Python code and tap into the power of C and C++ easily.</li></ul></div><p>Both alternatives will provide developers with the opportunity to run code in a more optimized fashion, depending, of course, on the characteristics of that code. For each option, we'll look into what exactly they are, how to install them, and some example code on how to use them.</p><div class="section" title="PyPy"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec31"/>PyPy</h1></div></div></div><p>Just like CPython is<a id="id316" class="indexterm"/> the standard implementation of the Python specifications and is written in C (of course), PyPy is an alternative implementation of Python, both for version 2.x and 3.x. It tries to mimic the behavior of the language that is written in RPython, a limited version of Python with static types.</p><p>The PyPy project (<a class="ulink" href="http://pypy.org/">http://pypy.org/</a>) is a continuation of another, older project called Psycho, which <a id="id317" class="indexterm"/>was a JIT compiler for Python, written in C. It worked great on 32-bit Intel processors, but it was never updated. Its latest stable release was in 2007, so it is now <a id="id318" class="indexterm"/>deprecated. PyPy took over in 2007 with its 1.0 release. Although it was initially considered a research project, it grew over the years. Finally, in 2010, version 1.4 was released. With this version, there was an increase in confidence that systems written in PyPy were production ready and compatible with Python 2.5.</p><p>The latest stable version of PyPy, released in June 2014, is version 2.5, which, in turn, is compatible with Python 2.7. There is also a beta release of PyPy3, which is, as expected, a version of PyPy that is compatible with Python 3.x.</p><p>The reason we will <a id="id319" class="indexterm"/>go over PyPy as a viable way of optimization for our scripts is due to these features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Speed</strong></span>: One of the main features of PyPy is its speed boost over regular Python. This is due to the<a id="id320" class="indexterm"/> in-built <span class="strong"><strong>Just-in-time</strong></span> (<span class="strong"><strong>JIT</strong></span>) compiler. It provides flexibility over statically compiled code, since it can adapt to the current platform (processor type, OS version, and so on) during execution time. On the other hand, a statically compiled program would need one executable or every single combination of cases.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Memory</strong></span>: Memory-consuming scripts will consume much less memory when executed using PyPy than with regular CPython.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Sandboxing</strong></span>: PyPy provides a sandboxing environment where every call to an external C library is stubbed. These calls communicate with an external process that handles the actual policy. Although this feature is promising, it is still only a prototype and needs more work to become useful.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Stackless</strong></span>: PyPy also provides a somewhat equivalent set of language features to the ones provided by Stackless Python (<a class="ulink" href="http://www.stackless.com/">http://www.stackless.com/</a>). Some may even consider it a more powerful and flexible version than the latter.</li></ul></div><div class="section" title="Installing PyPy"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec48"/>Installing PyPy</h2></div></div></div><p>There are <a id="id321" class="indexterm"/>several ways to install PyPy into your system:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You can download the binary files directly from their page (<a class="ulink" href="http://pypy.org/download.html#default-with-a-jit-compiler">http://pypy.org/download.html#default-with-a-jit-compiler</a>). Just make sure you download the right file, according to the OS indication next to the link on their website. Otherwise, there is a good chance it won't work on your system:<div class="mediaobject"><img src="graphics/B02088_06_08.jpg" alt="Installing PyPy"/></div><p>If you're using a Linux distribution or OS X, you can check whether its official package repository contains the PyPy package. Normally, systems such as Ubuntu, Debian, Homebrew, MacPorts, Fedora, Gentoo, and Arch tend to have it already. For Ubuntu, you can use the following line of code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get install pypy</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">Finally, another option is to download the source code and compile it yourself. This might be a harder task than downloading the binaries. However, if done correctly, it would assure you that the resulting installation is fully compatible with your system.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>Be <a id="id322" class="indexterm"/>warned though, compiling from source might sound like an easy task, but it will take a considerable amount of time. On an i7 with 8 GB of RAM, the entire process took about an hour, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B02088_06_10.jpg" alt="Installing PyPy"/></div></div></div></li></ul></div></div><div class="section" title="A Just-in-time compiler"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec49"/>A Just-in-time compiler</h2></div></div></div><p>This is one<a id="id323" class="indexterm"/> of the main<a id="id324" class="indexterm"/> features provided by PyPy. It's the main reason for its superior speed results compared to regular Python (CPython).</p><p>According to PyPy's official site, the performance might vary depending on the task, but on average, this compiler claims to be seven times faster than CPython.</p><p>Normally, with standard compiled programs, we translate the entire source code into machine code before we even execute it the first time. Otherwise, we won't be able to try it. This is the standard set of steps that normally compiled programs go through (preprocessing and translation of the source code, and finally, assembling and linking).</p><p>JIT means that the compilation of our code will take place during execution time instead of before it. What normally happens is that the code is translated in a two-step process:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, the original source code is translated into an intermediate language. For some languages, such as Java, it is called bytecode.</li><li class="listitem">After we have the bytecode, we start compiling it and translating it into machine code, but only when we need it. One of the peculiarities of JIT compilers is that they only compile the code that needs to be run, and not everything at once.</li></ol></div><p>The second step is what differentiates this type of implementation from other interpreted languages, such as CPython, when the bytecode is interpreted instead of being compiled. Additionally, JIT compilers normally cache compiled code so that the next time it is needed, the overhead of compilation will be avoided.</p><p>With all of this in mind, it is clear that for a program to take real advantage of a JIT compiler, it needs to run for at least a few seconds so that the instruction caching can take effect. Otherwise, the effect might be the opposite of what is intended, since the overhead of the compilation will be the only real-time difference that the developer will notice.</p><p>One of the main <a id="id325" class="indexterm"/>advantages<a id="id326" class="indexterm"/> of using a JIT compiler is that the program being executed is able to optimize the machine code for the specific system it is running on (including CPU, OS, and so on). Thus, it provides a level of flexibility that is completely out of scope for static compiled (and even interpreted) programs.</p></div><div class="section" title="Sandboxing"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec50"/>Sandboxing</h2></div></div></div><p>Although the <a id="id327" class="indexterm"/>sandboxing feature of PyPy is still considered as a prototype, we'll cover its basics internal <a id="id328" class="indexterm"/>workings to understand the potential it provides.</p><p>Sandboxing consists of providing a safe environment where untrusted Python code can run without any fear of causing harm to the host system.</p><p>This is achieved in PyPy in particular through a two-process model:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">On one side, we have a customized version of PyPy compiled specifically to function in the sandbox mode. In particular, this means that any library or system call (I/O for instance) gets marshaled into <code class="literal">stdout</code> waiting for a marshaled response back.</li><li class="listitem">On the other hand, we have a container process, which could be running using PyPy or CPython. This process will take care of answering the library and system calls from the internal PyPy process:<div class="mediaobject"><img src="graphics/B02088_06_09.jpg" alt="Sandboxing"/></div></li></ol></div><p>The preceding diagram shows the entire process where a piece of Python code that is executed in the sandbox mode is doing an external library call.</p><p>The container<a id="id329" class="indexterm"/> process is <a id="id330" class="indexterm"/>the one that decides what type of virtualization it provides. For instance, the inner process could be creating file handlers, which, in reality, are being faked by the container process. The process acts as a layer between the real OS and the sandboxed process.</p><p>Note that the mechanics explained earlier are very different from sandboxing at the language level. The entire set of instructions is available to the developer. Thus, you achieve a very transparent and secure system with code that could very well run on a standard system and on a secured one.</p></div><div class="section" title="Optimizing for the JIT"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec51"/>Optimizing for the JIT</h2></div></div></div><p>Like we already <a id="id331" class="indexterm"/>discussed, the JIT from PyPy is what sets it apart from CPython's implementation. It is this same feature that makes it so fast when running Python code.</p><p>Just using PyPy directly on our unchanged Python code, we'll most likely get better results. However, we should take into account some guidelines if we want to optimize our code even further.</p><div class="section" title="Think of functions"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec07"/>Think of functions</h3></div></div></div><p>JIT works by analyzing which functions are "hotter" (get executed more times) than others. Thus, we're better off structuring our code into functions, specifically for functions that<a id="id332" class="indexterm"/> will be executed repeatedly.</p><p>Let's see a quick example. The following code will show the time difference between doing the same calculation directly inline versus having it encapsulated inside a function and dealing with the added time relating to the function lookup and the function call itself:</p><div class="informalexample"><pre class="programlisting">import math
import time

TIMES = 10000000

init = time.clock()
for i in range(TIMES):
    value = math.sqrt(i * math.fabs(math.sin(i - math.cos(i))))

print "No function: %s" % ( init - time.clock())

def calcMath(i):
    return math.sqrt(i * math.fabs(math.sin(i - math.cos(i))))
init = time.clock()
for i in range(TIMES):
    value = calcMath(i)
print "Function: %s" % ( init – time.clock())</pre></div><p>The code is very <a id="id333" class="indexterm"/>simple, but you can still see how the second output shows that it is the faster implementation. Regular old CPython will work the opposite way, since there is no real-time optimization of the code. The second approach will yield slightly worse results because of the overhead of the function lookup and function call code. However, PyPy and its JIT prove once again that if you want to optimize your code for them, you need to stop thinking the old way.</p><div class="mediaobject"><img src="graphics/B02088_06_11.jpg" alt="Think of functions"/></div><p>The results from the preceding screenshot show what we've been discussing so far:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">PyPy runs the same code considerably faster than CPython</li><li class="listitem" style="list-style-type: disc">The JIT is optimizing our code in real time while CPython isn't</li></ul></div></div><div class="section" title="Consider using cStringIO to concatenate strings"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec08"/>Consider using cStringIO to concatenate strings</h3></div></div></div><p>This is not a <a id="id334" class="indexterm"/>small <a id="id335" class="indexterm"/>optimization, with respect to both code changes and achieved optimization. We've already covered the fact that for Python, strings are immutable objects. So, if we want to concatenate a large number of strings into a single one, we would be better off doing it with another structure instead of the string itself, since that would yield the worst performance.</p><p>In the case of PyPy, it still holds true. However, instead of using lists as the best option, we'll use the <a id="id336" class="indexterm"/>
<code class="literal">cStringIO</code> module (<a class="ulink" href="http://pymotw.com/2/StringIO/">http://pymotw.com/2/StringIO/</a>), which, as we'll see, provides the best results.</p><p>Note that because of the nature of PyPy, mentioning <code class="literal">cStringIO</code> instead of <code class="literal">StringIO</code> might be confusing, since we're referencing a C standard library instead of a pure Python one. This is correct and valid, since some of the C standard libraries common to CPython<a id="id337" class="indexterm"/> also work <a id="id338" class="indexterm"/>correctly on PyPy. In our case, the following code will calculate the time needed to perform the same concatenation operation in three different ways (using simple strings, using the <code class="literal">cStringIO</code> library, and finally, using lists):</p><div class="informalexample"><pre class="programlisting">from cStringIO import StringIO
import time

TIMES = 100000

init = time.clock()
value = ''
for i in range(TIMES):
    value += str(i)
print "Concatenation: %s" % ( init - time.clock())

init = time.clock()
value = StringIO()
for i in range(TIMES):
    value.write(str(i))
print "StringIO: %s" % ( init - time.clock())

init = time.clock()
value = []
for i in range(TIMES):
    value.append(str(i))
finalValue = ''.join(value)
print "List: %s" % ( init - time.clock())</pre></div><p>Out of the three alternatives, <code class="literal">StringIO</code> is the best one in PyPy. It is much better than simple string concatenation, and even slightly better than using lists.</p><p>If we run the same code through CPython, we will get different results. Thus, the best solution is still using lists.</p><div class="mediaobject"><img src="graphics/B02088_06_12.jpg" alt="Consider using cStringIO to concatenate strings"/></div><p>The <a id="id339" class="indexterm"/>preceding <a id="id340" class="indexterm"/>screenshot corroborates this. Note how with PyPy, the first approach is especially bad performance-wise.</p></div><div class="section" title="Actions that disable the JIT"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec09"/>Actions that disable the JIT</h3></div></div></div><p>Although not<a id="id341" class="indexterm"/> directly an optimization, there are some specific methods that will disable the effectiveness of the JIT if we use them. So, it's important to know about these methods.</p><p>The following three methods from the <code class="literal">sys</code> module disable the JIT (according to the current version of PyPy; this could, of course, change in the future):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">_getframe</code>: This method returns a frame object from the <code class="literal">callstack</code>. It even accepts an optional depth parameter that returns frame objects back from the <code class="literal">callstack</code>. The performance penalty is quite big, so its use is recommended only when it is absolutely needed, such as when developing a debugger.</li><li class="listitem" style="list-style-type: disc"><code class="literal">exc_info</code>: This method returns a tuple of three elements that provide information about the exception being handled. These elements are <code class="literal">type</code>, <code class="literal">value</code>, and <code class="literal">traceback</code>. They are explained here:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">type</code>: This is the type of the exception being handled</li><li class="listitem" style="list-style-type: disc"><code class="literal">value</code>: This gets the exception parameter</li><li class="listitem" style="list-style-type: disc"><code class="literal">traceback</code>: This gets the <code class="literal">traceback</code> object, which encapsulates a <code class="literal">callstack</code> object the moment the exception was thrown</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">Settrace</code>: This method sets the tracing function, which allows you to trace Python code from within Python. As mentioned earlier, its use is not recommended unless it is absolutely necessary, since it needs to disable the JIT in order to work properly.</li></ul></div></div></div><div class="section" title="Code sample"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec52"/>Code sample</h2></div></div></div><p>As a final example for this topic, let's take a look at the code from the <code class="literal">great_circle</code> function (explained later). The great circle calculation consists of finding the distance between two <a id="id342" class="indexterm"/>points on the earth's surface.</p><p>The script will do a <code class="literal">for</code> loop of 5 million iterations. In particular, it calls the same function over and over (5 million times to be precise). This scenario is less than ideal for the CPython interpreter, since it will complete the function lookup that many times.</p><p>However, on the other hand and as we've already mentioned, calling the same function over time allows for PyPy's JIT to start optimizing that call. This basically means that in our case, the code is already somewhat optimized for PyPy:</p><div class="informalexample"><pre class="programlisting">import math

def great_circle(lon1,lat1,lon2,lat2):
    radius = 3956 #miles
    x = math.pi/180.0

    a = (90.0-lat1)*(x)
    b = (90.0-lat2)*(x)
    theta = (lon2-lon1)*(x)
    c = math.acos((math.cos(a)*math.cos(b)) + (math.sin(a)*math.sin(b)*math.cos(theta))) 
    return radius*c


lon1, lat1, lon2, lat2 = -72.345, 34.323, -61.823, 54.826
num = 5000000

for i in range(num):great_circle(lon1,lat1,lon2,lat2)</pre></div><p>The preceding code can be further optimized following the same principle we just mentioned. We can remove one line from the <code class="literal">great_circle</code> function into a separate function, optimizing that execution even further, as shown here:</p><div class="informalexample"><pre class="programlisting">import math

<span class="strong"><strong>def calcualte_acos(a, b ,theta):</strong></span>
<span class="strong"><strong>  return math.acos((math.cos(a)*math.cos(b)) + (math.sin(a)*math.sin(b)*math.cos(theta)))</strong></span>

def great_circle(lon1,lat1,lon2,lat2):
    radius = 3956 #miles
    x = math.pi/180.0

    a = (90.0-lat1)*(x)
    b = (90.0-lat2)*(x)
    theta = (lon2-lon1)*(x)
    <span class="strong"><strong>c = calcualte_acos(a, b, theta)</strong></span>
    return radius*c


lon1, lat1, lon2, lat2 = -72.345, 34.323, -61.823, 54.826
num = 5000000

for i in range(num):
  great_circle(lon1,lat1,lon2,lat2)</pre></div><p>You can see how<a id="id343" class="indexterm"/> we moved the <code class="literal">acos</code> calculation into a separate function, since it was the most expensive line in the entire function (there is a total of six trig functions being called there). By moving that line into another function, we allowed the JIT to take care of optimizing its calls.</p><p>In the end, due to that simple change and the fact that we're using PyPy instead of regular Python, we have an execution time of 0.5 seconds. If, on the other hand, we were to run that same code using regular CPython, we would get a time of 4.5 seconds (on my current machine), which is considerably slower.</p></div></div></div>
<div class="section" title="Cython"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec32"/>Cython</h1></div></div></div><p>Although technically, Cython (<a class="ulink" href="http://cython.org/">http://cython.org/</a>) is not exactly an alternative to using the<a id="id344" class="indexterm"/> standard CPython<a id="id345" class="indexterm"/> interpreter, it will let us write Python code and compile it into C (something CPython doesn't do).</p><p>You'll see that Cython could be considered a transpiler, which simply means it's a piece of software meant to translate source code from one language into another. There are other similar products out there, such as CoffeeScript and Dart. Both are very different languages, and both are translated into JavaScript.</p><p>In our case, Cython translates a super set of Python (an extended version of the language) into optimized C/C++ code. Then, it's compiled into a Python extension module. This, in turn, allows the developer to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Write Python code that calls back and forth C or C++ code natively</li><li class="listitem" style="list-style-type: disc">Tune Python code into C-level performance using static-type declarations</li></ul></div><p>Static typing is the key feature that allows this transpiler to generate optimized C code, thus letting Cython move out of the dynamic nature of Python into a more static, yet faster, territory (sometimes, even by several orders of magnitude).</p><p>This, of course, makes the Python code more verbose, which, in turn, might hurt other aspects <a id="id346" class="indexterm"/>such as maintainability and readability. So, normally, using static typing is not recommended unless there is some kind of proof that clearly shows that adding it will indeed generate a faster running code.</p><p>All C types are available for developers to use. Cython is prepared to automatically perform type conversion on assignment. In the special case of Python's arbitrary long integers, when casting to C's integers, a Python overflow error will be raised if an overflow does happen.</p><p>The following table shows the same example written in pure Python and the Cython version:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Python version</p>
</th><th style="text-align: left" valign="bottom">
<p>Cython version</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def</strong></span> f(x):
    <span class="strong"><strong>return</strong></span> x<span class="strong"><strong>**2</strong></span>-x

<span class="strong"><strong>def</strong></span> integrate_f(a, b, N):
    s <span class="strong"><strong>=</strong></span> <span class="strong"><strong>0</strong></span>
    dx <span class="strong"><strong>=</strong></span> (b-a)/N
    <span class="strong"><strong>for</strong></span> i <span class="strong"><strong>in range</strong></span>(N):
        s <span class="strong"><strong>+=</strong></span> f(a<span class="strong"><strong>+</strong></span>i<span class="strong"><strong>*</strong></span>dx)
    <span class="strong"><strong>return</strong></span> s <span class="strong"><strong>*</strong></span> dx</pre></div>
 </td><td style="text-align: left" valign="top">
<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def</strong></span> f(<span class="strong"><strong>double</strong></span> x):
    <span class="strong"><strong>return</strong></span> x<span class="strong"><strong>**2</strong></span>-x

<span class="strong"><strong>def</strong></span> integrate_f(<span class="strong"><strong>double</strong></span> a, <span class="strong"><strong>double</strong></span> b, <span class="strong"><strong>int</strong></span> N):
    <span class="strong"><strong>cdef int i</strong></span>
    <span class="strong"><strong>cdef double s, dx</strong></span>
    s <span class="strong"><strong>=</strong></span> <span class="strong"><strong>0</strong></span>
    dx <span class="strong"><strong>=</strong></span> (b<span class="strong"><strong>-</strong></span>a)<span class="strong"><strong>/</strong></span>N
    <span class="strong"><strong>for</strong></span> i <span class="strong"><strong>in range</strong></span>(N):
        s <span class="strong"><strong>+=</strong></span> f(a<span class="strong"><strong>+</strong></span>i<span class="strong"><strong>*</strong></span>dx)
    <span class="strong"><strong>return</strong></span> s <span class="strong"><strong>*</strong></span> dx</pre></div>
</td></tr></tbody></table></div><p>The main difference in both codes is highlighted. It is only the definition of the types of every variable, both the parameters received by both functions, and the local variables used. With this alone, Cython can generate an optimized C version of the code on the left-hand side.</p><div class="section" title="Installing Cython"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec53"/>Installing Cython</h2></div></div></div><p>There are a couple<a id="id347" class="indexterm"/> of ways to install Cython into your system. However, for every case, the common requirement is to have a C compiler previously installed. We will not go over the steps required for this, because the instructions might vary from system to system.</p><p>Once the C compiler is installed, in order to get Cython, you can perform these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download the<a id="id348" class="indexterm"/> latest release<a id="id349" class="indexterm"/> from their website (<a class="ulink" href="http://cython.org">http://cython.org</a>), unpack the tarball file, enter the directory, and run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$python setup.py install</strong></span>
</pre></div></li><li class="listitem">If you have the setup tools installed in your system, you can run this command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$pip install cython</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>If you're already using one of the following development environments, it's quite likely that Cython is already installed in your system. However, you can use the earlier steps to update your current version as well:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Anaconda</li><li class="listitem" style="list-style-type: disc">Enthought Canopy</li><li class="listitem" style="list-style-type: disc">PythonXY</li><li class="listitem" style="list-style-type: disc">Sage</li></ul></div></div></div></li></ol></div></div><div class="section" title="Building a Cython module"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec54"/>Building a Cython module</h2></div></div></div><p>Cython is able to <a id="id350" class="indexterm"/>compile our code into C modules, which we can later import into our main code. In order to do this, you need to carry out the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, a <code class="literal">.pyx</code> file needs to be compiled (or translated) into a <code class="literal">.c</code> file by Cython. These are the source code files, basically Python code with some extensions added by Cython. We'll see some examples in a bit.</li><li class="listitem">The <code class="literal">.c</code> file will, in turn, be compiled into a <code class="literal">.so</code> library by the C compiler. This library can later be imported by Python.</li><li class="listitem">There are several ways in which we can compile the code, as explained earlier:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We can create a <code class="literal">distutils</code> setup file. Distutils is a module that facilitates the creation of other modules, so we can use it to generate our custom C-compiled ones.</li><li class="listitem" style="list-style-type: disc">We can run the <code class="literal">cython</code> command line to create a <code class="literal">.c</code> file from the <code class="literal">.pyx</code> one. Then, use the C compiler to manually compile the C code into the library.</li><li class="listitem" style="list-style-type: disc">Finally, another option would be to use the <code class="literal">pyximport</code> module and import the <code class="literal">.pyx</code> files as if they were <code class="literal">.py</code> files.</li></ul></div></li><li class="listitem">To illustrate the preceding points, let's look at an example using the <code class="literal">distutils</code> option:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#test.pyx</strong></span>
def join_n_print(parts):
    print ' '.join(parts)

<span class="strong"><strong>#test.py</strong></span>
from test import join_n_print
join_n_print( ["This", "is", "a", "test"] )

<span class="strong"><strong>#setup.py</strong></span>
from distutils.core import setup
from Cython.Build import cythonize

setup(
  name = 'Test app',
  ext_modules = cythonize("test.pyx"),
)</pre></div></li><li class="listitem">That's it! The preceding code that is to be exported should be inside the <code class="literal">.pyx</code> file. The <code class="literal">setup.py</code> file will normally be the same. It will call the <code class="literal">setup</code> function with different variations of the parameters. Finally, it will call the <code class="literal">test.py</code> file, which imports our compiled library and makes use of it.</li><li class="listitem">To effectively compile the code, you can use the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python setup.py build_ext –inplace</strong></span>
</pre></div></li></ol></div><p>The following <a id="id351" class="indexterm"/>screenshot shows the output from the preceding command. You can see how it doesn't just translate (cythonize) the code, but also compiles the library using the C compiler installed:</p><div class="mediaobject"><img src="graphics/B02088_06_01.jpg" alt="Building a Cython module"/></div><p>The preceding example shows a very simple module. However, normally, for more complex cases, a Cython module is comprised of two types of files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Definition files</strong></span>: These <a id="id352" class="indexterm"/>have a <code class="literal">.pxd</code> extension and contain C declarations of names that need<a id="id353" class="indexterm"/> to be available to other Cython modules.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Implementation files</strong></span>: These<a id="id354" class="indexterm"/> have a <code class="literal">.pyx</code> extension and contain the actual implementation <a id="id355" class="indexterm"/>of the functions declared on the <code class="literal">.pxd</code> files.</li></ul></div><p>Definition files <a id="id356" class="indexterm"/>normally contain C type declarations, external C functions or variable declarations, and declarations of C functions defined in the module. They cannot contain the implementation of any C or Python function, nor can they contain the definition of any <code class="literal">Python</code> class or any executable lines.</p><p>On the other hand, an implementation file can have almost any kind of Cython statement.</p><p>Here is a <a id="id357" class="indexterm"/>typical two-file module example taken from Cython's official documentation (<a class="ulink" href="http://docs.cython.org/src/userguide/sharing_declarations.html">http://docs.cython.org/src/userguide/sharing_declarations.html</a>); it shows how to import <code class="literal">.pxd</code> files:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#dishes.pxd</strong></span>
cdef enum otherstuff:
    sausage, eggs, lettuce

cdef struct spamdish:
    int oz_of_spam
    otherstuff filler

<span class="strong"><strong>#restaurant.pyx:</strong></span>
cimport dishes
from dishes cimport spamdish

cdef void prepare(spamdish *d):
    d.oz_of_spam = 42
    d.filler = dishes.sausage

def serve():
    cdef spamdish d
    prepare(&amp;d)
    print "%d oz spam, filler no. %d" % (d.oz_of_spam, d.filler)</pre></div><p>By default, when <code class="literal">cimport</code> is executed, it will look for a file called <code class="literal">modulename.pxd</code> in the search path. Whenever the definition file changes, each file importing it will need to be recompiled. Luckily, for us, the <code class="literal">Cythin.Build.cythonize</code> utility will take care of that.</p></div><div class="section" title="Calling C functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec55"/>Calling C functions</h2></div></div></div><p>Just like regular Python, Cython allows the developer to directly interface with C by calling<a id="id358" class="indexterm"/> functions compiled in external libraries. To import these libraries, the procedure is similar to the standard Python procedure:</p><div class="informalexample"><pre class="programlisting">from libc.stdlib cimport atoi</pre></div><p>The <code class="literal">cimport</code> statement is used in implementation or definition files in order to gain access to names declared in other files. Its syntax is exactly the same as standard Python's <code class="literal">import</code> statement.</p><p>If you also need to access the definition of some types defined in a library, you would need the header file (<code class="literal">.h</code> file). For these cases, with Cython it is not as simple as referencing the file. You'll also need to redeclare the types and structures you will use:</p><div class="informalexample"><pre class="programlisting">cdef extern from "library.h":
  int library_counter;
  char *pointerVar;</pre></div><p>The preceding example performs the following actions for Cython:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It lets Cython know how to place a <code class="literal">#include</code> statement in the generated C code, referencing the library we're including</li><li class="listitem" style="list-style-type: disc">It prevents Cython from generating any C code for the declarations inside the block</li><li class="listitem" style="list-style-type: disc">It treats all declarations inside the block as if they were made with <code class="literal">cdef extern</code>, which, in turn, means those declarations are defined elsewhere</li></ul></div><p>Note that this syntax is required because Cython does not, at any moment, read the content of the header file. So, you still need to redeclare the content for it. As a caveat, you technically only need to redeclare the part that you'll use, leaving out anything that's not directly needed by your code. For instance, if you had a big structure declared in your header file with a lot of members, you could redeclare it with only the members you'd need. This would work since during compiling time, the C compiler would use the original code with the full version of the structure.</p><div class="section" title="Solving naming conflicts"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec10"/>Solving naming conflicts</h3></div></div></div><p>An interesting problem arises when names from the imported functions are the same as the ones<a id="id359" class="indexterm"/> from your functions.</p><p>Say, you have your <code class="literal">myHeader.h</code> file that defines the <code class="literal">print_with_colors</code> function, and you need to wrap it in some Python function that you also want to call <code class="literal">print_with_colors</code>; Cython provides a way for you to work around this and keep the names as you want them.</p><p>You can add <code class="literal">extern</code> C function declarations into a Cython declaration file (<code class="literal">.pxd</code> file) and then <code class="literal">cimport</code> it into your Cython code file as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#my_declaration.pxd</strong></span>
cdef extern "myHeader.h":
  void print_with_colors(char *)

<span class="strong"><strong>#my_cython_code.pyx</strong></span>
from my_declaration cimport print_with_colors as c_print_with_colors

def print_with_colors(str):
  c_print_with_colors(str)</pre></div><p>You can also avoid renaming the function and use the name of the declaration file as a prefix:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#my_cython_code.pyx</strong></span>
cimport  my_declaration 
def print_with_colors(str):
  my_declaration.print_with_colors(str)</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>Both alternatives are valid, and the decision of using one over the other is completely up to the developer. For more information on this subject, head to: <a class="ulink" href="http://docs.cython.org/src/userguide/external_C_code.html">http://docs.cython.org/src/userguide/external_C_code.html</a>.</p></div></div></div></div><div class="section" title="Defining types"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec56"/>Defining types</h2></div></div></div><p>As mentioned earlier, Cython allows the developer to define the type of a variable or the return <a id="id360" class="indexterm"/>type of a function. In both cases, the keyword used for this is <code class="literal">cdef</code>. Typing is actually optional, since Cython will try to optimize the Python code by turning it into C. That being said, defining the static types where they're needed will certainly help.</p><p>Let's now look at a very basic example of a piece of code in Python and how the same code executes in its three versions: pure Python, compiled by Cython without typing, and finally, compiled and using typing.</p><p>The code is as follows:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Python</p>
</th><th style="text-align: left" valign="bottom">
<p>Cython</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="informalexample"><pre class="programlisting">def is_prime(num):
  for j in range(2,num):
    if (num % j) == 0:
      return False
  return True</pre></div>
</td><td style="text-align: left" valign="top">
<div class="informalexample"><pre class="programlisting">def is_prime(<span class="strong"><strong>int</strong></span> num):
  <span class="strong"><strong>cdef int j;</strong></span>
  for j in range(2,num):
    if (num % j) == 0:
      return False
  return True</pre></div>
</td></tr></tbody></table></div><p>Thanks to the fact that we're declaring the <code class="literal">for</code> loop variable as a C integer. Cython will turn this loop into an optimized C <code class="literal">for</code> loop, which will be one of the major improvements to this code.</p><p>Now, we will set up a main file that will import that function:</p><div class="informalexample"><pre class="programlisting">import sys
from &lt;right-module-name&gt; import is_prime


def main(argv):

  if (len(sys.argv) != 3):
    sys.exit('Usage: prime_numbers.py &lt;lowest_bound&gt; &lt;upper_bound&gt;')

  low = int(sys.argv[1])
  high = int(sys.argv[2])

  for i in range(low,high):
    if is_prime(i):
      print i,

if __name__ == "__main__":
  main(sys.argv[1:])</pre></div><p>Then, we will execute our script like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ time python script.py 10 10000</strong></span>
</pre></div><p>We will get the following interesting results:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Pure Python version</p>
</th><th style="text-align: left" valign="bottom">
<p>Compiled without typing</p>
</th><th style="text-align: left" valign="bottom">
<p>Compiled with typing</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>0.792 seconds</p>
</td><td style="text-align: left" valign="top">
<p>0.694 seconds</p>
</td><td style="text-align: left" valign="top">
<p>0.043 seconds</p>
</td></tr></tbody></table></div><p>Even though<a id="id361" class="indexterm"/> the non-optimized version of the code is faster than the pure Python one, we only see the real power of Cython when we start declaring the types.</p></div><div class="section" title="Defining types during function definitions"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec57"/>Defining types during function definitions</h2></div></div></div><p>There are two different types of functions that can be defined in Cython:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Standard Python functions</strong></span>: These are normal functions that are exactly like the ones <a id="id362" class="indexterm"/>declared in pure Python code. To do this, you need the standard <code class="literal">cdef</code> keyword, and these functions will receive Python objects as parameters and also return Python objects.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>C functions</strong></span>: These <a id="id363" class="indexterm"/>are the optimized versions of the standard functions. They take either Python objects or C values as parameters and can also return both. To define these, you need the special <code class="literal">cdef</code> keyword.</li></ul></div><p>Either type <a id="id364" class="indexterm"/>of function can be called from within a Cython module. However (and this is a very important difference), if you want to call your functions from within your Python code, you either need to make sure the function is declared as standard or you need to use the special <code class="literal">cpdef</code> keyword. This keyword will create a wrapper object for the function. So, when the function is called from within Cython, it'll use the C function, and when called from within Python code, it'll use the Python version.</p><p>When dealing with C types for the parameters of the function, an automatic conversion will be done (if possible) from the Python object to the C value. This is only currently possible for numeric types, <code class="literal">strings</code>, and <code class="literal">struct</code> types. If you attempt to use any other type, it will result in a compile-time error.</p><p>The following simple example illustrates the difference between both modes:</p><div class="informalexample"><pre class="programlisting">#my_functions.pxd

#this is a pure Python function, so Cython will create a make it return and receive Python objects instead of primitive types.
cdef full_python_function (x):
    return x**2

#This function instead, is defined as both, a standard function and an optimized C function, thanks to the use of the cpdef keyword.
cpdef int c_function(int num):
    return x**2</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>If the return type or the type of parameter is left undefined, then it will be assumed to be a Python object.</p></div></div><p>Finally, C functions that don't return a Python object have no way to report Python exceptions to its <a id="id365" class="indexterm"/>caller. So, when an error occurs, a warning message is printed and the exception is ignored. This is, of course, far from ideal. Luckily, for us, there is a way around this.</p><p>We can use the <code class="literal">except</code> keyword during function definition. This keyword specifies that whenever an exception occurs inside the function, a specific value will be returned. Here is an example:</p><div class="informalexample"><pre class="programlisting">cdef int text(double param) except -1:</pre></div><p>With the preceding code, whenever an exception occurs, <code class="literal">-1</code> will be returned. It is important that you don't manually return the exception value from your function. This is especially relevant if you define <code class="literal">False</code> to be your exception value because any <code class="literal">False</code> value will do here.</p><p>For cases where any possible return value is a valid return value, then there is an alternate notation that you can use:</p><div class="informalexample"><pre class="programlisting">cdef int text(double param) except? -1:</pre></div><p>The <code class="literal">?</code> sign sets <code class="literal">-1</code> as a possible exception value. When returned, Cython will call <code class="literal">PyErr_Occurred()</code> to make sure that it is really an error and not just a normal return action.</p><p>There is one more variation of the <code class="literal">except</code> keyword, which makes sure to call <code class="literal">PyErr_Occurred()</code> after every return:</p><div class="informalexample"><pre class="programlisting">cdef int text(double param) except *:</pre></div><p>The only real use of the preceding notation is for functions returning <code class="literal">void</code> that need to propagate errors. This is because in these special cases, there is no value to check; otherwise, there is no real use case for it.</p></div><div class="section" title="A Cython example"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec58"/>A Cython example</h2></div></div></div><p>Let's take a quick look at the same example we used for PyPy. It shows us how to improve the <a id="id366" class="indexterm"/>performance of a script. The code will again do the same calculation 5 million times: from math, import <code class="literal">PI</code>, <code class="literal">acos</code>, <code class="literal">cos</code>, and <code class="literal">sin</code>:</p><div class="informalexample"><pre class="programlisting">def great_circle(lon1,lat1,lon2,lat2):
    radius = 3956 #miles
    x = PI/180.0

    a = (90.0-lat1)*(x)
    b = (90.0-lat2)*(x)
    theta = (lon2-lon1)*(x)
    c = acos((cos(a)*cos(b)) +

                  (sin(a)*sin(b)*cos(theta)))
    return radius*c</pre></div><p>Then, we will test it by running the function 5,000,000 times with the following script:</p><div class="informalexample"><pre class="programlisting">from great_circle_py import great_circle

lon1, lat1, lon2, lat2 = -72.345, 34.323, -61.823, 54.826
num = 5000000

for i in range(num):
  great_circle(lon1,lat1,lon2,lat2)</pre></div><p>Again, as I've already mentioned earlier, if we run this script using the time command-line utility from Linux with the CPython interpreter, we will see that the resulting execution takes around 4.5 seconds to run (in my current system). Your numbers will most likely be different.</p><p>Instead of going to the profiler, like we did in earlier chapters, we'll go directly to Cython now. We'll implement some of the improvements we've been discussing into a Cython module that we can import from our test script.</p><p>Here's our first try at it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#great_circle_cy_v1.pyx</strong></span>
from math import pi as PI, acos, cos, sin

def great_circle(double lon1,double lat1,double lon2,double lat2):
    cdef double a, b, theta, c, x, radius

    radius = 3956 #miles
    x = PI/180.0

    a = (90.0-lat1)*(x)
    b = (90.0-lat2)*(x)
    theta = (lon2-lon1)*(x)
    c = acos((cos(a)*cos(b)) +
                  (sin(a)*sin(b)*cos(theta)))
    return radius*c
<span class="strong"><strong>#great_circle_setup_v1.py</strong></span>
from distutils.core import setup
from Cython.Build import cythonize

setup(
  name = 'Great Circle module v1',
  ext_modules = cythonize("great_circle_cy_v1.pyx"),
)</pre></div><p>As you can <a id="id367" class="indexterm"/>see in the preceding code, all we did was give a C type to all the variables and parameters we're using in our code. This alone took the execution time from 4.5 seconds down to 3. We shaved off 1.5 seconds, but we can probably do better.</p><p>Our code is still using a Python library <code class="literal">math.</code> Since Cython allows us to mix Python and C libraries, it comes in handy when we're in a hurry. It takes care of the conversions for us, but as we can see here, not without a cost. Let's now try to remove the dependency of that Python library and call upon C's <code class="literal">math.h</code> file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#great_circle_cy_v2.pyx</strong></span>
cdef extern from "math.h":
    float cosf(float theta)
    float sinf(float theta)
    float acosf(float theta)

def great_circle(double lon1,double lat1,double lon2,double lat2):
    cdef double a, b, theta, c, x, radius
    cdef double pi = 3.141592653589793

    radius = 3956 #miles
    x = pi/180.0

    a = (90.0-lat1)*(x)
    b = (90.0-lat2)*(x)
    theta = (lon2-lon1)*(x)
    c = acosf((cosf(a)*cosf(b)) +
                  (sinf(a)*sinf(b)*cosf(theta)))
    return radius*c</pre></div><p>After removing all <a id="id368" class="indexterm"/>references to the math Python library and working directly with C's <code class="literal">math.h</code> file, we went from the 3.5 seconds in our previously optimized code to an amazing 0.95 seconds.</p></div><div class="section" title="When to define a type"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec59"/>When to define a type</h2></div></div></div><p>The previous <a id="id369" class="indexterm"/>example might seem obvious and simple to optimize. However, for bigger scripts, redeclaring every variable as a C variable and importing all C libraries instead of Python ones (whenever possible) is not always the best way to go.</p><p>Going about it this way will lead to readability and maintainability issues. It will also hurt the inherent flexibility of Python code. It could, in fact, even end up hurting the performance by adding unnecessary type checks and conversions. So, there must be a way to determine the best places to add types and switch libraries. This way is using Cython. Cython comes with the ability to annotate your source code and show you, very graphically, how each line of code can be translated into C code.</p><p>Using the <code class="literal">-a</code> attribute in Cython, you can generate an HTML file that will highlight your code with yellow. The more yellow a line is, the more C-API interactions are required to translate that piece of code into C. White lines (lines without any color) are directly translated into C. Let's look at how our original code is rendered under this new tool:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cython -a great_circle_py.py</strong></span>
</pre></div><p>The following screenshot shows the HTML file generated from the preceding command:</p><div class="mediaobject"><img src="graphics/B02088_06_02.jpg" alt="When to define a type"/></div><p>We can clearly <a id="id370" class="indexterm"/>see that most of our code needs at least a few interactions with the C-API in order to be translated into C (only line 4 is completely white). It is important to understand that our aim should be to get as many lines to white as possible. The lines with a <span class="strong"><strong>+</strong></span> sign indicate that they can be clicked, and the C code generated will be displayed, as shown here:</p><div class="mediaobject"><img src="graphics/B02088_06_03.jpg" alt="When to define a type"/></div><p>Now, by looking at our results, we can see that the lighter yellow lines are the simple assignments (lines 5, 7, 8, and 9). They can be easily fixed by doing what we initially did: declare those variables as C variables instead of letting them be Python objects, which would require us to convert code.</p><p>By doing the <a id="id371" class="indexterm"/>conversion, we will get something like the next screenshot. This screenshot shows the resulting report from analyzing the <code class="literal">great_circle_cy_v1.pyx</code> file:</p><div class="mediaobject"><img src="graphics/B02088_06_04.jpg" alt="When to define a type"/></div><p>Much better! Now, those lines are fully white, except line 7, which is still light yellow. This is, of course, because that line is actually referencing the <code class="literal">math.pi</code> object. We could fix it simply by initializing the <code class="literal">pi</code> variable with a fixed value of <code class="literal">PI</code>. However, we still have the big <a id="id372" class="indexterm"/>yellow block, that is, lines 12 and 13. This is also due to our usage of the <code class="literal">math</code> library. So, after we get rid of it, we will get the following file:</p><div class="mediaobject"><img src="graphics/B02088_06_05.jpg" alt="When to define a type"/></div><p>The preceding screenshot shows the final code we presented earlier. Almost all of our code is directly translatable to C, and we got a good performance out of it. Now, we still have two yellow lines: 6 and 18.</p><p>We can't do much about line 6 because that function is the Python function we need to execute. If we were to declare it with <code class="literal">cdef</code>, we would not have access to it. However, again, line 18 is not completely white. This is because <code class="literal">great_circle</code> is a Python function and the returned value is a Python object, which needs to be wrapped and translated into a C value. If we click on it, we can see the generated code:</p><div class="mediaobject"><img src="graphics/B02088_06_06.jpg" alt="When to define a type"/></div><p>The only way we <a id="id373" class="indexterm"/>can fix this is by declaring our function with <code class="literal">cpdef</code>, which will create a wrapper for it. However, it will also let us declare the return type. So, we're no longer returning a Python object. Instead, we're returning a <code class="literal">double</code> value, and the resulting code and annotated screenshot is as follows:</p><div class="mediaobject"><img src="graphics/B02088_06_07.jpg" alt="When to define a type"/></div><p>We can see how the C code generated for the returned statement got simplified with this latest change. The performance got a small boost as well, since we went from 0.95 seconds down to 0.8 seconds.</p><p>Thanks to our<a id="id374" class="indexterm"/> analysis of the code, we were able to go one step further and optimize it a bit more. This technique is a good way to check your progress when optimizing code for Cython. This technique provides a visual and simple indicator of the complexity of the optimized code.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>Note that in this particular case, the results obtained from going the Cython route for this optimization are not as good as the ones obtained using PyPy earlier in this chapter (0.8 seconds with Cython versus 0.5 seconds with PyPy).</p></div></div></div><div class="section" title="Limitations"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec60"/>Limitations</h2></div></div></div><p>Everything we've seen so far seems to indicate that Cython is a perfectly viable option to our<a id="id375" class="indexterm"/> performance needs. However, the truth is that Cython is not yet 100 percent compatible with the Python syntax. Sadly, there are some limitations that we need to take into consideration before deciding to use this tool for our performance enhancement needs. From the current list of public bugs on the project, we can gather the list of current limitations.</p><div class="section" title="Generator expressions"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec11"/>Generator expressions</h3></div></div></div><p>These expressions are currently the ones that suffer the most, since they have several issues in the <a id="id376" class="indexterm"/>current version of Cython. These issues are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using iterables inside the generator expression causes a problem since there are issues with the evaluation scope.</li><li class="listitem" style="list-style-type: disc">Also, related to iterables inside a generator, Cython appears to be evaluating them inside the generator's body. On the other hand, CPython does it outside, before creating the actual generator.</li><li class="listitem" style="list-style-type: disc">Generators in Cpython have attributes that allow for introspection. Cython is still not fully up to date when it comes to supporting those attributes.</li></ul></div></div><div class="section" title="Comparison of char* literals"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec12"/>Comparison of char* literals</h3></div></div></div><p>The current implementation of Cython performs comparsons of byte literals based on the<a id="id377" class="indexterm"/> pointers used, instead of the actual value of the string.</p><div class="informalexample"><pre class="programlisting">cdef char* str = "test string"
print str == b"test string"</pre></div><p>The preceding code will not always print <code class="literal">True</code>. It will depend on the pointer used to store the first string instead of depending on the actual string value.</p></div><div class="section" title="Tuples as function arguments"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec13"/>Tuples as function arguments</h3></div></div></div><p>Although <a id="id378" class="indexterm"/>only a Python 2 feature, the language allows for the following syntax:</p><div class="informalexample"><pre class="programlisting">def myFunction( (a,b) ):
  return a + b
args = (1,2)
print myFunction(args)</pre></div><p>However, the preceding code is not even correctly parsed by Cython. This particular feature is flagged as probably "not fixable" in the future of Cython, since Python 3.x has removed it as well.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>Note that the Cython team is expecting to fix most of the limitations mentioned earlier by the time they release version 1.0.</p></div></div></div><div class="section" title="Stack frames"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec14"/>Stack frames</h3></div></div></div><p>Currently, Cython is generating fake tracebacks as part of its exception propagation mechanics. They're <a id="id379" class="indexterm"/>not filling in <code class="literal">locals</code> and <code class="literal">co_code</code> values. In order to do this properly, they would have to generate the stack frames on function call time, incurring in a potential performance penalty. So, it is unclear whether they will fix this in the future or not.</p></div></div></div>
<div class="section" title="How to choose the right option"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec33"/>How to choose the right option</h1></div></div></div><p>Up to this point, we've gone over two different alternatives to radically optimize our code. However, how <a id="id380" class="indexterm"/>do we know which one is the right one? Or even better, which one is the best one?</p><p>The answer to both those questions is the same: <span class="emphasis"><em>there is no single best or right one</em></span>. Whether one of the options is better or worse depends entirely on one or more of these aspects:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The actual use case you're trying to optimize</li><li class="listitem" style="list-style-type: disc">The familiarity of the developer with either Python or C</li><li class="listitem" style="list-style-type: disc">The importance of readability of your optimized code</li><li class="listitem" style="list-style-type: disc">The amount of time at hand to perform the optimization</li></ul></div><div class="section" title="When to go with Cython"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec61"/>When to go with Cython</h2></div></div></div><p>Here are the <a id="id381" class="indexterm"/>situations <a id="id382" class="indexterm"/>when you should go with Cython:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>You're familiar with C code</strong></span>: It's not like you'll be coding in C, but you will be using principles that are common to C, such as static types, and C libraries, such as <code class="literal">math.h</code>. So, being familiar with the language and its internals will definitely be helpful.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Losing Python's readability is not a problem</strong></span>: The code you'll write for Cython is not fully Python, so part of its readability will be lost.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Full support of the Python language is needed</strong></span>: Even though Cython is not Python, it is more an extension than a subset of the language. So, if you need full compatibility with the language, Cython might be the right choice.</li></ul></div></div><div class="section" title="When to go with PyPy"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec62"/>When to go with PyPy</h2></div></div></div><p>Here are the <a id="id383" class="indexterm"/>situations <a id="id384" class="indexterm"/>when you should go with PyPy:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>You're not dealing with an execute once script</strong></span>: PyPy's JIT optimization is great if your script is a long running program, with loops that can be optimized, but if instead, the script you're trying to improve will run once and be done, then PyPy is actually slower than the original CPython.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Full support of third-party libraries is not required</strong></span>: Even though PyPy is compatible with Python 2.7.x, it is not fully compatible with its external libraries, especially if they're C libraries. So, depending on your code, PyPy might not really be an option.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>You need your code to be compatible with CPython</strong></span>: If you need your code to run for both implementations (PyPy and CPython), then the Cython alternative is completely out of the question. PyPy becomes the only option.</li></ul></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec34"/>Summary</h1></div></div></div><p>In this chapter, we have covered two alternatives to the standard Python implementation. One is PyPy, which consists of a version of Python and is implemented in RPython. It has a JIT compiler in charge of optimizing the code during execution time. The other one is Cython, which is basically a transpiler of Python code into C code. We saw how each of them worked, how to install them, and how our code needed to be changed in order to gain benefits from using them.</p><p>Finally, we went over a few points on how and when to choose one over the other.</p><p>In the next chapter, we'll focus on a very specific use case for Python: number crunching. The topic is very common in the Python community, since the language is very often used for scientific purposes. We'll cover three options that will help us write code faster: Numba, Parakeet, and pandas.</p></div></body></html>