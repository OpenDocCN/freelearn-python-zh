<html><head></head><body>
		<div><h1 id="_idParaDest-184" class="chapter-number"><a id="_idTextAnchor238"/>5</h1>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor239"/>Basic Server-Side Development</h1>
			<p>We learned how to declare or extend business models in custom modules in <a href="B20997_04.xhtml#_idTextAnchor118"><em class="italic">Chapter 4</em></a>, <em class="italic">Application Models</em>. Writing methods for calculated fields and ways to restrict the field values are both addressed in that chapter’s tutorials. This chapter focuses on the fundamentals of server-side programming in Odoo method declarations, record set manipulation, and extending inherited methods. You may use this to create or alter business logins in the Odoo module.</p>
			<p>In this chapter, we will cover the following tutorials:</p>
			<ul>
				<li>Specifying model methods and implementing API decorators</li>
				<li>Notifying errors to the user</li>
				<li>Getting a blank recordset for a different model</li>
				<li>Creating new records</li>
				<li>Updating values of recordset records</li>
				<li>Searching for records</li>
				<li>Combining recordsets</li>
				<li>Filtering recordsets</li>
				<li>Traversing recordset relations</li>
				<li>Sorting recordsets</li>
				<li>Extending a model’s established business logic</li>
				<li>Extending <code>write()</code> and <code>create()</code></li>
				<li>Customizing how records are searched</li>
				<li>Fetching data in groups using <code>read_group()</code></li>
			</ul>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor240"/>Technical requirements</h1>
			<p>The online platform for Odoo is one of the prerequisites for this chapter.</p>
			<p>You can obtain all the code used in this chapter from the following GitHub repository: <a href="https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter05">https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter05</a></p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor241"/>Specifying model methods and using API decorators</h1>
			<p>A class in Odoo models consists of both business logic methods and field declarations. We learned <a id="_idIndexMarker281"/>how to add fields to a model in <a href="B20997_04.xhtml#_idTextAnchor118"><em class="italic">Chapter 4</em></a>, <em class="italic">Application Models</em>. We will now see how to include business logic and methods in a model.</p>
			<p>In this tutorial, we’ll learn <a id="_idIndexMarker282"/>how to create a function that may be used by our application’s user interface buttons or another piece of code. This method will operate on <code>HostelRoom</code> and take the necessary steps to modify the state of a number of rooms<a id="_idTextAnchor242"/>.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor243"/>Getting ready</h2>
			<p>This tutorial assumes that you have an instance ready, with the <code>my_hostel</code> add-on module available, as described in <a href="B20997_03.xhtml#_idTextAnchor083"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating Odoo Add-On Modules</em>. You will need to add a <code>state</code> field to the <code>HostelRoom</code> model, which is defined as follows:</p>
			<pre class="source-code">
from odoo import api, fields, models
class HostelRoom(models.Model):
    # [...]
    state = fields.Selection([
        ('draft', 'Unavailable'),
        ('available', 'Available'),
        ('closed', 'Closed')],
        'State', default="draft")</pre>			<p>Refer to the <em class="italic">Adding models</em> tutorial in <a href="B20997_03.xhtml#_idTextAnchor083"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating Odoo Add-On Modules</em>, for more information.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor244"/>How to do it…</h2>
			<p>To define a <a id="_idIndexMarker283"/>method for hostel rooms to change the state of a <a id="_idIndexMarker284"/>selection of rooms, you need to add the following code to the model definition:</p>
			<ol>
				<li>Add a helper method to check whether a state transition is allowed:<pre class="source-code">
    @api.model
    def is_allowed_transition(self, old_state, new_state):
        allowed = [('draft', 'available'),
                   ('available', 'closed'),
                   ('closed', 'draft')]
        return (old_state, new_state) in allowed</pre></li>				<li>Add a method to change the state of a  room to a new state that is passed as an argument:<pre class="source-code">
    def change_state(self, new_state):
        for room in self:
            if room.is_allowed_transition(room.state,\ 
            new_state):
                room.state = new_state
            else:
                continue</pre></li>				<li>Add a method to change the room state by calling the <code>change_state</code> method:<pre class="source-code">
    def make_available(self):
        self.change_state('available')
    def make_closed(self):
        self.change_state('closed')</pre></li>				<li>Add a button <a id="_idIndexMarker285"/>and status bar in the <code>&lt;form&gt;</code> view. This will <a id="_idIndexMarker286"/>help us trigger these methods from the user interface:<pre class="source-code">
&lt;form&gt;
...
    &lt;button name="make_available" string="Make Available" type="object"/&gt;
    &lt;button name="make_closed" string="Make Borrowed" type="object"/&gt;
    &lt;field name="state" widget="statusbar"/&gt;
...
&lt;/form&gt;</pre></li>			</ol>
			<p>To access these updates, you must update the module or install it.</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor245"/>How it works…</h2>
			<p>Several methods are defined in the tutorial’s code. They are typical Python methods with <code>self</code> as their first argument and the option of receiving additional arguments. The <code>odoo.api</code> module’s <strong class="bold">decorators</strong> are used to adorn some methods.</p>
			<p class="callout-heading">TIP</p>
			<p class="callout">In Odoo 9.0, the API decorators were first added to support both the old and new frameworks. The previous API is no longer supported as of Odoo 10.0, however, some decorators, such <code>@api.model</code>, are still in use.</p>
			<p>When writing a new method, if you don’t use a decorator, then the method is executed on a recordset. In such methods, <code>self</code> is a recordset that can refer to an arbitrary number of database records (this includes empty recordsets), and the code will often loop over the records in <code>self</code> to do something on each individual record.</p>
			<p>The <code>@api.model</code> decorator is similar, but it’s used on methods for which only the model is important, not the contents of the recordset, which is not acted upon by the method. The concept is similar to Python’s <code>@</code><code>classmethod</code> decorator.</p>
			<p>In <em class="italic">Step 1</em>, we created the <code>is_allowed_transition()</code> method. The purpose of this method is to verify whether a transition from one state to another is valid. The tuples in the <code>allowed</code> list are the available transitions. For example, we don’t want to allow a transition from <code>closed</code> to <code>available</code>, which is why we haven’t put <code>('</code><code>closed, 'available')</code>.</p>
			<p>In <em class="italic">Step 2</em>, we created the <code>change_state()</code> method. The purpose of this method is to change the <a id="_idIndexMarker287"/>status of the room. When this method is called, it changes <a id="_idIndexMarker288"/>the status of the room to the state given by the <code>new_state</code> parameter. It only changes the room status if the transition is allowed. We used a <code>for</code> loop here because <code>self</code> can contain multiple recordsets.</p>
			<p>In <em class="italic">Step 3</em>, we created the methods that change the state of the room by calling the <code>change_state()</code> method. In our case, this method will be triggered by the buttons that were added to the user interface.</p>
			<p>In <em class="italic">Step 4</em>, we added <code>&lt;button&gt;</code> in the <code>&lt;form&gt;</code> view. Upon clicking this button, the Odoo web client will invoke the Python function mentioned in the <code>name</code> attribute. Refer to the <em class="italic">Adding buttons to forms</em> tutorial in <a href="B20997_09.xhtml#_idTextAnchor446"><em class="italic">Chapter 9</em></a>, <em class="italic">Backend Views</em>, to learn how to call such a method from the user interface. We have also added the <code>state</code> field with the <code>statusbar</code> widget to display the status of the room in the <code>&lt;</code><code>form&gt;</code> view.</p>
			<p>When the user clicks on the button from the user interface, one of the methods from <em class="italic">Step 3</em> will be called. Here, <code>self</code> will be the recordset that contains the record of the <code>hostel.room</code> model. After that, we call the <code>change_state()</code> method and pass the appropriate parameter based on the button that was clicked.</p>
			<p>When <code>change_state()</code> is called, <code>self</code> is the same recordset of the <code>hostel.room</code> model. The body of the <code>change_state()</code> method loops over <code>self</code> to process each room in the recordset. Looping on <code>self</code> looks strange at first, but you will get used to this pattern very quickly.</p>
			<p>Inside the loop, <code>change_state()</code> calls <code>is_allowed_transition()</code>. The call is made using the <code>room</code> local variable, but it can be made on any recordset for the <code>hostel.room</code> model, including, for example, <code>self</code>, since <code>is_allowed_transition()</code> is decorated with <code>@api.model</code>. If the transition is allowed, <code>change_state()</code> assigns the new state to the room by assigning a value to the attribute of the recordset. This is only valid on recordsets with a length of <code>1</code>, which is guaranteed to be the case when iterating over <code>self</code>.</p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor246"/>Reporting errors to the user</h1>
			<p>Sometimes, it’s required to stop processing during method execution because the user’s activity is invalid <a id="_idIndexMarker289"/>or an error condition has been satisfied. By displaying an informative error message, this tutorial demonstrates how to handle these situations.</p>
			<p>The <code>UserError</code> exception is commonly utilized to inform users about errors or exceptional situations. It is typically employed when the user’s input fails to meet the expected criteria or when a particular operation cannot be executed due to specific conditions.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor247"/>Getting ready</h2>
			<p>This tutorial requires that you set up an instance with the <code>my_hostel</code> add-on module installed, as per the instructions from before.</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor248"/>How to do it…</h2>
			<p>We will make a change to the <code>change_state</code> method from the previous tutorial and display a helpful message when the user is trying to change the state that is not allowed by the <code>is_allowed_transition</code> method. Perform the following steps to get started:</p>
			<ol>
				<li>Add the following import at the beginning of the Python file:<pre class="source-code">
from odoo.exceptions import UserError
from odoo.tools.translate import _</pre></li>				<li>Modify the <code>change_state</code> method and raise a <code>UserError</code> exception from the <code>else</code> part:<pre class="source-code">
def change_state(self, new_state):
    for room in self:
        if room.is_allowed_transition(room.state, new_state):
            room.state = new_state
        else:
            msg = _('Moving from %s to %s is not
allowed') % (room.state, new_state)
            raise UserError(msg)</pre></li>			</ol>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor249"/>How it works…</h2>
			<p>When an <a id="_idIndexMarker290"/>exception is raised in Python, it propagates up the call stack until <a id="_idIndexMarker291"/>it is processed. In Odoo, the <strong class="bold">remote procedure call</strong> (<strong class="bold">RPC</strong>) layer that answers the calls made by the web client catches all exceptions and, depending on the exception class, triggers different possible behaviors on the web client.</p>
			<p>Any exception not defined in <code>odoo.exceptions</code> will be handled as an internal server error (<code>UserError</code> will display an error message in the user interface. The code of the tutorial raises <code>UserError</code> to ensure that the message is displayed in a user-friendly way. In all cases, the current database transaction is rolled back.</p>
			<p>We are using a function with a strange name, <code>_()</code>, which is defined in <code>odoo.tools.translate</code>. This function is used to mark a string as translatable and to retrieve the translated string at runtime, given the language of the end user that’s found in the execution context. More information on this is available in <a href="B20997_11.xhtml#_idTextAnchor595"><em class="italic">Chapter </em><em class="italic">11</em></a>, <em class="italic">Internationalisation</em>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">When using the <code>_()</code> function, ensure that you pass only strings with the interpolation placeholder, not the whole interpolated string. For example, <code>_('Warning: could not find %s') % value</code> is correct, but <code>_('Warning: could not find %s' % value)</code> is incorrect because the first one will not find the string with the substituted value in the translation database.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor250"/>There’s more…</h2>
			<p>Sometimes, you are working on error-prone code, meaning that the operation you are performing may generate an error. Odoo will catch this error and display a traceback to the user. If you don’t want to show a full error log to the user, you can catch the error and raise a custom <a id="_idIndexMarker292"/>exception with a meaningful message. In the example provided, we are generating <code>UserError</code> from the <code>try...catch</code> block so that instead of showing a full error log, Odoo will now show a warning with a meaningful message:</p>
			<pre class="source-code">
def post_to_webservice(self, data):
    try:
        req = requests.post('http://my-test-service.com', data=data, timeout=10)
        content = req.json()
    except IOError:
        error_msg = _("Something went wrong during data submission")
        raise UserError(error_msg)
    return content</pre>			<p>There are a few more exception classes defined in <code>odoo.exceptions</code>, all deriving from the base legacy <code>except_orm</code> exception class. Most of them are only used internally, apart from the following:</p>
			<ul>
				<li><code>ValidationError</code>: This exception is raised when a Python constraint on a field is not respected. In <a href="B20997_04.xhtml#_idTextAnchor118"><em class="italic">Chapter 4</em></a>, <em class="italic">Application Models</em>, refer to the <em class="italic">Adding constraint validations to a model</em> tutorial for more information.</li>
				<li><code>AccessError</code>: This error is usually generated automatically when the user tries to access something that is not allowed. You can raise the error manually if you want to show the access error from your code.</li>
				<li><code>RedirectWarning</code>: With this error, you can show a redirection button with the error message. You need to pass two parameters to this exception: the first parameter is <a id="_idIndexMarker293"/>the action ID, and the second parameter is the error message.</li>
				<li><code>Warning</code>: In Odoo 8.0, <code>odoo.exceptions.Warning</code> played the same role as <code>UserError</code> in 9.0 and later. It is now deprecated because the name was deceptive (it is an error, not a warning) and it collided with the Python built-in <code>Warning</code> class. It is kept for backward compatibility only, and you should use <code>UserError</code> in your code.</li>
			</ul>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor251"/>Obtaining an empty recordset for a different model</h1>
			<p>The current model’s methods are accessible through <code>self</code> while creating Odoo code. It is not <a id="_idIndexMarker294"/>feasible to start working on a different model by simply instantiating its class; you must first obtain a recordset for that model.</p>
			<p>This tutorial shows you how to get an empty recordset for any model that’s registered in Odoo inside a model method.</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor252"/>Getting ready</h2>
			<p>This tutorial will reuse the setup of the library example in the <code>my_hostel</code> add-on module.</p>
			<p>We will write a small method in the <code>hostel.room</code> model and search for all <code>hostel.room.members</code>. To do this, we need to get an empty recordset for <code>hostel.room.members</code>. Make sure you have added the <code>hostel.room.members</code> model and access rights for that model.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor253"/>How to do it…</h2>
			<p>To get a recordset for <code>hostel.room.members</code> in a method of <code>hostel.room</code>, you need to perform the following steps:</p>
			<div><div><img src="img/B20997_05_1.jpg" alt="Figure 5.1 – log_all_room_members"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – log_all_room_members</p>
			<ol>
				<li>In <a id="_idIndexMarker295"/>the <code>HostelRoom</code> class, write a method <a id="_idIndexMarker296"/>called <code>log_all_room_members</code>:<pre class="source-code">
class HostelRoom(models.Model):
    # ...
    def log_all_room_members(self):
        # This is an empty recordset of model hostel.room.member
        hostel_room_obj = self.env['hostel.room.member']
        all_members = hostel_room_obj.search([])
        print("ALL MEMBERS:", all_members)
        return True</pre></li>				<li>Add a button to the <code>&lt;form&gt;</code> view to invoke our method:<pre class="source-code">
&lt;button name="log_all_room_members"  string="Log Members" type="object"/&gt;</pre></li>			</ol>
			<p>Update the module to apply the changes. After that, you will see the <code>&lt;form&gt;</code> view. You may view the member’s recordset in the server log by clicking that button.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor254"/>How it works…</h2>
			<p>At startup, Odoo loads <a id="_idIndexMarker297"/>all the modules and combines the various classes that derive from <code>Model</code>, and also defines or extends the given model. These classes are stored in the <code>env</code> attribute of any recordset, available as <code>self.env</code>, is an instance of the <code>Environment</code> class defined in the <code>odoo.api</code> module.</p>
			<p>The <code>Environment</code> class plays a central role in Odoo development:</p>
			<ul>
				<li>It provides shortcut access to the registry by emulating a Python dictionary. If you know the name of the model you’re looking for, <code>self.env[model_name]</code> will get you an empty recordset for that model. Moreover, the recordset will share the environment of <code>self</code>.</li>
				<li>It has a <code>cr</code> attribute, which is a database cursor you may use to pass raw SQL queries. Refer to the <em class="italic">Executing raw SQL queries</em> tutorial in <a href="B20997_08.xhtml#_idTextAnchor388"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced Server-Side Development Techniques</em>, for more information on this.</li>
				<li>It has a <code>user</code> attribute, which is a reference to the current user performing the call. Take a look at <a href="B20997_08.xhtml#_idTextAnchor388"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced Server-Side Development Techniques</em>, and the <em class="italic">Changing the user performing an action</em> tutorial for more on this.</li>
				<li>It has a <code>context</code> attribute, which is a dictionary that contains the context of the call. This includes information about the language of the user, the time zone, and the current selection of records. Refer to the <em class="italic">Calling a method with a modified context</em> tutorial in <a href="B20997_08.xhtml#_idTextAnchor388"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced Server-Side Development Techniques</em>, for more on this.</li>
			</ul>
			<p>The call to <code>search()</code> is explained in the <em class="italic">Searching for records</em> tutorial later.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor255"/>See also</h2>
			<p>Sometimes, you want to use a modified version of the environment. One such example is that you want an environment with a different user and language. In <a href="B20997_08.xhtml#_idTextAnchor388"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced Server-Side Development Techniques</em>, you will learn how to modify the environment at runtime.</p>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor256"/>Creating new records</h1>
			<p>Creating new records is a regular requirement when putting business logic processes into practice. How you <a id="_idIndexMarker298"/>can build records for the <code>hostel.room.category</code> model is included in this tutorial. We’ll add a function to the <code>hostel.room.category</code> model to generate dummy categories for the purposes of our example. We will add  the <code>&lt;form&gt;</code> view to activate this approach.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor257"/>Getting ready</h2>
			<p>You need to understand the structure of the models for which you want to create a record, especially their names and types, as well as any constraints that exist on these fields (for example, whether some of them are mandatory).</p>
			<p>For this tutorial, we will reuse the <code>my_hostel</code> module from <a href="B20997_04.xhtml#_idTextAnchor118"><em class="italic">Chapter 4</em></a>, <em class="italic">Application Models</em>. Take a look at the following example to quickly recall the <code>hostel.room<a id="_idTextAnchor258"/>.category</code> model:</p>
			<pre class="source-code">
class RoomCategory(models.Model):
    _name = 'hostel.room.category'
    _description = 'Hostel Room Category'
    name = fields.Char('Category')
    description = fields.Text('Description')
    parent_id = fields.Many2one(
        'hostel.room.category',
        string='Parent Category',
        ondelete='restrict',
        index=True
    )
    child_ids = fields.One2many(
        'hostel.room.category', 'parent_id',
        string='Child Categories')</pre>			<p>Make sure you <a id="_idIndexMarker299"/>have added menus, views, and access rights for the <code>hostel.room.category</code> model.</p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor259"/>How to do it…</h2>
			<p>To create a category with some child categories, you need to perform the following steps:</p>
			<div><div><img src="img/B20997_05_2.jpg" alt="Figure 5.2 – Create a category"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Create a category</p>
			<ol>
				<li>Create a <a id="_idIndexMarker300"/>method in the <code>hostel.room.category</code> model with the name <code>create_categories</code>:<pre class="source-code">
def create_categories(self):
    ......</pre></li>				<li>Inside the body of this method, prepare a dictionary of values for the fields of the first child category:<pre class="source-code">
categ1 = {
    'name': 'Child category 1',
    'description': 'Description for child 1'
}</pre></li>				<li>Prepare a dictionary of values for the fields of the second category:<pre class="source-code">
categ2 = {
    'name': 'Child category 2',
    'description': 'Description for child 2'
}</pre></li>				<li>Prepare a <a id="_idIndexMarker301"/>dictionary of values for the fields of the parent category:<pre class="source-code">
parent_category_val = {
    'name': 'Parent category',
    'description': 'Description for parent category',
    'child_ids': [
        (0, 0, categ1),
        (0, 0, categ2),
    ]
}</pre></li>				<li>Call the <code>create()</code> method to creat<a id="_idTextAnchor260"/>e the new records:<pre class="source-code">
record = self.env['hostel.room.category'].create(parent_category_val)</pre></li>				<li>Add a button in the <code>&lt;form&gt;</code> view to trigger the <code>create_categories</code> method from t<a id="_idTextAnchor261"/>he user interface:<pre class="source-code">
&lt;button name="create_categories" string="Create Categories" type="object"/&gt;</pre></li>			</ol>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor262"/>How it works…</h2>
			<p>To add a new record for a model, we can call the <code>create(values)</code> method on any recordset related to the model. This method returns a new recordset with a length of <code>1</code> and contains the new record, with the field values specified in the <code>values</code> dictionary.</p>
			<p>The keys in the <a id="_idIndexMarker302"/>dictionary identify the fields by name, while the accompanying values reflect the field’s value. Depending on the field type, you need to pass different Python types for the values:</p>
			<ul>
				<li>A <code>Text</code> field value is given with Python strings.</li>
				<li>The <code>Float</code> and <code>Integer</code> field values are given using Python floats or integers.</li>
				<li>A <code>boolean</code> field value is given preferably using Python Booleans or integers.</li>
				<li>A <code>Date</code> field value is given with the Python <code>datetime.date</code> object.</li>
				<li>A <code>Datetime</code> field value is given with the Python <code>datetime.datetime</code> object.</li>
				<li>A <code>Binary</code> field value is passed as a Base64-encoded string. The <code>base64</code> module from the Python standard library provides methods such as <code>encodebytes(bytestring)</code> to encode a string in Base64.</li>
				<li>A <code>Many2one</code> field value is given with an integer, which has to be the database ID of the related record.</li>
				<li><code>One2many</code> and <code>Many2many</code> fields use a special syntax. The value is a list that contains tuples of three elements, as follows:</li>
			</ul>
			<div><div><img src="img/B20997_05_3.jpg" alt="Table 5.1 – Relational field write"/>
				</div>
			</div>
			<p class="IMG---Figure">Table 5.1 – Relational field write</p>
			<p>In this tutorial, we create the dictionaries for two categories in the hostel room we want to create, and then we use these dictionaries in the <code>child_ids</code> entry of the dictionary for the hostel <a id="_idIndexMarker303"/>room categories being created by using the <code>(0, 0, dict_val)</code> syntax we explained earlier.</p>
			<p>When <code>create()</code> is called in <em class="italic">Step 5</em>, three records are created:</p>
			<ul>
				<li>One for the parent room category, which is returned by <code>create</code></li>
				<li>Two records for the child room category, which are available in <code>record.child_ids</code></li>
			</ul>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor263"/>There’s more…</h2>
			<p>If the model defined some default values for some fields, nothing special needs to be done. <code>create()</code> will take care of computing the default values for the fields that aren’t present in the supplied dictionary.</p>
			<p>The <code>create()</code> method also <a id="_idIndexMarker304"/>supports the creation of records in a batch. To create multiple records in a batch, you need to pass a list of multiple values to the <code>create()</code> method, as shown in the following example:</p>
			<pre class="source-code">
categ1 = {
    'name': 'Category 1',
    'description': 'Description for Category 1'
}
categ2 = {
    'name': 'Category 2',
    'description': 'Description for Category 2'
}
multiple_records = self.env['hostel.room.category'].create([categ1, categ2])</pre>			<p>This code will return the recordset of created categories of the hostel room category.</p>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor264"/>Updating values of recordset records</h1>
			<p>Business logic <a id="_idIndexMarker305"/>often requires us to update records by changing the values of some of their fields. This tutorial shows you how to modify the <code>room_no</code> field of the partner as we go.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor265"/>Getting ready</h2>
			<p>This tutorial will use the same simplified <code>hostel.room</code> definition of the <em class="italic">Creating new records</em> tutorial. You may refer to this simplified definition to find out about the fields.</p>
			<p>We have the <code>room_no</code> field in the <code>hostel.room</code> model. For illustration purposes, we will write in this field with the click of a button.</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor266"/>How to do it…</h2>
			<ol>
				<li>To update a room’s <code>room_no</code> field, you can write a new method called <code>update_room_no()</code>, which is defined as follows:<pre class="source-code">
def update_room_no(self):
<a id="_idTextAnchor267"/>    self.ensure_one()
    self.room_no = "RM002"</pre></li>				<li>Then, you can add a button to the room’s <code>&lt;form&gt;</code> vie<a id="_idTextAnchor268"/>w in <code>xml</code>, as follows:<pre class="source-code">
&lt;button name="update_room_no" string="Update Room No" type="object"/&gt;</pre></li>				<li>Restart the server and update the <code>my_hostel</code> module to see the changes. Upon clicking the <code>room_no</code> will be changed.</li>
			</ol>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor269"/>How it works…</h2>
			<p>The method starts by checking whether the room recordset that’s passed as <code>self</code> contains exactly one record by calling <code>ensure_one()</code>. If this is not the case, this procedure will generate an exception, and processing will stop. This is necessary because we don’t want to change the room number of multiple records. If you want to update multiple values, you can remove <code>ensure_one()</code> and update the attribute using a loop on the recordset.</p>
			<p>Finally, the method <a id="_idIndexMarker306"/>modifies the values of the attributes of the room record. It updates the <code>room_no</code> field with the defined room number. Just by modifying the field attributes of the recordset, you can perform write operations.</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor270"/>There’s more…</h2>
			<p>There are three options available if you want to add new values to the fields of records:</p>
			<ul>
				<li>Option one is the one that was explained in this tutorial. It works in all contexts by assigning values directly to the attribute representing the field of the record. It isn’t possible to assign a value to all recordset elements in one go, so, you need to iterate on the recordset, unless you are certain that you are only handling a single record.</li>
				<li>Option two is to use the <code>update()</code> method by passing dictionary mapping field names to the values you want to set. This also only works for recordsets with a length of <code>1</code>. It can save some typing when you need to update the values of several fields at once on the same record. Here’s <em class="italic">Step 2</em> of the tutorial, rewritten to use this option:<pre class="source-code">
def change_room_no(self):
    self.ensure_one()
    self.update({
        'room_no': "RM002",
        'another_field': 'value'
        ...
    })</pre></li>				<li>Option three is to call the <code>write()</code> method, passing a dictionary that maps the field names to the values you want to set. This method works for recordsets of arbitrary size and will update all records with the specified values in one single database operation when the two previous options perform one database call per record and per field. However, it has some limitations: it does not work if the records are not yet present in the database (refer to the <em class="italic">Writing on change methods</em> tutorial in <a href="B20997_08.xhtml#_idTextAnchor388"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced Server-Side Development Techniques</em>, for more information on this). Also, it requires a special format when writing relational fields, similar to the one used by the <code>create()</code> method. Check the <a id="_idIndexMarker307"/>following table for the format that’s used to generate different values for the relational fields:</li>
			</ul>
			<div><div><img src="img/B20997_05_4.jpg" alt="Table 5.2 – Relational field update"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.2 – Relational field update</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The <code>1</code>, <code>2</code>, <code>3</code>, and <code>5</code> operation types cannot be used with the <code>create()</code> method.</p>
			<h1 id="_idParaDest-211"><a id="_idTextAnchor271"/>Searching for records</h1>
			<p>Searching for <a id="_idIndexMarker308"/>records is also a common operation in business logic methods. There are many cases where we need to search the data based on different criteria. Finding the room by name and category is demonstrated in this tutorial.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor272"/>Getting ready</h2>
			<p>This tutorial will use the same <code>hostel.room</code> definition as the <em class="italic">Creating new records</em> tutorial did previously. We will write the code in a method called <code>find_room(self)</code>.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor273"/>How to do it…</h2>
			<p>To find the <a id="_idIndexMarker309"/>rooms, you need to perform the following steps:</p>
			<ol>
				<li>Add the <code>find_room</code> method to the <code>hostel.room</code> model:<pre class="source-code">
def find_room(self):
    ...</pre></li>				<li>Write the search domain for your criteria:<pre class="source-code">
domain = [
    '|',
        '&amp;', ('name', 'ilike', 'Room Name'),
             ('category_id.name', 'ilike', 'Category Name'),
        '&amp;', ('name', 'ilike', 'Second Room Name 2'),
             ('category_id.name', 'ilike', 'SecondCategory Name 2')
]</pre></li>				<li>Call the <code>search()</code> method with the domain, which will return the recordset:<pre class="source-code">
rooms = self.search(domain)</pre></li>			</ol>
			<p>The <code>rooms</code> variable will have a recordset of searched rooms. You can print or log that variable to see the result in the server log.</p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor274"/>How it works…</h2>
			<p><em class="italic">Step 1</em> defines the method name prefixed with the <code>def</code> keyword.</p>
			<p><em class="italic">Step 2</em> creates a search domain in a local variable. Often, you’ll see this creation inline in the call to search, but with complex domains, it is good practice to define it separately.</p>
			<p>For a full explanation of the search domain syntax, refer to the <em class="italic">Defining filters on record lists – domain</em> tutorial in <a href="B20997_09.xhtml#_idTextAnchor446"><em class="italic">Chapter 9</em></a>, <em class="italic">Backend Views</em>.</p>
			<p><em class="italic">Step 3</em> calls the <code>search()</code> method with the domain. The method returns a recordset that contains <a id="_idIndexMarker310"/>all the records that match the domain, which can then be processed further. In this tutorial, we call the method with just the domain, but the following keyword arguments are also supported:</p>
			<ul>
				<li><code>offset=N</code>: This is <a id="_idIndexMarker311"/>used to skip the first <code>N</code> records that match the query. This can be used along with <code>limit</code> to implement pagination or to reduce memory consumption when processing a very large number of records. It defaults to <code>0</code>.</li>
				<li><code>limit=N</code>: This indicates <a id="_idIndexMarker312"/>that, at most, <code>N</code> records should be returned. By default, there is no limit.</li>
				<li><code>order=sort_specification</code>: This is used to force the order in the recordset <a id="_idIndexMarker313"/>returned. By default, the order is given by the <code>_order</code> attribute of the model class.</li>
				<li><code>count=boolean</code>: If <code>True</code>, this returns <a id="_idIndexMarker314"/>the number of records instead of the recordset. It defaults to <code>False</code>.</li>
			</ul>
			<p class="callout-heading">Important note</p>
			<p class="callout">We <a id="_idIndexMarker315"/>recommend using the <code>search_count(domain)</code> method rather than<em class="italic"> </em><code>search(domain, count=True)</code>, as the name of the method conveys the behavior in a much clearer way. Both will give the same result.</p>
			<p>Sometimes, you need to search from another model so that searching for <code>self</code> will return a recordset of the current model. To search from another model, we need to get an empty recordset for the model. For example, let’s say we want to search for some contacts. To do that, we will <a id="_idIndexMarker316"/>need to use the <code>search()</code> method on the <code>res.partner</code> model. Refer to the following code. Here, we get the empty recordset of <code>res.partner</code> to search the contacts:</p>
			<pre class="source-code">
def find_partner(self):
    PartnerObj = self.env['res.partner']
    domain = [
        '&amp;', ('name', 'ilike', 'SerpentCS'),
             ('company_id.name', '=', 'SCS')
    ]
    partner = PartnerObj.search(domain)</pre>			<p>In the preceding code, we have two conditions in the domain. You can omit the <code>'&amp;'</code> from the domain when you have two conditions to compare, because when you do not specify the domain; then, Odoo will take <code>'&amp;'</code> as a default.</p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor275"/>There’s more…</h2>
			<p>We said previously that the <code>search()</code> method returned all the records matching the domain. This is not actually completely true. The security rules ensure that the user only gets those records to which they have <code>read</code> access rights. Additionally, if the model has a <code>boolean</code> field called <code>active</code> and no term of the search domain specifies a condition on that field, then an implicit condition is added by search to only return <code>active=True</code> records. So, if you expect a search to return something, but you only get empty recordsets, ensure that you check the value of the <code>active</code> field (if present) to check for record rules.</p>
			<p>Refer to the <em class="italic">Calling a method with a different context</em> tutorial in <a href="B20997_08.xhtml#_idTextAnchor388"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced Server-Side Development Techniques</em>, for a way to not have the implicit <code>active=True</code> condition added. Take a look at the <em class="italic">Limiting record access using record rules</em> tutorial in <a href="B20997_10.xhtml#_idTextAnchor549"><em class="italic">Chapter 10</em></a>, <em class="italic">Security Access</em>, for more information about record-level access rules.</p>
			<p>If, for some reason, you find yourself writing raw SQL queries to find record IDs, ensure that you use <code>self.env['record.model'].search([('id', 'in', tuple(ids))]).ids</code> after retrieving the IDs to ensure that security rules are applied. This is <a id="_idIndexMarker317"/>especially important in <strong class="bold">multi-company</strong> Odoo instances where the record rules are used to ensure proper discrimination between companies.</p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor276"/>Combining recordsets</h1>
			<p>Sometimes, you will <a id="_idIndexMarker318"/>find that you have obtained recordsets that are not exactly what you need. This tutorial shows various ways of combining them.</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor277"/>Getting ready</h2>
			<p>To use this tutorial, you need to have two or more recordsets for the same model.</p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor278"/>How to do it…</h2>
			<p>Follow these steps to perform common operations on recordsets:</p>
			<ol>
				<li>To merge two recordsets into one while preserving their order, use the following operation:<pre class="source-code">
result = recordset1 + recordset2</pre></li>				<li>To merge two recordsets into one while ensuring that there are no duplicates in the result, use the following operation:<pre class="source-code">
result = recordset1 | recordset2</pre></li>				<li>To find the records that are common to two recordsets, use the following operation:<pre class="source-code">
result = recordset1 &amp; recordset2</pre></li>			</ol>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor279"/>How it works…</h2>
			<p>The class for recordsets implements various Python operator redefinitions, which are used here. Here’s a <a id="_idIndexMarker319"/>summary table of the most useful Python operators that can be used on recordsets:</p>
			<div><div><img src="img/Image96870.jpg" alt="Table 5.3 – Operators used with the domain"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.3 – Operators used with the domain</p>
			<p>There are also in-place operators, <code>+=</code>, <code>-=</code>, <code>&amp;=</code>, and <code>|=</code>, which modify the left-hand side operand instead of creating a new recordset. These are very useful when updating a record’s <code>One2many</code> or <code>Many2many</code> fields. Refer to the <em class="italic">Updating values of recordset records</em> tutorial for an example of this.</p>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor280"/>Filtering recordsets</h1>
			<p>Sometimes, you already have a recordset, but you just need to work on a subset of those records. Of course, you may iterate over the recordset, checking for the condition each time and <a id="_idIndexMarker320"/>taking action in accordance with the outcome of the check. The construction of a new recordset comprising only the interesting records and the use of a single operation on that recordset can be simpler and, in certain situations, more efficient.</p>
			<p>This tutorial shows you how to use the <code>filter()</code> method to extract a subset of recordsets based on a condition.</p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor281"/>Getting ready</h2>
			<p>We will reuse the simplified <code>hostel.room</code> model that was shown in the <em class="italic">Creating new records</em> tutorial. This tutorial defines a method to extract rooms that have multiple members from a supplied recordset.</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor282"/>How to do it…</h2>
			<p>To extract records that have multiple members from a recordset, you need to perform the following steps:</p>
			<ol>
				<li>Define the method to filter the recordset:<pre class="source-code">
       def filter_members(room):
        all_rooms = self.search([])
        filtered_rooms = self.rooms_with_multiple_members(all_rooms)</pre></li>				<li>Define the method to accept the original recordset:<pre class="source-code">
    @api.model
    def room_with_multiple_members(self, all_rooms):</pre></li>				<li>Define an inner <code>predicate</code> function:<pre class="source-code">
    def predicate(room):
        if len(room.member_ids) &gt; 1:
            return True
        return False</pre></li>				<li>Call <code>filter()</code>, as follows:<pre class="source-code">
return all_room.filter (predicate)</pre></li>			</ol>
			<p>The outcome of this procedure can be printed or logged so that a server log can include it. For further information, see the tutorial’s sample code.</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor283"/>How it works…</h2>
			<p>The recordset that is created by the <code>filter()</code> method’s implementation is empty. This blank recordset <a id="_idIndexMarker321"/>receives all the records that the predicate function evaluates to <code>True</code>. Finally, the fresh recordset is given back. Records in the original recordset are still in the same sequence.</p>
			<p>A named internal function was used in the last tutorial. You will frequently see an anonymous Lambda function being utilized for such straightforward predicates:</p>
			<pre class="source-code">
@api.model
def <code>room_wi<a id="_idTextAnchor284"/>th_multiple_rooms</code>(self, all_rooms):
    return all_<code>rooms</code>.filter(lambda b: len(b.member<code>_ids</code>) &gt; 1)</pre>			<p>Actually, you need to filter a recordset based on the fact that the value of a field is <em class="italic">truthy</em> in the Python sense (non-empty strings, non-zero numbers, non-empty containers, and so on). So, if you want to filter records that have a category set, you can pass the field name to filter like this: <code>all_rooms.filter('category_id')</code>.</p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor285"/>There’s more…</h2>
			<p>Remember that <code>filter()</code> uses memory <a id="_idIndexMarker322"/>to work. Use a search domain or even switch to SQL to improve the speed of a method on the critical route at the cost of readability.</p>
			<h1 id="_idParaDest-225"><a id="_idTextAnchor286"/>Traversing recordset relations</h1>
			<p>When working with a recordset with a length of <code>1</code>, various fields are available as record attributes. Relational attributes (<code>One2many</code>, <code>Many2one</code>, and <code>Many2many</code>) are also available with <a id="_idIndexMarker323"/>values that are recordsets, too. As an example, let’s say we want to access the name of the category from the recordset of the <code>hostel.room</code> model. You can access the category name by traversing through the <code>Many2one</code> field’s <code>category_id</code> as follows: <code>room.category_id.name</code>. However, when working with recordsets with more than one record, the attributes cannot be used.</p>
			<p>This tutorial demonstrates how to navigate recordset relations using the <code>mapped()</code> function. We’ll create a function to extract the members’ names from the list of rooms that are supplied as input.</p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor287"/>Getting ready</h2>
			<p>We will reuse the <code>hostel.room</code> model that was shown in the <em class="italic">Creating new records</em> tutorial in this chapter.</p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor288"/>How to do it…</h2>
			<p>You must do the following actions in order to retrieve the names of members from the room recordset:</p>
			<ol>
				<li>Define a method called <code>get_members_names()</code>:<pre class="source-code">
    @api.model
    def get_members_names(self, rooms):</pre></li>				<li>Call <code>mapped()</code> to get the name of the contacts of the member:<pre class="source-code">
    return rooms.mapped('member_ids.name')</pre></li>			</ol>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor289"/>How it works…</h2>
			<p>Simply defining the method is <em class="italic">Step 1</em>. The fields of the recordset are traversed in <em class="italic">Step 2</em> by calling the <code>mapped(path)</code> function; <code>path</code> is a string that comprises field names separated by dots. The next element in the route is applied to the new recordset created by <code>mapped()</code> for each field in the path. This new recordset comprises all the records connected by that field to every element in the current recordset. A recordset is returned by <code>mapped()</code> if the final field in the route is a relational field; otherwise, a Python list is returned.</p>
			<p>The <code>mapped()</code> method has two useful properties:</p>
			<ul>
				<li>When the route is a single scalar field name, the returned list is in the same chronological order as the recordset that was processed</li>
				<li>If a relational <a id="_idIndexMarker324"/>field is present in the route, the result’s order is not retained, but duplicates are eliminated</li>
			</ul>
			<p class="callout-heading">Important note</p>
			<p class="callout">This second property is very useful when you want to perform an operation on all the records that are pointed to by a <code>Many2many</code> field for all the records in <code>self</code>, but you need to ensure that the action is performed only once (even if two records of <code>self</code><em class="italic"> </em>share the same target record).</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor290"/>There’s more…</h2>
			<p>When using <code>mapped()</code>, keep in mind that it operates in memory inside the Odoo server by repeatedly <a id="_idIndexMarker325"/>traversing relations and therefore making SQL queries, which may not be efficient. However, the code is terse and expressive. If you are trying to optimize a method on the critical path of the performance of your instance, you may want to rewrite the call to <code>mapped()</code> and express it as <code>search()</code> with the appropriate domain, or even move to SQL (at the cost of readability).</p>
			<p>The <code>mapped()</code> method can also be called with a function as an argument. In this case, it returns a list containing the result of the function that’s applied to each record of <code>self</code>, or the union of the recordsets that’s returned by the function, if the function returns a recordset.</p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor291"/>See also</h2>
			<p>For more information, refer to the following:</p>
			<ul>
				<li>The <em class="italic">Searching for records</em> tutorial in this chapter</li>
				<li>The <em class="italic">Executing raw SQL queries</em> tutorial in <a href="B20997_08.xhtml#_idTextAnchor388"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced Server-Side </em><em class="italic">Development Techniques</em></li>
			</ul>
			<h1 id="_idParaDest-231"><a id="_idTextAnchor292"/>Sorting recordsets</h1>
			<p>When you fetch a recordset <a id="_idIndexMarker326"/>with the <code>search()</code> method, you can pass an optional argument order to get a recordset that’s in a particular order. This is useful if you already have a <a id="_idIndexMarker327"/>recordset from a previous bit of code and you want to sort it. It may also be useful if you use a set operation to combine two recordsets, for example, which would cause the order to be lost.</p>
			<p>This tutorial shows <a id="_idIndexMarker328"/>you how to use the <code>sorted()</code> method to sort an existing recordset. We will sort rooms by rating.</p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor293"/>Getting ready</h2>
			<p>We will reuse the <code>hostel.room</code> model that was shown in the <em class="italic">Creating new records</em> tutorial in this chapter.</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor294"/>How to do it…</h2>
			<p>You need to perform the following steps to get the sorted recordset of rooms based on <code>rating</code>:</p>
			<ol>
				<li>Define a method called <code>sort_rooms_by_rating()</code>:<pre class="source-code">
    @api.model
    def sort_rooms_by_rating(self, rooms):</pre></li>				<li>Use the <code>sorted()</code> method, as in the given example, to sort room records based on the <code>room_rating</code> field:<pre class="source-code">
    return rooms.sorted(key='room_rating')</pre></li>			</ol>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor295"/>How it works…</h2>
			<p>Simply defining the method is <em class="italic">Step 1</em>. In <em class="italic">Step 2</em>, we use the recordset of the rooms’ <code>sorted()</code> function. The field that is supplied as the key parameter will have its data fetched internally by the <code>sorted()</code> function. Then, it returns a <code>sorted</code> recordset using Python’s native sorted method.</p>
			<p>It also has one <a id="_idIndexMarker329"/>optional argument, <code>reverse=True</code>, which returns a recordset in reverse order. <code>reverse</code> is used as follows:</p>
			<pre class="source-code">
rooms.sorted(key='room_rating', reverse=True)</pre>			<h2 id="_idParaDest-235"><a id="_idTextAnchor296"/>There’s more…</h2>
			<p>The <code>sorted()</code> method will sort the records in a recordset. Called without arguments, the <code>_order</code> attribute of the model will be used. Otherwise, a function can be passed to compute a comparison key in the same way as the Python built-in sorted (sequence, key) function.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">When the default <code>_order</code> parameter of the model is used, the sorting is delegated to the database, and a new <code>SELECT</code> function is performed to get the order. Otherwise, the sorting is performed by Odoo. Depending on what is being manipulated, and depending on the size of the recordsets, there might be some important performance differences.</p>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor297"/>Extending the business logic defined in a model</h1>
			<p>Dividing application functionalities into various modules is a popular practice in Odoo. You may easily <a id="_idIndexMarker330"/>accomplish this by installing or uninstalling the application, which will enable or disable functionalities. Furthermore, you must modify the behavior of some methods that were predefined in the original app when you add new features to it. An old model could occasionally benefit from the addition of fresh fields. This is one of the most useful functions of the underlying framework and the process is quite simple in Odoo.</p>
			<p>In this tutorial, we will see how you can extend the business logic of one method from the method in another module. Additionally, we will use the new module to add new fields to an existing module.</p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor298"/>Getting ready</h2>
			<p>For this tutorial, we will continue to use the <code>my_hostel</code> module from the last tutorial. Make sure that you have the <code>hostel.room.category</code> model in the <code>my_hostel</code> module.</p>
			<p>For this tutorial, we will create a new module called <code>my_hostel_terminate</code>, which depends on the <code>my_ hostel</code> module. In this module, we will manage termination dates from the hostel. We will also automatically calculate the withdrawal date based on the category.</p>
			<p>In the <em class="italic">How to add features to a model using inheritance</em> tutorial in <a href="B20997_04.xhtml#_idTextAnchor118"><em class="italic">Chapter 4</em></a>, <em class="italic">Application Models</em>, we saw how <a id="_idIndexMarker331"/>to add a field to the existing model. In this module, extend the <code>hostel.room</code> model as follows:</p>
			<pre class="source-code">
class HostelRoom(models.Model):
    _inherit = 'hostel.room'
    date_terminate = fields.Date('Date of Termination')</pre>			<p>Then, extend the <code>hostel.room.category</code> model, as follows:</p>
			<pre class="source-code">
class RoomCategory(models.Model):
    _inherit = 'hostel.room.category'
    max_allow_days = fields.Integer(
        'Maximum allows days',
        help="For how many days room can be borrowed",
        default=365)</pre>			<p>To add this field in views, you need to follow the <em class="italic">Changing existing views – view inheritance</em> tutorial from <a href="B20997_09.xhtml#_idTextAnchor446"><em class="italic">Chapter 9</em></a>, <em class="italic">Backend Views</em>. You can find a full example of the code at <a href="https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition">https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition</a>.</p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor299"/>How to do it…</h2>
			<p>To extend <a id="_idIndexMarker332"/>the business logic in the <code>hostel.room</code> model, you need to perform the following steps:</p>
			<ol>
				<li>From <code>my_hostel_terminate</code>, we want to set <code>date_terminate</code> in the <code>rooms</code> record when we change the room status to <code>Closed</code>. For this, we will override the <code>make_closed</code> method from the <code>my_ </code><code>hostel_terminate</code> module:<pre class="source-code">
def make_closed(self):
    day_to_allocate = self.category_id.max_allow_days or 10
    self.date_return = fields.Date.today() + timedelta(days=day_to_allocate)
    return super(HostelRoom, self).make_closed()</pre></li>				<li>We also want to reset <code>date_terminate</code> when the room is returned and available to borrow, so we will override the <code>make_available</code> method to reset the date:<pre class="source-code">
    def make_available(self):
        self.date_terminate = False
        return super(HostelRoom, self).make_available()</pre></li>			</ol>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor300"/>How it works…</h2>
			<p><em class="italic">Steps 1</em> and <em class="italic">2</em>, in the preceding section, carry out the extension of the business logic. We define a model that extends <code>hostel.room</code> and redefines the <code>make_closed()</code> and <code>make_available()</code> methods. In the last line of both methods, the result that was implemented by the parent class is returned:</p>
			<pre class="source-code">
return super(HostelRoom, self).make_closed()</pre>			<p>In the case of Odoo models, the parent class is not what you’d expect by looking at the Python class definition. The framework has dynamically generated a class hierarchy for our recordset, and the parent class is the definition of the model from the modules that we depend on. So, the call to <code>super()</code> brings back the implementation of <code>hostel.room</code> from <code>my_hostel</code>. In this implementation, <code>make_closed()</code> changes the state of the <a id="_idIndexMarker333"/>room to <code>Closed</code>. So, calling <code>super()</code> will invoke the parent method and it will set the room state to <code>Closed</code>.</p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor301"/>There’s more…</h2>
			<p>In this tutorial, we choose <a id="_idIndexMarker334"/>to extend the default implementation <a id="_idIndexMarker335"/>of the methods. In the <code>make_closed()</code> and <code>make_available()</code> methods, we modified the returned result <em class="italic">before</em> the <code>super()</code> call. Note that, when you call <code>super()</code>, it will execute the default implementation. It is also possible to perform some actions <em class="italic">after</em> the <code>super()</code> call. Of course, we can also do both at the same time.</p>
			<p>To alter a method’s behavior in the midst, though, is more challenging. To do this, we must restructure the code in order to extract an extension point to a different function, which we can then override in the extension module.</p>
			<p>You might be inspired to rewrite a function from scratch. Always proceed with extreme caution. The extension mechanism and maybe the add-ons that extend the method are broken if you do not use the <code>super()</code> implementation of your method, which means that the extension methods will never be invoked. Avoid doing this unless you are working in a controlled environment where you are certain which add-ons are installed and you have verified that you are not breaking them. Additionally, if necessary, make sure to clearly document everything you do.</p>
			<p>What can you do before and after calling the original implementation of the method? There are lots of things, including (but not limited to) the following:</p>
			<ul>
				<li>Change the arguments that are sent to the initial implementation (in the past)</li>
				<li>Alter the context that was previously provided to the original implementation</li>
				<li>Change the outcome that the initial implementation returned (after)</li>
				<li>Call another method (before and after)</li>
				<li>Create records (before and after)</li>
				<li>Raise a <code>UserError</code> error to cancel the execution in forbidden cases (before and after)</li>
				<li>Split <code>self</code> into smaller recordsets and call the original implementation on each of the subsets in a different way (before)</li>
			</ul>
			<h1 id="_idParaDest-241"><a id="_idTextAnchor302"/>Extending write() and create()</h1>
			<p>Extending the business logic defined in a model tutorial from this chapter showed us how to extend <a id="_idIndexMarker336"/>methods that are defined on a model class. If you think about it, methods that are defined on the parent class of the model are also part of the <a id="_idIndexMarker337"/>model. This means that all the base methods that are defined on <code>models.Model</code> (actually, on <code>models.BaseModel</code>, which is the parent class of <code>models.Model</code>) are also available and can be extended.</p>
			<p>This tutorial shows you how to extend <code>create()</code> and <code>write()</code> to control access to some fields of the records.</p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor303"/>Getting ready</h2>
			<p>We will extend the library example from the <code>my_hostel</code> add-on module in <a href="B20997_03.xhtml#_idTextAnchor083"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating Odoo </em><em class="italic">Add-On Modules</em>.</p>
			<p>Add a <code>remarks</code> field to the <code>hostel.room</code> model. We only want members of the <code>Hostel Managers</code> group to be able to write to that field:</p>
			<pre class="source-code">
from odoo import models, api, exceptions
class HostelRoom(models.Model):
    _name = 'hostel.room'
    remarks = fields.Text('Remarks')</pre>			<p>Add the <code>remarks</code> field to the <code>&lt;form&gt;</code> view of the <code>view/hostel_room.xml</code> file to access this field from the user interface:</p>
			<pre class="source-code">
&lt;field name="remarks"/&gt;</pre>			<p>Modify the <code>security/ir.model.access.csv</code> file to give write access to library users:</p>
			<pre class="source-code">
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_hostel,hostel.room.user,model_hostel_room,base.group_user,1,1,0,0</pre>			<h2 id="_idParaDest-243"><a id="_idTextAnchor304"/>How to do it…</h2>
			<p>To prevent users <a id="_idIndexMarker338"/>who are not members of the manager group from modifying <a id="_idIndexMarker339"/>the value of <code>remarks</code>, you need to perform the following steps:</p>
			<ol>
				<li>Extend the <code>create()</code> method, as follows:<pre class="source-code">
    @api.model
    def create(self, values):
        if not self.user_has_groups('my_hostel.group_hostel_manager'):
            if values.get('remarks'):
                raise UserError(
                    'You are not allowed to modify '
                    'remarks'
                )
        return super(HostelRoom, self).create(values)</pre></li>				<li>Extend the <code>write()</code> method, as follows:<pre class="source-code">
    def write(self, values):
        if not self.user_has_groups('my_hostel.group_hostel_manager'):
            if values.get('remarks'):
                raise UserError(
                    'You are not allowed to modify '
                    'manager_remarks'
                )
        return super(HostelRoom, self).write(values)</pre></li>			</ol>
			<p>Install the module to see the code in action. Now, only a manager type of user can modify the <code>remarks</code> field. To test this implementation, you can log in as a demo user or revoke manager access from the current user.</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor305"/>How it works…</h2>
			<p><em class="italic">Step 1</em> in the preceding <a id="_idIndexMarker340"/>section redefines the <code>create()</code> method. Before <a id="_idIndexMarker341"/>calling the base implementation of <code>create()</code>, our method uses the <code>user_has_groups()</code> method to check whether the user belongs to the <code>my_hostel.group_hostel_manager</code> group (this is the XML ID of the group). If this is not the case and a value is passed for <code>remarks</code>, a <code>UserError</code> exception is raised, preventing the creation of the record. This check is performed before the base implementation is called.</p>
			<p><em class="italic">Step 2</em> does the same thing for the <code>write()</code> method. Prior to writing, we check the group and the presence of the field in the values so we can write and raise a <code>UserError</code> exception if there is a problem.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Having the field set to read only in the web client does not prevent RPC calls from writing it. This is why we extend <code>create()</code> and <code>write()</code>.</p>
			<p>In this tutorial, you have seen how you can override the <code>create()</code> and <code>write()</code> methods. However, note that this is not limited to the <code>create()</code> and <code>write()</code> methods. You can override any model method. For example, let’s say you want to do something when the record is deleted. To do so, you need to override the <code>unlink()</code> method (the <code>unlink()</code> method will be called when the record is deleted). Here is the small code snippet to override the <code>unlink()</code> method:</p>
			<pre class="source-code">
def unlink(self):
    # your logic
    return super(HostelRoom, self).unlink()</pre>			<p class="callout-heading">Warning</p>
			<pre>super(…).unlink()</strong>, records would not be deleted.</pre>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor306"/>There’s more…</h2>
			<p>When extending <code>write()</code>, note that, before calling the <code>super()</code> implementation of <code>write()</code>, <code>self</code> is still unmodified. You can use this to compare the current values of the fields to the ones in the <code>values</code> dictionary.</p>
			<p>In this tutorial, we chose <a id="_idIndexMarker342"/>to raise an exception, but we could have also <a id="_idIndexMarker343"/>chosen to remove the offending field from the <code>values</code> dictionary and silently skipped updating that field in the record:</p>
			<pre class="source-code">
def write(self, values):
    if not self.user_has_groups('my_hostel.group_hostel_manager'):
        if values.get('remarks'):
            del values['remarks']
    return super(HostelRoom, self).write(values)</pre>			<p>After calling <code>super().write()</code>, if you want to perform additional actions, you have to be wary of anything that can cause another call to <code>write()</code>, or you will create an infinite recursion loop. The workaround is to put a marker in the context that will be checked to break the recursion:</p>
			<pre class="source-code">
class MyModel(models.Model):
    def write(self, values):
        sup = super(MyModel, self).write(values)
        if self.env.context.get('MyModelLoopBreaker'):
            return
        self = self.with_context(MyModelLoopBreaker=True)
        self.compute_things() # can cause calls to writes
        return sup</pre>			<p>In the <a id="_idIndexMarker344"/>preceding example, we have added the <code>MyModelLoopBreaker</code> key before calling <a id="_idIndexMarker345"/>the <code>compute_things()</code> method. So, if the <code>write()</code> method is called again, it doesn’t go in an infinite loop.</p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor307"/>Customizing how records are searched</h1>
			<p>The <em class="italic">Defining the model representation and order</em> tutorial in <a href="B20997_03.xhtml#_idTextAnchor083"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating Odoo Add-On Modules</em>, introduced the <code>name_get()</code> method, which is used to compute a <a id="_idIndexMarker346"/>representation of the record in various places, including in the widget that’s used to display <code>Many2one</code> relations in the web client.</p>
			<p>This tutorial will show you how to search for a room in the <code>Many2one</code> widget by room number and name by redefining <code>name_search</code>.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor308"/>Getting ready</h2>
			<p>For this tutorial, we will use the following model definition:</p>
			<pre class="source-code">
class HostelRoom(models.Model):
    def name_get(self):
        result = []
        for room in self:
            member = room.member_ids.mapped('name')
            name = '%s (%s)' % (room.name, ', '.join(member))
            result.append((room.id, name))
            return result</pre>			<p>When using this model, a room in a <code>Many2one</code> widget is displayed as <code>name_search</code> only uses the attribute referred to by the <code>_rec_name</code> attribute of the model class, which, in our case, is <code>'name'</code>. We also want to allow filtering by room number.</p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor309"/>How to do it…</h2>
			<p>You need to <a id="_idIndexMarker347"/>perform the following steps in order to execute this tutorial:</p>
			<ol>
				<li>To be able to search for <code>hostel.room</code> either by the room’s name, one of the members, or the room number, you need to define the <code>_name_search()</code> method in the <code>HostelRoom</code> class, as follows:<pre class="source-code">
@api.model
def _name_search(self, name='', args=None, operator='ilike',
                  limit=100, name_get_uid=None):
     args = [] if args is None else args.copy()
     if not(name == '' and operator == 'ilike'):
         args += ['|', '|',
                  ('name', operator, name),
                  ('isbn', operator, name),
                  ('author_ids.name', operator, name)
                  ]
     return super(HostelRoom, self)._name_search(
         name=name, args=args, operator=operator,
         limit=limit, name_get_uid=name_get_uid)</pre></li>				<li>Add the <code>previous_room_id</code> <code>Many2one</code> field in t<a id="_idTextAnchor310"/>he <code>hostel.room</code> model to test the <code>_name_search</code> implementation:<pre class="source-code">
previous_room = fields.Many2one('hostel.room', string='Previous Room')</pre></li>				<li>Add the following field to the user interface:<pre class="source-code">
&lt;field name="previous_room_id" /&gt;</pre></li>				<li>Restart and update the module to reflect these changes.</li>
			</ol>
			<p>You can invoke the <code>_name_search</code> method by searching in the <code>previous_room_id</code> <code>Many2one</code> field.</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor311"/>How it works…</h2>
			<p>The default <a id="_idIndexMarker348"/>implementation of <code>name_search()</code> actually only calls the <code>_name_search()</code> method, which does the real job. This <code>_name_search()</code> method has an additional argument, <code>name_get_uid</code>, which is used in some corner cases such as if you want to compute the results using <code>sudo()</code> or with a different user.</p>
			<p>We pass most of the arguments that we receive unchanged to the <code>super()</code> implementation of the method:</p>
			<ul>
				<li><code>name</code> is a string that contains the value the user has typed so far.</li>
				<li><code>args</code> is either <code>None</code> or a search domain that’s used as a prefilter for the possible records. (It can come from the domain parameter of the <code>Many2one</code> relation, for instance.)</li>
				<li><code>operator</code> is a string containing the match operator. Generally, you will have <code>'ilike'</code> or <code>'='</code>.</li>
				<li><code>limit</code> is the maximum number of rows to retrieve.</li>
				<li><code>name_get_uid</code> can be used to specify a different user when calling <code>name_get()</code> to compute the strings to display in the widget.</li>
			</ul>
			<p>Our implementation of the method does the following:</p>
			<ol>
				<li>It generates a new empty list if <code>args</code> is <code>None</code>, and makes a copy of <code>args</code> otherwise. We make a copy to avoid our modifications to the list having side effects on the caller.</li>
				<li>Then, we check that <code>name</code> is not an empty string or that <code>operator</code> is not <code>'ilike'</code>. This is to avoid generating a dumb domain, such as <code>[('name', ilike, '')]</code>, that doesn’t filter anything. In this case, we jump straight to the <code>super()</code> call implementation.</li>
				<li>If we have <code>name</code>, or if <code>operator</code> is not <code>'ilike'</code>, then we add some filtering criteria to <code>args</code>. In our case, we add clauses that will search for the supplied name in the title of the rooms, in their room number, or the members’ names.</li>
				<li>Finally, we call the <code>super()</code> implementation with the modified domain in <code>args</code> and force <code>name</code> to be <code>''</code> and <code>operator</code> to be <code>ilike</code>. We do this to force the <a id="_idIndexMarker349"/>default implementation of <code>_name_search()</code> to not alter the domain it receives, so, the one we specified will be used.</li>
			</ol>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor312"/>There’s more…</h2>
			<p>We mentioned in the introduction that this method is used in the <code>Many2one</code> widget. For completeness, it is also used in the following parts of Odoo:</p>
			<ul>
				<li>When using the <code>in</code> operator on the <code>One2many</code> and <code>Many2many</code> fields in the domain</li>
				<li>To search for records in the <code>many2many_tags</code> widget</li>
				<li>To search for records in the CSV file import</li>
			</ul>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor313"/>See also</h2>
			<p>The <em class="italic">Defining the model representation and order</em> tutorial in <a href="B20997_03.xhtml#_idTextAnchor083"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating Odoo Add-On Modules</em>, demonstrates how to define the <code>name_get()</code> method, which is used to create a text representation of a record.</p>
			<p>The <em class="italic">Defining filters on record lists – domain</em> tutorial in <a href="B20997_09.xhtml#_idTextAnchor446"><em class="italic">Chapter 9</em></a>, <em class="italic">Backe<a id="_idTextAnchor314"/>nd Views</em>, provides more information about search domain syntax.</p>
			<h1 id="_idParaDest-252"><a id="_idTextAnchor315"/>Fetching data in groups using read_group()</h1>
			<p>In the previous tutorials, we saw how we can search and fetch data from the database. However, sometimes, you <a id="_idIndexMarker350"/>want results by <a id="_idIndexMarker351"/>aggregating records, such as the average cost of last month’s sales order. Usually, we use <code>group by</code> and the <code>aggregate</code> function in SQL queries for such a result. Luckily, in Odoo, we have the <code>read_group()</code> method. In this tutorial, you will learn how to use the <code>read_group()</code> method to get the aggregate result.</p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor316"/>Getting ready</h2>
			<p>In this tutorial, we will use the <code>my_hostel</code> add-on module from <a href="B20997_03.xhtml#_idTextAnchor083"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating Odoo </em><em class="italic">Add-On Modules</em>.</p>
			<p>Modify the <code>hostel.room</code> model, as shown in the following model definition:</p>
			<pre class="source-code">
class HostelRoom(models.Model):
    _name = 'hostel.room'
    name = fields.Char('Name', required=True)
    cost_price = fields.Float('Room Cost')
    category_id = fields.Many2one('hostel.room.category')</pre>			<p>Add the <code>hostel.room.category</code> model. For simplicity, we will just add it to the same <code>hostel_room.py</code> file:</p>
			<pre class="source-code">
class HostelCategory(models.Model):
    _name = 'hostel.room.category'
    name = fields.Char('Category')
    description = fields.Text('Description')</pre>			<p>We will be using the <code>hostel.room</code> model and getting an average cost price per category.</p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor317"/>How to do it…</h2>
			<p>To extract <a id="_idIndexMarker352"/>grouped results, we will <a id="_idIndexMarker353"/>add the <code>_get_average_cost</code> method to the <code>hostel.room</code> model, which will use the <code>read_group()</code> method to fetch the data in a group:</p>
			<pre class="source-code">
    @api.model
    def _get_average_cost(self):
        grouped_result = self.read_group(
            [('cost_price', "!=", False)], # Domain
            ['category_id', 'cost_price:avg'], # Fields to access
            ['category_id'] # group_by
            )
        return grouped_result</pre>			<p>To test this implementation, you need to add a button to the user interface that triggers this method. Then, you can print the result in the server log.</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor318"/>How it works…</h2>
			<p>The <code>read_group()</code> method internally uses the SQL <code>groupby</code> and <code>aggregate</code> functions to fetch the data. The most common arguments that are passed to the <code>read_group()</code> method <a id="_idIndexMarker354"/>are as follows:</p>
			<ul>
				<li><code>domain</code>: This is used to filter records for grouping. For more information on <code>domain</code>, refer to the <em class="italic">Searching views</em> tutorial in <a href="B20997_09.xhtml#_idTextAnchor446"><em class="italic">Chapter 9</em></a>, <em class="italic">Backend Views</em>.</li>
				<li><code>fields</code>: This passes the names of fields you want to fetch with the grouped data. Possible values for this argument are as follows:<ul><li><code>field name</code>: You can pass the field name into the <code>fields</code> argument, but if you are using this option, then you must pass this field name to the <code>groupby</code> parameter too, otherwise it will generate an error.</li><li><code>field_name:agg</code>: You can pass the field name with the <code>aggregate</code> function. For example, in <code>cost_price:avg</code>, <code>avg</code> is an SQL aggregate function. A list <a id="_idIndexMarker355"/>of PostgreSQL aggregate functions can be found at <a href="https://www.postgresql.org/docs/current/static/functions-aggregate.html">https://www.postgresql.org/docs/current/static/functions-aggregate.html</a>.</li><li><code>name:agg(field_name)</code>: This is the same as the previous one, but, with this syntax, you can provide column aliases, such as <code>average_price:avg(cost_price)</code>.</li></ul></li>
				<li><code>groupby</code>: This argument accepts a list of field descriptions. Records will be grouped based on these fields. For the <code>date</code> and <code>datetime</code> column, you can pass <code>groupby_function</code> to apply date groupings based on different time durations. You can do grouping based on months for date type fields.</li>
				<li><code>read_group()</code> also supports some optional arguments, as follows:<ul><li><code>offset</code>: This indicates an optional number of records to skip.</li><li><code>limit</code>: This indicates an optional maximum number of records to return.</li><li><code>orderby</code>: If this option is passed, the result will be sorted based on the given fields.</li><li><code>lazy</code>: This accepts Boolean values and, by default, is <code>True</code>. If <code>True</code> is passed, the results are only grouped by the first <code>groupby</code>, and the remaining <code>groupby</code> arguments are put in the <code>__context</code> key. If <code>False</code>, all <code>groupby</code> functions are done in one call.</li></ul></li>
			</ul>
			<p class="callout-heading">Performance tip</p>
			<p class="callout"><code>read_group()</code> is a lot faster <a id="_idIndexMarker356"/>than reading and processing values from a recordset. So, for KPIs or graphs, you should always use <code>read_group()</code>.</p>
		</div>
	</body></html>