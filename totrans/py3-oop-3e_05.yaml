- en: When to Use Object-Oriented Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we've covered many of the defining features of object-oriented
    programming. We now know the principles and paradigms of object-oriented design,
    and we've covered the syntax of object-oriented programming in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet, we don''t know exactly how and, especially, when to utilize these principles
    and syntax in practice. In this chapter, we''ll discuss some useful applications
    of the knowledge we''ve gained, looking at some new topics along the way:'
  prefs: []
  type: TYPE_NORMAL
- en: How to recognize objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data and behaviors, once again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping data behaviors using properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restricting data using behaviors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Don't Repeat Yourself principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognizing repeated code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Treat objects as objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This may seem obvious; you should generally give separate objects in your problem
    domain a special class in your code. We''ve seen examples of this in the case
    studies in previous chapters: first, we identify objects in the problem, and then
    model their data and behaviors.'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying objects is a very important task in object-oriented analysis and
    programming. But it isn't always as easy as counting the nouns in short paragraphs
    that, frankly, I have constructed explicitly for that purpose. Remember, objects
    are things that have both data and behavior. If we are working only with data,
    we are often better off storing it in a list, set, dictionary, or other Python
    data structure (which we'll be covering thoroughly in [Chapter 6](6a121a79-7716-4a8f-94ab-f96781e82d25.xhtml),
    *Python Data Structures*). On the other hand, if we are working only with behavior,
    but no stored data, a simple function is more suitable.
  prefs: []
  type: TYPE_NORMAL
- en: An object, however, has both data and behavior. Proficient Python programmers
    use built-in data structures unless (or until) there is an obvious need to define
    a class. There is no reason to add an extra level of abstraction if it doesn't
    help organize our code. On the other hand, the *obvious* need is not always self-evident.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can often start our Python programs by storing data in a few variables.
    As the program expands, we will later find that we are passing the same set of
    related variables to a set of functions. This is the time to think about grouping
    both variables and functions into a class. If we are designing a program to model
    polygons in two-dimensional space, we might start with each polygon represented
    as a list of points. The points would be modeled as two tuples (*x*, *y*) describing
    where that point is located. This is all data, stored in a set of nested data
    structures (specifically, a list of tuples):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we want to calculate the distance around the perimeter of the polygon,
    we need to sum the distances between each point. To do this, we need a function
    to calculate the distance between two points. Here are two such functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as object-oriented programmers, we clearly recognize that a `polygon`
    class could encapsulate the list of points (data) and the `perimeter` function
    (behavior). Further, a `point` class, such as we defined in [Chapter 2](0786c893-abb9-4f35-9320-3f2f54de95eb.xhtml),
    *Objects in Python*, might encapsulate the `x` and `y` coordinates and the `distance`
    method. The question is: is it valuable to do this?'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the previous code, maybe yes, maybe no. With our recent experience in object-oriented
    principles, we can write an object-oriented version in record time. Let''s compare
    them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the highlighted sections, there is twice as much code here
    as there was in our earlier version, although we could argue that the `add_point`
    method is not strictly necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to understand the differences a little better, let''s compare the two
    APIs in use. Here''s how to calculate the perimeter of a square using the object-oriented
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s fairly succinct and easy to read, you might think, but let''s compare
    it to the function-based code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Hmm, maybe the object-oriented API isn't so compact! That said, I'd argue that
    it was easier to *read* than the functional example. How do we know what the list
    of tuples is supposed to represent in the second version? How do we remember what
    kind of object we're supposed to pass into the `perimeter` function? (a list of
    two tuples? That's not intuitive!) We would need a lot of documentation to explain
    how these functions should be used.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, the object-oriented code is relatively self-documenting. We just
    have to look at the list of methods and their parameters to know what the object
    does and how to use it. By the time we wrote all the documentation for the functional
    version, it would probably be longer than the object-oriented code.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, code length is not a good indicator of code complexity. Some programmers
    get hung up on complicated *one liners* that do an incredible amount of work in
    one line of code. This can be a fun exercise, but the result is often unreadable,
    even to the original author the following day. Minimizing the amount of code can
    often make a program easier to read, but do not blindly assume this is the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, this trade-off isn''t necessary. We can make the object-oriented `Polygon`
    API as easy to use as the functional implementation. All we have to do is alter
    our `Polygon` class so that it can be constructed with multiple points. Let''s
    give it an initializer that accepts a list of `Point` objects. In fact, let''s
    allow it to accept tuples too, and we can construct the `Point` objects ourselves,
    if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This initializer goes through the list and ensures that any tuples are converted
    to points. If the object is not a tuple, we leave it as is, assuming that it is
    either a `Point` object already, or an unknown duck-typed object that can act
    like a `Point` object.
  prefs: []
  type: TYPE_NORMAL
- en: If you are experimenting with the above code, you could subclass `Polygon` and
    override the `__init__` function instead of replacing the initializer or copying
    the `add_point` and `perimeter` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Still, there's no clear winner between the object-oriented and more data-oriented
    versions of this code. They both do the same thing. If we have new functions that
    accept a polygon argument, such as `area(polygon)` or `point_in_polygon(polygon,
    x, y)`, the benefits of the object-oriented code become increasingly obvious.
    Likewise, if we add other attributes to the polygon, such as `color` or `texture`,
    it makes more and more sense to encapsulate that data into a single class.
  prefs: []
  type: TYPE_NORMAL
- en: The distinction is a design decision, but in general, the more important a set
    of data is, the more likely it is to have multiple functions specific to that
    data, and the more useful it is to use a class with attributes and methods instead.
  prefs: []
  type: TYPE_NORMAL
- en: When making this decision, it also pays to consider how the class will be used.
    If we're only trying to calculate the perimeter of one polygon in the context
    of a much greater problem, using a function will probably be quickest to code
    and easier to use *one time only*. On the other hand, if our program needs to
    manipulate numerous polygons in a wide variety of ways (calculating the perimeter,
    area, and intersection with other polygons, moving or scaling them, and so on),
    we have almost certainly identified an object; one that needs to be extremely
    versatile.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, pay attention to the interaction between objects. Look for inheritance
    relationships; inheritance is impossible to model elegantly without classes, so
    make sure to use them. Look for the other types of relationships we discussed
    in [Chapter 1](f3a06c74-ab7f-450f-9663-bfe014b359bf.xhtml), *Object-Oriented Design*,
    association and composition. Composition can, technically, be modeled using only
    data structures; for example, we can have a list of dictionaries holding tuple
    values, but it is sometimes less complicated to create a few classes of objects,
    especially if there is behavior associated with the data.
  prefs: []
  type: TYPE_NORMAL
- en: Don't rush to use an object just because you can use an object, but don't neglect
    to create a class when you need to use a class.
  prefs: []
  type: TYPE_NORMAL
- en: Adding behaviors to class data with properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we've focused on the separation of behavior and data.
    This is very important in object-oriented programming, but we're about to see
    that, in Python, the distinction is uncannily blurry. Python is very good at blurring
    distinctions; it doesn't exactly help us to *think outside the box*. Rather, it
    teaches us to stop thinking about the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get into the details, let''s discuss some bad object-oriented theory.
    Many object-oriented languages teach us to never access attributes directly (Java
    is the most notorious). They insist that we write attribute access like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The variables are prefixed with an underscore to suggest that they are private
    (other languages would actually force them to be private). Then, the `get` and
    `set` methods provide access to each variable. This class would be used in practice
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not nearly as readable as the direct access version that Python favors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So, why would anyone insist upon the method-based syntax? Their reasoning is
    that, someday, we may want to add extra code when a value is set or retrieved.
    For example, we could decide to cache a value to avoid complex computations, or
    we might want to validate that a given value is a suitable input.
  prefs: []
  type: TYPE_NORMAL
- en: 'In code, for example, we could decide to change the `set_name()` method as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in Java and similar languages, if we had written our original code for
    direct attribute access, and then later changed it to a method like the preceding
    one, we''d have a problem: anyone who had written code that accessed the attribute
    directly would now have to access a method. If they didn''t then change the access
    style from attribute access to a function call, their code will be broken.'
  prefs: []
  type: TYPE_NORMAL
- en: The mantra in these languages is that we should never make public members private.
    This doesn't make much sense in Python since there isn't any real concept of private
    members!
  prefs: []
  type: TYPE_NORMAL
- en: 'Python gives us the `property` keyword to make methods that *look* like attributes.
    We can therefore write our code to use direct member access, and if we ever unexpectedly
    need to alter the implementation to do some calculation when getting or setting
    that attribute''s value, we can do so without changing the interface. Let''s see
    how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Compared to the earlier class, we first change the `name` attribute into a (semi-)private
    `_name` attribute. Then, we add two more (semi-)private methods to get and set
    that variable, performing our validation when we set it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have the `property` declaration at the bottom. This is the Python
    magic. It creates a new attribute on the `Color` class called `name`, to replace
    the direct `name` attribute. It sets this attribute to be a **property**. Under
    the hood, `property` calls the two methods we just created whenever the value
    is accessed or changed. This new version of the `Color` class can be used exactly
    the same way as the earlier version, yet it now performs validation when we set
    the `name` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: So, if we'd previously written code to access the `name` attribute, and then
    changed it to use our `property`-based object, the previous code would still work,
    unless it was sending an empty `property` value, which is the behavior we wanted
    to forbid in the first place. Success!
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that, even with the `name` property, the previous code is not 100%
    safe. People can still access the `_name` attribute directly and set it to an
    empty string if they want to. But if they access a variable we've explicitly marked
    with an underscore to suggest it is private, they're the ones that have to deal
    with the consequences, not us.
  prefs: []
  type: TYPE_NORMAL
- en: Properties in detail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Think of the `property` function as returning an object that proxies any requests
    to set or access the attribute value through the methods we have specified. The
    `property` built-in is like a constructor for such an object, and that object
    is set as the public-facing member for the given attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `property` constructor can actually accept two additional arguments, a
    `delete` function and a docstring for the property. The `delete` function is rarely
    supplied in practice, but it can be useful for logging the fact that a value has
    been deleted, or possibly to veto deleting if we have reason to do so. The docstring
    is just a string describing what the property does, no different from the docstrings
    we discussed in [Chapter 2](0786c893-abb9-4f35-9320-3f2f54de95eb.xhtml), *Objects
    in Python*. If we do not supply this parameter, the docstring will instead be
    copied from the docstring for the first argument: the `getter` method. Here is
    a silly example that states whenever any of the methods are called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we actually use this class, it does indeed print out the correct strings
    when we ask it to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, if we look at the help file for the `Silly` class (by issuing `help(Silly)`
    at the interpreter prompt), it shows us the custom docstring for our `silly` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, everything is working as we planned. In practice, properties are
    normally only defined with the first two parameters: the `getter` and `setter`
    functions. If we want to supply a docstring for a property, we can define it on
    the `getter` function; the property proxy will copy it into its own docstring.
    The `delete` function is often left empty because object attributes are so rarely
    deleted. If a coder does try to delete a property that doesn''t have a `delete`
    function specified, it will raise an exception. Therefore, if there is a legitimate
    reason to delete our property, we should supply that function.'
  prefs: []
  type: TYPE_NORMAL
- en: Decorators – another way to create properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've never used Python decorators before, you might want to skip this section
    and come back to it after we've discussed the decorator pattern in [Chapter 10](345fe617-9a90-4c59-9355-e7076759f9a4.xhtml),
    *Python Design Patterns I*. However, you don't need to understand what's going
    on to use the decorator syntax in order to make property methods more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `property` function can be used with the decorator syntax to turn a `get`
    function into a `property` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This applies the `property` function as a decorator, and is equivalent to the
    previous `foo = property(foo)` syntax. The main difference, from a readability
    perspective, is that we get to mark the `foo` function as a property at the top
    of the method, instead of after it is defined, where it can be easily overlooked.
    It also means we don't have to create private methods with underscore prefixes
    just to define a property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going one step further, we can specify a `setter` function for the new property
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This syntax looks pretty odd, although the intent is obvious. First, we decorate
    the `foo` method as a getter. Then, we decorate a second method with exactly the
    same name by applying the `setter` attribute of the originally decorated `foo`
    method! The `property` function returns an object; this object always comes with
    its own `setter` attribute, which can then be applied as a decorator to other
    functions. Using the same name for the get and set methods is not required, but
    it does help to group together the multiple methods that access one property.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also specify a `delete` function with `@foo.deleter`. We cannot specify
    a docstring using `property` decorators, so we need to rely on the property copying
    the docstring from the initial getter method. Here''s our previous `Silly` class
    rewritten to use `property` as a decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This class operates *exactly* the same as our earlier version, including the
    help text. You can use whichever syntax you feel is more readable and elegant.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding when to use properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the built-in property clouding the division between behavior and data,
    it can be confusing to know when to choose an attribute, or a method, or a property.
    The use case example we saw earlier is one of the most common uses of properties;
    we have some data on a class that we later want to add behavior to. There are
    also other factors to take into account when deciding to use a property.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, in Python, data, properties, and methods are all attributes on
    a class. The fact that a method is callable does not distinguish it from other
    types of attributes; indeed, we'll see in [Chapter 7](b70c8ea0-4778-4005-af13-bdae3d90d2c6.xhtml),
    *Python Object-Oriented Shortcuts*, that it is possible to create normal objects
    that can be called like functions. We'll also discover that functions and methods
    are themselves normal objects.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that methods are just callable attributes, and properties are just
    customizable attributes, can help us make this decision. Methods should typically
    represent actions; things that can be done to, or performed by, the object. When
    you call a method, even with only one argument, it should *do* something. Method
    names are generally verbs.
  prefs: []
  type: TYPE_NORMAL
- en: Once confirming that an attribute is not an action, we need to decide between
    standard data attributes and properties. In general, always use a standard attribute
    until you need to control access to that property in some way. In either case,
    your attribute is usually a noun. The only difference between an attribute and
    a property is that we can invoke custom actions automatically when a property
    is retrieved, set, or deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a more realistic example. A common need for custom behavior is
    caching a value that is difficult to calculate or expensive to look up (requiring,
    for example, a network request or database query). The goal is to store the value
    locally to avoid repeated calls to the expensive calculation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this with a custom getter on the property. The first time the value
    is retrieved, we perform the lookup or calculation. Then, we can locally cache
    the value as a private attribute on our object (or in dedicated caching software),
    and the next time the value is requested, we return the stored data. Here''s how
    we might cache a web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test this code to see that the page is only retrieved once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'I was on an awful satellite connection when I originally tested this code for
    the first version of this book back in 2010 and it took 20 seconds the first time
    I loaded the content. The second time, I got the result in 2 seconds (which is
    really just the amount of time it took to type the lines into the interpreter).
    On my more modern connection it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It takes about 620 milliseconds to retrieve a page from my web host. From my
    laptop's RAM, it takes 0.018 milliseconds!
  prefs: []
  type: TYPE_NORMAL
- en: 'Custom getters are also useful for attributes that need to be calculated on
    the fly, based on other object attributes. For example, we might want to calculate
    the average for a list of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This very simple class inherits from `list`, so we get list-like behavior for
    free. We just add a property to the class, and hey presto, our list can have an
    average as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we could have made this a method instead, but then we ought to call
    it `calculate_average()`, since methods represent actions. But a property called
    `average` is more suitable, and is both easier to type and easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: Custom setters are useful for validation, as we've already seen, but they can
    also be used to proxy a value to another location. For example, we could add a
    content setter to the `WebPage` class that automatically logs into our web server
    and uploads a new page whenever the value is set.
  prefs: []
  type: TYPE_NORMAL
- en: Manager objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've been focused on objects and their attributes and methods. Now, we'll take
    a look at designing higher-level objects; the kind of objects that manage other
    objects – the objects that tie everything together.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between these objects and most of the previous examples is that
    the latter usually represent concrete ideas. Management objects are more like
    office managers; they don't do the actual *visible* work out on the floor, but
    without them, there would be no communication between departments and nobody would
    know what they are supposed to do (although, this can be true anyway if the organization
    is badly managed!). Analogously, the attributes on a management class tend to
    refer to other objects that do the *visible* work; the behaviors on such a class
    delegate to those other classes at the right time, and pass messages between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we''ll write a program that does a find-and-replace action for
    text files stored in a compressed ZIP file. We''ll need objects to represent the
    ZIP file and each individual text file (luckily, we don''t have to write these
    classes, as they''re available in the Python standard library). The manager object
    will be responsible for ensuring the following three steps occur in order:'
  prefs: []
  type: TYPE_NORMAL
- en: Unzipping the compressed file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Performing the find-and-replace action
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Zipping up the new files
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The class is initialized with the `.zip` filename, and search and replace strings.
    We create a temporary directory to store the unzipped files in, so that the folder
    stays clean. The `pathlib` library helps out with file and directory manipulation.
    We''ll learn more about it in [Chapter 8](9a6335a2-1c69-4fa8-a685-02bbeeba23be.xhtml),
    *Strings and Serialization*, but the interface should be pretty clear in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create an overall *manager* method for each of the three steps. This
    method delegates responsibility to other objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, we could do all three steps in one method, or indeed in one script,
    without ever creating an object. There are several advantages to separating the
    three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Readability**: The code for each step is in a self-contained unit that is
    easy to read and understand. The method name describes what the method does, and
    less additional documentation is required to understand what is going on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensibility**: If a subclass wanted to use compressed TAR files instead
    of ZIP files, it could override the `zip` and `unzip` methods without having to
    duplicate the `find_replace` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partitioning**: An external class could create an instance of this class
    and call the `find_replace` method directly on some folder without having to `zip`
    the content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The delegation method is the first in the following code; the rest of the methods
    are included for completeness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: For brevity, the code for zipping and unzipping files is sparsely documented.
    Our current focus is on object-oriented design; if you are interested in the inner
    details of the `zipfile` module, refer to the documentation in the standard library,
    either online or by typing `import zipfile ; help(zipfile)` into your interactive
    interpreter. Note that this toy example only searches the top-level files in a
    ZIP file; if there are any folders in the unzipped content, they will not be scanned,
    nor will any files inside those folders.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a Python version older than 3.6, you will need to convert the
    path objects to strings before calling `extractall`, `rmtree`, and `file.write`
    on the `ZipFile` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last two lines in the example allow us to run the program from the command
    line by passing the `zip` filename, the search string, and the replace string
    as arguments, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this object does not have to be created from the command line; it
    could be imported from another module (to perform batch ZIP file processing),
    or accessed as part of a GUI interface or even a higher-level management object
    that knows where to get ZIP files (for example, to retrieve them from an FTP server
    or back them up to an external disk).
  prefs: []
  type: TYPE_NORMAL
- en: As programs become more and more complex, the objects being modeled become less
    and less like physical objects. Properties are other abstract objects, and methods
    are actions that change the state of those abstract objects. But at the heart
    of every object, no matter how complex, is a set of concrete data and well-defined
    behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Removing duplicate code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, the code in management style classes such as `ZipReplace` is quite generic
    and can be applied in a variety of ways. It is possible to use either composition
    or inheritance to help keep this code in one place, thus eliminating duplicate
    code. Before we look at any examples of this, let's discuss a tiny bit of theory.
    Specifically, why is duplicate code a bad thing?
  prefs: []
  type: TYPE_NORMAL
- en: There are several reasons, but they all boil down to readability and maintainability.
    When we're writing a new piece of code that is similar to an earlier piece, the
    easiest thing to do is copy the old code and change whatever needs to be changed
    (variable names, logic, comments) to make it work in the new location. Alternatively,
    if we're writing new code that seems similar, but not identical, to code elsewhere
    in the project, it is often easier to write fresh code with similar behavior,
    rather than figuring out how to extract the overlapping functionality.
  prefs: []
  type: TYPE_NORMAL
- en: But as soon as someone has to read and understand the code and they come across
    duplicate blocks, they are faced with a dilemma. Code that might have appeared
    to make sense suddenly has to be understood. How is one section different from
    the other? How are they the same? Under what conditions is one section called?
    When do we call the other? You might argue that you're the only one reading your
    code, but if you don't touch that code for eight months, it will be as incomprehensible
    to you as it is to a fresh coder. When we're trying to read two similar pieces
    of code, we have to understand why they're different, as well as how they're different.
    This wastes the reader's time; code should always be written to be readable first.
  prefs: []
  type: TYPE_NORMAL
- en: I once had to try to understand someone's code that had three identical copies
    of the same 300 lines of very poorly written code. I had been working with the
    code for a month before I finally comprehended that the three *identical* versions
    were actually performing slightly different tax calculations. Some of the subtle
    differences were intentional, but there were also obvious areas where someone
    had updated a calculation in one function without updating the other two. The
    number of subtle, incomprehensible bugs in the code could not be counted. I eventually
    replaced all 900 lines with an easy-to-read function of 20 lines or so.
  prefs: []
  type: TYPE_NORMAL
- en: Reading such duplicate code can be tiresome, but code maintenance is even more
    tormenting. As the preceding story suggests, keeping two similar pieces of code
    up to date can be a nightmare. We have to remember to update both sections whenever
    we update one of them, and we have to remember how multiple sections differ so
    we can modify our changes when we are editing each of them. If we forget to update
    all sections, we will end up with extremely annoying bugs that usually manifest
    themselves as, But I fixed that already, why is it still happening*?*
  prefs: []
  type: TYPE_NORMAL
- en: The result is that people who are reading or maintaining our code have to spend
    astronomical amounts of time understanding and testing it compared to the time
    required to write it in a non-repetitive manner in the first place. It's even
    more frustrating when we are the ones doing the maintenance; we find ourselves
    saying, Why didn't I do this right the first time? The time we save by copying
    and pasting existing code is lost the very first time we have to maintain it.
    Code is both read and modified many more times and much more often than it is
    written. Comprehensible code should always be a priority.
  prefs: []
  type: TYPE_NORMAL
- en: This is why programmers, especially Python programmers (who tend to value elegant
    code more than average developers), follow what is known as the **Don't Repeat
    Yourself** (**DRY**) principle. DRY code is maintainable code. My advice for beginning
    programmers is to never use the copy-and-paste feature of their editor. To intermediate
    programmers, I suggest they think thrice before they hit *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: But what should we do instead of code duplication? The simplest solution is
    often to move the code into a function that accepts parameters to account for
    whatever parts are different. This isn't a terribly object-oriented solution,
    but it is frequently optimal.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we have two pieces of code that unzip a ZIP file into two different
    directories, we can easily replace it with a function that accepts a parameter
    for the directory to which it should be unzipped. This may make the function itself
    slightly more difficult to read, but a good function name and docstring can easily
    make up for that, and any code that invokes the function will be easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s certainly enough theory! The moral of the story is: always make the
    effort to refactor your code to be easier to read instead of writing bad code
    that may seem easier to write.'
  prefs: []
  type: TYPE_NORMAL
- en: In practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's explore two ways we can reuse existing code. After writing our code to
    replace strings in a ZIP file full of text files, we are later contracted to scale
    all the images in a ZIP file to 640 x 480\. It looks like we could use a very
    similar paradigm to what we used in `ZipReplace`. Our first impulse might be to
    save a copy of that file and change the `find_replace` method to `scale_image`
    or something similar.
  prefs: []
  type: TYPE_NORMAL
- en: But, that's suboptimal. What if someday we want to change the `unzip` and `zip`
    methods to also open TAR files? Or maybe we'll want to use a guaranteed unique
    directory name for temporary files. In either case, we'd have to change it in
    two different places!
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by demonstrating an inheritance-based solution to this problem.
    First, we''ll modify our original `ZipReplace` class into a superclass for processing
    generic ZIP files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We changed the `filename` property to `zipname` to avoid confusion with the
    `filename` local variables inside the various methods. This helps make the code
    more readable, even though it isn't actually a change in design.
  prefs: []
  type: TYPE_NORMAL
- en: We also dropped the two parameters to `__init__` (`search_string` and `replace_string`)
    that were specific to `ZipReplace`. Then, we renamed the `zip_find_replace` method
    to `process_zip` and made it call an (as yet undefined) `process_files` method
    instead of `find_replace`; these name changes help demonstrate the more generalized
    nature of our new class. Notice that we have removed the `find_replace` method
    altogether; that code is specific to `ZipReplace` and has no business here.
  prefs: []
  type: TYPE_NORMAL
- en: This new `ZipProcessor` class doesn't actually define a `process_files` method.
    If we ran it directly, it would raise an exception. Because it isn't meant to
    run directly, we removed the main call at the bottom of the original script. We
    could make this an abstract base class in order to communicate that this method
    needs to be defined in a subclass, but I've left it out for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, before we move on to our image processing application, let''s fix up our
    original `zipsearch` class to make use of this parent class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This code is shorter than the original version, since it inherits its ZIP processing
    abilities from the parent class. We first import the base class we just wrote
    and make `ZipReplace` extend that class. Then, we use `super()` to initialize
    the parent class. The `find_replace` method is still here, but we renamed it `process_files`
    so the parent class can call it from its management interface. Because this name
    isn't as descriptive as the old one, we added a docstring to describe what it
    is doing.
  prefs: []
  type: TYPE_NORMAL
- en: Now, that was quite a bit of work, considering that all we have now is a program
    that is functionally not different from the one we started with! But having done
    that work, it is now much easier for us to write other classes that operate on
    files in a ZIP archive, such as the (hypothetically requested) photo scaler. Further,
    if we ever want to improve or bug fix the zip functionality, we can do it for
    all subclasses at once by changing only the one `ZipProcessor` base class. Therefore
    maintenance will be much more effective.
  prefs: []
  type: TYPE_NORMAL
- en: 'See how simple it is now to create a photo scaling class that takes advantage
    of the `ZipProcessor` functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Look how simple this class is! All that work we did earlier paid off. All we
    do is open each file (assuming that it is an image; it will unceremoniously crash
    if a file cannot be opened or isn't an image), scale it, and save it back. The
    `ZipProcessor` class takes care of the zipping and unzipping without any extra
    work on our part.
  prefs: []
  type: TYPE_NORMAL
- en: Case study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this case study, we'll try to delve further into the question, When should
    I choose an object versus a built-in type? We'll be modeling a `Document` class
    that might be used in a text editor or word processor. What objects, functions,
    or properties should it have?
  prefs: []
  type: TYPE_NORMAL
- en: We might start with a `str` for the `Document` contents, but in Python, strings
    aren't mutable (able to be changed). Once a `str` is defined, it is forever. We
    can't insert a character into it or remove one without creating a brand new string
    object. That would be leaving a lot of `str` objects taking up memory until Python's
    garbage collector sees fit to clean up behind us.
  prefs: []
  type: TYPE_NORMAL
- en: So, instead of a string, we'll use a list of characters, which we can modify
    at will. In addition, we'll need to know the current cursor position within the
    list, and should probably also store a filename for the document.
  prefs: []
  type: TYPE_NORMAL
- en: Real text editors use a binary tree-based data structure called a `rope` to
    model their document contents. This book's title isn't *Advanced Data Structures*,
    so if you're interested in learning more about this fascinating topic, you may
    want to search the web for *rope data structure*.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of things we might want to do to a text document, including
    inserting, deleting, and selecting characters; cutting, copying, and, pasting
    the selection; and saving or closing the document. It looks like there are copious
    amounts of both data and behavior, so it makes sense to put all this stuff into
    its own `Document` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'A pertinent question is: should this class be composed of a bunch of basic
    Python objects such as `str` filenames, `int` cursor positions, and a `list` of
    characters? Or should some or all of those things be specially defined objects
    in their own right? What about individual lines and characters? Do they need to
    have classes of their own?'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll answer these questions as we go, but let''s start with the simplest
    possible class first- `Document`  and see what it can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This basic class allows us full control over editing a basic document. Have
    a look at it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: It looks like it's working. We could connect a keyboard's letter and arrow keys
    to these methods and the document would track everything just fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if we want to connect more than just arrow keys. What if we want to
    connect the *Home* and *End* keys as well? We could add more methods to the `Document`
    class that search forward or backward for newline characters (a newline character,
    escaped as `\n`, represents the end of one line and the beginning of a new one)
    in the string and jump to them, but if we did that for every possible movement
    action (move by words, move by sentences, *Page Up*, *P**age Down*, end of line,
    beginning of white space, and others), the class would be huge. Maybe it would
    be better to put those methods on a separate object. So, let''s turn the `Cursor`
    attribute into an object that is aware of its position and can manipulate that
    position. We can move the forward and back methods to that class, and add a couple
    more for the `Home` and `End` keys, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This class takes the document as an initialization parameter so the methods
    have access to the content of the document's character list. It then provides
    simple methods for moving backward and forward, as before, and for moving to the `home`
    and `end` positions.
  prefs: []
  type: TYPE_NORMAL
- en: This code is not very safe. You can very easily move past the ending position,
    and if you try to go home on an empty file, it will crash. These examples are
    kept short to make them readable, but that doesn't mean they are defensive! You
    can improve the error checking of this code as an exercise; it might be a great
    opportunity to expand your exception-handling skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Document` class itself is hardly changed, except for removing the two
    methods that were moved to the `Cursor` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We just updated anything that accessed the old cursor integer to use the new
    object instead. We can now test that the `home` method is really moving to the
    newline character, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, since we''ve been using that string `join` function a lot (to concatenate
    the characters so we can see the actual document contents), we can add a property
    to the `Document` class to give us the complete string as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes our testing a little simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This framework is simple to extend, create and edit a complete plain text document
    (though it might be a bit time consuming!) Now, let's extend it to work for rich
    text; text that can have **bold**, underlined, or *italic* characters.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways we could process this. The first is to insert *fake* characters
    into our character list that act like instructions, such as *bold characters until
    you find a stop bold character*. The second is to add information to each character,
    indicating what formatting it should have. While the former method is more common
    in real editors, we'll implement the latter solution. To do that, we're obviously
    going to need a class for characters. This class will have an attribute representing
    the character, as well as three Boolean attributes representing whether it is
    *bold, italic, or underlined*.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm, wait! Is this `Character` class going to have any methods? If not, maybe
    we should use one of the many Python data structures instead; a tuple or named
    tuple would probably be sufficient. Are there any actions that we would want to
    execute or invoke on a character?
  prefs: []
  type: TYPE_NORMAL
- en: Well, clearly, we might want to do things with characters, such as delete or
    copy them, but those are things that need to be handled at the `Document` level,
    since they are really modifying the list of characters. Are there things that
    need to be done to individual characters?
  prefs: []
  type: TYPE_NORMAL
- en: Actually, now that we're thinking about what a `Character` class actually **is**...
    what is it? Would it be safe to say that a `Character` class is a string? Maybe
    we should use an inheritance relationship here? Then we can take advantage of
    the numerous methods that `str` instances come with.
  prefs: []
  type: TYPE_NORMAL
- en: What sorts of methods are we talking about? There's `startswith`, `strip`, `find`,
    `lower`, and many more. Most of these methods expect to be working on strings
    that contain more than one character. In contrast, if `Character` were to subclass
    `str`, we'd probably be wise to override `__init__` to raise an exception if a
    multi-character string were supplied. Since all those methods we'd get for free
    wouldn't really apply to our `Character` class, it seems we shouldn't use inheritance,
    after all.
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us back to our original question; should `Character` even be a
    class? There is a very important special method on the `object` class that we
    can take advantage of to represent our characters. This method, called `__str__`
    (two underscores at each end, like `__init__`), is used in string-manipulation
    functions such as `print` and the `str` constructor to convert any class to a
    string. The default implementation does some boring stuff, such as printing the
    name of the module and class, and its address in memory. But if we override it,
    we can make it print whatever we like. For our implementation, we could make it
    prefix characters with special characters to represent whether they are bold,
    italic, or underlined. So, we will create a class to represent a character, and
    here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This class allows us to create characters and prefix them with a special character
    when the `str()` function is applied to them. Nothing too exciting there. We only
    have to make a few minor modifications to the `Document` and `Cursor` classes
    to work with this class. In the `Document` class, we add these two lines at the
    beginning of the `insert` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This is a rather strange bit of code. Its basic purpose is to check whether
    the character being passed in is a `Character` or a `str`. If it is a string,
    it is wrapped in a `Character` class so all objects in the list are `Character`
    objects. However, it is entirely possible that someone using our code would want
    to use a class that is neither a `Character` nor a string, using duck typing.
    If the object has a character attribute, we assume it is a `Character`-like object.
    But if it does not, we assume it is a `str`-like object and wrap it in `Character`.
    This helps the program take advantage of duck typing as well as polymorphism;
    as long as an object has a character attribute, it can be used in the `Document`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: This generic check could be very useful. For example, if we wanted to make a
    programmer's editor with syntax highlighting, we'd need extra data on the character,
    such as what type of syntax token the character belongs to. Note that, if we are
    doing a lot of this kind of comparison, it's probably better to implement `Character`
    as an abstract base class with an appropriate `__subclasshook__`, as discussed
    in [Chapter 3](ba7b3eb7-17cc-4f1c-bb74-fb7d5ee7d517.xhtml), *When Objects Are
    Alike*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we need to modify the string property on `Document` to accept
    the new `Character` values. All we need to do is call `str()` on each character
    before we join it, as demonstrated in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This code uses a generator expression, which we'll discuss in [Chapter 9](0abbcae0-eb3f-4237-adda-32765e1cce32.xhtml),
    *The Iterator Pattern*. It's a shortcut to perform a specific action on all the
    objects in a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we also need to check `Character.character`, instead of just the string
    character we were storing before, in the `home` and `end` functions when we''re
    looking to see whether it matches a newline character, as demonstrated in the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This completes the formatting of characters. We can test it to see that it
    works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As expected, whenever we print the string, each bold character is preceded by
    a `*` character, each italicized character by a `/` character, and each underlined
    character by a `_` character. All our functions seem to work, and we can modify
    characters in the list after the fact. We have a working rich text document object
    that could be plugged into a proper graphical user interface and hooked up with
    a keyboard for input and a screen for output. Naturally, we'd want to display
    real *bold, italic, and underlined* fonts in a UI, instead of using our `__str__`
    method, but it was sufficient for the basic testing we demanded of it.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've looked at various ways that objects, data, and methods can interact with
    each other in an object-oriented Python program. As usual, your first thoughts
    should be how you can apply these principles to your own work. Do you have any
    messy scripts lying around that could be rewritten using an object-oriented manager?
    Look through some of your old code and look for methods that are not actions.
    If the name isn't a verb, try rewriting it as a property.
  prefs: []
  type: TYPE_NORMAL
- en: Think about code you've written in any language. Does it break the DRY principle?
    Is there any duplicate code? Did you copy and paste code? Did you write two versions
    of similar pieces of code because you didn't feel like understanding the original
    code? Go back over some of your recent code now and see whether you can refactor
    the duplicate code using inheritance or composition. Try to pick a project you're
    still interested in maintaining; not code so old that you never want to touch
    it again. That will help to keep you interested when you do the improvements!
  prefs: []
  type: TYPE_NORMAL
- en: Now, look back over some of the examples we looked at in this chapter. Start
    with the cached web page example that uses a property to cache the retrieved data.
    An obvious problem with this example is that the cache is never refreshed. Add
    a timeout to the property's getter, and only return the cached page if the page
    has been requested before the timeout has expired. You can use the `time` module
    (`time.time() - an_old_time` returns the number of seconds that have elapsed since
    `an_old_time`) to determine whether the cache has expired.
  prefs: []
  type: TYPE_NORMAL
- en: Also look at the inheritance-based `ZipProcessor`. It might be reasonable to
    use composition instead of inheritance here. Instead of extending the class in
    the `ZipReplace` and `ScaleZip` classes, you could pass instances of those classes
    into the `ZipProcessor` constructor and call them to do the processing part. Implement
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Which version do you find easier to use? Which is more elegant? What is easier
    to read? These are subjective questions; the answer varies for each of us. Knowing
    the answer, however, is important. If you find you prefer inheritance over composition,
    you need to pay attention that you don't overuse inheritance in your daily coding.
    If you prefer composition, make sure you don't miss opportunities to create an
    elegant inheritance-based solution.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, add some error handlers to the various classes we created in the case
    study. They should ensure single characters are entered, that you don't try to
    move the cursor past the end or beginning of the file, that you don't delete a
    character that doesn't exist, and that you don't save a file without a filename.
    Try to think of as many edge cases as you can, and account for them (thinking
    about edge cases is about 90% of a professional programmer's job!). Consider different
    ways to handle them; should you raise an exception when the user tries to move
    past the end of the file, or just stay on the last character?
  prefs: []
  type: TYPE_NORMAL
- en: In your daily coding, pay attention to the copy and paste commands. Every time
    you use them in your editor, consider whether it would be a good idea to improve
    your program's organization so that you only have one version of the code you
    are about to copy.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on identifying objects, especially objects that
    are not immediately apparent; objects that manage and control. Objects should
    have both data and behaviors, but properties can be used to blur the distinction
    between the two. The DRY principle is an important indicator of code quality,
    and inheritance and composition can be applied to reduce code duplication.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover several of the built-in Python data structures
    and objects, focusing on their object-oriented properties and how they can be
    extended or adapted.
  prefs: []
  type: TYPE_NORMAL
