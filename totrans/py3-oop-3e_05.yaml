- en: When to Use Object-Oriented Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用面向对象编程
- en: In previous chapters, we've covered many of the defining features of object-oriented
    programming. We now know the principles and paradigms of object-oriented design,
    and we've covered the syntax of object-oriented programming in Python.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们介绍了面向对象编程的许多定义特征。我们现在知道了面向对象设计的原理和范式，并且我们已经介绍了Python中面向对象编程的语法。
- en: 'Yet, we don''t know exactly how and, especially, when to utilize these principles
    and syntax in practice. In this chapter, we''ll discuss some useful applications
    of the knowledge we''ve gained, looking at some new topics along the way:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们并不知道确切如何以及特别是在实践中何时利用这些原则和语法。在本章中，我们将讨论一些有用知识的应用，沿途探讨一些新主题：
- en: How to recognize objects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何识别对象
- en: Data and behaviors, once again
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据和行为，再次强调
- en: Wrapping data behaviors using properties
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性包装数据行为
- en: Restricting data using behaviors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用行为限制数据
- en: The Don't Repeat Yourself principle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要重复原则
- en: Recognizing repeated code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别重复的代码
- en: Treat objects as objects
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将对象视为对象
- en: 'This may seem obvious; you should generally give separate objects in your problem
    domain a special class in your code. We''ve seen examples of this in the case
    studies in previous chapters: first, we identify objects in the problem, and then
    model their data and behaviors.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很明显；你应该通常给你的问题域中的单独对象在代码中一个特殊的类。我们在前几章的案例研究中看到了这样的例子：首先，我们识别问题中的对象，然后建模它们的数据和行为。
- en: Identifying objects is a very important task in object-oriented analysis and
    programming. But it isn't always as easy as counting the nouns in short paragraphs
    that, frankly, I have constructed explicitly for that purpose. Remember, objects
    are things that have both data and behavior. If we are working only with data,
    we are often better off storing it in a list, set, dictionary, or other Python
    data structure (which we'll be covering thoroughly in [Chapter 6](6a121a79-7716-4a8f-94ab-f96781e82d25.xhtml),
    *Python Data Structures*). On the other hand, if we are working only with behavior,
    but no stored data, a simple function is more suitable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 识别对象是面向对象分析和编程中一个非常重要的任务。但这并不总是像在简短的段落中数名词那么简单，坦白说，我为此目的明确地构建了这些段落。记住，对象是既有数据又有行为的事物。如果我们只处理数据，我们通常最好将其存储在列表、集合、字典或其他Python数据结构中（我们将在[第6章](6a121a79-7716-4a8f-94ab-f96781e82d25.xhtml)，*Python数据结构*中彻底介绍）。另一方面，如果我们只处理行为，但没有存储的数据，一个简单的函数就更为合适。
- en: An object, however, has both data and behavior. Proficient Python programmers
    use built-in data structures unless (or until) there is an obvious need to define
    a class. There is no reason to add an extra level of abstraction if it doesn't
    help organize our code. On the other hand, the *obvious* need is not always self-evident.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个对象既有数据也有行为。熟练的Python程序员会使用内置的数据结构，除非（或直到）有明显的需要定义一个类。如果没有帮助组织我们的代码，就没有理由添加额外的抽象层次。另一方面，*明显*的需要并不总是显而易见的。
- en: 'We can often start our Python programs by storing data in a few variables.
    As the program expands, we will later find that we are passing the same set of
    related variables to a set of functions. This is the time to think about grouping
    both variables and functions into a class. If we are designing a program to model
    polygons in two-dimensional space, we might start with each polygon represented
    as a list of points. The points would be modeled as two tuples (*x*, *y*) describing
    where that point is located. This is all data, stored in a set of nested data
    structures (specifically, a list of tuples):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常可以通过在几个变量中存储数据来开始我们的Python程序。随着程序的扩展，我们稍后会发现我们将同一组相关的变量传递给一组函数。这时，我们应该考虑将变量和函数分组到一个类中。如果我们正在设计一个用于模拟二维空间中多边形的程序，我们可能从每个多边形表示为点的列表开始。这些点将被建模为描述该点位置的(*x*,
    *y*)两个元组。这全是数据，存储在一系列嵌套的数据结构中（具体来说，是一个元组的列表）：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, if we want to calculate the distance around the perimeter of the polygon,
    we need to sum the distances between each point. To do this, we need a function
    to calculate the distance between two points. Here are two such functions:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要计算多边形周长的距离，我们需要求出每个点之间的距离之和。为此，我们需要一个函数来计算两点之间的距离。这里有两个这样的函数：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, as object-oriented programmers, we clearly recognize that a `polygon`
    class could encapsulate the list of points (data) and the `perimeter` function
    (behavior). Further, a `point` class, such as we defined in [Chapter 2](0786c893-abb9-4f35-9320-3f2f54de95eb.xhtml),
    *Objects in Python*, might encapsulate the `x` and `y` coordinates and the `distance`
    method. The question is: is it valuable to do this?'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为面向对象的程序员，我们明显认识到`polygon`类可以封装点列表（数据）和`perimeter`函数（行为）。此外，一个`point`类，例如我们在[第2章](0786c893-abb9-4f35-9320-3f2f54de95eb.xhtml)“Python中的对象”中定义的，可以封装`x`和`y`坐标以及`distance`方法。问题是：这样做有价值吗？
- en: 'For the previous code, maybe yes, maybe no. With our recent experience in object-oriented
    principles, we can write an object-oriented version in record time. Let''s compare
    them as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于之前的代码，也许是的，也许不是。凭借我们最近在面向对象原则方面的经验，我们可以快速编写面向对象的版本。让我们如下进行比较：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we can see from the highlighted sections, there is twice as much code here
    as there was in our earlier version, although we could argue that the `add_point`
    method is not strictly necessary.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从突出显示的部分中可以看到，这里的代码量是我们早期版本的两倍，尽管我们可以争论`add_point`方法并不是严格必要的。
- en: 'Now, to understand the differences a little better, let''s compare the two
    APIs in use. Here''s how to calculate the perimeter of a square using the object-oriented
    code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了更好地理解两者之间的差异，让我们比较一下两个API的使用情况。以下是使用面向对象代码计算正方形周长的方法：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'That''s fairly succinct and easy to read, you might think, but let''s compare
    it to the function-based code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当简洁且易于阅读，你可能会这样认为，但让我们将其与基于函数的代码进行比较：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Hmm, maybe the object-oriented API isn't so compact! That said, I'd argue that
    it was easier to *read* than the functional example. How do we know what the list
    of tuples is supposed to represent in the second version? How do we remember what
    kind of object we're supposed to pass into the `perimeter` function? (a list of
    two tuples? That's not intuitive!) We would need a lot of documentation to explain
    how these functions should be used.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，也许面向对象的API并不那么紧凑！话虽如此，我认为它比函数示例更容易*阅读*。我们如何知道在第二个版本中元组的列表应该代表什么？我们如何记住我们应该传递给`perimeter`函数的对象类型？（一个包含两个元组的列表？这并不直观！）我们需要大量的文档来解释这些函数应该如何使用。
- en: In contrast, the object-oriented code is relatively self-documenting. We just
    have to look at the list of methods and their parameters to know what the object
    does and how to use it. By the time we wrote all the documentation for the functional
    version, it would probably be longer than the object-oriented code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，面向对象的代码相对自文档化。我们只需查看方法列表及其参数，就可以知道对象的功能以及如何使用它。等到我们为函数版本编写完所有文档，它可能比面向对象的代码还要长。
- en: Finally, code length is not a good indicator of code complexity. Some programmers
    get hung up on complicated *one liners* that do an incredible amount of work in
    one line of code. This can be a fun exercise, but the result is often unreadable,
    even to the original author the following day. Minimizing the amount of code can
    often make a program easier to read, but do not blindly assume this is the case.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码长度并不是代码复杂性的良好指标。一些程序员会陷入复杂的*一行代码*中，一行代码就能完成大量的工作。这可能是一项有趣的练习，但结果往往是难以阅读的，即使是原作者第二天再看也会如此。尽量减少代码量通常可以使程序更容易阅读，但不要盲目地假设这是正确的。
- en: 'Luckily, this trade-off isn''t necessary. We can make the object-oriented `Polygon`
    API as easy to use as the functional implementation. All we have to do is alter
    our `Polygon` class so that it can be constructed with multiple points. Let''s
    give it an initializer that accepts a list of `Point` objects. In fact, let''s
    allow it to accept tuples too, and we can construct the `Point` objects ourselves,
    if needed:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这种权衡是不必要的。我们可以使面向对象的`Polygon` API与函数实现一样易于使用。我们只需要修改我们的`Polygon`类，使其可以用多个点来构造。让我们给它一个接受`Point`对象列表的初始化器。实际上，让我们允许它接受元组，如果需要，我们还可以自己构造`Point`对象：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This initializer goes through the list and ensures that any tuples are converted
    to points. If the object is not a tuple, we leave it as is, assuming that it is
    either a `Point` object already, or an unknown duck-typed object that can act
    like a `Point` object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个初始化器会遍历列表，并确保将任何元组转换为点。如果对象不是元组，我们就保持原样，假设它要么是一个已经存在的`Point`对象，要么是一个可以像`Point`对象一样操作的未知鸭子类型对象。
- en: If you are experimenting with the above code, you could subclass `Polygon` and
    override the `__init__` function instead of replacing the initializer or copying
    the `add_point` and `perimeter` methods.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在尝试上述代码，你可以通过子类化`Polygon`并覆盖`__init__`函数来代替替换初始化器或复制`add_point`和`perimeter`方法。
- en: Still, there's no clear winner between the object-oriented and more data-oriented
    versions of this code. They both do the same thing. If we have new functions that
    accept a polygon argument, such as `area(polygon)` or `point_in_polygon(polygon,
    x, y)`, the benefits of the object-oriented code become increasingly obvious.
    Likewise, if we add other attributes to the polygon, such as `color` or `texture`,
    it makes more and more sense to encapsulate that data into a single class.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在面向对象和更多数据导向的代码版本之间，并没有明显的胜者。它们都做了同样的事情。如果我们有接受多边形参数的新函数，如`area(polygon)`或`point_in_polygon(polygon,
    x, y)`，面向对象代码的好处将越来越明显。同样，如果我们给多边形添加其他属性，如`color`或`texture`，将数据封装到单个类中会更有意义。
- en: The distinction is a design decision, but in general, the more important a set
    of data is, the more likely it is to have multiple functions specific to that
    data, and the more useful it is to use a class with attributes and methods instead.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区别是一个设计决策，但一般来说，一组数据越重要，就越有可能有针对该数据的多个特定函数，使用具有属性和方法类的用途就越大。
- en: When making this decision, it also pays to consider how the class will be used.
    If we're only trying to calculate the perimeter of one polygon in the context
    of a much greater problem, using a function will probably be quickest to code
    and easier to use *one time only*. On the other hand, if our program needs to
    manipulate numerous polygons in a wide variety of ways (calculating the perimeter,
    area, and intersection with other polygons, moving or scaling them, and so on),
    we have almost certainly identified an object; one that needs to be extremely
    versatile.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出这个决定时，考虑类将如何被使用也是有帮助的。如果我们只是在更大的问题背景下尝试计算一个多边形的周长，使用一个函数可能编写起来最快，也更容易一次性使用。另一方面，如果我们的程序需要以多种方式操纵大量多边形（计算周长、面积、与其他多边形的交集、移动或缩放等），我们几乎肯定已经识别出一个对象；一个需要极其灵活的对象。
- en: Additionally, pay attention to the interaction between objects. Look for inheritance
    relationships; inheritance is impossible to model elegantly without classes, so
    make sure to use them. Look for the other types of relationships we discussed
    in [Chapter 1](f3a06c74-ab7f-450f-9663-bfe014b359bf.xhtml), *Object-Oriented Design*,
    association and composition. Composition can, technically, be modeled using only
    data structures; for example, we can have a list of dictionaries holding tuple
    values, but it is sometimes less complicated to create a few classes of objects,
    especially if there is behavior associated with the data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意对象之间的交互。寻找继承关系；没有类，继承是无法优雅建模的，所以请确保使用它们。寻找我们在[第1章](f3a06c74-ab7f-450f-9663-bfe014b359bf.xhtml)“面向对象设计”中讨论的其他类型的关系，如关联和组合。在技术上，组合可以使用仅数据结构来建模；例如，我们可以有一个包含元组值的字典列表，但有时创建几个具有与数据相关行为的对象类会更简单。
- en: Don't rush to use an object just because you can use an object, but don't neglect
    to create a class when you need to use a class.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不要因为可以使用对象就急于使用对象，但当你需要使用类时，也不要忽视创建一个类。
- en: Adding behaviors to class data with properties
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将行为添加到具有属性的类数据中
- en: Throughout this book, we've focused on the separation of behavior and data.
    This is very important in object-oriented programming, but we're about to see
    that, in Python, the distinction is uncannily blurry. Python is very good at blurring
    distinctions; it doesn't exactly help us to *think outside the box*. Rather, it
    teaches us to stop thinking about the box.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们一直关注行为和数据分离。这在面向对象编程中非常重要，但我们将看到，在Python中，这种区别非常模糊。Python非常擅长模糊化区别；它并不真正帮助我们跳出思维定式。相反，它教会我们停止考虑思维定式。
- en: 'Before we get into the details, let''s discuss some bad object-oriented theory.
    Many object-oriented languages teach us to never access attributes directly (Java
    is the most notorious). They insist that we write attribute access like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入细节之前，让我们讨论一些不好的面向对象理论。许多面向对象的语言教导我们永远不要直接访问属性（Java是最臭名昭著的）。他们坚持认为我们应该这样编写属性访问：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The variables are prefixed with an underscore to suggest that they are private
    (other languages would actually force them to be private). Then, the `get` and
    `set` methods provide access to each variable. This class would be used in practice
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 变量以下划线为前缀，以表明它们是私有的（其他语言实际上会强制它们成为私有）。然后，`get`和`set`方法提供了对每个变量的访问。这个类在实际应用中的使用如下：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is not nearly as readable as the direct access version that Python favors:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这在可读性上远不如Python所青睐的直接访问版本：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, why would anyone insist upon the method-based syntax? Their reasoning is
    that, someday, we may want to add extra code when a value is set or retrieved.
    For example, we could decide to cache a value to avoid complex computations, or
    we might want to validate that a given value is a suitable input.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么有人会坚持使用基于方法的语法呢？他们的理由是，总有一天，我们可能想在设置或检索值时添加额外的代码。例如，我们可以决定缓存一个值以避免复杂的计算，或者我们可能想验证给定的值是否是一个合适的输入。
- en: 'In code, for example, we could decide to change the `set_name()` method as
    follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在代码中，我们可以决定将`set_name()`方法更改为以下内容：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, in Java and similar languages, if we had written our original code for
    direct attribute access, and then later changed it to a method like the preceding
    one, we''d have a problem: anyone who had written code that accessed the attribute
    directly would now have to access a method. If they didn''t then change the access
    style from attribute access to a function call, their code will be broken.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Java和类似的语言中，如果我们最初为直接属性访问编写了原始代码，然后后来将其更改为前面提到的方法，我们会遇到问题：任何编写了直接访问属性代码的人现在都必须访问一个方法。如果他们没有将访问样式从属性访问更改为函数调用，他们的代码就会出错。
- en: The mantra in these languages is that we should never make public members private.
    This doesn't make much sense in Python since there isn't any real concept of private
    members!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语言中的格言是，我们永远不应该将公共成员设置为私有。在Python中这并没有太多意义，因为Python中并没有真正的私有成员概念！
- en: 'Python gives us the `property` keyword to make methods that *look* like attributes.
    We can therefore write our code to use direct member access, and if we ever unexpectedly
    need to alter the implementation to do some calculation when getting or setting
    that attribute''s value, we can do so without changing the interface. Let''s see
    how it looks:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Python为我们提供了`property`关键字来创建看起来像属性的函数。因此，我们可以编写代码以使用直接成员访问，如果我们需要意外地更改实现以在获取或设置该属性的值时进行一些计算，我们可以这样做而不必更改接口。让我们看看它看起来如何：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Compared to the earlier class, we first change the `name` attribute into a (semi-)private
    `_name` attribute. Then, we add two more (semi-)private methods to get and set
    that variable, performing our validation when we set it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与早期版本相比，我们首先将`name`属性更改为（半）私有属性`_name`。然后，我们添加了两个更多（半）私有方法来获取和设置该变量，在我们设置它时执行验证。
- en: 'Finally, we have the `property` declaration at the bottom. This is the Python
    magic. It creates a new attribute on the `Color` class called `name`, to replace
    the direct `name` attribute. It sets this attribute to be a **property**. Under
    the hood, `property` calls the two methods we just created whenever the value
    is accessed or changed. This new version of the `Color` class can be used exactly
    the same way as the earlier version, yet it now performs validation when we set
    the `name` attribute:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在底部有`property`声明。这是Python的魔法。它为`Color`类创建了一个名为`name`的新属性，以替换直接的`name`属性。它将此属性设置为**属性**。在底层，`property`在访问或更改值时调用我们刚刚创建的两个方法。这个`Color`类的新版本可以像早期版本一样使用，但现在在设置`name`属性时它将执行验证：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, if we'd previously written code to access the `name` attribute, and then
    changed it to use our `property`-based object, the previous code would still work,
    unless it was sending an empty `property` value, which is the behavior we wanted
    to forbid in the first place. Success!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们之前编写了访问`name`属性的代码，然后将其更改为使用我们的基于`property`的对象，之前的代码仍然会工作，除非它发送了一个空的`property`值，这正是我们最初想要禁止的行为。成功了！
- en: Bear in mind that, even with the `name` property, the previous code is not 100%
    safe. People can still access the `_name` attribute directly and set it to an
    empty string if they want to. But if they access a variable we've explicitly marked
    with an underscore to suggest it is private, they're the ones that have to deal
    with the consequences, not us.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，即使有了`name`属性，之前的代码也不是100%安全的。人们仍然可以直接访问`_name`属性并将其设置为空字符串，如果他们想这么做的话。但如果他们访问了我们明确标记为下划线以表明它是私有的变量，那么他们必须承担后果，而不是我们。
- en: Properties in detail
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性的详细说明
- en: Think of the `property` function as returning an object that proxies any requests
    to set or access the attribute value through the methods we have specified. The
    `property` built-in is like a constructor for such an object, and that object
    is set as the public-facing member for the given attribute.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `property` 函数想象成返回一个对象，该对象通过我们指定的方法代理对属性值的设置或访问请求。`property` 内置函数就像这样一个对象的构造函数，并且该对象被设置为给定属性的公共成员。
- en: 'This `property` constructor can actually accept two additional arguments, a
    `delete` function and a docstring for the property. The `delete` function is rarely
    supplied in practice, but it can be useful for logging the fact that a value has
    been deleted, or possibly to veto deleting if we have reason to do so. The docstring
    is just a string describing what the property does, no different from the docstrings
    we discussed in [Chapter 2](0786c893-abb9-4f35-9320-3f2f54de95eb.xhtml), *Objects
    in Python*. If we do not supply this parameter, the docstring will instead be
    copied from the docstring for the first argument: the `getter` method. Here is
    a silly example that states whenever any of the methods are called:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个 `property` 构造函数可以接受两个额外的参数，一个 `delete` 函数和属性的文档字符串。在实践中，很少提供 `delete`
    函数，但它可以用于记录值已被删除的事实，或者如果我们有理由这样做，可以拒绝删除。文档字符串只是一个描述属性做什么的字符串，与我们在[第 2 章](0786c893-abb9-4f35-9320-3f2f54de95eb.xhtml)，《Python
    中的对象》中讨论的文档字符串没有区别。如果我们不提供此参数，则文档字符串将复制自第一个参数的文档字符串：`getter` 方法。以下是一个愚蠢的例子，它声明了每次调用任何方法时：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we actually use this class, it does indeed print out the correct strings
    when we ask it to:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们实际使用这个类，当我们要求它打印正确的字符串时，它确实会这样做：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Further, if we look at the help file for the `Silly` class (by issuing `help(Silly)`
    at the interpreter prompt), it shows us the custom docstring for our `silly` attribute:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们查看 `Silly` 类的帮助文件（通过在解释器提示符中输入 `help(Silly)`），它将显示我们 `silly` 属性的自定义文档字符串：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once again, everything is working as we planned. In practice, properties are
    normally only defined with the first two parameters: the `getter` and `setter`
    functions. If we want to supply a docstring for a property, we can define it on
    the `getter` function; the property proxy will copy it into its own docstring.
    The `delete` function is often left empty because object attributes are so rarely
    deleted. If a coder does try to delete a property that doesn''t have a `delete`
    function specified, it will raise an exception. Therefore, if there is a legitimate
    reason to delete our property, we should supply that function.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，一切都在我们的计划之中。在实践中，属性通常只使用前两个参数定义：`getter` 和 `setter` 函数。如果我们想为属性提供一个文档字符串，我们可以在
    `getter` 函数上定义它；属性代理将把它复制到自己的文档字符串中。`delete` 函数通常留空，因为对象属性很少被删除。如果一个编码者尝试删除没有指定
    `delete` 函数的属性，它将引发异常。因此，如果有合法的理由删除我们的属性，我们应该提供该函数。
- en: Decorators – another way to create properties
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器 – 创建属性的另一种方式
- en: If you've never used Python decorators before, you might want to skip this section
    and come back to it after we've discussed the decorator pattern in [Chapter 10](345fe617-9a90-4c59-9355-e7076759f9a4.xhtml),
    *Python Design Patterns I*. However, you don't need to understand what's going
    on to use the decorator syntax in order to make property methods more readable.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前从未使用过 Python 装饰器，你可能想要跳过这一节，在我们讨论了[第 10 章](345fe617-9a90-4c59-9355-e7076759f9a4.xhtml)，《Python
    设计模式 I》中的装饰器模式后再回来。然而，你不需要理解正在发生的事情，就可以使用装饰器语法来使属性方法更易读。
- en: 'The `property` function can be used with the decorator syntax to turn a `get`
    function into a `property` function, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`property` 函数可以用装饰器语法使用，将 `get` 函数转换为 `property` 函数，如下所示：'
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This applies the `property` function as a decorator, and is equivalent to the
    previous `foo = property(foo)` syntax. The main difference, from a readability
    perspective, is that we get to mark the `foo` function as a property at the top
    of the method, instead of after it is defined, where it can be easily overlooked.
    It also means we don't have to create private methods with underscore prefixes
    just to define a property.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `property` 函数用作装饰器，与之前的 `foo = property(foo)` 语法等效。从可读性的角度来看，主要区别在于我们可以在方法顶部标记
    `foo` 函数为属性，而不是在定义之后，这样它就不容易被忽视了。这也意味着我们不需要创建带有下划线前缀的私有方法来定义属性。
- en: 'Going one step further, we can specify a `setter` function for the new property
    as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 再进一步，我们可以为新的属性指定一个 `setter` 函数，如下所示：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This syntax looks pretty odd, although the intent is obvious. First, we decorate
    the `foo` method as a getter. Then, we decorate a second method with exactly the
    same name by applying the `setter` attribute of the originally decorated `foo`
    method! The `property` function returns an object; this object always comes with
    its own `setter` attribute, which can then be applied as a decorator to other
    functions. Using the same name for the get and set methods is not required, but
    it does help to group together the multiple methods that access one property.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法看起来相当奇怪，尽管意图是明显的。首先，我们将`foo`方法装饰为一个getter。然后，我们通过应用原始装饰的`foo`方法的`setter`属性来装饰一个具有完全相同名称的第二个方法！`property`函数返回一个对象；这个对象总是带有自己的`setter`属性，然后可以将它作为装饰器应用于其他函数。get和set方法使用相同的名称不是必需的，但它有助于将访问同一属性的多个方法分组在一起。
- en: 'We can also specify a `delete` function with `@foo.deleter`. We cannot specify
    a docstring using `property` decorators, so we need to rely on the property copying
    the docstring from the initial getter method. Here''s our previous `Silly` class
    rewritten to use `property` as a decorator:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`@foo.deleter`指定一个`delete`函数。我们不能使用`property`装饰器来指定文档字符串，因此我们需要依赖于属性从初始的getter方法复制文档字符串。以下是我们之前重写的`Silly`类，使用`property`作为装饰器：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This class operates *exactly* the same as our earlier version, including the
    help text. You can use whichever syntax you feel is more readable and elegant.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类与我们的早期版本操作**完全相同**，包括帮助文本。你可以使用你认为更易读和优雅的语法。
- en: Deciding when to use properties
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决定何时使用属性
- en: With the built-in property clouding the division between behavior and data,
    it can be confusing to know when to choose an attribute, or a method, or a property.
    The use case example we saw earlier is one of the most common uses of properties;
    we have some data on a class that we later want to add behavior to. There are
    also other factors to take into account when deciding to use a property.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内置的`property`模糊了行为和数据之间的界限，知道何时选择属性、方法或属性可能会令人困惑。我们之前看到的用例示例是属性最常见的使用之一；我们有一个类上的数据，我们稍后想添加行为。在决定使用属性时，还需要考虑其他因素。
- en: Technically, in Python, data, properties, and methods are all attributes on
    a class. The fact that a method is callable does not distinguish it from other
    types of attributes; indeed, we'll see in [Chapter 7](b70c8ea0-4778-4005-af13-bdae3d90d2c6.xhtml),
    *Python Object-Oriented Shortcuts*, that it is possible to create normal objects
    that can be called like functions. We'll also discover that functions and methods
    are themselves normal objects.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，在Python中，数据、属性和方法都是类上的属性。一个方法是可调用的这一事实并不能将其与其他类型的属性区分开来；实际上，我们将在[第7章](b70c8ea0-4778-4005-af13-bdae3d90d2c6.xhtml)，《Python面向对象快捷方式》中看到，可以创建出可以像函数一样调用的普通对象。我们还将发现函数和方法本身也是普通对象。
- en: The fact that methods are just callable attributes, and properties are just
    customizable attributes, can help us make this decision. Methods should typically
    represent actions; things that can be done to, or performed by, the object. When
    you call a method, even with only one argument, it should *do* something. Method
    names are generally verbs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 方法只是可调用的属性，属性只是可定制的属性这一事实可以帮助我们做出这个决定。方法通常表示动作；可以对对象执行或由对象执行的事情。当你调用一个方法时，即使只有一个参数，它也应该**做**些事情。方法名通常是动词。
- en: Once confirming that an attribute is not an action, we need to decide between
    standard data attributes and properties. In general, always use a standard attribute
    until you need to control access to that property in some way. In either case,
    your attribute is usually a noun. The only difference between an attribute and
    a property is that we can invoke custom actions automatically when a property
    is retrieved, set, or deleted.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确认一个属性不是动作，我们需要在标准数据属性和属性之间做出选择。一般来说，直到你需要以某种方式控制对该属性的访问时，才使用标准属性。在两种情况下，你的属性通常是名词。属性和属性之间的唯一区别是我们可以在属性被检索、设置或删除时自动调用自定义操作。
- en: Let's look at a more realistic example. A common need for custom behavior is
    caching a value that is difficult to calculate or expensive to look up (requiring,
    for example, a network request or database query). The goal is to store the value
    locally to avoid repeated calls to the expensive calculation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个更实际的例子。自定义行为的常见需求是缓存一个难以计算或查找代价高昂的值（例如，需要网络请求或数据库查询）。目标是存储该值以避免重复调用昂贵的计算。
- en: 'We can do this with a custom getter on the property. The first time the value
    is retrieved, we perform the lookup or calculation. Then, we can locally cache
    the value as a private attribute on our object (or in dedicated caching software),
    and the next time the value is requested, we return the stored data. Here''s how
    we might cache a web page:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在属性上使用自定义获取器来实现这一点。第一次检索值时，我们执行查找或计算。然后，我们可以在我们的对象（或专门的缓存软件）上本地缓存该值作为私有属性，下次请求该值时，我们返回存储的数据。以下是我们可能缓存网页的方式：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can test this code to see that the page is only retrieved once:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以测试这段代码，看看页面是否只检索一次：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'I was on an awful satellite connection when I originally tested this code for
    the first version of this book back in 2010 and it took 20 seconds the first time
    I loaded the content. The second time, I got the result in 2 seconds (which is
    really just the amount of time it took to type the lines into the interpreter).
    On my more modern connection it looks as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在2010年测试这本书的第一版时，我原本在一个糟糕的卫星连接上，第一次加载内容时花费了20秒。第二次，我用了2秒（这实际上只是将行输入解释器所需的时间）。在我的更现代的连接上，它看起来如下所示：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It takes about 620 milliseconds to retrieve a page from my web host. From my
    laptop's RAM, it takes 0.018 milliseconds!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从我的网络主机检索一个页面大约需要620毫秒。从我的笔记本电脑的RAM中，它只需要0.018毫秒！
- en: 'Custom getters are also useful for attributes that need to be calculated on
    the fly, based on other object attributes. For example, we might want to calculate
    the average for a list of integers:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义获取器对于需要根据其他对象属性动态计算属性的情况也非常有用。例如，我们可能想要计算一系列整数的平均值：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This very simple class inherits from `list`, so we get list-like behavior for
    free. We just add a property to the class, and hey presto, our list can have an
    average as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非常简单的类从`list`继承，因此我们免费获得了类似列表的行为。我们只需向类中添加一个属性，嘿，我们的列表就可以有平均值了，如下所示：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Of course, we could have made this a method instead, but then we ought to call
    it `calculate_average()`, since methods represent actions. But a property called
    `average` is more suitable, and is both easier to type and easier to read.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们本可以将这做成一个方法，但那时我们应该将其命名为`calculate_average()`，因为方法代表动作。但名为`average`的属性更合适，它既容易输入也容易阅读。
- en: Custom setters are useful for validation, as we've already seen, but they can
    also be used to proxy a value to another location. For example, we could add a
    content setter to the `WebPage` class that automatically logs into our web server
    and uploads a new page whenever the value is set.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义设置器在验证方面很有用，正如我们之前所看到的，但它们也可以用来代理一个值到另一个位置。例如，我们可以在`WebPage`类中添加一个内容设置器，每当值被设置时，它会自动登录我们的网络服务器并上传一个新页面。
- en: Manager objects
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理对象
- en: We've been focused on objects and their attributes and methods. Now, we'll take
    a look at designing higher-level objects; the kind of objects that manage other
    objects – the objects that tie everything together.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直关注对象及其属性和方法。现在，我们将探讨设计更高级的对象；那些管理其他对象的对象——那些将一切联系在一起的对象。
- en: The difference between these objects and most of the previous examples is that
    the latter usually represent concrete ideas. Management objects are more like
    office managers; they don't do the actual *visible* work out on the floor, but
    without them, there would be no communication between departments and nobody would
    know what they are supposed to do (although, this can be true anyway if the organization
    is badly managed!). Analogously, the attributes on a management class tend to
    refer to other objects that do the *visible* work; the behaviors on such a class
    delegate to those other classes at the right time, and pass messages between them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象与之前的大多数示例之间的区别在于，后者通常代表具体的概念。管理对象更像是办公室经理；他们不在现场做实际的*可见*工作，但没有他们，部门之间就没有沟通，没有人知道他们应该做什么（尽管，如果组织管理不善，这也可能是真的！）。类似地，管理类上的属性往往指的是做*可见*工作的其他对象；此类上的行为在适当的时候委托给其他类，并在它们之间传递消息。
- en: 'As an example, we''ll write a program that does a find-and-replace action for
    text files stored in a compressed ZIP file. We''ll need objects to represent the
    ZIP file and each individual text file (luckily, we don''t have to write these
    classes, as they''re available in the Python standard library). The manager object
    will be responsible for ensuring the following three steps occur in order:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将编写一个程序，对存储在压缩ZIP文件中的文本文件执行查找和替换操作。我们需要对象来表示ZIP文件和每个单独的文本文件（幸运的是，我们不需要编写这些类，因为它们在Python标准库中可用）。管理对象将负责确保以下三个步骤按顺序发生：
- en: Unzipping the compressed file
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压压缩文件
- en: Performing the find-and-replace action
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行查找和替换操作
- en: Zipping up the new files
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 压缩新文件
- en: 'The class is initialized with the `.zip` filename, and search and replace strings.
    We create a temporary directory to store the unzipped files in, so that the folder
    stays clean. The `pathlib` library helps out with file and directory manipulation.
    We''ll learn more about it in [Chapter 8](9a6335a2-1c69-4fa8-a685-02bbeeba23be.xhtml),
    *Strings and Serialization*, but the interface should be pretty clear in the following
    example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 类使用`.zip`文件名、搜索和替换字符串进行初始化。我们创建一个临时目录来存储解压的文件，这样文件夹就可以保持干净。`pathlib`库帮助处理文件和目录操作。我们将在[第8章](9a6335a2-1c69-4fa8-a685-02bbeeba23be.xhtml)中了解更多关于它的信息，*字符串和序列化*，但以下示例中的接口应该相当清晰：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we create an overall *manager* method for each of the three steps. This
    method delegates responsibility to other objects:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为每个步骤创建一个总的*管理*方法。这个方法将责任委托给其他对象：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Obviously, we could do all three steps in one method, or indeed in one script,
    without ever creating an object. There are several advantages to separating the
    three steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以在一个方法中完成这三个步骤，或者在一个脚本中完成，而不需要创建对象。分离这三个步骤有几个优点：
- en: '**Readability**: The code for each step is in a self-contained unit that is
    easy to read and understand. The method name describes what the method does, and
    less additional documentation is required to understand what is going on.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读性**：每个步骤的代码都是一个自包含的单元，易于阅读和理解。方法名描述了方法的作用，不需要额外的文档就可以理解正在发生的事情。'
- en: '**Extensibility**: If a subclass wanted to use compressed TAR files instead
    of ZIP files, it could override the `zip` and `unzip` methods without having to
    duplicate the `find_replace` method.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：如果子类想使用压缩TAR文件而不是ZIP文件，它可以覆盖`zip`和`unzip`方法，而无需重复`find_replace`方法。'
- en: '**Partitioning**: An external class could create an instance of this class
    and call the `find_replace` method directly on some folder without having to `zip`
    the content.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分区**：外部类可以创建这个类的实例，并直接在某个文件夹上调用`find_replace`方法，而无需压缩内容。'
- en: 'The delegation method is the first in the following code; the rest of the methods
    are included for completeness:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 委派方法是以下代码中的第一个；其余的方法包括为了完整性：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For brevity, the code for zipping and unzipping files is sparsely documented.
    Our current focus is on object-oriented design; if you are interested in the inner
    details of the `zipfile` module, refer to the documentation in the standard library,
    either online or by typing `import zipfile ; help(zipfile)` into your interactive
    interpreter. Note that this toy example only searches the top-level files in a
    ZIP file; if there are any folders in the unzipped content, they will not be scanned,
    nor will any files inside those folders.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，对文件压缩和解压缩的代码只有很少的文档说明。我们目前的重点是面向对象设计；如果你对`zipfile`模块的内部细节感兴趣，可以参考标准库中的文档，无论是在线还是通过在你的交互式解释器中输入`import
    zipfile ; help(zipfile)`来查看。请注意，这个玩具示例只搜索ZIP文件中的顶级文件；如果解压内容中包含任何文件夹，它们将不会被扫描，文件夹内的任何文件也不会被扫描。
- en: If you are using a Python version older than 3.6, you will need to convert the
    path objects to strings before calling `extractall`, `rmtree`, and `file.write`
    on the `ZipFile` object.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是低于3.6版本的Python，在调用`extractall`、`rmtree`和`file.write`在`ZipFile`对象上之前，你需要将路径对象转换为字符串。
- en: 'The last two lines in the example allow us to run the program from the command
    line by passing the `zip` filename, the search string, and the replace string
    as arguments, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的最后两行允许我们通过传递`zip`文件名、搜索字符串和替换字符串作为参数，从命令行运行程序，如下所示：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Of course, this object does not have to be created from the command line; it
    could be imported from another module (to perform batch ZIP file processing),
    or accessed as part of a GUI interface or even a higher-level management object
    that knows where to get ZIP files (for example, to retrieve them from an FTP server
    or back them up to an external disk).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: As programs become more and more complex, the objects being modeled become less
    and less like physical objects. Properties are other abstract objects, and methods
    are actions that change the state of those abstract objects. But at the heart
    of every object, no matter how complex, is a set of concrete data and well-defined
    behaviors.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Removing duplicate code
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, the code in management style classes such as `ZipReplace` is quite generic
    and can be applied in a variety of ways. It is possible to use either composition
    or inheritance to help keep this code in one place, thus eliminating duplicate
    code. Before we look at any examples of this, let's discuss a tiny bit of theory.
    Specifically, why is duplicate code a bad thing?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: There are several reasons, but they all boil down to readability and maintainability.
    When we're writing a new piece of code that is similar to an earlier piece, the
    easiest thing to do is copy the old code and change whatever needs to be changed
    (variable names, logic, comments) to make it work in the new location. Alternatively,
    if we're writing new code that seems similar, but not identical, to code elsewhere
    in the project, it is often easier to write fresh code with similar behavior,
    rather than figuring out how to extract the overlapping functionality.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: But as soon as someone has to read and understand the code and they come across
    duplicate blocks, they are faced with a dilemma. Code that might have appeared
    to make sense suddenly has to be understood. How is one section different from
    the other? How are they the same? Under what conditions is one section called?
    When do we call the other? You might argue that you're the only one reading your
    code, but if you don't touch that code for eight months, it will be as incomprehensible
    to you as it is to a fresh coder. When we're trying to read two similar pieces
    of code, we have to understand why they're different, as well as how they're different.
    This wastes the reader's time; code should always be written to be readable first.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: I once had to try to understand someone's code that had three identical copies
    of the same 300 lines of very poorly written code. I had been working with the
    code for a month before I finally comprehended that the three *identical* versions
    were actually performing slightly different tax calculations. Some of the subtle
    differences were intentional, but there were also obvious areas where someone
    had updated a calculation in one function without updating the other two. The
    number of subtle, incomprehensible bugs in the code could not be counted. I eventually
    replaced all 900 lines with an easy-to-read function of 20 lines or so.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Reading such duplicate code can be tiresome, but code maintenance is even more
    tormenting. As the preceding story suggests, keeping two similar pieces of code
    up to date can be a nightmare. We have to remember to update both sections whenever
    we update one of them, and we have to remember how multiple sections differ so
    we can modify our changes when we are editing each of them. If we forget to update
    all sections, we will end up with extremely annoying bugs that usually manifest
    themselves as, But I fixed that already, why is it still happening*?*
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The result is that people who are reading or maintaining our code have to spend
    astronomical amounts of time understanding and testing it compared to the time
    required to write it in a non-repetitive manner in the first place. It's even
    more frustrating when we are the ones doing the maintenance; we find ourselves
    saying, Why didn't I do this right the first time? The time we save by copying
    and pasting existing code is lost the very first time we have to maintain it.
    Code is both read and modified many more times and much more often than it is
    written. Comprehensible code should always be a priority.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: This is why programmers, especially Python programmers (who tend to value elegant
    code more than average developers), follow what is known as the **Don't Repeat
    Yourself** (**DRY**) principle. DRY code is maintainable code. My advice for beginning
    programmers is to never use the copy-and-paste feature of their editor. To intermediate
    programmers, I suggest they think thrice before they hit *Ctrl* + *C*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: But what should we do instead of code duplication? The simplest solution is
    often to move the code into a function that accepts parameters to account for
    whatever parts are different. This isn't a terribly object-oriented solution,
    but it is frequently optimal.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we have two pieces of code that unzip a ZIP file into two different
    directories, we can easily replace it with a function that accepts a parameter
    for the directory to which it should be unzipped. This may make the function itself
    slightly more difficult to read, but a good function name and docstring can easily
    make up for that, and any code that invokes the function will be easier to read.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s certainly enough theory! The moral of the story is: always make the
    effort to refactor your code to be easier to read instead of writing bad code
    that may seem easier to write.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: In practice
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's explore two ways we can reuse existing code. After writing our code to
    replace strings in a ZIP file full of text files, we are later contracted to scale
    all the images in a ZIP file to 640 x 480\. It looks like we could use a very
    similar paradigm to what we used in `ZipReplace`. Our first impulse might be to
    save a copy of that file and change the `find_replace` method to `scale_image`
    or something similar.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: But, that's suboptimal. What if someday we want to change the `unzip` and `zip`
    methods to also open TAR files? Or maybe we'll want to use a guaranteed unique
    directory name for temporary files. In either case, we'd have to change it in
    two different places!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by demonstrating an inheritance-based solution to this problem.
    First, we''ll modify our original `ZipReplace` class into a superclass for processing
    generic ZIP files:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We changed the `filename` property to `zipname` to avoid confusion with the
    `filename` local variables inside the various methods. This helps make the code
    more readable, even though it isn't actually a change in design.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: We also dropped the two parameters to `__init__` (`search_string` and `replace_string`)
    that were specific to `ZipReplace`. Then, we renamed the `zip_find_replace` method
    to `process_zip` and made it call an (as yet undefined) `process_files` method
    instead of `find_replace`; these name changes help demonstrate the more generalized
    nature of our new class. Notice that we have removed the `find_replace` method
    altogether; that code is specific to `ZipReplace` and has no business here.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: This new `ZipProcessor` class doesn't actually define a `process_files` method.
    If we ran it directly, it would raise an exception. Because it isn't meant to
    run directly, we removed the main call at the bottom of the original script. We
    could make this an abstract base class in order to communicate that this method
    needs to be defined in a subclass, but I've left it out for brevity.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, before we move on to our image processing application, let''s fix up our
    original `zipsearch` class to make use of this parent class, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This code is shorter than the original version, since it inherits its ZIP processing
    abilities from the parent class. We first import the base class we just wrote
    and make `ZipReplace` extend that class. Then, we use `super()` to initialize
    the parent class. The `find_replace` method is still here, but we renamed it `process_files`
    so the parent class can call it from its management interface. Because this name
    isn't as descriptive as the old one, we added a docstring to describe what it
    is doing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Now, that was quite a bit of work, considering that all we have now is a program
    that is functionally not different from the one we started with! But having done
    that work, it is now much easier for us to write other classes that operate on
    files in a ZIP archive, such as the (hypothetically requested) photo scaler. Further,
    if we ever want to improve or bug fix the zip functionality, we can do it for
    all subclasses at once by changing only the one `ZipProcessor` base class. Therefore
    maintenance will be much more effective.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'See how simple it is now to create a photo scaling class that takes advantage
    of the `ZipProcessor` functionality:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Look how simple this class is! All that work we did earlier paid off. All we
    do is open each file (assuming that it is an image; it will unceremoniously crash
    if a file cannot be opened or isn't an image), scale it, and save it back. The
    `ZipProcessor` class takes care of the zipping and unzipping without any extra
    work on our part.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Case study
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this case study, we'll try to delve further into the question, When should
    I choose an object versus a built-in type? We'll be modeling a `Document` class
    that might be used in a text editor or word processor. What objects, functions,
    or properties should it have?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: We might start with a `str` for the `Document` contents, but in Python, strings
    aren't mutable (able to be changed). Once a `str` is defined, it is forever. We
    can't insert a character into it or remove one without creating a brand new string
    object. That would be leaving a lot of `str` objects taking up memory until Python's
    garbage collector sees fit to clean up behind us.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: So, instead of a string, we'll use a list of characters, which we can modify
    at will. In addition, we'll need to know the current cursor position within the
    list, and should probably also store a filename for the document.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Real text editors use a binary tree-based data structure called a `rope` to
    model their document contents. This book's title isn't *Advanced Data Structures*,
    so if you're interested in learning more about this fascinating topic, you may
    want to search the web for *rope data structure*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of things we might want to do to a text document, including
    inserting, deleting, and selecting characters; cutting, copying, and, pasting
    the selection; and saving or closing the document. It looks like there are copious
    amounts of both data and behavior, so it makes sense to put all this stuff into
    its own `Document` class.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'A pertinent question is: should this class be composed of a bunch of basic
    Python objects such as `str` filenames, `int` cursor positions, and a `list` of
    characters? Or should some or all of those things be specially defined objects
    in their own right? What about individual lines and characters? Do they need to
    have classes of their own?'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll answer these questions as we go, but let''s start with the simplest
    possible class first- `Document`  and see what it can do:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This basic class allows us full control over editing a basic document. Have
    a look at it in action:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It looks like it's working. We could connect a keyboard's letter and arrow keys
    to these methods and the document would track everything just fine.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if we want to connect more than just arrow keys. What if we want to
    connect the *Home* and *End* keys as well? We could add more methods to the `Document`
    class that search forward or backward for newline characters (a newline character,
    escaped as `\n`, represents the end of one line and the beginning of a new one)
    in the string and jump to them, but if we did that for every possible movement
    action (move by words, move by sentences, *Page Up*, *P**age Down*, end of line,
    beginning of white space, and others), the class would be huge. Maybe it would
    be better to put those methods on a separate object. So, let''s turn the `Cursor`
    attribute into an object that is aware of its position and can manipulate that
    position. We can move the forward and back methods to that class, and add a couple
    more for the `Home` and `End` keys, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This class takes the document as an initialization parameter so the methods
    have access to the content of the document's character list. It then provides
    simple methods for moving backward and forward, as before, and for moving to the `home`
    and `end` positions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: This code is not very safe. You can very easily move past the ending position,
    and if you try to go home on an empty file, it will crash. These examples are
    kept short to make them readable, but that doesn't mean they are defensive! You
    can improve the error checking of this code as an exercise; it might be a great
    opportunity to expand your exception-handling skills.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Document` class itself is hardly changed, except for removing the two
    methods that were moved to the `Cursor` class:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We just updated anything that accessed the old cursor integer to use the new
    object instead. We can now test that the `home` method is really moving to the
    newline character, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, since we''ve been using that string `join` function a lot (to concatenate
    the characters so we can see the actual document contents), we can add a property
    to the `Document` class to give us the complete string as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This makes our testing a little simpler:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This framework is simple to extend, create and edit a complete plain text document
    (though it might be a bit time consuming!) Now, let's extend it to work for rich
    text; text that can have **bold**, underlined, or *italic* characters.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways we could process this. The first is to insert *fake* characters
    into our character list that act like instructions, such as *bold characters until
    you find a stop bold character*. The second is to add information to each character,
    indicating what formatting it should have. While the former method is more common
    in real editors, we'll implement the latter solution. To do that, we're obviously
    going to need a class for characters. This class will have an attribute representing
    the character, as well as three Boolean attributes representing whether it is
    *bold, italic, or underlined*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Hmm, wait! Is this `Character` class going to have any methods? If not, maybe
    we should use one of the many Python data structures instead; a tuple or named
    tuple would probably be sufficient. Are there any actions that we would want to
    execute or invoke on a character?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Well, clearly, we might want to do things with characters, such as delete or
    copy them, but those are things that need to be handled at the `Document` level,
    since they are really modifying the list of characters. Are there things that
    need to be done to individual characters?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Actually, now that we're thinking about what a `Character` class actually **is**...
    what is it? Would it be safe to say that a `Character` class is a string? Maybe
    we should use an inheritance relationship here? Then we can take advantage of
    the numerous methods that `str` instances come with.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: What sorts of methods are we talking about? There's `startswith`, `strip`, `find`,
    `lower`, and many more. Most of these methods expect to be working on strings
    that contain more than one character. In contrast, if `Character` were to subclass
    `str`, we'd probably be wise to override `__init__` to raise an exception if a
    multi-character string were supplied. Since all those methods we'd get for free
    wouldn't really apply to our `Character` class, it seems we shouldn't use inheritance,
    after all.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us back to our original question; should `Character` even be a
    class? There is a very important special method on the `object` class that we
    can take advantage of to represent our characters. This method, called `__str__`
    (two underscores at each end, like `__init__`), is used in string-manipulation
    functions such as `print` and the `str` constructor to convert any class to a
    string. The default implementation does some boring stuff, such as printing the
    name of the module and class, and its address in memory. But if we override it,
    we can make it print whatever we like. For our implementation, we could make it
    prefix characters with special characters to represent whether they are bold,
    italic, or underlined. So, we will create a class to represent a character, and
    here it is:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This class allows us to create characters and prefix them with a special character
    when the `str()` function is applied to them. Nothing too exciting there. We only
    have to make a few minor modifications to the `Document` and `Cursor` classes
    to work with this class. In the `Document` class, we add these two lines at the
    beginning of the `insert` method, as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is a rather strange bit of code. Its basic purpose is to check whether
    the character being passed in is a `Character` or a `str`. If it is a string,
    it is wrapped in a `Character` class so all objects in the list are `Character`
    objects. However, it is entirely possible that someone using our code would want
    to use a class that is neither a `Character` nor a string, using duck typing.
    If the object has a character attribute, we assume it is a `Character`-like object.
    But if it does not, we assume it is a `str`-like object and wrap it in `Character`.
    This helps the program take advantage of duck typing as well as polymorphism;
    as long as an object has a character attribute, it can be used in the `Document`
    class.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: This generic check could be very useful. For example, if we wanted to make a
    programmer's editor with syntax highlighting, we'd need extra data on the character,
    such as what type of syntax token the character belongs to. Note that, if we are
    doing a lot of this kind of comparison, it's probably better to implement `Character`
    as an abstract base class with an appropriate `__subclasshook__`, as discussed
    in [Chapter 3](ba7b3eb7-17cc-4f1c-bb74-fb7d5ee7d517.xhtml), *When Objects Are
    Alike*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we need to modify the string property on `Document` to accept
    the new `Character` values. All we need to do is call `str()` on each character
    before we join it, as demonstrated in the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This code uses a generator expression, which we'll discuss in [Chapter 9](0abbcae0-eb3f-4237-adda-32765e1cce32.xhtml),
    *The Iterator Pattern*. It's a shortcut to perform a specific action on all the
    objects in a sequence.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we also need to check `Character.character`, instead of just the string
    character we were storing before, in the `home` and `end` functions when we''re
    looking to see whether it matches a newline character, as demonstrated in the
    following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This completes the formatting of characters. We can test it to see that it
    works as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As expected, whenever we print the string, each bold character is preceded by
    a `*` character, each italicized character by a `/` character, and each underlined
    character by a `_` character. All our functions seem to work, and we can modify
    characters in the list after the fact. We have a working rich text document object
    that could be plugged into a proper graphical user interface and hooked up with
    a keyboard for input and a screen for output. Naturally, we'd want to display
    real *bold, italic, and underlined* fonts in a UI, instead of using our `__str__`
    method, but it was sufficient for the basic testing we demanded of it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've looked at various ways that objects, data, and methods can interact with
    each other in an object-oriented Python program. As usual, your first thoughts
    should be how you can apply these principles to your own work. Do you have any
    messy scripts lying around that could be rewritten using an object-oriented manager?
    Look through some of your old code and look for methods that are not actions.
    If the name isn't a verb, try rewriting it as a property.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Think about code you've written in any language. Does it break the DRY principle?
    Is there any duplicate code? Did you copy and paste code? Did you write two versions
    of similar pieces of code because you didn't feel like understanding the original
    code? Go back over some of your recent code now and see whether you can refactor
    the duplicate code using inheritance or composition. Try to pick a project you're
    still interested in maintaining; not code so old that you never want to touch
    it again. That will help to keep you interested when you do the improvements!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Now, look back over some of the examples we looked at in this chapter. Start
    with the cached web page example that uses a property to cache the retrieved data.
    An obvious problem with this example is that the cache is never refreshed. Add
    a timeout to the property's getter, and only return the cached page if the page
    has been requested before the timeout has expired. You can use the `time` module
    (`time.time() - an_old_time` returns the number of seconds that have elapsed since
    `an_old_time`) to determine whether the cache has expired.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Also look at the inheritance-based `ZipProcessor`. It might be reasonable to
    use composition instead of inheritance here. Instead of extending the class in
    the `ZipReplace` and `ScaleZip` classes, you could pass instances of those classes
    into the `ZipProcessor` constructor and call them to do the processing part. Implement
    this.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Which version do you find easier to use? Which is more elegant? What is easier
    to read? These are subjective questions; the answer varies for each of us. Knowing
    the answer, however, is important. If you find you prefer inheritance over composition,
    you need to pay attention that you don't overuse inheritance in your daily coding.
    If you prefer composition, make sure you don't miss opportunities to create an
    elegant inheritance-based solution.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Finally, add some error handlers to the various classes we created in the case
    study. They should ensure single characters are entered, that you don't try to
    move the cursor past the end or beginning of the file, that you don't delete a
    character that doesn't exist, and that you don't save a file without a filename.
    Try to think of as many edge cases as you can, and account for them (thinking
    about edge cases is about 90% of a professional programmer's job!). Consider different
    ways to handle them; should you raise an exception when the user tries to move
    past the end of the file, or just stay on the last character?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: In your daily coding, pay attention to the copy and paste commands. Every time
    you use them in your editor, consider whether it would be a good idea to improve
    your program's organization so that you only have one version of the code you
    are about to copy.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on identifying objects, especially objects that
    are not immediately apparent; objects that manage and control. Objects should
    have both data and behaviors, but properties can be used to blur the distinction
    between the two. The DRY principle is an important indicator of code quality,
    and inheritance and composition can be applied to reduce code duplication.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover several of the built-in Python data structures
    and objects, focusing on their object-oriented properties and how they can be
    extended or adapted.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
