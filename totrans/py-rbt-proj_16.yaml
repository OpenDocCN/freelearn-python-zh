- en: Machine Learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Robots and computers from its primitive days to even right now are being programmed
    to do a set of activities. These activities can be very large. Hence, to develop
    complex programs, there is a need for a lot of software engineers who work day
    and night to achieve a certain functionality. This is workable when the problem
    is well defined. But what about situations when the problem is also way complex?
  prefs: []
  type: TYPE_NORMAL
- en: Learning is something that has made us humans what we are. Our experiences molded
    us to adapt to situations in a better and a more efficient way. Every time we
    do something, we know more. This makes us better at doing that task over a period
    of time. It is said practice makes a man perfect, and it is learning through doing
    things again and again that makes us better.
  prefs: []
  type: TYPE_NORMAL
- en: However, let us step back and define what learning is? I would like to quote
    Google here according to it, *It is a knowledge acquired through study, experience
    or being taught*. So, learning is basically a way of acquiring information from
    our surroundings to understand a process and its nature.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you must be thinking, wait a minute, haven't we made our system learn a
    lot of vision data in previous chapters when we were making the guard robot. You
    would be absolutely correct to think so. However, the learning can be done in
    different ways. What may work for one kind of problem can be futile for some other
    kind of problem. Hence, there are various types of learning algorithms and their
    principles. In this chapter, we will be focusing on an algorithm named **k-nearest
    neighbor**. It's named the **lazy algorithm**. I love this algorithm personally
    for classification. Why? Because technically there is no training phase. How?
  prefs: []
  type: TYPE_NORMAL
- en: k-nearest neighbor is actually a smart algorithm. Rather than computing a regression
    of data provided and do a lot of mathematics calculations, it simply takes a structured
    data from the dataset provided. Whenever there is new data that has come in for
    prediction, then it simply searches the closest *k* match of the data provided
    by the user to the database based on its classification given. So, in this chapter,
    we will learn how this algorithm will work and how we can use it to make our home
    smart.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Making a dataset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prediction using dataset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making your home learn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Home learning and automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like in [Chapter 10](f5d8044d-e608-4ab6-adca-52ec2689f115.xhtml), *Making a
    Guard Robot*, we have used multiple images for the user to train the model to
    find out whether the object in the image is a man or something else. In a very
    similar way, we would have to make a dummy dataset so that the machine learning
    algorithm can predict based on that data what should be done.
  prefs: []
  type: TYPE_NORMAL
- en: To make a dataset, we need to understand what data is being considered. In this
    chapter, we will be making a machine learning algorithm based on time and the
    temperature to predict whether the fan should be on or off. Hence, there are at
    least two things that should be provided by us to the system one being `Temperature`,
    and the other would be `Time` so that the prediction can take place. But one thing
    to remember is that we are talking about a supervised learning algorithm, so to
    train the model, we need to also give the outcome of `Temperature` and `Time`
    onto the state of the fan. Here, the state of the fan would be either on or off.
    Hence, we can depict it using `0` or `1`. Now let's go ahead and make a dataset
    by ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to make a dataset, you simply have to open Microsoft Excel and start writing
    the dataset as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f96de387-2d29-4a30-a656-6aabaaf3b3ab.png)'
  prefs: []
  type: TYPE_IMG
- en: It is always better to have a dataset of more than 20 sets of data. Also, its
    important that the data has a distinct characteristic and its not random data.
    For example, in the preceding case, you can see that at `12.44` when the temperature
    is `28`, the fan will be on; however, at the same time, when the time is `12.13`
    and temperature is `21`, then the fan is off.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have created a dataset, then you must save it with the name `dataset` in
    the CSV format. There may be some users who would not use a Microsoft Excel, in
    which case you can write the data with the same format in text editor and finally
    save it in the CSV format.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the `dataset.csv` files, then you must go ahead and copy them
    into the place where you will be saving the upcoming code. Once you are done,
    then we can move on to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the better the quality of data, the better the learning process.
    So you may take some time and carefully craft your dataset so that it does make
    sense.
  prefs: []
  type: TYPE_NORMAL
- en: Predicting using a dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Without much talking, let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s see what we are doing here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We are importing `numpy` to our program; this helps us handle lists and matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are importing a library named `pandas`; this helps us read files in
    comma-separated values or in other words, CSV files. We will be using CSV files
    to store our data and access it for learning process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are importing `KneighborsClassifier` from the library `sklearn`. `sklearn`
    itself is a huge library; hence, we are importing only a part of it as we will
    not be using all of it in this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are giving value to variable `knn` wherein the value would be `KNeighborsClassifer(n_neighbors
    =5)`; what this means is that it is using the `KneighborsClassifer()` function
    with the argument as `n_neighbors=5`. This argument tells the `KneighborsClassifer`
    function that we will be having five neighbors in the algorithm. Further to this
    using this declaration, the whole function can be called using `knn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are providing value to a variable called `data` and the value passed
    is `pd.read_csv(''dataset.csv'')`; what this means is that whenever `data` is
    called, then a `pd.read_csv()` function from the `pandas` library will be called.
    The purpose of this function is to read data from the CSV files. Here, the argument
    passed is `dataset.csv`; hence, it is indicating which data would be read by the
    function. In our case, it will read from a file name: `dataset.csv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following line, we are passing value to the variable `x`, and the value
    being passed is `np.array(data[[''Time, ''Temp'']])`. Now the `np.array` function
    to make an array through the `numpy` library. This array will store the data by
    the name of `Time` and `Temp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like the previous time, we are storing `State` in an array made through
    the `numpy` library `.ravel()` function at the end would transpose the array.
    This is done so that the mathematical functions can be done between two arrays—`x`
    and `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this small line, we are using the function from the `knn` library called `fit()`
    what it is doing is fitting the model using the `x` as the primary data and `y`
    as the output resultant data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this line, we are requesting the data from the user. In the first line, we
    will be printing `Enter time` and thereafter wait for user to enter the time.
    After user has entered the time, it will be stored in the variable named `time`.
    Once that is done, then it would move on to the next line; the code and it would
    print `Enter temp` once that is prompted to the user it would wait for data to
    be collected. Once data is fetched by the user, it will store that data in the
    variable called `temp:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are making an empty list by the name of `data`; this list will be
    used for calculating the resultant state of the output. As all the machine learning
    algorithm is working in list data type. Hence, the input must be given for decision
    in the form of a list itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are adding data to the list that we just created with the name `data`.
    First, `time` will be added, followed by `temp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once that is done, a function named `predict` from the `knn` algorithm will
    be used to predict the output based on the list provided with the name of `data`.
    The output of the prediction algorithm is fetched to a variable by the name  `a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Finally, once the prediction is done, then we would read the value of   `a` and
    remember that all the data I/O is happening in the form of lists. Hence, the data
    output given by the prediction algorithm would also be in the list format. Hence,
    we are printing the first element of the list.
  prefs: []
  type: TYPE_NORMAL
- en: This output will predict which state will be of the fan according to the dataset
    given by the user. So, go ahead and give a temperature and a time and let the
    system predict the outcome for you. See if it works fine or not. If it doesn't,
    then try adding some more datasets to the CSV files or see whether the values
    in the dataset actually make any sense. I am sure that you end up with a wonderful
    predictive system.
  prefs: []
  type: TYPE_NORMAL
- en: Making your home learn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once this constitution is done, go ahead and wire it up, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/855c4bae-d685-44b1-bb0c-5926da8035a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once that is set, it is time for us to write the following code on to our Raspberry
    Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see what we have done here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this line of the code, we have assigned the value `open("dataset.csv", "a+")`
    to the variable `f`. Thereafter, the `open()` function will open the file that
    is passed on to its argument, which in our case is `dataset.csv`; the argument `a+`
    stands for appending the value at the end of the CSV file. Hence, what this line
    will do is to open the file `dataset.csv` and add a value that we will pass later
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We are declaring an empty string by the name of `data`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We are adding values of hours and minutes to the string, separated by a dot
    in between for differentiation. Hence, the data will look like `HH.MM`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using this line to read the humidity and temperature reading from the
    DHT 11 sensor and the values that would be passed on to the variables `humidity`
    and `temperature`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the data is read, we are adding temperature to the variable `data` as
    well. Hence, now the data would look like this `HH.MM` and `TT.TT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have defined different types of states which are corresponding to
    the switch combinations. The table for it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Switch 1** | **Switch 2** | **State** |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `2` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `3` |'
  prefs: []
  type: TYPE_TB
- en: 'Hence, by the value of state, we can understand which switch would be turned
    on and which would be turned off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the value of state is also added to the variable named `data`. Now,
    finally, the data would look like `HH.MM`, `TT.TT`, and `S`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the `write()` function, we are writing the value of data to the file
    that we have already defined by the value `f` earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, with every single switch on or off, the data would be collected, and
    the value would be recorded with the time stamp in that file. This data can then
    be used to predict the state of the home at any given time without any intervention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are comparing the state with the `prev_state` as you can see in our
    program. The previous state is calculated at the start of our program. So, if
    there is any change in the state of the system, then the value of `prev_state`
    and `state` would be different. This will lead to the `if` statement to be true.
    When that happens, the data would be written onto our file using the `write()`
    function. The argument passed is the value that needs to be written. Finally,
    the value of count is increased by `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Once this is left running for a few hours or may be days, then it would collect
    some really useful data regarding your switching pattern of the lights and fan.
    Thereafter, this data can be fetched to the previous program wherein it would
    be able to to take its own decision based on the time and temperature.
  prefs: []
  type: TYPE_NORMAL
- en: Home learning and automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that in the previous section we have understood how the learning works,
    it''s time to use this concept to make a robot that will automatically understand
    how we function and make decisions. Based on our decisions, the system will judge
    what should be done. But this time, rather than giving a set of data by the user,
    let''s make this program create the data for itself. Once the data seems sufficient
    for itself to function. So, without much explanation, let''s get right into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s see what we have done here. In this program, the first part of the
    program inside the condition `while count < 200:` is exactly the same as what
    we have done in the last code. So, it is just doing the things according to the
    user, and at the same time, it''s taking in the values from the users to understand
    their working behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Thereafter, we have the second part of the code that will start to execute
    when the count is beyond `200` that is inside the preceding loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In this line, we are forming an empty string by the name of time where we would
    be storing the value of time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We are storing the values of time into the variable named `H` and `M`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now storing the value of time in the string `time`. This would include
    both hours and minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of ease of calculations and reducing the computing load on the
    system, we are reducing the size of the temperature variable . We are doing it
    by removing the decimal places. To do that `TT.TT`; we are simply eliminating
    the decimal point and converting it into integer. This is done by the function
    named `int()`. The value of temperature in `int` will be stored in the variable
    named `temp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are adding the value of the time and the temperature to a list named `test_set`
    if you look in the program, then you will see the declaration of an empty set
    in the mid of the program. So, now this `test_set` has the value of `time` and `temp`, which
    can be further used by the prediction algorithm to predict the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the simple function named `predict()` from the `knn` function, we can
    predict the value of the state. All we need to do is to pass on the data or `test_set`
    list over to the predict function. The output of this function will be a list
    that will be stored in a variable named `a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of `Out` will be set to the first element of the list `a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Using the preceding code block, we are able to switch on the light and fans
    selectively based on the state predicted by the algorithm. Hence, using this,
    the program would be able to automatically predict and switch on or off the light
    and the fans without your intervention.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we understood how machine learning works even without learning.
    We understood how datasets can be provided, and we can create a new dataset using
    the existing system. Finally, we understood how the system can work seamlessly
    to collect data, learn from that data, and finally, provide the input. Want to
    build a wheeled self-balancing robot? Well, then see you in the next chapter!
  prefs: []
  type: TYPE_NORMAL
