<html><head></head><body>
<section id="chapter-9-itertools-for-combinatorics-permutations-and-combinations" class="level2 chapterHead" data-number="0.13">&#13;
<h2 class="chapterHead" data-number="0.13"><span class="titlemark"> 9</span><br/>&#13;
<span id="x1-1990009"/>Itertools for Combinatorics – Permutations and Combinations</h2>&#13;
<p>Functional programming emphasizes stateless algorithms. In Python, this leads us to work with generator expressions, generator functions, and iterables. In this chapter, we’ll continue our study of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> library, with numerous functions to help us work with iterable collections.</p>&#13;
<p>In the previous chapter, we looked at three broad groupings of iterator functions. They are as follows:</p>&#13;
<ul>&#13;
<li><p>Functions that work with infinite iterators, which can be applied to any iterable or an iterator over any collection; they consume the entire source</p></li>&#13;
<li><p>Functions that work with finite iterators, which can either accumulate a source multiple times, or produce a reduction of the source</p></li>&#13;
<li><p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">tee()</code></span></span> iterator function, which clones an iterator into several copies that can each be used independently</p></li>&#13;
</ul>&#13;
<p>In this chapter, we’ll look at the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> functions that work with permutations and combinations. These include several combinatorial functions and a few recipes built on these functions. The functions are as follows:</p>&#13;
<ul>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">product()</code></span></span>: This function<span id="dx1-199001"/> forms a Cartesian product<span id="dx1-199002"/> equivalent to the nested <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statements or nested generator expressions.</p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">permutations()</code></span></span>: This function yields tuples<span id="dx1-199003"/> of length <span class="italic">r </span>from a universe <span class="italic">p </span>in all possible orderings; there are no repeated elements.</p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">combinations()</code></span></span>: This function yields tuples<span id="dx1-199004"/> of length <span class="italic">r </span>from a universe <span class="italic">p </span>in sorted order; there are no repeated elements.</p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">combinations_with_replacement()</code></span></span>: This function yields tuples<span id="dx1-199005"/> of length <span class="italic">r </span>from <span class="italic">p </span>in sorted order, allowing the repetition of elements.</p></li>&#13;
</ul>&#13;
<p>These functions embody algorithms that can create potentially large result sets from small collections of input data. Some kinds of problems have exact solutions based on exhaustively enumerating the universe of permutations. As a trivial example, when trying to find out if a hand of cards contains a <span class="cmti-10x-x-109">straight </span>(all numbers in adjacent, ascending order), one solution is to compute all permutations and see if at least one arrangement of cards is ascending. For a 5-card hard, there are only 120 arrangements. These functions make it simple to yield all the permutations; in some cases, this kind of simple enumeration isn’t optimal or even desirable. <span id="x1-199006r199"/></p>&#13;
<section id="enumerating-the-cartesian-product" class="level3 sectionHead" data-number="0.13.1">&#13;
<h3 class="sectionHead" data-number="0.13.1"><span class="titlemark">9.1 </span> <span id="x1-2000001"/>Enumerating the Cartesian product</h3>&#13;
<p>The term <span class="keyWord">Cartesian product </span>refers to the idea of enumerating<span id="dx1-200001"/> all the possible combinations of elements drawn from the elements of sets.</p>&#13;
<p>Mathematically, we might say that the product of two sets, <span class="cmsy-10x-x-109">{</span>1<span class="italic">,</span>2<span class="italic">,</span>3<span class="italic">,</span><span class="italic">…</span><span class="italic">,</span>13<span class="cmsy-10x-x-109">}×{♣</span><span class="italic">,</span><span class="cmsy-10x-x-109">♢</span><span class="italic">,</span><span class="cmsy-10x-x-109">♡</span><span class="italic">,</span><span class="cmsy-10x-x-109">♠}</span>, has 52 pairs, as follows:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file80.jpg" class="math-display" alt="{(1,♣),(1,♢),(1,♡ ),(1,♠ ),(2,♣ ),(2,♢ ),(2,♡),(2,♠),...,(13,♣ ),(13,♢),(13,♡),(13,♠ )} "/>&#13;
</div>&#13;
<p>We can produce the preceding results by executing the following commands:</p>&#13;
<pre id="listing-202" class="lstlisting"><code>&gt;&gt;&gt; cards = list(product(range(1, 14), ’♣♢♡♠’)) &#13;
&gt;&gt;&gt; cards[:4] &#13;
[(1, ’♣’), (1, ’♢’), (1, ’♡’), (1, ’♠’)] &#13;
&gt;&gt;&gt; cards[4:8] &#13;
[(2, ’♣’), (2, ’♢’), (2, ’♡’), (2, ’♠’)] &#13;
&gt;&gt;&gt; cards[-4:] &#13;
[(13, ’♣’), (13, ’♢’), (13, ’♡’), (13, ’♠’)]</code></pre>&#13;
<p>The calculation<span id="dx1-200009"/> of a product can be extended to any number of iterable collections. Using a large number of collections can lead to a very large result set. <span id="x1-200010r207"/></p>&#13;
</section>&#13;
<section id="reducing-a-product" class="level3 sectionHead" data-number="0.13.2">&#13;
<h3 class="sectionHead" data-number="0.13.2"><span class="titlemark">9.2 </span> <span id="x1-2010002"/>Reducing a product</h3>&#13;
<p>In relational database theory, a join between tables can be thought of as a filtered product. For those who know SQL, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">SELECT</code></span></span> statement joining tables without a <span class="obeylines-h"><span class="verb"><code class="inlineCode">WHERE</code></span></span> clause will produce a Cartesian<span id="dx1-201001"/> product of rows in the tables. This can be thought of as the worst-case algorithm—a vast product without any useful filtering to pick the desired subset of results. We can implement this using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools.product()</code></span></span> function to enumerate all possible combinations and filter those to keep the few that match properly.</p>&#13;
<p>We can define a <span class="obeylines-h"><span class="verb"><code class="inlineCode">join()</code></span></span> function to join two iterable collections or generators, as shown in the following commands:</p>&#13;
<pre id="listing-203" class="lstlisting"><code>from collections.abc import Iterable, Iterator, Callable &#13;
from itertools import product &#13;
from typing import TypeVar &#13;
 &#13;
JTL = TypeVar("JTL") &#13;
JTR = TypeVar("JTR") &#13;
 &#13;
def join( &#13;
    t1: Iterable[JTL], &#13;
    t2: Iterable[JTR], &#13;
    where: Callable[[tuple[JTL, JTR]], bool] &#13;
) -&gt; Iterable[tuple[JTL, JTR]]: &#13;
    return filter(where, product(t1, t2))</code></pre>&#13;
<p>All combinations<span id="dx1-201015"/> of the two iterables, <span class="obeylines-h"><span class="verb"><code class="inlineCode">t1</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">t2</code></span></span>, are computed. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> function will apply the given <span class="obeylines-h"><span class="verb"><code class="inlineCode">where()</code></span></span> function to pass or reject two-tuples, hinted as <span class="obeylines-h"><span class="verb"><code class="inlineCode">tuple[JTL,</code><code class="inlineCode"> JTR]</code></span></span>, that match properly. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">where()</code></span></span> function has the hint <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable[[tuple[JTL,</code><code class="inlineCode"> JTR]],</code></span></span> <span class="obeylines-h"><span class="verb"><code class="inlineCode">bool]</code></span></span> to show that it returns a Boolean result. This is typical of how SQL database queries work in the worst-case situation where there are no useful indexes or cardinality statistics to suggest a better algorithm.</p>&#13;
<p>While this algorithm always works, it can be terribly inefficient. We often need to look carefully at the problem and the available data to find a more efficient algorithm.</p>&#13;
<p>First, we’ll generalize the problem slightly by replacing the simple Boolean matching function. Instead of a binary result, it’s common to look for a minimum or maximum of some distance between items. In this case, the comparison yields a float value.</p>&#13;
<p>Assume that we have a class to define instances in a table of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Color</code></span></span> objects, as follows:</p>&#13;
<pre id="listing-204" class="lstlisting"><code>from typing import NamedTuple &#13;
class Color(NamedTuple): &#13;
    rgb: tuple[int, int, int] &#13;
    name: str</code></pre>&#13;
<p>Here’s an example of using this definition to create some <span class="obeylines-h"><span class="verb"><code class="inlineCode">Color</code></span></span> instances:</p>&#13;
<div id="tcolobox-209" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; palette = [Color(rgb=(239, 222, 205), name=’Almond’), &#13;
...  Color(rgb=(255, 255, 153), name=’Canary’), &#13;
...  Color(rgb=(28, 172, 120), name=’Green’), &#13;
...  Color(rgb=(255, 174, 66), name=’Yellow Orange’) &#13;
... ]</code></pre>&#13;
&#13;
</div>&#13;
<p>For more information, see <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 6</span></a>, <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Recursions and Reductions</span></a>, where we showed you how to parse a file of colors to create <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> objects. In this case, we’ve left the RGB color as a <span class="obeylines-h"><span class="verb"><code class="inlineCode">tuple[int,</code><code class="inlineCode"> int,</code><code class="inlineCode"> int]</code></span></span>, instead of decomposing each individual field.</p>&#13;
<p>An image will have a collection<span id="dx1-201026"/> of pixels, each of which is an RGB tuple. Conceptually, an image contains data like this:</p>&#13;
<pre id="listing-205" class="lstlisting"><code>pixels = [(r, g, b), (r, g, b), (r, g, b), ...]</code></pre>&#13;
<p>As a practical matter, the <span class="keyWord">Python Imaging Library </span>(<span class="keyWord">PIL</span>)<span id="dx1-201028"/> package presents the pixels in a number of forms. One of these is the mapping from the (<span class="italic">x,y</span>) coordinate to the RGB triple. For the Pillow project documentation, visit <a href="https://pypi.python.org/pypi/Pillow" class="url">https://pypi.python.org/pypi/Pillow</a>.</p>&#13;
<p>Given a <span class="obeylines-h"><span class="verb"><code class="inlineCode">PIL.Image</code></span></span> object, we can iterate over the collection of pixels with something like the following commands:</p>&#13;
<pre id="listing-206" class="lstlisting"><code>from collections.abc import Iterator &#13;
from typing import TypeAlias &#13;
from PIL import Image  # type: ignore[import] &#13;
 &#13;
Point: TypeAlias = tuple[int, int] &#13;
RGB: TypeAlias = tuple[int, int, int] &#13;
Pixel: TypeAlias = tuple[Point, RGB] &#13;
 &#13;
def pixel_iter(img: Image) -&gt; Iterator[Pixel]: &#13;
    w, h = img.size &#13;
    return ( &#13;
        (c, img.getpixel(c)) &#13;
        for c in product(range(w), range(h)) &#13;
    )</code></pre>&#13;
<p>This function determines the range of each coordinate based on the image size, <span class="obeylines-h"><span class="verb"><code class="inlineCode">img.size</code></span></span>. The values of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">product(range(w),</code><code class="inlineCode"> range(h))</code></span></span> method create all the possible combinations of coordinates. It has a result identical to two nested <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statements in a single expression.</p>&#13;
<p>This has the advantage of enumerating<span id="dx1-201043"/> each pixel with its coordinates. We can then process the pixels in no particular order and still reconstruct an image. This is particularly handy when using multiprocessing or multithreading to spread the workload among several cores or processors. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">concurrent.futures</code></span></span> module provides an easy way to distribute work among cores or processors. <span id="x1-201044r204"/></p>&#13;
<section id="computing-distances" class="level4 subsectionHead" data-number="0.13.2.1">&#13;
<h4 class="subsectionHead" data-number="0.13.2.1"><span class="titlemark">9.2.1 </span> <span id="x1-2020001"/>Computing distances</h4>&#13;
<p>A number of decision-making problems<span id="dx1-202001"/> require that we find a close enough match. We might not be able to use a simple equality test. Instead, we have to use a distance metric and locate items with the shortest distance to our target. The <span class="cmbxti-10x-x-109">k</span><span class="keyWord">-Nearest Neighbors </span>(<span class="keyWord">k-NN</span>) algorithm, for example, uses a training set of data and a distance measurement function. It locates the <span class="italic">k </span>nearest neighbors<span id="dx1-202002"/> to an unknown sample, and uses the majority of those neighbors to classify the unknown sample.</p>&#13;
<p>To explore this concept of enumerating all possible matches, we’ll use a slightly simpler example. However, even though it’s superficially simpler, it doesn’t work out well if we approach it naively and exhaustively enumerate all potential matches.</p>&#13;
<p>When doing color matching, we won’t have a simple equality test. A color, <span class="italic">C</span>, for our purposes, is a triple <span class="cmsy-10x-x-109">⟨</span><span class="italic">r,g,b</span><span class="cmsy-10x-x-109">⟩</span>. It’s a point in three-dimensional space. It’s often sensible to define a minimal distance function to determine whether two colors are close enough, without having the same three values of <span class="cmsy-10x-x-109">⟨</span><span class="italic">r</span><sub><span class="cmr-8">1</span></sub><span class="italic">,g</span><sub><span class="cmr-8">1</span></sub><span class="italic">,b</span><sub><span class="cmr-8">1</span></sub><span class="cmsy-10x-x-109">⟩ </span>= <span class="cmsy-10x-x-109">⟨</span><span class="italic">r</span><sub><span class="cmr-8">2</span></sub><span class="italic">,g</span><sub><span class="cmr-8">2</span></sub><span class="italic">,b</span><sub><span class="cmr-8">2</span></sub><span class="cmsy-10x-x-109">⟩</span>. We need a multi-dimensional distance computation, using the red, green, and blue axes of a color space. There are several common approaches to measuring distance, including the Euclidean distance, Manhattan distance, and other more complex weightings based on visual preferences.</p>&#13;
<p>Here are the Euclidean and Manhattan distance<span id="dx1-202003"/> functions:</p>&#13;
<pre id="listing-207" class="lstlisting"><code>import math &#13;
def euclidean(pixel: RGB, color: Color) -&gt; float: &#13;
    return math.sqrt( &#13;
        sum(map( &#13;
            lambda x_1, x_2: (x_1 - x_2) ** 2, &#13;
            pixel, &#13;
            color.rgb)) &#13;
        ) &#13;
 &#13;
def manhattan(pixel: RGB, color: Color) -&gt; float: &#13;
    return sum(map( &#13;
        lambda x_1, x_2: abs(x_1 - x_2), &#13;
        pixel, &#13;
        color.rgb))</code></pre>&#13;
<p>The <span class="keyWord">Euclidean distance</span><span id="dx1-202018"/> measures the hypotenuse of a right-angled triangle among the three points in an RGB space. Here’s the formal definition for three dimensions:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file81.jpg" class="math-display" alt=" ∘ -------------------------------- ED (c1,c2) = (r1 − r2)2 + (g1 − g2)2 + (b1 − b2)2 "/>&#13;
</div>&#13;
<p>Here’s a two-dimensional sketch of the Euclidean distance between two points:</p>&#13;
<div class="center">&#13;
<p><img src="../Images/file82.jpg" alt=" √ ------- ((E14D,,15))= 32 + 42 = 5"/></p>&#13;
</div>&#13;
<p>The <span class="keyWord">Manhattan distance</span><span id="dx1-202019"/> sums the edges of each leg of the right-angled triangle among the three points. It’s named after the gridded<span id="dx1-202020"/> layout of the Borough of Manhattan in New York City. To get around, one is forced to travel only on the streets and avenues. Here’s the formal definition for three dimensions:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file83.jpg" class="math-display" alt="M D(c1,c2) = (r1 − r2) + (g1 − g2)+ (b1 − b2) "/>&#13;
</div>&#13;
<p>Here’s a two-dimensional sketch of the Manhattan distance between two points:</p>&#13;
<div class="center">&#13;
<p><img src="../Images/file84.jpg" alt="((M14,,D15))= 3+ 4 = 7"/></p>&#13;
</div>&#13;
<p>The Euclidean distance offers precision, while the Manhattan distance offers calculation speed.</p>&#13;
<p>Looking forward, we’re aiming for a structure that looks like this. For each individual pixel, we can compute the distance from that pixel’s color to the available colors in a limited color set. The results of this calculation<span id="dx1-202021"/> for one individual pixel of an image might start like the following example:</p>&#13;
<div id="tcolobox-210" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>[((0, 0), &#13;
  (92, 139, 195), &#13;
  Color(rgb=(239, 222, 205), name=’Almond’), &#13;
  169.10943202553784), &#13;
 ((0, 0), &#13;
  (92, 139, 195), &#13;
  Color(rgb=(255, 255, 153), name=’Canary’), &#13;
  204.42357985320578), &#13;
 ((0, 0), &#13;
  (92, 139, 195), &#13;
  Color(rgb=(28, 172, 120), name=’Green’), &#13;
  103.97114984456024), &#13;
 ((0, 0), &#13;
  (92, 139, 195), &#13;
  Color(rgb=(48, 186, 143), name=’Mountain Meadow’), &#13;
  82.75868534480233),</code></pre>&#13;
&#13;
</div>&#13;
<p>We’ve shown a sequence of tuples; each tuple has four items:</p>&#13;
<ul>&#13;
<li><p>The pixel’s coordinates; for example, (0,0)</p></li>&#13;
<li><p>The pixel’s original color; for example, (92, 139, 195)</p></li>&#13;
<li><p>A <span class="obeylines-h"><span class="verb"><code class="inlineCode">Color</code></span></span> object from a set of seven colors; for example, <span class="lstinline"><span style="color:#000000"><code class="inlineCode">Color</code></span><span style="color:#000000"><code class="inlineCode">(</code></span><span style="color:#000000"><code class="inlineCode">rgb</code></span><span style="color:#000000"><code class="inlineCode">=(48,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">186,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">143)</code></span><span style="color:#000000"><code class="inlineCode">,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">name</code></span><span style="color:#000000"><code class="inlineCode">=’</code></span><span style="color:#000000"><code class="inlineCode">Mountain</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">Meadow</code></span><span style="color:#000000"><code class="inlineCode">’)</code></span></span></p></li>&#13;
<li><p>The Euclidean distance between the original color and the given <span class="obeylines-h"><span class="verb"><code class="inlineCode">Color</code></span></span> object; for example, 82.75868534480233</p></li>&#13;
</ul>&#13;
<p>It can help to create a <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> to encapsulate the four items in each tuple. We could call it an X-Y, Pixel, Color, Distance tuple, something like ”XYPCD.” This would make it slightly easier to identify the (<span class="italic">x,y</span>) coordinate, the original pixel’s color, the matching color, and the distance between the original color and the selected match.</p>&#13;
<p>The smallest Euclidean distance<span id="dx1-202039"/> is a closest match color. For the four example colors, the Mountain Meadow is the closest match for this pixel. This kind of reduction is done with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">min()</code></span></span> function. If the overall four-tuple of (x,y), pixel, color, and distance is assigned to a variable name, <span class="obeylines-h"><span class="verb"><code class="inlineCode">choices</code></span></span>, the pixel-level reduction would look like this:</p>&#13;
<pre id="listing-208" class="lstlisting"><code>min(choices, key=lambda xypcd: xypcd[3])</code></pre>&#13;
<p>This expression will pick a single tuple as the optimal match between a pixel and color. It uses a lambda to select item 3 from the tuple, the distance metric. <span id="x1-202041r209"/></p>&#13;
</section>&#13;
<section id="getting-all-pixels-and-all-colors" class="level4 subsectionHead" data-number="0.13.2.2">&#13;
<h4 class="subsectionHead" data-number="0.13.2.2"><span class="titlemark">9.2.2 </span> <span id="x1-2030002"/>Getting all pixels and all colors</h4>&#13;
<p>How do we get to the structure<span id="dx1-203001"/> that contains all pixels and all colors? One seemingly simple answer turns out to be less than optimal.</p>&#13;
<p>One way to map pixels to colors is to enumerate<span id="dx1-203002"/> all pixels and all colors using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">product()</code></span></span> function:</p>&#13;
<pre id="listing-209" class="lstlisting"><code>from collections.abc import Iterable &#13;
from itertools import groupby &#13;
 &#13;
def matching_1( &#13;
        pixels: Iterable[Pixel], &#13;
        colors: Iterable[Color] &#13;
    ) -&gt; Iterator[tuple[Point, RGB, Color, float]]: &#13;
 &#13;
    distances = ( &#13;
        (pixel[0], pixel[1], color, euclidean(pixel[1], color)) &#13;
        for pixel, color in product(pixels, colors) &#13;
    ) &#13;
    for _, choices in groupby(distances, key=lambda xy_p_c_d: xy_p_c_d[0]): &#13;
        yield min(choices, key=lambda xypcd: xypcd[3])</code></pre>&#13;
<p>The core of this is the <span class="obeylines-h"><span class="verb"><code class="inlineCode">product(pixel_iter(img),</code><code class="inlineCode"> colors)</code></span></span> expression that creates a sequence of all pixels combined with all colors. The overall expression then applies the <span class="obeylines-h"><span class="verb"><code class="inlineCode">euclidean()</code></span></span> function to compute distances between pixels and <span class="obeylines-h"><span class="verb"><code class="inlineCode">Color</code></span></span> objects. The result is a sequence of four-tuple objects with the original (<span class="italic">x,y</span>) coordinate, the original pixel, an available color, and the distance between the original pixel color and the available color.</p>&#13;
<p>The final selection<span id="dx1-203017"/> of colors uses the <span class="obeylines-h"><span class="verb"><code class="inlineCode">groupby()</code></span></span> function and the <span class="obeylines-h"><span class="verb"><code class="inlineCode">min(choices,</code><code class="inlineCode"> ...)</code></span></span> expression to locate the closest match.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">product()</code></span></span> function applied<span id="dx1-203018"/> to pixels and colors creates a long, flat iterable. We grouped the iterable into smaller collections where the coordinates match. This will break the big iterable into smaller iterables of only the pool of colors associated with a single pixel. We can then pick the minimal color distance for each available color for a pixel.</p>&#13;
<p>In a picture that’s 3,648<span class="tcrm-1095">×</span>2,736 pixels with 133 Crayola colors, we have an iterable with 3<span class="italic">,</span>648 <span class="cmsy-10x-x-109">× </span>2<span class="italic">,</span>736 <span class="cmsy-10x-x-109">× </span>133 = 1<span class="italic">,</span>327<span class="italic">,</span>463<span class="italic">,</span>424 items to be evaluated. That is a billion combinations created by this <span class="obeylines-h"><span class="verb"><code class="inlineCode">distances</code></span></span> expression. The number is not necessarily impractical; it’s well within the limits of what Python can do. However, it reveals an important flaw in the naive use of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">product()</code></span></span> function.</p>&#13;
<p>We can’t trivially do this kind of large-scale processing without first doing some analysis to see how large the intermediate data will be. Here are some <span class="obeylines-h"><span class="verb"><code class="inlineCode">timeit</code></span></span> numbers for these two distance functions. This is the overall number of seconds to do each of these calculations only 1,000,000 times:</p>&#13;
<ul>&#13;
<li><p>Euclidean: 1.761</p></li>&#13;
<li><p>Manhattan: 0.857</p></li>&#13;
</ul>&#13;
<p>Scaling up by a factor of 1,000—from 1 million combinations to 1 billion—means the processing will take at least 1,800 seconds; that is, about half an hour for the Manhattan distance and 46 minutes to calculate the Euclidean distance. It appears this kind of naive bulk processing is ineffective for large datasets.</p>&#13;
<p>More importantly, we’re doing it wrong. This kind of <span class="cmti-10x-x-109">width</span> <span class="cmsy-10x-x-109">×</span> <span class="cmti-10x-x-109">height</span> <span class="cmsy-10x-x-109">×</span> <span class="cmti-10x-x-109">color</span> processing is simply a bad design. In many cases, we can do much better. <span id="x1-203019r208"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="performance-improvements" class="level3 sectionHead" data-number="0.13.3">&#13;
<h3 class="sectionHead" data-number="0.13.3"><span class="titlemark">9.3 </span> <span id="x1-2040003"/>Performance improvements</h3>&#13;
<p>A key feature of any big data algorithm<span id="dx1-204001"/> is locating a way to execute some kind of a divide-and-conquer strategy. This is true of functional programming design as well as imperative design.</p>&#13;
<p>Here are three options to speed up this processing:</p>&#13;
<ul>&#13;
<li><p>We can try to use parallelism to do more of the calculations concurrently. On a four-core processor, the time can be cut to approximately 25 percent. This reduces the time to 8 minutes for Manhattan distances.</p></li>&#13;
<li><p>We can see if caching intermediate results will reduce the amount of redundant calculation. The question arises of how many colors are the same and how many colors are unique.</p></li>&#13;
<li><p>We can look for a radical change in the algorithm.</p></li>&#13;
</ul>&#13;
<p>We’ll combine the last two points by computing all the possible comparisons between source colors and target colors. In this case, as in many other contexts, we can easily enumerate the entire mapping of pixels and colors. If colors are repeated, we avoid doing redundant calculations to locate the closest color. We’ll also change the algorithm from a series of comparisons to a series of lookups in a mapping object.</p>&#13;
<p>In many problem domains, the source data is a collection of floating-point values. While these <span class="obeylines-h"><span class="verb"><code class="inlineCode">float</code></span></span> values are flexible, and correspond in some ways with the mathematical abstraction of real numbers, they introduce some additional costs. Float operations can be slower than integer operations. More importantly, float values can contain a number of ”noise” bits. For example, common RGB color definitions use 256 distinct values for each of the Red, Green, and Blue components. These values are represented exactly with 8 bits. A floating-point variant, using values from 0.0 to 1.0, would use the full 64 bits for each color. Any arithmetic that led to floating-point truncation would introduce noise. While <span class="obeylines-h"><span class="verb"><code class="inlineCode">float</code></span></span> values seem simple, they introduce troubling problems.</p>&#13;
<p>Here’s an example, using a red <span class="obeylines-h"><span class="verb"><code class="inlineCode">r=15</code></span></span>:</p>&#13;
<div id="tcolobox-211" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; r = 15 &#13;
&gt;&gt;&gt; r_f = 15/256 &#13;
&gt;&gt;&gt; r_f &#13;
0.05859375 &#13;
&gt;&gt;&gt; r_f + 1/100 - 1/100 &#13;
0.05859374999999999</code></pre>&#13;
&#13;
</div>&#13;
<p>Algebraically, <span class="italic">r</span><sub><span class="cmmi-8">f</span></sub> + <img src="../Images/file85.jpg" class="frac" data-align="middle" alt="1100"/> <span class="cmsy-10x-x-109">−</span><img src="../Images/file86.jpg" class="frac" data-align="middle" alt="1100-"/> = <span class="italic">r</span><sub><span class="cmmi-8">f</span></sub>. However, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">float</code></span></span> definition is only an approximation of the abstract concept of a real number. The value of <img src="../Images/file87.jpg" class="frac" data-align="middle" alt="-1- 100"/> doesn’t have an exact representation in binary-based floating-point. Using a value like this introduces truncation errors that propagate through subsequent computations. We’ve chosen to use integer-based color matching to show a way to minimize the additional complications that can arise from floating-point values.</p>&#13;
<p>When looking at this idea of pre-computing all transformations<span id="dx1-204009"/> from source color to target color, we need some overall statistics for an arbitrary image. The code associated with this book includes <span class="obeylines-h"><span class="verb"><code class="inlineCode">IMG_2705.jpg</code></span></span>. Here is a basic algorithm to collect all of the distinct color tuples from the specified image:</p>&#13;
<pre id="listing-210" class="lstlisting"><code>from collections import defaultdict, Counter &#13;
def gather_colors() -&gt; defaultdict[RGB, list[Point]]: &#13;
    img = Image.open("IMG_2705.jpg") &#13;
 &#13;
    palette = defaultdict(list) &#13;
    for xy, rgb in pixel_iter(img): &#13;
        palette[rgb].append(xy) &#13;
 &#13;
    w, h = img.size &#13;
    print(f"total pixels {w*h}") &#13;
    print(f"total colors {len(palette)}") &#13;
    return palette</code></pre>&#13;
<p>We collected all pixels of a given color into a list organized by color. From this, we’ll learn the following facts:</p>&#13;
<ul>&#13;
<li><p>The total number of pixels is 9,980,928. This fits the expectation for a 10-megapixel image.</p></li>&#13;
<li><p>The total number of colors is 210,303. If we try to compute the Euclidean distance between actual colors and the 133 target colors, we would do 27,970,299 calculations, which might take about 76 seconds.</p></li>&#13;
<li><p>If we use a less accurate representation, one with fewer bits, we can speed things up. We’ll call this ”masking” to remove some of the irrelevant least-significant bits. Using a 3-bit mask, <span class="obeylines-h"><span class="verb"><code class="inlineCode">0b11100000</code></span></span>, the total number of colors actually used is reduced to 214 out of a domain of 2<sup><span class="cmr-8">3</span></sup> <span class="cmsy-10x-x-109">× </span>2<sup><span class="cmr-8">3</span></sup> <span class="cmsy-10x-x-109">× </span>2<sup><span class="cmr-8">3</span></sup> = 512 possible colors.</p></li>&#13;
<li><p>Using a 4-bit mask, <span class="obeylines-h"><span class="verb"><code class="inlineCode">0b11110000</code></span></span>, 1,150 colors are actually used.</p></li>&#13;
<li><p>Using a 5-bit mask, <span class="obeylines-h"><span class="verb"><code class="inlineCode">0b11111000</code></span></span>, 5,845 colors are actually used.</p></li>&#13;
<li><p>Using a 6-bit mask, <span class="obeylines-h"><span class="verb"><code class="inlineCode">0b11111100</code></span></span>, 27,726 colors are actually used. The domain of possible colors swells to 2<sup><span class="cmr-8">6</span></sup> <span class="cmsy-10x-x-109">× </span>2<sup><span class="cmr-8">6</span></sup> <span class="cmsy-10x-x-109">× </span>2<sup><span class="cmr-8">6</span></sup> = 262<span class="italic">,</span>144.</p></li>&#13;
</ul>&#13;
<p>This gives us some insight into how we can rearrange the data structure, calculate the matching colors quickly, and then rebuild the image without doing a billion comparisons and avoiding any additional complications<span id="dx1-204022"/> from floating-point approximations. There are a number of changes required to avoid needless (and error-introducing) computations.</p>&#13;
<p>The core idea behind masking is to preserve the most significant bits of a value and eliminate the least significant bits. Consider a color with a red value of 200. We can use the Python <span class="obeylines-h"><span class="verb"><code class="inlineCode">bin()</code></span></span> function to see the binary representation of that value:</p>&#13;
<div id="tcolobox-212" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; bin(200) &#13;
’0b11001000’ &#13;
&gt;&gt;&gt; 200 &amp; 0b11100000 &#13;
192 &#13;
&gt;&gt;&gt; bin(192) &#13;
’0b11000000’</code></pre>&#13;
&#13;
</div>&#13;
<p>The computation of <span class="obeylines-h"><span class="verb"><code class="inlineCode">200</code><code class="inlineCode"> &amp;</code><code class="inlineCode"> 0b11100000</code></span></span> applied a mask to conceal the least significant 5 bits and preserve the most significant 3 bits. What remains after the mask is applied as a red value of 192.</p>&#13;
<p>We can apply mask values to the RGB three-tuple with the following command:</p>&#13;
<pre id="listing-211" class="lstlisting"><code>masked_color = tuple(map(lambda x: x &amp; 0b11100000, c))</code></pre>&#13;
<p>This will pick out the most significant<span id="dx1-204031"/> 3 bits of the red, green, and blue values of a color tuple by using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">&amp;</code></span></span> operator to select particular bits from an integer value. If we use this masked value instead of the original color to create a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Counter</code></span></span> object, we’ll see that the image only uses 214 distinct values after the mask is applied. This is fewer than half the theoretical number of colors. <span id="x1-204032r210"/></p>&#13;
<section id="rearranging-the-problem" class="level4 subsectionHead" data-number="0.13.3.1">&#13;
<h4 class="subsectionHead" data-number="0.13.3.1"><span class="titlemark">9.3.1 </span> <span id="x1-2050001"/>Rearranging the problem</h4>&#13;
<p>The naive use of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">product()</code></span></span> function to compare all pixels and all colors was a bad idea. There are 10 million pixels, but only 200,000 unique colors. When mapping the source colors to target colors, we only have to save 200,000 values in a simple map.</p>&#13;
<p>We’ll approach it as follows:</p>&#13;
<ol>&#13;
<li><div id="x1-205002x1">&#13;
<p>Compute the source-to-target color mapping. In this case, let’s use 3-bit color values as output. Each R, G, and B value comes from the eight values in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">range(0,</code><code class="inlineCode"> 256,</code><code class="inlineCode"> 32)</code></span></span> expression. We can use this expression to enumerate all the output colors:</p>&#13;
<pre id="listing-212" class="lstlisting"><code>product(range(0, 256, 32), range(0, 256, 32), range(0, 256, 32))</code></pre>&#13;
</div></li>&#13;
<li><div id="x1-205005x2">&#13;
<p>We can then compute the Euclidean distance to the nearest color in our source palette, doing just 68,096 calculations. This takes about 0.14 seconds. It’s done one time only and computes the 200,000 mappings.</p>&#13;
</div></li>&#13;
<li><div id="x1-205007x3">&#13;
<p>In one pass through the source image, we build a new image using the revised color table. In some cases, we can exploit the truncation of integer values. We can use an expression such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">(0b11100000&amp;r,</code><code class="inlineCode"> 0b11100000&amp;g,</code><code class="inlineCode"> 0b11100000&amp;b)</code></span></span> to remove the least significant bits of an image color. We’ll look at this additional reduction in computation later.</p>&#13;
</div></li>&#13;
</ol>&#13;
<p>This will replace a billion distance calculations with 10 million dictionary lookups, transforming a potential 30 minutes of calculation into about 30 seconds.</p>&#13;
<p>Given a source palette of approximately 200,000 colors, we can apply a fast Manhattan distance to locate the nearest color in a target palette, such as the Crayola colors.</p>&#13;
<p>We’ll fold in yet another optimization—truncation. This will give us an even faster algorithm. <span id="x1-205008r212"/></p>&#13;
</section>&#13;
<section id="combining-two-transformations" class="level4 subsectionHead" data-number="0.13.3.2">&#13;
<h4 class="subsectionHead" data-number="0.13.3.2"><span class="titlemark">9.3.2 </span> <span id="x1-2060002"/>Combining two transformations</h4>&#13;
<p>When combining multiple<span id="dx1-206001"/> transformations, we can build a more complex mapping from the source through intermediate targets to the result. To illustrate this, we’ll truncate the colors as well as applying a mapping.</p>&#13;
<p>In some problem contexts, truncation can be difficult. In other cases, it’s often quite simple. For example, truncating US postal ZIP codes from nine to five characters is common. Postal codes can be further truncated to three characters to determine a regional facility that represents a larger geography.</p>&#13;
<p>For colors, we can use the bit-masking shown previously to truncate colors from three 8-bit values (24 bits, 16 million colors) to three 3-bit values (9 bits, 512 colors).</p>&#13;
<p>Here is a way to build a color map that combines distances to a given set of colors and truncation of the source colors:</p>&#13;
<pre id="listing-213" class="lstlisting"><code>from collections.abc import Sequence &#13;
def make_color_map(colors: Sequence[Color]) -&gt; dict[RGB, Color]: &#13;
    bit3 = range(0, 256, 0b0010_0000) &#13;
 &#13;
    best_iter = ( &#13;
        min((euclidean(rgb, c), rgb, c) for c in colors) &#13;
        for rgb in product(bit3, bit3, bit3) &#13;
    ) &#13;
    color_map = dict((b[1], b[2]) for b in best_iter) &#13;
    return color_map</code></pre>&#13;
<p>We created a range object, <span class="obeylines-h"><span class="verb"><code class="inlineCode">bit3</code></span></span>, that will iterate through all eight of the 3-bit color values. The use of the binary value, <span class="obeylines-h"><span class="verb"><code class="inlineCode">0b0010_0000</code></span></span>, can help visualize the way the bits are being used. The least significant 5 bits will be ignored; only the upper 3 bits will be used.</p>&#13;
<div id="tcolobox-213" class="packt_tip">&#13;
&#13;
&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">range</code></span></span> objects aren’t like ordinary iterators; they can be used multiple times. As a result of this, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">product(bit3,</code><code class="inlineCode"> bit3,</code><code class="inlineCode"> bit3)</code></span></span> expression will produce all 512 color combinations that we’ll use as the output colors.</p>&#13;
&#13;
</div>&#13;
<p>For each truncated RGB color, we created a three-tuple that has (0) the distance from all crayon colors, (1) the RGB color, and (2) the crayon <span class="obeylines-h"><span class="verb"><code class="inlineCode">Color</code></span></span> object. When we ask for the minimum value of this collection, we’ll get the closest crayon <span class="obeylines-h"><span class="verb"><code class="inlineCode">Color</code></span></span> object to the truncated RGB color.</p>&#13;
<p>We built a dictionary<span id="dx1-206012"/> that maps from the truncated RGB color to the closest crayon. In order to use this mapping, we’ll truncate a source color before looking up the nearest crayon in the mapping. This use of truncation coupled with the pre-computed mapping shows how we might need to combine mapping techniques.</p>&#13;
<p>The following function will build a new image from a color map:</p>&#13;
<pre id="listing-214" class="lstlisting"><code>def clone_picture( &#13;
    color_map: dict[RGB, Color], &#13;
    filename: str = "IMG_2705.jpg" &#13;
) -&gt; None: &#13;
    mask = 0b1110_0000 &#13;
    img = Image.open(filename) &#13;
    clone = img.copy() &#13;
    for xy, rgb in pixel_iter(img): &#13;
        r, g, b = rgb &#13;
        repl = color_map[(mask &amp; r, mask &amp; g, mask &amp; b)] &#13;
        clone.putpixel(xy, repl.rgb) &#13;
    clone.show()</code></pre>&#13;
<p>This uses the PIL <span class="obeylines-h"><span class="verb"><code class="inlineCode">putpixel()</code></span></span> function to replace all of the pixels in a picture with other pixels. The mask value preserves the upper-most three bits of each color, reducing the number of colors to a subset.</p>&#13;
<p>What we’ve seen is that the naive use of some functional programming tools can lead to algorithms that are expressive<span id="dx1-206025"/> and succinct, but also inefficient. The essential tools to compute the complexity of a calculation (sometimes called <span class="keyWord">Big-O analysis</span>) is just as important for functional programming as it is for imperative programming.</p>&#13;
<p>The problem is not that the <span class="obeylines-h"><span class="verb"><code class="inlineCode">product()</code></span></span> function is inefficient. The problem is that we can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">product()</code></span></span> function to create an inefficient algorithm. <span id="x1-206026r211"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="permuting-a-collection-of-values" class="level3 sectionHead" data-number="0.13.4">&#13;
<h3 class="sectionHead" data-number="0.13.4"><span class="titlemark">9.4 </span> <span id="x1-2070004"/>Permuting a collection of values</h3>&#13;
<p>When we permute a collection of values, we’ll generate all the possible orders for the values in the collection. There are <span class="italic">n</span>! permutations of <span class="italic">n </span>items. We can use a sequence of permutations<span id="dx1-207001"/> as a kind of brute-force solution to a variety of optimization problems.</p>&#13;
<p>Typical combinatorial optimization problems are the <span class="keyWord">Traveling Salesman</span> <span class="keyWord">problem</span>, the <span class="keyWord">Minimum Spanning Tree problem</span>, and the <span class="keyWord">Knapsack</span> <span class="keyWord">problem</span>. These problems are famous because they involve potentially vast numbers of permutations. Approximate solutions are necessary to avoid exhaustive enumeration of all permutations. The use of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools.permutations()</code></span></span> function is only handy for exploring very small problems.</p>&#13;
<p>One popular example of these combinatorial optimization<span id="dx1-207002"/> problems is the <span class="keyWord">assignment problem</span>. We have <span class="italic">n </span>agents and <span class="italic">n </span>tasks, but the cost of each agent performing a given task is not equal. Imagine that some agents have trouble with some details, while other agents excel at these details. If we can properly assign tasks to agents, we can minimize the costs.</p>&#13;
<p>We can create a simple grid that shows how well a given agent is able to perform a given task. For a small problem of seven agents and tasks, there will be a grid of 49 costs. Each cell in the grid shows agents <span class="italic">A</span><sub><span class="cmr-8">0</span></sub> to <span class="italic">A</span><sub><span class="cmr-8">6</span></sub> performing tasks <span class="italic">T</span><sub><span class="cmr-8">0</span></sub> to <span class="italic">T</span><sub><span class="cmr-8">6</span></sub>:</p>&#13;
<div class="center">&#13;
<div class="tabular">&#13;
&#13;
</div>&#13;
</div>&#13;
<div class="multicolumn" style="white-space:nowrap; text-align:center;">&#13;
Agent&#13;
</div>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<p>Task</p>&#13;
<p><span class="italic">A</span><sub><span class="cmr-8">0</span></sub></p>&#13;
<p><span class="italic">A</span><sub><span class="cmr-8">1</span></sub></p>&#13;
<p><span class="italic">A</span><sub><span class="cmr-8">2</span></sub></p>&#13;
<p><span class="italic">A</span><sub><span class="cmr-8">3</span></sub></p>&#13;
<p><span class="italic">A</span><sub><span class="cmr-8">4</span></sub></p>&#13;
<p><span class="italic">A</span><sub><span class="cmr-8">5</span></sub></p>&#13;
<p><span class="italic">A</span><sub><span class="cmr-8">6</span></sub></p>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<p><span class="italic">T</span><sub><span class="cmr-8">0</span></sub></p>&#13;
<p>14</p>&#13;
<p>11</p>&#13;
<p>6</p>&#13;
<p>20</p>&#13;
<p>12</p>&#13;
<p>9</p>&#13;
<p>4</p>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<p><span class="italic">T</span><sub><span class="cmr-8">1</span></sub></p>&#13;
<p>15</p>&#13;
<p>28</p>&#13;
<p>34</p>&#13;
<p>4</p>&#13;
<p>12</p>&#13;
<p>24</p>&#13;
<p>21</p>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<p><span class="italic">T</span><sub><span class="cmr-8">2</span></sub></p>&#13;
<p>16</p>&#13;
<p>31</p>&#13;
<p>22</p>&#13;
<p>18</p>&#13;
<p>31</p>&#13;
<p>15</p>&#13;
<p>23</p>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<p><span class="italic">T</span><sub><span class="cmr-8">3</span></sub></p>&#13;
<p>20</p>&#13;
<p>18</p>&#13;
<p>9</p>&#13;
<p>15</p>&#13;
<p>30</p>&#13;
<p>4</p>&#13;
<p>18</p>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<p><span class="italic">T</span><sub><span class="cmr-8">4</span></sub></p>&#13;
<p>24</p>&#13;
<p>8</p>&#13;
<p>24</p>&#13;
<p>30</p>&#13;
<p>28</p>&#13;
<p>25</p>&#13;
<p>4</p>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<p><span class="italic">T</span><sub><span class="cmr-8">5</span></sub></p>&#13;
<p>3</p>&#13;
<p>23</p>&#13;
<p>22</p>&#13;
<p>11</p>&#13;
<p>5</p>&#13;
<p>30</p>&#13;
<p>5</p>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<p><span class="italic">T</span><sub><span class="cmr-8">6</span></sub></p>&#13;
<p>13</p>&#13;
<p>7</p>&#13;
<p>5</p>&#13;
<p>10</p>&#13;
<p>7</p>&#13;
<p>7</p>&#13;
<p>32</p>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<hr/>&#13;
<p>Given this grid, we can enumerate all the possible permutations<span id="dx1-207003"/> of agents and their tasks. However, this approach doesn’t scale well. For this problem, there are 720 alternatives. If we have more agents, for example 10, the value of 10! is 3,628,800. We can create the entire sequence of 3 million items with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">list(permutations(range(10)))</code></span></span> expression.</p>&#13;
<p>We would expect to solve a problem of this tiny size in a fraction of a second. For 10!, we might take a few seconds. When we double the size of the problem to 20!, we have a bit of a scalability problem: there will be 2<span class="italic">.</span>433 <span class="cmsy-10x-x-109">× </span>10<sup><span class="cmr-8">18</span></sup> permutations. On a computer where it takes about 0.56 seconds to generate 10! permutations, the process of generating 20! permutations would take about 12,000 years.</p>&#13;
<p>We can formulate the exhaustive search for the optimal solution as follows:</p>&#13;
<pre id="listing-215" class="lstlisting"><code>from itertools import permutations &#13;
 &#13;
def assignment(cost: list[tuple[int, ...]]) -&gt; list[tuple[int, ...]]: &#13;
    n_tasks = len(cost) &#13;
    perms = permutations(range(n_tasks)) &#13;
    alt = [ &#13;
        ( &#13;
            sum( &#13;
                cost[task][agent] for agent, task in enumerate(perm) &#13;
            ), &#13;
            perm &#13;
        ) &#13;
        for perm in perms &#13;
    ] &#13;
    m = min(alt)[0] &#13;
    return [ans for s, ans in alt if s == m]</code></pre>&#13;
<p>We’ve created all permutations of tasks for a group of agents and assigned this to <span class="obeylines-h"><span class="verb"><code class="inlineCode">perms</code></span></span>. From this, we’ve created two-tuples of the sum of all costs in the cost matrix for a given permutation. To locate the relevant costs, a specific permutation is enumerated to create two-tuples showing the agent and the task assignment for that agent. For example, one of the permutations<span id="dx1-207020"/> is tasks <span class="obeylines-h"><span class="verb"><code class="inlineCode">(2,</code><code class="inlineCode"> 4,</code><code class="inlineCode"> 6,</code><code class="inlineCode"> 1,</code><code class="inlineCode"> 5,</code><code class="inlineCode"> 3,</code><code class="inlineCode"> 0)</code></span></span>. We can assign agent index values using the expression <span class="lstinline"><span style="color:#000000"><code class="inlineCode">list</code></span><span style="color:#000000"><code class="inlineCode">(</code></span><span style="color:#000000"><code class="inlineCode">enumerate</code></span><span style="color:#000000"><code class="inlineCode">((2,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">4,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">6,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">1,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">5,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">3,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">0)</code></span><span style="color:#000000"><code class="inlineCode">)</code></span><span style="color:#000000"><code class="inlineCode">)</code></span></span>. The result, <span class="obeylines-h"><span class="verb"><code class="inlineCode">[(0,</code><code class="inlineCode"> 2),</code><code class="inlineCode"> (1,</code><code class="inlineCode"> 4),</code><code class="inlineCode"> (2,</code><code class="inlineCode"> 6),</code><code class="inlineCode"> (3,</code><code class="inlineCode"> 1),</code><code class="inlineCode"> (4,</code><code class="inlineCode"> 5),</code><code class="inlineCode"> (5,</code><code class="inlineCode"> 3),</code><code class="inlineCode"> (6,</code><code class="inlineCode"> 0)]</code></span></span>, has all seven agent index values and their associated task assignments. We can translate the index numbers to agent names and task names by incorporating a dictionary lookup. The sum of the values in the cost matrix tells us how expensive this specific task assignment would be.</p>&#13;
<p>One of the optimal solutions might look like the assignment above. It requires folding in the agent names and task names to translate the task permutation into a specific list of assignments:</p>&#13;
<div class="center">&#13;
<div class="tabular">&#13;
<table id="TBL-5" class="tabular">&#13;
<tbody>&#13;
<tr class="odd hline">&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-5-1-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-5-1-1" class="td11" style="text-align: center; white-space: nowrap;"><span class="italic">A</span><sub><span class="cmr-8">0</span></sub></td>&#13;
<td id="TBL-5-1-2" class="td11" style="text-align: center; white-space: nowrap;"><span class="italic">T</span><sub><span class="cmr-8">2</span></sub></td>&#13;
</tr>&#13;
<tr class="odd hline">&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-5-2-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-5-2-1" class="td11" style="text-align: center; white-space: nowrap;"><span class="italic">A</span><sub><span class="cmr-8">1</span></sub></td>&#13;
<td id="TBL-5-2-2" class="td11" style="text-align: center; white-space: nowrap;"><span class="italic">T</span><sub><span class="cmr-8">4</span></sub></td>&#13;
</tr>&#13;
<tr class="odd hline">&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-5-3-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-5-3-1" class="td11" style="text-align: center; white-space: nowrap;"><span class="italic">A</span><sub><span class="cmr-8">2</span></sub></td>&#13;
<td id="TBL-5-3-2" class="td11" style="text-align: center; white-space: nowrap;"><span class="italic">T</span><sub><span class="cmr-8">6</span></sub></td>&#13;
</tr>&#13;
<tr class="odd hline">&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-5-4-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-5-4-1" class="td11" style="text-align: center; white-space: nowrap;"><span class="italic">A</span><sub><span class="cmr-8">3</span></sub></td>&#13;
<td id="TBL-5-4-2" class="td11" style="text-align: center; white-space: nowrap;"><span class="italic">T</span><sub><span class="cmr-8">1</span></sub></td>&#13;
</tr>&#13;
<tr class="odd hline">&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-5-5-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-5-5-1" class="td11" style="text-align: center; white-space: nowrap;"><span class="italic">A</span><sub><span class="cmr-8">4</span></sub></td>&#13;
<td id="TBL-5-5-2" class="td11" style="text-align: center; white-space: nowrap;"><span class="italic">T</span><sub><span class="cmr-8">5</span></sub></td>&#13;
</tr>&#13;
<tr class="odd hline">&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-5-6-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-5-6-1" class="td11" style="text-align: center; white-space: nowrap;"><span class="italic">A</span><sub><span class="cmr-8">5</span></sub></td>&#13;
<td id="TBL-5-6-2" class="td11" style="text-align: center; white-space: nowrap;"><span class="italic">T</span><sub><span class="cmr-8">3</span></sub></td>&#13;
</tr>&#13;
<tr class="odd hline">&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-5-7-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-5-7-1" class="td11" style="text-align: center; white-space: nowrap;"><span class="italic">A</span><sub><span class="cmr-8">6</span></sub></td>&#13;
<td id="TBL-5-7-2" class="td11" style="text-align: center; white-space: nowrap;"><span class="italic">T</span><sub><span class="cmr-8">0</span></sub></td>&#13;
</tr>&#13;
<tr class="odd hline">&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-5-8-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-5-8-1" class="td11" style="text-align: center; white-space: nowrap;"/>&#13;
<td/>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div>&#13;
</div>&#13;
<p>In some cases, there might be multiple optimal solutions; this algorithm will locate all of them. The expression <span class="obeylines-h"><span class="verb"><code class="inlineCode">min(alt)[0]</code></span></span> selects the first of the set of minima.</p>&#13;
<p>For small textbook examples, this seems to be reasonably fast. There are linear programming approaches which avoid exhaustive enumeration of all permutations. The Python Linear Programming module PuLP can be used to solve the assignment problem. See <a href="https://coin-or.github.io/pulp/" class="url">https://coin-or.github.io/pulp/</a>. <span id="x1-207021r214"/></p>&#13;
</section>&#13;
<section id="generating-all-combinations" class="level3 sectionHead" data-number="0.13.5">&#13;
<h3 class="sectionHead" data-number="0.13.5"><span class="titlemark">9.5 </span> <span id="x1-2080005"/>Generating all combinations</h3>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> module also supports computing all combinations of a set of values. When looking at combinations, the order doesn’t matter, so there are far fewer combinations than permutations. The number of combinations<span id="dx1-208001"/> is often stated as <img src="../Images/file88.jpg" alt="(p) r"/> = <img src="../Images/file89.jpg" class="frac" data-align="middle" alt="--p!-- r!(p− r)!"/>. This is the number of ways that we can take combinations of <span class="italic">r </span>things at a time from a universe of <span class="italic">p </span>items overall.</p>&#13;
<p>For example, there are 2,598,960 five-card poker hands. We can actually enumerate all 2 million hands by executing the following command:</p>&#13;
<pre id="listing-216" class="lstlisting"><code>&gt;&gt;&gt; from itertools import combinations, product &#13;
 &#13;
&gt;&gt;&gt; hands = list( &#13;
...     combinations( &#13;
...         tuple( &#13;
...             product(range(13), ’♠♡♢♣’) &#13;
...         ), 5 &#13;
...     ) &#13;
... )</code></pre>&#13;
<p>More practically, assume we have a dataset with a number of variables. A common exploratory technique is to determine the correlation among all pairs of variables in a set of data. If there are <span class="italic">v </span>variables, then we will enumerate all variables that must be compared by executing the following command:</p>&#13;
<div id="tcolobox-214" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; combinations(range(v), 2)</code></pre>&#13;
&#13;
</div>&#13;
<p>A fun source of data for simple statistical analysis is the <span class="keyWord">Spurious</span> <span class="keyWord">Correlations </span>site. This has a great many datasets with surprising statistical properties. Let’s get some sample data from <span class="keyWord">Spurious Correlations</span>, <a href="http://www.tylervigen.com" class="url">http://www.tylervigen.com</a>, to show how this will work. We’ll pick three datasets with the same time range, datasets numbered 7, 43, and 3,890. We’ll simply catenate the data into a grid. Because the source data repeats the <span class="obeylines-h"><span class="verb"><code class="inlineCode">year</code></span></span> column, we’ll start with data that includes the repeated <span class="obeylines-h"><span class="verb"><code class="inlineCode">year</code></span></span> column. We’ll eventually remove the obvious redundancy, but it’s often best to start with all of the data present as a way to confirm that the various sources of data align with each other properly.</p>&#13;
<p>This is how the first and the remaining<span id="dx1-208013"/> rows of the yearly data will look:</p>&#13;
<div id="tcolobox-215" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>[(’year’, ’Per capita consumption of cheese (US)Pounds (USDA)’, &#13;
’Number of people who died by becoming tangled in their &#13;
bedsheets Deaths (US) (CDC)’, &#13;
’year’, ’Per capita consumption of mozzarella cheese (US)Pounds &#13;
(USDA)’, ’Civil engineering doctorates awarded (US) Degrees awarded &#13;
(National Science Foundation)’, &#13;
’year’, ’US crude oil imports from Venezuela Millions of barrels &#13;
(Dept. of Energy)’, ’Per capita consumption of high fructose corn &#13;
syrup (US) Pounds (USDA)’), &#13;
 &#13;
(2000, 29.8, 327, 2000, 9.3, 480, 2000, 446, 62.6), &#13;
(2001, 30.1, 456, 2001, 9.7, 501, 2001, 471, 62.5), &#13;
(2002, 30.5, 509, 2002, 9.7, 540, 2002, 438, 62.8), &#13;
(2003, 30.6, 497, 2003, 9.7, 552, 2003, 436, 60.9), &#13;
(2004, 31.3, 596, 2004, 9.9, 547, 2004, 473, 59.8), &#13;
(2005, 31.7, 573, 2005, 10.2, 622, 2005, 449, 59.1), &#13;
(2006, 32.6, 661, 2006, 10.5, 655, 2006, 416, 58.2), &#13;
(2007, 33.1, 741, 2007, 11, 701, 2007, 420, 56.1), &#13;
(2008, 32.7, 809, 2008, 10.6, 712, 2008, 381, 53), &#13;
(2009, 32.8, 717, 2009, 10.6, 708, 2009, 352, 50.1)]</code></pre>&#13;
&#13;
</div>&#13;
<p>This is how we can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">combinations()</code></span></span> function to yield all the combinations of the nine variables in this dataset, taken two at a time:</p>&#13;
<div id="tcolobox-216" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; combinations(range(9), 2)</code></pre>&#13;
&#13;
</div>&#13;
<p>There are 36 possible combinations. We’ll have to reject the combinations that involve matching columns <span class="obeylines-h"><span class="verb"><code class="inlineCode">year</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">year</code></span></span>. These will trivially correlate with a value of 1.00.</p>&#13;
<p>Here is a function that picks a column of data out of our dataset:</p>&#13;
<pre id="listing-217" class="lstlisting"><code>from typing import TypeVar &#13;
from collections.abc import Iterator, Iterable &#13;
T = TypeVar("T") &#13;
 &#13;
def column(source: Iterable[list[T]], x: int) -&gt; Iterator[T]: &#13;
    for row in source: &#13;
        yield row[x]</code></pre>&#13;
<p>This allows us to use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">corr()</code></span></span> function from <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with</span> <span class="cmti-10x-x-109">Collections</span></a>, to compute the correlation between the two columns of data.</p>&#13;
<p>This is how we can compute all combinations<span id="dx1-208044"/> of correlations:</p>&#13;
<pre id="listing-218" class="lstlisting"><code>from collections.abc import Iterator &#13;
from itertools import * &#13;
from Chapter04.ch04_ex4 import corr &#13;
 &#13;
def multi_corr( &#13;
        source: list[list[float]] &#13;
    ) -&gt; Iterator[tuple[float, float, float]]: &#13;
    n = len(source[0]) &#13;
    for p, q in combinations(range(n), 2): &#13;
        header_p, *data_p = list(column(source, p)) &#13;
        header_q, *data_q = list(column(source, q)) &#13;
        if header_p == header_q: &#13;
            continue &#13;
        r_pq = corr(data_p, data_q) &#13;
        yield header_p, header_q, r_pq</code></pre>&#13;
<p>For each combination of columns, we’ve extracted the two columns of data from our dataset. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">header_p,</code><code class="inlineCode"> *data_p</code><code class="inlineCode"> =...</code></span></span> statement uses multiple assignments to separate the first item in the sequence, the header, from the remaining rows of data. If the headers match, we’re comparing a variable to itself. This will be <span class="obeylines-h"><span class="verb"><code class="inlineCode">True</code></span></span> for the three combinations of year and year that stem from the redundant year columns.</p>&#13;
<p>Given a combination<span id="dx1-208060"/> of columns, we will compute the correlation function and then print the two headings along with the correlation of the columns. We’ve intentionally chosen two datasets that show spurious correlations with a third dataset that does not follow the same pattern as closely. In spite of this, the correlations are remarkably high.</p>&#13;
<p>The results look like this:</p>&#13;
<div id="tcolobox-217" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>0.96: year vs Per capita consumption of cheese (US) Pounds (USDA) &#13;
 &#13;
0.95: year vs Number of people who died by becoming tangled in their &#13;
bedsheets Deaths (US) (CDC) &#13;
 &#13;
0.92: year vs Per capita consumption of mozzarella cheese (US) Pounds &#13;
(USDA) &#13;
 &#13;
0.98: year vs Civil engineering doctorates awarded (US) Degrees awarded &#13;
(National Science Foundation) &#13;
 &#13;
-0.80: year vs US crude oil imports from Venezuela Millions of barrels &#13;
(Dept. of Energy) &#13;
 &#13;
-0.95: year vs Per capita consumption of high fructose corn syrup (US) &#13;
Pounds (USDA) &#13;
 &#13;
0.95: Per capita consumption of cheese (US) Pounds (USDA) vs Number of &#13;
people who died by becoming tangled in their bedsheets Deaths (US) (CDC) &#13;
 &#13;
0.96: Per capita consumption of cheese (US)Pounds (USDA) vs year &#13;
 &#13;
0.98: Per capita consumption of cheese (US)Pounds (USDA) vs Per capita &#13;
consumption of mozzarella cheese (US)Pounds (USDA) &#13;
 &#13;
... &#13;
 &#13;
0.88: US crude oil imports from Venezuela Millions of barrels (Dept. of &#13;
Energy) vs Per capita consumption of high fructose corn syrup (US)Pounds &#13;
(USDA)</code></pre>&#13;
&#13;
</div>&#13;
<p>It’s not at all clear what this pattern means. Why do these values correlate? The presence of spurious correlations with no significance can cloud statistical analysis. We’ve located data that has strangely high correlations with no obvious causal factors.</p>&#13;
<p>What’s important is that a simple expression, <span class="obeylines-h"><span class="verb"><code class="inlineCode">combinations(range(9),</code><code class="inlineCode"> 2)</code></span></span>, enumerates all the possible combinations of data. This kind of succinct, expressive technique makes it easier to focus on the data analysis issues instead of the combinatoric<span id="dx1-208092"/> algorithm considerations. <span id="x1-208093r213"/></p>&#13;
<section id="combinations-with-replacement" class="level4 subsectionHead" data-number="0.13.5.1">&#13;
<h4 class="subsectionHead" data-number="0.13.5.1"><span class="titlemark">9.5.1 </span> <span id="x1-2090001"/>Combinations with replacement</h4>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> library has two functions for generating combinations<span id="dx1-209001"/> of items selected from some set of values. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">combinations()</code></span></span> function reflects our expectations when dealing hands from a deck of cards: each card will appear at most once. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">combinations_with_</code></span></span> <span class="obeylines-h"><span class="verb"><code class="inlineCode">replacement()</code></span></span> function reflects the idea of taking a card from a deck, writing it down, and then shuffling it back into the deck before selecting another card. This second procedure could potentially yield a five-card sample with five aces of spades.</p>&#13;
<p>We can see this more clearly by using the following kind of expression:</p>&#13;
<div id="tcolobox-218" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; import itertools &#13;
&gt;&gt;&gt; from pprint import pprint &#13;
&gt;&gt;&gt; pprint( &#13;
... list(itertools.combinations([1,2,3,4,5,6], 2)) &#13;
... ) &#13;
[(1, 2), &#13;
 (1, 3), &#13;
 (1, 4), &#13;
... &#13;
 (4, 6), &#13;
 (5, 6)] &#13;
&gt;&gt;&gt; pprint( &#13;
... list(itertools.combinations_with_replacement([1,2,3,4,5,6], 2)) &#13;
... ) &#13;
[(1, 1), &#13;
 (1, 2), &#13;
 (1, 3), &#13;
... &#13;
 (5, 5), &#13;
 (5, 6), &#13;
 (6, 6)]</code></pre>&#13;
&#13;
</div>&#13;
<p>There are <img src="../Images/file90.jpg" alt="(6) 2"/> = 15 combinations of six things taken two at a time. There are 6<sup><span class="cmr-8">2</span></sup> = 36 combinations<span id="dx1-209026"/> when replacement is permitted, since any value is a possible member of the result. <span id="x1-209027r215"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="recipes" class="level3 sectionHead" data-number="0.13.6">&#13;
<h3 class="sectionHead" data-number="0.13.6"><span class="titlemark">9.6 </span> <span id="x1-2100006"/>Recipes</h3>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> chapter of the Python library documentation is outstanding. The basic definitions are followed by a series of recipes that are extremely clear and helpful. Since there’s no reason to reproduce these, we’ll reference them here. They are required reading materials on functional programming in Python.</p>&#13;
<p>The <span class="cmti-10x-x-109">Itertools Recipes </span>section in the <span class="cmti-10x-x-109">Python Standard Library </span>is a wonderful resource. Visit <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes">https://docs.python.org/3/library/itertools.html#itertools-recipes</a> for more details.</p>&#13;
<p>These function definitions aren’t importable functions in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> modules. These are ideas that need to be read and understood and then, perhaps, copied or modified before inclusion in an application.</p>&#13;
<p>The following table summarizes some recipes that show functional programming algorithms built from the itertools basics: <span id="x1-210001r1"/></p>&#13;
<div class="longtable">&#13;
<table id="TBL-6" class="longtable">&#13;
<tbody>&#13;
<tr id="TBL-6-1-" class="odd" style="vertical-align:baseline;">&#13;
<td colspan="3" id="TBL-6-1-1" class="td11" style="text-align: left; white-space: normal;"><span class="cmidrule"/></td>&#13;
</tr>&#13;
<tr id="TBL-6-2-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-6-2-1" class="td11" style="text-align: left; white-space: normal;"><p><span class="keyWord">Function Name</span></p>&#13;
</td>&#13;
<td id="TBL-6-2-2" class="td11" style="text-align: left; white-space: normal;"><p><span class="keyWord">Arguments</span></p>&#13;
</td>&#13;
<td id="TBL-6-2-3" class="td11" style="text-align: left; white-space: normal;"><p><span class="keyWord">Results</span></p>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-6-3-" class="odd" style="vertical-align:baseline;">&#13;
<td colspan="3" id="TBL-6-3-1" class="td11" style="text-align: left; white-space: normal;"><span class="cmidrule"/></td>&#13;
</tr>&#13;
<tr id="TBL-6-4-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-6-4-1" class="td11" style="text-align: left; white-space: normal;"/>&#13;
<td style="text-align: left;"/>&#13;
<td style="text-align: left;"/>&#13;
</tr>&#13;
<tr id="TBL-6-5-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-6-5-1" class="td11" style="text-align: left; white-space: normal;"/>&#13;
<td id="TBL-6-5-2" class="td11" style="text-align: left; white-space: normal;"/>&#13;
<td id="TBL-6-5-3" class="td11" style="text-align: left; white-space: normal;"/>&#13;
</tr>&#13;
<tr id="TBL-6-6-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-6-6-1" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">powerset</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-6-6-2" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">(iterable)</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-6-6-3" class="td11" style="text-align: left; white-space: normal;"><p>Generate all the subsets of the iterable. Each subset is a tuple object, not a set instance.</p>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-6-7-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-6-7-1" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">random\_product</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-6-7-2" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">(*args,</code><code class="inlineCode"> repeat=1)</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-6-7-3" class="td11" style="text-align: left; white-space: normal;"><p>Randomly select from <span class="obeylines-h"><span class="verb"><code class="inlineCode">product()</code></span></span>.</p>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-6-8-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-6-8-1" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">random\_permutation</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-6-8-2" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">(iterable,</code><code class="inlineCode"> r=None)</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-6-8-3" class="td11" style="text-align: left; white-space: normal;"><p>Randomly select from <span class="obeylines-h"><span class="verb"><code class="inlineCode">permutations()</code></span></span>.</p>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-6-9-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-6-9-1" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">random\_combination</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-6-9-2" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">(iterable,</code><code class="inlineCode"> r)</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-6-9-3" class="td11" style="text-align: left; white-space: normal;"><p>Randomly select from <span class="obeylines-h"><span class="verb"><code class="inlineCode">combinations()</code></span></span>.</p>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-6-10-" class="even" style="vertical-align:baseline;">&#13;
<td colspan="3" id="TBL-6-10-1" class="td11" style="text-align: left; white-space: normal;"><span class="cmidrule"/></td>&#13;
</tr>&#13;
<tr id="TBL-6-11-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-6-11-1" class="td11" style="text-align: left; white-space: normal;"/>&#13;
<td style="text-align: left;"/>&#13;
<td style="text-align: left;"/>&#13;
</tr>&#13;
<tr id="TBL-6-12-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-6-12-1" class="td11" style="text-align: left; white-space: normal;"/>&#13;
<td style="text-align: left;"/>&#13;
<td style="text-align: left;"/>&#13;
</tr>&#13;
<tr id="TBL-6-13-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-6-13-1" class="td11" style="text-align: left; white-space: normal;"/>&#13;
<td style="text-align: left;"/>&#13;
<td style="text-align: left;"/>&#13;
</tr>&#13;
<tr id="TBL-6-14-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-6-14-1" class="td11" style="text-align: left; white-space: normal;"/>&#13;
<td style="text-align: left;"/>&#13;
<td style="text-align: left;"/>&#13;
</tr>&#13;
<tr id="TBL-6-15-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-6-15-1" class="td11" style="text-align: left; white-space: normal;"/>&#13;
<td style="text-align: left;"/>&#13;
<td style="text-align: left;"/>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div>&#13;
<p><span id="x1-210002r217"/></p>&#13;
</section>&#13;
<section id="summary-8" class="level3 sectionHead" data-number="0.13.7">&#13;
<h3 class="sectionHead" data-number="0.13.7"><span class="titlemark">9.7 </span> <span id="x1-2110007"/>Summary</h3>&#13;
<p>In this chapter, we looked at a number of functions in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> module. This standard library module provides a number of functions that help us work with iterators in sophisticated ways.</p>&#13;
<p>We looked at these combination-producing functions:</p>&#13;
<ul>&#13;
<li><p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">product()</code></span></span> function computes all the possible combinations of the elements chosen from two or more collections.</p></li>&#13;
<li><p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">permutations()</code></span></span> function gives us different ways to reorder a given set of values.</p></li>&#13;
<li><p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">combinations()</code></span></span> function returns all the possible subsets of an original set.</p></li>&#13;
</ul>&#13;
<p>We also looked at ways in which the <span class="obeylines-h"><span class="verb"><code class="inlineCode">product()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">permutations()</code></span></span> functions can be used naively to create extremely large result sets. This is an important cautionary note. A succinct and expressive algorithm can also involve a vast amount of computation. We must perform basic complexity analysis to be sure that the code will finish in a reasonable amount of time.</p>&#13;
<p>In the next chapter, we’ll look at the <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools</code></span></span> module. This module includes some tools to work with functions as first-class objects. This builds on some material shown in <a href="Chapter_02.xhtml#x1-340002"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 2</span></a>, <a href="Chapter_02.xhtml#x1-340002"><span class="cmti-10x-x-109">Introducing Essential Functional Concepts</span></a>, and <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 5</span></a>, <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Higher-Order Functions</span></a>. <span id="x1-211001r218"/></p>&#13;
</section>&#13;
<section id="exercises-8" class="level3 sectionHead" data-number="0.13.8">&#13;
<h3 class="sectionHead" data-number="0.13.8"><span class="titlemark">9.8 </span> <span id="x1-2120008"/>Exercises</h3>&#13;
<p>This chapter’s exercises are based on code available from Packt Publishing on GitHub. See <a href="https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition" class="url">https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition</a>.</p>&#13;
<p>In some cases, the reader will notice that the code provided on GitHub includes partial solutions to some of the exercises. These serve as hints, allowing the reader to explore alternative solutions.</p>&#13;
<p>In many cases, exercises will need unit test cases to confirm they actually solve the problem. These are often identical to the unit test cases already provided in the GitHub repository. The reader should replace the book’s example function name with their own solution to confirm that it works. <span id="x1-212001r216"/></p>&#13;
<section id="alternative-distance-computations" class="level4 subsectionHead" data-number="0.13.8.1">&#13;
<h4 class="subsectionHead" data-number="0.13.8.1"><span class="titlemark">9.8.1 </span> <span id="x1-2130001"/>Alternative distance computations</h4>&#13;
<p>See <span class="cmti-10x-x-109">Effects of Distance Measure Choice on KNN Classifier Performance - A</span> <span class="cmti-10x-x-109">Review</span>. This is available at <a href="https://arxiv.org/pdf/1708.04321" class="url">https://arxiv.org/pdf/1708.04321</a>. In this paper, dozens of distance metrics are examined for their utility in implementing the <span class="cmbxti-10x-x-109">k</span><span class="keyWord">-Nearest Neighbors </span>(<span class="cmbxti-10x-x-109">k</span><span class="keyWord">-NN</span>) classifier.</p>&#13;
<p>Some of these are also suitable for the color-matching algorithm presented in this chapter. We defined a color, <span class="italic">c</span>, a three-tuple, (<span class="italic">r,g,b</span>), based on the Red, Green, and Blue components of the color. We can compute the distance between two colors, <span class="italic">D</span>(<span class="italic">c</span><sub><span class="cmr-8">1</span></sub><span class="italic">,c</span><sub><span class="cmr-8">2</span></sub>), based on their RGB components:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file91.jpg" class="math-display" alt=" ( ) D (c1,c2) = D (r1,g1,b1),(r2,g2,b2) "/>&#13;
</div>&#13;
<p>We showed two: Euclidean and Manhattan distances. Here are some more formal definitions:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file92.jpg" class="math-display" alt=" ∘ -------2-----------2----------2- ED = (r1 − r2) + (g1 − g2) + (b1 − b2) "/>&#13;
</div>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file93.jpg" class="math-display" alt="M D = |r1 − r2|+ |g1 − g2|+ |b1 − b2| "/>&#13;
</div>&#13;
<p>Some additional examples include these:</p>&#13;
<ul>&#13;
<li><p><span class="keyWord">The Chebyshev Distance </span>(<span class="keyWord">CD</span>) is the maximum of the absolute values of each color difference:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file94.jpg" class="math-display" alt="CD = max (|r1 − r2|,|g1 − g2|,|b1 − b2|) "/>&#13;
</div></li>&#13;
<li><p>The <span class="keyWord">Sorensen Distance </span>(<span class="keyWord">SD</span>) is a modification of the Manhattan distance that tends to normalize the distance:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file95.jpg" class="math-display" alt=" |r1 −-r2|+-|g1 −-g2|+-|b1 −-b2| SD = r1 + r2 + g1 + g2 + b1 + b2 "/>&#13;
</div></li>&#13;
</ul>&#13;
<p>Redefine the <span class="obeylines-h"><span class="verb"><code class="inlineCode">make_color_map()</code></span></span> function to be a higher-order function that will accept a distance function as a parameter. All of the distance functions should have a type hint of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable[[RGB,</code><code class="inlineCode"> Color],</code><code class="inlineCode"> float]</code></span></span>. Once the <span class="obeylines-h"><span class="verb"><code class="inlineCode">make_color_map()</code></span></span> function has been changed, it becomes possible to create alternative color maps with alternative distance functions.</p>&#13;
<p>This function creates a mapping from ”masked” RGB values to a defined set of colors. Using a 3-bit mask defines a mapping from 2<sup><span class="cmr-8">3</span></sup> <span class="cmsy-10x-x-109">× </span>2<sup><span class="cmr-8">3</span></sup> <span class="cmsy-10x-x-109">× </span>2<sup><span class="cmr-8">3</span></sup> = 512 possible RGB values to the domain of 133 colors.</p>&#13;
<p>The function’s definition should look like this:</p>&#13;
<pre id="listing-219" class="lstlisting"><code>def make_color_map(colors: Sequence[Color], distance: Callable[[RGB, Color], float]) -&gt; dict[RGB, Color]:</code></pre>&#13;
<p>How much difference does the choice of distance function make? How can we characterize the mapping from the large collection of possible RGB values to the limited domain of subset colors? Is a histogram showing how many distinct RGB values map to a subset color sensible and informative? <span id="x1-213002r220"/></p>&#13;
</section>&#13;
<section id="actual-domain-of-pixel-color-values" class="level4 subsectionHead" data-number="0.13.8.2">&#13;
<h4 class="subsectionHead" data-number="0.13.8.2"><span class="titlemark">9.8.2 </span> <span id="x1-2140002"/>Actual domain of pixel color values</h4>&#13;
<p>When creating a color map, a mask was used to reduce the domain of possible colors from 2<sup><span class="cmr-8">8</span></sup> <span class="cmsy-10x-x-109">× </span>2<sup><span class="cmr-8">8</span></sup> <span class="cmsy-10x-x-109">× </span>2<sup><span class="cmr-8">8</span></sup> = 16<span class="italic">,</span>777<span class="italic">,</span>216 to a more manageable 2<sup><span class="cmr-8">3</span></sup> <span class="cmsy-10x-x-109">× </span>2<sup><span class="cmr-8">3</span></sup> <span class="cmsy-10x-x-109">× </span>2<sup><span class="cmr-8">3</span></sup> = 512 possible values.</p>&#13;
<p>Does it make sense to scan the original image using the mask value to determine the actual domain of available colors? A given image, may, for example, have only 210 distinct colors when a 3-bit mask is used. How much additional time is required to create this summary of colors actually in use?</p>&#13;
<p>Can the color summary be further optimized? Could we, for example, exclude rarely used colors? If we do exclude these rarely used colors, how do we replace a pixel’s color with more commonly used colors? What changes in an image if we use the color of the majority of the neighboring pixels to replace pixels with rarely used colors?</p>&#13;
<p>Consider an algorithm that makes the following two passes over an image’s pixels:</p>&#13;
<ol>&#13;
<li><div id="x1-214002x1">&#13;
<p>Create a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Counter</code></span></span> with the frequency of each color.</p>&#13;
</div></li>&#13;
<li><div id="x1-214004x2">&#13;
<p>For colors with fewer than some threshold, <span class="italic">𝜖</span>, locate the neighboring pixels. In a corner, there may be as few as three. In the middle, there will be no more than eight. Find the color of the majority of those pixels and replace the outlier.</p>&#13;
</div></li>&#13;
</ol>&#13;
<div class="algorithm">&#13;
<figure>&#13;
<img src="../Images/Algo_9.1.JPG" class="math" data-align="middle" alt="Algorithm 8: Imperative iteration "/>&#13;
<figcaption aria-hidden="true"><span class="id">Algorithm 8: </span><span class="content">Imperative iteration </span></figcaption>&#13;
</figure>&#13;
</div>&#13;
&#13;
<p>Before starting on this algorithm, it’s important to consider any ”edge” cases. Specifically, there is a potential complication when rarely used colors are adjacent.</p>&#13;
<p>Consider this case:</p>&#13;
<div class="center">&#13;
<div class="tabular">&#13;
<table id="TBL-7" class="tabular">&#13;
<tbody>&#13;
<tr class="odd hline">&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-7-1-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-7-1-1" class="td11" style="text-align: center; white-space: nowrap;"><span class="italic">p</span><sub><span class="cmr-8">(0</span><span class="cmmi-8">,</span><span class="cmr-8">0)</span></sub></td>&#13;
<td id="TBL-7-1-2" class="td11" style="text-align: center; white-space: nowrap;"><span class="italic">p</span><sub><span class="cmr-8">(1</span><span class="cmmi-8">,</span><span class="cmr-8">0)</span></sub></td>&#13;
<td id="TBL-7-1-3" class="td11" style="text-align: center; white-space: nowrap;"><span class="italic">p</span><sub><span class="cmr-8">(2</span><span class="cmmi-8">,</span><span class="cmr-8">0)</span></sub></td>&#13;
</tr>&#13;
<tr class="odd hline">&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-7-2-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-7-2-1" class="td11" style="text-align: center; white-space: nowrap;"><span class="italic">p</span><sub><span class="cmr-8">(0</span><span class="cmmi-8">,</span><span class="cmr-8">1)</span></sub></td>&#13;
<td id="TBL-7-2-2" class="td11" style="text-align: center; white-space: nowrap;"><span class="italic">p</span><sub><span class="cmr-8">(1</span><span class="cmmi-8">,</span><span class="cmr-8">1)</span></sub></td>&#13;
<td id="TBL-7-2-3" class="td11" style="text-align: center; white-space: nowrap;"><span class="italic">p</span><sub><span class="cmr-8">(2</span><span class="cmmi-8">,</span><span class="cmr-8">1)</span></sub></td>&#13;
</tr>&#13;
<tr class="odd hline">&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-7-3-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-7-3-1" class="td11" style="text-align: center; white-space: nowrap;"><span class="italic">p</span><sub><span class="cmr-8">(0</span><span class="cmmi-8">,</span><span class="cmr-8">2)</span></sub></td>&#13;
<td id="TBL-7-3-2" class="td11" style="text-align: center; white-space: nowrap;"><span class="italic">p</span><sub><span class="cmr-8">(1</span><span class="cmmi-8">,</span><span class="cmr-8">2)</span></sub></td>&#13;
<td id="TBL-7-3-3" class="td11" style="text-align: center; white-space: nowrap;"><span class="italic">p</span><sub><span class="cmr-8">(2</span><span class="cmmi-8">,</span><span class="cmr-8">2)</span></sub></td>&#13;
</tr>&#13;
<tr class="odd hline">&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-7-4-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-7-4-1" class="td11" style="text-align: center; white-space: nowrap;"/>&#13;
<td/>&#13;
<td/>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div>&#13;
</div>&#13;
<p>If the four pixels in the top-left corner, <span class="italic">p</span><sub><span class="cmr-8">(0</span><span class="cmmi-8">,</span><span class="cmr-8">0)</span></sub>, <span class="italic">p</span><sub><span class="cmr-8">(1</span><span class="cmmi-8">,</span><span class="cmr-8">0)</span></sub>, <span class="italic">p</span><sub><span class="cmr-8">(0</span><span class="cmmi-8">,</span><span class="cmr-8">1)</span></sub>, and <span class="italic">p</span><sub><span class="cmr-8">(1</span><span class="cmmi-8">,</span><span class="cmr-8">1)</span></sub>, all had rarely used colors, then it would be difficult to pick a majority color to replace <span class="italic">p</span><sub><span class="cmr-8">(0</span><span class="cmmi-8">,</span><span class="cmr-8">0)</span></sub>.</p>&#13;
<p>In the case where there are no non-rare colors surrounding a pixel with a rare color, the algorithm would need to queue this up for later resolution after the neighbors have been processed. In this example, the color for pixel <span class="italic">p</span><sub><span class="cmr-8">(1</span><span class="cmmi-8">,</span><span class="cmr-8">0)</span></sub> can be computed using neighbors that are not rare colors. After <span class="italic">p</span><sub><span class="cmr-8">(0</span><span class="cmmi-8">,</span><span class="cmr-8">1)</span></sub> and <span class="italic">p</span><sub><span class="cmr-8">(1</span><span class="cmmi-8">,</span><span class="cmr-8">1)</span></sub> are also resolved, then <span class="italic">p</span><sub><span class="cmr-8">(0</span><span class="cmmi-8">,</span><span class="cmr-8">0)</span></sub> can be replaced with the majority color of the three neighbors.</p>&#13;
<p>Is this algorithmic complexity helpful for a picture with 10 million pixels? Choosing one or a few photos arbitrarily isn’t a sophisticated survey. However, it can help to avoid overthinking potential problems.</p>&#13;
<p>Survey the colors in a collection of images. How common is it to see a single pixel with a unique color? If you don’t have a private collection of images, visit <a href="https://kaggle.com" class="url">kaggle.com</a> to look for image datasets that can be examined. <span id="x1-214007r221"/></p>&#13;
</section>&#13;
<section id="cribbage-hand-scoring" class="level4 subsectionHead" data-number="0.13.8.3">&#13;
<h4 class="subsectionHead" data-number="0.13.8.3"><span class="titlemark">9.8.3 </span> <span id="x1-2150003"/>Cribbage hand scoring</h4>&#13;
<p>The card game of cribbage involves a phase where a player’s hand is evaluated. A player will use four cards that are dealt to them, plus a fifth card, called the starter.</p>&#13;
<p>To avoid overusing the word ”points,” we’ll consider each card to have a number of pips. Each face card is counted as having 10 pips; all other cards have a number of pips equal to their rank. Aces have a single pip.</p>&#13;
<p>The scoring involves the following combinations of cards:</p>&#13;
<ul>&#13;
<li><p>Any combination of cards that totals 15 pips adds 2 points to the score.</p></li>&#13;
<li><p>Pairs – two cards of the same rank – add 2 points to the score.</p></li>&#13;
<li><p>Any run of three, four, or five cards adds 3, 4, or 5 points to the score.</p></li>&#13;
<li><p>A flush of four cards in a hand adds 4 points to the score. If the starter card is of the same suit, then the flush, as a whole, is 5 points.</p></li>&#13;
<li><p>If a jack in a hand has the same suit as the starter card, this adds 1 point to the score.</p></li>&#13;
</ul>&#13;
<p>If a hand contains three cards of the same rank, this is counted as three separate pairs, worth 6 points in aggregate.</p>&#13;
<p>An interesting hand involves runs with a pair. For example, a hand 7C, 7D, 8H, and 9S, with an irrelevant starter card of a Queen, has two runs—7C, 8H, 9S, and 7D, 8H, 9S—and a pair of 7’s. This is a total of 8 points. Furthermore, there are two combinations that add to 15: 7C, 8H and 7D, 8H, bringing the hand’s value to 12 points.</p>&#13;
<p>Note that a 4-card run is <span class="cmti-10x-x-109">not </span>counted as two overlapping 3-card runs. It’s only worth 4 points.</p>&#13;
<p>Another interesting example is holding 4C, 5D, 5H, 6S, and the starter card is 3C. There are two distinct runs of 4 cards: 3C, 4C, 5D, 6S, and 3C, 4C, 5H, 6S, as well a pair of 5s, leading to 10 points for this pattern. Additionally, there are two distinct ways to count 15 pips: 4C, 5D, 6S and 4C, 5H, 6S, adding 4 more points to the score.</p>&#13;
<p>A handy algorithm for this is to enumerate several combinations and permutations of cards to locate all the scoring. The following rules can be applied:</p>&#13;
<ol>&#13;
<li><div id="x1-215002x1">&#13;
<p>Iterate over the powerset of the cards. This is the set of all subsets: all of the singletons, all of the pairs, all of the triples, etc., up to the set of all five cards. Each of these is a distinct set, some of which will tally to 15 pips. For more information on generating the powerset, see the <span class="cmti-10x-x-109">Itertools Recipes </span>section of the Python Standard Library documentation.</p>&#13;
</div></li>&#13;
<li><div id="x1-215004x2">&#13;
<p>Enumerate all pairs of cards to compute scores for any pairs. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">combinations()</code></span></span> function works well for this.</p>&#13;
</div></li>&#13;
<li><div id="x1-215006x3">&#13;
<p>For sets of five cards, if they’re adjacent, ascending values, this is a run. If they’re not adjacent, ascending values, then enumerate the sets of four-card runs to see if either of these have adjacent numbers. Failing that test, enumerate all sets of three-card runs to see if any of these have adjacent numbers. The longest run applies to the score, and shorter runs are ignored.</p>&#13;
</div></li>&#13;
<li><div id="x1-215008x4">&#13;
<p>Check the hand and starter for a five-flush. If there’s no five-flush, check the hand only for a four-flush. Only one of these two combinations is scored.</p>&#13;
</div></li>&#13;
<li><div id="x1-215010x5">&#13;
<p>Also, check to see if the hand has a jack of the same suit as the starter.</p>&#13;
</div></li>&#13;
</ol>&#13;
<p>Since there are only five cards involved in this, the number of permutations and combinations is rather small. Be prepared to summarize exactly how many combinations and permutations are required for a five-card hand.</p>&#13;
</section>&#13;
</section>&#13;
<section id="join-our-community-discord-space-9" class="level3 likesectionHead" data-number="0.13.9">&#13;
<h3 class="likesectionHead" data-number="0.13.9"><span id="x1-2160003"/>Join our community Discord space</h3>&#13;
<p>Join our Python Discord workspace to discuss and know more about the book: <a href="https://packt.link/dHrHU">https://packt.link/dHrHU</a></p>&#13;
<p><img src="../Images/file1.png" alt="PIC" width="85" height="85"/></p>&#13;
<p><span id="x1-216001r206"/></p>&#13;
</section>&#13;
</section>&#13;
</body></html>