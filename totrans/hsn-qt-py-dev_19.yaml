- en: Threading and Multiprocessing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程和进程池
- en: As we have seen throughout this book, if we keep on adding new functionalities
    to our GUI application, we will have some problems, such as the application freezing,
    operation speed dropping, problems with simultaneous execution, and many more
    uncomfortable cases. These are the problems that occur in any multi-functional
    application. In our own experience, when we use Microsoft Office, design tools,
    or other software that uses a lot of memory resources, we encounter various waits,
    freezes, and so on. If we add to the functionality of the app that we are creating,
    at some stage, the app will become slow (in the best case) and will be not as
    functional as we want it to be. Why does this happen? In most cases, almost every
    operating system details the processes and threads of execution. We can open the
    Task Manager of our operating system and see that various programs are running
    as processes (tasks). They have **process IDs** (**PIDs**), names, and so on.
    These applications (processes) operate with some internal tasks and usually have
    threads of execution from additional operations. They can also operate with external
    tasks, that is, independent processes. These processes can contain multiple threads
    that execute tasks concurrently. When our created application is running in one
    process and as one thread and the app has a lot of tasks, the available memory
    resources may be not enough to run them all. The solution to this problem is to
    split tasks into different threads and maybe into different processes if need
    be. This chapter will introduce these aspects of GUI creation. We will explore
    Qt library instruments such as `QProcess` and `QThread`. We will also demonstrate
    Python standard library tools that can easily be implemented in the GUI. We will
    also examine the advantages and disadvantages of these instruments.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在整本书中看到的那样，如果我们继续向我们的GUI应用程序添加新功能，我们将会遇到一些问题，例如应用程序冻结、操作速度下降、同时执行的问题以及许多其他不舒适的情况。这些问题在任何多功能应用程序中都会出现。根据我们自己的经验，当我们使用微软办公软件、设计工具或其他占用大量内存资源的软件时，我们会遇到各种等待、冻结等情况。如果我们向正在创建的应用程序的功能中添加内容，在某个阶段，应用程序将变得缓慢（在最好的情况下），并且可能不会像我们希望的那样功能齐全。为什么会这样呢？在大多数情况下，几乎每个操作系统都详细说明了执行进程和线程。我们可以打开我们操作系统的任务管理器，看到各种程序作为进程（任务）运行。它们有**进程ID**（**PID**）、名称等等。这些应用程序（进程）使用一些内部任务，并且通常有执行额外操作的线程。它们也可以使用外部任务，即独立进程。这些进程可以包含多个线程，它们可以并发执行任务。当我们的应用程序在一个进程中以一个线程运行，并且有很多任务时，可用的内存资源可能不足以运行它们。解决这个问题的方法是将任务分割成不同的线程，如果需要的话，还可以分割成不同的进程。本章将介绍GUI创建的这些方面。我们将探索Qt库工具，例如`QProcess`和`QThread`。我们还将演示可以轻松实现于GUI中的Python标准库工具。我们还将检查这些工具的优点和缺点。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Processes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程
- en: Threads
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程
- en: Locks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁
- en: Python standard library tools
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 标准库工具
- en: Processes
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程
- en: Processes (in computing) are the main part of any environment. In a broad sense,
    a process is an instance of a program that executes the application. It can have
    more than one process for operating tasks and usually includes multiple threads.
    If only a single CPU is used, only one process can be executed at any one time.
    However, if the CPU has multiple cores, the execution of tasks can be split between
    these cores. However, this doesn't mean that a multi-core architecture concurrently
    executes all processes/tasks that operate. In reality, the system multitasks,
    which means that when new tasks start, they can interrupt tasks that have already
    started, they can be interrupted by new tasks, and they can be started again.
    In this way, the execution of the processes is split into the segments that operate
    concurrently. A common situation is when the main program has a single parent
    process and the child processes are executed in parallel. Communication between
    processes usually occurs by using the input channel (stream of data) `STDIN` (standard
    input) and two predefined output channels (separate streams of data) – `STDOUT`
    (standard output) and `STDERR` (standard error), in this case. The channels of
    the process are also known as the **read** (`STDOUT` and `STDERR`) and **write**
    (`STDIN`) channels. One of the ways that the Qt library runs new processes and
    implements **Inter-Process Communication** (**IPC**) in applications is by using
    the `QProcess` class. This class allows us to manage an application's external
    processes. `QProcess` is a cross-platform class that's available in the `QtCore`
    module of the Qt library. In an application, it can be used to start external
    programs as child processes and communicate with them, depending on the operating
    tasks. This mechanism is an API that controls and monitors the states of the child
    processes. The `QProcess` class also provides access to the I/O (input/output)
    channels of child processes by inheriting from the **`QtCore.QIODevice`** class.
    A simple example of these operations is running a third-party application that
    implements additional functionality, such as opening a web browser or running
    servers. It also can be used for long-term tasks, including loops and estimation.
    However, the `QProcess` class does not support some platforms, such as iOS. Therefore,
    the application can use Python standard library tools such as the `subprocess` module
    and the multiprocessing package.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算中，进程是任何环境的主要部分。从广义上讲，进程是程序的实例，它执行应用程序。它可以有多个进程来执行操作任务，通常包括多个线程。如果只使用单个CPU，则任何时刻只能执行一个进程。然而，如果CPU有多个核心，任务的执行可以在这些核心之间分配。但这并不意味着多核架构会并发执行所有操作进程/任务。实际上，系统是多任务的，这意味着当新任务开始时，它们可以中断已经启动的任务，可以被新任务中断，并且可以再次启动。这样，进程的执行被分割成并发操作的段。一个常见的情况是主程序有一个父进程，子进程并行执行。进程之间的通信通常是通过使用输入通道（数据流）`STDIN`（标准输入）和两个预定义的输出通道（分离的数据流）——`STDOUT`（标准输出）和`STDERR`（标准错误）来进行的。进程的通道也被称为**读**（`STDOUT`和`STDERR`）和**写**（`STDIN`）通道。Qt库运行新进程并在应用程序中实现**进程间通信**（**IPC**）的一种方式是通过使用`QProcess`类。这个类允许我们管理应用程序的外部进程。`QProcess`是一个跨平台类，它在Qt库的`QtCore`模块中可用。在应用程序中，它可以用来启动外部程序作为子进程，并根据操作任务与它们通信。这种机制是一个API，用于控制和监控子进程的状态。`QProcess`类还通过继承**`QtCore.QIODevice`**类提供了对子进程的I/O（输入/输出）通道的访问。这些操作的简单示例是运行实现附加功能（如打开网页或运行服务器）的第三方应用程序。它也可以用于长期任务，包括循环和估计。然而，`QProcess`类不支持某些平台，例如iOS。因此，应用程序可以使用Python标准库工具，如`subprocess`模块和`multiprocessing`包。
- en: Application processes
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序流程
- en: 'To understand application processes that occur when we create and run GUI or
    non-GUI applications, we need to know about the Qt modules and the inheritance
    scheme of the classes that participate in the application''s processes. The `QCoreApplication`
    class of the `QtCore` module inherits from the `QObject` class and creates the
    event loop of non-GUI applications. The `QGuiApplication` class of the `QtGui`
    module inherits `QCoreApplication` and manages the control flow with the main
    settings of the GUI app. The `QApplication` class of the `QtWidgets` module inherits
    `QGuiApplication` and manages the control flow with the main settings of the GUI
    application relative to the `QWidget` class, based on additional functionality.
    To access the application object, you can use global pointers:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解在创建和运行 GUI 或非 GUI 应用程序时发生的应用程序进程，我们需要了解 Qt 模块以及参与应用程序进程的类的继承方案。`QtCore` 模块中的
    `QCoreApplication` 类继承自 `QObject` 类，并为非 GUI 应用程序创建事件循环。`QtGui` 模块中的 `QGuiApplication`
    类继承自 `QCoreApplication`，并使用 GUI 应用程序的主要设置管理控制流。`QtWidgets` 模块中的 `QApplication`
    类继承自 `QGuiApplication`，并基于附加功能，使用 GUI 应用程序相对于 `QWidget` 类的主要设置管理控制流。要访问应用程序对象，您可以使用全局指针：
- en: '`QtCore.QCoreApplication.instance()`: For `QCoreApplication`, `QGuiApplication`,
    and `QApplication`.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QCoreApplication.instance()`：用于 `QCoreApplication`、`QGuiApplication`
    和 `QApplication`。'
- en: '`QtGui.QGuiApplication.qGuiApp`: For `QGuiApplication`.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtGui.QGuiApplication.qGuiApp`：用于 `QGuiApplication`。'
- en: '`QtWidgets.QApplication.qApp`: For `QApplication`.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtWidgets.QApplication.qApp`：用于 `QApplication`。'
- en: 'In the application, long-term tasks (loops) can also be used with the `processEvents()`
    static method of the `QCoreApplication` class. The creation of long-term operations
    usually looks like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，可以使用 `QCoreApplication` 类的 `processEvents()` 静态方法与长期任务（循环）一起使用。长期操作通常如下所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This `while` instruction is infinite and will print the string until it is stopped
    by pressing *Ctrl* + *Z*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `while` 指令是无限循环的，并将打印字符串，直到通过按 *Ctrl* + *Z* 停止。
- en: QProcess
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QProcess
- en: 'This class provides Qt library instruments that you can use when working with
    processes in an application. Using this class starts external tasks (programs)
    in separate processes and organizes communication with them. The declaration syntax
    of this class is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此类提供了在应用程序中处理进程时可以使用的 Qt 库工具。使用此类在单独的进程中启动外部任务（程序），并组织与它们的通信。此类的声明语法如下：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`QProcess` inherits from `QIODevice`, which is the base interface class of
    all I/O devices in the Qt library, and improves functionality with the following
    functions.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`QProcess` 继承自 `QIODevice`，它是 Qt 库中所有 I/O 设备的基接口类，并通过以下功能增强了功能。'
- en: set
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: set
- en: 'These functions set the parameters/properties of the process:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数设置进程的参数/属性：
- en: '`process.setArguments([str])`: This sets the arguments, specified in the parameter,
    for the called program when this process starts.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.setArguments([str])`：此操作为在进程启动时调用的程序设置指定的参数。'
- en: '`process.setEnvironment(["environment"])`: This sets the environment, specified
    in the parameter, that will be used with this process.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.setEnvironment(["environment"])`：此操作为该进程设置指定的环境，该环境将与该进程一起使用。'
- en: '`process.setInputChannelMode(QtCore.QProcess.InputChannelMode)`: This sets
    the channel mode, specified in the parameter, for the `STDIN` of this process.
    The available input channel modes are as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.setInputChannelMode(QtCore.QProcess.InputChannelMode)`：此操作为该进程的 `STDIN`
    设置指定的参数中的通道模式。可用的输入通道模式如下：'
- en: '**`QtCore.QProcess.ManagedInputChannel`**—`0`: This process manages the input
    of the running process.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`QtCore.QProcess.ManagedInputChannel`**—`0`：此进程管理运行进程的输入。'
- en: '**`QtCore.QProcess.ForwardedInputChannel`**—`1`: This process forwards the
    input of the main process onto the running process.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`QtCore.QProcess.ForwardedInputChannel`**—`1`：此进程将主进程的输入转发到运行进程。'
- en: '`process.setProcessChannelMode(QtCore.QProcess.ProcessChannelMode)`: This sets
    the channel mode, specified in the parameter, for the `STDOUT` (standard output)
    of this process. The available process channel modes are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.setProcessChannelMode(QtCore.QProcess.ProcessChannelMode)`：此操作为该进程的
    `STDOUT`（标准输出）设置指定的参数中的通道模式。可用的进程通道模式如下：'
- en: '`QtCore.QProcess.SeparateChannels`—`0`: `STDOUT` and `STDERR` data in separate
    internal buffers.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QProcess.SeparateChannels`—`0`：`STDOUT` 和 `STDERR` 数据在单独的内部缓冲区中。'
- en: '`QtCore.QProcess.MergedChannels`—`1`: This merges the output of the process
    into the `STDOUT` (standard output) channel.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QProcess.MergedChannels`—`1`：此操作将进程的输出合并到 `STDOUT`（标准输出）通道。'
- en: '`QtCore.QProcess.ForwardedChannels`—`2`: This forwards the output of the process
    to the main process.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QProcess.ForwardedChannels`—`2`: 这将进程的输出转发到主进程。'
- en: '`QtCore.QProcess.ForwardedErrorChannel`—`4`: This forwards the `STDERR` (standard
    error) to the main process.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QProcess.ForwardedErrorChannel`—`4`: 这将 `STDERR`（标准错误）转发到主进程。'
- en: '`process.setProcessEnvironment(QtCore.QProcessEnvironment)`: This sets the
    environment, specified in the parameter, that will be used with this process.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.setProcessEnvironment(QtCore.QProcessEnvironment)`: 这将设置由参数指定的环境，该环境将用于此进程。'
- en: '`process.setProcessState(QtCore.QProcess.ProcessState)`: This sets the process
    state, specified in the parameter, of this process. The available states are as
    follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.setProcessState(QtCore.QProcess.ProcessState)`: 这将此进程的状态设置为参数中指定的状态。可用状态如下：'
- en: '`QtCore.QProcess.NotRunning`—`0`: This process is not running.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QProcess.NotRunning`—`0`: 此进程未运行。'
- en: '`QtCore.QProcess.Starting`—`1`: This process is starting, but the program that
    the process operates hasn''t been invoked yet.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QProcess.Starting`—`1`: 此进程正在启动，但该进程所操作的程序尚未被调用。'
- en: '`QtCore.QProcess.Running`—`2`: This process is running and ready.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QProcess.Running`—`2`: 此进程正在运行且准备就绪。'
- en: '`process.setProgram("program")`: This sets the program, specified in the parameter,
    that will be started in this process.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`process.setProgram("program")`: 这将设置由参数指定的程序，该程序将在此进程中启动。'
- en: '`process.setReadChannel(QtCore.QProcess.ProcessChannel)`: This sets the channel,
    specified in the parameter, for this process. The available process channels are
    as follows:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`process.setReadChannel(QtCore.QProcess.ProcessChannel)`: 这将为此进程设置参数中指定的通道。可用的进程通道如下：'
- en: '`QtCore.QProcess.StandardOutput`—`0`: The `STDOUT` (standard output) of the
    process.'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QProcess.StandardOutput`—`0`: 进程的 `STDOUT`（标准输出）。'
- en: '`QtCore.QProcess.StandardError`—`1`: The `STDERR` (standard error) of the process.'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QProcess.StandardError`—`1`: 进程的 `STDERR`（标准错误）。'
- en: '`process.setStandardErrorFile("path/to/the/filename", QtCore.QIODevice.OpenMode)`:
    This redirects the `STDERR` (standard error) to the file (the first parameter)
    relative to the file mode (the second parameter).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.setStandardErrorFile("path/to/the/filename", QtCore.QIODevice.OpenMode)`:
    这将 `STDERR`（标准错误）重定向到文件（第一个参数），相对于文件模式（第二个参数）。'
- en: '`process.setStandardInputFile("path/to/the/filename")`: This redirects the
    `STDIN` (standard input) to the file specified in the parameter.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.setStandardInputFile("path/to/the/filename")`: 这将 `STDIN`（标准输入）重定向到参数指定的文件。'
- en: '`process.setStandardOutputFile("path/to/the/filename", QtCore.QIODevice.OpenMode)`:
    This redirects the `STDOUT` (standard output) to the file (the first parameter)
    relative to the file mode (the second parameter).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.setStandardOutputFile("path/to/the/filename", QtCore.QIODevice.OpenMode)`:
    这将 `STDOUT`（标准输出）重定向到文件（第一个参数），相对于文件模式（第二个参数）。'
- en: '`process.setStandardOutputProcess(QtCore.QProcess)`: This pipes the `STDOUT`
    (standard output) stream of this process to the `STDIN` (standard input) of the
    process specified in the parameter.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.setStandardOutputProcess(QtCore.QProcess)`: 这将此进程的 `STDOUT`（标准输出）流管道连接到参数指定的进程的
    `STDIN`（标准输入）。'
- en: '`process.setWorkingDirectory("path/to/dir")`: This sets the working directory,
    specified in the parameter, where this process will be started.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.setWorkingDirectory("path/to/dir")`: 这将设置由参数指定的工作目录，在此进程中启动此进程。'
- en: is
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: is
- en: 'This function returns a Boolean value (`bool`) related to the process'' state:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回与进程状态相关的布尔值 (`bool`)：
- en: '`process.isSequential()`: This returns `True` if this process is sequential.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.isSequential()`: 如果此进程是顺序的，则返回 `True`。'
- en: functional
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: functional
- en: 'These functions relate to the current values of the process, changes in functionality,
    and so on:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数与进程的当前值、功能变化等相关：
- en: '`process.arguments()`: This returns the list of the most -recently started
    process'' command-line arguments.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.arguments()`: 这返回最近启动的进程的命令行参数列表。'
- en: '`process.atEnd()`: This returns `True` if this process is not running, and
    there is no more data to read.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.atEnd()`: 如果此进程未运行且没有更多数据可读，则返回 `True`。'
- en: '`process.bytesAvailable()`: This returns the bytes that are available for reading
    with this process.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.bytesAvailable()`: 这返回可用于读取的此进程的字节数。'
- en: '`process.bytesToWrite()`: This returns the bytes that are available for writing
    with this process.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.bytesToWrite()`: 这返回可用于写入的此进程的字节数。'
- en: '`process.canReadLine()`: This returns `True` if a complete line of data can
    be read with this process.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.canReadLine()`: 如果可以通过此进程读取完整的数据行，则返回 `True`。'
- en: '`process.close()`: This kills this process and closes all communications.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.close()`: 这将终止此进程并关闭所有通信。'
- en: '`process.closeReadChannel(QtCore.QProcess.ProcessChannel)`: This closes the
    read channel specified in the parameter.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.closeReadChannel(QtCore.QProcess.ProcessChannel)`: 这关闭指定的读取通道。'
- en: '`process.closeWriteChannel()`: This closes the channel once all the data has
    been written.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.closeWriteChannel()`: 这在所有数据都已写入后关闭通道。'
- en: '`process.environment()`: This returns the environment for this process.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.environment()`: 这返回此进程的环境。'
- en: '`process.error()`: This returns the last error that occurred of the `QtCore.QProcess.ProcessError`
    type. The available process errors are as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.error()`: 这返回最后一个发生的错误，类型为 `QtCore.QProcess.ProcessError`。可用的进程错误如下：'
- en: '`QtCore.QProcess.FailedToStart`—`0`: This process failed to start.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QProcess.FailedToStart`—`0`: 此进程启动失败。'
- en: '`QtCore.QProcess.Crashed`—`1`: This process crashed.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QProcess.Crashed`—`1`: 此进程崩溃。'
- en: '**`QtCore.QProcess.Timedout`**—`2`: This process timed out.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`QtCore.QProcess.Timedout`**—`2`: 此进程超时。'
- en: '`QtCore.QProcess.ReadError`—`3`: An error with reading from this process.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QProcess.ReadError`—`3`: 从此进程读取时出现错误。'
- en: '`QtCore.QProcess.WriteError`—`4`: An error with writing to this process.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QProcess.WriteError`—`4`: 向此进程写入时出现错误。'
- en: '`QtCore.QProcess.UnknownError`—`5`: An unknown error in this process.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QProcess.UnknownError`—`5`: 此进程中出现未知错误。'
- en: '`process.execute("command")`: This starts the command, specified in the parameter,
    in the new process.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.execute("command")`: 这将在新进程中启动由参数指定的命令。'
- en: '`process.execute("program", "arguments")`: This starts the program (the first
    parameter) with arguments (the second parameter) in the new process.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.execute("program", "arguments")`: 这将在新进程中以参数（第二个参数）启动程序（第一个参数）。'
- en: '`process.exitCode()`: This returns the last process exit code.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.exitCode()`: 这返回最后一个进程退出代码。'
- en: '`process.exitStatus()`: This returns the last process exit status of the **`QtCore.QProcess.ExitStatus`**
    type. The available exit statuses are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.exitStatus()`: 这返回最后一个进程退出状态，类型为 **`QtCore.QProcess.ExitStatus`**。可用的退出状态如下：'
- en: '`QtCore.QProcess.NormalExit`—`0`: This process exited normally.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QProcess.NormalExit`—`0`: 此进程正常退出。'
- en: '`QtCore.QProcess.CrashExit`—`1`: This process crashed.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QProcess.CrashExit`—`1`: 此进程崩溃。'
- en: '`process.inputChannelMode()`: This returns the channel mode of the `QtCore.QProcess.InputChannelMode`
    type for this process'' `STDIN` (standard input) channel.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.inputChannelMode()`: 这返回此进程 `STDIN` (标准输入) 通道的 `QtCore.QProcess.InputChannelMode`
    类型的通道模式。'
- en: '`process.kill()`: This kills this process and exits immediately.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.kill()`: 这将立即终止此进程并退出。'
- en: '`process.nullDevice()`: This is the null device of the operating system that''s
    used to discard the output streams of a process or empty files for input streams.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.nullDevice()`: 这是操作系统中的空设备，用于丢弃进程的输出流或空文件用于输入流。'
- en: '`process.open(QtCore.QIODevice.OpenMode)`: This opens the process with the
    mode specified in the parameter.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.open(QtCore.QIODevice.OpenMode)`: 这以参数指定的模式打开进程。'
- en: '`process.processChannelMode()`: This returns the channel mode of the `QtCore.QProcess.ProcessChannelMode`
    type for the standard output and standard error channels of this process.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.processChannelMode()`: 这返回此进程标准输出和标准错误通道的 `QtCore.QProcess.ProcessChannelMode`
    类型的通道模式。'
- en: '`process.processEnvironment()`: This returns the environment of the `QtCore.QProcessEnvironment`
    type for this process.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.processEnvironment()`: 这返回此进程的 `QtCore.QProcessEnvironment` 类型的环境。'
- en: '`process.processId()`: This returns the native ID for the running process.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.processId()`: 这返回运行进程的本地 ID。'
- en: '`process.program()`: This returns the last program that started with this process.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.program()`: 这返回与此进程一起启动的最后一个程序。'
- en: '`process.readAllStandardError()`: This returns all the error data of the `QtCore.QByteArray`
    type from the `STDERR` of this process.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.readAllStandardError()`: 这将从此进程的 `STDERR` 返回 `QtCore.QByteArray` 类型的所有错误数据。'
- en: '`process.readAllStandardOutput()`: This returns all the data of the `QtCore.QByteArray`
    type from the `STDOUT` of this process.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.readAllStandardOutput()`: 这将从此进程的 `STDOUT` 返回 `QtCore.QByteArray`
    类型的所有数据。'
- en: '`process.readChannel()`: This returns the read channel of the **`QtCore.QProcess.ProcessChannel`**
    type for this process.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.readChannel()`: 这返回此进程的 **`QtCore.QProcess.ProcessChannel`** 类型的读取通道。'
- en: '`process.readData(int)`: This reads the bytes limited to a maximum size, specified
    in the parameter, into data.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.readData(int)`: 这将读取限制在参数指定的最大大小的字节到数据中。'
- en: '`process.start(QtCore.QIODevice.OpenMode)`: This starts the program with the
    mode specified in the parameter in the new process.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.start(QtCore.QIODevice.OpenMode)`: 这将在新进程中以参数中指定的模式启动程序。'
- en: '`process.start("command", QtCore.QIODevice.OpenMode)`: This starts the command
    (the first parameter) with the mode (the second parameter) in the new process.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.start("command", QtCore.QIODevice.OpenMode)`: 这将在新进程中以模式（第二个参数）启动命令（第一个参数）。'
- en: '`process.start("program", ["arguments"], QtCore.QIODevice.OpenMode)`: This
    starts the program (the first parameter) with arguments (the second parameter)
    relative to the mode (the third parameter) in the new process.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.start("program", ["arguments"], QtCore.QIODevice.OpenMode)`: 这将在新进程中以相对于模式（第三个参数）的参数（第二个参数）启动程序（第一个参数）。'
- en: '`process.startDetached()`: This starts the program in the new process, then
    detaches from this process.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.startDetached()`: 这将在新进程中启动程序，然后从该进程中分离出来。'
- en: '`process.startDetached(int)`: This starts the program in the new process with
    the process ID specified in the parameter, then detaches from this process.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.startDetached(int)`: 这将在新进程中以参数中指定的进程 ID 启动程序，然后从该进程中分离出来。'
- en: '`process.startDetached("command")`: This starts the command specified in the
    parameter in the new process, then detaches from this process.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.startDetached("command")`: 这将在新进程中启动参数中指定的命令，然后从该进程中分离出来。'
- en: '`process.startDetached("program", ["arguments"])`: This starts the program
    (the first parameter) with arguments (the second parameter) in the new process,
    then detaches from this process.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.startDetached("program", ["arguments"])`: 这将在新进程中以参数（第二个参数）启动程序（第一个参数），然后从该进程中分离出来。'
- en: '`process.startDetached("program", ["arguments"], "path/to/dir")`: This starts
    the program (the first parameter) with arguments (the second parameter) and the
    working directory (the third parameter) in the new process, then detaches from
    this process.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.startDetached("program", ["arguments"], "path/to/dir")`: 这将在新进程中以参数（第二个参数）和工作目录（第三个参数）启动程序（第一个参数），然后从该进程中分离出来。'
- en: '`process.state()`: This returns the current state of the `QtCore.QProcess.ProcessState`
    type for this process.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.state()`: 这返回此进程的 `QtCore.QProcess.ProcessState` 类型的当前状态。'
- en: '`process.systemEnvironment()`: This returns the system environment for this
    process.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.systemEnvironment()`: 这返回此进程的系统环境。'
- en: '`process.terminate()`: This terminates the process.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.terminate()`: 这将终止进程。'
- en: '`process.waitForBytesWritten(int)`: This waits for the number of milliseconds
    specified in the parameter until a payload of buffered written bytes has been
    written.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.waitForBytesWritten(int)`: 这将等待参数中指定的毫秒数，直到已将缓冲写入的字节数据写入。'
- en: '`process.waitForFinished(int)`: This waits for the number of milliseconds specified
    in the parameter, blocking the process until this process has finished.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.waitForFinished(int)`: 这将等待参数中指定的毫秒数，直到此进程完成，阻塞进程。'
- en: '`process.waitForReadyRead(int)`: This waits for the number of milliseconds specified
    in the parameter, blocking the process until new data is available for reading.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.waitForReadyRead(int)`: 这将等待参数中指定的毫秒数，直到有新数据可供读取，阻塞进程。'
- en: '`process.waitForStarted(int)`: This waits for the number of milliseconds specified
    in the parameter, blocking the process until this process has started.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.waitForStarted(int)`: 这将等待参数中指定的毫秒数，直到此进程开始，阻塞进程。'
- en: '`process.workingDirectory()`: This returns the working directory that''s used
    for this process.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.workingDirectory()`: 这返回用于此进程的工作目录。'
- en: signals
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号
- en: 'The following signals are available with the `QProcess` class:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与 `QProcess` 类一起可用的信号：
- en: '`process.errorOccurred(QtCore.QProcess.ProcessError)`: This signal is emitted
    when an error occurs with this process, with the error passed in the parameter.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.errorOccurred(QtCore.QProcess.ProcessError)`: 当此进程发生错误时，会发出此信号，并将错误作为参数传递。'
- en: '`process.finished(int, QtCore.QProcess.ExitStatus)`: This signal is emitted
    when this process has finished, with the exit code and the exit status passed
    in the parameter.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.finished(int, QtCore.QProcess.ExitStatus)`: 当此进程完成时，会发出此信号，并将退出代码和退出状态作为参数传递。'
- en: '`process.readyReadStandardError()`: This signal is emitted when this process
    makes new data available on the `STDERR` channel.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.readyReadStandardError()`: 当此进程在 `STDERR` 通道上提供新数据时，会发出此信号。'
- en: '`process.readyReadStandardOutput()`: This signal is emitted when this process
    makes new data available on the `STDOUT` channel.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.readyReadStandardOutput()`: 当此进程在 `STDOUT` 通道上提供新数据时，会发出此信号。'
- en: '`process.started()`: This signal is emitted when this process starts.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.started()`: 当此进程开始时，会发出此信号。'
- en: '`process.stateChanged(QtCore.QProcess.ProcessState)`: This signal is emitted
    when the state of this process changes, with the new process state passed in the
    parameter.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.stateChanged(QtCore.QProcess.ProcessState)`: 当此进程的状态改变时，会发出此信号，并将新的进程状态作为参数传递。'
- en: QProcessEnvironment
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QProcessEnvironment
- en: 'This class creates the environment variables that can be used when you start a
    program that uses processes in the application. The process'' environment variables
    are represented as a set of *key/value* pairs, such as `["PATH=/Path/To/dir",
    "USER=user"]`.  The declaration syntax of this class is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此类创建在启动使用进程的应用程序中的程序时可以使用的环境变量。进程的环境变量表示为键/值对的集合，例如 `["PATH=/Path/To/dir", "USER=user"]`。此类的声明语法如下：
- en: '[PRE2]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `QProcessEnvironment` class improves functionality with the following functions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`QProcessEnvironment` 类通过以下函数增强了功能。'
- en: is
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是
- en: 'This function returns a Boolean value (`bool`) related to the process environment
    states:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回一个与进程环境状态相关的布尔值 (`bool`)：
- en: '`process_env.isEmpty()`: This returns `True` if this process environment is
    empty and doesn''t have any environment variables.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_env.isEmpty()`: 这将返回 `True`，如果这个进程环境为空且没有任何环境变量。'
- en: functional
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能性
- en: 'These functions relate to the current values of the process environment, changes
    in functionality, and so on:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数与进程环境的当前值、功能变化等相关：
- en: '`process_env.clear()`: This clears all key/value pairs from this process environment.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_env.clear()`: 这将清除此进程环境中的所有键/值对。'
- en: '`process_env.contains(str)`: This returns `True` if the variable with the name
    specified in the parameter is found in this process environment.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_env.contains(str)`: 如果在参数指定的名称在此进程环境中找到变量，则返回 `True`。'
- en: '`process_env.insert(QtCore.QProcessEnvironment)`: This inserts the contents
    of the process environment specified in the parameter in this process environment.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_env.insert(QtCore.QProcessEnvironment)`: 这将参数指定的进程环境的内容插入到此进程环境中。'
- en: '`process_env.insert(str, str)`: This inserts the key (the first parameter)
    and value (the second parameter) of the environment variable in this process environment.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_env.insert(str, str)`: 这将在此进程环境中插入环境变量的键（第一个参数）和值（第二个参数）。'
- en: '`process_env.keys()`: This returns a list with all the environment variable
    keys of this process environment.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_env.keys()`: 这将返回一个包含此进程环境所有环境变量键的列表。'
- en: '`process_env.remove(str)`: This removes the environment variable that contains
    the name (key) specified in the parameter.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_env.remove(str)`: 这将删除包含参数指定的名称（键）的环境变量。'
- en: '`process_env.swap(QtCore.QProcessEnvironment)`: This swaps this process environment
    with the process environment specified in the parameter.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_env.swap(QtCore.QProcessEnvironment)`: 这将与此参数指定的进程环境交换此进程环境。'
- en: '`process_env.systemEnvironment()`: This returns the system environment of the
    **`QtCore.QProcessEnvironment`** type for the process.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_env.systemEnvironment()`: 这将返回进程的 `**`QtCore.QProcessEnvironment`**`
    类型的系统环境。'
- en: '`process_env.toStringList()`: This converts this process environment into a
    list of strings of key/value pairs.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_env.toStringList()`: 这将此进程环境转换为键/值对的字符串列表。'
- en: '`process_env.value(str, str)`: This returns the value of the name (key) specified
    in the first parameter, or the default value (the second parameter) if the variable
    with the name passed in does not exist in this process environment.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_env.value(str, str)`: 这将返回第一个参数指定的名称（键）的值，或者如果此进程环境中不存在具有该名称的变量，则返回默认值（第二个参数）。'
- en: Process example
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程示例
- en: 'Let''s look at an example of the using `QProcess` class by making some additions
    to our application. We will use the QML script we used previously in this book
    to visualize the buttons in the applications section of the tab widget, and we
    will run these apps by clicking on a few of them. Note that processes created
    with the `QProcess` class may not work with some operating systems, and for this
    reason, the `subprocess` module constructions are still commented. So, to do this,
    we need to copy the directories we used with the QML implementation, such as `qmls/`
    and `jscripts/`, into our working directory. We also need to copy the `u_qml.qml`
    file. Now, we need to create new `apps.qml` files in both the `App/App_PySide2/`
    and `App/App_PyQt5/` directories, which will contain the QML script for the buttons
    in the applications. The `apps.qml` file looks as follows, and can be copied and
    modified from the `qmls/UGrid.qml` file we created earlier:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向我们的应用程序添加一些内容来查看使用 `QProcess` 类的示例。我们将使用本书中之前使用的 QML 脚本来可视化标签控件的应用程序部分中的按钮，并通过单击其中的一些按钮来运行这些应用程序。请注意，使用
    `QProcess` 类创建的进程可能无法与某些操作系统一起工作，因此 `subprocess` 模块构造仍然是注释的。因此，为了做到这一点，我们需要将我们用于
    QML 实现的目录（如 `qmls/` 和 `jscripts/`）复制到我们的工作目录中。我们还需要复制 `u_qml.qml` 文件。现在，我们需要在
    `App/App_PySide2/` 和 `App/App_PyQt5/` 目录中创建新的 `apps.qml` 文件，其中将包含应用程序中按钮的 QML
    脚本。`apps.qml` 文件如下所示，可以复制并从我们之前创建的 `qmls/UGrid.qml` 文件中进行修改：
- en: 'Add the QML import section, a base `Rectangle`, along with its properties,
    and a grid layout for the buttons to the `apps.qml` file:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 QML 导入部分、一个基本的 `Rectangle` 以及其属性和按钮的网格布局添加到 `apps.qml` 文件中：
- en: '[PRE3]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is the parent rectangle for all the rectangles in QML. Note that, while
    writing this book, the versions of Qt changed, and the `QtQuick` versions changed
    as well. So, before using the QML script, it is recommended that you check the
    available versions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 QML 中所有矩形的父矩形。请注意，在编写本书时，Qt 的版本发生了变化，`QtQuick` 的版本也发生了变化。因此，在使用 QML 脚本之前，建议您检查可用的版本。
- en: 'Add the first glow button, which will be used for running the video camera,
    to the grid layout:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第一个发光按钮，该按钮将用于运行视频摄像头，并将其添加到网格布局中：
- en: '[PRE4]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is the first rectangle with a glow effect and will call the video camera
    application in a separate window.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是带有发光效果的第一个矩形，它将在单独的窗口中调用视频摄像头应用程序。
- en: 'Add the second glow button, which will be used to run the QML application example,
    to the grid layout:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第二个发光按钮添加到网格布局中，该按钮将用于运行 QML 应用程序示例：
- en: '[PRE5]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is the second rectangle with a glow effect, which will call the QML application
    through the created `clicked()` signal that will be used.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是带有发光效果的第二个矩形，它将通过创建的 `clicked()` 信号调用 QML 应用程序。
- en: 'Add the third glow button, which will be used to run Jupyter Notebook, to the grid
    layout:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第三个发光按钮，该按钮将用于运行 Jupyter Notebook，并将其添加到网格布局中：
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The third rectangle with a glow effect will start the Jupyter Notebook in the
    separated process that's created with the `QProcess` class.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 带有发光效果的第三个矩形将在使用 `QProcess` 类创建的分离进程中启动 Jupyter Notebook。
- en: 'Finally, add the fourth glow button, which will be used to run the default
    web browser, to the grid layout, thereby completing the QML file:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加第四个发光按钮，该按钮将用于运行默认的网页浏览器，并将其添加到网格布局中，从而完成 QML 文件：
- en: '[PRE7]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The fourth rectangle with a glow effect will open the default web browser for
    the system in a separate process.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 带有发光效果的第四个矩形将在单独的进程中打开系统的默认网页浏览器。
- en: 'Now, we need to make some changes in the `u_app.py` file to implement the QML
    script in the application that will run new processes, such as QML apps and other
    third-party programs:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在 `u_app.py` 文件中进行一些更改，以实现 QML 脚本并在运行新进程的应用程序中运行，例如 QML 应用程序和其他第三方程序：
- en: 'First, add the following lines to the import section of each file:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下行添加到每个文件的导入部分：
- en: 'Add the following to the PySide2 `u_app.py` file:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将以下内容添加到 PySide2 的 `u_app.py` 文件中：
- en: '[PRE8]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the following to the PyQt5 `u_app.py` file:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将以下内容添加到 PyQt5 的 `u_app.py` 文件中：
- en: '[PRE9]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, add/change some lines to/in the `__init__()` function of the `UApp` class,
    as follows:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，根据以下内容修改或添加 `UApp` 类的 `__init__()` 函数中的某些行：
- en: '[PRE10]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The created signals in the QML file will be used to call the functions related
    to new processes that will run new tasks. Now, we need to add some functions to
    the `UApp` class to realize the QML and run the processes with specified applications.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 QML 文件中创建的信号将被用于调用与将要运行的新任务相关联的函数。现在，我们需要向 `UApp` 类添加一些函数，以实现 QML 并使用指定的应用程序运行进程。
- en: 'Add the resize event handler in order to resize the QML elements in the view:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加调整大小事件处理程序以调整视图中的 QML 元素大小：
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This event handler will resize the tab of the widget that contains the QML elements
    when the window of the application is resized with a mouse or in another way.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此事件处理程序将在使用鼠标或其他方式调整应用程序窗口大小时，调整包含 QML 元素的窗口的标签大小。
- en: 'Add the first process for running a video camera device:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第一个进程以运行视频摄像头设备：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will start the camera widget in the new process. The camera device functionality
    provided by the Qt library may vary from version to version. If you are using
    an operating system that requires root privileges, you need to start this functionality
    according to these requirements.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在新进程中启动摄像头小部件。Qt 库提供的摄像头设备功能可能因版本而异。如果您使用的是需要 root 权限的操作系统，您需要根据这些要求启动此功能。
- en: 'Add the second process, which will run the QML application we created previously:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第二个进程，该进程将运行我们之前创建的 QML 应用程序：
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will run the QML application in the new process. We also need to create
    a `u_qml.py` file in both the `App/App_PySide2/` and `App/App_PyQt5/` directories
    and add the following lines.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在新进程中运行 QML 应用程序。我们还需要在 `App/App_PySide2/` 和 `App/App_PyQt5/` 目录中创建一个 `u_qml.py`
    文件，并添加以下行。
- en: 'Add the following lines in each `import` section:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个 `import` 部分添加以下行：
- en: 'Add the following lines to the PySide2 `u_qml.py` file:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将以下行添加到 PySide2 的 `u_qml.py` 文件中：
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the following lines to the PyQt5 `u_qml.py` file:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将以下行添加到 PyQt5 的 `u_qml.py` 文件中：
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, add the following lines, which are for starting the QML in the application,
    to both files:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，将以下用于在应用程序中启动 QML 的行添加到两个文件中：
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We change this file in a similar manner to the QML application – without using
    the classes. However, the `u_qml.py` file that we created in [Chapter 2](e8aa0a88-3426-4280-86f9-8d39cf7f6391.xhtml),
    *An Overview of QML*, can be used with additional modifications as well.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以类似的方式更改此文件，即不使用类。然而，我们在 [第 2 章](e8aa0a88-3426-4280-86f9-8d39cf7f6391.xhtml)，*QML
    概述*中创建的 `u_qml.py` 文件也可以通过额外的修改来使用。
- en: 'Add the third process in order to run Jupyter Notebook in a specified browser
    (which can be changed to your favorite browser; if one is not specified, the default
    browser will be used):'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在指定的浏览器中运行 Jupyter Notebook（可以更改为您喜欢的浏览器；如果没有指定，将使用默认浏览器）：
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This function will start Jupyter Notebook in the new process, which will be
    displayed in the Firefox web browser. If we want to open the notebook in our default
    browser, this can be done by not specifying any browser in the browser parameter
    of the `start()` function. Or we can open with our favorite by specifying the
    browser parameter.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将在新进程中启动 Jupyter Notebook，它将在 Firefox 浏览器中显示。如果我们想在我们的默认浏览器中打开笔记本，可以通过在 `start()`
    函数的浏览器参数中不指定任何浏览器来实现。或者，我们可以通过指定浏览器参数来使用我们喜欢的浏览器。
- en: 'Finally, add the fourth process, which will run the default web browser with
    the Python standard library''s `webbrowser` module, and the specified URL:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加第四个进程，该进程将使用 Python 标准库的 `webbrowser` 模块运行默认的网页浏览器，并指定 URL：
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we are specifying the command in the `start()` function of the `QProcess`
    class, similar to the construction of the `subprocess` module of the Python standard
    library. All of these functions for starting processes emulate the toggling of
    the buttons. When the button is clicked, the process will start. When it is no
    longer being clicked, the `kill()` function will be called. These functions are
    optional and can be used to start another program.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定了 `QProcess` 类的 `start()` 函数中的命令，类似于 Python 标准库中 `subprocess` 模块的构建。所有这些用于启动进程的函数都模拟了按钮的切换。当按钮被点击时，进程将启动。当不再被点击时，将调用
    `kill()` 函数。这些函数是可选的，可以用来启动另一个程序。
- en: Threads
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程
- en: The next element of execution operations that's related to the environment of
    applications and programs is threads. Threads are very similar to processes in
    nature, but there are some differences. Threads do things in parallel. In a broad
    sense, the thread of an execution is a sequence of instructions that can be managed
    independently by a scheduler of the operating system's operations. In most applications
    that are available at the moment, a thread is a component of a process. In the
    world around us, we usually encounter multitasking OSes that provide a multithreading
    model that allows multiple threads to exist within the context of one process.
    So, how we can describe threads?  When you are using your favorite operating system,
    or you are running your favorite editor, for example, the Spyder editor included
    in the Anaconda toolset, you want to find out the latest news and open a web browser.
    Let's say you open your media player to listen to some music or watch a video – these
    applications are usually used when you are doing something like this. This is
    an example of several processes working in parallel using the multitasking model
    of execution. Moreover, as we can see, each of these processes has other internal
    processes that execute in parallel in one single process. While you are using
    the text field of the editor, you can run another option of this editor simultaneously.
    This behavior describes the sense of the threads in an application – concurrency
    within one single process.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与应用程序和程序的环境相关的执行操作的下一个元素是线程。在本质上，线程与进程非常相似，但也有一些区别。线程以并行的方式做事。从广义上讲，执行线程是操作系统操作调度器可以独立管理的指令序列。在目前大多数可用的应用程序中，线程是进程的一个组成部分。在我们周围的世界里，我们通常遇到的多任务操作系统提供了多线程模型，允许在单个进程的上下文中存在多个线程。那么，我们如何描述线程呢？当你使用你喜欢的操作系统，或者运行你喜欢的编辑器，例如，Anaconda工具集包含的Spyder编辑器时，你想要找到最新的新闻并打开一个网页浏览器。假设你打开你的媒体播放器来听音乐或看视频——这些应用程序通常在你做类似的事情时使用。这是一个几个进程在使用执行的多任务模型并行工作的例子。此外，正如我们所看到的，这些进程中的每一个都有其他在单个进程中并行执行的内部进程。当你使用编辑器的文本字段时，你可以同时运行这个编辑器的另一个选项。这种行为描述了应用程序中线程的意义——单个进程内的并发。
- en: How we can describe concurrent execution? As we described in the *Processes*
    section of this chapter, parallel execution on a CPU with a single core is an
    illusion. For processes, this is as an interruption of a process when another
    process starts, and then another process is interrupted when another process starts.
    This situation with processes can be extrapolated to the execution of a program's
    segments of one single process. When a process starts, it always executes one
    code segment. This is known as a process having one thread. We can split the execution
    of a process into two code segments, which will make it look like two different
    code sequences are operating simultaneously. When we have a single-core CPU, concurrency
    is realized in a similar way to the parallel execution of processes. If we have
    a multi-core CPU, these threads can be assigned to multiple cores. This is concurrency
    in the real sense of the word.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何描述并发执行呢？正如我们在本章的*进程*部分所描述的，在单核CPU上的并行执行只是一个假象。对于进程来说，这就像当另一个进程开始时对进程的打断，然后当另一个进程开始时，另一个进程又被打断。这种情况可以推广到单个进程的程序段执行。当一个进程开始时，它总是执行一个代码段。这被称为进程有一个线程。我们可以将进程的执行分割成两个代码段，这样看起来就像有两个不同的代码序列同时在运行。当我们有一个单核CPU时，并发是通过与进程的并行执行类似的方式实现的。如果我们有一个多核CPU，这些线程可以被分配到多个核心上。这实际上就是并发。
- en: 'In regard to GUI application development with Qt (although this is not only related
    to Qt), there are two types of threads that we need to know about. The first type
    is a GUI thread that is used as the main thread of the application. This is started
    by calling the `QtCore.QApplication.exec()` function when we run our application.
    All GUI components, such as widgets, and some classes, such as `QPixmap`, must
    run in this thread. The second type is a secondary thread, also known as the worker
    thread, which is used to offload the main thread and run long-term tasks. All
    the threads that have been demonstrated in this book that provide additional functionality,
    such as pandas, are worker threads. Each thread has its own stack (call history
    and local variables) with a size that is usually defined by the operating system.
    Threads share the same address space. We need to know about the following if we
    want to use threads in the application:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用Qt（尽管这不仅仅与Qt相关）进行GUI应用程序开发，我们需要了解两种类型的线程。第一种类型是作为应用程序主线程使用的GUI线程。当我们运行应用程序时，通过调用
    `QtCore.QApplication.exec()` 函数启动此线程。所有GUI组件，如小部件，以及一些类，如 `QPixmap`，都必须在此线程中运行。第二种类型是辅助线程，也称为工作线程，用于卸载主线程并运行长期任务。本书中展示的所有提供额外功能（如pandas）的线程都是工作线程。每个线程都有自己的堆栈（调用历史和局部变量），其大小通常由操作系统定义。线程共享相同的地址空间。如果我们想在应用程序中使用线程，我们需要了解以下内容：
- en: The number of available threads for the real concurrent execution is equal to
    the number of available CPU cores
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际并发执行可用的线程数等于可用的CPU核心数
- en: Several threads cannot access the same object at one time
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个线程不能同时访问同一对象
- en: All thread objects can only be used safely when other threads are not related
    to them and objects don't have an implicit coupling with other threads
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有线程对象只有在其他线程与它们无关且对象没有与其他线程的隐式耦合时才能安全使用
- en: We cannot change something in the GUI thread from the worker thread
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能从工作线程中更改GUI线程中的某个内容
- en: The Qt library provides several classes for working with threads in an application,
    such as `QThread` and `QThreadPool`. The advantages of the `QThread` class are
    that we can make changes in GUI components using the signals mechanism. The Qt
    library provides documentation terms such as *re-entrant* and *thread-safe*, which
    are used to mark classes and functions to indicate how they can be used in multithreading
    applications. The term **thread-safe** means that this method can be called from
    multiple threads, even when the invocations use shared data, because all references
    to the shared data are serialized.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Qt库提供了几个用于在应用程序中处理线程的类，例如 `QThread` 和 `QThreadPool`。`QThread` 类的优点是我们可以使用信号机制更改GUI组件。Qt库提供了诸如
    *可重入* 和 *线程安全* 这样的文档术语，用于标记类和函数，以指示它们如何在多线程应用程序中使用。术语 **线程安全** 意味着即使调用使用共享数据，此方法也可以从多个线程中调用，因为所有对共享数据的引用都是序列化的。
- en: The term **re-entrant** means that this method can be called from multiple threads,
    but only if each invocation uses its own data. In this section, we will cover
    the `QThread` and `QThreadPool` classes. We also recommend learning about the
    `QtConcurrent` module and the `WorkerScript` QML type.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 **可重入** 意味着此方法可以从多个线程中调用，但前提是每个调用都使用自己的数据。在本节中，我们将介绍 `QThread` 和 `QThreadPool`
    类。我们还建议学习 `QtConcurrent` 模块和 `WorkerScript` QML 类型。
- en: QThread
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QThread
- en: 'This class manages the threads that can be used in an application. It is platform-independent
    and provides a way to separate the execution of tasks into different event loops.
    The declaration syntax of this class is as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此类管理应用程序中可用的线程。它是平台无关的，并提供了一种将任务执行分离到不同事件循环的方法。此类声明的语法如下：
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`QThread` inherits from the `QObject` class and improves functionality with
    the following functions.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`QThread` 从 `QObject` 类继承，并通过以下函数增强了功能。'
- en: set
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: 'These functions set the parameters/properties to the thread:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数将参数/属性设置到线程中：
- en: '`thread.setEventDispatcher(QtCore.QAbstractEventDispatcher)`: This sets the
    event dispatcher, specified in the parameter, that will be used with this thread.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.setEventDispatcher(QtCore.QAbstractEventDispatcher)`: 这将设置用于此线程的事件分发器，该分发器由参数指定。'
- en: '`thread.setPriority(QtCore.QThread.Priority)`: This sets the priority, specified
    in the parameter, that will be used with the running of this thread. The available
    priorities are as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.setPriority(QtCore.QThread.Priority)`: 这将设置用于此线程运行的优先级，该优先级由参数指定。可用的优先级如下：'
- en: '`QtCore.QThread.IdlePriority`—`0`: This thread is running only when no other
    threads are running.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QThread.IdlePriority`—`0`: 此线程仅在没有任何其他线程运行时运行。'
- en: '`QtCore.QThread.LowestPriority`—`1`: This thread has the lowest running priority.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QThread.LowestPriority`—`1`: 此线程具有最低的运行优先级。'
- en: '`QtCore.QThread.LowPriority`—`2`: This thread has a low running priority.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QThread.LowPriority`—`2`: 此线程具有低运行优先级。'
- en: '`QtCore.QThread.NormalPriority`—`3`: This thread has a normal (the default
    of the operating system) running priority.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QThread.NormalPriority`—`3`: 此线程具有正常（操作系统的默认值）的运行优先级。'
- en: '`QtCore.QThread.HighPriority`—`4`: This thread has a high running priority.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QThread.HighPriority`—`4`: 此线程具有高运行优先级。'
- en: '`QtCore.QThread.HighestPriority`—`5`: This thread has the highest running priority.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QThread.HighestPriority`—`5`: 此线程具有最高的运行优先级。'
- en: '`QtCore.QThread.TimeCriticalPriority`—`6`: This thread runs as often as possible
    against other threads.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QThread.TimeCriticalPriority`—`6`: 此线程尽可能频繁地与其他线程运行。'
- en: '`QtCore.QThread.InheritPriority`—`7`: This thread is running with the same
    priority as the creating thread.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QThread.InheritPriority`—`7`: 此线程以与创建线程相同的优先级运行。'
- en: '`thread.setStackSize(int)`: This sets the maximum stack size as a number of
    bytes, specified in the parameter, for this thread.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.setStackSize(int)`: 这将此线程的最大堆栈大小设置为参数中指定的字节数。'
- en: '`thread.setTerminationEnabled(bool)`: If this parameter is `True`, it enables
    the thread''s termination.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.setTerminationEnabled(bool)`: 如果此参数为 `True`，则启用线程的终止。'
- en: is
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: is
- en: 'These functions return a Boolean value, `bool`, related to the threads'' states:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数返回与线程状态相关的布尔值，`bool`：
- en: '`thread.isFinished()`: This returns `True` if this thread is finished.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.isFinished()`: 如果此线程已完成，则返回 `True`。'
- en: '`thread.isInterruptionRequested()`: This returns `True` if an interruption
    of this thread is requested.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.isInterruptionRequested()`: 如果请求中断此线程，则返回 `True`。'
- en: '`thread.isRunning()`: This returns `True` if this thread is running.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.isRunning()`: 如果此线程正在运行，则返回 `True`。'
- en: functional
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: functional
- en: 'These functions relate to the current values of the thread, changes in functionality,
    and so on:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数与线程的当前值、功能变化等相关：
- en: '`thread.currentThread()`: This returns the currently operating thread object
    of the `QtCore.QThread` type.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.currentThread()`: 这返回当前操作线程的 `QtCore.QThread` 类型的对象。'
- en: '`thread.currentThreadId()`: This returns the thread handler of the current
    thread.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.currentThreadId()`: 这返回当前线程的处理程序。'
- en: '`thread.eventDispatcher()`: This returns the event dispatcher object of the
    `QtCore.QAbstractEventDispatcher` type for the currently operating thread.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.eventDispatcher()`: 这返回当前操作线程的 `QtCore.QAbstractEventDispatcher` 类型的事件分发器对象。'
- en: '`thread.exec_()`: This executes this thread by entering the event loop.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.exec_()`: 这通过进入事件循环来执行此线程。'
- en: '`thread.exit(int)`: This exits the event loop of the thread with a return code
    specified in the parameter (`0` is a success; any nonzero value is an error).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.exit(int)`: 这以参数中指定的返回代码退出线程的事件循环（`0` 表示成功；任何非零值表示错误）。'
- en: '`thread.idealThreadCount()`: This returns the ideal number of threads that
    can be used on the system.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.idealThreadCount()`: 这返回系统上可以使用的理想线程数。'
- en: '`thread.loopLevel()`: This returns the event loop level for this thread.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.loopLevel()`: 这返回此线程的事件循环级别。'
- en: '`thread.msleep(int)`: This thread falls asleep after the number of milliseconds
    specified in the parameter have elapsed.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.msleep(int)`: 在参数中指定的毫秒数过去后，此线程会进入休眠状态。'
- en: '`thread.priority()`: This returns the priority of the `QtCore.QThread.Priority`
    type used for this thread.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.priority()`: 这返回用于此线程的 `QtCore.QThread.Priority` 类型的优先级。'
- en: '`thread.quit()`: This exits the event loop of this thread with a return code
    of `0`.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.quit()`: 这以返回代码 `0` 退出此线程的事件循环。'
- en: '`thread.requestInterruption()`: This requests the interruption of this thread'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.requestInterruption()`: 这请求中断此线程'
- en: '`thread.run()`: This calls the `run()` function of the created thread.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.run()`: 这调用创建的线程的 `run()` 函数。'
- en: '`thread.sleep(int)`: This thread falls asleep after the duration in seconds
    specified in the parameter.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.sleep(int)`: 在参数中指定的秒数过去后，此线程会进入休眠状态。'
- en: '`thread.stackSize()`: This returns the maximum stack size for this thread as
    a number of bytes.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.stackSize()`: 这返回此线程的最大堆栈大小，以字节数表示。'
- en: '`thread.start(QtCore.QThread.Priority)`: This starts this thread and begins
    executing the `run()` function instructions, with priority specified in the parameter.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.start(QtCore.QThread.Priority)`: 这启动此线程并开始执行参数中指定的 `run()` 函数指令，指定优先级。'
- en: '`thread.terminate()`: This terminates the execution of this thread.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.terminate()`: 这将终止此线程的执行。'
- en: '`thread.usleep(int)`: This thread falls asleep in the number of microseconds
    specified in the parameter.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.usleep(int)`: 该线程将在参数指定的微秒数内休眠。'
- en: '`thread.wait(int)`: This blocks this thread and waits until it has finished
    execution or waits for the number of milliseconds specified in the parameter.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.wait(int)`: 这将阻塞此线程，直到它完成执行或等待参数指定的毫秒数。'
- en: '`thread.yieldCurrentThread()`: This yields the execution of this thread to
    another thread, which the operating system will switch to.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.yieldCurrentThread()`: 这将使当前线程的执行权交由另一个线程，操作系统将切换到该线程。'
- en: signals
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号
- en: 'These are the available signals of the `QThread` class:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 `QThread` 类的可用信号：
- en: '`thread.finished()`: This signal is emitted before this thread finishes executing.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.finished()`: 在此线程执行完毕之前发出此信号。'
- en: '`thread.started()`: This signal is emitted before this thread starts executing.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread.started()`: 在此线程开始执行之前发出此信号。'
- en: QThreadPool
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QThreadPool
- en: 'This class manages a collection of threads that can be used in an application.
    The Qt application has a global `QThreadPool` object that manages the main (**GUI**)
    and additional (**worker**) threads that are used in the application. This existing
    thread pool can be accessed by calling the `globalInstance()` static function.
    The declaration syntax of this class is as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此类管理可用于应用程序的线程集合。Qt应用程序有一个全局的 `QThreadPool` 对象，用于管理应用程序中使用的主（**GUI**）和附加（**工作**）线程。可以通过调用
    `globalInstance()` 静态函数来访问现有的线程池。此类的声明语法如下：
- en: '[PRE20]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`QThreadPool` inherits from the `QObject` class and enhances its functionality
    with the following functions.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`QThreadPool` 从 `QObject` 类继承，并通过以下函数增强了其功能。'
- en: set
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: 'These functions set the parameters/properties of the thread pool:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数设置线程池的参数/属性：
- en: '`thread_pool.setExpiryTimeout(int)`: This sets the expiry timeout in milliseconds,
    specified in the parameter, for the thread pool, after which all unused threads
    are considered expired and exit.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread_pool.setExpiryTimeout(int)`: 这将为线程池设置过期超时时间（以毫秒为单位），指定在参数中，之后所有未使用的线程都被视为过期并退出。'
- en: '`thread_pool.setMaxThreadCount(int)`: This sets the maximum number of threads,
    specified in the parameter, that will be used in the pool.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread_pool.setMaxThreadCount(int)`: 这将设置池中将使用的最大线程数，该数由参数指定。'
- en: '`thread_pool.setStackSize(int)`: This sets the maximum stack size as a number
    of bytes, specified in the parameter, for the worker threads in the pool.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread_pool.setStackSize(int)`: 这将为池中的工作线程设置最大堆栈大小，以字节数的形式指定在参数中。'
- en: functional
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式
- en: 'These functions relate to the current values of the thread pool, changes in
    functionality, and so on:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数与线程池的当前值、功能变化等相关：
- en: '`thread_pool.activeThreadCount()`: This returns the number of active threads
    in the pool.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread_pool.activeThreadCount()`: 这返回池中活动线程的数量。'
- en: '`thread_pool.cancel(QtCore.QRunnable)`: This removes a runnable object that
    hasn''t been started or specified in the parameter from the queue.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread_pool.cancel(QtCore.QRunnable)`: 这将从队列中移除尚未启动或指定在参数中的可运行对象。'
- en: '`thread_pool.clear()`: This removes runnable objects that haven''t been started from
    the queue.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread_pool.clear()`: 这将从队列中移除尚未启动的可运行对象。'
- en: '`thread_pool.expiryTimeout()`: This returns the expiry timeout for the thread
    pool, or the time in milliseconds after which all unused threads are considered
    expired, and exit.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread_pool.expiryTimeout()`: 这返回线程池的过期超时时间，或所有未使用的线程被视为过期并退出后的时间（以毫秒为单位）。'
- en: '`thread_pool.globalInstance()`: This returns the global instance of the **`QtCore.QThreadPool`**
    type for the thread pool.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread_pool.globalInstance()`: 这返回线程池的 **`QtCore.QThreadPool`** 类的全局实例。'
- en: '`thread_pool.maxThreadCount()`: This returns the maximum number of threads
    used in the pool.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread_pool.maxThreadCount()`: 这将返回池中使用的最大线程数。'
- en: '`thread_pool.releaseThread()`: This releases the thread that was previously
    reserved with the `reserveThread()` function.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread_pool.releaseThread()`: 通过 `reserveThread()` 函数之前保留的线程被释放。'
- en: '`thread_pool.reserveThread()`: This reserves the thread.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread_pool.reserveThread()`: 这将保留线程。'
- en: '`thread_pool.stackSize()`: This returns the maximum stack size as the number
    of bytes for the worker threads in the pool.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread_pool.stackSize()`: 这返回池中工作线程的最大堆栈大小（以字节数表示）。'
- en: '`thread_pool.start(QtCore.QRunnable, int)`: This reserves this thread and uses
    it to run a runnable (the first parameter) object with priority (the second parameter)
    for the queue''s order of execution.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread_pool.start(QtCore.QRunnable, int)`：这会保留这个线程，并使用它来运行一个可运行的（第一个参数）对象，具有优先级（第二个参数），以确定队列的执行顺序。'
- en: '`thread_pool.tryStart(QtCore.QRunnable)`: This tries to reserve the thread
    in order to run a runnable object, specified in the parameter, in the queue.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread_pool.tryStart(QtCore.QRunnable)`：这尝试保留线程以运行在参数中指定的可运行对象。'
- en: '`thread_pool.tryTake(QtCore.QRunnable)`: This tries to remove the runnable
    object that''s specified in the parameter from the queue.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread_pool.tryTake(QtCore.QRunnable)`：这尝试从队列中移除在参数中指定的可运行对象。'
- en: '`thread_pool.waitForDone(int)`: This waits for the timeout in milliseconds,
    specified in the parameter, for all threads to exit, and removes all threads from
    the pool (the default timeout is `-1` or ignored).'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread_pool.waitForDone(int)`：这将等待在参数中指定的毫秒数超时，等待所有线程退出，并从池中移除所有线程（默认超时为`-1`或忽略）。'
- en: Threads example
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程示例
- en: 'In order to look at an example of threads, we will modify the previous code
    related to CouchDB and MongoDB functionality. In the `u_tools.py` files, let''s
    add the classes with threads and functions that will make threads dependent on
    the tasks in the application:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看线程的示例，我们将修改与CouchDB和MongoDB功能相关的先前代码。在`u_tools.py`文件中，让我们添加具有线程和函数的类，这些函数将使线程依赖于应用程序中的任务：
- en: 'Add the thread class for the MongoDB server:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加用于MongoDB服务器的线程类：
- en: '[PRE21]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is the first part of the class with a signal that will emit data. It also
    has the `on_source()` function, which will receive data.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这是课程的第一个部分，它有一个会发射数据的信号。它还包含`on_source()`函数，该函数将接收数据。
- en: 'Now, we need to add the `run()` function, which will implement our threading
    functionality, to the `MongoThread` class:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将实现我们的线程功能的`run()`函数添加到`MongoThread`类中：
- en: '[PRE22]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `run()` function of the thread will start the thread functionality. It will
    try to connect to the MongoDB server. When it is connected, it will try to insert/select
    the values to/from the database.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 线程的`run()`函数将启动线程功能。它将尝试连接到MongoDB服务器。当连接成功后，它将尝试向/从数据库插入/选择值。
- en: 'Add the `CouchThread` class for the CouchDB server:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加用于CouchDB服务器的`CouchThread`类：
- en: '[PRE23]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is the first part of the class and has a signal that will emit data, as
    well as the `on_source()` function, which will receive data.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这是课程的第一个部分，它有一个会发射数据的信号，以及`on_source()`函数，该函数将接收数据。
- en: 'Now, add the `run()` function, which will implement the threading functionality, to
    the `CouchThread` class:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将实现线程功能的`run()`函数添加到`CouchThread`类中：
- en: '[PRE24]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `run()` function of this thread will start the thread functionality. It
    will try to connect to the CouchDB server. When it is connected, it will try to
    insert/select values to/from the database. Now, we need to add the functions that
    will provide the threading functionality in the application. First, we need to
    add the signals that will be used in the `UTools` class.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个线程的`run()`函数将启动线程功能。它将尝试连接到CouchDB服务器。当连接成功后，它将尝试向/从数据库插入/选择值。现在，我们需要添加将在应用程序中提供线程功能的功能。首先，我们需要添加在`UTools`类中将使用的信号。
- en: 'The signals that will be used for communication look like this:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于通信的信号看起来像这样：
- en: '[PRE25]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: These new signals will communicate between the `UTools` class' functionality
    and the threads that were created for Mongo and Couch database realization. Then,
    we need to change the previously created functions in the `UTools` class of the
    `u_tools.py` files to write to and read from the Couch and Mongo databases.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新信号将在`UTools`类的功能与为Mongo和Couch数据库实现创建的线程之间进行通信。然后，我们需要将`u_tools.py`文件中的`UTools`类的先前创建的函数修改为写入和读取Couch和Mongo数据库。
- en: 'Change the `mongo_insert()` function of the `UTools` class:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`UTools`类的`mongo_insert()`函数：
- en: '[PRE26]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This function will write the data specified in the `datas` list using a thread.
    The instance of this thread will be used, along with the connection of the signal
    for emitting this data to the thread. This will start the thread (by default,
    the priority is `InheritPriority`).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将使用线程写入`datas`列表中指定的数据。这个线程的实例将被使用，以及用于向线程发射这些数据的信号的连接。这将启动线程（默认优先级为`InheritPriority`）。
- en: 'Change the `mongo_select()` function of the `UTools` class:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`UTools`类的`mongo_select()`函数：
- en: '[PRE27]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This function will read the data of the MongoDB instance using the thread. The
    instance of the thread will be created with the connection of the signal for emitting
    this data to the thread.  The emitted data will be a list with an empty dictionary
    (optional) and a string that indicates the reading operation. Then, the thread
    starts.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将使用线程读取MongoDB实例的数据。线程实例将与用于向线程发射此数据的信号连接创建。发射的数据将是一个包含空字典（可选）和指示读取操作的字符串的列表。然后，线程开始运行。
- en: 'Now, change the `couch_insert()` function of the `UTools` class:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，修改`UTools`类的`couch_insert()`函数：
- en: '[PRE28]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This function will write the data specified in the `datas` list using the thread
    to the Couch database. The instance of the thread will be used, along with the
    connection of the signal for emitting this data to the thread. Now, the thread
    will start.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将使用线程将`datas`列表中指定的数据写入Couch数据库。线程实例将被使用，同时连接用于向线程发射此数据的信号。现在，线程将开始运行。
- en: 'Change the `couch_select()` function of the `UTools` class:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`UTools`类的`couch_select()`函数：
- en: '[PRE29]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This function will read the data using the thread. The instance of the thread
    will be created, along with the connection of the signal for emitting this data
    to the thread. The emitted data will be a list with an empty dictionary (optional)
    and a string that indicates the reading operation.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将使用线程读取数据。线程实例将被创建，同时连接用于向线程发射此数据的信号。发射的数据将是一个包含空字典（可选）和指示读取操作的字符串的列表。
- en: 'Now, we need to change the `data()` function of the `UApp` class from the `u_app.py`
    files that are related to reading from the Couch and Mongo databases. Let''s get
    started:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要修改与从Couch和Mongo数据库读取相关的`u_app.py`文件中的`UApp`类的`data()`函数。让我们开始吧：
- en: 'Change the `data()` function of the `UApp` class:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`UApp`类的`data()`函数：
- en: '[PRE30]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These lines provide MongoDB functionality when the  Data | MongoDB option in the
    top panel is selected. It calls the `mongo_select()` function when it receives
    the thread object, connects to the nested function with the signal of the thread,
    and puts the database data into the text field. If an error occurs, it shows this
    error in the status bar of the application.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当在顶部面板中选择`数据`|`MongoDB`选项时，这些行提供MongoDB功能。它接收到线程对象时调用`mongo_select()`函数，通过线程的信号连接到嵌套函数，并将数据库数据放入文本字段。如果发生错误，它将在应用程序的状态栏中显示此错误。
- en: 'Change the `data()` function of the `UApp` class:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`UApp`类的`data()`函数：
- en: '[PRE31]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: These lines provide CouchDB functionality when the `CouchDB` option is selected.
    It calls the `couch_select()` function when it receives the thread object, connects
    to the nested function with the signal of the thread, and puts the database data
    into the text field. If an error occurs, it shows this error in the status bar
    of the application.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择`CouchDB`选项时，这些行提供CouchDB功能。它接收到线程对象时调用`couch_select()`函数，通过线程的信号连接到嵌套函数，并将数据库数据放入文本字段。如果发生错误，它将在应用程序的状态栏中显示此错误。
- en: These examples have some restrictions in regard to use. Note that when we use
    this functionality, we need to ensure that the CouchDB and MongoDB servers are
    configured and working, and that databases are created in the directory.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例在使用方面有一些限制。请注意，当我们使用此功能时，我们需要确保CouchDB和MongoDB服务器已配置并正在运行，并且数据库已在该目录中创建。
- en: Locks
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁定
- en: When using threads in an application, problems may arise in relation to accessing
    a similar source with several threads, or when you need to lock the execution
    of part of the code. The Qt library provides several classes to solve this problem,
    such as `QMutex`, `QMutexLocker`, `QReadWriteLock`, `QSemaphore`, and `QWaitCondition`.
    Here, we will describe some of them. However, please note that locking some sources
    can create other problems related to blocking the GUI thread, or another thread.
    Therefore, using locks in an application is not trivial, and before implementation,
    we need to think about it carefully.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中使用线程时，可能会出现与多个线程访问类似源相关的问题，或者当您需要锁定代码的一部分执行时。Qt库提供了一些类来解决此问题，例如`QMutex`、`QMutexLocker`、`QReadWriteLock`、`QSemaphore`和`QWaitCondition`。在这里，我们将描述其中的一些。然而，请注意，锁定某些源可能会创建与阻塞GUI线程或另一个线程相关的其他问题。因此，在应用程序中使用锁不是一件简单的事情，在实现之前，我们需要仔细考虑。
- en: QMutex
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QMutex
- en: 'This class allows access serialization between threads. To enforce **mutual
    exclusion** (**mutex**), the thread locks a mutex in order to gain access to the
    resource. The declaration syntax of this class is as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类允许线程之间的访问序列化。为了强制**互斥**（**mutex**），线程锁定互斥锁以获取对资源的访问。这个类的声明语法如下：
- en: '[PRE32]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The mutex can be constructed with the recursion mode specified in the parameter.
    The available recursion modes are as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过参数指定递归模式来构造互斥锁。可用的递归模式如下：
- en: '`QtCore.QMutex.Recursive`—`0`: This thread is capable of locking the same mutex
    multiple times. This mutex will not be unlocked until a corresponding number of
    `unlock()` function calls have been made.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QMutex.Recursive`—`0`: 这个线程能够多次锁定相同的互斥锁。这个互斥锁将不会解锁，直到相应的`unlock()`函数调用次数达到相应的数量。'
- en: '`QtCore.QMutex.NonRecursive`—`1`: This thread can lock the same mutex only
    once.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QMutex.NonRecursive`—`1`: 这个线程只能锁定一次相同的互斥锁。'
- en: '`QMutex` inherits from the `QBasicMutex` class and enhances its functionality
    with the following functions.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`QMutex`从`QBasicMutex`类继承，并通过以下函数增强了其功能。'
- en: is
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是
- en: 'This function returns a Boolean value (`bool`) related to the mutex states:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回一个与互斥锁状态相关的布尔值（`bool`）：
- en: '`mutex.isRecursive()`: This returns `True` if this mutex has a recursive mode.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutex.isRecursive()`: 如果这个互斥锁具有递归模式，则返回`True`。'
- en: functional
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能性
- en: 'These functions relate to the current values of the mutex, changes in functionality,
    and so on:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数与互斥锁的当前值、功能变化等相关：
- en: '`mutex.lock()`: This locks the mutex.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutex.lock()`: 这将锁定互斥锁。'
- en: '`mutex.tryLock(int)`: This tries to lock the mutex. If another thread has locked
    the mutex, it will wait before the lock for the number of milliseconds specified
    in the parameter (the default timeout is `0`).'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutex.tryLock(int)`: 这将尝试锁定互斥锁。如果另一个线程已经锁定了互斥锁，它将在锁定之前等待指定参数中的毫秒数（默认超时为`0`）。'
- en: '`mutex.unlock()`: This unlocks the mutex.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutex.unlock()`: 这将解锁互斥锁。'
- en: QMutex example
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QMutex 示例
- en: 'Mutexes can usually be implemented in an application when threads are used.
    Let''s demonstrate this with the following lines of code:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用线程时，通常可以在应用程序中实现互斥锁。让我们用以下代码行来演示这一点：
- en: '[PRE33]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `__init__()` function created the instance of the `QMutex` class that was
    imported from the `QtCore` module. Inside the `run()` function of the thread,
    we added the line with the `lock()` and `unlock()` methods of the mutex, which
    will lock and unlock the code between them, respectively.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()`函数创建了从`QtCore`模块导入的`QMutex`类的实例。在线程的`run()`函数内部，我们添加了包含互斥锁的`lock()`和`unlock()`方法的行，它们将分别锁定和解锁它们之间的代码。'
- en: QMutexLocker
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QMutexLocker
- en: 'This class provides the additional convenient functionality of locking and
    unlocking mutexes. The declaration syntax of this class is as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类提供了锁定和解锁互斥锁的附加方便功能。这个类的声明语法如下：
- en: '[PRE34]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `QMutexLocker` class improves functionality with the following functions.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`QMutexLocker`类通过以下函数提高了功能。'
- en: functional
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能性
- en: 'These functions relate to the current values of the mutex locker, changes in
    functionality, and so on:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数与互斥锁锁定的当前值、功能变化等相关：
- en: '`mutex_locker.mutex()`: This returns the mutex of the `QtCore.QMutex` type
    that operates by this mutex locker.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutex_locker.mutex()`: 这将返回由这个互斥锁锁定器操作的`QtCore.QMutex`类型的互斥锁。'
- en: '`mutex_locker.relock()`: This relocks the unlocked mutex locker.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutex_locker.relock()`: 这将重新锁定已解锁的互斥锁锁定器。'
- en: '`mutex_locker.unlock()`: This unlocks the mutex locker.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutex_locker.unlock()`: 这将解锁互斥锁锁定器。'
- en: QMutexLocker example
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QMutexLocker 示例
- en: 'The previous example of mutexes has some flaws. If an exception occurs during
    the execution of the code before the `unlock()` method, the mutex can be locked
    forever. To solve this problem, we can use the `QMutexLocker` class. Let''s demonstrate
    this with the previously created mutex:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 之前关于互斥锁的例子有一些缺陷。如果在`unlock()`方法执行代码之前发生异常，互斥锁可能会永久锁定。为了解决这个问题，我们可以使用`QMutexLocker`类。让我们用之前创建的互斥锁来演示这一点：
- en: '[PRE35]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the `run()` function, we''ve created an instance of the `QMutexLocker` class
    that''s been imported from the `QtCore` module, with the mutex specified in the
    parameter. After the end of scope, the destructor of the class will be called,
    and this lock will be automatically released. This can also be used in the construction
    of the context manager for things such as instructions; for example, *with*/*as*.
    Change the previous lines of code to the following:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `run()` 函数中，我们创建了一个从 `QtCore` 模块导入的 `QMutexLocker` 类的实例，并将指定的互斥锁作为参数。在作用域结束时，类的析构函数将被调用，并且这个锁将自动释放。这也可以用于构建上下文管理器，例如指令；例如，*with*/*as*。将前面的代码行更改为以下内容：
- en: '[PRE36]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: QSystemSemaphore
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QSystemSemaphore
- en: 'This class provides a general counting system semaphore for working with threads
    and multiple processes in an application. The declaration syntax of this class
    is as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 此类为在应用程序中与线程和多个进程一起工作提供了一般计数系统信号量。此类的声明语法如下：
- en: '[PRE37]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This system semaphore can be constructed with a key (the first parameter) and
    a system-dependent initialization of the number of resources (the second parameter)
    with the access mode (the third parameter). The available access modes are as
    follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 此系统信号量可以使用键（第一个参数）和系统依赖的初始化资源数量（第二个参数）以及访问模式（第三个参数）进行构造。可用的访问模式如下：
- en: '`QtCore.QSystemSemaphore.Open`—`0`: If the system semaphore exists, its initial
    resource count is not reset; otherwise, it will be created.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QSystemSemaphore.Open`—`0`: 如果系统信号量存在，则其初始资源计数不会被重置；否则，它将被创建。'
- en: '`QtCore.QSystemSemaphore.Create`—`0`: The system semaphore will be created.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QSystemSemaphore.Create`—`0`: 系统信号量将被创建。'
- en: The `QSystemSemaphore` class improves functionality with the following functions.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSystemSemaphore` 类通过以下函数增强了功能。'
- en: set
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: set
- en: 'This function sets the parameters/properties of the system semaphore:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数设置系统信号量的参数/属性：
- en: '`system_semaphore.setKey(str, int, QtCore.QSystemSemaphore.AccessMode)`: This reconstructs
    the system semaphore object with a key (the first parameter) and a system-dependent
    initialization of the number of resources (the second parameter) with the access
    mode (the third parameter)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`system_semaphore.setKey(str, int, QtCore.QSystemSemaphore.AccessMode)`: 这使用键（第一个参数）和系统依赖的初始化资源数量（第二个参数）以及访问模式（第三个参数）重建系统信号量对象。'
- en: functional
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: functional
- en: 'These functions relate to the current values of the system semaphore, changes
    in functionality, and so on:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数与系统信号量的当前值、功能变化等相关：
- en: '`system_semaphore.acquire()`: This acquires one of the resources that are guarded
    by this system semaphore.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`system_semaphore.acquire()`: 这将获取由该系统信号量守护的资源之一。'
- en: '`system_semaphore.error(QtCore.QSystemSemaphore.SystemSemaphoreError)`: This
    returns a value of the error type if an error occurred with this system semaphore.
    The errors that can occur are as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`system_semaphore.error(QtCore.QSystemSemaphore.SystemSemaphoreError)`: 如果此系统信号量发生错误，则返回错误类型的值。可能发生的错误如下：'
- en: '`QtCore.QSystemSemaphore.NoError`—`0`: No error.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QSystemSemaphore.NoError`—`0`: 无错误。'
- en: '`QtCore.QSystemSemaphore.PermissionDenied`—`1`: Not enough permissions for
    the caller.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QSystemSemaphore.PermissionDenied`—`1`: 调用者权限不足。'
- en: '`QtCore.QSystemSemaphore.KeyError`—`2`: An invalid key has been specified.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QSystemSemaphore.KeyError`—`2`: 已指定无效的键。'
- en: '`QtCore.QSystemSemaphore.AlreadyExists`—`3`: A system semaphore with the specified
    key already exists.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QSystemSemaphore.AlreadyExists`—`3`: 指定的键的系统信号量已存在。'
- en: '`QtCore.QSystemSemaphore.NotFound`—`4`: A system semaphore with the specified
    key can''t be found.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QSystemSemaphore.NotFound`—`4`: 指定的系统信号量无法找到。'
- en: '`QtCore.QSystemSemaphore.OutOfResources`—`5`: Not enough memory.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QSystemSemaphore.OutOfResources`—`5`: 内存不足。'
- en: '`QtCore.QSystemSemaphore.UnknownError`—`6`: The error is unknown.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCore.QSystemSemaphore.UnknownError`—`6`: 错误未知。'
- en: '`system_semaphore.errorString()`: This returns a text description of the error.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`system_semaphore.errorString()`: 这返回错误文本描述。'
- en: '`system_semaphore.key()`: This returns the key for this system semaphore or
    the name by which this system semaphore can be accessed from other processes.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`system_semaphore.key()`: 这返回此系统信号量的键或从其他进程访问此系统信号量的名称。'
- en: '`system_semaphore.release(int)`: This releases the number, specified in the
    parameter, of resources guarded by this system semaphore.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`system_semaphore.release(int)`: 这将释放由该系统信号量守护的指定参数数量的资源。'
- en: QSemaphore
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QSemaphore
- en: 'This class creates the general counting semaphore for working with threads
    in the application. The declaration syntax of this class is as follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类为应用程序中与线程一起工作创建了一般计数信号量。这个类的声明语法如下：
- en: '[PRE38]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The semaphore can be constructed with the initialization of the number of resources
    specified in the parameter. The `QSemaphore` class improves functionality with
    the following functions.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量可以通过指定参数中指定的资源数量进行初始化。`QSemaphore`类通过以下函数增强了功能。
- en: functional
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: functional
- en: 'These functions relate to the current values of the semaphore, changes in functionality,
    and so on:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数与信号量的当前值、功能变化等相关：
- en: '`semaphore.acquire(int)`: This acquires the number, specified in the parameter,
    of the resources guarded by this semaphore.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`semaphore.acquire(int)`: 这获取由该信号量保护的指定数量（参数中指定）的资源。'
- en: '`semaphore.available()`: This returns the amount of resources available to
    this semaphore.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`semaphore.available()`: 这返回此信号量可用的资源数量。'
- en: '`semaphore.release(int)`: This releases the amount, specified in the parameter,
    of resources guarded by this semaphore.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`semaphore.release(int)`: 这释放由该信号量保护的指定数量的资源。'
- en: '`semaphore.tryAcquire(int)`: This tries to acquire the amount, specified in
    the parameter, of resources guarded by this semaphore.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`semaphore.tryAcquire(int)`: 这尝试获取由该信号量保护的指定数量的资源。'
- en: '`semaphore.tryAcquire(int, int)`: This tries to acquire the amount (the first
    parameter) of resources guarded by this semaphore for the duration specified (the
    second parameter).'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`semaphore.tryAcquire(int, int)`: 这尝试获取由该信号量保护的资源数量（第一个参数）在指定的时间内（第二个参数）。'
- en: The semaphore constructions are commonly used to control access to the source
    by the several threads. A good example of semaphores can be found in the threading
    examples, with PyQt5/PySide bindings, and in the `/examples/threads/` folder of
    `site-packages/`, which is related to the binding used.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量构造通常用于控制多个线程对资源的访问。在PyQt5/PySide绑定和`/examples/threads/`文件夹中的线程示例中，可以找到一个很好的信号量示例，该文件夹位于`site-packages/`，这与使用的绑定相关。
- en: QWaitCondition
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QWaitCondition
- en: 'This class synchronizes the threads by providing a condition variable. The
    declaration syntax of this class is as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类通过提供条件变量来同步线程。这个类的声明语法如下：
- en: '[PRE39]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `QWaitCondition` class improves functionality with the following functions.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`QWaitCondition`类通过以下函数增强了功能。'
- en: functional
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: functional
- en: 'These functions relate to the returns of the current values of the semaphore,
    changes in functionality, and so on:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数与信号量的当前值返回、功能变化等相关：
- en: '`wait_condition.wait(QtCore.QMutex, int)`: This releases the locked mutex (the
    first parameter) and waits on the wait condition, such as other thread signals,
    including `wakeOne()` or `wakeAll()`, or the timeout in milliseconds (the second
    parameter) elapses.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait_condition.wait(QtCore.QMutex, int)`: 这释放被锁定的互斥锁（第一个参数）并等待等待条件，例如其他线程的信号，包括`wakeOne()`或`wakeAll()`，或者毫秒数（第二个参数）超时。'
- en: '`wait_condition.wait(QtCore.QReadWriteLock, int)`: This releases the locked
    read/write lock (the first parameter) and waits on the wait condition, such as
    other thread signals, including `wakeOne()` or `wakeAll()`, or the timeout in
    milliseconds (the second parameter) elapses.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait_condition.wait(QtCore.QReadWriteLock, int)`: 这释放被锁定的读写锁（第一个参数）并等待等待条件，例如其他线程的信号，包括`wakeOne()`或`wakeAll()`，或者毫秒数（第二个参数）超时。'
- en: '`wait_condition.wakeAll()`: This wakes all threads that are waiting with the
    wait condition.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait_condition.wakeAll()`: 这唤醒所有正在等待等待条件的线程。'
- en: '`wait_condition.wakeOne()`: This wakes one of the threads that is waiting with
    the wait condition.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait_condition.wakeOne()`: 这唤醒一个正在等待等待条件的线程。'
- en: Python standard library tools
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python标准库工具
- en: The instruments of the Python standard library can be easily implemented with
    the PySide2/PyQt5 Python bindings of the Qt library in our GUI application. We
    can describe the tools we're going to use in a similar way to how we did earlier
    in this chapter.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库的工具可以通过Qt库的PySide2/PyQt5 Python绑定轻松实现，在我们的GUI应用程序中。我们可以用类似我们在本章前面描述的方式描述我们将要使用的工具。
- en: threading
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: threading
- en: 'This Python standard library module implements the threading functionality
    with any Python-based application that has the PyQt and PySide bindings. This
    module can be used in a wider sense than the analogous `QThread` class for specialized
    tasks in the application. But we need to know that, in PyQt/PySide GUIs, the `QThread`
    class allows communication and functionality through the signals. To use threading
    in the application, we need to import this module:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 此 Python 标准库模块使用 PyQt 和 PySide 绑定实现了任何基于 Python 的应用程序的线程功能。此模块可以在比类似 `QThread`
    类更广泛的意义上使用，用于应用程序中的专用任务。但我们需要知道，在 PyQt/PySide GUI 中，`QThread` 类允许通过信号进行通信和功能。要在应用程序中使用线程，我们需要导入此模块：
- en: '[PRE40]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We will only describe the commonly used part of this module. Full information
    about this module is available in the official documents: [https://docs.python.org/3/](https://docs.python.org/3/).
    This module uses the following useful functions:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只描述此模块的常用部分。有关此模块的完整信息可在官方文档中找到：[https://docs.python.org/3/](https://docs.python.org/3/)。此模块使用以下有用的函数：
- en: '`threading.active_count()`: This returns the number of threads that are currently
    alive.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`threading.active_count()`: 这返回当前正在运行的线程数。'
- en: '`threading.current_thread()`: This returns the thread that''s currently in
    use.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`threading.current_thread()`: 这返回当前正在使用的线程。'
- en: '`threading.get_ident()`: This returns the identifier of the current thread.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`threading.get_ident()`: 这返回当前线程的标识符。'
- en: '`threading.enumerate()`: This returns the list of all threads that are currently
    alive.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`threading.enumerate()`: 这返回当前所有正在运行的线程的列表。'
- en: '`threading.main_thread()`: This returns the main thread. In the Pythonic sense,
    this is a thread from which the Python interpreter, which operates the Python
    environment, was started.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`threading.main_thread()`: 这返回主线程。在 Python 语境中，这是启动操作 Python 环境的 Python 解释器的线程。'
- en: '`threading.stack_size(int)`: This returns the stack size that will be used
    when creating new threads. If the optional parameter is specified, it will be
    used as the stack size. Note that the parameter is a number of bytes, and that `0`
    or at least 32 KiB (`32768`) can be used; for example, 512 KiB is represented
    as `524288` in numeric form.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`threading.stack_size(int)`: 这返回创建新线程时将使用的堆栈大小。如果指定了可选参数，则将其用作堆栈大小。请注意，该参数是字节数，并且可以使用
    `0` 或至少 32 KiB (`32768`)；例如，512 KiB 以数字形式表示为 `524288`。'
- en: The `threading` module implements this functionality through several classes
    (the arguments that are provided are related to Python 3.x).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`threading` 模块通过几个类实现此功能（提供的参数与 Python 3.x 相关）。'
- en: Thread
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Thread
- en: 'The `thread` class of the `threading` module is as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`threading` 模块的 `thread` 类如下：'
- en: '[PRE41]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`group` is reserved for future extension when a `ThreadGroup` class is implemented;
    `target` is a callable object; `name` is the name of the thread; `args` is a tuple
    of arguments that are used; `kwargs` is a dictionary of the keyword arguments;
    and `daemon` sets the thread as daemonic. The `Thread` class has the following
    functions:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`group` 保留用于将来扩展，当实现 `ThreadGroup` 类时；`target` 是一个可调用对象；`name` 是线程的名称；`args`
    是用于的参数元组；`kwargs` 是关键字参数的字典；`daemon` 将线程设置为守护线程。`Thread` 类具有以下功能：'
- en: '`thread1.start()`: This starts the thread.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thread1.start()`: 这将启动线程。'
- en: '`thread1.run()`: This represents thread activity.'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thread1.run()`: 这代表线程活动。'
- en: '`thread1.join(float)`: This waits until the thread terminates. The timeout
    parameter optionally waits before blocking the operation or blocking immediately
    after termination.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thread1.join(float)`: 这等待直到线程终止。超时参数可选地等待在阻塞操作之前或终止后立即阻塞。'
- en: '`thread1.is_alive()`: This returns `True` if this thread is alive, otherwise
    it returns `False`.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thread1.is_alive()`: 如果此线程正在运行，则返回 `True`，否则返回 `False`。'
- en: 'Construction of this class usually looks like this:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 构建此类通常如下所示：
- en: '[PRE42]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Lock
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lock
- en: 'These are primitive lock objects:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是原始锁对象：
- en: '[PRE43]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `Lock` class has the following functions:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lock` 类具有以下功能：'
- en: '`thread1_lock.acquire(blocking=True, timeout=-1)`: This acquires blocking or
    non-blocking.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread1_lock.acquire(blocking=True, timeout=-1)`: 这将获取阻塞或非阻塞。'
- en: '`thread1_lock.release()`: This releases the lock.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread1_lock.release()`: 这将释放锁。'
- en: RLock
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RLock
- en: 'These are re-entrant lock objects:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是可重入锁对象：
- en: '[PRE44]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `RLock` class has the following functions:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`RLock` 类具有以下功能：'
- en: '`thread1_rlock.acquire(blocking=True, timeout=-1)`: This acquires blocking
    or non-blocking.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread1_rlock.acquire(blocking=True, timeout=-1)`: 这将获取阻塞或非阻塞。'
- en: '`thread1_rlock.release()`: This releases the lock.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread1_rlock.release()`: 这将释放锁。'
- en: Condition
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件
- en: 'These are the condition variable objects:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是条件变量对象：
- en: '[PRE45]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `Condition` class has the following functions:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`Condition`类有以下功能：'
- en: '`thread1_cond.acquire(*args)`: This acquires the underlying lock.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread1_cond.acquire(*args)`: 这获取底层的锁。'
- en: '`thread1_cond.release()`: This releases the underlying lock.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread1_cond.release()`: 这释放了底层的锁。'
- en: '`thread1_cond.wait(timeout=None)`: This waits until it''s notified, or a timeout
    occurs.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread1_cond.wait(timeout=None)`: 这将等待直到被通知或发生超时。'
- en: '`thread1_cond.wait_for(predicate, timeout=None)`: This waits until a condition
    evaluates to `True`. The predicate parameter is a callable that returns a Boolean
    (`True` or `False`).'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread1_cond.wait_for(predicate, timeout=None)`: 这将等待直到条件评估为`True`。条件参数是一个可调用对象，它返回一个布尔值（`True`或`False`）。'
- en: '`thread1_cond.notify(n=1)`: This wakes up `n` threads.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread1_cond.notify(n=1)`: 这将唤醒`n`个线程。'
- en: '`thread1_cond.notify_all()`: This wakes up all threads.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread1_cond.notify_all()`: 这唤醒所有线程。'
- en: Semaphore
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号量
- en: 'These are semaphore objects, which manage a counter that counts the number
    of releases minus the number of acquires, plus an initial value:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是信号量对象，它们管理一个计数器，该计数器计算释放次数减去获取次数，再加上初始值：
- en: '[PRE46]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `Semaphore` class has the following functions:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`Semaphore`类有以下功能：'
- en: '`thread1_sema.acquire(*args)`: This acquires the semaphore.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread1_sema.acquire(*args)`: 这获取信号量。'
- en: '`thread1_sema.release()`: This releases the semaphore.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread1_sema.release()`: 这释放信号量。'
- en: BoundedSemaphore
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有界信号量
- en: 'These are the bounded semaphore objects that check that the  current value
    doesn''t exceed its initial value:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是有界信号量对象，用于检查当前值是否不超过其初始值：
- en: '[PRE47]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Event
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: 'These are event objects that are used for communication between threads. This
    is done by managing internal flags:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是用于线程间通信的事件对象。这是通过管理内部标志来完成的：
- en: '[PRE48]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `Event` class has the following functions:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '`Event`类有以下功能：'
- en: '`thread1_event.is_set()`: This returns `True` if the internal flag is `True`.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread1_event.is_set()`: 如果内部标志为`True`，则返回`True`。'
- en: '`thread1_event.set()`: This sets the internal flag to `True`.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread1_event.set()`: 这将内部标志设置为`True`。'
- en: '`thread1_event.clear()`: This sets the internal flag to `False`.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread1_event.clear()`: 这将内部标志设置为`False`。'
- en: '`thread1_event.wait(timeout=None)`: This blocks until the flag is `True`.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread1_event.wait(timeout=None)`: 这将阻塞直到标志为`True`。'
- en: Timer
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定时器
- en: 'These are timer objects that run the timing for the action. This will only
    be run after a duration that is specified. The parameters that are provided are
    the `interval` after which the action will run; the `function` that will be run; `args` as
    the arguments that will be used; and `kwargs` as keyword arguments:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是运行动作计时的定时器对象。这将在指定的时间段之后运行。提供的参数是动作将运行的`interval`；要运行的`function`；作为将使用的参数的`args`；以及作为关键字参数的`kwargs`：
- en: '[PRE49]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `Timer` class has the following function:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`Timer`类有以下功能：'
- en: '`thread1_timer.cancel()`: This stops the timer by canceling its execution.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread1_timer.cancel()`: 这通过取消其执行来停止定时器。'
- en: Barrier
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 屏障
- en: 'These are barrier objects that are realized with a fixed number of threads
    that need to wait for each other. Threads try to pass the barrier by calling the
    `wait()` method. The parameters provided are `parties`, which is the number of
    threads; `action`, which is the callable that will be called by one of the threads;
    and `timeout`, which is the value that''s used for the `wait()` method:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是使用固定数量的线程实现的屏障对象，这些线程需要相互等待。线程通过调用`wait()`方法来尝试通过屏障。提供的参数是`parties`，即线程的数量；`action`，即将被一个线程调用的可调用对象；以及`timeout`，它是用于`wait()`方法的值：
- en: '[PRE50]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `Barrier` class has the following functions:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`Barrier`类有以下功能：'
- en: '`thread1_barrier.wait(timeout=None)`: This passes the barrier.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread1_barrier.wait(timeout=None)`: 这通过屏障。'
- en: '`thread1_barrier.reset()`: This resets the barrier and sets the empty state.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread1_barrier.reset()`: 这重置屏障并设置空状态。'
- en: '`thread1_barrier.abort()`: This aborts the barrier and sets the broken state.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread1_barrier.abort()`: 这中止屏障并设置损坏状态。'
- en: '`thread1_barrier.parties`: This returns the number of threads required to pass
    the barrier.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread1_barrier.parties`: 这返回通过屏障所需的线程数量。'
- en: '`thread1_barrier.n_waiting`: This returns the number of threads waiting in
    the barrier.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread1_barrier.n_waiting`: 这返回在屏障中等待的线程数量。'
- en: '`thread1_barrier.broken`: This returns `True` if the barrier is in a broken
    state.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread1_barrier.broken`: 如果屏障处于损坏状态，则返回`True`。'
- en: queue
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列
- en: 'In cases when several threads wait to run a task, it is very important to run
    this task using a queue. The standard library `queue` module can use the multi-producer
    and multi-consumer queue functionality in our application. Python bindings to
    Qt have not-so-simple instruments for the implementation of queues, and this module
    is widely used with threading constructions in GUIs. This module implements three
    types of queues: **First In First Out** (**FIFO**), **Last In First Out** (**LIFO**),
    and queues with priorities. To use them in our application, we need to import
    the following module:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个线程等待运行一个任务的情况下，使用队列来运行这个任务非常重要。标准库`queue`模块可以在我们的应用程序中使用多生产者和多消费者队列功能。Python对Qt的绑定有相对复杂的队列实现工具，并且这个模块在GUI的线程结构中得到了广泛的应用。此模块实现了三种类型的队列：**先进先出**（**FIFO**）、**后进先出**（**LIFO**）和带优先级的队列。要在我们的应用程序中使用它们，我们需要导入以下模块：
- en: '[PRE51]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Let's describe the most important classes and methods that can be used.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一下可以使用的最重要的类和方法。
- en: Queue
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Queue
- en: 'These are the FIFO queues with the `maxsize` upper-bound limit of items that
    can be placed in the queue:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是具有`maxsize`上限的FIFO队列，可以放置在队列中的项目数量：
- en: '[PRE52]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: LifoQueue
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LifoQueue
- en: 'These are the LIFO queues with the `maxsize` upper-bound limit of items that
    can be placed in the queue:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是具有`maxsize`上限的LIFO队列，可以放置在队列中的项目数量：
- en: '[PRE53]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: PriorityQueue
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PriorityQueue
- en: 'These are the priority queues with the `maxsize` upper-bound limit of items
    that can be placed in the queue:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是具有`maxsize`上限的优先队列，可以放置在队列中的项目数量：
- en: '[PRE54]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: SimpleQueue
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SimpleQueue
- en: 'These are unbounded FIFO queues:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是无界FIFO队列：
- en: '[PRE55]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: functions
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: functions
- en: 'The methods of the `Queue`, `LifoQueue`, `PriorityQueue`, and `SimpleQueue`
    classes that can be used are as follows:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用的`Queue`, `LifoQueue`, `PriorityQueue`, 和 `SimpleQueue`类的方法定义如下：
- en: '`queue1.qsize()`: This returns the approximate size of the queue because the
    queues usually change (`Queue`, `LifoQueue`, `PriorityQueue`, `SimpleQueue`).'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue1.qsize()`: 返回队列的大约大小，因为队列通常会变化（`Queue`, `LifoQueue`, `PriorityQueue`,
    `SimpleQueue`）。'
- en: '`queue1.empty()`: This returns `True` if the queue is approximately empty (`Queue`,
    `LifoQueue`, `PriorityQueue`, `SimpleQueue`).'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue1.empty()`: 如果队列大约为空，则返回`True`（`Queue`, `LifoQueue`, `PriorityQueue`,
    `SimpleQueue`）。'
- en: '`queue1.full()`: This returns `True` if the queue is approximately full (has
    at least one item) (`Queue`, `LifoQueue`, `PriorityQueue`).'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue1.full()`: 如果队列大约已满（至少有一个项目），则返回`True`（`Queue`, `LifoQueue`, `PriorityQueue`）。'
- en: '`queue1.put(item, block=True, timeout=None)`: This puts the specified item
    into the queue. The optional block and timeout arguments are provided (`Queue`,
    `LifoQueue`, `SimpleQueue`).'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue1.put(item, block=True, timeout=None)`: 将指定的项目放入队列。提供了可选的block和timeout参数（`Queue`,
    `LifoQueue`, `SimpleQueue`）。'
- en: '`queue1.put((priority, item), block=True, timeout=None)`: This puts the specified
    item into the queue with an integer priority value. The optional block and timeout arguments
    are provided (`PriorityQueue`).'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue1.put((priority, item), block=True, timeout=None)`: 将指定的项目以整数优先级值放入队列。提供了可选的block和timeout参数（`PriorityQueue`）。'
- en: '`queue1.put_nowait(item)`: This puts the specified item into the queue. The
    optional block and timeout arguments are provided (`Queue`, `LifoQueue`, `SimpleQueue`).'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue1.put_nowait(item)`: 将指定的项目放入队列。提供了可选的block和timeout参数（`Queue`, `LifoQueue`,
    `SimpleQueue`）。'
- en: '`queue1.put_nowait((priority, item))`: This puts the specified item into the
    queue with an integer priority value. The optional block and timeout arguments
    are provided (`PriorityQueue`).'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue1.put_nowait((priority, item))`: 将指定的项目以整数优先级值放入队列。提供了可选的block和timeout参数（`PriorityQueue`）。'
- en: '`queue1.get(block=True, timeout=None)`: This returns an item from the queue.
    The optional block and timeout arguments are provided (`Queue`, `LifoQueue`, `PriorityQueue`,
    `SimpleQueue`).'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue1.get(block=True, timeout=None)`: 从队列中返回一个项目。提供了可选的block和timeout参数（`Queue`,
    `LifoQueue`, `PriorityQueue`, `SimpleQueue`）。'
- en: '`queue1.get_nowait()`: This returns an item from the queue (`Queue`, `LifoQueue`,
    `PriorityQueue`, `SimpleQueue`).'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue1.get_nowait()`: 这从队列中返回一个项目（`Queue`, `LifoQueue`, `PriorityQueue`, `SimpleQueue`）。'
- en: '`queue1.task_done()`: This indicates that the task of the queue is complete
    (`Queue`, `LifoQueue`, `PriorityQueue`).'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue1.task_done()`: 这表示队列的任务已完成（`Queue`, `LifoQueue`, `PriorityQueue`）。'
- en: '`queue1.join()`: This blocks until all items have been processed and have completed
    (`Queue`, `LifoQueue`, `PriorityQueue`).'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue1.join()`: 这将阻塞，直到所有项目都已被处理并完成（`Queue`, `LifoQueue`, `PriorityQueue`）。'
- en: subprocess
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: subprocess
- en: 'This Python standard library module realizes the functionality related to running
    processes in a similar manner to the `QProcess` class of the Qt library. This
    module runs tasks as new processes, connects to the input/output/error pipes of
    the processes, and obtains their return codes. Previously, we implemented subprocesses
    such as running the camera device functionality. Let''s describe this module in
    more detail. To use it in our application, we need to import the following module:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Python标准库模块以类似于Qt库中的`QProcess`类的方式实现了运行进程的功能。此模块以新进程的形式运行任务，连接到进程的输入/输出/错误管道，并获取它们的返回码。之前，我们实现了运行相机设备功能等子进程。让我们更详细地描述这个模块。要在我们的应用程序中使用它，我们需要导入以下模块：
- en: '[PRE56]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The most important classes and methods that can be used in the application are
    described in the following section.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分中描述了在应用程序中可以使用的最重要的类和方法。
- en: run()
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: run()
- en: 'The `run()` method, which is available from Python version 3.5, runs the tasks
    in the new process. The syntax is as follows:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 3.5版本开始可用的`run()`方法，在新的进程中运行任务。其语法如下：
- en: '[PRE57]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The first parameter is a list with a command and arguments, as well as flags
    if they are provided. The `stdin`, `stdout`, and `stderr` arguments specify the
    executed program's `STDIN` (standard input), `STDOUT` (standard output), and `STDERR`
    (standard error). Values such as `PIPE`, `DEVNULL`, and `STDOUT` can be used.
    The `input` is used for the `communicate()` method. If `capture_output` is `True`,
    `stdout` and `stderr` will be captured. If `shell` is `True`, it specifies the
    command to execute through the shell. If `cwd` is not `None`, it changes the `cwd`
    (current working directory) before executing. `timeout` is used for the `communicate()`
    method. When the timeout expires, the child process will be killed and waited
    for. If `check` is `True`, and the process exits with a nonzero exit code, a `CalledProcessError`
    exception will be raised. `encoding` specifies which encoding will be used, such
    as `"utf-8"` or `" cp1252"`. `errors` specifies how encoding and decoding errors
    are to be handled with string values such as `"strict"`, `"ignore"`, `"replace"`,
    `"backslashreplace"`, `"xmlcharrefreplace"`,  and `"namereplace"`. If `text` is
    `True`, the file objects for `stdin`, `stdout`, and `stderr` are opened in text
    mode. `env` defines the environment variables for the new process. `universal_newlines`
    is equivalent to text and is provided for backward compatibility.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个包含命令、参数以及如果有的话标志的列表。`stdin`、`stdout`和`stderr`参数指定了执行程序的`STDIN`（标准输入）、`STDOUT`（标准输出）和`STDERR`（标准错误）。可以使用`PIPE`、`DEVNULL`和`STDOUT`等值。`input`用于`communicate()`方法。如果`capture_output`为`True`，则`stdout`和`stderr`将被捕获。如果`shell`为`True`，则指定通过shell执行的命令。如果`cwd`不是`None`，则在执行前会更改`cwd`（当前工作目录）。`timeout`用于`communicate()`方法。当超时到期时，子进程将被杀死并等待。如果`check`为`True`，并且进程以非零退出码退出，则将引发`CalledProcessError`异常。`encoding`指定将使用哪种编码，例如`"utf-8"`或`"cp1252"`。`errors`指定如何使用字符串值（如`"strict"`、`"ignore"`、`"replace"`、`"backslashreplace"`、`"xmlcharrefreplace"`和`"namereplace"`）处理编码和解码错误。如果`text`为`True`，则`stdin`、`stdout`和`stderr`的文件对象将以文本模式打开。`env`定义了新进程的环境变量。`universal_newlines`与`text`等效，并提供向后兼容性。
- en: Popen
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Popen
- en: 'The `Popen` class handles the underlying process creation and management in
    the `subprocess` module. This class provides additional optional arguments that
    can be used. The syntax of this class looks like this:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '`Popen`类在`subprocess`模块中处理底层进程创建和管理。这个类提供了可以使用的附加可选参数。这个类的语法看起来像这样：'
- en: '[PRE58]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The first parameter is a list with a command and arguments, as well as flags
    if they are provided. `bufsize` will be used with the `open()` function when creating
    the `stdin`/`stdout`/`stderr` pipe file objects. `executable` specifies a replacement
    program to execute. The `stdin`, `stdout`, and `stderr` arguments specify the
    executed program's `STDIN` (standard input), `STDOUT` (standard output), and `STDERR`
    (standard error). Valid values include `PIPE`, `DEVNULL`, and `STDOUT`.  The object
    is called in the child process just before the child is executed (POSIX only)
    if `preexec_fn` is set. If `close_fds` is `True`, all file descriptors will be
    closed before execution, except `0`, `1`, and `2`. The command will get executed
    through the shell if the shell is `True`. If `cwd` is not `None`, it changes the
    `cwd` (current working directory) before executing. `env` defines the environment
    variables for the new process. `universal_newlines` is equivalent to text and
    is provided for backward compatibility. `startupinfo` will be a `STARTUPINFO`
    object that is passed to the `CreateProcess` function with creation flags. If
    `restore_signals` is `True`, all signals that are set to `SIG_IGN` are restored
    to `SIG_DFL` before execution (POSIX only). If `start_new_session` is `True`,
    a `setsid()` system call will be made in the child process prior to the execution
    of the subprocess (POSIX only). `pass_fds` is a sequence of file descriptors that will
    be kept open between the parent and child (POSIX only). `encoding` specifies which
    encoding will be used, such as `"utf-8"` or `"cp1252"`. `errors` specifies how
    encoding and decoding errors are to be handled, with string values such as `"strict"`,
    **`"ignore"`**, `"replace"`, `"backslashreplace"`, `"xmlcharrefreplace"`, and
    `"namereplace"`. If `text` is `True`, the file objects for `stdin`, `stdout`,
    and `stderr` are opened in text mode.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个包含命令、参数以及（如果提供）标志的列表。`bufsize`将在创建`stdin`/`stdout`/`stderr`管道文件对象时与`open()`函数一起使用。`executable`指定要执行的替换程序。`stdin`、`stdout`和`stderr`参数指定要执行的程序的`STDIN`（标准输入）、`STDOUT`（标准输出）和`STDERR`（标准错误）。有效值包括`PIPE`、`DEVNULL`和`STDOUT`。如果设置了`preexec_fn`，则对象将在子进程执行之前在子进程中调用（仅限POSIX）。如果`close_fds`为`True`，则在执行之前将关闭所有文件描述符，除了`0`、`1`和`2`。如果`shell`为`True`，则将通过shell执行命令。如果`cwd`不是`None`，则在执行之前将更改`cwd`（当前工作目录）。`env`定义了新进程的环境变量。`universal_newlines`等同于文本，并提供向后兼容性。`startupinfo`将是一个`STARTUPINFO`对象，它将带有创建标志传递给`CreateProcess`函数。如果`restore_signals`为`True`，则在执行之前将所有设置为`SIG_IGN`的信号恢复为`SIG_DFL`（仅限POSIX）。如果`start_new_session`为`True`，则在子进程执行子进程之前将执行`setsid()`系统调用（仅限POSIX）。`pass_fds`是父进程和子进程之间保持打开的文件描述符序列（仅限POSIX）。`encoding`指定将使用哪种编码，例如`"utf-8"`或`"cp1252"`。`errors`指定如何处理编码和解码错误，字符串值包括`"strict"`、**`"ignore"`**、`"replace"`、`"backslashreplace"`、`"xmlcharrefreplace"`和`"namereplace"`。如果`text`为`True`，则将`stdin`、`stdout`和`stderr`的文件对象以文本模式打开。
- en: functions
  id: totrans-496
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'The following methods can be used with this module:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 可以与该模块一起使用的以下方法：
- en: '`subprocess1.poll()`: This checks if the sub-process has terminated.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '`subprocess1.poll()`: 这检查子进程是否已终止。'
- en: '`subprocess1.wait(timeout=None)`: This waits for the termination of the sub-process
    with a timeout, if specified.'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '`subprocess1.wait(timeout=None)`: 如果指定了超时，则等待子进程终止。'
- en: '`subprocess1.communicate(input=None, timeout=None)`: This interacts with the
    process by sending the data to `STDIN` and reading the data from `STDOUT`/`STDERR`,
    while waiting for termination. The input can be data to be sent to the sub-process.'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '`subprocess1.communicate(input=None, timeout=None)`: 通过向子进程发送数据并从`STDOUT`/`STDERR`读取数据，同时等待终止来与进程交互。输入可以是发送到子进程的数据。'
- en: '`subprocess1.send_signal(signal)`: This sends the signal to the sub-process.
    It has the following functions:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '`subprocess1.send_signal(signal)`: 这向子进程发送信号。它有以下功能：'
- en: '`subprocess1.terminate()`: This terminates the sub-process using OS parameters.'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subprocess1.terminate()`: 使用操作系统参数终止子进程。'
- en: '`subprocess1.kill()`: This kills the sub-process using OS parameters.'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subprocess1.kill()`: 使用操作系统参数终止子进程。'
- en: '`subprocess1.args`: This returns the arguments passed to `Popen`.'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subprocess1.args`: 这返回传递给`Popen`的参数。'
- en: '`subprocess1.stdin`: This returns the argument passed to `Popen` standard input.'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subprocess1.stdin`: 这返回传递给`Popen`标准输入的参数。'
- en: '`subprocess1.stdout`: This returns the argument passed to `Popen` standard
    output.'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subprocess1.stdout`: 这返回传递给`Popen`标准输出的参数。'
- en: '`subprocess1.stderr`: This returns the argument passed to `Popen` standard
    error.'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subprocess1.stderr`: 这返回传递给`Popen`标准错误的参数。'
- en: '`subprocess1.pid`: This returns the process ID of the sub-process.'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subprocess1.pid`: 这将返回子进程的进程 ID。'
- en: '`subprocess1.returncode`: This returns the return code of the sub-process.'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subprocess1.returncode`: 这将返回子进程的返回代码。'
- en: multiprocessing
  id: totrans-510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: multiprocessing
- en: 'This Python standard library package manages the spawning processes that can
    be used in the application. When using local and remote concurrency, this instrument
    side steps the **Global Interpreter Lock** (**GIL**) limitations by using sub-processes
    instead of threads, and, as a result, effectively leverages multiple processors
    if the device has them. The API of the multiprocessing package is similar to the
    `threading` module, and the methods mostly replicate the `Thread` class of the
    `threading` module, similar to `Queue` of the `queue` module that was shown earlier.
    To use it in our application, we need to import the following package:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Python 标准库包管理了在应用程序中可以使用的进程创建。当使用本地和远程并发时，这个工具通过使用子进程而不是线程来绕过 **全局解释器锁**
    (**GIL**) 的限制，如果设备有多个处理器，则可以有效地利用多个处理器。multiprocessing 包的 API 与 `threading` 模块类似，方法大多复制了
    `threading` 模块的 `Thread` 类，类似于前面展示的 `queue` 模块的 `Queue`。为了在我们的应用程序中使用它，我们需要导入以下包：
- en: '[PRE59]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Process
  id: totrans-513
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Process
- en: 'This class represents the process objects that enable multiprocessing and the
    activity of the separate processes. The syntax is as follows:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类表示了能够实现多进程和单独进程活动的进程对象。语法如下：
- en: '[PRE60]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The parameters have similar meanings to those in the `Thread` class of the
    threading module. The methods that are used in this class are as follows:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的含义与 `threading` 模块的 `Thread` 类中的参数类似。在这个类中使用的如下方法：
- en: '`process1.run()`: This represents the activity of the processes.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '`process1.run()`: 这代表进程的活动。'
- en: '`process1.start()`: This starts the processes.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '`process1.start()`: 这将启动进程。'
- en: '`process1.join(float)`: This waits until the process terminates. The timeout
    parameter (optional) waits before blocking the operation or blocking immediately
    after termination.'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '`process1.join(float)`: 这将等待直到进程终止。超时参数（可选）在阻塞操作之前等待，或者在终止后立即阻塞。'
- en: '`process1.is_alive()`: This returns `True` if this process is alive, otherwise
    it returns `False`.'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '`process1.is_alive()`: 如果此进程正在运行，则返回 `True`，否则返回 `False`。'
- en: '`process1.close()`: This closes the process and releases all associated resources.'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '`process1.close()`: 这将关闭进程并释放所有相关资源。'
- en: '`process1.kill()`: This kills the process.'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '`process1.kill()`: 这将杀死进程。'
- en: '`process1.terminate()`: This terminates the process.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '`process1.terminate()`: 这将终止进程。'
- en: '`process1.name`: This returns the name of the process.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '`process1.name`: 这将返回进程的名称。'
- en: '`process1.daemon`: This returns the daemon flag of the process, that is, `True`
    or `False`.'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '`process1.daemon`: 这将返回进程的守护进程标志，即 `True` 或 `False`。'
- en: '`process1.pid`: This returns the ID of the process.'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '`process1.pid`: 这将返回进程的 ID。'
- en: '`process1.exitcode`: This returns the sub-process exit code.'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '`process1.exitcode`: 这将返回子进程的退出代码。'
- en: '`process1.authkey`: This returns the authentication key of the process.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '`process1.authkey`: 这将返回进程的认证密钥。'
- en: '`process1.sentinel`: This returns the numeric handle of a system object that
    will be ready when the process ends.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '`process1.sentinel`: 这将返回系统对象数字句柄，当进程结束时将准备好。'
- en: Connection
  id: totrans-530
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Connection
- en: 'This class creates the connection objects that allow us to send and receive
    pickleable objects or strings. The syntax is as follows:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类创建了连接对象，允许我们发送和接收可序列化的对象或字符串。语法如下：
- en: '[PRE61]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The methods that can be used are as follows:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用的方法如下：
- en: '`conn.send(obj)`: This sends the pickleable object to the other end of the
    connection.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '`conn.send(obj)`: 这将可序列化的对象发送到连接的另一端。'
- en: '`conn.recv()`: This returns an object that''s received from the other end of
    the connection.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '`conn.recv()`: 这将返回从连接另一端接收到的对象。'
- en: '`conn.fileno()`: This returns the file descriptor or handle of the connection.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '`conn.fileno()`: 这将返回连接的文件描述符或句柄。'
- en: '`conn.close()`: This closes the connection.'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '`conn.close()`: 这将关闭连接。'
- en: '`conn.poll(timeout)`: This returns `True` if any data is available to be read.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '`conn.poll(timeout)`: 如果有可读数据，则返回 `True`。'
- en: '`conn.send_bytes(buffer, offset, size)`: This sends the data from a bytes-like
    object. The data will read from the position in** `buffer`** if `offset` is specified,
    with the `size` of bytes, if specified.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '`conn.send_bytes(buffer, offset, size)`: 这将从字节对象发送数据。如果指定了 `offset`，则将从 `buffer`
    中的位置读取数据，如果指定了 `size`，则以字节数为单位。'
- en: '`conn.recv_bytes(maxlength)`: This returns the message of byte data received
    from the other end of the connection. `maxlength` limits the message, if specified.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '`conn.recv_bytes(maxlength)`: 这返回从连接的另一端接收到的字节数据的消息。如果指定了`maxlength`，则限制消息。'
- en: '`conn.recv_bytes_into(buffer, offset)`: This reads the message of byte data that''s
    received from the other end of the connection and returns the number of bytes
    in the message. If `offset` is specified, the message will be written into `buffer`
    from that position.'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '`conn.recv_bytes_into(buffer, offset)`: 这读取从连接的另一端接收到的字节数据的消息，并返回消息中的字节数。如果指定了`offset`，则消息将从该位置写入`buffer`。'
- en: 'Connections are usually created with the `Pipe` class. Constructing a connection
    like this has the following syntax:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 连接通常使用`Pipe`类创建。构建此类连接的语法如下：
- en: '[PRE62]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If the duplex parameter is `True`, the pipe is bidirectional, and if it''s
    `False`, the pipe is unidirectional. This means that `conn1` is used for receiving
    messages and `conn2` is used for sending messages. An example of connections is
    as follows:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`duplex`参数为`True`，则管道是双向的；如果为`False`，则管道是单向的。这意味着`conn1`用于接收消息，而`conn2`用于发送消息。以下是一个连接的示例：
- en: '[PRE63]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here, we have created functions with the send methods of the `Connection` class;
    the `Pipe` class was used for the connection, and the methods that were described
    previously were also used. This construction is not random. In terms of multiprocessing,
    we need to operate the processes inside the **`if __name__ == "__main__"`** instruction,
    or call the function with multiprocessing functionality. With the `multiprocessing`
    package, classes such as `Pool`, which creates the pool of processes; `Queue`,
    which creates the queues; `Manager`, which controls the server process that manages
    shared objects; and the `Listener` and `Client` classes of the connection module,
    are also available. It is recommended that you learn about these classes and modules.
    In addition, the multiprocessing package has the following methods, which can
    be useful:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了具有`Connection`类的发送方法的函数；使用了`Pipe`类进行连接，并且也使用了之前描述的方法。这种构建不是随机的。在多进程方面，我们需要在**`if
    __name__ == "__main__"`**指令内操作进程，或者调用具有多进程功能的功能。使用`multiprocessing`包，类如`Pool`（创建进程池）、`Queue`（创建队列）、`Manager`（控制管理共享对象的服务器进程）以及连接模块的`Listener`和`Client`类也是可用的。建议您了解这些类和模块。此外，多进程包还具有以下方法，可能很有用：
- en: '`multiprocessing.active_children()`: This returns all the live children of
    the current process.'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multiprocessing.active_children()`: 这返回当前进程的所有活动子进程。'
- en: '`multiprocessing.cpu_count()`: This returns the number of CPUs used in the
    device.'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multiprocessing.cpu_count()`: 这返回设备中使用的CPU数量。'
- en: '`multiprocessing.current_process()`: This returns the current process.'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multiprocessing.current_process()`: 这返回当前进程。'
- en: Summary
  id: totrans-550
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter completes the basic part of this book's material. The use of threads
    improves the productivity of the application. The importance and size of the instruments
    is such a vast subject that we would need a separate book to cover it all. This
    is why we just looked at the starting points. More information about these interesting
    and useful tools is available in the official documentations of PySide2 ([https://doc.qt.io/qtforpython/index.html](https://doc.qt.io/qtforpython/index.html)),
    PyQt5 ([https://www.riverbankcomputing.com/static/Docs/PyQt5/](https://www.riverbankcomputing.com/static/Docs/PyQt5/)),
    and of course Python ([https://docs.python.org/3/](https://docs.python.org/3/)). Constructions
    of multithreading and multiprocessing and implementing them in our application
    have pole positions because they make the GUI application comfortable and user-friendly.
    Almost everything that's necessary for use in GUI development was covered in this
    chapter.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完成了本书材料的基本部分。线程的使用提高了应用程序的生产力。仪器的重性和大小是一个如此庞大的主题，以至于我们需要一本书来涵盖所有内容。这就是为什么我们只看了起点。关于这些有趣且有用的工具的更多信息可以在PySide2的官方文档（[https://doc.qt.io/qtforpython/index.html](https://doc.qt.io/qtforpython/index.html)）、PyQt5（[https://www.riverbankcomputing.com/static/Docs/PyQt5/](https://www.riverbankcomputing.com/static/Docs/PyQt5/））和当然还有Python（[https://docs.python.org/3/](https://docs.python.org/3/)）的官方文档中找到。多线程和多进程的构建以及在我们应用程序中的实现具有核心地位，因为它们使得GUI应用程序舒适且用户友好。本章涵盖了GUI开发中所需的所有必要内容。
- en: The next chapter will complete this book. We will finalize our GUI application,
    provide mechanisms for embedding the application in different platforms, and try
    out some code while explaining the basics.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将完成这本书。我们将最终确定我们的图形用户界面应用程序，提供将应用程序嵌入不同平台的方法，并在解释基础知识的同时尝试一些代码。
