- en: Threading and Multiprocessing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen throughout this book, if we keep on adding new functionalities
    to our GUI application, we will have some problems, such as the application freezing,
    operation speed dropping, problems with simultaneous execution, and many more
    uncomfortable cases. These are the problems that occur in any multi-functional
    application. In our own experience, when we use Microsoft Office, design tools,
    or other software that uses a lot of memory resources, we encounter various waits,
    freezes, and so on. If we add to the functionality of the app that we are creating,
    at some stage, the app will become slow (in the best case) and will be not as
    functional as we want it to be. Why does this happen? In most cases, almost every
    operating system details the processes and threads of execution. We can open the
    Task Manager of our operating system and see that various programs are running
    as processes (tasks). They have **process IDs** (**PIDs**), names, and so on.
    These applications (processes) operate with some internal tasks and usually have
    threads of execution from additional operations. They can also operate with external
    tasks, that is, independent processes. These processes can contain multiple threads
    that execute tasks concurrently. When our created application is running in one
    process and as one thread and the app has a lot of tasks, the available memory
    resources may be not enough to run them all. The solution to this problem is to
    split tasks into different threads and maybe into different processes if need
    be. This chapter will introduce these aspects of GUI creation. We will explore
    Qt library instruments such as `QProcess` and `QThread`. We will also demonstrate
    Python standard library tools that can easily be implemented in the GUI. We will
    also examine the advantages and disadvantages of these instruments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python standard library tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Processes (in computing) are the main part of any environment. In a broad sense,
    a process is an instance of a program that executes the application. It can have
    more than one process for operating tasks and usually includes multiple threads.
    If only a single CPU is used, only one process can be executed at any one time.
    However, if the CPU has multiple cores, the execution of tasks can be split between
    these cores. However, this doesn't mean that a multi-core architecture concurrently
    executes all processes/tasks that operate. In reality, the system multitasks,
    which means that when new tasks start, they can interrupt tasks that have already
    started, they can be interrupted by new tasks, and they can be started again.
    In this way, the execution of the processes is split into the segments that operate
    concurrently. A common situation is when the main program has a single parent
    process and the child processes are executed in parallel. Communication between
    processes usually occurs by using the input channel (stream of data) `STDIN` (standard
    input) and two predefined output channels (separate streams of data) – `STDOUT`
    (standard output) and `STDERR` (standard error), in this case. The channels of
    the process are also known as the **read** (`STDOUT` and `STDERR`) and **write**
    (`STDIN`) channels. One of the ways that the Qt library runs new processes and
    implements **Inter-Process Communication** (**IPC**) in applications is by using
    the `QProcess` class. This class allows us to manage an application's external
    processes. `QProcess` is a cross-platform class that's available in the `QtCore`
    module of the Qt library. In an application, it can be used to start external
    programs as child processes and communicate with them, depending on the operating
    tasks. This mechanism is an API that controls and monitors the states of the child
    processes. The `QProcess` class also provides access to the I/O (input/output)
    channels of child processes by inheriting from the **`QtCore.QIODevice`** class.
    A simple example of these operations is running a third-party application that
    implements additional functionality, such as opening a web browser or running
    servers. It also can be used for long-term tasks, including loops and estimation.
    However, the `QProcess` class does not support some platforms, such as iOS. Therefore,
    the application can use Python standard library tools such as the `subprocess` module
    and the multiprocessing package.
  prefs: []
  type: TYPE_NORMAL
- en: Application processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand application processes that occur when we create and run GUI or
    non-GUI applications, we need to know about the Qt modules and the inheritance
    scheme of the classes that participate in the application''s processes. The `QCoreApplication`
    class of the `QtCore` module inherits from the `QObject` class and creates the
    event loop of non-GUI applications. The `QGuiApplication` class of the `QtGui`
    module inherits `QCoreApplication` and manages the control flow with the main
    settings of the GUI app. The `QApplication` class of the `QtWidgets` module inherits
    `QGuiApplication` and manages the control flow with the main settings of the GUI
    application relative to the `QWidget` class, based on additional functionality.
    To access the application object, you can use global pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QtCore.QCoreApplication.instance()`: For `QCoreApplication`, `QGuiApplication`,
    and `QApplication`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtGui.QGuiApplication.qGuiApp`: For `QGuiApplication`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtWidgets.QApplication.qApp`: For `QApplication`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the application, long-term tasks (loops) can also be used with the `processEvents()`
    static method of the `QCoreApplication` class. The creation of long-term operations
    usually looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This `while` instruction is infinite and will print the string until it is stopped
    by pressing *Ctrl* + *Z*.
  prefs: []
  type: TYPE_NORMAL
- en: QProcess
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class provides Qt library instruments that you can use when working with
    processes in an application. Using this class starts external tasks (programs)
    in separate processes and organizes communication with them. The declaration syntax
    of this class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`QProcess` inherits from `QIODevice`, which is the base interface class of
    all I/O devices in the Qt library, and improves functionality with the following
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These functions set the parameters/properties of the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.setArguments([str])`: This sets the arguments, specified in the parameter,
    for the called program when this process starts.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.setEnvironment(["environment"])`: This sets the environment, specified
    in the parameter, that will be used with this process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.setInputChannelMode(QtCore.QProcess.InputChannelMode)`: This sets
    the channel mode, specified in the parameter, for the `STDIN` of this process.
    The available input channel modes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`QtCore.QProcess.ManagedInputChannel`**—`0`: This process manages the input
    of the running process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`QtCore.QProcess.ForwardedInputChannel`**—`1`: This process forwards the
    input of the main process onto the running process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`process.setProcessChannelMode(QtCore.QProcess.ProcessChannelMode)`: This sets
    the channel mode, specified in the parameter, for the `STDOUT` (standard output)
    of this process. The available process channel modes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QtCore.QProcess.SeparateChannels`—`0`: `STDOUT` and `STDERR` data in separate
    internal buffers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QProcess.MergedChannels`—`1`: This merges the output of the process
    into the `STDOUT` (standard output) channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QProcess.ForwardedChannels`—`2`: This forwards the output of the process
    to the main process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QProcess.ForwardedErrorChannel`—`4`: This forwards the `STDERR` (standard
    error) to the main process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`process.setProcessEnvironment(QtCore.QProcessEnvironment)`: This sets the
    environment, specified in the parameter, that will be used with this process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.setProcessState(QtCore.QProcess.ProcessState)`: This sets the process
    state, specified in the parameter, of this process. The available states are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QtCore.QProcess.NotRunning`—`0`: This process is not running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QProcess.Starting`—`1`: This process is starting, but the program that
    the process operates hasn''t been invoked yet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QProcess.Running`—`2`: This process is running and ready.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`process.setProgram("program")`: This sets the program, specified in the parameter,
    that will be started in this process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`process.setReadChannel(QtCore.QProcess.ProcessChannel)`: This sets the channel,
    specified in the parameter, for this process. The available process channels are
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QProcess.StandardOutput`—`0`: The `STDOUT` (standard output) of the
    process.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QProcess.StandardError`—`1`: The `STDERR` (standard error) of the process.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`process.setStandardErrorFile("path/to/the/filename", QtCore.QIODevice.OpenMode)`:
    This redirects the `STDERR` (standard error) to the file (the first parameter)
    relative to the file mode (the second parameter).'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.setStandardInputFile("path/to/the/filename")`: This redirects the
    `STDIN` (standard input) to the file specified in the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.setStandardOutputFile("path/to/the/filename", QtCore.QIODevice.OpenMode)`:
    This redirects the `STDOUT` (standard output) to the file (the first parameter)
    relative to the file mode (the second parameter).'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.setStandardOutputProcess(QtCore.QProcess)`: This pipes the `STDOUT`
    (standard output) stream of this process to the `STDIN` (standard input) of the
    process specified in the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.setWorkingDirectory("path/to/dir")`: This sets the working directory,
    specified in the parameter, where this process will be started.'
  prefs: []
  type: TYPE_NORMAL
- en: is
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This function returns a Boolean value (`bool`) related to the process'' state:'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.isSequential()`: This returns `True` if this process is sequential.'
  prefs: []
  type: TYPE_NORMAL
- en: functional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These functions relate to the current values of the process, changes in functionality,
    and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.arguments()`: This returns the list of the most -recently started
    process'' command-line arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.atEnd()`: This returns `True` if this process is not running, and
    there is no more data to read.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.bytesAvailable()`: This returns the bytes that are available for reading
    with this process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.bytesToWrite()`: This returns the bytes that are available for writing
    with this process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.canReadLine()`: This returns `True` if a complete line of data can
    be read with this process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.close()`: This kills this process and closes all communications.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.closeReadChannel(QtCore.QProcess.ProcessChannel)`: This closes the
    read channel specified in the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.closeWriteChannel()`: This closes the channel once all the data has
    been written.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.environment()`: This returns the environment for this process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.error()`: This returns the last error that occurred of the `QtCore.QProcess.ProcessError`
    type. The available process errors are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QtCore.QProcess.FailedToStart`—`0`: This process failed to start.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QProcess.Crashed`—`1`: This process crashed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`QtCore.QProcess.Timedout`**—`2`: This process timed out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QProcess.ReadError`—`3`: An error with reading from this process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QProcess.WriteError`—`4`: An error with writing to this process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QProcess.UnknownError`—`5`: An unknown error in this process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`process.execute("command")`: This starts the command, specified in the parameter,
    in the new process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.execute("program", "arguments")`: This starts the program (the first
    parameter) with arguments (the second parameter) in the new process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.exitCode()`: This returns the last process exit code.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.exitStatus()`: This returns the last process exit status of the **`QtCore.QProcess.ExitStatus`**
    type. The available exit statuses are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QtCore.QProcess.NormalExit`—`0`: This process exited normally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QProcess.CrashExit`—`1`: This process crashed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`process.inputChannelMode()`: This returns the channel mode of the `QtCore.QProcess.InputChannelMode`
    type for this process'' `STDIN` (standard input) channel.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.kill()`: This kills this process and exits immediately.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.nullDevice()`: This is the null device of the operating system that''s
    used to discard the output streams of a process or empty files for input streams.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.open(QtCore.QIODevice.OpenMode)`: This opens the process with the
    mode specified in the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.processChannelMode()`: This returns the channel mode of the `QtCore.QProcess.ProcessChannelMode`
    type for the standard output and standard error channels of this process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.processEnvironment()`: This returns the environment of the `QtCore.QProcessEnvironment`
    type for this process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.processId()`: This returns the native ID for the running process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.program()`: This returns the last program that started with this process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.readAllStandardError()`: This returns all the error data of the `QtCore.QByteArray`
    type from the `STDERR` of this process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.readAllStandardOutput()`: This returns all the data of the `QtCore.QByteArray`
    type from the `STDOUT` of this process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.readChannel()`: This returns the read channel of the **`QtCore.QProcess.ProcessChannel`**
    type for this process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.readData(int)`: This reads the bytes limited to a maximum size, specified
    in the parameter, into data.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.start(QtCore.QIODevice.OpenMode)`: This starts the program with the
    mode specified in the parameter in the new process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.start("command", QtCore.QIODevice.OpenMode)`: This starts the command
    (the first parameter) with the mode (the second parameter) in the new process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.start("program", ["arguments"], QtCore.QIODevice.OpenMode)`: This
    starts the program (the first parameter) with arguments (the second parameter)
    relative to the mode (the third parameter) in the new process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.startDetached()`: This starts the program in the new process, then
    detaches from this process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.startDetached(int)`: This starts the program in the new process with
    the process ID specified in the parameter, then detaches from this process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.startDetached("command")`: This starts the command specified in the
    parameter in the new process, then detaches from this process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.startDetached("program", ["arguments"])`: This starts the program
    (the first parameter) with arguments (the second parameter) in the new process,
    then detaches from this process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.startDetached("program", ["arguments"], "path/to/dir")`: This starts
    the program (the first parameter) with arguments (the second parameter) and the
    working directory (the third parameter) in the new process, then detaches from
    this process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.state()`: This returns the current state of the `QtCore.QProcess.ProcessState`
    type for this process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.systemEnvironment()`: This returns the system environment for this
    process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.terminate()`: This terminates the process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.waitForBytesWritten(int)`: This waits for the number of milliseconds
    specified in the parameter until a payload of buffered written bytes has been
    written.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.waitForFinished(int)`: This waits for the number of milliseconds specified
    in the parameter, blocking the process until this process has finished.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.waitForReadyRead(int)`: This waits for the number of milliseconds specified
    in the parameter, blocking the process until new data is available for reading.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.waitForStarted(int)`: This waits for the number of milliseconds specified
    in the parameter, blocking the process until this process has started.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.workingDirectory()`: This returns the working directory that''s used
    for this process.'
  prefs: []
  type: TYPE_NORMAL
- en: signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following signals are available with the `QProcess` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.errorOccurred(QtCore.QProcess.ProcessError)`: This signal is emitted
    when an error occurs with this process, with the error passed in the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.finished(int, QtCore.QProcess.ExitStatus)`: This signal is emitted
    when this process has finished, with the exit code and the exit status passed
    in the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.readyReadStandardError()`: This signal is emitted when this process
    makes new data available on the `STDERR` channel.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.readyReadStandardOutput()`: This signal is emitted when this process
    makes new data available on the `STDOUT` channel.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.started()`: This signal is emitted when this process starts.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process.stateChanged(QtCore.QProcess.ProcessState)`: This signal is emitted
    when the state of this process changes, with the new process state passed in the
    parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: QProcessEnvironment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class creates the environment variables that can be used when you start a
    program that uses processes in the application. The process'' environment variables
    are represented as a set of *key/value* pairs, such as `["PATH=/Path/To/dir",
    "USER=user"]`.  The declaration syntax of this class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `QProcessEnvironment` class improves functionality with the following functions.
  prefs: []
  type: TYPE_NORMAL
- en: is
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This function returns a Boolean value (`bool`) related to the process environment
    states:'
  prefs: []
  type: TYPE_NORMAL
- en: '`process_env.isEmpty()`: This returns `True` if this process environment is
    empty and doesn''t have any environment variables.'
  prefs: []
  type: TYPE_NORMAL
- en: functional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These functions relate to the current values of the process environment, changes
    in functionality, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '`process_env.clear()`: This clears all key/value pairs from this process environment.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process_env.contains(str)`: This returns `True` if the variable with the name
    specified in the parameter is found in this process environment.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process_env.insert(QtCore.QProcessEnvironment)`: This inserts the contents
    of the process environment specified in the parameter in this process environment.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process_env.insert(str, str)`: This inserts the key (the first parameter)
    and value (the second parameter) of the environment variable in this process environment.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process_env.keys()`: This returns a list with all the environment variable
    keys of this process environment.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process_env.remove(str)`: This removes the environment variable that contains
    the name (key) specified in the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process_env.swap(QtCore.QProcessEnvironment)`: This swaps this process environment
    with the process environment specified in the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process_env.systemEnvironment()`: This returns the system environment of the
    **`QtCore.QProcessEnvironment`** type for the process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process_env.toStringList()`: This converts this process environment into a
    list of strings of key/value pairs.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process_env.value(str, str)`: This returns the value of the name (key) specified
    in the first parameter, or the default value (the second parameter) if the variable
    with the name passed in does not exist in this process environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Process example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at an example of the using `QProcess` class by making some additions
    to our application. We will use the QML script we used previously in this book
    to visualize the buttons in the applications section of the tab widget, and we
    will run these apps by clicking on a few of them. Note that processes created
    with the `QProcess` class may not work with some operating systems, and for this
    reason, the `subprocess` module constructions are still commented. So, to do this,
    we need to copy the directories we used with the QML implementation, such as `qmls/`
    and `jscripts/`, into our working directory. We also need to copy the `u_qml.qml`
    file. Now, we need to create new `apps.qml` files in both the `App/App_PySide2/`
    and `App/App_PyQt5/` directories, which will contain the QML script for the buttons
    in the applications. The `apps.qml` file looks as follows, and can be copied and
    modified from the `qmls/UGrid.qml` file we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the QML import section, a base `Rectangle`, along with its properties,
    and a grid layout for the buttons to the `apps.qml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is the parent rectangle for all the rectangles in QML. Note that, while
    writing this book, the versions of Qt changed, and the `QtQuick` versions changed
    as well. So, before using the QML script, it is recommended that you check the
    available versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the first glow button, which will be used for running the video camera,
    to the grid layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is the first rectangle with a glow effect and will call the video camera
    application in a separate window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the second glow button, which will be used to run the QML application example,
    to the grid layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is the second rectangle with a glow effect, which will call the QML application
    through the created `clicked()` signal that will be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the third glow button, which will be used to run Jupyter Notebook, to the grid
    layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The third rectangle with a glow effect will start the Jupyter Notebook in the
    separated process that's created with the `QProcess` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the fourth glow button, which will be used to run the default
    web browser, to the grid layout, thereby completing the QML file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The fourth rectangle with a glow effect will open the default web browser for
    the system in a separate process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to make some changes in the `u_app.py` file to implement the QML
    script in the application that will run new processes, such as QML apps and other
    third-party programs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the following lines to the import section of each file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following to the PySide2 `u_app.py` file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to the PyQt5 `u_app.py` file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add/change some lines to/in the `__init__()` function of the `UApp` class,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The created signals in the QML file will be used to call the functions related
    to new processes that will run new tasks. Now, we need to add some functions to
    the `UApp` class to realize the QML and run the processes with specified applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the resize event handler in order to resize the QML elements in the view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This event handler will resize the tab of the widget that contains the QML elements
    when the window of the application is resized with a mouse or in another way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the first process for running a video camera device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will start the camera widget in the new process. The camera device functionality
    provided by the Qt library may vary from version to version. If you are using
    an operating system that requires root privileges, you need to start this functionality
    according to these requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the second process, which will run the QML application we created previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will run the QML application in the new process. We also need to create
    a `u_qml.py` file in both the `App/App_PySide2/` and `App/App_PyQt5/` directories
    and add the following lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines in each `import` section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines to the PySide2 `u_qml.py` file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines to the PyQt5 `u_qml.py` file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the following lines, which are for starting the QML in the application,
    to both files:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We change this file in a similar manner to the QML application – without using
    the classes. However, the `u_qml.py` file that we created in [Chapter 2](e8aa0a88-3426-4280-86f9-8d39cf7f6391.xhtml),
    *An Overview of QML*, can be used with additional modifications as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the third process in order to run Jupyter Notebook in a specified browser
    (which can be changed to your favorite browser; if one is not specified, the default
    browser will be used):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This function will start Jupyter Notebook in the new process, which will be
    displayed in the Firefox web browser. If we want to open the notebook in our default
    browser, this can be done by not specifying any browser in the browser parameter
    of the `start()` function. Or we can open with our favorite by specifying the
    browser parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the fourth process, which will run the default web browser with
    the Python standard library''s `webbrowser` module, and the specified URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are specifying the command in the `start()` function of the `QProcess`
    class, similar to the construction of the `subprocess` module of the Python standard
    library. All of these functions for starting processes emulate the toggling of
    the buttons. When the button is clicked, the process will start. When it is no
    longer being clicked, the `kill()` function will be called. These functions are
    optional and can be used to start another program.
  prefs: []
  type: TYPE_NORMAL
- en: Threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next element of execution operations that's related to the environment of
    applications and programs is threads. Threads are very similar to processes in
    nature, but there are some differences. Threads do things in parallel. In a broad
    sense, the thread of an execution is a sequence of instructions that can be managed
    independently by a scheduler of the operating system's operations. In most applications
    that are available at the moment, a thread is a component of a process. In the
    world around us, we usually encounter multitasking OSes that provide a multithreading
    model that allows multiple threads to exist within the context of one process.
    So, how we can describe threads?  When you are using your favorite operating system,
    or you are running your favorite editor, for example, the Spyder editor included
    in the Anaconda toolset, you want to find out the latest news and open a web browser.
    Let's say you open your media player to listen to some music or watch a video – these
    applications are usually used when you are doing something like this. This is
    an example of several processes working in parallel using the multitasking model
    of execution. Moreover, as we can see, each of these processes has other internal
    processes that execute in parallel in one single process. While you are using
    the text field of the editor, you can run another option of this editor simultaneously.
    This behavior describes the sense of the threads in an application – concurrency
    within one single process.
  prefs: []
  type: TYPE_NORMAL
- en: How we can describe concurrent execution? As we described in the *Processes*
    section of this chapter, parallel execution on a CPU with a single core is an
    illusion. For processes, this is as an interruption of a process when another
    process starts, and then another process is interrupted when another process starts.
    This situation with processes can be extrapolated to the execution of a program's
    segments of one single process. When a process starts, it always executes one
    code segment. This is known as a process having one thread. We can split the execution
    of a process into two code segments, which will make it look like two different
    code sequences are operating simultaneously. When we have a single-core CPU, concurrency
    is realized in a similar way to the parallel execution of processes. If we have
    a multi-core CPU, these threads can be assigned to multiple cores. This is concurrency
    in the real sense of the word.
  prefs: []
  type: TYPE_NORMAL
- en: 'In regard to GUI application development with Qt (although this is not only related
    to Qt), there are two types of threads that we need to know about. The first type
    is a GUI thread that is used as the main thread of the application. This is started
    by calling the `QtCore.QApplication.exec()` function when we run our application.
    All GUI components, such as widgets, and some classes, such as `QPixmap`, must
    run in this thread. The second type is a secondary thread, also known as the worker
    thread, which is used to offload the main thread and run long-term tasks. All
    the threads that have been demonstrated in this book that provide additional functionality,
    such as pandas, are worker threads. Each thread has its own stack (call history
    and local variables) with a size that is usually defined by the operating system.
    Threads share the same address space. We need to know about the following if we
    want to use threads in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of available threads for the real concurrent execution is equal to
    the number of available CPU cores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several threads cannot access the same object at one time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All thread objects can only be used safely when other threads are not related
    to them and objects don't have an implicit coupling with other threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot change something in the GUI thread from the worker thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Qt library provides several classes for working with threads in an application,
    such as `QThread` and `QThreadPool`. The advantages of the `QThread` class are
    that we can make changes in GUI components using the signals mechanism. The Qt
    library provides documentation terms such as *re-entrant* and *thread-safe*, which
    are used to mark classes and functions to indicate how they can be used in multithreading
    applications. The term **thread-safe** means that this method can be called from
    multiple threads, even when the invocations use shared data, because all references
    to the shared data are serialized.
  prefs: []
  type: TYPE_NORMAL
- en: The term **re-entrant** means that this method can be called from multiple threads,
    but only if each invocation uses its own data. In this section, we will cover
    the `QThread` and `QThreadPool` classes. We also recommend learning about the
    `QtConcurrent` module and the `WorkerScript` QML type.
  prefs: []
  type: TYPE_NORMAL
- en: QThread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class manages the threads that can be used in an application. It is platform-independent
    and provides a way to separate the execution of tasks into different event loops.
    The declaration syntax of this class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`QThread` inherits from the `QObject` class and improves functionality with
    the following functions.'
  prefs: []
  type: TYPE_NORMAL
- en: set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These functions set the parameters/properties to the thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.setEventDispatcher(QtCore.QAbstractEventDispatcher)`: This sets the
    event dispatcher, specified in the parameter, that will be used with this thread.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.setPriority(QtCore.QThread.Priority)`: This sets the priority, specified
    in the parameter, that will be used with the running of this thread. The available
    priorities are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QtCore.QThread.IdlePriority`—`0`: This thread is running only when no other
    threads are running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QThread.LowestPriority`—`1`: This thread has the lowest running priority.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QThread.LowPriority`—`2`: This thread has a low running priority.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QThread.NormalPriority`—`3`: This thread has a normal (the default
    of the operating system) running priority.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QThread.HighPriority`—`4`: This thread has a high running priority.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QThread.HighestPriority`—`5`: This thread has the highest running priority.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QThread.TimeCriticalPriority`—`6`: This thread runs as often as possible
    against other threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QThread.InheritPriority`—`7`: This thread is running with the same
    priority as the creating thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thread.setStackSize(int)`: This sets the maximum stack size as a number of
    bytes, specified in the parameter, for this thread.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.setTerminationEnabled(bool)`: If this parameter is `True`, it enables
    the thread''s termination.'
  prefs: []
  type: TYPE_NORMAL
- en: is
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These functions return a Boolean value, `bool`, related to the threads'' states:'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.isFinished()`: This returns `True` if this thread is finished.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.isInterruptionRequested()`: This returns `True` if an interruption
    of this thread is requested.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.isRunning()`: This returns `True` if this thread is running.'
  prefs: []
  type: TYPE_NORMAL
- en: functional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These functions relate to the current values of the thread, changes in functionality,
    and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.currentThread()`: This returns the currently operating thread object
    of the `QtCore.QThread` type.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.currentThreadId()`: This returns the thread handler of the current
    thread.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.eventDispatcher()`: This returns the event dispatcher object of the
    `QtCore.QAbstractEventDispatcher` type for the currently operating thread.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.exec_()`: This executes this thread by entering the event loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.exit(int)`: This exits the event loop of the thread with a return code
    specified in the parameter (`0` is a success; any nonzero value is an error).'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.idealThreadCount()`: This returns the ideal number of threads that
    can be used on the system.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.loopLevel()`: This returns the event loop level for this thread.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.msleep(int)`: This thread falls asleep after the number of milliseconds
    specified in the parameter have elapsed.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.priority()`: This returns the priority of the `QtCore.QThread.Priority`
    type used for this thread.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.quit()`: This exits the event loop of this thread with a return code
    of `0`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.requestInterruption()`: This requests the interruption of this thread'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.run()`: This calls the `run()` function of the created thread.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.sleep(int)`: This thread falls asleep after the duration in seconds
    specified in the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.stackSize()`: This returns the maximum stack size for this thread as
    a number of bytes.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.start(QtCore.QThread.Priority)`: This starts this thread and begins
    executing the `run()` function instructions, with priority specified in the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.terminate()`: This terminates the execution of this thread.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.usleep(int)`: This thread falls asleep in the number of microseconds
    specified in the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.wait(int)`: This blocks this thread and waits until it has finished
    execution or waits for the number of milliseconds specified in the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.yieldCurrentThread()`: This yields the execution of this thread to
    another thread, which the operating system will switch to.'
  prefs: []
  type: TYPE_NORMAL
- en: signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the available signals of the `QThread` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.finished()`: This signal is emitted before this thread finishes executing.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread.started()`: This signal is emitted before this thread starts executing.'
  prefs: []
  type: TYPE_NORMAL
- en: QThreadPool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class manages a collection of threads that can be used in an application.
    The Qt application has a global `QThreadPool` object that manages the main (**GUI**)
    and additional (**worker**) threads that are used in the application. This existing
    thread pool can be accessed by calling the `globalInstance()` static function.
    The declaration syntax of this class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`QThreadPool` inherits from the `QObject` class and enhances its functionality
    with the following functions.'
  prefs: []
  type: TYPE_NORMAL
- en: set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These functions set the parameters/properties of the thread pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread_pool.setExpiryTimeout(int)`: This sets the expiry timeout in milliseconds,
    specified in the parameter, for the thread pool, after which all unused threads
    are considered expired and exit.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread_pool.setMaxThreadCount(int)`: This sets the maximum number of threads,
    specified in the parameter, that will be used in the pool.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread_pool.setStackSize(int)`: This sets the maximum stack size as a number
    of bytes, specified in the parameter, for the worker threads in the pool.'
  prefs: []
  type: TYPE_NORMAL
- en: functional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These functions relate to the current values of the thread pool, changes in
    functionality, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread_pool.activeThreadCount()`: This returns the number of active threads
    in the pool.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread_pool.cancel(QtCore.QRunnable)`: This removes a runnable object that
    hasn''t been started or specified in the parameter from the queue.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread_pool.clear()`: This removes runnable objects that haven''t been started from
    the queue.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread_pool.expiryTimeout()`: This returns the expiry timeout for the thread
    pool, or the time in milliseconds after which all unused threads are considered
    expired, and exit.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread_pool.globalInstance()`: This returns the global instance of the **`QtCore.QThreadPool`**
    type for the thread pool.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread_pool.maxThreadCount()`: This returns the maximum number of threads
    used in the pool.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread_pool.releaseThread()`: This releases the thread that was previously
    reserved with the `reserveThread()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread_pool.reserveThread()`: This reserves the thread.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread_pool.stackSize()`: This returns the maximum stack size as the number
    of bytes for the worker threads in the pool.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread_pool.start(QtCore.QRunnable, int)`: This reserves this thread and uses
    it to run a runnable (the first parameter) object with priority (the second parameter)
    for the queue''s order of execution.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread_pool.tryStart(QtCore.QRunnable)`: This tries to reserve the thread
    in order to run a runnable object, specified in the parameter, in the queue.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread_pool.tryTake(QtCore.QRunnable)`: This tries to remove the runnable
    object that''s specified in the parameter from the queue.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread_pool.waitForDone(int)`: This waits for the timeout in milliseconds,
    specified in the parameter, for all threads to exit, and removes all threads from
    the pool (the default timeout is `-1` or ignored).'
  prefs: []
  type: TYPE_NORMAL
- en: Threads example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to look at an example of threads, we will modify the previous code
    related to CouchDB and MongoDB functionality. In the `u_tools.py` files, let''s
    add the classes with threads and functions that will make threads dependent on
    the tasks in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the thread class for the MongoDB server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is the first part of the class with a signal that will emit data. It also
    has the `on_source()` function, which will receive data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to add the `run()` function, which will implement our threading
    functionality, to the `MongoThread` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `run()` function of the thread will start the thread functionality. It will
    try to connect to the MongoDB server. When it is connected, it will try to insert/select
    the values to/from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `CouchThread` class for the CouchDB server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is the first part of the class and has a signal that will emit data, as
    well as the `on_source()` function, which will receive data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `run()` function, which will implement the threading functionality, to
    the `CouchThread` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `run()` function of this thread will start the thread functionality. It
    will try to connect to the CouchDB server. When it is connected, it will try to
    insert/select values to/from the database. Now, we need to add the functions that
    will provide the threading functionality in the application. First, we need to
    add the signals that will be used in the `UTools` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The signals that will be used for communication look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: These new signals will communicate between the `UTools` class' functionality
    and the threads that were created for Mongo and Couch database realization. Then,
    we need to change the previously created functions in the `UTools` class of the
    `u_tools.py` files to write to and read from the Couch and Mongo databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `mongo_insert()` function of the `UTools` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This function will write the data specified in the `datas` list using a thread.
    The instance of this thread will be used, along with the connection of the signal
    for emitting this data to the thread. This will start the thread (by default,
    the priority is `InheritPriority`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `mongo_select()` function of the `UTools` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This function will read the data of the MongoDB instance using the thread. The
    instance of the thread will be created with the connection of the signal for emitting
    this data to the thread.  The emitted data will be a list with an empty dictionary
    (optional) and a string that indicates the reading operation. Then, the thread
    starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, change the `couch_insert()` function of the `UTools` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This function will write the data specified in the `datas` list using the thread
    to the Couch database. The instance of the thread will be used, along with the
    connection of the signal for emitting this data to the thread. Now, the thread
    will start.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `couch_select()` function of the `UTools` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This function will read the data using the thread. The instance of the thread
    will be created, along with the connection of the signal for emitting this data
    to the thread. The emitted data will be a list with an empty dictionary (optional)
    and a string that indicates the reading operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to change the `data()` function of the `UApp` class from the `u_app.py`
    files that are related to reading from the Couch and Mongo databases. Let''s get
    started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `data()` function of the `UApp` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: These lines provide MongoDB functionality when the  Data | MongoDB option in the
    top panel is selected. It calls the `mongo_select()` function when it receives
    the thread object, connects to the nested function with the signal of the thread,
    and puts the database data into the text field. If an error occurs, it shows this
    error in the status bar of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `data()` function of the `UApp` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: These lines provide CouchDB functionality when the `CouchDB` option is selected.
    It calls the `couch_select()` function when it receives the thread object, connects
    to the nested function with the signal of the thread, and puts the database data
    into the text field. If an error occurs, it shows this error in the status bar
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: These examples have some restrictions in regard to use. Note that when we use
    this functionality, we need to ensure that the CouchDB and MongoDB servers are
    configured and working, and that databases are created in the directory.
  prefs: []
  type: TYPE_NORMAL
- en: Locks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using threads in an application, problems may arise in relation to accessing
    a similar source with several threads, or when you need to lock the execution
    of part of the code. The Qt library provides several classes to solve this problem,
    such as `QMutex`, `QMutexLocker`, `QReadWriteLock`, `QSemaphore`, and `QWaitCondition`.
    Here, we will describe some of them. However, please note that locking some sources
    can create other problems related to blocking the GUI thread, or another thread.
    Therefore, using locks in an application is not trivial, and before implementation,
    we need to think about it carefully.
  prefs: []
  type: TYPE_NORMAL
- en: QMutex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class allows access serialization between threads. To enforce **mutual
    exclusion** (**mutex**), the thread locks a mutex in order to gain access to the
    resource. The declaration syntax of this class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The mutex can be constructed with the recursion mode specified in the parameter.
    The available recursion modes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QtCore.QMutex.Recursive`—`0`: This thread is capable of locking the same mutex
    multiple times. This mutex will not be unlocked until a corresponding number of
    `unlock()` function calls have been made.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QMutex.NonRecursive`—`1`: This thread can lock the same mutex only
    once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QMutex` inherits from the `QBasicMutex` class and enhances its functionality
    with the following functions.'
  prefs: []
  type: TYPE_NORMAL
- en: is
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This function returns a Boolean value (`bool`) related to the mutex states:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mutex.isRecursive()`: This returns `True` if this mutex has a recursive mode.'
  prefs: []
  type: TYPE_NORMAL
- en: functional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These functions relate to the current values of the mutex, changes in functionality,
    and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mutex.lock()`: This locks the mutex.'
  prefs: []
  type: TYPE_NORMAL
- en: '`mutex.tryLock(int)`: This tries to lock the mutex. If another thread has locked
    the mutex, it will wait before the lock for the number of milliseconds specified
    in the parameter (the default timeout is `0`).'
  prefs: []
  type: TYPE_NORMAL
- en: '`mutex.unlock()`: This unlocks the mutex.'
  prefs: []
  type: TYPE_NORMAL
- en: QMutex example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mutexes can usually be implemented in an application when threads are used.
    Let''s demonstrate this with the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `__init__()` function created the instance of the `QMutex` class that was
    imported from the `QtCore` module. Inside the `run()` function of the thread,
    we added the line with the `lock()` and `unlock()` methods of the mutex, which
    will lock and unlock the code between them, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: QMutexLocker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class provides the additional convenient functionality of locking and
    unlocking mutexes. The declaration syntax of this class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `QMutexLocker` class improves functionality with the following functions.
  prefs: []
  type: TYPE_NORMAL
- en: functional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These functions relate to the current values of the mutex locker, changes in
    functionality, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mutex_locker.mutex()`: This returns the mutex of the `QtCore.QMutex` type
    that operates by this mutex locker.'
  prefs: []
  type: TYPE_NORMAL
- en: '`mutex_locker.relock()`: This relocks the unlocked mutex locker.'
  prefs: []
  type: TYPE_NORMAL
- en: '`mutex_locker.unlock()`: This unlocks the mutex locker.'
  prefs: []
  type: TYPE_NORMAL
- en: QMutexLocker example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous example of mutexes has some flaws. If an exception occurs during
    the execution of the code before the `unlock()` method, the mutex can be locked
    forever. To solve this problem, we can use the `QMutexLocker` class. Let''s demonstrate
    this with the previously created mutex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `run()` function, we''ve created an instance of the `QMutexLocker` class
    that''s been imported from the `QtCore` module, with the mutex specified in the
    parameter. After the end of scope, the destructor of the class will be called,
    and this lock will be automatically released. This can also be used in the construction
    of the context manager for things such as instructions; for example, *with*/*as*.
    Change the previous lines of code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: QSystemSemaphore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class provides a general counting system semaphore for working with threads
    and multiple processes in an application. The declaration syntax of this class
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This system semaphore can be constructed with a key (the first parameter) and
    a system-dependent initialization of the number of resources (the second parameter)
    with the access mode (the third parameter). The available access modes are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QtCore.QSystemSemaphore.Open`—`0`: If the system semaphore exists, its initial
    resource count is not reset; otherwise, it will be created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QSystemSemaphore.Create`—`0`: The system semaphore will be created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `QSystemSemaphore` class improves functionality with the following functions.
  prefs: []
  type: TYPE_NORMAL
- en: set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This function sets the parameters/properties of the system semaphore:'
  prefs: []
  type: TYPE_NORMAL
- en: '`system_semaphore.setKey(str, int, QtCore.QSystemSemaphore.AccessMode)`: This reconstructs
    the system semaphore object with a key (the first parameter) and a system-dependent
    initialization of the number of resources (the second parameter) with the access
    mode (the third parameter)'
  prefs: []
  type: TYPE_NORMAL
- en: functional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These functions relate to the current values of the system semaphore, changes
    in functionality, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '`system_semaphore.acquire()`: This acquires one of the resources that are guarded
    by this system semaphore.'
  prefs: []
  type: TYPE_NORMAL
- en: '`system_semaphore.error(QtCore.QSystemSemaphore.SystemSemaphoreError)`: This
    returns a value of the error type if an error occurred with this system semaphore.
    The errors that can occur are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QtCore.QSystemSemaphore.NoError`—`0`: No error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QSystemSemaphore.PermissionDenied`—`1`: Not enough permissions for
    the caller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QSystemSemaphore.KeyError`—`2`: An invalid key has been specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QSystemSemaphore.AlreadyExists`—`3`: A system semaphore with the specified
    key already exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QSystemSemaphore.NotFound`—`4`: A system semaphore with the specified
    key can''t be found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QSystemSemaphore.OutOfResources`—`5`: Not enough memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtCore.QSystemSemaphore.UnknownError`—`6`: The error is unknown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`system_semaphore.errorString()`: This returns a text description of the error.'
  prefs: []
  type: TYPE_NORMAL
- en: '`system_semaphore.key()`: This returns the key for this system semaphore or
    the name by which this system semaphore can be accessed from other processes.'
  prefs: []
  type: TYPE_NORMAL
- en: '`system_semaphore.release(int)`: This releases the number, specified in the
    parameter, of resources guarded by this system semaphore.'
  prefs: []
  type: TYPE_NORMAL
- en: QSemaphore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class creates the general counting semaphore for working with threads
    in the application. The declaration syntax of this class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The semaphore can be constructed with the initialization of the number of resources
    specified in the parameter. The `QSemaphore` class improves functionality with
    the following functions.
  prefs: []
  type: TYPE_NORMAL
- en: functional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These functions relate to the current values of the semaphore, changes in functionality,
    and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '`semaphore.acquire(int)`: This acquires the number, specified in the parameter,
    of the resources guarded by this semaphore.'
  prefs: []
  type: TYPE_NORMAL
- en: '`semaphore.available()`: This returns the amount of resources available to
    this semaphore.'
  prefs: []
  type: TYPE_NORMAL
- en: '`semaphore.release(int)`: This releases the amount, specified in the parameter,
    of resources guarded by this semaphore.'
  prefs: []
  type: TYPE_NORMAL
- en: '`semaphore.tryAcquire(int)`: This tries to acquire the amount, specified in
    the parameter, of resources guarded by this semaphore.'
  prefs: []
  type: TYPE_NORMAL
- en: '`semaphore.tryAcquire(int, int)`: This tries to acquire the amount (the first
    parameter) of resources guarded by this semaphore for the duration specified (the
    second parameter).'
  prefs: []
  type: TYPE_NORMAL
- en: The semaphore constructions are commonly used to control access to the source
    by the several threads. A good example of semaphores can be found in the threading
    examples, with PyQt5/PySide bindings, and in the `/examples/threads/` folder of
    `site-packages/`, which is related to the binding used.
  prefs: []
  type: TYPE_NORMAL
- en: QWaitCondition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class synchronizes the threads by providing a condition variable. The
    declaration syntax of this class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `QWaitCondition` class improves functionality with the following functions.
  prefs: []
  type: TYPE_NORMAL
- en: functional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These functions relate to the returns of the current values of the semaphore,
    changes in functionality, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '`wait_condition.wait(QtCore.QMutex, int)`: This releases the locked mutex (the
    first parameter) and waits on the wait condition, such as other thread signals,
    including `wakeOne()` or `wakeAll()`, or the timeout in milliseconds (the second
    parameter) elapses.'
  prefs: []
  type: TYPE_NORMAL
- en: '`wait_condition.wait(QtCore.QReadWriteLock, int)`: This releases the locked
    read/write lock (the first parameter) and waits on the wait condition, such as
    other thread signals, including `wakeOne()` or `wakeAll()`, or the timeout in
    milliseconds (the second parameter) elapses.'
  prefs: []
  type: TYPE_NORMAL
- en: '`wait_condition.wakeAll()`: This wakes all threads that are waiting with the
    wait condition.'
  prefs: []
  type: TYPE_NORMAL
- en: '`wait_condition.wakeOne()`: This wakes one of the threads that is waiting with
    the wait condition.'
  prefs: []
  type: TYPE_NORMAL
- en: Python standard library tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The instruments of the Python standard library can be easily implemented with
    the PySide2/PyQt5 Python bindings of the Qt library in our GUI application. We
    can describe the tools we're going to use in a similar way to how we did earlier
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: threading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This Python standard library module implements the threading functionality
    with any Python-based application that has the PyQt and PySide bindings. This
    module can be used in a wider sense than the analogous `QThread` class for specialized
    tasks in the application. But we need to know that, in PyQt/PySide GUIs, the `QThread`
    class allows communication and functionality through the signals. To use threading
    in the application, we need to import this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We will only describe the commonly used part of this module. Full information
    about this module is available in the official documents: [https://docs.python.org/3/](https://docs.python.org/3/).
    This module uses the following useful functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`threading.active_count()`: This returns the number of threads that are currently
    alive.'
  prefs: []
  type: TYPE_NORMAL
- en: '`threading.current_thread()`: This returns the thread that''s currently in
    use.'
  prefs: []
  type: TYPE_NORMAL
- en: '`threading.get_ident()`: This returns the identifier of the current thread.'
  prefs: []
  type: TYPE_NORMAL
- en: '`threading.enumerate()`: This returns the list of all threads that are currently
    alive.'
  prefs: []
  type: TYPE_NORMAL
- en: '`threading.main_thread()`: This returns the main thread. In the Pythonic sense,
    this is a thread from which the Python interpreter, which operates the Python
    environment, was started.'
  prefs: []
  type: TYPE_NORMAL
- en: '`threading.stack_size(int)`: This returns the stack size that will be used
    when creating new threads. If the optional parameter is specified, it will be
    used as the stack size. Note that the parameter is a number of bytes, and that `0`
    or at least 32 KiB (`32768`) can be used; for example, 512 KiB is represented
    as `524288` in numeric form.'
  prefs: []
  type: TYPE_NORMAL
- en: The `threading` module implements this functionality through several classes
    (the arguments that are provided are related to Python 3.x).
  prefs: []
  type: TYPE_NORMAL
- en: Thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `thread` class of the `threading` module is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`group` is reserved for future extension when a `ThreadGroup` class is implemented;
    `target` is a callable object; `name` is the name of the thread; `args` is a tuple
    of arguments that are used; `kwargs` is a dictionary of the keyword arguments;
    and `daemon` sets the thread as daemonic. The `Thread` class has the following
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread1.start()`: This starts the thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thread1.run()`: This represents thread activity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thread1.join(float)`: This waits until the thread terminates. The timeout
    parameter optionally waits before blocking the operation or blocking immediately
    after termination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thread1.is_alive()`: This returns `True` if this thread is alive, otherwise
    it returns `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Construction of this class usually looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Lock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are primitive lock objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Lock` class has the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread1_lock.acquire(blocking=True, timeout=-1)`: This acquires blocking or
    non-blocking.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread1_lock.release()`: This releases the lock.'
  prefs: []
  type: TYPE_NORMAL
- en: RLock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are re-entrant lock objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RLock` class has the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread1_rlock.acquire(blocking=True, timeout=-1)`: This acquires blocking
    or non-blocking.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread1_rlock.release()`: This releases the lock.'
  prefs: []
  type: TYPE_NORMAL
- en: Condition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the condition variable objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Condition` class has the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread1_cond.acquire(*args)`: This acquires the underlying lock.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread1_cond.release()`: This releases the underlying lock.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread1_cond.wait(timeout=None)`: This waits until it''s notified, or a timeout
    occurs.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread1_cond.wait_for(predicate, timeout=None)`: This waits until a condition
    evaluates to `True`. The predicate parameter is a callable that returns a Boolean
    (`True` or `False`).'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread1_cond.notify(n=1)`: This wakes up `n` threads.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread1_cond.notify_all()`: This wakes up all threads.'
  prefs: []
  type: TYPE_NORMAL
- en: Semaphore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are semaphore objects, which manage a counter that counts the number
    of releases minus the number of acquires, plus an initial value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Semaphore` class has the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread1_sema.acquire(*args)`: This acquires the semaphore.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread1_sema.release()`: This releases the semaphore.'
  prefs: []
  type: TYPE_NORMAL
- en: BoundedSemaphore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the bounded semaphore objects that check that the  current value
    doesn''t exceed its initial value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are event objects that are used for communication between threads. This
    is done by managing internal flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Event` class has the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread1_event.is_set()`: This returns `True` if the internal flag is `True`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread1_event.set()`: This sets the internal flag to `True`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread1_event.clear()`: This sets the internal flag to `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread1_event.wait(timeout=None)`: This blocks until the flag is `True`.'
  prefs: []
  type: TYPE_NORMAL
- en: Timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are timer objects that run the timing for the action. This will only
    be run after a duration that is specified. The parameters that are provided are
    the `interval` after which the action will run; the `function` that will be run; `args` as
    the arguments that will be used; and `kwargs` as keyword arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Timer` class has the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread1_timer.cancel()`: This stops the timer by canceling its execution.'
  prefs: []
  type: TYPE_NORMAL
- en: Barrier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are barrier objects that are realized with a fixed number of threads
    that need to wait for each other. Threads try to pass the barrier by calling the
    `wait()` method. The parameters provided are `parties`, which is the number of
    threads; `action`, which is the callable that will be called by one of the threads;
    and `timeout`, which is the value that''s used for the `wait()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Barrier` class has the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread1_barrier.wait(timeout=None)`: This passes the barrier.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread1_barrier.reset()`: This resets the barrier and sets the empty state.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread1_barrier.abort()`: This aborts the barrier and sets the broken state.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread1_barrier.parties`: This returns the number of threads required to pass
    the barrier.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread1_barrier.n_waiting`: This returns the number of threads waiting in
    the barrier.'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread1_barrier.broken`: This returns `True` if the barrier is in a broken
    state.'
  prefs: []
  type: TYPE_NORMAL
- en: queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In cases when several threads wait to run a task, it is very important to run
    this task using a queue. The standard library `queue` module can use the multi-producer
    and multi-consumer queue functionality in our application. Python bindings to
    Qt have not-so-simple instruments for the implementation of queues, and this module
    is widely used with threading constructions in GUIs. This module implements three
    types of queues: **First In First Out** (**FIFO**), **Last In First Out** (**LIFO**),
    and queues with priorities. To use them in our application, we need to import
    the following module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Let's describe the most important classes and methods that can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the FIFO queues with the `maxsize` upper-bound limit of items that
    can be placed in the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: LifoQueue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the LIFO queues with the `maxsize` upper-bound limit of items that
    can be placed in the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: PriorityQueue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the priority queues with the `maxsize` upper-bound limit of items
    that can be placed in the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: SimpleQueue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are unbounded FIFO queues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The methods of the `Queue`, `LifoQueue`, `PriorityQueue`, and `SimpleQueue`
    classes that can be used are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`queue1.qsize()`: This returns the approximate size of the queue because the
    queues usually change (`Queue`, `LifoQueue`, `PriorityQueue`, `SimpleQueue`).'
  prefs: []
  type: TYPE_NORMAL
- en: '`queue1.empty()`: This returns `True` if the queue is approximately empty (`Queue`,
    `LifoQueue`, `PriorityQueue`, `SimpleQueue`).'
  prefs: []
  type: TYPE_NORMAL
- en: '`queue1.full()`: This returns `True` if the queue is approximately full (has
    at least one item) (`Queue`, `LifoQueue`, `PriorityQueue`).'
  prefs: []
  type: TYPE_NORMAL
- en: '`queue1.put(item, block=True, timeout=None)`: This puts the specified item
    into the queue. The optional block and timeout arguments are provided (`Queue`,
    `LifoQueue`, `SimpleQueue`).'
  prefs: []
  type: TYPE_NORMAL
- en: '`queue1.put((priority, item), block=True, timeout=None)`: This puts the specified
    item into the queue with an integer priority value. The optional block and timeout arguments
    are provided (`PriorityQueue`).'
  prefs: []
  type: TYPE_NORMAL
- en: '`queue1.put_nowait(item)`: This puts the specified item into the queue. The
    optional block and timeout arguments are provided (`Queue`, `LifoQueue`, `SimpleQueue`).'
  prefs: []
  type: TYPE_NORMAL
- en: '`queue1.put_nowait((priority, item))`: This puts the specified item into the
    queue with an integer priority value. The optional block and timeout arguments
    are provided (`PriorityQueue`).'
  prefs: []
  type: TYPE_NORMAL
- en: '`queue1.get(block=True, timeout=None)`: This returns an item from the queue.
    The optional block and timeout arguments are provided (`Queue`, `LifoQueue`, `PriorityQueue`,
    `SimpleQueue`).'
  prefs: []
  type: TYPE_NORMAL
- en: '`queue1.get_nowait()`: This returns an item from the queue (`Queue`, `LifoQueue`,
    `PriorityQueue`, `SimpleQueue`).'
  prefs: []
  type: TYPE_NORMAL
- en: '`queue1.task_done()`: This indicates that the task of the queue is complete
    (`Queue`, `LifoQueue`, `PriorityQueue`).'
  prefs: []
  type: TYPE_NORMAL
- en: '`queue1.join()`: This blocks until all items have been processed and have completed
    (`Queue`, `LifoQueue`, `PriorityQueue`).'
  prefs: []
  type: TYPE_NORMAL
- en: subprocess
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This Python standard library module realizes the functionality related to running
    processes in a similar manner to the `QProcess` class of the Qt library. This
    module runs tasks as new processes, connects to the input/output/error pipes of
    the processes, and obtains their return codes. Previously, we implemented subprocesses
    such as running the camera device functionality. Let''s describe this module in
    more detail. To use it in our application, we need to import the following module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The most important classes and methods that can be used in the application are
    described in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: run()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `run()` method, which is available from Python version 3.5, runs the tasks
    in the new process. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is a list with a command and arguments, as well as flags
    if they are provided. The `stdin`, `stdout`, and `stderr` arguments specify the
    executed program's `STDIN` (standard input), `STDOUT` (standard output), and `STDERR`
    (standard error). Values such as `PIPE`, `DEVNULL`, and `STDOUT` can be used.
    The `input` is used for the `communicate()` method. If `capture_output` is `True`,
    `stdout` and `stderr` will be captured. If `shell` is `True`, it specifies the
    command to execute through the shell. If `cwd` is not `None`, it changes the `cwd`
    (current working directory) before executing. `timeout` is used for the `communicate()`
    method. When the timeout expires, the child process will be killed and waited
    for. If `check` is `True`, and the process exits with a nonzero exit code, a `CalledProcessError`
    exception will be raised. `encoding` specifies which encoding will be used, such
    as `"utf-8"` or `" cp1252"`. `errors` specifies how encoding and decoding errors
    are to be handled with string values such as `"strict"`, `"ignore"`, `"replace"`,
    `"backslashreplace"`, `"xmlcharrefreplace"`,  and `"namereplace"`. If `text` is
    `True`, the file objects for `stdin`, `stdout`, and `stderr` are opened in text
    mode. `env` defines the environment variables for the new process. `universal_newlines`
    is equivalent to text and is provided for backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Popen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Popen` class handles the underlying process creation and management in
    the `subprocess` module. This class provides additional optional arguments that
    can be used. The syntax of this class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is a list with a command and arguments, as well as flags
    if they are provided. `bufsize` will be used with the `open()` function when creating
    the `stdin`/`stdout`/`stderr` pipe file objects. `executable` specifies a replacement
    program to execute. The `stdin`, `stdout`, and `stderr` arguments specify the
    executed program's `STDIN` (standard input), `STDOUT` (standard output), and `STDERR`
    (standard error). Valid values include `PIPE`, `DEVNULL`, and `STDOUT`.  The object
    is called in the child process just before the child is executed (POSIX only)
    if `preexec_fn` is set. If `close_fds` is `True`, all file descriptors will be
    closed before execution, except `0`, `1`, and `2`. The command will get executed
    through the shell if the shell is `True`. If `cwd` is not `None`, it changes the
    `cwd` (current working directory) before executing. `env` defines the environment
    variables for the new process. `universal_newlines` is equivalent to text and
    is provided for backward compatibility. `startupinfo` will be a `STARTUPINFO`
    object that is passed to the `CreateProcess` function with creation flags. If
    `restore_signals` is `True`, all signals that are set to `SIG_IGN` are restored
    to `SIG_DFL` before execution (POSIX only). If `start_new_session` is `True`,
    a `setsid()` system call will be made in the child process prior to the execution
    of the subprocess (POSIX only). `pass_fds` is a sequence of file descriptors that will
    be kept open between the parent and child (POSIX only). `encoding` specifies which
    encoding will be used, such as `"utf-8"` or `"cp1252"`. `errors` specifies how
    encoding and decoding errors are to be handled, with string values such as `"strict"`,
    **`"ignore"`**, `"replace"`, `"backslashreplace"`, `"xmlcharrefreplace"`, and
    `"namereplace"`. If `text` is `True`, the file objects for `stdin`, `stdout`,
    and `stderr` are opened in text mode.
  prefs: []
  type: TYPE_NORMAL
- en: functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following methods can be used with this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`subprocess1.poll()`: This checks if the sub-process has terminated.'
  prefs: []
  type: TYPE_NORMAL
- en: '`subprocess1.wait(timeout=None)`: This waits for the termination of the sub-process
    with a timeout, if specified.'
  prefs: []
  type: TYPE_NORMAL
- en: '`subprocess1.communicate(input=None, timeout=None)`: This interacts with the
    process by sending the data to `STDIN` and reading the data from `STDOUT`/`STDERR`,
    while waiting for termination. The input can be data to be sent to the sub-process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`subprocess1.send_signal(signal)`: This sends the signal to the sub-process.
    It has the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`subprocess1.terminate()`: This terminates the sub-process using OS parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subprocess1.kill()`: This kills the sub-process using OS parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subprocess1.args`: This returns the arguments passed to `Popen`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subprocess1.stdin`: This returns the argument passed to `Popen` standard input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subprocess1.stdout`: This returns the argument passed to `Popen` standard
    output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subprocess1.stderr`: This returns the argument passed to `Popen` standard
    error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subprocess1.pid`: This returns the process ID of the sub-process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subprocess1.returncode`: This returns the return code of the sub-process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: multiprocessing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This Python standard library package manages the spawning processes that can
    be used in the application. When using local and remote concurrency, this instrument
    side steps the **Global Interpreter Lock** (**GIL**) limitations by using sub-processes
    instead of threads, and, as a result, effectively leverages multiple processors
    if the device has them. The API of the multiprocessing package is similar to the
    `threading` module, and the methods mostly replicate the `Thread` class of the
    `threading` module, similar to `Queue` of the `queue` module that was shown earlier.
    To use it in our application, we need to import the following package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class represents the process objects that enable multiprocessing and the
    activity of the separate processes. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters have similar meanings to those in the `Thread` class of the
    threading module. The methods that are used in this class are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`process1.run()`: This represents the activity of the processes.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process1.start()`: This starts the processes.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process1.join(float)`: This waits until the process terminates. The timeout
    parameter (optional) waits before blocking the operation or blocking immediately
    after termination.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process1.is_alive()`: This returns `True` if this process is alive, otherwise
    it returns `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process1.close()`: This closes the process and releases all associated resources.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process1.kill()`: This kills the process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process1.terminate()`: This terminates the process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process1.name`: This returns the name of the process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process1.daemon`: This returns the daemon flag of the process, that is, `True`
    or `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process1.pid`: This returns the ID of the process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process1.exitcode`: This returns the sub-process exit code.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process1.authkey`: This returns the authentication key of the process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`process1.sentinel`: This returns the numeric handle of a system object that
    will be ready when the process ends.'
  prefs: []
  type: TYPE_NORMAL
- en: Connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class creates the connection objects that allow us to send and receive
    pickleable objects or strings. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The methods that can be used are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`conn.send(obj)`: This sends the pickleable object to the other end of the
    connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '`conn.recv()`: This returns an object that''s received from the other end of
    the connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '`conn.fileno()`: This returns the file descriptor or handle of the connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '`conn.close()`: This closes the connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '`conn.poll(timeout)`: This returns `True` if any data is available to be read.'
  prefs: []
  type: TYPE_NORMAL
- en: '`conn.send_bytes(buffer, offset, size)`: This sends the data from a bytes-like
    object. The data will read from the position in** `buffer`** if `offset` is specified,
    with the `size` of bytes, if specified.'
  prefs: []
  type: TYPE_NORMAL
- en: '`conn.recv_bytes(maxlength)`: This returns the message of byte data received
    from the other end of the connection. `maxlength` limits the message, if specified.'
  prefs: []
  type: TYPE_NORMAL
- en: '`conn.recv_bytes_into(buffer, offset)`: This reads the message of byte data that''s
    received from the other end of the connection and returns the number of bytes
    in the message. If `offset` is specified, the message will be written into `buffer`
    from that position.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connections are usually created with the `Pipe` class. Constructing a connection
    like this has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'If the duplex parameter is `True`, the pipe is bidirectional, and if it''s
    `False`, the pipe is unidirectional. This means that `conn1` is used for receiving
    messages and `conn2` is used for sending messages. An example of connections is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have created functions with the send methods of the `Connection` class;
    the `Pipe` class was used for the connection, and the methods that were described
    previously were also used. This construction is not random. In terms of multiprocessing,
    we need to operate the processes inside the **`if __name__ == "__main__"`** instruction,
    or call the function with multiprocessing functionality. With the `multiprocessing`
    package, classes such as `Pool`, which creates the pool of processes; `Queue`,
    which creates the queues; `Manager`, which controls the server process that manages
    shared objects; and the `Listener` and `Client` classes of the connection module,
    are also available. It is recommended that you learn about these classes and modules.
    In addition, the multiprocessing package has the following methods, which can
    be useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '`multiprocessing.active_children()`: This returns all the live children of
    the current process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multiprocessing.cpu_count()`: This returns the number of CPUs used in the
    device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multiprocessing.current_process()`: This returns the current process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter completes the basic part of this book's material. The use of threads
    improves the productivity of the application. The importance and size of the instruments
    is such a vast subject that we would need a separate book to cover it all. This
    is why we just looked at the starting points. More information about these interesting
    and useful tools is available in the official documentations of PySide2 ([https://doc.qt.io/qtforpython/index.html](https://doc.qt.io/qtforpython/index.html)),
    PyQt5 ([https://www.riverbankcomputing.com/static/Docs/PyQt5/](https://www.riverbankcomputing.com/static/Docs/PyQt5/)),
    and of course Python ([https://docs.python.org/3/](https://docs.python.org/3/)). Constructions
    of multithreading and multiprocessing and implementing them in our application
    have pole positions because they make the GUI application comfortable and user-friendly.
    Almost everything that's necessary for use in GUI development was covered in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will complete this book. We will finalize our GUI application,
    provide mechanisms for embedding the application in different platforms, and try
    out some code while explaining the basics.
  prefs: []
  type: TYPE_NORMAL
