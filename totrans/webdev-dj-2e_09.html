<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-260"><a id="_idTextAnchor275"/>9. Sessions and Authentication</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">This chapter begins with a brief introduction to <strong class="bold">middleware</strong> before delving into the concepts of <strong class="bold">authentication models</strong> and <strong class="bold">session engines</strong>. You will implement Django's authentication model to restrict permissions to only a specific set of users. Then, you will see how you can leverage Django authentication to provide a flexible approach to application security. After that, you will learn how Django supports multiple session engines to retain user data. By the end of the chapter, you will be proficient at using sessions to retain information on past user interactions and to maintain user preferences for when pages are revisited.</p>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor276"/>Introduction</h1>
			<p>Up until now, we have used Django to develop dynamic applications that allow users to interact with application models, but we have not attempted to secure these applications from unwanted use. For example, our Bookr app allows unauthenticated users to add reviews and upload media. This is a critical security issue for any online web app as it leaves the site open to the posting of spam or other inappropriate material and the vandalism of existing content. We want the creation and modification of content to be strictly limited to authenticated users who have registered with the site.</p>
			<p>The <strong class="bold">authentication app</strong> supplies Django with the models for representing users, groups, and permissions. It also provides middleware, utility functions, decorators, and mixins that help integrate user authentication into our apps. Furthermore, the authentication app allows grouping and naming certain sets of users. </p>
			<p>In <em class="italic">Chapter 4</em>, <em class="italic">Introduction to Django Admin</em>, we used the Admin app to create a help desk user group with the permissions "Can view log entry," "Can view permission," "Can change user," and "Can view user." Those permissions could be referenced in our code using their corresponding codenames: <code>view_logentry</code>, <code>view_permissions</code>, <code>change_user</code>, and <code>view_user</code>. In this chapter, we will learn how to customize Django behavior based on specific user permissions.</p>
			<p>Permissions are directives that delineate what is permissible by classes of users. Permissions can be assigned either to groups or directly to individual users. From an administrative point of view, it is cleaner to assign permissions to groups. Groups make it easier to model roles and organizational structures. If a new permission is created, it is less time-consuming to modify a few groups than to remember to assign it to a subset of users. </p>
			<p>We are already familiar with creating users and groups and assigning permissions using several methods, such as the option of instantiating users and groups through the model using scripts and the convenience of creating them through the Django Admin app. The authentication app also offers us programmatic ways of creating and deleting users, groups, and permissions and assigning relations between them.</p>
			<p>As we go through this chapter, we'll learn how to use authentication and permissions to implement application security and how to store user-specific data to customize the user's experience. This will help us secure the <code>bookr</code> project from unauthorized content changes and make it contextually relevant for different types of users. Adding this basic security to our <code>bookr</code> project is crucial before we consider deploying it on the internet.</p>
			<p>Authentication, as well as session management (which we'll learn about in the <em class="italic">Sessions</em> section), is handled by something known as a <code>bookr</code> project, let's learn a bit about this middleware stack and its modules.</p>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor277"/>Middleware</h1>
			<p>In <em class="italic">Chapter 3</em>, <em class="italic">URL Mapping, Views, and Templates</em>, we discussed Django's implementation of the request/response process along with its view and rendering functionality. In addition to these, another feature that plays an extremely important role when it comes to Django's core web processing is <strong class="bold">middleware</strong>. Django's middleware refers to a variety of software components that intervene in this request/response process to integrate important functionalities such as security, session management, and authentication.</p>
			<p>So, when we write a view in Django, we don't have to explicitly set a series of important security features in the response header. These additions to the response object are automatically made by the <code>SecurityMiddleware</code> instance after the view returns its response. As middleware components wrap the view and perform a series of pre-processes on the request and post-processes on the response, the view is not cluttered with a lot of repetitive code and we can concentrate on coding application logic rather than worrying about low-level server behavior. Rather than building these functionalities into the Django core, Django's implementation of a middleware stack allows these components to be both optional and replaceable.</p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor278"/>Middleware Modules</h2>
			<p>When we run the <code>startproject</code> subcommand, a default list of middleware modules is added to the <code>MIDDLEWARE</code> variable in the <code>&lt;project&gt;/settings.py</code> file, as follows:</p>
			<pre>MIDDLEWARE = ['django.middleware.security.SecurityMiddleware',\
              'django.contrib.sessions.middleware.SessionMiddleware',\
              'django.middleware.common.CommonMiddleware',\
              'django.middleware.csrf.CsrfViewMiddleware',\
              'django.contrib.auth.middleware.AuthenticationMiddleware',\
              'django.contrib.messages.middleware.MessageMiddleware',\
              'django.middleware.clickjacking.XFrameOptionsMiddleware',\]</pre>
			<p>This is a minimal middleware stack that is suitable for most Django applications. The following list elaborates on the general purpose of each module:</p>
			<ul>
				<li><code>SecurityMiddleware</code> provides common security enhancements such as handling SSL redirects and adding response headers to prevent common hacks.</li>
				<li><code>SessionMiddleware</code> enables session support and seamlessly associates a stored session with the current request.</li>
				<li><code>CommonMiddleware</code> implements a lot of miscellaneous features, such as rejecting requests from the <code>DISALLOWED_USER_AGENTS</code> list, implementing URL rewrite rules, and setting the <code>Content-Length</code> header.</li>
				<li><code>CsrfViewMiddleware</code> adds protection against <strong class="bold">Cross-Site Request Forgery</strong> (<strong class="bold">CSRF</strong>).</li>
				<li><code>AuthenticationMiddleware</code> adds the <code>user</code> attribute to the <code>request</code> object.</li>
				<li><code>MessageMiddleware</code> adds "flash" message support.</li>
				<li><code>XFrameOptionsMiddleware</code> protects against <code>X-Frame-Options</code> header clickjacking attacks.</li>
			</ul>
			<p>The middleware modules are loaded in the order that they appear in the <code>MIDDLEWARE</code> list. This makes sense because we want to call the middleware that deals with initial security issues first so that dangerous requests are rejected before further processing occurs. Django also comes with several other middleware modules that perform important functions, such as using <code>gzip</code> file compression, redirect configuration, and web cache configuration.</p>
			<p>This chapter is devoted to discussing two important aspects of stateful application development that are implemented as middleware components – <code>SessionMiddleware</code> and <code>AuthenticationMiddleware</code>.</p>
			<p>The <code>process_request</code> method of <code>SessionMiddleware</code> adds a <code>session</code> object as an attribute of the <code>request</code> object. The <code>process_request</code> method of <code>AuthenticationMiddleware</code> adds a <code>user</code> object as an attribute of the <code>request</code> object.</p>
			<p>It is possible to write a Django project without these layers of the middleware stack if a project does not require user authentication or a means of preserving the state of individual interactions. However, most of the default middleware plays an important role in application security. If you don't have a good reason for changing the middleware components, it is best to maintain these initial settings. In fact, the Admin app requires <code>SessionMiddleware</code>, <code>AuthenticationMiddleware</code>, and <code>MessageMiddleware</code> to run, and the Django server will throw errors such as these if the Admin app is installed without them:</p>
			<pre>django.core.management.base.SystemCheckError: SystemCheckError: System check identified some issues:
ERRORS:
?: (admin.E408) 'django.contrib.auth.middleware.AuthenticationMiddleware' must be in MIDDLEWARE in order to use the admin application.
?: (admin.E409) 'django.contrib.messages.middleware.MessageMiddleware' must be in MIDDLEWARE in order to use the admin application.
?: (admin.E410) 'django.contrib.sessions.middleware.SessionMiddleware' must be in MIDDLEWARE in order to use the admin application.</pre>
			<p>Now that we know about the middleware modules, let's look at one approach to enable authentication in our project using the authentication app's views and templates.</p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor279"/>Implementing Authentication Views and Templates</h2>
			<p>We have already encountered the login form on the Admin app in <em class="italic">Chapter 4</em>, <em class="italic">Introduction to Django Admin</em>. This is the authentication entry point for staff users who have access to the Admin app. We also need to create a login capability for ordinary users who want to give book reviews. Fortunately, the authentication app comes with the tools to make this possible.</p>
			<p>As we work through the forms and views of the authentication app, we encounter a lot of flexibility in its implementation. We are free to implement our own login pages, define either very simple or fine-grained security policies at the view level, and authenticate against external authorities.</p>
			<p>The authentication app exists to accommodate a lot of different approaches to authentication so that Django doesn't rigidly enforce a single mechanism. For a first-time user encountering the documentation, this can be quite bewildering. For the most part in this chapter, we will follow Django's defaults, but some of the important configuration options will be noted.</p>
			<p>A Django project's <code>settings</code> object contains attributes for login behavior. <code>LOGIN_URL</code> specifies the URL of the login page. <code>'/accounts/login/'</code> is the default value. <code>LOGIN_REDIRECT_URL</code> specifies the path where a successful login is redirected to. The default path is <code>'/accounts/profile/'</code>.</p>
			<p>The authentication app supplies standard forms and views for carrying out typical authentication tasks. The forms are located in <code>django.contrib.auth.forms</code> and the views are in <code>django.contrib.auth.views</code>.</p>
			<p>The views are referenced by these URL patterns present in <code>django.contrib.auth.urls</code>:</p>
			<pre>urlpatterns = [path('login/', views.LoginView.as_view(), \
                    name='login'),
               path('logout/', views.LogoutView.as_view(), \
                    name='logout'),
               path('password_change/', \
                    views.PasswordChangeView.as_view()),\
                    (name='password_change'),\
               path('password_change/done/', \
                    views.PasswordChangeDoneView.as_view()),\
                    (name='password_change_done'),\
               path('password_reset/', \
                    views.PasswordResetView.as_view()),\
                    (name='password_reset'),\
               path('password_reset/done/', \
                    views.PasswordResetDoneView.as_view()),\
                    (name='password_reset_done'),\
               path('reset/&lt;uidb64&gt;/&lt;token&gt;/', \
                    views.PasswordResetConfirmView.as_view()),\
                    (name='password_reset_confirm'),\
               path('reset/done/', \
                    views.PasswordResetCompleteView.as_view()),\
                    (name='password_reset_complete'),]</pre>
			<p>If this style of views looks unfamiliar, it is because they are class-based views rather than the function-based views that we have previously encountered. We will learn more about class-based views in <em class="italic">Chapter 11</em>, <em class="italic">Advanced Templates and Class-Based Views</em>. For now, note that the authentication app makes use of class inheritance to group the functionality of views and prevent a lot of repetitive coding.</p>
			<p>If we want to maintain the default URLs and views that are presupposed by the authentication app and Django settings, we can include the authentication app's URLs in our project's <code>urlpatterns</code>.</p>
			<p>By taking this approach, we have saved a lot of work. We need only include the authentication app's URLs to our <code>&lt;project&gt;/urls.py</code> file and assign it the <code>'accounts'</code> namespace. Designating this namespace ensures that our reverse URLs correspond to the default template values of the views:</p>
			<pre>urlpatterns = [path('accounts/', \
                    include(('django.contrib.auth.urls', 'auth')),\
                    (namespace='accounts')),\
               path('admin/', admin.site.urls),\
               path('', include('reviews.urls'))]</pre>
			<p>Though the authentication app comes with its own forms and views, it lacks the templates needed to render these components as HTML. <em class="italic">Figure 9.1</em> lists the templates that we require to implement the authentication functionality in our project. Fortunately, the Admin app does implement a set of templates that we can utilize for our purposes.</p>
			<p>We could just copy the template files from the Django source code in the <code>django/contrib/admin/templates/registration</code> directory and <code>django/contrib/admin/templates/admin/login.html</code> to our project's <code>templates/registration</code> directory.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When we say Django source code, it's the directory where your Django installation resides. If you installed Django in a virtual environment (as detailed in the <em class="italic">Preface</em>), you can find these template files at the following path: <code>&lt;name of your virtual environment&gt;/lib/python3.X/site-packages/django/contrib/admin/templates/registration/</code>. Provided your virtual environment is activated and Django is installed in it, you can also retrieve the complete path to the <code>site-packages</code> directory by running the following command in a terminal: <code>python -c "import sys; print(sys.path)"</code>. </p>
			<div><div><img src="img/B15509_09_01.jpg" alt="Figure 9.1: Default paths for authentication templates&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1: Default paths for authentication templates</p>
			<p class="callout-heading">Note</p>
			<p class="callout"> We need only copy the templates that are dependencies for the views and should avoid copying the <code>base.html</code> or <code>base_site.html</code> files.</p>
			<p>This gives a promising result at first, but as they stand, the admin templates do not meet our precise needs as we can see from the login page (<em class="italic">Figure 9.2</em>):</p>
			<div><div><img src="img/B15509_09_02.jpg" alt="Figure 9.2: A first attempt at a user login screen&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2: A first attempt at a user login screen</p>
			<p>As these authentication pages inherit from the Admin app's <code>admin/base_site.html</code> template, they follow the style of the Admin app. We would prefer for these pages to follow the style of the <code>bookr</code> project that we have developed. We can do this by following these three steps on each Django template that we have copied from the Admin app to our project:</p>
			<ol>
				<li>The first change that needs to be made is to replace the <code>{% extends "admin/base_site.html" %}</code> tag with <code>{% extends "base.html" %}</code>.</li>
				<li>Given that <code>template/base.html</code> only contains the following block definitions – <code>title</code>, <code>brand</code>, and <code>content</code> – we should remove all other block substitutions from our templates in the <code>bookr</code> folder. We are not using the content from the <code>userlinks</code> and <code>breadcrumbs</code> blocks in our app, so these blocks can be removed entirely.<p>Some of these blocks, such as <code>content_title</code> and <code>reset_link</code>, contain HTML content that is relevant to our application. We should strip the block from around this HTML and put it inside the content block.</p><p>For example, the <code>password_change_done.html</code> template contains an extensive number of blocks:</p><pre>{% extends "admin/base_site.html" %}
{% load i18n %}
{% block userlinks %}{% url 'django-admindocs-docroot' as docsroot %}  {% if docsroot %}&lt;a href="{{ docsroot }}"&gt;{% trans 'Documentation' %}    &lt;/a&gt; / {% endif %}{% trans 'Change password' %} / &lt;a href="{% url       'admin:logout' %}"&gt;{% trans 'Log out' %}&lt;/a&gt;{% endblock %}
{% block breadcrumbs %}
&lt;div class="breadcrumbs"&gt;
&lt;a href="{% url 'admin:index' %}"&gt;{% trans 'Home' %}&lt;/a&gt;
&amp;rsaquo; {% trans 'Password change' %}
&lt;/div&gt;
{% endblock %}
{% block title %}{{ title }}{% endblock %}
{% block content_title %}&lt;h1&gt;{{ title }}&lt;/h1&gt;{% endblock %}
{% block content %}
&lt;p&gt;{% trans 'Your password was changed.' %}&lt;/p&gt;
{% endblock %}</pre><p>It will be simplified to this template in the <code>bookr</code> project:</p><pre>{% extends "base.html" %}
{% load i18n %}
{% block title %}{{ title }}{% endblock %}
{% block content %}
&lt;h1&gt;{{ title }}&lt;/h1&gt;
&lt;p&gt;{% trans 'Your password was changed.' %}&lt;/p&gt;
{% endblock %}</pre></li>
				<li>Likewise, there are reverse URL patterns that need to change to reflect the current path, so <code>{% url 'login' %}</code> gets replaced by <code>{% url 'accounts:login' %}</code>. </li>
			</ol>
			<p>Given these considerations, the next exercise will focus on transforming the Admin app's login template into a login template for the <code>bookr</code> project.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>i18n</code> module is used for creating multilingual content. If you intend to develop multilingual content for your website, leave the <code>i18n</code> import, <code>trans</code> tags, and <code>transblock</code> statements in the templates. For brevity, we will not be covering those in detail in this chapter.</p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor280"/>Exercise 9.01: Repurposing the Admin App Login Template</h2>
			<p>We started this chapter without a login page for our project. By adding the URL patterns for authentication and copying the templates from the Admin app to our own project, we can implement the functionality of a login page. But this login page is not satisfactory as it is directly copied from the Admin app and is disconnected from the Bookr design. In this exercise, we will follow the steps needed to repurpose the Admin app's login template for our project. The new login template will need to inherit its style and format directly from the <code>bookr</code> project's <code>templates/base.html</code>:</p>
			<ol>
				<li value="1">Create a directory inside your project for <code>templates/registration</code>.</li>
				<li>The Admin login template is located in the Django source directory at the <code>django/contrib/admin/templates/admin/login.html</code> path. It begins with an <code>extends</code> tag, a <code>load</code> tag, the importing of the <code>i18n</code> and <code>static</code> modules, and a series of block extensions that over-ride the blocks defined in the child template, <code>django/contrib/admin/templates/admin/base.html</code>. A truncated snippet of the <code>login.html</code> file is shown in the following code block:<pre>{% extends "admin/base_site.html" %}
{% load i18n static %}
{% block extrastyle %}{{ block.super }}…
{% endblock %}
{% block bodyclass %}{{ block.super }} login{% endblock %}
{% block usertools %}{% endblock %}
{% block nav-global %}{% endblock %}
{% block content_title %}{% endblock %}
{% block breadcrumbs %}{% endblock %}</pre></li>
				<li>Copy this Admin login template, <code>django/contrib/admin/templates/admin/login.html</code>, into <code>templates/registration</code> and begin editing the file using PyCharm.</li>
				<li>As the login template you are editing is located at <code>templates/registration/login.html</code> and extends the base template (<code>templates/base.html</code>), replace the argument of the <code>extends</code> tag at the top of <code>templates/registration/login.html</code>:<pre>{% extends "base.html" %}</pre></li>
				<li>We don't need most of the contents of this file. Just retain the <code>content</code> block, which contains the login form. The remainder of the template will consist of loading the <code>i18n</code> and <code>static</code> tag libraries:<pre>{% load i18n static %}
{% block content %}
…
{% endblock %}</pre></li>
				<li>Now you must replace the paths and reverse URL patterns in <code>templates/registration/login.html</code> with ones that are appropriate to your project. As you don't have an <code>app_path</code> variable defined in your template, it needs to be replaced with the reverse URL for the login, <code>'accounts:login'</code>. So, consider the following line:<pre>&lt;form action="{{ app_path }}" method="post" id="login-form"&gt;</pre><p>This line changes as follows:</p><pre>&lt;form action="{% url 'accounts:login' %}" method="post" id="login-form"&gt;</pre><p>There is no <code>'admin_password_reset'</code> defined in your project paths, so it will be replaced with <code>'accounts:password_reset'</code>.</p><p>Consider the following line:</p><pre>{% url 'admin_password_reset' as password_reset_url %}</pre><p>This line changes as follows:</p><pre>{% url 'accounts:password_reset' as password_reset_url %}</pre><p>Your login template will look as follows:</p><pre>templates/registration/login.html
1  {% extends "base.html" %}
2  {% load i18n static %}
3
4  {% block content %}
5  {% if form.errors and not form.non_field_errors %}
6  &lt;p class="errornote"&gt;
7  {% if form.errors.items|length == 1 %}{% trans "Please correct the error     below." %}{% else %}{% trans "Please correct the errors below." %}{% endif %}
8  &lt;/p&gt;
9  {% endif %}
You can find the complete code for this file at <a href="http://packt.live/2MILJtF">http://packt.live/2MILJtF</a>.</pre></li>
				<li>To use the standard Django authentication views, we must add the URLs mapping to them. Open the <code>urls.py</code> file in the <code>bookr</code> project directory, then add this URL pattern:<pre>urlpatterns = [path(<strong class="bold">'accounts/', \</strong>
<strong class="bold">                    include(('django.contrib.auth.urls', 'auth')),\</strong>
<strong class="bold">                    (namespace='accounts')),\</strong>
               path('admin/', admin.site.urls),\
               path('', include('reviews.urls'))]</pre></li>
				<li>Now when you visit the login link at <code>http://127.0.0.1:8000/accounts/login/</code>, you will see this page:<div><img src="img/B15509_09_03.jpg" alt="Figure 9.3: The Bookr login page&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 9.3: The Bookr login page</p>
			<p>By completing this exercise, you have created the template required for non-admin authentication in your project.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Before you proceed, you'll need to make sure the rest of the templates in the <code>registration</code> directory follow the <code>bookr</code> project's style; that is, they inherit from the Admin app's <code>admin/base_site.html</code> template. You've already seen this done with <code>password_change_done.html</code> and the <code>login.html</code> templates. Go ahead and apply what you've learned in this exercise (and the section before it) to the rest of the files in the <code>registration</code> directory. Alternatively, you may download the modified files from the GitHub repo: <a href="http://packt.live/3s4R5iU">http://packt.live/3s4R5iU</a>.</p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor281"/>Password Storage in Django</h2>
			<p>Django does not store passwords in plain text form in the database. Instead, passwords are digested with a hashing algorithm, such as <strong class="bold">PBKDF2/SHA256</strong>, <strong class="bold">BCrypt</strong>/<strong class="bold">SHA256</strong>, or <strong class="bold">Argon2</strong>. As hashing algorithms are a one-way transformation, this prevents a user's password from being decrypted from the hash stored in the database. This often comes as a surprise to users who expect a system administrator to retrieve their forgotten password, but it is best practice in security design. So, if we query the database for the password, we will see something like this:</p>
			<pre>sqlite&gt; select password from auth_user;pbkdf2_sha256$180000$qgDCHSUv1E4w$jnh69TEIO6kypHMQPOknkNWMlE1e2ux8Q1Ow4AHjJDU=</pre>
			<p>The components of this string are <code>&lt;algorithm&gt;$&lt;iterations&gt;$&lt;salt&gt;$&lt;hash&gt;</code>. As several hashing algorithms have been compromised over time and we sometimes need to work with mandated security requirements, Django is flexible enough to accommodate new algorithms and can maintain data encrypted in multiple algorithms.</p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor282"/>The Profile Page and the request.user Object</h2>
			<p>When a login is successful, the login view redirects to <code>/accounts/profile</code>. However, this path is not included in the existing <code>auth.url</code> nor does the authentication app provide a template for it. To avoid a <code>Page not Found</code> error, a view and an appropriate URL pattern are required.</p>
			<p>Each Django request has a <code>request.user</code> object. If the request is made by an unauthenticated user, <code>request.user</code> will be an <code>AnonymousUser</code> object. If the request is made by an authenticated user, then <code>request.user</code> will be a <code>User</code> object. This makes it easy to retrieve personalized user information in a Django view and render it in a template.</p>
			<p>In the next exercise, we will add a profile page to our <code>bookr</code> project.</p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor283"/>Exercise 9.02: Adding a Profile Page</h2>
			<p>In this exercise, we will add a profile page to our project. To do so, we need to include the path to it in our URL patterns and also include it in our views and templates. The profile page will simply display the following attributes from the <code>request.user</code> object:</p>
			<ul>
				<li><code>username</code></li>
				<li><code>first_name</code> and <code>last_name</code></li>
				<li><code>date_joined</code></li>
				<li><code>email</code></li>
				<li><code>last_login</code></li>
			</ul>
			<p>Perform the following steps to complete this exercise:</p>
			<ol>
				<li value="1">Add <code>bookr/views.py</code> to the project. It needs a trivial profile function to define our view:<pre>from django.shortcuts import render
def profile(request):
    return render(request, 'profile.html')</pre></li>
				<li>In the templates folder of your main <code>bookr</code> project, create a new file called <code>profile.html</code>. In this template, the attributes of the <code>request.user</code> object can easily be referenced by using a notation such as <code>{{ request.user.username }}</code>:<pre>{% extends "base.html" %}
{% block title %}Bookr{% endblock %}
{% block content %}
&lt;h2&gt;Profile&lt;/h2&gt;
&lt;div&gt;
  &lt;p&gt;
      Username: {{ request.user.username }} &lt;br&gt;
      Name: {{ request.user.first_name }} {{ request.user.last_name }}&lt;br&gt;
      Date Joined: {{ request.user.date_joined }} &lt;br&gt;
      Email: {{ request.user.email }}&lt;br&gt;
      Last Login: {{ request.user.last_login }}&lt;br&gt;
  &lt;/p&gt;
&lt;/div&gt;
{% endblock %}</pre><p>Also, we added a block containing profile details of the user. More importantly, we made sure that <code>profile.html</code> extends <code>base.html</code>.</p></li>
				<li>Finally, this path needs to be added to the top of the <code>urlpatterns</code> list in <code>bookr/urls.py</code>. First, import the new views and then add a path linking the URL <code>accounts/profile/</code> to <code>bookr.views.profile</code>:<pre>from bookr.views import profile
urlpatterns = [path('accounts/', \
                    include(('django.contrib.auth.urls', 'auth')),\
                   (namespace='accounts')),\
               <code>http://localhost:8000/accounts/profile/</code>, it is rendered as shown in the screenshot in <em class="italic">Figure 9.4</em>. Remember, if the server needs to be started, use the <code>python manage.py runserver</code> command:</p><div><img src="img/B15509_09_04.jpg" alt="Figure 9:4: Alice visits her user profile&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 9:4: Alice visits her user profile</p>
			<p>We've seen how we can redirect a user to their profile page, once they've successfully logged in. Let's now discuss how we can give content access to specific users only.</p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor284"/>Authentication Decorators and Redirection</h2>
			<p>Now that we have learned how to allow ordinary users to log in to our project, we can discover how to restrict content to authenticated users. The authentication module comes with some useful decorators that can be used to secure views according to the current user's authentication or access.</p>
			<p>Unfortunately, if, say, a user named Alice was to log out of Bookr, the profile page would still render and display empty details. Instead of this happening, it would be preferable for any unauthenticated visitor to be directed to the login screen:</p>
			<div><div><img src="img/B15509_09_05.jpg" alt="Figure 9.5: An unauthenticated user visits a user profile&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5: An unauthenticated user visits a user profile</p>
			<p>The authentication app comes with useful decorators for adding authentication behavior to Django views. In this situation of securing our profile view, we can use the <code>login_required</code> decorator:</p>
			<pre>from django.contrib.auth.decorators import login_required
@login_required
def profile(request):
    …</pre>
			<p>Now if an unauthenticated user visits the <code>/accounts/profile</code> URL, they will be redirected to <code>http://localhost:8000/accounts/login/?next=/accounts/profile/</code>.</p>
			<p>This URL takes the user to the login URL. The <code>next</code> parameter in the <code>GET</code> variables tells the login view where to redirect to after a successful login. The default behavior is to redirect back to the current view, but this can be overridden by specifying the <code>login_url</code> argument to the <code>login_required</code> decorator. For example, if we had some need to redirect to a different page after login, we could have explicitly stated it in the decorator call like this:</p>
			<pre>@login_required(login_url='/accounts/<strong class="bold">profile2</strong>')</pre>
			<p>If we had rewritten our login view to expect the redirection URL to be specified in a different URL argument to <code>'next'</code>, we could explicate this in the decorator call with the <code>redirect_field_name</code> argument:</p>
			<pre>@login_required(<strong class="bold">redirect_field_argument='redirect_to'</strong>)</pre>
			<p>There are often situations where a URL should be restricted to users or groups holding a specific condition. Consider the case where we have a page for staff users to view any user profile. We don't want this URL to be accessible to all users, so we want to limit this URL to users or groups with the <code>'view_user'</code> permission and to forward the unauthorized requests to the login URL:</p>
			<pre>from django.contrib.auth.decorators \
import login_required, permission_required
…
@permission_required('view_group')
def user_profile(request, uid):
    user = get_object_or_404(User, id=uid)
    permissions = user.get_all_permissions()
    return render(request, 'user_profile.html',\
                  {'user': user, 'permissions': permissions}</pre>
			<p>So with this decorator applied on our <code>user_profile</code> view, an unauthorized user visiting <code>http://localhost:8000/accounts/users/123/profile/</code> would be redirected to <code>http://localhost:8000/accounts/login/?next=/accounts/users/123/profile/</code>.</p>
			<p>Sometimes, though, we need to structure more subtle conditional permissions that don't fall into the scope of these two directors. For this purpose, Django provides a custom decorator that takes an arbitrary function as an argument. The <code>user_passes_test</code> decorator requires a <code>test_func</code> argument:</p>
			<pre>user_passes_test(test_func, login_url=None, redirect_field_name='next')</pre>
			<p>Here's an example where we have a view, <code>veteran_features</code>, that is only available to users who have been registered on the site for more than a year:</p>
			<pre>from django.contrib.auth.decorators import (login_required),\
                                           (permission_required),\
                                           (user_passes_test)
…
def veteran_user(user):
    now = datetime.datetime.now()
    if user.date_joined is None:
        return False
    return now - user.date_joined &gt; datetime.timedelta(days=365)
@user_passes_test(veteran_user)
def veteran_features(request):
    user = request.user
    permissions = user.get_all_permissions()
    return render(request, 'veteran_profile.html',\
                  {'user': user, 'permissions': permissions}</pre>
			<p>Sometimes the logic in our views cannot be handled with one of these decorators and we need to apply the redirect within the control flow of the view. We can do this using the <code>redirect_to_login</code> helper function. It takes the same arguments as the decorators, as shown in the following snippet:</p>
			<pre>redirect_to_login(next, login_url=None, redirect_field_name='next')</pre>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor285"/>Exercise 9.03: Adding Authentication Decorators to the Views</h2>
			<p>Having learned about the flexibility of the authentication app's permission and authentication decorators, we will now set about putting them to use in the Reviews app. We need to ensure that only authenticated users can edit reviews and that only staff users can edit publishers. There are several ways of doing this, so we will attempt a few approaches. All the code in these steps is in the <code>reviews/views.py</code> file:</p>
			<ol>
				<li value="1">Your first instinct to solve this problem would be to think that the <code>publisher_edit</code> method needs an appropriate decorator to enforce that the user has <code>edit_publisher</code> permission. For this, you could easily do something like this:<pre>from django.contrib.auth.decorators import permission_required 
…
@permission_required('edit_publisher')
def publisher_edit(request, pk=None):
    …</pre></li>
				<li>Using this method is fine and it's one way to add permissions checking to a view. You can also use a slightly more complicated but more flexible method. Instead of using a permission decorator to enforce permission rights on the <code>publisher_edit</code> method, you will create a test function that requires a staff user and apply this test function to <code>publisher_edit</code> with the <code>user_passes_test</code> decorator. Writing a test function allows more customization on how you validate users' access rights or permissions. If you made changes to your <code>views.py</code> file in <em class="italic">step 1</em>, feel free to comment the decorator out (or delete it) and write the following test function instead:<pre>from django.contrib.auth.decorators import user_passes_test
…
def is_staff_user(user):
    return user.is_staff
@user_passes_test(is_staff_user)
    …</pre></li>
				<li>Ensure that login is required for the <code>review_edit</code> and <code>book_media</code> functions by adding the appropriate decorator:<pre>…
from django.contrib.auth.decorators import login_required, \
                                           user_passes_test
…
@login_required
def review_edit(request, book_pk, review_pk=None):
@login_required
def book_media(request, pk):
…</pre></li>
				<li>In the <code>review_edit</code> method, add logic to the view that requires that the user be either a staff user or the owner of the review. The <code>review_edit</code> view controls the behavior of both review creation and review updates. The constraint that we are developing only applies to the case where an existing review is being updated. So, the place to add code is after a <code>Review</code> object has been successfully retrieved. If the user is not a staff account or the review's creator doesn't match the current user, we need to raise a <code>PermissionDenied</code> error:<pre>…
from django.core.exceptions import PermissionDenied
from PIL import Image
from django.contrib import messages
…
@login_required
def review_edit(request, book_pk, review_pk=None):
    book = get_object_or_404(Book, pk=book_pk)
    if review_pk is not None:
        review = get_object_or_404(Review),\
                                 (book_id=book_pk),\
                                 (pk=review_pk)
        user = request.user
        if not user.is_staff and review.creator.id != user.id:
            raise PermissionDenied
    else:
        review = None
…</pre><p>Now, when a non-staff user attempts to edit another user's review, a <code>Forbidden</code> error will be thrown, as in <em class="italic">Figure 9.6</em>. In the next section, we will look at applying conditional logic in templates so that users aren't taken to pages that they don't have sufficient permission to access:</p><div><img src="img/B15509_09_06.jpg" alt="Figure 9.6: Access is forbidden to non-staff users&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 9.6: Access is forbidden to non-staff users</p>
			<p>In this exercise, we have used authentication decorators to secure views in a Django app. The authentication decorators that were applied provided a simple mechanism to restrict views from users lacking necessary permissions, non-staff users, and unauthenticated users. Django's authentication decorators provide a robust mechanism that follows Django's role and permission framework, while the <code>user_passes_test</code> decorator provides an option to develop custom authentication.</p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor286"/>Enhancing Templates with Authentication Data</h2>
			<p>In <em class="italic">Exercise 9.02</em>, <em class="italic">Adding a Profile Page</em>, we saw that we can pass the <code>request.user</code> object to the template to render the current user's attributes in the HTML. We can also take the approach of giving different template renderings according to the user type or permissions held by a user. Consider that we want to add an edit link that only appears to staff users. We might apply an <code>if</code> condition to achieve this:</p>
			<pre>{% if user.is_staff %}
  &lt;p&gt;&lt;a href="{% url 'review:edit' %}"&gt;Edit this Review&lt;/a&gt;&lt;/p&gt;
{% endif %}</pre>
			<p>If we didn't take the time to conditionally render links based on permissions, users would have a frustrating experience navigating the application as many of the links that they click on would lead to <code>403 Forbidden</code> pages. The following exercise will show how we can use templates and authentication to present contextually appropriate links in our project.</p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor287"/>Exercise 9.04: Toggling Login and Logout Links in the Base Template </h2>
			<p>In the <code>bookr</code> project's base template, located in <code>templates/base.html</code>, we have a placeholder logout link in the header. It is coded in HTML as follows:</p>
			<pre>&lt;li class="nav-item"&gt;
  &lt;a class="nav-link" href="#"&gt;Logout&lt;/a&gt;
&lt;/li&gt;</pre>
			<p>We don't want the logout link to appear after a user has logged out. So, this exercise aims to apply conditional logic in the template so that <code>Login</code> and <code>Logout</code> links are toggled depending on whether the user is authenticated:</p>
			<ol>
				<li value="1">Edit the <code>templates/base.html</code> file. Copy the structure of the <code>Logout</code> list element and create a <code>Login</code> list element. Then, replace the placeholder links with the correct URLs for the <code>Logout</code> and <code>Login</code> pages – <code>/accounts/logout</code> and <code>/accounts/login</code>, respectively – as follows:<pre>&lt;li class="nav-item"&gt;
  &lt;a class="nav-link" href="/accounts/logout"&gt;Logout&lt;/a&gt;
&lt;/li&gt;
&lt;li class="nav-item"&gt;
  &lt;a class="nav-link" href="/accounts/login"&gt;Login&lt;/a&gt;
&lt;/li&gt;</pre></li>
				<li>Now put our two <code>li</code> elements inside an <code>if … else … endif</code> conditional block. The logic condition that we are applying is <code>if user.is_authenticated</code>:<pre>{% if user.is_authenticated %}
  &lt;li class="nav-item"&gt;
    &lt;a class="nav-link" href="/accounts/logout"&gt;Logout&lt;/a&gt;
  &lt;/li&gt;
    {% else %}
  &lt;li class="nav-item"&gt;
    &lt;a class="nav-link" href="/accounts/login"&gt;Login&lt;/a&gt;
  &lt;/li&gt;
{% endif %}</pre></li>
				<li>Now visit the user profile page at <code>http://localhost:8000/accounts/profile/</code>. When authenticated, you will see the <code>Logout</code> link:<div><img src="img/B15509_09_07.jpg" alt="Figure 9.7: An authenticated user sees the Logout link&#13;&#10;"/></div><p class="figure-caption">Figure 9.7: An authenticated user sees the Logout link</p></li>
				<li>Now click the <code>Logout</code> link; you will be taken to the <code>/accounts/logout</code> page. The <code>Login</code> link appears in the menu, confirming that the link is contextually dependent on the authentication state of the user:<div><img src="img/B15509_09_08.jpg" alt="Figure 9.8: An unauthenticated user sees the Login link &#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 9.8: An unauthenticated user sees the Login link </p>
			<p>This exercise was a simple example of how Django templates can be used with authentication information to create a stateful and contextual user experience. We also do not want to provide links that a user does not have access to or actions that are not permissible for the user's permission level. The following activity will use this templating technique to fix some of these problems in Bookr. </p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor288"/>Activity 9.01: Authentication-Based Content Using Conditional Blocks in Templates </h2>
			<p>In this activity, you will apply conditional blocks in templates that modify content based on user authentication and user status. Users should not be presented with links that they are not permitted to visit or actions that they are not authorized to carry out. The following steps will help you complete this activity:</p>
			<ol>
				<li value="1">In the <code>book_detail</code> template, in the file at <code>reviews/templates/reviews/book_detail.html</code>, hide the <code>Add Review</code> and <code>Media</code> buttons from non-authenticated users. </li>
				<li>Also, hide the heading that says "<em class="italic">Be the first one to write a review</em>," as that is not an option for non-authenticated users.</li>
				<li>In the same template, make the <code>Edit Review</code> link only appear for the staff or the user that wrote the review. The conditional logic for the template block is very similar to the conditional logic that we used in the <code>review_edit</code> view in the previous section:<div><img src="img/B15509_09_09.jpg" alt="Figure 9.9: The Edit Review link appears on Alice's review when Alice is logged in&#13;&#10;"/></div><p class="figure-caption">Figure 9.9: The Edit Review link appears on Alice's review when Alice is logged in</p><div><img src="img/B15509_09_10.jpg" alt="Figure 9.10: There is no Edit Review link on Alice's review when Bob is logged in&#13;&#10;"/></div><p class="figure-caption">Figure 9.10: There is no Edit Review link on Alice's review when Bob is logged in</p></li>
				<li>Modify <code>template/base.html</code> so that it displays the currently authenticated user's username to the right of the search form in the header, linking to the user profile page.<p>By completing this activity, you will have added dynamic content to the template that reflects the authentication state and identity of the current user, as can be seen from the following screenshot:</p><div><img src="img/B15509_09_11.jpg" alt="Figure 9.11: An authenticated user's name appears after the search form&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 9.11: An authenticated user's name appears after the search form</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="http://packt.live/2Nh1NTJ">http://packt.live/2Nh1NTJ</a>.</p>
			<h1 id="_idParaDest-274"><a id="_idTextAnchor289"/>Sessions</h1>
			<p>It is worth looking at some theory to understand why sessions are a common solution in web applications for managing user content. The HTTP protocol defines the interactions between a client and a server. It is said to be a "stateless" protocol as no stateful information is retained by the server between requests. This protocol design worked well for delivering hypertextual information in the early days of the World Wide Web, but it did not suit the needs of secured web applications delivering customized information to specific users.</p>
			<p>We are now acquainted with seeing websites adapt to our personal viewing habits. Shopping sites recommend similar products to the ones that we have recently viewed and tell us about products that are popular in our region. These features all required a stateful approach to website development. One of the most common ways to implement a stateful web experience is through <strong class="bold">sessions</strong>. A session refers to a user's current interaction with a web server or application and requires that data is persisted for the duration of the interaction. This may include information about the links that the user has visited, the actions that they have performed, and the preferences that they have made in their interactions.</p>
			<p>If a user sets a blogging site to a dark theme on one page, there is an expectation that the next page will use the same theme as well. We describe this behavior as "maintaining state." A session key is stored client-side as a browser cookie, which can be identified with server-side information that persists while the user is logged in.</p>
			<p>In Django, sessions are implemented as a form of middleware. When we initially created the app in <em class="italic">Chapter 4</em>, <em class="italic">Introduction to Django Admin</em>, session support was activated by default.</p>
			<h3 id="_idParaDest-275"><a id="_idTextAnchor290"/>The Session Engine</h3>
			<p>Information about current and expired sessions needs to be stored somewhere. In the early days of the World Wide Web, this was done through saving session information in files on the server, but as web server architectures have become more elaborate and their performance demands have increased, other more efficient strategies such as a database or in-memory storage have become the norm. By default, in Django, session information is stored in a project's database.</p>
			<p>This is a reasonable default for most small projects. However, Django's middleware implementation of sessions gives us the flexibility to store our project's session information in a variety of ways to suit our system architecture and performance requirements. Each of these different implementations is called a session engine. If we want to change the session configuration, we need to specify the <code>SESSION_ENGINE</code> setting in the project's <code>settings.py</code> file:</p>
			<ul>
				<li><code>django.contrib.sessions.backends.cache</code> and <code>django.contrib.sessions.backends.cached_db</code> session engines for this purpose.</li>
				<li><strong class="bold">File-based sessions</strong>: As stated earlier, this is a somewhat antiquated way of maintaining session information but may suit some sites where performance is not an issue and there are reasons not to store dynamic information in a database.</li>
				<li><strong class="bold">Cookie-based sessions</strong>: Rather than keeping session information server-side, you can keep them entirely in the web browser client by serializing the contents of the session as JSON and storing it in a browser-based cookie.</li>
			</ul>
			<h3 id="_idParaDest-276"><a id="_idTextAnchor291"/>Do You Need to Flag Cookie Content?</h3>
			<p>All of Django's implementations of sessions require storing a session ID in a cookie on the user's web browser. </p>
			<p>Regardless of the session engine employed, all these middleware implementations involve storing a site-specific cookie in the web browser. In the early days of web development, it was not uncommon to pass session IDs as URL arguments, but this approach has been eschewed in Django for reasons of security.</p>
			<p>In many jurisdictions, including the European Union, websites are legally required to warn users if the site sets cookies in their browsers. If there are such legislative requirements in the region where you intend to operate your site, it is your responsibility to ensure that the code meets these obligations. Be sure to use up-to-date implementations and avoid using abandoned projects that have not kept pace with legislative changes. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">To cater to these changes and legislative requirements, there are many useful apps, such as <strong class="bold">Django Simple Cookie Consent</strong> and <strong class="bold">Django Cookie Law</strong>, that are designed to work with several legislative frameworks. You can find more by going to the following links:</p>
			<p class="callout"><a href="https://pypi.org/project/django-simple-cookie-consent/">https://pypi.org/project/django-simple-cookie-consent/</a></p>
			<p class="callout"><a href="https://github.com/TyMaszWeb/django-cookie-law">https://github.com/TyMaszWeb/django-cookie-law</a></p>
			<p class="callout">Many JavaScript modules exist that implement similar cookie consent mechanisms.</p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor292"/>Pickle or JSON storage</h2>
			<p>Python provides the <strong class="bold">pickle</strong> module in its standard library for serializing Python objects into a byte stream representation. A pickle is a binary structure that has the benefit of being interoperable between different architectures and different versions of Python, so that a Python object can be serialized to a pickle on a Windows PC and deserialized to a Python object on a Linux Raspberry Pi.</p>
			<p>This flexibility comes with security vulnerabilities and it is not recommended that it is used to represent untrusted data. Consider the following Python object, which contains several types of data. It can be serialized using <code>pickle</code>:</p>
			<pre>import datetime
data = dict(viewed_books=[17, 18, 3, 2, 1],\
            search_history=['1981', 'Machine Learning', 'Bronte'],\
            background_rgb=(96, 91, 92),\
            foreground_rgb=(17, 17, 17),\
            last_login_login=datetime.datetime(2019, 12, 3, 15, 30, 30),\
            password_change=datetime.datetime(2019, 9, 2, 8, 41, 25),\
            user_class='Veteran',\
            average_rating=4.75,\
            reviewed_books={18, 3, 7})</pre>
			<p>Using the <code>dumps</code> (dump string) method of the <code>pickle</code> module, we can serialize the data object to produce a byte representation:</p>
			<pre>import pickle
data_pickle = pickle.dumps(data)</pre>
			<p><code>pickle</code> format:</p>
			<pre>import json
data_json = json.dumps(data)</pre>
			<p>Because data contains Python <code>datetime</code> and <code>set</code> objects, which aren't serializable with JSON, when we attempt to serialize the structure a type error will be thrown:</p>
			<pre>TypeError: Object of type datetime is not JSON serializable</pre>
			<p>For serializing to JSON, we could convert the <code>datetime</code> objects to <code>string</code> and <code>set</code> to a list:</p>
			<pre>data['last_login_login'] = data['last_login_login'].strftime("%Y%d%m%H%M%S")
data['password_change'] = data['password_change'].strftime("%Y%d%m%H%M%S")
data['reviewed_books'] = list(data['reviewed_books'])</pre>
			<p>As JSON data is human readable, it is easy to examine:</p>
			<pre>{"viewed_books": [17, 18, 3, 2, 1], "search_history": ["1981", "Machine Learning", "Bronte"], "background_rgb": [96, 91, 92], "foreground_rgb": [17, 17, 17], "last_login_login": "20190312153030", "password_change": "20190209084125", "user_class": "Veteran", "average_rating": 4.75, "reviewed_books": [18, 3, 7]}</pre>
			<p>Note that we had to explicitly convert the <code>datetime</code> and <code>set</code> objects, but the tuple is automatically converted to a list by the JSON. Django ships with <code>PickleSerializer</code> and <code>JSONSerializer</code>. If the situation arises where the serializer needs to be altered, it can be changed by setting the <code>SESSION_SERIALIZER</code> variable in the project's <code>settings.py</code> file:</p>
			<pre>SESSION_SERIALIZER = 'django.contrib.sessions.serializers.JSONSerializer'</pre>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor293"/>Exercise 9.05: Examining the Session Key</h2>
			<p>The purpose of this exercise is to query the project's SQLite database and perform queries on the session table, so as to become familiar with how session data is stored. You will then create a Python script for examining session data that is stored using <code>JSONSerializer</code>:</p>
			<ol>
				<li value="1">At a command prompt, open the project database using this command:<pre>sqlite3 db.sqlite3</pre></li>
				<li>Use the <code>.schema</code> directive to observe the structure of the <code>django_session</code> table as follows:<pre>sqlite&gt; .schema django_session
CREATE TABLE IF NOT EXISTS "django_session" ("<code>django_session</code> table in the database stores session information in the following fields:</p><p><code>session_key</code></p><p><code>session_data</code></p><p><code>expire_date</code></p></li>
				<li>Query the data in the <code>django_session</code> table by using the SQL command <code>select * from django_session;</code>:<div><img src="img/B15509_09_12.jpg" alt="Figure 9.12: Querying data in the django_session table&#13;&#10;"/></div><p class="figure-caption">Figure 9.12: Querying data in the django_session table</p><p class="callout-heading">Note</p><p class="callout">To exit <code>sqlite3</code>, hit <em class="italic">Ctrl </em>+ <em class="italic">D</em> on Linux and macOS or <em class="italic">Ctrl</em> + <em class="italic">Z</em> and <em class="italic">Enter</em> on Windows.</p></li>
				<li>We have observed that the session data is encoded in <code>base64</code> format. We can decrypt this data at the Python command line using the <code>base64</code> module. Once decoded from <code>base64</code>, the <code>session_key</code> data contains a <code>binary_key</code> and a JSON payload separated by a colon:<pre>b'\x82\x1e"z\xc9\xb4\xd7\xbf8\x83K…5e02:{"_auth_user_id":"1"…}'</pre><p>This Python code shows how to obtain the payload:</p><p>     </p><div><img src="img/B15509_09_13.jpg" alt="Figure 9.13: Decoding the session key with the Python shell&#13;&#10;"/></div><p class="figure-caption">Figure 9.13: Decoding the session key with the Python shell</p><p>We can see the structure that is encoded in the payload. The payload represents the minimal data stored in a session. It contains keys for <code>_auth_user_id</code>, <code>_auth_user_backend</code>, and <code>_auth_user_hash</code> with values obtained from <code>User.id</code>, the <code>ModelBackend</code> class name, and the hash that is derived from the user's for password information. We will learn how to add additional data in the next section.</p></li>
				<li>We will develop a simple Python utility for decrypting this session information. It requires modules that we have used as well as <code>pprint</code> for formatting output and the <code>sys</code> module for checking command-line arguments:<pre>import base64
import json
import pprint
import sys</pre></li>
				<li>After the <code>import</code> statements, write a function that decodes the session key and loads the JSON payload as a Python dictionary:<pre>def get_session_dictionary(session_key):
    binary_key, payload = base64.b64decode\
                          (session_key).split(b':', 1)
    session_dictionary = json.loads(payload.decode())
    return session_dictionary</pre></li>
				<li>Add a code block so that when this utility is run, it takes a <code>session_key</code> argument specified at the command line and converts it to a dictionary using the <code>get_session_dictionary</code> function. Then, use the <code>pprint</code> module to print an indented version of the dictionary structure:<pre>if __name__ == '__main__':
    if len(sys.argv)&gt;1:
        session_key = sys.argv[1]
        session_dictionary = get_session_dictionary(session_key)
        pp = pprint.PrettyPrinter(indent=4)
        pp.pprint(session_dictionary)</pre></li>
				<li>Now you can use this Python script to examine session data that is stored in the database. You can call it on the command line by passing the session data as an argument as follows:<pre>    python session_info.py &lt;session_data&gt;</pre><p>It will be useful for debugging session behavior when you attempt the final activity:</p><div><img src="img/B15509_09_14.jpg" alt="Figure 9.14: Python script&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 9.14: Python script</p>
			<p>This script outputs the decoded session information. At present, the session only contains three keys:</p>
			<p><code>_auth_user_backend</code> is a string representation of the class of the user backend. As our project stores user credentials in the model, <code>ModelBackend</code> is used.</p>
			<p><code>_auth_user_hash</code> is a hash of the user's password.</p>
			<p><code>_auth_user_id</code> is the user ID obtained from the model's <code>User.id</code> attribute.</p>
			<p>This exercise helped you become familiar with how session data is stored in Django. We will now turn our attention to adding additional information to Django sessions.</p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor294"/>Storing Data in Sessions</h2>
			<p>We've covered the way sessions are implemented in Django. Now we are going to briefly examine some of the ways that we can make use of sessions to enrich our user experience. In Django, the session is an attribute of the <code>request</code> object. It is implemented as a dictionary-like object. In our views, we can assign keys to the <code>session</code> object like a typical dictionary, as here:</p>
			<pre>request.session['books_reviewed_count'] = 39</pre>
			<p>But there are some restrictions. First, the keys in the session must be strings, so integers and timestamps are not allowed. Secondly, keys starting with an underscore are reserved for internal system use. Data is limited to values that can be encoded as JSON, so some byte sequences that can't be decoded as UTF-8, such as the <code>binary_key</code> listed previously, can't be stored as JSON data. The other warning is to avoid reassigning <code>request.session</code> to a different value. We should only assign or delete keys. So, don't do this:</p>
			<pre>request.session = {'books_read_count':30, 'books_reviewed_count': 39}</pre>
			<p>Instead, do this:</p>
			<pre>request.session['books_read_count'] = 30
request.session['books_reviewed_count'] = 39</pre>
			<p>With those restrictions in mind, we will investigate the use that we can make of session data in our Reviews application.</p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor295"/>Exercise 9.06: Storing Recently Viewed Books in Sessions</h2>
			<p>The purpose of this exercise is to use the session to keep information about the <code>10</code> books that have been most recently browsed by the authenticated user. This information will be displayed on the profile page of the <code>bookr</code> project. When a book is browsed, the <code>book_detail</code> view is called. In this exercise, we will edit <code>reviews/views.py</code> and add some additional logic to the <code>book_detail</code> method. We will add a key to the session called <code>viewed_books</code>. Using basic knowledge of HTML and CSS, the page can be created to show the profile details and viewed books stored in separate divisions of the page, as follows:</p>
			<div><div><img src="img/B15509_09_15.jpg" alt="Figure 9.15: The Profile page incorporating Viewed Books&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.15: The Profile page incorporating Viewed Books</p>
			<ol>
				<li value="1">Edit <code>reviews/views.py</code> and the <code>book_detail</code> method. We are only interested in adding session information for authenticated users, so add a conditional statement to check whether the user is authenticated and set <code>max_viewed_books_length</code>, the maximum length of the viewed books list, to <code>10</code>:<pre>def book_detail(request, pk):
    …
    if request.user.is_authenticated:
        max_viewed_books_length = 10</pre></li>
				<li>Within the same conditional block, add code to retrieve the current value of <code>request.session['viewed_books']</code>. If this key isn't present in the session, start with an empty list:<pre>        viewed_books = request.session.get('viewed_books', [])</pre></li>
				<li>If the current book's primary key is already present in <code>viewed_books</code>, the following code will remove it:<pre>        viewed_book = [book.id, book.title]
        if viewed_book in viewed_books:
            viewed_books.pop(viewed_books.index(viewed_book))</pre></li>
				<li>The following code inserts the current book's primary key to the start of the <code>viewed_books</code> list:<pre>        viewed_books.insert(0, viewed_book)</pre></li>
				<li>Add the following key to only keep the first 10 elements of the list:<pre>        viewed_books = viewed_books[:max_viewed_books_length]</pre></li>
				<li>The following code will add our <code>viewed_books</code> back to <code>session[ 'viewed_books']</code>, so that it is available in subsequent requests:<pre>        request.session['viewed_books'] = viewed_books</pre></li>
				<li>As before, at the end of the <code>book_detail</code> function, render the <code>reviews/book_detail.html</code> template given the request and context data:<pre>    return render(request, "reviews/book_detail.html", context)</pre><p>Once complete, the <code>book_detail</code> view will have this conditional block:</p><pre>def book_detail(request, pk):
    …
    if request.user.is_authenticated:
        max_viewed_books_length = 10
        viewed_books = request.session.get('viewed_books', [])
        viewed_book = [book.id, book.title]
        if viewed_book in viewed_books:
            viewed_books.pop(viewed_books.index(viewed_book))
        viewed_books.insert(0, viewed_book)
        viewed_books = viewed_books[:max_viewed_books_length]
        request.session['viewed_books'] = viewed_books
    return render(request, "reviews/book_detail.html", context)</pre></li>
				<li>Modify the page layout and CSS of <code>templates/profile.html</code> to accommodate the viewed book division. As we may add more divisions to this page in the future, one convenient layout concept is the <code>div</code> instances that will be arranged horizontally on the page. We will refer to the internal <code>div</code> instances as <code>infocell</code> instances and style them with green borders and rounded edges:<pre>&lt;style&gt;
.flexrow { display: flex;
           border: 2px black;
}
.flexrow &gt; div { flex: 1; }
.infocell {
  border: 2px solid green;
  border-radius: 5px 25px;
  background-color: white;
  padding: 5px;
  margin: 20px 5px 5px 5px;
}
&lt;/style&gt;
  &lt;div class="flexrow" &gt;
    &lt;div class="infocell" &gt;
      &lt;p&gt;Profile&lt;/p&gt;
      …
    &lt;/div&gt;
    &lt;div class="infocell" &gt;
      &lt;p&gt;Viewed Books&lt;/p&gt;
      …
    &lt;/div&gt;
  &lt;/div&gt;</pre></li>
				<li>Modify the <code>Viewed Books</code> <code>div</code> in <code>templates/profile.html</code> so that if there are books present, their titles are displayed, linked to the individual book detail pages. This will be rendered as follows:<pre>&lt;a href="/books/1"&gt;Advanced Deep Learning with Keras&lt;/a&gt;&lt;br&gt;</pre><p>There should be a message displayed if the list is empty. The entire <code>div</code>, including the iteration through <code>request.session.viewed_books</code>, will look like this:</p><pre>    &lt;div class="infocell" &gt;
      &lt;p&gt;Viewed Books&lt;/p&gt;
      &lt;p&gt;
      {% for book_id, book_title in request.session.viewed_books %}
      &lt;a href="/books/{{ book_id }}"&gt;{{ book_title }}&lt;/a&gt;&lt;br&gt;
      {% empty %}
            No recently viewed books found.
      {% endfor %}
      &lt;/p&gt;
    &lt;/div&gt;</pre><p>This will be the complete profile template once all these changes have been incorporated:</p></li>
			</ol>
			<pre>templates/profile.html
1  {% extends "base.html" %}
2
3  {% block title %}Bookr{% endblock %}
4
5  {% block heading %}Profile{% endblock %}
6
7  {% block content %}
8
9  &lt;style&gt;
You can find the complete code for this file at <a href="http://packt.live/3btvSJZ">http://packt.live/3btvSJZ</a>.</pre>
			<p>This exercise has enhanced the profile page by adding a list of recently viewed books. Now when you visit the login link at <code>http://127.0.0.1:8000/accounts/profile/</code>, you will see this page:</p>
			<div><div><img src="img/B15509_09_16.jpg" alt="Figure 9.16: Recently viewed books &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.16: Recently viewed books </p>
			<p>We can use the <code>session_info.py</code> script that we developed in <em class="italic">Exercise 9.04</em>, <em class="italic">Toggling Login and Logout Links in the Base Template</em>, to examine the user's session once this feature is implemented. It can be called on the command line by passing the session data as an argument:</p>
			<pre>    python session_info.py &lt;session_data&gt;</pre>
			<p>We can see that the book IDs and titles are listed in the <code>viewed_books</code> key. Remember that the encoded data is obtained by querying the <code>django_session</code> table in the SQLite database:</p>
			<div><div><img src="img/B15509_09_17.jpg" alt="Figure 9.17: The viewed books are stored in the session data&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.17: The viewed books are stored in the session data</p>
			<p>In this exercise, we have used Django's session mechanism to store ephemeral information about user interactions with the Django project. We have learned how this information can be retrieved from the user session and be displayed in a view that informs users about their recent activity.</p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor296"/>Activity 9.02: Using Session Storage for the Book Search Page</h2>
			<p>Sessions are a useful way to store short-lived information that assists in maintaining a stateful experience on a site. Users frequently revisit pages such as search forms, and it would be convenient to store their most recently used form settings when they return to those pages. In <em class="italic">Chapter 3</em>, <em class="italic">URL Mapping, Views, and Templates</em>, we developed a book search feature for the <code>bookr</code> project. The book search page has two options for <code>Search in</code> – <code>Title</code> and <code>Contributor</code>. Currently, each time the page is visited, it defaults to <code>Title</code>:</p>
			<div><div><img src="img/B15509_09_18.jpg" alt="Figure 9.18: The Search and Search in fields of the book search form&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.18: The Search and Search in fields of the book search form</p>
			<p>In this activity, you will use session storage so that when the book search page, <code>/book-search</code>, is visited, it will default to the most recently used search option. You will also add a third <code>infocell</code> to the profile page that contains a list of links to the most recently used search terms. These are the steps that you need to complete this activity:</p>
			<ol>
				<li value="1">Edit the <code>book_search</code> view and retrieve <code>search_history</code> from the session.</li>
				<li>When the form has received valid input and a user is logged in, append the search option and search text to the session's search history list.<p>In the case that the form hasn't been filled (for example, when the page is first visited), render the form with the previously used <code>Search in</code> option selected, that is, either <code>Title</code> or <code>Contributor</code> (<em class="italic">Figure 9.19</em>):</p><div><img src="img/B15509_09_19.jpg" alt="Figure 9.19: Selecting Contributor in the search page&#13;&#10;"/></div><p class="figure-caption">Figure 9.19: Selecting Contributor in the search page</p></li>
				<li>In the profile template, include an additional <code>infocell</code> division for <code>Search History</code>.</li>
				<li>List the search history as a series of links to the book search page. The links will take this form: <code>/book-search?search=Python&amp;search_in=title</code>.</li>
			</ol>
			<p>This activity will challenge you to apply session data to solve a usability issue in a web form. This approach will have applicability in many real-world situations and will give you some idea of the use of sessions in creating a stateful web experience. After completing this activity, the profile page will contain the third <code>infocell</code> as in <em class="italic">Figure 9.20</em>:</p>
			<div><div><img src="img/B15509_09_20.jpg" alt="Figure 9.20: The profile page with the Search History infocell&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.20: The profile page with the Search History infocell</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="http://packt.live/2Nh1NTJ">http://packt.live/2Nh1NTJ</a>.</p>
			<h1 id="_idParaDest-282"><a id="_idTextAnchor297"/>Summary</h1>
			<p>In this chapter, we have examined Django's middleware implementation of authentication and sessions. We have learned how to incorporate authentication and permission logic into views and templates. We can set permissions on specific pages and limit their access to authenticated users. We have also examined how to store data in a user's session and render it in subsequent pages.</p>
			<p>Now you have the skills to customize a Django project to deliver a personalized web experience. You can limit the content to authenticated or privileged users and you can personalize a user's experience based on their prior interactions. In the next chapter, we will revisit the Admin app and learn some advanced techniques to customize our user model and apply fine-grained changes to the admin interface for our models.</p>
		</div>
	</body></html>