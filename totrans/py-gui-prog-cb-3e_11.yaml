- en: Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore the different *best practices* that can help
    us to build our GUI efficiently and keep it both *maintainable* and *extendable*.
  prefs: []
  type: TYPE_NORMAL
- en: These best practices will also help you to debug your GUI to get it just the
    way you want it to be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the overview of Python modules for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb40adb7-139a-4b41-a0f4-1610ddbeee5c.png)'
  prefs: []
  type: TYPE_IMG
- en: Knowing how to code using best practices will greatly enhance your Python programming
    skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipes that will be discussed in this chapter are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding spaghetti code
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Using __init__ to connect modules
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixing fall-down and OOP coding
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a code naming convention
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When not to use OOP
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use design patterns successfully
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding complexity
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: GUI design using multiple notebooks
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding spaghetti code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will explore a typical way to create spaghetti code and then
    we will see a much better way of how to avoid such code.
  prefs: []
  type: TYPE_NORMAL
- en: Spaghetti code is code in which a lot of functionality is intertangled.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a new, simple GUI, written in Python using the built-in Python
    `tkinkter` library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having searched online and read the documentation, we might start by writing
    the following code to create our GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new module: `GUI_Spaghetti.py`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and observe the output, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8210fa3a-659d-485f-b811-b38085f5f028.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Compare the preceding GUI to the intended GUI design, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c9648873-cc9e-48b8-94cc-1527bfde7313.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new module, `GUI_NOT_Spaghetti.py`, and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add some controls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some more widgets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and observe the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/791cb3bf-f7d2-47fd-84c3-a06097ba5b17.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the spaghetti code created a GUI, it is very hard to read because there
    is so much confusion in the code. Good code has many advantages over spaghetti
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of spaghetti code first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, consider this example good code (note that there is not much confusion
    in reading the code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The good code has a clearly commented section. We can easily find the import
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following spaghetti code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, consider the following good code. Here, as stated previously, we can easily
    find the import statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Good code, as shown in the preceding block, has a natural flow that follows
    how the widgets get laid out in the main GUI form.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the spaghetti code, the bottom `LabelFrame` gets created before the top
    `LabelFrame`, and it is intermixed with an `import` statement and some widget
    creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of spaghetti code that portrays this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Good code does not contain unnecessary variable assignments, nor does it have
    a `PRINTME` function that does not do the debugging we might expect it to when
    reading the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The following code blocks enumerate this aspect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the spaghetti code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the good code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Good code has none of the instances mentioned for the spaghetti code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `import` statements only import the required modules, and they are not
    cluttered throughout the code. Also, there are no duplicate `import` statements.
    There is no `import *` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The following code blocks enumerate this aspect.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the spaghetti code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the good code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Good code, as shown in the preceding example and compared to spaghetti code,
    has variable names that are quite meaningful. There are no unnecessary `if` statements
    that use the number `1` instead of `True`. It also has good indentation that makes
    the code much more readable.
  prefs: []
  type: TYPE_NORMAL
- en: In `GUI_NOT_Spaghetti.py`, we did not lose the intended window title and our
    check button ended up in the correct position. We also made the `LabelFrame` that
    surrounds the check button visible.
  prefs: []
  type: TYPE_NORMAL
- en: In `GUI_Spaghetti.py`, we both lost the window title and did not display the
    top `LabelFrame`. The check button ended up in the wrong place.
  prefs: []
  type: TYPE_NORMAL
- en: Using __init__ to connect modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create a new Python package using the PyDev plugin for the Eclipse IDE,
    it automatically creates an `__init__.py` module. We can also create it ourselves
    manually, when not using Eclipse.
  prefs: []
  type: TYPE_NORMAL
- en: The `__init__.py` module is usually empty and, then, has a size of 0 KB.
  prefs: []
  type: TYPE_NORMAL
- en: We can use this usually empty module to connect different Python modules by
    entering code into it. This recipe will show how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a new GUI similar to the one we created in the previous recipe,
    *Avoiding spaghetti code*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As our project becomes larger and larger, we naturally break it out into several
    Python modules. Sometimes, it can be complicated to find modules that are located
    in different subfolders, either above or below the code that needs to import it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this recipe sequentially:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty file and save it as `__init__.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look at its size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/50771dad-df83-401a-b1ab-771e1e7c8239.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new module, `GUI__init.py`, and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add some widgets and a callback function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and click the `Click Me` button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/48aeb0d5-3c0a-412a-909c-2cf39f415b58.png)'
  prefs: []
  type: TYPE_IMG
- en: Create three subfolders below where you are running your Python modules from.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name them `Folder1`, `Folder2`, and `Folder3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fed12450-6897-479b-b244-88c0e1dc6d7d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In `Folder3`, create a new module: `MessageBox.py`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Open `GUI__init.py` and save it as `GUI__init_import_folder.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Comment out or delete the `clickMe` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code from your development environment and observe the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1d6b3f2b-eb03-4dcb-ad56-1afe028d32f0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open Command Prompt and try to run it. If running the code is unsuccessful,
    you can see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0fa821f7-a6cc-4549-887f-b2da7a9e6161.png)'
  prefs: []
  type: TYPE_IMG
- en: Open `__init__.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the `__init__.py` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Open `GUI__init_import_folder.py` and save it as `GUI__init_import_folder_directly.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following two import statements and comment out the previous import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code from Command Prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c8b13ae4-8aac-4e6f-bc9a-1828f1fcfc86.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create an `__init__.py` module, it is typically empty with a file size
    of 0 KB.
  prefs: []
  type: TYPE_NORMAL
- en: The `__init__.py` module is not the same as the `__init__(self):` method of
    a Python class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `GUI__init.py`, we created the following function, which imports Python''s
    message box and then uses it to display the message box dialog window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When we move the `clickMe()` message box code into a nested directory folder
    and try to `import` it into our GUI module, we might run into some challenges.
  prefs: []
  type: TYPE_NORMAL
- en: We have created three subfolders below where our Python module lives. We have
    then placed the `clickMe()` message box code into a new Python module, which we
    named `MessageBox.py`. This module is located in `Folder3`, three levels below
    where our Python module is.
  prefs: []
  type: TYPE_NORMAL
- en: We want to import `MessageBox.py` in order to use the `clickMe()` function that
    this module contains.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use Python''s relative import syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the path is hardcoded. If we remove `Folder2`, it would
    no longer work.
  prefs: []
  type: TYPE_NORMAL
- en: In `GUI__init_import_folder.py`, we deleted the local `clickMe()` function and
    now our callback is expected to use the imported `clickMe()` function. This works
    from within Eclipse and other IDEs that set `PYTHONPATH` to a project where you
    develop your code.
  prefs: []
  type: TYPE_NORMAL
- en: It may or may not work from Command Prompt, depending on whether you have set
    `PYTHONPATH` to the root of where the `Ch11_Code\Folder1\Folder2\Folder3` folders
    are located.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this error, we can initialize our Python search path from within the
    `__init__.py` module. This often solves relative import errors.
  prefs: []
  type: TYPE_NORMAL
- en: In the `GUI__init_import_folder_directly.py` module, we no longer have to specify
    the full folder path. We can import the module and its function directly.
  prefs: []
  type: TYPE_NORMAL
- en: We have to explicitly import `__init__` for this code to work.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe showed a few troubleshooting approaches in case you run into this
    sort of challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing fall-down and OOP coding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is an OOP language, yet it does not always make sense to use OOP. For
    simple scripting tasks, the legacy waterfall coding style is still appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a new GUI that mixes both the fall-down coding
    style with the more modern OOP coding style.
  prefs: []
  type: TYPE_NORMAL
- en: We will create an OOP-style class that will display a tooltip when we hover
    the mouse over a widget in a Python GUI, which we will create using the waterfall
    style.
  prefs: []
  type: TYPE_NORMAL
- en: Fall-down and waterfall coding styles are the same. It means that we have to
    physically place code above code before we can call it from the code below. In
    this paradigm, the code literally falls down from the top of our program to the
    bottom of our program when we execute the code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a GUI using `tkinter`, which is similar to the
    GUI we created in the first chapter of this book.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to perform this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: We will first create a GUI using `tkinter` in a procedural fashion and then
    we will add a class to it to display tooltips over GUI widgets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will create a new module: `GUI_FallDown.py`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add some widgets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Add more widgets in a loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and click one of the buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c4fc7273-ebc5-4a85-be6f-2fc231001ab8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new module: `GUI_FallDown_Tooltip.py`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the code from `GUI_FallDown.py` and then add the following code to it at
    the top:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and hover the mouse over several widgets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/339bb25c-a797-443a-ae30-d1126593381e.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we create a Python GUI in `GUI_FallDown.py` using `tkinter` and code
    it in the waterfall style.
  prefs: []
  type: TYPE_NORMAL
- en: We can improve our Python GUI by adding tooltips. The best way to do this is
    to isolate the code that creates the tooltip functionality from our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: We do this by creating a separate class, which has the tooltip functionality,
    and then we create an instance of this class in the same Python module that creates
    our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Using Python, there is no need to place our `ToolTip` class into a separate
    module. We can place it just above the procedural code and then call it from below
    the class code.
  prefs: []
  type: TYPE_NORMAL
- en: In `GUI_FallDown_Tooltip.py`, the code is almost identical to `GUI_FallDown.py`,
    but now we have tooltips.
  prefs: []
  type: TYPE_NORMAL
- en: We can very easily mix and match both procedural and OOP programming in the
    same Python module.
  prefs: []
  type: TYPE_NORMAL
- en: Using a code naming convention
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe will show you the value of adhering to a code naming scheme: it
    helps us to find the code we want to extend, and reminds us of the design of our
    program.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will look at Python module names and look at good naming
    conventions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create example projects with different Python module names to compare
    the naming:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `ModuleNames` folder under `Folder1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following Python modules, 1, 11, 2, and 3:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3b68c8c4-0684-4a69-a664-d5711a57b52e.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, create a new `ModuleNames_` folder under `Folder1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following Python modules, 1, 11, 2, and 3:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f290f8fe-1d3e-4f2d-b62b-e7894af0e317.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, create a new `ModuleNames_Desc` folder under `Folder1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following Python modules, `Logger`, `UnitTests`, `GUI`, and `debug`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d2fa59ec-51d6-420f-a516-a791d5aee4d9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Look at this naming convention as an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5bdd6b95-5c07-4729-a2a0-85db9d4f437b.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 1*, we create a package subfolder named `ModuleNames`.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2*, we add Python modules to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 3*, we create another package folder and add a trailing underscore
    to the name: `ModuleNames_`.'
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4*, we add new Python modules that have the same names as the ones
    in *step 2*.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, we create another package folder with a much more descriptive name,
    `ModuleNames_Desc`.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6*, we add Python modules but this time with much more descriptive
    names that explain the purpose of each Python module.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in *step 7*, we show a full example of how this can look.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, a typical way to start coding is by incrementing numbers, as can be seen
    in `ModuleNames`.
  prefs: []
  type: TYPE_NORMAL
- en: Later, coming back to this code, we don't have much of an idea which Python
    module provides which functionality and, sometimes, our last incremented modules
    are not as good as the earlier versions.
  prefs: []
  type: TYPE_NORMAL
- en: A clear naming convention does help.
  prefs: []
  type: TYPE_NORMAL
- en: A slight improvement is adding underscores, which makes module names more readable,
    as in `ModuleNames_`.
  prefs: []
  type: TYPE_NORMAL
- en: A better way is to add some description of what the module does, as seen in
    `ModuleNames_Desc`.
  prefs: []
  type: TYPE_NORMAL
- en: While not perfect, the names chosen for the different Python modules indicate
    what each module's responsibility is. When we want to add more unit tests, it
    is clear in which module they reside.
  prefs: []
  type: TYPE_NORMAL
- en: In the last example, we are using the placeholder, `PRODUCT`, for a real name.
  prefs: []
  type: TYPE_NORMAL
- en: Replace the word `PRODUCT` with the product you are currently working on.
  prefs: []
  type: TYPE_NORMAL
- en: The entire application is a GUI. All parts are connected. The `DEBUG.py` module
    is only used for debugging code. The main module to invoke the GUI has its name
    reversed when compared with all of the other modules. It starts with `Gui` and
    has a `.pyw` extension.
  prefs: []
  type: TYPE_NORMAL
- en: It is the only Python module that has this extension name.
  prefs: []
  type: TYPE_NORMAL
- en: From this naming convention, if you are familiar enough with Python, it will
    be obvious that, to run this GUI, you can double-click the `Gui_PRODUCT.pyw` module.
  prefs: []
  type: TYPE_NORMAL
- en: All other Python modules contain functionality for the GUI and also execute
    the underlying business logic to fulfill the purpose this GUI addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions for Python code modules are a great help in keeping us efficient
    and helping us to remember our original design. When we need to debug and fix
    a defect or add new functionality, they are the first resources to look at.
  prefs: []
  type: TYPE_NORMAL
- en: Incrementing module names by numbers is not very meaningful and eventually wastes
    development time.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, naming Python variables is more of a free form. Python infers
    types, so we do not have to specify that a variable will be of the `list` type
    (it might not be, or later in the code, it might become a different type).
  prefs: []
  type: TYPE_NORMAL
- en: A good idea for naming variables is to make them descriptive, and it is a good
    idea not to abbreviate too much.
  prefs: []
  type: TYPE_NORMAL
- en: If we wish to point out that a certain variable is designed to be of the `list`
    type, then it is much more intuitive to use the full word `list_of_things` instead
    of `lst_of_things`. Similarly, use for `number` instead of `num`.
  prefs: []
  type: TYPE_NORMAL
- en: 'While it is a good idea to have very descriptive names for variables, sometimes
    that can get too long. In Apple''s Objective-C language, some variable and function
    names are extreme: `thisIsAMethodThatDoesThisAndThatAndAlsoThatIfYouPassInNIntegers:1:2:3`.'
  prefs: []
  type: TYPE_NORMAL
- en: Use common sense when naming variables, methods, and functions.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: When not to use OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python comes built in with OOP capabilities, but at the same time, we can write
    scripts that do not need to use OOP. For some tasks, OOP does not make sense.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show us when not to use OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a Python GUI similar to the previous recipes.
    We will compare the OOP code to the non-OOP alternative way of programming the
    GUI. The resultant output will be the same but the code of the two versions is
    slightly different.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to perform this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's first create a new GUI using the OOP methodology. The code shown in the
    following steps will create the GUI displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new module: `GUI_OOP.py`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a method to create widgets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a menu bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and observe the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/65445ad7-62bc-4f4a-92f0-ad1977fe5656.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s have a look at a new scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new module, `GUI_NOT_OOP.py`, and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Create more widgets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a menu bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create the entire GUI, calling the function that creates the widgets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Run the code. The resultant GUI will be identical to the one from `GUI_OOP.py`
    shown previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we create a Python `tkinter` GUI in OOP style, `GUI_OOP.py`. Then, we
    create the same GUI in a procedural style, `GUI_NOT_OOP.py`.
  prefs: []
  type: TYPE_NORMAL
- en: We can achieve the same GUI without using an OOP approach by restructuring our
    code slightly. First, we remove the `OOP` class and its `__init__` method. Next,
    we move all of the methods to the left and remove the `self` class reference,
    which turns them into unbound functions. We also remove any other `self` references
    our previous code had. Then, we move the `createWidgets` function call below the
    point of the function's declaration. We place it just above the `mainloop` call.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, we achieve the same GUI but without using OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Python enables us to use OOP when it makes sense. Other languages such as Java
    and C# force us to always use the OOP approach to coding. In this recipe, we explored
    a situation when it did not make sense to use OOP.
  prefs: []
  type: TYPE_NORMAL
- en: The OOP approach will be more extendable if the code base grows, but if it's
    certain that it is the only code that's needed, then there's no need to go through
    OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to use design patterns successfully
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create widgets for our Python GUI by using the *factory
    design pattern*. In the previous recipes, we created our widgets either manually
    one at a time or dynamically in a loop. Using the factory design pattern, we will
    use the *factory* to create our widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a Python GUI that has three buttons, each having a different
    style.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a Python GUI with different button styles and we will use a
    factory design pattern to create these different styles:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new module: `GUI_DesignPattern.py`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the factory class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a base class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Create classes that inherit from the base class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a list that contains the previous classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new class that uses the previous code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and observe the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f933506b-a17d-415a-b9e4-ec254f1ecaa9.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We create a base class that our different button style classes inherit from
    and in which each of them overrides the `relief` and `foreground` configuration
    attributes. All subclasses inherit the `getButtonConfig` method from this base
    class. This method returns a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: We also create a button factory class and a list that holds the names of our
    button subclasses. We name the list `buttonTypes`, as our factory will create
    different types of buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Further down in the module, we create the button widgets, using the same `buttonTypes`
    list. We create an instance of the button factory and then we use our factory
    to create our buttons.
  prefs: []
  type: TYPE_NORMAL
- en: The items in the `buttonTypes` list are the names of our subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: We invoke the `createButton` method and then immediately call the `getButtonConfig`
    method of the base class and retrieve the configuration attributes using dot notation.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that our Python GUI factory did indeed create different buttons,
    each having a different style. They differ in the color of their text and their
    `relief` property.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns are a very exciting tool in our software development toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding complexity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will extend our Python GUI and learn ways to handle the increasing
    complexity of our software development efforts.
  prefs: []
  type: TYPE_NORMAL
- en: Our co-workers and clients love the GUIs we create in Python and ask for more
    and more features to add to our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: This increases complexity and can easily ruin our original nice design.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a new Python GUI similar to those in the previous recipes and
    will add many features to it in the form of widgets.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to perform the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: We will start with a Python GUI that has two tabs and then we will add more
    widgets to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new module: `GUI_Complexity_start.py`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a global variable and a class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a method that creates the widgets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and click both tabs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/35bf9481-3a0a-4b34-b4de-d85845b18b44.png)'
  prefs: []
  type: TYPE_IMG
- en: Open `GUI_Complexity_start.py` and save it as `GUI_Complexity_start_add_button.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the `createWidgets` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code just below `__init__(self)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and observe the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6d00c1a7-0e8d-4dc8-b2c3-e4677f664cd9.png)'
  prefs: []
  type: TYPE_IMG
- en: Open `GUI_Complexity_start_add_button.py` and save it as `GUI_Complexity_start_add_three_more_buttons.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the `createWidgets` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and observe the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/20b1d196-a134-4d41-8602-0bc25a950521.png)'
  prefs: []
  type: TYPE_IMG
- en: Open `GUI_Complexity_start_add_three_more_buttons.py` and save it as `GUI_Complexity_start_add_three_more_buttons_add_more.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the `createWidgets` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and observe the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3848bfc4-d4ab-4450-9624-ac8b40e7db8c.png)'
  prefs: []
  type: TYPE_IMG
- en: Open `GUI_Complexity_start_add_three_more_buttons_add_more.py` and save it as
    `GUI_Complexity_end_tab3.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the `createWidgets` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and click on Tab 3:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/322f3e01-e7cc-43fe-8ba3-28b64fb2479e.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We start with a GUI built with `tkinter`, `GUI_Complexity_start.py`, and it
    has some widgets on two tabs. We have created similar GUIs throughout this entire
    book.
  prefs: []
  type: TYPE_NORMAL
- en: The first new feature request we receive is to add functionality to Tab 1, which
    clears the `scrolledtext` widget.
  prefs: []
  type: TYPE_NORMAL
- en: Easy enough. We just add another button to Tab 1.
  prefs: []
  type: TYPE_NORMAL
- en: We also have to create the callback method in `GUI_Complexity_start_add_button.py`
    to add the desired functionality, which we define toward the top of our class
    and outside the method that creates our widgets. Now, our GUI has a new button
    and, when we click it, we clear the text of the `ScrolledText` widget. To add
    this functionality, we had to add code in two places in the same Python module.
  prefs: []
  type: TYPE_NORMAL
- en: We inserted the new button in the `createWidgets` method and then we created
    a new callback method, which our new button calls when it is clicked. We placed
    this code just below the callback of our first button.
  prefs: []
  type: TYPE_NORMAL
- en: Our next feature request is to add more functionality. The business logic is
    encapsulated in another Python module. We invoke this new functionality by adding
    three more buttons to Tab 1 in `GUI_Complexity_start_add_three_more_buttons.py`.
    We use a loop to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Next, our customers ask for more features and we use the same approach in `GUI_Complexity_start_add_three_more_buttons_add_more.py.`
  prefs: []
  type: TYPE_NORMAL
- en: This is not too bad. When we get new feature requests for another 50 new features,
    we start to wonder whether our approach is still the best one to use.
  prefs: []
  type: TYPE_NORMAL
- en: One way to manage the increasing complexity our GUI handles is by adding tabs.
    By adding more tabs and placing related features into their own tab, we get control
    of the complexity and make our GUI more intuitive. We do this in `GUI_Complexity_end_tab3.py`,
    which creates our new Tab 3.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to handle complexity by modularizing our GUI by breaking large features
    into smaller pieces and arranging them in functionally related areas using tabs.
  prefs: []
  type: TYPE_NORMAL
- en: While complexity has many aspects, modularizing and refactoring the code is
    usually a very good approach to handling software code complexity.
  prefs: []
  type: TYPE_NORMAL
- en: GUI design using multiple notebooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create our GUI using multiple notebooks. Surprisingly,
    `tkinter` does not ship out of the box with this functionality, but we can design
    such a widget ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple notebooks will further reduce the complexity discussed in the
    previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a new Python GUI similar to the one in the previous recipe. This
    time, however, we will design our GUI with two notebooks. To focus on this feature,
    we will use functions instead of class methods. Reading the previous recipe will
    be a good introduction to this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to perform this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: To use multiple notebooks within the same GUI, we start by creating two frames.
    The first frame will hold the notebooks and their tabs while the second frame
    will serve as the display area for the widgets each tab is designed to display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new module: `GUI_Complexity_end_tab3_multiple_notebooks.py`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Create callback functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a menu bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Create Tab Display Area 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Create Tab Display Area 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Create Tab Display Area 3:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the code to display a button for all other tabs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the notebook callback:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the GUI with the multiple notebooks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code, click on Tab 1, and observe the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7d71405b-d650-46dc-a728-bdf6b98936e0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Tab 2\. You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7af19d25-73a5-451e-8727-1e7b8dbb504a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Tab 3\. You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/021a189c-81f9-4215-9540-3478441f4576.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Tab 4 in the second row and observe the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9aac87a8-00a5-424b-ae01-c32df2320085.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Tab 5 in the first row and then click the button in Tab Display Area
    to see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e8617474-ee5a-4b9f-bf40-8745996f6ffe.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `GUI_Complexity_end_tab3_multiple_notebooks.py`, we use the grid layout
    manager to arrange the two frames we are creating, placing one above the other.
    Then, we create two notebooks and arrange them within the first frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/258b406b-e5ab-41e9-8fa0-b30c36aecafb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we use a loop to create five tabs and add them to each notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b457857b-d8a7-4b9a-99f0-da56d27a4a87.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We create a callback function and bind the click event of the two notebooks
    to this callback function. Now, when the user clicks on any tab belonging to the
    two notebooks, this callback function will be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84f8dce3-79b9-4519-94b2-ec11126d6bbb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the callback function, we add logic that decides which widgets get displayed
    after clicking a tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f8b9d09-ad12-4845-81ab-aba6fea756e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We add a function that creates a display area and another function that clears
    the area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/350ad1f9-8c9a-4f2f-a35f-d6aec81700f1.png)'
  prefs: []
  type: TYPE_IMG
- en: Note how the `notebook_callback()` function calls the `clear_display_area()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The `clear_display_area()` function knows both the row and column in which the
    widgets of tabs are being created, and, by finding row 0, we can then use `grid_forget()`
    to clear the display.
  prefs: []
  type: TYPE_NORMAL
- en: For tabs 1 to 3 of the first notebook, we create new frames to hold more widgets.
    Clicking any of those three tabs then results in a GUI very similar to the one
    we created in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: These first three tabs are being invoked in the callback function as `display_tab1()`,
    `display_tab2()`, and `display_tab3()` when those tabs are being clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code that runs when clicking on Tab 3 of the first notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ec681ba-6982-4420-be4f-5e23ef044bc7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking any tab other than the first three tabs of the first notebook one
    calls the same function, `display_button()`, which results in a button being displayed
    whose text property is being set to show the notebook and tab number:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af83e6d9-2b75-4d2a-9f84-28cb2333a558.png)'
  prefs: []
  type: TYPE_IMG
- en: Clicking any of these buttons results in a message box.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the code, we invoke the `display_tab1()` function. When the GUI
    first starts up, the widgets of this tab are what get displayed in the display
    area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e267007f-100b-4028-a483-cf12c566ab37.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Running the `GUI_Complexity_end_tab3_multiple_notebooks.py` code of this recipe
    creates the following GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8e45837-4b5e-4cac-a8b2-27bd60a281db.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on Tab 2 of the first notebook clears the tab display area and then
    displays the widgets created in the `display_tab2()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e63dc49-32b4-4bb7-bbcb-0fb1b8fc4aaa.png)'
  prefs: []
  type: TYPE_IMG
- en: Note how the tab display area automatically adjusts to the sizes of the widgets
    being created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking Tab 3 results in the following GUI display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3c252af-465a-4b5b-b6c8-1fe713e59b45.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking any other tab in either the first or the second notebook results in
    a button being displayed in the tab display area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa4bd375-b3e6-4eab-8887-9d40708136e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking any of those buttons results in a message box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2584263f-6438-46f4-a55c-f9b6f6e18708.png)'
  prefs: []
  type: TYPE_IMG
- en: There is no limit to creating notebooks. We can create as many notebooks as
    our design requires.
  prefs: []
  type: TYPE_NORMAL
