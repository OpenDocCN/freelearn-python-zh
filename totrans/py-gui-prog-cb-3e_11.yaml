- en: Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: In this chapter, we will explore the different *best practices* that can help
    us to build our GUI efficiently and keep it both *maintainable* and *extendable*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨不同的 *最佳实践*，这些实践可以帮助我们高效地构建 GUI，并使其既 *可维护* 又 *可扩展*。
- en: These best practices will also help you to debug your GUI to get it just the
    way you want it to be.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些最佳实践还将帮助你调试 GUI，使其达到你想要的样子。
- en: 'Here is the overview of Python modules for this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本章 Python 模块的概述：
- en: '![](img/eb40adb7-139a-4b41-a0f4-1610ddbeee5c.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eb40adb7-139a-4b41-a0f4-1610ddbeee5c.png)'
- en: Knowing how to code using best practices will greatly enhance your Python programming
    skills.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何使用最佳实践将大大提高你的 Python 编程技能。
- en: 'The recipes that will be discussed in this chapter are the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将要讨论的食谱如下：
- en: Avoiding spaghetti code
  id: totrans-7
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用 spaghetti 代码
- en: Using __init__ to connect modules
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `__init__` 连接模块
- en: Mixing fall-down and OOP coding
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合 fall-down 和 OOP 编码
- en: Using a code naming convention
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代码命名约定
- en: When not to use OOP
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当不使用 OOP 时
- en: How to use design patterns successfully
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何成功使用设计模式
- en: Avoiding complexity
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免复杂性
- en: GUI design using multiple notebooks
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个笔记本进行 GUI 设计
- en: Avoiding spaghetti code
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用 spaghetti 代码
- en: In this recipe, we will explore a typical way to create spaghetti code and then
    we will see a much better way of how to avoid such code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨创建 spaghetti 代码的典型方法，然后我们将看到避免此类代码的更好方法。
- en: Spaghetti code is code in which a lot of functionality is intertangled.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: spaghetti 代码是功能很多且相互交织的代码。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will create a new, simple GUI, written in Python using the built-in Python
    `tkinkter` library.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的、简单的 GUI，使用 Python 内置的 `tkinter` 库编写。
- en: How to do it…
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Having searched online and read the documentation, we might start by writing
    the following code to create our GUI:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在网上搜索并阅读文档后，我们可能会先编写以下代码来创建我们的 GUI：
- en: 'Create a new module: `GUI_Spaghetti.py`.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的模块：`GUI_Spaghetti.py`。
- en: 'Add the following code:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Run the code and observe the output, as follows:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并观察以下输出，如下所示：
- en: '![](img/8210fa3a-659d-485f-b811-b38085f5f028.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8210fa3a-659d-485f-b811-b38085f5f028.png)'
- en: 'Compare the preceding GUI to the intended GUI design, as follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前面的 GUI 与预期的 GUI 设计进行比较，如下所示：
- en: '![](img/c9648873-cc9e-48b8-94cc-1527bfde7313.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c9648873-cc9e-48b8-94cc-1527bfde7313.png)'
- en: 'Create a new module, `GUI_NOT_Spaghetti.py`, and add the following code:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的模块，`GUI_NOT_Spaghetti.py`，并添加以下代码：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, add some controls:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一些控件：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add some more widgets:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加更多小部件：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the code and observe the following output:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并观察以下输出：
- en: '![](img/791cb3bf-f7d2-47fd-84c3-a06097ba5b17.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/791cb3bf-f7d2-47fd-84c3-a06097ba5b17.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解代码以更好地理解它。
- en: How it works…
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: While the spaghetti code created a GUI, it is very hard to read because there
    is so much confusion in the code. Good code has many advantages over spaghetti
    code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当 spaghetti 代码创建了一个 GUI 时，它非常难以阅读，因为代码中存在太多的混乱。良好的代码与 spaghetti 代码相比有很多优势。
- en: 'Let''s see an example of spaghetti code first:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看 spaghetti 代码的一个例子：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, consider this example good code (note that there is not much confusion
    in reading the code):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑以下示例为良好的代码（请注意，阅读代码时没有太多的混乱）：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The good code has a clearly commented section. We can easily find the import
    statements:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的代码有一个清晰的注释部分。我们可以轻松地找到导入语句：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Consider the following spaghetti code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 spaghetti 代码：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, consider the following good code. Here, as stated previously, we can easily
    find the import statements:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑以下良好的代码。在这里，如前所述，我们可以轻松地找到导入语句：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Good code, as shown in the preceding block, has a natural flow that follows
    how the widgets get laid out in the main GUI form.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码块所示，良好的代码有一个自然的流程，遵循小部件在主 GUI 表单中的布局方式。
- en: 'In the spaghetti code, the bottom `LabelFrame` gets created before the top
    `LabelFrame`, and it is intermixed with an `import` statement and some widget
    creation:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 spaghetti 代码中，底部的 `LabelFrame` 在顶部的 `LabelFrame` 之前创建，并且与一个 `import` 语句和一些小部件创建混合在一起：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following is an example of spaghetti code that portrays this feature:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 spaghetti 代码的示例，展示了这一特性：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Good code does not contain unnecessary variable assignments, nor does it have
    a `PRINTME` function that does not do the debugging we might expect it to when
    reading the code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的代码不包含不必要的变量赋值，也没有一个 `PRINTME` 函数，它不会进行我们阅读代码时可能期望的调试：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The following code blocks enumerate this aspect.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块列举了这一方面。
- en: 'Here is the spaghetti code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 spaghetti 代码：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is the good code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是良好的代码：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Good code has none of the instances mentioned for the spaghetti code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的代码不应包含任何提到的意大利面代码实例。
- en: 'The `import` statements only import the required modules, and they are not
    cluttered throughout the code. Also, there are no duplicate `import` statements.
    There is no `import *` statement:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句仅导入所需的模块，并且它们不会在代码中杂乱无章。也没有重复的`import`语句。没有`import *`语句：'
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The following code blocks enumerate this aspect.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块列举了这一方面。
- en: 'This is the spaghetti code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是意大利面代码：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is the good code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是良好的代码：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Good code, as shown in the preceding example and compared to spaghetti code,
    has variable names that are quite meaningful. There are no unnecessary `if` statements
    that use the number `1` instead of `True`. It also has good indentation that makes
    the code much more readable.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的代码，如前例所示，与意大利面代码相比，具有相当有意义的变量名。没有使用数字`1`而不是`True`的不必要的`if`语句。它还有良好的缩进，使代码更容易阅读。
- en: In `GUI_NOT_Spaghetti.py`, we did not lose the intended window title and our
    check button ended up in the correct position. We also made the `LabelFrame` that
    surrounds the check button visible.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GUI_NOT_Spaghetti.py`中，我们没有丢失预期的窗口标题，并且我们的复选框最终位于正确的位置。我们还使包围复选框的`LabelFrame`可见。
- en: In `GUI_Spaghetti.py`, we both lost the window title and did not display the
    top `LabelFrame`. The check button ended up in the wrong place.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GUI_Spaghetti.py`中，我们既丢失了窗口标题，也没有显示顶部的`LabelFrame`。复选框最终位于错误的位置。
- en: Using __init__ to connect modules
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用__init__连接模块
- en: When we create a new Python package using the PyDev plugin for the Eclipse IDE,
    it automatically creates an `__init__.py` module. We can also create it ourselves
    manually, when not using Eclipse.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用Eclipse IDE的PyDev插件创建新的Python包时，它会自动创建一个`__init__.py`模块。如果我们不使用Eclipse，我们也可以手动创建它。
- en: The `__init__.py` module is usually empty and, then, has a size of 0 KB.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__.py`模块通常是空的，然后其大小为0 KB。'
- en: We can use this usually empty module to connect different Python modules by
    entering code into it. This recipe will show how to do this.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个通常为空的模块，通过在其中输入代码来连接不同的Python模块。这个菜谱将展示如何做到这一点。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will create a new GUI similar to the one we created in the previous recipe,
    *Avoiding spaghetti code*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的GUI，类似于我们在之前的菜谱中创建的，*避免意大利面代码*。
- en: How to do it…
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: As our project becomes larger and larger, we naturally break it out into several
    Python modules. Sometimes, it can be complicated to find modules that are located
    in different subfolders, either above or below the code that needs to import it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的项目越来越大，我们自然会将其分解成几个Python模块。有时，找到位于不同子目录中的模块可能会很复杂，无论是位于需要导入它的代码之上还是之下。
- en: 'Let''s see this recipe sequentially:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按顺序看看这个菜谱：
- en: Create an empty file and save it as `__init__.py`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空文件并将其保存为`__init__.py`。
- en: 'Look at its size:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看它的大小：
- en: '![](img/50771dad-df83-401a-b1ab-771e1e7c8239.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/50771dad-df83-401a-b1ab-771e1e7c8239.png)'
- en: 'Create a new module, `GUI__init.py`, and add the following code:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的模块，`GUI__init.py`，并添加以下代码：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, add some widgets and a callback function:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一些小部件和回调函数：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the code and click the `Click Me` button:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并点击`Click Me`按钮：
- en: '![](img/48aeb0d5-3c0a-412a-909c-2cf39f415b58.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/48aeb0d5-3c0a-412a-909c-2cf39f415b58.png)'
- en: Create three subfolders below where you are running your Python modules from.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您运行Python模块的目录下创建三个子目录。
- en: 'Name them `Folder1`, `Folder2`, and `Folder3`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们命名为`Folder1`、`Folder2`和`Folder3`：
- en: '![](img/fed12450-6897-479b-b244-88c0e1dc6d7d.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fed12450-6897-479b-b244-88c0e1dc6d7d.png)'
- en: 'In `Folder3`, create a new module: `MessageBox.py`.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Folder3`中创建一个新的模块：`MessageBox.py`。
- en: 'Add the following code:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Open `GUI__init.py` and save it as `GUI__init_import_folder.py`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GUI__init.py`并将其保存为`GUI__init_import_folder.py`。
- en: 'Add the following import:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下导入：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Comment out or delete the `clickMe` function:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉或删除`clickMe`函数：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the code from your development environment and observe the output:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的开发环境中运行代码并观察输出：
- en: '![](img/1d6b3f2b-eb03-4dcb-ad56-1afe028d32f0.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1d6b3f2b-eb03-4dcb-ad56-1afe028d32f0.png)'
- en: 'Open Command Prompt and try to run it. If running the code is unsuccessful,
    you can see the following output:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符并尝试运行它。如果运行代码失败，您可以看到以下输出：
- en: '![](img/0fa821f7-a6cc-4549-887f-b2da7a9e6161.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0fa821f7-a6cc-4549-887f-b2da7a9e6161.png)'
- en: Open `__init__.py`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`__init__.py`。
- en: 'Add the following code to the `__init__.py` module:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`__init__.py`模块中：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Open `GUI__init_import_folder.py` and save it as `GUI__init_import_folder_directly.py`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI__init_import_folder.py` 并将其保存为 `GUI__init_import_folder_directly.py`。
- en: 'Add the following two import statements and comment out the previous import:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下两个导入语句并注释掉之前的导入：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run the code from Command Prompt:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符中运行代码：
- en: '![](img/c8b13ae4-8aac-4e6f-bc9a-1828f1fcfc86.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8b13ae4-8aac-4e6f-bc9a-1828f1fcfc86.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解代码，以便更好地理解它。
- en: How it works…
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When we create an `__init__.py` module, it is typically empty with a file size
    of 0 KB.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个 `__init__.py` 模块时，它通常是空的，文件大小为 0 KB。
- en: The `__init__.py` module is not the same as the `__init__(self):` method of
    a Python class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__.py` 模块与 Python 类的 `__init__(self):` 方法不同。'
- en: 'In `GUI__init.py`, we created the following function, which imports Python''s
    message box and then uses it to display the message box dialog window:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GUI__init.py` 中，我们创建了以下函数，该函数导入 Python 的消息框，然后使用它来显示消息框对话框：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When we move the `clickMe()` message box code into a nested directory folder
    and try to `import` it into our GUI module, we might run into some challenges.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 `clickMe()` 消息框代码移动到嵌套目录文件夹中并尝试将其 `import` 到我们的 GUI 模块中时，我们可能会遇到一些挑战。
- en: We have created three subfolders below where our Python module lives. We have
    then placed the `clickMe()` message box code into a new Python module, which we
    named `MessageBox.py`. This module is located in `Folder3`, three levels below
    where our Python module is.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的 Python 模块下方创建了三个子文件夹。然后我们将 `clickMe()` 消息框代码放入一个新的 Python 模块中，我们将其命名为
    `MessageBox.py`。此模块位于 `Folder3` 中，位于我们的 Python 模块下方三个层级。
- en: We want to import `MessageBox.py` in order to use the `clickMe()` function that
    this module contains.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想导入 `MessageBox.py` 以使用该模块包含的 `clickMe()` 函数。
- en: 'We can use Python''s relative import syntax:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Python 的相对导入语法：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, the path is hardcoded. If we remove `Folder2`, it would
    no longer work.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，路径是硬编码的。如果我们删除 `Folder2`，它将不再工作。
- en: In `GUI__init_import_folder.py`, we deleted the local `clickMe()` function and
    now our callback is expected to use the imported `clickMe()` function. This works
    from within Eclipse and other IDEs that set `PYTHONPATH` to a project where you
    develop your code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GUI__init_import_folder.py` 中，我们删除了本地的 `clickMe()` 函数，现在我们的回调函数预期将使用导入的 `clickMe()`
    函数。这适用于在 Eclipse 和其他将 `PYTHONPATH` 设置为开发代码的项目路径的 IDE 中。
- en: It may or may not work from Command Prompt, depending on whether you have set
    `PYTHONPATH` to the root of where the `Ch11_Code\Folder1\Folder2\Folder3` folders
    are located.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能或可能不会在命令提示符中工作，这取决于你是否已将 `PYTHONPATH` 设置为 `Ch11_Code\Folder1\Folder2\Folder3`
    文件夹的根目录。
- en: To solve this error, we can initialize our Python search path from within the
    `__init__.py` module. This often solves relative import errors.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个错误，我们可以在 `__init__.py` 模块中初始化我们的 Python 搜索路径。这通常可以解决相对导入错误。
- en: In the `GUI__init_import_folder_directly.py` module, we no longer have to specify
    the full folder path. We can import the module and its function directly.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GUI__init_import_folder_directly.py` 模块中，我们不再需要指定完整的文件夹路径。我们可以直接导入模块及其函数。
- en: We have to explicitly import `__init__` for this code to work.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须显式导入 `__init__` 才能使此代码工作。
- en: This recipe showed a few troubleshooting approaches in case you run into this
    sort of challenge.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了在遇到这种挑战时的几个故障排除方法。
- en: Mixing fall-down and OOP coding
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合逐级下降和面向对象编程（OOP）编码
- en: Python is an OOP language, yet it does not always make sense to use OOP. For
    simple scripting tasks, the legacy waterfall coding style is still appropriate.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种面向对象编程语言，但并不总是使用面向对象编程有意义。对于简单的脚本任务，传统的瀑布式编码风格仍然适用。
- en: In this recipe, we will create a new GUI that mixes both the fall-down coding
    style with the more modern OOP coding style.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将创建一个新的 GUI，它混合了逐级下降编码风格和更现代的面向对象编程风格。
- en: We will create an OOP-style class that will display a tooltip when we hover
    the mouse over a widget in a Python GUI, which we will create using the waterfall
    style.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个面向对象风格的类，当我们将鼠标悬停在 Python GUI 中的小部件上时，它将显示一个工具提示，我们将使用瀑布风格创建它。
- en: Fall-down and waterfall coding styles are the same. It means that we have to
    physically place code above code before we can call it from the code below. In
    this paradigm, the code literally falls down from the top of our program to the
    bottom of our program when we execute the code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 逐级下降和瀑布式编码风格是相同的。这意味着在我们从下面的代码中调用它之前，我们必须在物理上将代码放置在代码之上。在这个范例中，当我们执行代码时，代码实际上是从程序顶部逐级下降到程序底部的。
- en: Getting ready
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will create a GUI using `tkinter`, which is similar to the
    GUI we created in the first chapter of this book.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 `tkinter` 创建一个 GUI，这与本书第一章中创建的 GUI 类似。
- en: How to do it…
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s see how to perform this recipe:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何执行这个菜谱：
- en: We will first create a GUI using `tkinter` in a procedural fashion and then
    we will add a class to it to display tooltips over GUI widgets.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先以过程式的方式使用 `tkinter` 创建一个 GUI，然后我们将向其中添加一个类来显示 GUI 小部件的提示信息。
- en: 'Next, we will create a new module: `GUI_FallDown.py`.'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个新的模块：`GUI_FallDown.py`。
- en: 'Add the following code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, add some widgets:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一些小部件：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add more widgets in a loop:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环中添加更多小部件：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Run the code and click one of the buttons:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并点击其中一个按钮：
- en: '![](img/c4fc7273-ebc5-4a85-be6f-2fc231001ab8.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c4fc7273-ebc5-4a85-be6f-2fc231001ab8.png)'
- en: 'Create a new module: `GUI_FallDown_Tooltip.py`.'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的模块：`GUI_FallDown_Tooltip.py`。
- en: 'Use the code from `GUI_FallDown.py` and then add the following code to it at
    the top:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `GUI_FallDown.py` 中的代码，然后在顶部添加以下代码：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run the code and hover the mouse over several widgets:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并将鼠标悬停在几个小部件上：
- en: '![](img/339bb25c-a797-443a-ae30-d1126593381e.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/339bb25c-a797-443a-ae30-d1126593381e.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解代码以更好地理解它。
- en: How it works…
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we create a Python GUI in `GUI_FallDown.py` using `tkinter` and code
    it in the waterfall style.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在 `GUI_FallDown.py` 中使用 `tkinter` 创建一个 Python GUI，并以瀑布式编写代码。
- en: We can improve our Python GUI by adding tooltips. The best way to do this is
    to isolate the code that creates the tooltip functionality from our GUI.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加提示信息来改进我们的 Python GUI。最好的方法是隔离创建提示功能代码与我们的 GUI。
- en: We do this by creating a separate class, which has the tooltip functionality,
    and then we create an instance of this class in the same Python module that creates
    our GUI.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个具有提示功能的不同类来实现这一点，然后在创建 GUI 的同一个 Python 模块中创建这个类的实例。
- en: Using Python, there is no need to place our `ToolTip` class into a separate
    module. We can place it just above the procedural code and then call it from below
    the class code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python，我们不需要将我们的 `ToolTip` 类放入一个单独的模块中。我们可以在过程式代码的上方放置它，然后从类代码下方调用它。
- en: In `GUI_FallDown_Tooltip.py`, the code is almost identical to `GUI_FallDown.py`,
    but now we have tooltips.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GUI_FallDown_Tooltip.py` 中，代码几乎与 `GUI_FallDown.py` 相同，但现在我们有了提示信息。
- en: We can very easily mix and match both procedural and OOP programming in the
    same Python module.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以非常容易地在同一个 Python 模块中混合使用过程式和面向对象编程。
- en: Using a code naming convention
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代码命名约定
- en: 'This recipe will show you the value of adhering to a code naming scheme: it
    helps us to find the code we want to extend, and reminds us of the design of our
    program.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将展示遵循代码命名方案的价值：它帮助我们找到想要扩展的代码，并提醒我们程序的设计。
- en: Getting ready
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will look at Python module names and look at good naming
    conventions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将查看 Python 模块名称，并探讨良好的命名约定。
- en: How to do it…
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will create example projects with different Python module names to compare
    the naming:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建具有不同 Python 模块名称的示例项目以比较命名：
- en: Create a new `ModuleNames` folder under `Folder1`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Folder1` 下创建一个新的 `ModuleNames` 文件夹。
- en: 'Add the following Python modules, 1, 11, 2, and 3:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下 Python 模块：1、11、2 和 3：
- en: '![](img/3b68c8c4-0684-4a69-a664-d5711a57b52e.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b68c8c4-0684-4a69-a664-d5711a57b52e.png)'
- en: Next, create a new `ModuleNames_` folder under `Folder1`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `Folder1` 下创建一个新的 `ModuleNames_` 文件夹。
- en: 'Add the following Python modules, 1, 11, 2, and 3:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下 Python 模块：1、11、2 和 3：
- en: '![](img/f290f8fe-1d3e-4f2d-b62b-e7894af0e317.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f290f8fe-1d3e-4f2d-b62b-e7894af0e317.png)'
- en: Next, create a new `ModuleNames_Desc` folder under `Folder1`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `Folder1` 下创建一个新的 `ModuleNames_Desc` 文件夹。
- en: 'Add the following Python modules, `Logger`, `UnitTests`, `GUI`, and `debug`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下 Python 模块：`Logger`、`UnitTests`、`GUI` 和 `debug`：
- en: '![](img/d2fa59ec-51d6-420f-a516-a791d5aee4d9.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2fa59ec-51d6-420f-a516-a791d5aee4d9.png)'
- en: 'Look at this naming convention as an example:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此命名约定作为一个例子：
- en: '![](img/5bdd6b95-5c07-4729-a2a0-85db9d4f437b.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5bdd6b95-5c07-4729-a2a0-85db9d4f437b.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解代码以更好地理解它。
- en: How it works…
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 1*, we create a package subfolder named `ModuleNames`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中，我们创建一个名为 `ModuleNames` 的包子文件夹。
- en: In *step 2*, we add Python modules to it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 2* 中，我们将 Python 模块添加到其中。
- en: 'In *step 3*, we create another package folder and add a trailing underscore
    to the name: `ModuleNames_`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 3* 中，我们创建另一个包文件夹，并在名称后添加一个尾随下划线：`ModuleNames_`。
- en: In *step 4*, we add new Python modules that have the same names as the ones
    in *step 2*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们添加了与*步骤2*中相同的名称的新Python模块。
- en: In *step 5*, we create another package folder with a much more descriptive name,
    `ModuleNames_Desc`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们创建了一个具有更多描述性名称的另一个包文件夹，名为`ModuleNames_Desc`。
- en: In *step 6*, we add Python modules but this time with much more descriptive
    names that explain the purpose of each Python module.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6*中，我们添加了Python模块，但这次使用了更具描述性的名称，这些名称解释了每个Python模块的目的。
- en: Lastly, in *step 7*, we show a full example of how this can look.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*步骤7*中，我们展示了如何完整地展示这一点。
- en: There's more...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Often, a typical way to start coding is by incrementing numbers, as can be seen
    in `ModuleNames`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，开始编码的一种典型方式是通过递增数字，正如在`ModuleNames`中可以看到的那样。
- en: Later, coming back to this code, we don't have much of an idea which Python
    module provides which functionality and, sometimes, our last incremented modules
    are not as good as the earlier versions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，当我们回到这段代码时，我们并不清楚哪个Python模块提供了哪种功能，有时，我们最后递增的模块并不如早期版本好。
- en: A clear naming convention does help.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰的命名约定确实有帮助。
- en: A slight improvement is adding underscores, which makes module names more readable,
    as in `ModuleNames_`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微改进一下，添加下划线可以使模块名称更易读，例如`ModuleNames_`。
- en: A better way is to add some description of what the module does, as seen in
    `ModuleNames_Desc`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是添加一些关于模块做什么的描述，就像在`ModuleNames_Desc`中看到的那样。
- en: While not perfect, the names chosen for the different Python modules indicate
    what each module's responsibility is. When we want to add more unit tests, it
    is clear in which module they reside.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不完美，但为不同的Python模块选择的名称表明了每个模块的责任。当我们想要添加更多单元测试时，它们位于哪个模块中是清晰的。
- en: In the last example, we are using the placeholder, `PRODUCT`, for a real name.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个例子中，我们使用占位符`PRODUCT`来表示一个真实名称。
- en: Replace the word `PRODUCT` with the product you are currently working on.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 将单词`PRODUCT`替换为你目前正在工作的产品名称。
- en: The entire application is a GUI. All parts are connected. The `DEBUG.py` module
    is only used for debugging code. The main module to invoke the GUI has its name
    reversed when compared with all of the other modules. It starts with `Gui` and
    has a `.pyw` extension.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 整个应用程序是一个GUI。所有部分都是连接的。`DEBUG.py`模块仅用于调试代码。与所有其他模块相比，调用GUI的主要模块的名称是反转的。它以`Gui`开头，并具有`.pyw`扩展名。
- en: It is the only Python module that has this extension name.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是唯一具有这种扩展名的Python模块。
- en: From this naming convention, if you are familiar enough with Python, it will
    be obvious that, to run this GUI, you can double-click the `Gui_PRODUCT.pyw` module.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从这种命名约定来看，如果你对Python足够熟悉，那么很明显，要运行这个GUI，你可以双击`Gui_PRODUCT.pyw`模块。
- en: All other Python modules contain functionality for the GUI and also execute
    the underlying business logic to fulfill the purpose this GUI addresses.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他Python模块都包含用于GUI的功能，并且执行底层业务逻辑以满足GUI所解决的问题。
- en: Naming conventions for Python code modules are a great help in keeping us efficient
    and helping us to remember our original design. When we need to debug and fix
    a defect or add new functionality, they are the first resources to look at.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Python代码模块的命名约定对我们保持高效和帮助我们记住原始设计非常有帮助。当我们需要调试和修复缺陷或添加新功能时，它们是我们首先查看的资源。
- en: Incrementing module names by numbers is not very meaningful and eventually wastes
    development time.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过数字递增模块名称并不很有意义，并且最终会浪费开发时间。
- en: On the other hand, naming Python variables is more of a free form. Python infers
    types, so we do not have to specify that a variable will be of the `list` type
    (it might not be, or later in the code, it might become a different type).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Python变量的命名更自由。Python推断类型，因此我们不必指定变量将是`list`类型（它可能不是，或者稍后代码中，它可能成为不同的类型）。
- en: A good idea for naming variables is to make them descriptive, and it is a good
    idea not to abbreviate too much.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 变量命名的良好建议是使它们具有描述性，并且最好不要过度缩写。
- en: If we wish to point out that a certain variable is designed to be of the `list`
    type, then it is much more intuitive to use the full word `list_of_things` instead
    of `lst_of_things`. Similarly, use for `number` instead of `num`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要指出某个变量被设计为`list`类型，那么使用完整的单词`list_of_things`而不是`lst_of_things`会更加直观。同样，使用`number`而不是`num`。
- en: 'While it is a good idea to have very descriptive names for variables, sometimes
    that can get too long. In Apple''s Objective-C language, some variable and function
    names are extreme: `thisIsAMethodThatDoesThisAndThatAndAlsoThatIfYouPassInNIntegers:1:2:3`.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然给变量起非常描述性的名字是个好主意，但有时名字可能会太长。在苹果的Objective-C语言中，一些变量和函数名非常极端：`thisIsAMethodThatDoesThisAndThatAndAlsoThatIfYouPassInNIntegers:1:2:3`。
- en: Use common sense when naming variables, methods, and functions.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名变量、方法和函数时使用常识。
- en: Now, let's move on to the next recipe.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个示例。
- en: When not to use OOP
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时不使用OOP
- en: Python comes built in with OOP capabilities, but at the same time, we can write
    scripts that do not need to use OOP. For some tasks, OOP does not make sense.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Python自带了面向对象编程（OOP）的能力，但与此同时，我们也可以编写不需要使用OOP的脚本。对于某些任务，使用OOP并不合适。
- en: This recipe will show us when not to use OOP.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将向我们展示何时不使用OOP。
- en: Getting ready
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will create a Python GUI similar to the previous recipes.
    We will compare the OOP code to the non-OOP alternative way of programming the
    GUI. The resultant output will be the same but the code of the two versions is
    slightly different.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个类似于之前示例的Python GUI。我们将比较OOP代码和非OOP编程GUI的替代方法。结果输出将相同，但两个版本的代码略有不同。
- en: How to do it…
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let''s see how to perform this recipe:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何执行这个示例：
- en: Let's first create a new GUI using the OOP methodology. The code shown in the
    following steps will create the GUI displayed.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们使用面向对象的方法创建一个新的GUI。以下步骤中显示的代码将创建显示的GUI。
- en: 'Create a new module: `GUI_OOP.py`.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的模块：`GUI_OOP.py`。
- en: 'Add the following code:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a class:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类：
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add a method to create widgets:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个创建小部件的方法：
- en: '[PRE32]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a menu bar:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个菜单栏：
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the code and observe the following output:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并观察以下输出：
- en: '![](img/65445ad7-62bc-4f4a-92f0-ad1977fe5656.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/65445ad7-62bc-4f4a-92f0-ad1977fe5656.png)'
- en: 'Let''s have a look at a new scenario:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个新的场景：
- en: 'Create a new module, `GUI_NOT_OOP.py`, and add the following code:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的模块，`GUI_NOT_OOP.py`，并添加以下代码：
- en: '[PRE34]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create more widgets:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建更多小部件：
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a menu bar:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个菜单栏：
- en: '[PRE36]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, create the entire GUI, calling the function that creates the widgets:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建整个GUI，调用创建小部件的函数：
- en: '[PRE37]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Run the code. The resultant GUI will be identical to the one from `GUI_OOP.py`
    shown previously.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。生成的GUI将与之前显示的`GUI_OOP.py`中的GUI相同。
- en: How it works…
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: First, we create a Python `tkinter` GUI in OOP style, `GUI_OOP.py`. Then, we
    create the same GUI in a procedural style, `GUI_NOT_OOP.py`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们以OOP风格创建一个Python `tkinter` GUI，`GUI_OOP.py`。然后，我们以过程式风格创建相同的GUI，`GUI_NOT_OOP.py`。
- en: We can achieve the same GUI without using an OOP approach by restructuring our
    code slightly. First, we remove the `OOP` class and its `__init__` method. Next,
    we move all of the methods to the left and remove the `self` class reference,
    which turns them into unbound functions. We also remove any other `self` references
    our previous code had. Then, we move the `createWidgets` function call below the
    point of the function's declaration. We place it just above the `mainloop` call.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过稍微重构我们的代码来实现不使用OOP方法达到相同的GUI。首先，我们移除`OOP`类及其`__init__`方法。接下来，我们将所有方法移动到左边，并移除`self`类引用，使它们变成未绑定函数。我们还移除了之前代码中所有的`self`引用。然后，我们将`createWidgets`函数调用移动到函数声明点下方。我们将其放置在`mainloop`调用之上。
- en: In the end, we achieve the same GUI but without using OOP.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们达到了相同的GUI，但没有使用OOP。
- en: Python enables us to use OOP when it makes sense. Other languages such as Java
    and C# force us to always use the OOP approach to coding. In this recipe, we explored
    a situation when it did not make sense to use OOP.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Python使我们能够在合适的时候使用OOP。其他语言，如Java和C#，强制我们始终使用OOP方法进行编码。在这个示例中，我们探讨了不使用OOP的情况。
- en: The OOP approach will be more extendable if the code base grows, but if it's
    certain that it is the only code that's needed, then there's no need to go through
    OOP.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码库增长，OOP方法将更具可扩展性，但如果确定只需要这段代码，那么就没有必要通过OOP。
- en: Now, let's move on to the next recipe.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个示例。
- en: How to use design patterns successfully
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何成功使用设计模式
- en: In this recipe, we will create widgets for our Python GUI by using the *factory
    design pattern*. In the previous recipes, we created our widgets either manually
    one at a time or dynamically in a loop. Using the factory design pattern, we will
    use the *factory* to create our widgets.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将通过使用*工厂设计模式*来创建我们的Python GUI的小部件。在之前的配方中，我们手动逐个创建小部件或动态地在循环中创建。使用工厂设计模式，我们将使用*工厂*来创建我们的小部件。
- en: Getting ready
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will create a Python GUI that has three buttons, each having a different
    style.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个具有三个按钮的Python GUI，每个按钮都有不同的样式。
- en: How to do it…
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will create a Python GUI with different button styles and we will use a
    factory design pattern to create these different styles:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个具有不同按钮样式的Python GUI，我们将使用工厂设计模式来创建这些不同的样式：
- en: 'Create a new module: `GUI_DesignPattern.py`.'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的模块：`GUI_DesignPattern.py`。
- en: 'Add the following code:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE38]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create the factory class:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建工厂类：
- en: '[PRE39]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create a base class:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基类：
- en: '[PRE40]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create classes that inherit from the base class:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建从基类继承的类：
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a list that contains the previous classes:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含之前类的列表：
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a new class that uses the previous code:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的类，它使用之前的代码：
- en: '[PRE43]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Run the code and observe the output:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并观察输出：
- en: '![](img/f933506b-a17d-415a-b9e4-ec254f1ecaa9.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f933506b-a17d-415a-b9e4-ec254f1ecaa9.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解代码以更好地理解它。
- en: How it works…
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We create a base class that our different button style classes inherit from
    and in which each of them overrides the `relief` and `foreground` configuration
    attributes. All subclasses inherit the `getButtonConfig` method from this base
    class. This method returns a tuple.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个基类，我们的不同按钮样式类都从它继承，并且每个类都覆盖了`relief`和`foreground`配置属性。所有子类都从该基类继承`getButtonConfig`方法。此方法返回一个元组。
- en: We also create a button factory class and a list that holds the names of our
    button subclasses. We name the list `buttonTypes`, as our factory will create
    different types of buttons.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个按钮工厂类和一个包含我们的按钮子类名称的列表。我们把这个列表命名为`buttonTypes`，因为我们的工厂将创建不同类型的按钮。
- en: Further down in the module, we create the button widgets, using the same `buttonTypes`
    list. We create an instance of the button factory and then we use our factory
    to create our buttons.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块的更下方，我们使用相同的`buttonTypes`列表创建了按钮小部件。我们创建了一个按钮工厂的实例，然后我们使用我们的工厂来创建我们的按钮。
- en: The items in the `buttonTypes` list are the names of our subclasses.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`buttonTypes`列表中的项是我们子类的名称。'
- en: We invoke the `createButton` method and then immediately call the `getButtonConfig`
    method of the base class and retrieve the configuration attributes using dot notation.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`createButton`方法，然后立即调用基类的`getButtonConfig`方法，并使用点符号获取配置属性。
- en: We can see that our Python GUI factory did indeed create different buttons,
    each having a different style. They differ in the color of their text and their
    `relief` property.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们的Python GUI工厂确实创建了不同的按钮，每个按钮都有不同的样式。它们在文本颜色和`relief`属性上有所不同。
- en: Design patterns are a very exciting tool in our software development toolbox.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是我们软件开发工具箱中一个非常激动人心的工具。
- en: Avoiding complexity
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免复杂性
- en: In this recipe, we will extend our Python GUI and learn ways to handle the increasing
    complexity of our software development efforts.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将扩展我们的Python GUI，并学习处理软件开发努力不断增加的复杂性。
- en: Our co-workers and clients love the GUIs we create in Python and ask for more
    and more features to add to our GUI.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的同事和客户都喜欢我们在Python中创建的GUI，并要求添加更多功能到我们的GUI中。
- en: This increases complexity and can easily ruin our original nice design.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这增加了复杂性，并可能轻易破坏我们的原始良好设计。
- en: Getting ready
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will create a new Python GUI similar to those in the previous recipes and
    will add many features to it in the form of widgets.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的Python GUI，类似于之前的配方，并将添加许多以小部件形式的功能。
- en: How to do it…
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s see how to perform the recipe:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何执行配方：
- en: We will start with a Python GUI that has two tabs and then we will add more
    widgets to it.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从一个具有两个标签页的Python GUI开始，然后我们将添加更多的小部件到它。
- en: 'Create a new module: `GUI_Complexity_start.py`.'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的模块：`GUI_Complexity_start.py`。
- en: 'Add the following code:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE44]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create a global variable and a class:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个全局变量和一个类：
- en: '[PRE45]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add a method that creates the widgets:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个创建小部件的方法：
- en: '[PRE46]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Run the code and click both tabs:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并点击两个标签页：
- en: '![](img/35bf9481-3a0a-4b34-b4de-d85845b18b44.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/35bf9481-3a0a-4b34-b4de-d85845b18b44.png)'
- en: Open `GUI_Complexity_start.py` and save it as `GUI_Complexity_start_add_button.py`.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_Complexity_start.py` 并将其保存为 `GUI_Complexity_start_add_button.py`。
- en: 'Add the following code to the `createWidgets` method:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `createWidgets` 方法中：
- en: '[PRE47]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Add the following code just below `__init__(self)`:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `__init__(self)` 下方添加以下代码：
- en: '[PRE48]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Run the code and observe the following output:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并观察以下输出：
- en: '![](img/6d00c1a7-0e8d-4dc8-b2c3-e4677f664cd9.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6d00c1a7-0e8d-4dc8-b2c3-e4677f664cd9.png)'
- en: Open `GUI_Complexity_start_add_button.py` and save it as `GUI_Complexity_start_add_three_more_buttons.py`.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_Complexity_start_add_button.py` 并将其保存为 `GUI_Complexity_start_add_three_more_buttons.py`。
- en: 'Add the following code to the `createWidgets` method:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `createWidgets` 方法中：
- en: '[PRE49]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Run the code and observe the output:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并观察输出：
- en: '![](img/20b1d196-a134-4d41-8602-0bc25a950521.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/20b1d196-a134-4d41-8602-0bc25a950521.png)'
- en: Open `GUI_Complexity_start_add_three_more_buttons.py` and save it as `GUI_Complexity_start_add_three_more_buttons_add_more.py`.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_Complexity_start_add_three_more_buttons.py` 并将其保存为 `GUI_Complexity_start_add_three_more_buttons_add_more.py`。
- en: 'Add the following code to the `createWidgets` method:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `createWidgets` 方法中：
- en: '[PRE50]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Run the code and observe the following output:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并观察以下输出：
- en: '![](img/3848bfc4-d4ab-4450-9624-ac8b40e7db8c.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3848bfc4-d4ab-4450-9624-ac8b40e7db8c.png)'
- en: Open `GUI_Complexity_start_add_three_more_buttons_add_more.py` and save it as
    `GUI_Complexity_end_tab3.py`.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_Complexity_start_add_three_more_buttons_add_more.py` 并将其保存为 `GUI_Complexity_end_tab3.py`。
- en: 'Add the following code to the `createWidgets` method:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `createWidgets` 方法中：
- en: '[PRE51]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Run the code and click on Tab 3:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并点击标签3：
- en: '![](img/322f3e01-e7cc-43fe-8ba3-28b64fb2479e.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/322f3e01-e7cc-43fe-8ba3-28b64fb2479e.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解代码，以便更好地理解。
- en: How it works…
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We start with a GUI built with `tkinter`, `GUI_Complexity_start.py`, and it
    has some widgets on two tabs. We have created similar GUIs throughout this entire
    book.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个使用 `tkinter`、`GUI_Complexity_start.py` 构建的GUI开始，它有两个标签页上的控件。我们在这整本书中创建了许多类似的GUI。
- en: The first new feature request we receive is to add functionality to Tab 1, which
    clears the `scrolledtext` widget.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到的第一个新功能请求是在标签1中添加清除 `scrolledtext` 小部件的功能。
- en: Easy enough. We just add another button to Tab 1.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 足够简单。我们只需在标签1中添加另一个按钮。
- en: We also have to create the callback method in `GUI_Complexity_start_add_button.py`
    to add the desired functionality, which we define toward the top of our class
    and outside the method that creates our widgets. Now, our GUI has a new button
    and, when we click it, we clear the text of the `ScrolledText` widget. To add
    this functionality, we had to add code in two places in the same Python module.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须在 `GUI_Complexity_start_add_button.py` 中创建回调方法以添加所需的功能，我们定义这个功能在类的顶部和创建小部件的方法之外。现在，我们的GUI有一个新的按钮，当我们点击它时，它会清除
    `ScrolledText` 小部件中的文本。为了添加此功能，我们不得不在同一个Python模块中的两个地方添加代码。
- en: We inserted the new button in the `createWidgets` method and then we created
    a new callback method, which our new button calls when it is clicked. We placed
    this code just below the callback of our first button.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `createWidgets` 方法中插入了新的按钮，然后创建了一个新的回调方法，当我们的新按钮被点击时，它会调用这个方法。我们将此代码放置在第一个按钮的回调代码下方。
- en: Our next feature request is to add more functionality. The business logic is
    encapsulated in another Python module. We invoke this new functionality by adding
    three more buttons to Tab 1 in `GUI_Complexity_start_add_three_more_buttons.py`.
    We use a loop to do this.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个功能请求是添加更多功能。业务逻辑封装在另一个Python模块中。我们在 `GUI_Complexity_start_add_three_more_buttons.py`
    中的标签1中添加了三个更多按钮来调用这个新功能。我们使用循环来完成这个操作。
- en: Next, our customers ask for more features and we use the same approach in `GUI_Complexity_start_add_three_more_buttons_add_more.py.`
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的客户要求更多功能，我们在 `GUI_Complexity_start_add_three_more_buttons_add_more.py`
    中使用了相同的方法。
- en: This is not too bad. When we get new feature requests for another 50 new features,
    we start to wonder whether our approach is still the best one to use.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不太糟糕。当我们收到新的50个新功能请求时，我们开始怀疑我们的方法是否仍然是最佳选择。
- en: One way to manage the increasing complexity our GUI handles is by adding tabs.
    By adding more tabs and placing related features into their own tab, we get control
    of the complexity and make our GUI more intuitive. We do this in `GUI_Complexity_end_tab3.py`,
    which creates our new Tab 3.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 管理我们GUI处理的日益增加的复杂性的方法之一是添加标签页。通过添加更多标签页并将相关功能放入它们自己的标签页中，我们控制了复杂性，并使我们的GUI更加直观。我们在
    `GUI_Complexity_end_tab3.py` 中这样做，它创建了我们的新标签3。
- en: We saw how to handle complexity by modularizing our GUI by breaking large features
    into smaller pieces and arranging them in functionally related areas using tabs.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到如何通过将GUI模块化，将大特性分解成小块，并使用标签在功能相关区域中排列，来处理复杂性。
- en: While complexity has many aspects, modularizing and refactoring the code is
    usually a very good approach to handling software code complexity.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然复杂性有许多方面，但模块化和重构代码通常是处理软件代码复杂性的非常有效的方法。
- en: GUI design using multiple notebooks
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多个笔记本进行GUI设计
- en: In this recipe, we will create our GUI using multiple notebooks. Surprisingly,
    `tkinter` does not ship out of the box with this functionality, but we can design
    such a widget ourselves.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用多个笔记本创建我们的GUI。令人惊讶的是，`tkinter`没有自带这种功能，但我们可以自己设计这样的小部件。
- en: Using multiple notebooks will further reduce the complexity discussed in the
    previous recipe.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个笔记本将进一步减少前一个食谱中讨论的复杂性。
- en: Getting ready
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: We will create a new Python GUI similar to the one in the previous recipe. This
    time, however, we will design our GUI with two notebooks. To focus on this feature,
    we will use functions instead of class methods. Reading the previous recipe will
    be a good introduction to this recipe.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的Python GUI，类似于前一个食谱中的GUI。然而，这次我们将使用两个笔记本来设计我们的GUI。为了专注于这个特性，我们将使用函数而不是类方法。阅读前一个食谱将是对这个食谱的良好介绍。
- en: How to do it…
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s see how to perform this recipe:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何执行这个食谱：
- en: To use multiple notebooks within the same GUI, we start by creating two frames.
    The first frame will hold the notebooks and their tabs while the second frame
    will serve as the display area for the widgets each tab is designed to display.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在同一个GUI中使用多个笔记本，我们首先创建两个框架。第一个框架将包含笔记本及其标签页，而第二个框架将作为每个标签页设计的控件显示区域。
- en: 'Create a new module: `GUI_Complexity_end_tab3_multiple_notebooks.py`.'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的模块：`GUI_Complexity_end_tab3_multiple_notebooks.py`。
- en: 'Add the following code:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE52]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create callback functions:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建回调函数：
- en: '[PRE53]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create a menu bar:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建菜单栏：
- en: '[PRE54]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create Tab Display Area 1:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建标签显示区域1：
- en: '[PRE55]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Create Tab Display Area 2:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建标签显示区域2：
- en: '[PRE56]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create Tab Display Area 3:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建标签显示区域3：
- en: '[PRE57]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Write the code to display a button for all other tabs:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码以显示所有其他标签的按钮：
- en: '[PRE58]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create the notebook callback:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建笔记本回调函数：
- en: '[PRE59]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create the GUI with the multiple notebooks:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用多个笔记本创建GUI：
- en: '[PRE60]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Run the code, click on Tab 1, and observe the following output:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，点击第1个标签页，并观察以下输出：
- en: '![](img/7d71405b-d650-46dc-a728-bdf6b98936e0.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7d71405b-d650-46dc-a728-bdf6b98936e0.png)'
- en: 'Click on Tab 2\. You will see the following output:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击第2个标签页。您将看到以下输出：
- en: '![](img/7af19d25-73a5-451e-8727-1e7b8dbb504a.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7af19d25-73a5-451e-8727-1e7b8dbb504a.png)'
- en: 'Click on Tab 3\. You will see the following output:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击第3个标签页。您将看到以下输出：
- en: '![](img/021a189c-81f9-4215-9540-3478441f4576.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/021a189c-81f9-4215-9540-3478441f4576.png)'
- en: 'Click on Tab 4 in the second row and observe the following output:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二行的第4个标签页上点击，并观察以下输出：
- en: '![](img/9aac87a8-00a5-424b-ae01-c32df2320085.png)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9aac87a8-00a5-424b-ae01-c32df2320085.png)'
- en: 'Click on Tab 5 in the first row and then click the button in Tab Display Area
    to see the following output:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一行的第5个标签页上点击，然后点击标签显示区域中的按钮，您将看到以下输出：
- en: '![](img/e8617474-ee5a-4b9f-bf40-8745996f6ffe.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e8617474-ee5a-4b9f-bf40-8745996f6ffe.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们幕后了解代码，以便更好地理解。
- en: How it works…
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In `GUI_Complexity_end_tab3_multiple_notebooks.py`, we use the grid layout
    manager to arrange the two frames we are creating, placing one above the other.
    Then, we create two notebooks and arrange them within the first frame:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GUI_Complexity_end_tab3_multiple_notebooks.py`中，我们使用网格布局管理器来安排我们创建的两个框架，将一个放置在另一个之上。然后，我们创建两个笔记本并将它们安排在第一个框架内：
- en: '![](img/258b406b-e5ab-41e9-8fa0-b30c36aecafb.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/258b406b-e5ab-41e9-8fa0-b30c36aecafb.png)'
- en: 'Next, we use a loop to create five tabs and add them to each notebook:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用循环创建五个标签页并将它们添加到每个笔记本中：
- en: '![](img/b457857b-d8a7-4b9a-99f0-da56d27a4a87.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b457857b-d8a7-4b9a-99f0-da56d27a4a87.png)'
- en: 'We create a callback function and bind the click event of the two notebooks
    to this callback function. Now, when the user clicks on any tab belonging to the
    two notebooks, this callback function will be called:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个回调函数并将两个笔记本的点击事件绑定到这个回调函数。现在，当用户点击属于这两个笔记本的任何标签时，这个回调函数将被调用：
- en: '![](img/84f8dce3-79b9-4519-94b2-ec11126d6bbb.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/84f8dce3-79b9-4519-94b2-ec11126d6bbb.png)'
- en: 'In the callback function, we add logic that decides which widgets get displayed
    after clicking a tab:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调函数中，我们添加逻辑来决定点击标签后显示哪些控件：
- en: '![](img/7f8b9d09-ad12-4845-81ab-aba6fea756e8.png)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7f8b9d09-ad12-4845-81ab-aba6fea756e8.png)'
- en: 'We add a function that creates a display area and another function that clears
    the area:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个创建显示区域的函数和另一个清除区域的函数：
- en: '![](img/350ad1f9-8c9a-4f2f-a35f-d6aec81700f1.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/350ad1f9-8c9a-4f2f-a35f-d6aec81700f1.png)'
- en: Note how the `notebook_callback()` function calls the `clear_display_area()`
    function.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`notebook_callback()`函数是如何调用`clear_display_area()`函数的。
- en: The `clear_display_area()` function knows both the row and column in which the
    widgets of tabs are being created, and, by finding row 0, we can then use `grid_forget()`
    to clear the display.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`clear_display_area()`函数知道小部件在标签中创建的行和列，通过找到行0，我们可以使用`grid_forget()`来清除显示。'
- en: For tabs 1 to 3 of the first notebook, we create new frames to hold more widgets.
    Clicking any of those three tabs then results in a GUI very similar to the one
    we created in the previous recipe.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个笔记本的1到3标签，我们创建新的框架来容纳更多的小部件。点击这三个标签中的任何一个，然后结果会是一个与我们在上一个菜谱中创建的GUI非常相似的GUI。
- en: These first three tabs are being invoked in the callback function as `display_tab1()`,
    `display_tab2()`, and `display_tab3()` when those tabs are being clicked.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这前三个标签在回调函数中被调用为`display_tab1()`、`display_tab2()`和`display_tab3()`，当点击这些标签时。
- en: 'Here is the code that runs when clicking on Tab 3 of the first notebook:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是点击第一个笔记本的标签3时运行的代码：
- en: '![](img/1ec681ba-6982-4420-be4f-5e23ef044bc7.png)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1ec681ba-6982-4420-be4f-5e23ef044bc7.png)'
- en: 'Clicking any tab other than the first three tabs of the first notebook one
    calls the same function, `display_button()`, which results in a button being displayed
    whose text property is being set to show the notebook and tab number:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 点击第一个笔记本的前三个标签之外的任何标签都会调用相同的函数，即`display_button()`，这会导致显示一个按钮，其文本属性被设置为显示笔记本和标签编号：
- en: '![](img/af83e6d9-2b75-4d2a-9f84-28cb2333a558.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/af83e6d9-2b75-4d2a-9f84-28cb2333a558.png)'
- en: Clicking any of these buttons results in a message box.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 点击这些按钮中的任何一个都会弹出一个消息框。
- en: 'At the end of the code, we invoke the `display_tab1()` function. When the GUI
    first starts up, the widgets of this tab are what get displayed in the display
    area:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的末尾，我们调用了`display_tab1()`函数。当GUI首次启动时，这个标签的小部件会显示在显示区域中：
- en: '![](img/e267007f-100b-4028-a483-cf12c566ab37.png)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e267007f-100b-4028-a483-cf12c566ab37.png)'
- en: 'Running the `GUI_Complexity_end_tab3_multiple_notebooks.py` code of this recipe
    creates the following GUI:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个菜谱的`GUI_Complexity_end_tab3_multiple_notebooks.py`代码会创建以下GUI：
- en: '![](img/c8e45837-4b5e-4cac-a8b2-27bd60a281db.png)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c8e45837-4b5e-4cac-a8b2-27bd60a281db.png)'
- en: 'Clicking on Tab 2 of the first notebook clears the tab display area and then
    displays the widgets created in the `display_tab2()` function:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 点击第一个笔记本的标签2会清除标签显示区域，然后显示`display_tab2()`函数创建的小部件：
- en: '![](img/6e63dc49-32b4-4bb7-bbcb-0fb1b8fc4aaa.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6e63dc49-32b4-4bb7-bbcb-0fb1b8fc4aaa.png)'
- en: Note how the tab display area automatically adjusts to the sizes of the widgets
    being created.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 注意标签显示区域是如何自动调整到创建的小部件的大小。
- en: 'Clicking Tab 3 results in the following GUI display:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 点击标签3会导致以下GUI显示：
- en: '![](img/c3c252af-465a-4b5b-b6c8-1fe713e59b45.png)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c3c252af-465a-4b5b-b6c8-1fe713e59b45.png)'
- en: 'Clicking any other tab in either the first or the second notebook results in
    a button being displayed in the tab display area:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 点击第一个或第二个笔记本中的任何其他标签都会在标签显示区域中显示一个按钮：
- en: '![](img/aa4bd375-b3e6-4eab-8887-9d40708136e2.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aa4bd375-b3e6-4eab-8887-9d40708136e2.png)'
- en: 'Clicking any of those buttons results in a message box:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 点击这些按钮中的任何一个都会弹出一个消息框：
- en: '![](img/2584263f-6438-46f4-a55c-f9b6f6e18708.png)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2584263f-6438-46f4-a55c-f9b6f6e18708.png)'
- en: There is no limit to creating notebooks. We can create as many notebooks as
    our design requires.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 创建笔记本没有限制。我们可以创建我们设计所需的任意数量的笔记本。
