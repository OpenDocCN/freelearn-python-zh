<html><head></head><body><div><div><h1 id="_idParaDest-223"><em class="italic"><a id="_idTextAnchor227"/></em><a href="B16119_08_Final_PD_ePub.xhtml#_idTextAnchor227"><em class="italic">Chapter 8</em></a>: Business Logic – Supporting Business Processes</h1>
			<p>In the previous chapters, we learned how to use models to build the application data structures, and then how to explore and interact with that data using the ORM API and recordsets.</p>
			<p>In this chapter, we will put all this together to implement business logic patterns that are common in applications. We will learn about the several ways business logic can be triggered, as well as some common patterns that are used to support them. We will also learn about important development techniques, such as logging, debugging, and testing.</p>
			<p>We'll cover the following topics in this chapter:</p>
			<ul>
				<li>Learning project – the book checkout module</li>
				<li>Ways to trigger business logic</li>
				<li>Understanding ORM method decorators for recordsets</li>
				<li>Exploring useful data model patterns</li>
				<li>Using the ORM built-in methods</li>
				<li>Adding onchange user interface logic</li>
				<li>The message and activity features</li>
				<li>Creating a wizard</li>
				<li>Raising exceptions</li>
				<li>Writing unit tests</li>
				<li>Using log messages</li>
				<li>Learning about the available developer tools</li>
			</ul>
			<p>By the end of this chapter, you should be confident in designing and implementing business logic automation and know how to test and debug your code.</p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor228"/>Technical requirements</h1>
			<p>In this chapter, we will create a new <code>library_checkout</code> add-on module. It depends on the <code>library_app</code> and <code>library_member</code> add-on modules, which we created in the previous chapters.</p>
			<p>The code for these add-on modules can be found in this book's GitHub repository, at <a href="https://github.com/PacktPublishing/Odoo-15-Development-Essentials-Fifth-Edition">https://github.com/PacktPublishing/Odoo-15-Development-Essentials-Fifth-Edition</a>, in the <code>ch08</code> directory.</p>
			<p>Both of these add-on modules need to be available in the Odoo add-ons path so that they can be installed and used.</p>
			<h1 id="_idParaDest-225"><a id="_idTextAnchor229"/>Learning project – the book checkout module</h1>
			<p>The master data<a id="_idIndexMarker589"/> structures for the library application are in place. Now, we want to add transactions to our system. We would like library members to be able to borrow books. This means we should keep track of book availability and returns.</p>
			<p>Each book checkout has a life cycle, from the moment they are created to the moment when the books are returned. It is a simple workflow that can be represented as a Kanban board, where the several stages are presented as columns, and the work items from the left-hand column are sent to the right until they are completed.</p>
			<p>This chapter focuses on the data model and business logic that are needed to support this feature.</p>
			<p>The basic user interface will be discussed in <a href="B16119_10_Final_PD_ePub.xhtml#_idTextAnchor287"><em class="italic">Chapter 10</em></a>, <em class="italic">Backend Views – Designing the User Interface</em>, while the Kanban views will be discussed in <a href="B16119_11_Final_PD_ePub.xhtml#_idTextAnchor324"><em class="italic">Chapter 11</em></a>, <em class="italic">Kanban Views and Client-Side QWeb</em>. Let's quickly have a rundown of the data model.</p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor230"/>Preparing the data model</h2>
			<p>The first thing we must do is plan the <a id="_idIndexMarker590"/>data model that's needed for the book checkout feature.</p>
			<p>The <strong class="bold">book checkout</strong> model should have the following fields:</p>
			<ul>
				<li><strong class="bold">Library member</strong> borrowing books (required)</li>
				<li><strong class="bold">Checkout date</strong> (defaults to today)</li>
				<li><strong class="bold">Responsible person</strong> for the checkout (defaults to the current user)</li>
				<li><strong class="bold">Checkout lines</strong>, with the books requested (one or more)</li>
			</ul>
			<p>To support the book checkout life cycle, we will also have the following:</p>
			<ul>
				<li><strong class="bold">Stage</strong> of the request—draft, open, borrowed, returned, or canceled</li>
				<li><strong class="bold">Due date</strong>, when the books are due to be returned</li>
				<li><strong class="bold">Returned date</strong>, when the books were returned</li>
			</ul>
			<p>We will start by<a id="_idIndexMarker591"/> creating the new <code>library_checkout</code> module and implementing an initial version of the library checkout model. This will not introduce anything new compared to the previous chapters but will provide the foundation to build the features that are relevant for this chapter.</p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor231"/>Creating the module</h2>
			<p>The <code>library_checkout</code> module <a id="_idIndexMarker592"/>needs to be created, similar to what we did in the previous chapters. Follow these steps to do this:</p>
			<ol>
				<li>Create a new <code>library_checkout</code> directory in the same directory as the other add-on modules of the library project. This is where the following files should be added.</li>
				<li>Add the <code>__manifest__.py</code>  file and ensure it has the following content:<pre>{ "name": "Library Book Checkout",
  "description": "Members can borrow books from the 
    library.",
  "author": "Daniel Reis",
  "depends": ["library_member"],
  "data": [
    "security/ir.model.access.csv",
    "views/library_menu.xml",
    "views/checkout_view.xml",
  ],
}</pre></li>
				<li>Add the main <code>__init__.py</code> file with the following line of code:<pre>from . import models</pre></li>
				<li>Add the <code>models/__init__.py</code> file with the following line of code:<pre>from . import library_checkout</pre></li>
				<li>Add the model <a id="_idIndexMarker593"/>definition file, <code>models/library_checkout.py</code>, as follows:<pre>from odoo import fields, models
class Checkout(models.Model):
    _name = "library.checkout"
    _description = "Checkout Request"
    member_id = fields.Many2one(
        "library.member",
        required=True,
    )
    user_id = fields.Many2one(
        "res.users",
        "Librarian",
        default=lambda s: s.env.user,
    )
    request_date = fields.Date(
        default=lambda s: fields.Date.today(),
    )</pre></li>
			</ol>
			<p>Next, we should add the data files, including the access rule, the menu items, and some basic views so that the module can be used.</p>
			<ol>
				<li value="1">Add the access security configuration to the <code>security/ir.model.access.</code><code>csv</code> file:<pre>id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
checkout_user,Checkout User,model_library_checkout,library_app.library_group_user,1,1,1,1</pre></li>
				<li>Next, the <code>views/library_menu.xml</code> file needs to be added for implementing<a id="_idIndexMarker594"/> the menu items:<pre>&lt;odoo&gt;
  &lt;record id="action_library_checkout" 
          model="ir.actions.act_window"&gt;
    &lt;field name="name"&gt;Checkouts&lt;/field&gt;
    &lt;field name="res_model"&gt;library.checkout&lt;/field&gt;
    &lt;field name="view_mode"&gt;tree,form&lt;/field&gt;
  &lt;/record&gt;
  &lt;menuitem id="menu_library_checkout"
            name="Checkout"
            action="action_library_checkout"
            parent="library_app.menu_library"
  /&gt;
&lt;/odoo&gt;</pre></li>
				<li>The views are<a id="_idIndexMarker595"/> implemented in the <code>views/checkout_view.xml</code> file:<pre>&lt;odoo&gt;
  &lt;record id="view_tree_checkout" model="ir.ui.view"&gt;
    &lt;field name="name"&gt;Checkout Tree&lt;/field&gt;
    &lt;field name="model"&gt;library.checkout&lt;/field&gt;
    &lt;field name="arch" type="xml"&gt;
        &lt;tree&gt;
            &lt;field name="request_date" /&gt;
            &lt;field name="member_id" /&gt;
        &lt;/tree&gt;
    &lt;/field&gt;
  &lt;/record&gt;
  &lt;record id="view_form_checkout" model="ir.ui.view"&gt;
    &lt;field name="name"&gt;Checkout Form&lt;/field&gt;
    &lt;field name="model"&gt;library.checkout&lt;/field&gt;
    &lt;field name="arch" type="xml"&gt;
      &lt;form&gt;
        &lt;sheet&gt;
          &lt;group&gt;
            &lt;field name="member_id" /&gt;
            &lt;field name="request_date" /&gt;
            &lt;field name="user_id" /&gt;
          &lt;/group&gt;
        &lt;/sheet&gt;
      &lt;/form&gt;
    &lt;/field&gt;
  &lt;/record&gt;
&lt;/odoo&gt;</pre></li>
			</ol>
			<p>Now that the<a id="_idIndexMarker596"/> module contains the preceding files, it can be installed in our development database:</p>
			<div><div><img src="img/Figure_8.1_B16119.jpg" alt="Figure 8.1 – The initial Library Checkout feature&#13;&#10;" width="1078" height="280"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – The initial Library Checkout feature</p>
			<p>Now, we can start adding more interesting features.</p>
			<p>Throughout this project, we will be adding pieces of business logic to different places to showcase the several possibilities that Odoo provides. The next section will discuss these options.</p>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor232"/>Exploring ways to trigger business logic</h1>
			<p>Once the data model is in place, business logic is needed to perform some automatic actions on it. Business logic can either be directly initiated by the user, with an action such as a button click, or it can be triggered automatically when an event occurs, such as a write on a record.</p>
			<p>Much of this <a id="_idIndexMarker597"/>business logic will involve reading and writing on recordsets. The details and techniques for this were discussed in <a href="B16119_07_Final_PD_ePub.xhtml#_idTextAnchor194"><em class="italic">Chapter 7</em></a>, <em class="italic">Recordsets – Working with Model Data</em>, where we provided the tools for the actual business logic implementation.</p>
			<p>The next question is how the business logic should be triggered. This will depend on when and why the business logic should be triggered. Here is a summary of the several options.</p>
			<p>Some business logic is tightly connected to the model field definitions. Some of the instances of <strong class="bold">model definition-related business logic</strong> are as follows:</p>
			<ul>
				<li><code>@api.constrains</code>.</li>
				<li><code>@api.depends</code> and assigned to the <code>compute</code> field attribute.</li>
				<li><code>@api.model</code> and assigned to the <code>default</code> field attribute.</li>
			</ul>
			<p>This model definition logic was discussed in detail in <a href="B16119_06_Final_PD_ePub.xhtml#_idTextAnchor164"><em class="italic">Chapter 6</em></a>, <em class="italic">Models – Structuring the Application Data</em>. Some examples can be found in the <em class="italic">Data model patterns</em> section. The <em class="italic">ORM method decorators for recordsets</em> section provides a recap of the several ORM decorators mentioned here.</p>
			<p>We also have <strong class="bold">model event-related business logic</strong>, which<a id="_idIndexMarker601"/> is related to business workflows. It can be attached to the following record-related events:</p>
			<ul>
				<li><strong class="bold">Create, write, and unlink</strong> business logic can be added to these events, for the cases where the other, more elegant approaches are not possible.</li>
				<li><strong class="bold">Onchange</strong> logic can be applied to user interface views so that we have some field values that are changed as a consequence of changes being made to other fields.</li>
			</ul>
			<p>For actions that are directly initiated by the user, the following options are available:</p>
			<ul>
				<li>A <code>button</code> view element for calling an object method. The button can be on a form or tree of the Kanban view.</li>
				<li>A <code>server</code> action, which is available from a menu item or in the <code>Action</code> context menu.</li>
				<li>A <code>window</code> action for opening a wizard form, where input can be collected from the user and a button will call the business logic. This allows for richer user interaction.</li>
			</ul>
			<p>These techniques will be presented throughout this chapter. The supporting methods will often use API decorators, so it is important to understand the different available ones. For clarity, the next section provides an overview of them.</p>
			<h1 id="_idParaDest-229"><a id="_idTextAnchor233"/>Understanding ORM method decorators for recordsets</h1>
			<p>The <a id="_idIndexMarker602"/>method definition can be preceded by an <code>@</code>, which applies a decorator to it. These decorators add specific behaviors for these methods and depending on the purpose of a method, different decorators can be used.</p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor234"/>Decorators for computed fields and validation methods</h2>
			<p>A few decorators are<a id="_idIndexMarker603"/> useful for validation logic and computed fields. They <a id="_idIndexMarker604"/>are listed here:</p>
			<ul>
				<li><code>@api.depends(fld1,...)</code> is used for computed field functions to identify what changes the (re)calculation should be triggered on. It must set values on the computed fields; otherwise, an error will be shown.</li>
				<li><code>@api.constrains(fld1,...)</code> is used for model validation functions and performs checks for when any of the mentioned fields are changed. It should not write changes in the data. If the checks fail, an exception should be raised.</li>
			</ul>
			<p>These were discussed in detail in <a href="B16119_06_Final_PD_ePub.xhtml#_idTextAnchor164"><em class="italic">Chapter 6</em></a>, <em class="italic">Models – Structuring the Application Data</em>.</p>
			<p>Another group of decorators affect the <code>self</code> recordset behavior and are relevant when you're implementing other kinds of business logic.</p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor235"/>Decorators that affect the self recordset</h2>
			<p>By default, methods are <a id="_idIndexMarker605"/>expected to act on a recordset that's provided by the self <code>first</code> argument. The method code will usually include a <code>for</code> statement that loops through each of the records in the <code>self</code> recordset.</p>
			<p class="callout-heading">Changes in Odoo 14</p>
			<p class="callout">The <code>@api.multi</code> decorator was removed from Odoo 14. In previous Odoo versions, it was used to explicitly signal that the decorated method expects a recordset in the <code>self</code> parameter. This is already the default behavior for methods, so its use is only for clarity. The <code>@api.one</code> decorator has been deprecated since Odoo 9 and was also removed in Odoo 14. It handled the record loop for you so that the method code would be called once for each record, and the <code>self</code> argument would always be a singleton. Since Odoo 14, both decorators must be removed from the code since they are not supported anymore.</p>
			<p>In some cases, the method is expected to work at the class level and not on particular records, behaving like a <code>@api.model</code> and, in this case, the <code>self</code> method parameter should be used as a reference to the model; it is not expected to contain records.</p>
			<p>For example, the <code>create()</code> method uses <code>@api.model</code> – it does not expect records as input, only a<a id="_idIndexMarker606"/> values dictionary, which will be used to create and return a record. The methods that are used to calculate default values should also use the <code>@api.model</code> decorator.</p>
			<p>Before we can go deeper into the business logic's implementation, we must add more depth to the data model and, in the process, provide examples of a couple of common data model patterns.</p>
			<h1 id="_idParaDest-232"><a id="_idTextAnchor236"/>Exploring useful data model patterns</h1>
			<p>There are a few data <a id="_idIndexMarker607"/>structures that are often needed for models that represent business documents. These can be seen in several Odoo apps, such as <strong class="bold">Sales Orders</strong> or <strong class="bold">Invoices</strong>.</p>
			<p>A common pattern is the header/lines data structure. It will be used for a checkout request so that you can have several books. Another pattern is to use states or stages. These two have differences, and we will discuss them and provide a reference implementation shortly.</p>
			<p>Finally, the ORM API provides a few methods that are relevant for the user interface. These will also be discussed in this section.</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor237"/>Using header and lines models</h2>
			<p>A common need for<a id="_idIndexMarker608"/> form views is to have header-line data structures. For example, a sales order includes several lines for the ordered items. In the case of the checkout feature, a checkout request can have several request lines, one for each of the borrowed items.</p>
			<p>With Odoo, it is simple to implement this. Two models are needed for a header-line form view – one for the document header and another for the document lines. The line model has a many-to-one field to identify the header it belongs to, while the header model has a one-to-many <a id="_idIndexMarker609"/>field listing the lines in that document.</p>
			<p>The <code>library_checkout</code> module was already added to the checkout model, so now, we want to add the lines. Follow these steps to do so:</p>
			<ol>
				<li value="1">Edit the <code>models/library_checkout.py</code> file to add the one-to-many field for the checkout lines:<pre>    line_ids = fields.One2many(
        "library.checkout.line",
        "checkout_id",
        string="Borrowed Books",
    )</pre></li>
				<li>Add the file for the<a id="_idIndexMarker610"/> new model to <code>models/__init__.py</code>, as <a id="_idIndexMarker611"/>follows:<pre>from . import library_checkout
<strong class="bold">from . import library_checkout_line</strong></pre></li>
				<li>Next, add the Python file for declaring the checkout lines model, <code>models/library_checkout_line.py</code>, with the following content:<pre>from odoo import api, exceptions, fields, models
class CheckoutLine(models.Model):
    _name = "library.checkout.line"
    _description = "Checkout Request Line"
    checkout_id = fields.Many2one(
        "library.checkout",
        required=True,
    )
    book_id = fields.Many2one("library.book", 
      required=True)
    note = fields.Char("Notes")</pre></li>
				<li>We must also add access <a id="_idIndexMarker612"/>security configuration. Edit the <code>security/ir.model.access.csv</code> file and add the following highlighted line:<pre>id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
checkout_user,Checkout User,model_library_checkout,library_app.library_group_user,1,1,1,1
<strong class="bold">checkout_line_user,Checkout Line User,model_library_checkout,library_app.library_group_user,1,1,1,1</strong></pre></li>
				<li>Next, we want<a id="_idIndexMarker613"/> to add the checkout lines to the form. We will be adding it as the first page of a notebook widget. Edit the <code>views/checkout_view.xml</code> file and, just before the <code>&lt;/sheet&gt;</code> element, add the following code:<pre>          &lt;notebook&gt;
            &lt;page name="lines"&gt;
              &lt;field name="line_ids"&gt;
                &lt;tree editable="bottom"&gt;
                  &lt;field name="book_id" /&gt;
                  &lt;field name="note" /&gt;
                &lt;/tree&gt;
              &lt;/field&gt;
            &lt;/page&gt;
          &lt;/notebook&gt;</pre></li>
			</ol>
			<p>The Checkouts form will look as follows:</p>
			<div><div><img src="img/Figure_8.2_B16119.jpg" alt="Figure 8.2 – The Checkouts form with the notebook widget&#13;&#10;" width="1169" height="542"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – The Checkouts form with the notebook widget</p>
			<p>The line's <a id="_idIndexMarker614"/>one-to-many field displays a list view that's nested in the parent form view. By <a id="_idIndexMarker615"/>default, Odoo will look up a list view definition to use for rendering, which is typical for any list view. If none are found, a default one will be automatically generated.</p>
			<p>It is also possible to declare specific views inside <code>&lt;field&gt;</code>. We did this in the preceding code. Inside the <code>line_ids</code> field element, there is a nested <code>&lt;tree&gt;</code> view definition that will be used for this form.</p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor238"/>Using stages and states for document-centered workflows</h2>
			<p>In Odoo, we can<a id="_idIndexMarker616"/> implement workflows that are<a id="_idIndexMarker617"/> centered on documents. What we<a id="_idIndexMarker618"/> refer to as documents can be things<a id="_idIndexMarker619"/> such as sales orders, project tasks, or HR applicants. All of these are expected to follow a certain life cycle since they're created until they conclude. Each work item is recorded in a document that will progress through a list of possible stages until it is completed.</p>
			<p>If we present these stages as columns in a board, and the documents as items in those columns, we get a Kanban board, providing a quick view of all the work in progress.</p>
			<p>There are two approaches to implementing these progress steps – <strong class="bold">states</strong> and <strong class="bold">stages</strong>:</p>
			<ul>
				<li><code>state</code> special field name, making it convenient to use. The closed states list is a disadvantage, in that it can't easily accommodate custom process steps.</li>
				<li><code>stage_id</code> field name. The list of available stages is easy to modify as you can remove, add, or reorder them. It has the disadvantage of not being reliable for process automation. Since the list of stages can be changed, automation rules can't rely on particular stage IDs or descriptions.</li>
			</ul>
			<p>When we're <a id="_idIndexMarker622"/>designing the data model, we need <a id="_idIndexMarker623"/>to decide whether it should use stages or states. If triggering business logic is more important than the ability to configure the process steps, states should be preferred; otherwise, stages should be the preferred choice.</p>
			<p>If you can't decide, there <a id="_idIndexMarker624"/>is an approach that can provide<a id="_idIndexMarker625"/> the best of both worlds: we can use stages and map each stage to a corresponding state. The list of process steps can easily be configured by users, and since each stage will be linked to some reliable state code, it can also be confidently used to automate business logic.</p>
			<p>This combined approach will be used for the library checkout feature. To implement the checkout stages, we will add the <code>library.checkout.stage</code> model. The fields that are needed to describe a stage are as follows:</p>
			<ul>
				<li><strong class="bold">Name</strong>, or title.</li>
				<li><strong class="bold">Sequence</strong>, which is used to order the stage columns.</li>
				<li><strong class="bold">Fold</strong>, to be used by the Kanban view to decide what columns should be folded by default. We usually want to set this on inactive item columns, such as <em class="italic">Done</em> or <em class="italic">Canceled</em>.</li>
				<li><strong class="bold">Active</strong>, to allow archived or no-longer-used stages, in case the process is changed.</li>
				<li><strong class="bold">State</strong>, a closed selection list, which is used to map each stage to a fixed state.</li>
			</ul>
			<p>To implement <a id="_idIndexMarker626"/>the preceding fields, we should start<a id="_idIndexMarker627"/> adding the <strong class="bold">Stages</strong> model, including the model definition, views, menus, and access security:</p>
			<ol>
				<li value="1">Add the <code>models/library_checkout_stage.py</code> file and ensure it contains the following model definition code:<pre>from odoo import fields, models
class CheckoutStage(models.Model):
    _name = "library.checkout.stage"
    _description = "Checkout Stage"
    _order = "sequence"
    name = fields.Char()
    sequence = fields.Integer(default=10)
    fold = fields.Boolean()
    active = fields.Boolean(default=True)
    state = fields.Selection(
        [("new","Requested"),
         ("open","Borrowed"),
         ("done","Returned"),
         ("cancel", "Canceled")],
        default="new",
    )</pre><p>The preceding code shouldn't be surprising to you. Stages have a logical sequence, so the order in which they are presented is important. This is ensured by <code>_order="sequence"</code>. We can also see the <code>state</code> field mapping each stage to a basic state, which can be safely used by the business logic.</p></li>
				<li>As usual, the <a id="_idIndexMarker628"/>new code file must be <a id="_idIndexMarker629"/>added to the <code>models/__init__.py</code> file, which should then look like this:<pre><strong class="bold">from . import library_checkout_stage</strong>
from . import library_checkout
from . import library_checkout_line</pre></li>
				<li>Access security rules are also needed. Stages contain setup data, and it should only be editable by the <code>security/ir.model.access.csv</code> file:<pre>id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
checkout_user,Checkout User,model_library_checkout,library_app.library_group_user,1,1,1,1
checkout_line_user,Checkout Line
User,model_library_checkout,library_app.library_group_user,1,1,1,1
<strong class="bold">checkout_stage_user,Checkout Stage User,model_library_checkout_stage,library_app.library_group_user,1,0,0,0</strong>
<strong class="bold">checkout_stage_manager,Checkout Stage Manager,model_library_checkout_stage,library_app.library_group_manager,1,1,1,1</strong></pre></li>
				<li>Next, a<a id="_idIndexMarker630"/> menu item is needed, to <a id="_idIndexMarker631"/>navigate to the stage's setup. This should be under the <code>library_app</code> module does not provide one yet, so let's edit it to add this. Edit the <code>library_app/views/library_menu.xml</code> file and add the following XML:<pre>  &lt;menuitem id="menu_library_configuration"
            name="Configuration"
            parent="menu_library"
  /&gt;</pre></li>
				<li>Now, the <code>library_checkout/views/library_menu.xml</code> file and add the following XML:<pre>  &lt;record id="action_library_stage" 
          model="ir.actions.act_window"&gt;
    &lt;field name="name"&gt;Stages&lt;/field&gt;
    &lt;field name="res_model"&gt;
      library.checkout.stage&lt;/field&gt;
    &lt;field name="view_mode"&gt;tree,form&lt;/field&gt;
  &lt;/record&gt;
  &lt;menuitem id="menu_library_stage"
            name="Stages"
            action="action_library_stage"
            parent=
             "library_app.menu_library_configuration" 
  /&gt;</pre></li>
				<li>We need<a id="_idIndexMarker632"/> some stages to work with, so <a id="_idIndexMarker633"/>let's add some default data to the module. Create the <code>data/library_checkout_stage.xml</code> file with the following code:<pre>&lt;odoo noupdate="1"&gt;
  &lt;record id="stage_new" model=
    "library.checkout.stage"&gt;
      &lt;field name="name"&gt;Draft&lt;/field&gt;
      &lt;field name="sequence"&gt;10&lt;/field&gt;
      &lt;field name="state"&gt;new&lt;/field&gt;
  &lt;/record&gt;
  &lt;record id="stage_open" model=
    "library.checkout.stage"&gt;
      &lt;field name="name"&gt;Borrowed&lt;/field&gt;
      &lt;field name="sequence"&gt;20&lt;/field&gt;
      &lt;field name="state"&gt;open&lt;/field&gt;
  &lt;/record&gt;
  &lt;record id="stage_done" model=
    "library.checkout.stage"&gt;
      &lt;field name="name"&gt;Completed&lt;/field&gt;
      &lt;field name="sequence"&gt;90&lt;/field&gt;
      &lt;field name="state"&gt;done&lt;/field&gt;
  &lt;/record&gt;
  &lt;record id="stage_cancel" model=
    "library.checkout.stage"&gt;
      &lt;field name="name"&gt;Canceled&lt;/field&gt;
      &lt;field name="sequence"&gt;95&lt;/field&gt;
      &lt;field name="state"&gt;cancel&lt;/field&gt;
  &lt;/record&gt;
&lt;/odoo&gt;</pre></li>
				<li>Before this <a id="_idIndexMarker634"/>can take effect, it needs to be<a id="_idIndexMarker635"/> added to the <code>library_checkout/__manifest__.py</code> file, as follows:<pre>  "data": [
    "security/ir.model.access.csv",
    "views/library_menu.xml",
    "views/checkout_view.xml",
<strong class="bold">    "data/library_checkout_stage.xml",</strong>
  ],</pre></li>
			</ol>
			<p>The following screenshot shows what the Stages list view is expected to look like:</p>
			<div><div><img src="img/Figure_8.3_B16119.jpg" alt="Figure 8.3 – The Stages list view&#13;&#10;" width="1177" height="292"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – The Stages list view</p>
			<p>This takes care of all the components that are needed to add the Stages model to <code>library_checkout</code> and allow users to configure it.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor239"/>Adding stage workflow support to models</h2>
			<p>Next, the stage <a id="_idIndexMarker636"/>field should be added to the library<a id="_idIndexMarker637"/> checkout model. For a proper user experience, two more things should be taken care of:</p>
			<ul>
				<li>The default stage to assign should be the first with a <code>new</code> state.</li>
				<li>When grouping by stage, all the available stages should be present, even if there are no checkouts in each of the stages.</li>
			</ul>
			<p>These should be added to the <code>library_checkout/models/library_checkout.py</code> file, in the <code>Checkout</code> class.</p>
			<p>The function for finding the default stage should return the record that will be used as the default value:</p>
			<pre>    @api.model
    def _default_stage_id(self):
        Stage = self.env["library.checkout.stage"]
        return Stage.search([("state", "=", "new")], 
          limit=1)</pre>
			<p>This returns the first record in the stage model. Since the stage model is ordered by sequence, it will return the one with the lowest sequence number.</p>
			<p>When we're grouping by stages, we would like to see all the possible stages rather than only the ones with checkout records. The method that's used for this should return a recordset to use for the groups. In this case, it is appropriate to return all the active stages:</p>
			<pre>    @api.model
    def _group_expand_stage_id(self, stages, domain, 
      order):
        return stages.search([], order=order)</pre>
			<p>Finally, the <code>stage_id</code> field we wish to add to the checkout model can use the preceding methods for the <code>default</code> and <code>group_expand</code> attributes:</p>
			<pre>    stage_id = fields.Many2one(
        "library.checkout.stage",
        default=_default_stage_id,
        group_expand="_group_expand_stage_id")
    state = fields.Selection(related="stage_id.state")</pre>
			<p><code>stage_id</code> has a many-to-one relationship with the stages model. The default value is calculated by the <code>_default_stage_id</code> method function, and the groupby on <code>stage_id</code> will <a id="_idIndexMarker638"/>use the result of the <code>_group_expand_stage_id</code> method <a id="_idIndexMarker639"/>function.</p>
			<p class="callout-heading">Changes in Odoo 10</p>
			<p class="callout">The <code>group_expand</code> field attribute was introduced in Odoo 10 and is not available in previous versions.</p>
			<p>The <code>group_expand</code> parameter overrides the way grouping works on the field. The default behavior for grouping operations is to only see the stages that are being used; the stages with no checkout document won't be shown. But in the case of the <code>stage_id</code> field, we want to see all the available stages, even if some don't have any items.</p>
			<p>The <code>_group_expand_stage_id()</code> helper function returns the list of group records that the grouping operation should use. In this case, it returns all the existing stages, regardless of having library checkouts in that stage or not.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>group_expand</code> attribute must be a string with a method name. This is unlike other attributes, such as <code>default</code>, which can be either strings or direct references to the method name.</p>
			<p>The <code>state</code> field was also added. It simply makes the stage-related <code>state</code> field in this model available so that it can be used in views. This will use the special support for <code>state</code> that views have available.</p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor240"/>Methods to support the user interface</h2>
			<p>The following methods are mostly used by the web client to render the user interface and perform basic interaction:</p>
			<ul>
				<li><code>name_get()</code> computes<a id="_idIndexMarker640"/> the <code>(ID, name)</code> tuples, along with the ID. It is the default computation for the <code>display_name</code> value and can be extended to implement custom display representations, such as displaying an identifier code along with the record name.</li>
				<li><code>name_search(name="", args=None, operator="ilike", limit=100)</code> performs a search on the display name. It is used on views when the user is typing in a relationship field to produce a list containing the suggested records that match the typed text. It returns a list of <code>(ID, name)</code> tuples.</li>
				<li><code>name_create(name)</code> creates a new record that only has a name as input. It is used in Kanban views with <code>on_create="quick_create"</code>, where you can quickly create a related record by just providing its name. It can be extended to provide specific defaults for the new records that are created through this feature.</li>
				<li><code>default_get([fields])</code> returns the default values for a new record to be created, as a dictionary. The default values may depend on variables, such as the current user or the session context. This can be extended to add additional default values.</li>
				<li><code>fields_get()</code> is used to describe the model's field definitions.</li>
				<li><code>fields_view_get()</code> is used by the web client to retrieve the structure of the UI view to render. It can be given the ID of the view as an argument, or the type of view we want using <code>view_type="form"</code>. For example, <code>self.fields_view_get(view_type="tree")</code> will return the tree view XML architecture <a id="_idIndexMarker641"/>to be rendered for the <code>self</code> model.</li>
			</ul>
			<p>These built-in ORM models can be helpful as extension points to implement model-specific business logic.</p>
			<p>The next section will discuss how business logic can be triggered by record operations, such as creating or writing on a record.</p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor241"/>Using the ORM built-in methods</h1>
			<p>The model<a id="_idIndexMarker642"/> definition-related methods can do many things, but some business logic is not possible through them, so it needs to be attached to the ORM record writing operations.</p>
			<p>ORM provides methods to perform <strong class="bold">Create</strong>, <strong class="bold">Read</strong>, <strong class="bold">Update</strong>, and <strong class="bold">Delete</strong> (<strong class="bold">CRUD</strong>) operations<a id="_idIndexMarker643"/> on our model data. Let's explore these write operations and how they can be extended to support custom logic.</p>
			<p>To read data, the main methods that are provided are <code>search()</code> and <code>browse()</code>, as discussed in <a href="B16119_07_Final_PD_ePub.xhtml#_idTextAnchor194"><em class="italic">Chapter 7</em></a>, <em class="italic">Recordsets – Working with Model Data</em>.</p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor242"/>Methods for writing model data</h2>
			<p>The ORM provides three<a id="_idIndexMarker644"/> methods for the three basic write operations, shown as follows:</p>
			<ul>
				<li><code>&lt;Model&gt;.create(values)</code> creates a new record on the model. It returns the created record. <code>values</code> can be a dictionary or a list of dictionaries for mass-creating records.</li>
				<li><code>&lt;Recordset&gt;.write(values)</code> updates the recordset with the <code>values</code> dictionary. It returns nothing.</li>
				<li><code>&lt;Recordset&gt;.unlink()</code> deletes the records from the database. It returns nothing.</li>
			</ul>
			<p>The <code>values</code> argument<a id="_idIndexMarker645"/> is a dictionary that maps field names to values to write. These methods are decorated with <code>@api.multi</code>, except for the <code>create()</code> method, which is decorated with <code>@api.model</code>.</p>
			<p class="callout-heading">Changes in Odoo 12</p>
			<p class="callout">Being able to use <code>create()</code> to access a list of dictionaries, instead of a single dictionary object, was introduced in Odoo 12. This also allows us to create records in batches. This capability is supported through the special <code>@api.model_create_multi</code> decorator.</p>
			<p>In some cases, these methods need to be extended to run some specific business logic when they are triggered. This business logic can be run before or after the main method operations are executed.</p>
			<h3>Example of extending create()</h3>
			<p>Let's look at an <a id="_idIndexMarker646"/>example that makes use of this. We want to prevent new checkout records from being created directly in the <code>Borrowed</code> or <code>Returned</code> states. Usually, validations should be implemented in specific methods that are decorated with <code>@api.constrains</code>. But this particular case is tied to the create record event and is hard to implement as a regular validation.</p>
			<p>Edit the <code>library_checkout/models/library_checkout.py</code> file and add the <code>create()</code> extension method:</p>
			<pre>    @api.model 
    def create(self, vals):
        # Code before create: should use the 'vals' dict
        new_record = super().create(vals) 
        # Code after create: can use the 'new_record' 
        # created 
        if new_record.stage_id.state in ("open", "close"):
            raise exceptions.UserError(
                "State not allowed for new checkouts."
            )
        return new_record</pre>
			<p>The new record is created by the <code>super().create()</code> call. Before this, the new record is not available to use in the business logic – only the <code>values</code> dictionary can be used, or even changed, to force values on the to-be-created record.</p>
			<p>The code after <code>super().create()</code> does have access to the new record that's been created and can use record features, such as accessing related records using dot-notation chains. The <a id="_idIndexMarker647"/>preceding example uses <code>new_record.stage_id.state</code> to access the state that corresponds to the new record stage. States are not user-configurable and provide a reliable list of values to use in business logic. So, we can look for <code>open</code> or <code>done</code> states and raise an error if any of them are found.</p>
			<h3>Example of extending write()</h3>
			<p>Let's look <a id="_idIndexMarker648"/>at another example. The <code>Checkout</code> model should keep track of the date when the books were borrowed, <code>Checkout Date</code>, and the date when they were returned, <code>Close Date</code>. This can't be done using computed fields. Instead, the <code>write()</code> method should be extended to detect changes on the checkout state and then update the dates that have been filed at the right moment: when changing into the <code>open</code> or <code>close</code> states.</p>
			<p>Before we implement this logic, the two date fields must be created. Edit the <code>library_checkout/models/library_checkout.py</code> file and add the following code:</p>
			<pre>    checkout_date = fields.Date(readonly=True)
    close_date = fields.Date(readonly=True)</pre>
			<p>When a record is modified, the <code>checkout_date</code> and <code>close_date</code> fields should be set when the checkout record enters the appropriated states. For this, we will use a custom <code>write()</code> method, as follows:</p>
			<pre>    def write(self, vals):
        # Code before write: 'self' has the old values 
<strong class="bold">        if "stage_id" in vals:</strong>
<strong class="bold">            Stage = self.env["library.checkout.stage"]</strong>
<strong class="bold">            </strong><strong class="bold">old_state = self.stage_id.state</strong>
<strong class="bold">            new_state = </strong>
<strong class="bold">              Stage.browse(vals["stage_id"]).state</strong>
<strong class="bold">            if new_state != old_state and new_state == </strong>
<strong class="bold">              "open":</strong>
<strong class="bold">                vals['checkout_date'] = fields.Date.today()</strong>
<strong class="bold">            if new_state != old_state and new_state == </strong>
<strong class="bold">               "done":</strong>
<strong class="bold">                vals['close_date'] = fields.Date.today()</strong>
        super().write(vals)
        # Code after write: can use 'self' with the updated 
        # values
        return True</pre>
			<p>In the preceding <a id="_idIndexMarker649"/>example, the extension code was added before the <code>super()</code> call; so, <em class="italic">before</em> the write operation is done on the <code>self</code> record. To know what change is about to be made to the record, we can inspect the <code>vals</code> parameter. The <code>stage_id</code> value in the <code>vals</code> dictionary is an ID number, not a record, so it needs to be browsed to get the corresponding record, and then read the corresponding <code>state</code>.</p>
			<p>The old and<a id="_idIndexMarker650"/> new states are compared to trigger the date value update at the appropriate moment. Whenever possible, we prefer to change the values to write before the <code>super().write()</code> instruction and modify the <code>vals</code> dictionary instead of setting the field value directly. We'll see why in the next section.</p>
			<h3>Example of extending write() that sets values on fields</h3>
			<p>The previous <a id="_idIndexMarker651"/>code only modifies the values to use for the write; it does not assign values directly to the model fields. This is safe to do, but it may not be enough in some cases.</p>
			<p>Assigning a model field value inside a <code>write()</code> method leads to an infinite recursion loop: the assignment triggers the write method again, which then repeats the assignment, triggering yet another write call. This will repeat until Python returns a recursion error.</p>
			<p>There is a technique to avoid this recursion loop, making it possible for <code>write()</code> methods to set values on its record fields. The trick is to set a unique marker in the environment's <code>context</code> before setting the values, and only run the setting values code when that marker is not present.</p>
			<p>An example will help make this clear. Let's rewrite the previous example so that the updates are done after calling <code>super()</code>, rather than before:</p>
			<pre>    def write(self, vals):
        # Code before write: 'self' has the old values 
        old_state = self.stage_id.state
        super().write(vals)
        # Code after write: can use 'self' with the updated 
        # values
        new_state = self.stage_id.state 
        <strong class="bold">if not self.env.context.get("_checkout_write"):</strong>
            if new_state != old_state and new_state == "open":
                self<strong class="bold">.with_context(</strong>
<strong class="bold">                  _checkout_write=True)</strong>.write(
                    {"checkout_date": fields.Date.today()})
            if new_state != old_state and new_state == 
              "done":
                self<strong class="bold">.with_context(</strong>
<strong class="bold">                  _checkout_write=True)</strong>.write(
                    {"close_date": fields.Date.today()})
        return True</pre>
			<p>With this technique, the extension code is guarded by an <code>if</code> statement and only runs if a specific marker is not found in the context. Furthermore, the additional <code>self.write()</code> operations use the <code>with_context</code> method to set that marker before doing the write. This<a id="_idIndexMarker652"/> combination ensures that the custom login inside the <code>if</code> statement runs only once and is not triggered on further <code>write()</code> calls, avoiding the infinite loop.</p>
			<h3>When (not) to extend the create() and write() methods</h3>
			<p>Extending the <code>create()</code> or <code>write()</code> methods should be carefully considered.</p>
			<p>In most cases, some <a id="_idIndexMarker653"/>validation must be performed, or some value must be automatically computed when the record is saved. For these common cases, there are better options, as listed here:</p>
			<ul>
				<li>For field values that are automatically calculated based on other fields, use computed fields. For example, you should calculate a header total when the values of the lines are changed.</li>
				<li>For non-fixed field default values, use a function as the default field value. It will be evaluated and used to assign the default value.</li>
				<li>To have other field values change when some field is changed, use the <code>onchange</code> methods, if this is expected to be done on the user interface, or use the new <code>onchange</code> methods, this only works on form view interaction, not on direct write calls, though computed writable fields work in both cases. The <em class="italic">Adding onchange user interface logic</em> section will provide more detail about this.</li>
				<li>For validations, use <code>constraint</code> functions. These are automatically triggered when the<a id="_idIndexMarker654"/> field value changes and are expected to raise errors if the validation conditions fail.</li>
			</ul>
			<p>There are still cases where none of these options will work and extending <code>create()</code> or <code>write()</code> is needed, such as when the default values to set depend on the other fields of the record that's being created. In this case, a default value function won't work because it does not have access to the other field values of the new record.</p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor243"/>Methods for data import and export</h2>
			<p>Data import and export, as discussed in <a href="B16119_05_Final_PD_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 5</em></a>, <em class="italic">Importing, Exporting, and Module Data</em>, is also available from the ORM API, through the following methods:</p>
			<ul>
				<li><code>load([fields], [data])</code> is<a id="_idIndexMarker655"/> used to import data and is used by Odoo when importing CSV or spreadsheet data into Odoo. The first argument is the list of fields to import, and it maps directly to a CSV top row. The second argument is a list of records, where each record is a list of string values to parse and import. It maps directly to the CSV data rows and columns and implements the features of CSV data import, such as external identifiers support.</li>
				<li><code>export_data([fields])</code> is used by<a id="_idIndexMarker656"/> the web client's <code>Export</code> function. It returns a dictionary with a <code>datas</code> key containing the data; that is, a list of rows. The field names can use the <code>.id</code> and <code>/id</code> suffixes that are used in CSV files, and the data is in a format that's compatible with an importable CSV file.</li>
			</ul>
			<p>It is also possible to implement automation on the user interface, while the user is editing data. We'll learn about this in the next section.</p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor244"/>Adding onchange user interface logic</h1>
			<p>It is possible to <a id="_idIndexMarker657"/>make changes to the web client view while the user is editing it. This <a id="_idIndexMarker658"/>mechanism is known as <code>@api.onchange</code>, and they are triggered by the user interface view when the user edits a value on a particular field.</p>
			<p>Since Odoo 13, the same effect can be achieved by using a particular form of computed fields, called <strong class="bold">computed writable fields</strong>. This <a id="_idIndexMarker659"/>ORM improvement aims to avoid some limitations of the classic onchange mechanism, and in the long run, it should replace it completely.</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor245"/>Classic onchange methods</h2>
			<p>Onchange methods<a id="_idIndexMarker660"/> can change other field values in the form, perform a validation, show a message to the user, or set a domain filter in relation fields, limiting the available options.</p>
			<p>The onchange method is called asynchronously and returns data that's being used by the web client to update the fields in the current view.</p>
			<p>Onchange methods are linked to the triggering fields, which are passed as arguments to the <code>@api.onchange("fld1", "fld2", ...)</code> decorator.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>api.onchange</code> arguments do not support dot notation; for example, <code>"partner_id.name"</code>. If used, it will be ignored.</p>
			<p>Inside the method, the <code>self</code> argument is a virtual record that contains the current form data. It is virtual because it can be a new or changed record that is still being edited and hasn't been saved to the database yet. If values are set on this <code>self</code> record, these will be changed on the user interface form. Notice that it doesn't write to database records; instead, it provides information so that you can change the data in the UI form.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Other restrictions apply to onchange methods, as documented at <a href="https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html#odoo.api.onchange">https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html#odoo.api.onchange</a>.Computed writable fields can be used as a full-featured alternative to onchanges. See the <em class="italic">The new onchange, with computed writable fields</em> section for more information.</p>
			<p>No return value is needed, but a <code>dict</code> structure may be returned with a warning message to display in the user interface, or a domain filter to be set on form fields.</p>
			<p>Let's work with an <a id="_idIndexMarker661"/>example. On the checkout form, when the library member is selected, the request date will be set to <code>today</code>. If the date changed, a warning message will be shown to the user, alerting them about it.</p>
			<p>To implement this, edit the <code>library_checkout/models/library_checkout.py</code> file and add the following method:</p>
			<pre>    @api.onchange("member_id")
    def onchange_member_id(self):
        today_date = fields.Date.today()
        if self.request_date != today_date:
            self.request_date = today_date
            return {
                "warning": {
                    "title": "Changed Request Date",
                    "message": "Request date changed to 
                      today!",
                }
            }</pre>
			<p>The previous <code>onchange</code> method is triggered when the <code>member_id</code> field is set on the user interface. The actual method name is not relevant, but the convention is for its name to begin with the <code>onchange_</code> prefix.</p>
			<p>Inside an <code>onchange</code> method, <code>self</code> represents a single virtual record containing all of the fields that have currently been set in the record being edited, and we can interact with them.</p>
			<p>The method code checks whether the current <code>request_date</code> needs to be changed. If it does, <code>request_date</code> is set to today so that the user will see that change in the form. Then, a non-blocking warning message is returned to the user.</p>
			<p>The <code>onchange</code> methods do not need to return anything, but they can return a dictionary containing a <a id="_idIndexMarker662"/>warning or a domain key, as follows:</p>
			<ul>
				<li>The warning key should describe a message to show in a dialog window, such as <code>{"title": "Message Title", "message": "Message Body"}</code>.</li>
				<li>The domain key can set or change the domain attribute of other fields. This allows you to build more user-friendly interfaces; having a to-many field only makes the options that make sense at that moment available. The value for the domain key looks like <code>{"user_id": [("email", "!=", False)]}</code>.</li>
			</ul>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor246"/>The new onchange, with computed writable fields</h2>
			<p>The classic onchange mechanism has <a id="_idIndexMarker663"/>a key role in the user experience that's provided by the Odoo framework. However, it has a few important limitations.</p>
			<p>One is that it works disconnected from the server-side events. Onchange is only played when requested by the form view and is not called as a consequence of an actual <code>write()</code> value change. This forces the server-side business logic to explicitly replay the relevant onchange methods.</p>
			<p>Another limitation is that onchange is attached to the triggering fields and not to the change-affected fields. In non-trivial cases, this becomes hard to extend and makes it difficult to track the source of the changes.</p>
			<p>To address these issues, the <a id="_idIndexMarker664"/>Odoo framework expanded the computed field capabilities so that it can also address the onchange use case. We will call this technique <strong class="bold">computed writable fields</strong>. The classic onchange is still supported and used, but it is expected to be replaced by computed fields and become deprecated in future versions.</p>
			<p class="callout-heading">Changes in Odoo 13</p>
			<p class="callout">Computed writable fields were introduced in Odoo 13 and are available for that version and later ones.</p>
			<p>Computed writable fields have compute methods assigned to them, must be stored, and must have the <strong class="bold">readonly=False</strong> attribute.</p>
			<p>Let's implement the previous onchange using this technique instead. This is how the <code>request_date</code> field definition should be changed:</p>
			<pre>    request_date = fields.Date(
        default=lambda s: fields.Date.today(),
<strong class="bold">        compute="_compute_request_date_onchange",</strong>
<strong class="bold">        store=True,</strong>
<strong class="bold">        readonly=False,</strong>
    )</pre>
			<p>This is a <a id="_idIndexMarker665"/>regular stored and writable field, but it has attached a compute method that can be triggered in particular conditions. For example, the computed method should be triggered when the <code>member_id</code> field changes.</p>
			<p>This is the code for the compute method, <code>_compute_request_date_onchange</code>:</p>
			<pre><strong class="bold">    @api.depends("member_id")</strong>
<strong class="bold">    def _compute_request_date_onchange(self):</strong>
        today_date = fields.Date.today()
        if self.request_date != today_date:
            self.request_date = today_date
            return {
                "warning": {
                    "title": "Changed Request Date",
                    "message": "Request date changed to 
                      today!",
                }
            }</pre>
			<p><code>@api.depends</code> works as usual for computed fields and declares the fields to watch for changes. The actual field list to provide is the same as the one that's used by the classic <code>@api.onchange</code>.</p>
			<p>The method code can be very similar to the equivalent onchange method. In this particular case, it is identical. Note that the computed field is not ensured to be set a value on every method call. This <a id="_idIndexMarker666"/>only happens when some conditions are met. In this case, the original request date is different from today's date. This goes against regular computed field rules but is allowed for computed writable fields.</p>
			<p>Particularly relevant to business processes is the ability to send emails or notify users. The next section discusses the features that Odoo provides for this.</p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor247"/>The message and activity features</h1>
			<p>Odoo has global messaging and activity planning features available, all of which are provided by the <code>mail</code> technical name.</p>
			<p>The messaging features<a id="_idIndexMarker667"/> are added by the <code>mail.thread</code> model and make a message widget on form views available, also known as C<em class="italic">hatter</em>. This widget allows you to log notes or send messages to other people. It also keeps a history of the messages that have been sent, and it is also used by automatic processes to log progress tracking messages.</p>
			<p>The same app also provides activity management features<a id="_idIndexMarker668"/> through the <code>mail.activity.mixin</code> model. The activity widget can be added to the form view to allow users to schedule and track the history of activities.</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor248"/>Adding message and activity features</h2>
			<p>The mail module provides the <code>mail.thread</code> abstract class, which is used to add the messaging<a id="_idIndexMarker669"/> features to any model, and <code>mail.activity.mixin</code>, which does the same for the planned<a id="_idIndexMarker670"/> activity features. In <a href="B16119_04_Final_PD_ePub.xhtml#_idTextAnchor119"><em class="italic">Chapter 4</em></a>, <em class="italic">Extending Modules</em>, we explained how to add these inherited features to models using the inheritance from mixin abstract classes.</p>
			<p>Let's go through the necessary steps:</p>
			<ol>
				<li value="1">Add the <code>mail</code> module dependency to the <code>library_checkout</code> add-on module by editing the <code>'depends'</code> key in the <code>library_checkout/__manifest__.py </code>file, as follows:<pre>  "depends": ["library_member", <strong class="bold">"mail"</strong>],</pre></li>
				<li>To have the <code>library.checkout</code> model inherit from the message and activity abstract classes, edit the <code>library_checkout/models/library_checkout.py </code>files, as follows:<pre>class Checkout(models.Model): 
    _name = "library.checkout"
    _description = "Checkout Request"
    <strong class="bold">_inherit = ["mail.thread", "mail.activity.mixin"]</strong></pre></li>
				<li>To add the message and activity fields to the checkout form view, edit the <code>library_checkout/</code> and <code>views/checkout_view.xml</code> files:<pre>  &lt;record id="view_form_checkout" model="ir.ui.view"&gt;
    &lt;field name="name"&gt;Checkout Form&lt;/field&gt;
    &lt;field name="model"&gt;library.checkout&lt;/field&gt;
    &lt;field name="arch" type="xml"&gt;
      &lt;form&gt;
        &lt;sheet&gt;
          &lt;group&gt;
            &lt;field name="member_id" /&gt;
            &lt;field name="request_date" /&gt;
            &lt;field name="user_id" /&gt;
          &lt;/group&gt;
          &lt;notebook&gt;
            &lt;page name="lines"&gt;
              &lt;field name="line_ids"&gt;
                &lt;tree editable="bottom"&gt;
                  &lt;field name="book_id" /&gt;
                  &lt;field name="note" /&gt;
                &lt;/tree&gt;
              &lt;/field&gt;
            &lt;/page&gt;
          &lt;/notebook&gt;
        &lt;/sheet&gt;
<strong class="bold">        &lt;div class="oe_chatter"&gt;</strong>
<strong class="bold">          &lt;field name="message_follower_ids"</strong>
<strong class="bold">                 widget="mail_followers" /&gt;</strong>
<strong class="bold">          &lt;field name="activity_ids"</strong>
<strong class="bold">                 widget="mail_activity"/&gt;</strong>
<strong class="bold">          &lt;field name="message_ids"</strong>
<strong class="bold">                 widget="mail_thread" /&gt;</strong>
<strong class="bold">        </strong><strong class="bold">&lt;/div&gt;</strong>
      &lt;/form&gt;
    &lt;/field&gt;
  &lt;/record&gt;
&lt;/odoo&gt;</pre></li>
			</ol>
			<p>Having done this, the checkout model will have the message and activity fields and their features available.</p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor249"/>Message and activity fields and models</h2>
			<p>The message and activity features add new fields to the models that inherit the <code>mail.thread</code> and <code>mail.activity.mixin</code> classes, along with all the supporting models for these features. These are the basic data structures that have been added.</p>
			<p>The <code>mail.thread</code> mixin class makes two new fields available:</p>
			<ul>
				<li><code>message_follower_ids</code> has a <a id="_idIndexMarker671"/>one-to-many relationship with <code>mail.followers</code> and stores the message followers that should receive notifications. Followers can either be partners or <a id="_idIndexMarker672"/>channels. A <strong class="bold">partner</strong> represents a specific person or organization. A <strong class="bold">channel</strong> is not a particular person and instead represents a<a id="_idIndexMarker673"/> subscription list.</li>
				<li><code>message_ids</code> has a<a id="_idIndexMarker674"/> one-to-many relationship with <code>mail.message</code> records and lists the record message history.</li>
			</ul>
			<p>The <code>mail.activity.mixin</code> mixin class adds the following new field:</p>
			<ul>
				<li><code>activity_ids</code> has a one-to-many relationship with <code>mail.activity</code> and stores activities<a id="_idIndexMarker675"/> that have been completed or planned.</li>
			</ul>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor250"/>Message subtypes</h2>
			<p>Messages can be <a id="_idIndexMarker676"/>assigned a <strong class="bold">subtype</strong>. Subtypes can identify particular events, such as a task being created or closed, and are useful for fine-tuning what notifications should be sent to whom.</p>
			<p>Subtypes are stored in the <code>mail.message.subtype</code> model and can be configured in the <strong class="bold">Settings</strong> | <strong class="bold">Technical</strong> | <strong class="bold">Email</strong> | <strong class="bold">Subtypes</strong> menu.</p>
			<p>The basic message subtypes that are available are as follows:</p>
			<ul>
				<li><code>mail.mt_comment</code> XML ID, are used for the messages that are sent through the <strong class="bold">Send message</strong> option in the message widget. Followers will be sent a message notification about this.</li>
				<li><code>mail.mt_note</code> XML ID, is used by the messages that are created with the <strong class="bold">Log note</strong> XML ID, which do not send out notifications.</li>
				<li><code>mail.mt_activities</code> XML ID, are used for the messages that are created with the <code>Schedule activity</code> link. It is not intended to send a notification.</li>
			</ul>
			<p>Apps can add their own subtypes, which are usually linked to relevant events. For example, the <code>Quotation sent</code> and <code>Sales Order Confirmed</code>. These are used by the app's business logic when you're logging these events in the message history.</p>
			<p>Subtypes allow you to determine when notifications should be sent out and to whom. The followers menu, at the top right of the messages widget, allows you to add or remove followers, as well as selecting the particular subtypes they will receive notifications about. The following screenshot shows the subtype selection form for a specific follower – <em class="italic">Deco Addict</em>, in this case:</p>
			<div><div><img src="img/Figure_8.4_B16119.jpg" alt="Figure 8.4 – Followers widget to select the active message subtypes&#13;&#10;" width="1284" height="546"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – Followers widget to select the active message subtypes</p>
			<p>The subtype<a id="_idIndexMarker680"/> subscription flags can be edited manually, and their default value is configured on editing the <strong class="bold">Subtype</strong> definition to check the <strong class="bold">Default</strong> field. When it is set, the followers on new records will receive notifications by default.</p>
			<p>Other than the built-in subtypes, add-on modules add their own subtypes. A subtype can be global or intended for a particular model. In the latter case, the subtype's <code>res_model</code> field identifies the model it applies to.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor251"/>Posting messages</h2>
			<p>Module business<a id="_idIndexMarker681"/> logic can make use of the messaging system to send notifications to users.</p>
			<p>The <code>message_post()</code> method is used to post a message. Here is an example:</p>
			<pre>self.message_post("Hello!")</pre>
			<p>The preceding code adds a simple text message but sends no notification to the followers. This is because, by default, messages are posted using <code>subtype="mail.mt_note"</code> parameter.</p>
			<p>To have the message send a notification as well, the <code>mail.mt_comment</code> subtype should be used, as shown in the following example:</p>
			<pre>self.message_post(
    "Hello again!",
    subject="Hello",
    subtype='mail.mt_comment",
)</pre>
			<p>The message body <a id="_idIndexMarker682"/>is HTML, so we can include markup for text effects, such as <code>&lt;b&gt;</code> for bold text or <code>&lt;i&gt;</code> for italics. </p>
			<p>The message body will be sanitized for security reasons, so some particular HTML elements may not make it to the final message.</p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor252"/>Adding followers</h2>
			<p>Also useful<a id="_idIndexMarker683"/> from a business logic viewpoint is the ability to automatically <a id="_idIndexMarker684"/>add followers to a document so that they can then get the corresponding notifications. There are a few methods available to add followers, as follows:</p>
			<ul>
				<li><code>message_subscribe(partner_ids=&lt;list of int IDs&gt;)</code> adds partners</li>
				<li><code>message_subscribe(channel_ids=&lt;list of int IDs&gt;)</code> adds channels</li>
				<li><code>message_subscribe_users(user_ids=&lt;list of int IDs&gt;)</code> adds users</li>
			</ul>
			<p>The default subtypes will be applied to each subscriber. To force a user to subscribe to a specific list of subtypes, you can add the <code>subtype_ids=&lt;list of int IDs&gt;</code> attribute, which lists the specific subtypes to enable for the subscription. If this is used, it will also reset the existing follower-subscribed subtypes to the specified ones.</p>
			<h1 id="_idParaDest-249"><a id="_idTextAnchor253"/>Creating a wizard</h1>
			<p><strong class="bold">Wizards</strong> are <a id="_idIndexMarker685"/>user interface patterns that provide rich interaction for the user, usually to provide input for an automated process.</p>
			<p>As an example, the <a id="_idIndexMarker686"/><code>checkout</code> module will provide a wizard for library users to mass email borrowers. For example, they could select the oldest checkouts with borrowed books and send them all a message, requesting for the books to be returned.</p>
			<p>Users start by going to the checkouts list view, selecting the checkout records to use, and then selecting a <strong class="bold">Send Messages</strong> option from the <strong class="bold">Action</strong> context menu. This will open the wizard form, allowing them to write the message subject and body. Clicking the <strong class="bold">Send</strong> button will send an email to each person that borrowed the selected checkouts.</p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor254"/>The wizard model</h2>
			<p>A wizard<a id="_idIndexMarker687"/> displays a form view to the user, usually as a dialog window, with some fields to be filled in and buttons to trigger some business logic. These will then be used for the wizard's logic.</p>
			<p>This is implemented using the same model/view architecture that's used for regular views, but the supporting model is based on <code>models.TransientModel</code> instead of <code>models.Model</code>. This type of model has a database representation too, which is used to store the wizard's state. The wizard data is temporary, to allow the wizard to complete its work. A scheduled job regularly cleans up the old data from the wizard database tables.</p>
			<p>The <code>library_checkout/wizard/library_checkout_massmessage.py</code> file will create the model data structure that's needed for the user interaction: the list of checkout records to be notified, the message subject, and the message body.</p>
			<p>Follow these steps to add the wizard to the <code>library_checkout</code> module:</p>
			<ol>
				<li value="1">First, edit the <code>library_checkout/__init__.py</code> file to import the code into the <code>wizard/</code> subdirectory, as follows:<pre>from . import models
<strong class="bold">from . import wizard</strong></pre></li>
				<li>Add the <code>wizard/__init__.py</code> file with the following line of code:<pre>from . import checkout_mass_message</pre></li>
				<li>Then, create the actual <code>wizard/checkout_mass_message.py</code> file, as follows:<pre>from odoo import api, exceptions, fields, models
class CheckoutMassMessage(models.TransientModel): 
    _name = "library.checkout.massmessage"
    _description = "Send Message to Borrowers"
    checkout_ids = fields.Many2many(
        "library.checkout",
        string="Checkouts",
    )
    message_subject = fields.Char()
    message_body = fields.Html()</pre></li>
			</ol>
			<p>With that, we have<a id="_idIndexMarker688"/> prepared the basic data structures that are needed for the wizard.</p>
			<p>Note that regular models shouldn't have relationship fields that use transient models.</p>
			<p>The consequence of this is that transient models shouldn't have one-to-many relationships with regular models. The reason for this is that the one-to-many relationship on the transient model would require the regular model to have the inverse many-to-one relationship with the transient model, which would cause issues with automatically cleaning up transient records.</p>
			<p>The alternative to this is to use a many-to-many relationship. Many-to-many relationships are stored in a dedicated table, and the rows in this table are automatically deleted when either side of the relationship is deleted.</p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor255"/>The wizard's access security</h2>
			<p>Just like regular<a id="_idIndexMarker689"/> models, transient models also need access security rules to be defined on them. This is done in the same way as it is for regular modules – usually, in the <code>security/ir.model.access.csv</code> file.</p>
			<p class="callout-heading">Changes in Odoo 13</p>
			<p class="callout">Up until Odoo 12, transient models did not need access security rules. This changed in Odoo 13, so now, transient models require access rules, just like regular models do.</p>
			<p>To add ACLs for the wizard's model, edit the <code>security/ir.model.access.csv</code> file and add the following highlighted line:</p>
			<pre>id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
checkout_user,Checkout User,model_library_checkout,library_app.library_group_user,1,1,1,1
checkout_line_user,Checkout Line
checkout_user,Checkout User,model_library_checkout,library_app.library_group_user,1,1,1,1
checkout_stage_user,Checkout Stage User,model_library_checkout_stage,library_app.library_group_user,1,0,0,0
checkout_stage_manager,Checkout Stage Manager,model_library_checkout_stage,library_app.library_group_manager,1,1,1,1
<strong class="bold">checkout_massmessage_user,Checkout Mass Message User,model_library_checkout_massmessage,library_app.library_group_user,1,1,1,1</strong></pre>
			<p>Adding one <a id="_idIndexMarker690"/>line is enough to add full access to the Library User group; no specific access rights are needed for the Library Manager group.</p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor256"/>The wizard form</h2>
			<p>The wizard form<a id="_idIndexMarker691"/> views are defined in the same way as they are for regular models, except for two specific elements:</p>
			<ul>
				<li>A <code>&lt;footer&gt;</code> section can be used to replace the action buttons.</li>
				<li>A <code>special="cancel"</code> button is available to interrupt the wizard without performing any action.</li>
			</ul>
			<p>The following is the content of the <code>wizard/checkout_mass_message_wizard_view.xml</code> file:</p>
			<pre>&lt;odoo&gt;
  &lt;record id="view_form_checkout_message" 
    model="ir.ui.view"&gt;
    &lt;field name="name"&gt;Library Checkout Mass Message 
      Wizard&lt;/field&gt;
    &lt;field name="model"&gt;
      library.checkout.massmessage&lt;/field&gt;
    &lt;field name="arch" type="xml"&gt;
      &lt;form&gt;
        &lt;group&gt;
          &lt;field name="message_subject" /&gt;
          &lt;field name="message_body" /&gt;
          &lt;field name="checkout_ids" /&gt;
        &lt;/group&gt;
        &lt;footer&gt;
          &lt;button type="object"
            name="button_send"
            string="Send Messages" /&gt;
          &lt;button special="cancel" 
            string="Cancel" 
            class="btn-secondary" /&gt;
        &lt;/footer&gt;
      &lt;/form&gt;
    &lt;/field&gt;
  &lt;/record&gt;
  &lt;record id="action_checkout_message"
          model="ir.actions.act_window"&gt;
    &lt;field name="name"&gt;Send Messages&lt;/field&gt;
    &lt;field name="res_model"&gt;
      library.checkout.massmessage&lt;/field&gt;
    &lt;field name="view_mode"&gt;form&lt;/field&gt;
    &lt;field name="binding_model_id"
           ref="model_library_checkout" /&gt;
    &lt;field name="binding_view_types"&gt;form,list&lt;/field&gt;
    &lt;field name="target"&gt;new&lt;/field&gt;
  &lt;/record&gt;
&lt;/odoo&gt;</pre>
			<p>The previous XML code adds two data records – one for the wizard form view and another for the action to open the wizard.</p>
			<p>The <code>ir.actions.act_window</code> window action record is made available in the <code>binding_model_id</code> field value.</p>
			<p>Remember to<a id="_idIndexMarker692"/> add this file to the manifest file:</p>
			<pre>  "data": [
    "security/ir.model.access.csv",
<strong class="bold">    "wizard/checkout_mass_message_wizard_view.xml",</strong>
    "views/library_menu.xml",
    "views/checkout_view.xml",
    "data/library_checkout_stage.xml",
  ],</pre>
			<p>The wizard form will look as follows:</p>
			<div><div><img src="img/Figure_8.5_B16119.jpg" alt="Figure 8.5 – The Send Messages wizard form&#13;&#10;" width="1179" height="547"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – The Send Messages wizard form</p>
			<p>To open the <a id="_idIndexMarker693"/>wizard, the user should select one or more records on the checkout list view and choose the <strong class="bold">Send Messages</strong> option via the <strong class="bold">Action</strong> menu, which is available at the top of the list view.</p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor257"/>The wizard business logic</h2>
			<p>At this point, the <a id="_idIndexMarker694"/>action opens the wizard form, but it is not capable of performing any operations on the records yet. To start with, we would like the wizard to present the list of records that were selected in the checkout list view.</p>
			<p>When the wizard form is opened, it displays an empty form. It is not a record yet; this will only happen when you click on a button that's calling a method.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When the wizard form is opened, we have an empty record. The <code>create()</code> method hasn't been invoked yet; this will only happen when we press a button. So, it can't be used to set the initial values to be presented in a wizard form.</p>
			<p>It is still possible to populate data on the empty form by setting default values on the fields. <code>default_get()</code> is an ORM API method that's in charge of computing the default values for a record. It can be extended to add custom logic, like so:</p>
			<pre>    @api.model
    def default_get(self, field_names):
        defaults_dict = super().default_get(field_names)
        # Add values to the defaults_dict here
        return defaults_dict</pre>
			<p>The preceding method function can be used to add the default value for the <code>checkout_ids</code> field. But we still need to know how to access the list of records that will be selected in the origin list view.</p>
			<p>When you're <a id="_idIndexMarker695"/>navigating from a client window to the next, the web client stores some data about the origin view in the environment's <code>context</code>. This data is as follows:</p>
			<ul>
				<li><code>Active_model</code>, which is the technical name of the model</li>
				<li><code>Active_id</code>, which is the ID of the form active record or the tree view's first record, if you're navigating from a list</li>
				<li><code>active_ids</code>, which is a list that contains the selected records or just one element if you're navigating from a form</li>
				<li><code>active_domain</code>, if the action is triggered from a form view</li>
			</ul>
			<p>In this case, <code>active_ids</code> can be used to get the record IDs that have been selected in the list view and set the default value on the <code>checkout_ids</code> field. This is what the <code>default_get</code> method looks like:</p>
			<pre>    @api.model
    def default_get(self, field_names):
        defaults_dict = super().default_get(field_names)
<strong class="bold">        checkout_ids = self.env.context["active_ids"]</strong>
<strong class="bold">        defaults_dict["checkout_ids"] = checkout_ids</strong>
        return defaults_dict</pre>
			<p>First, <code>super()</code> is used to call the framework's <code>default_get()</code> implementation, which returns a dictionary containing default values. Then, the <code>checkout_id</code> key is added to <code>defaults_dict</code>, with the <code>active_ids</code> value read from the environment's context.</p>
			<p>With this, when the <a id="_idIndexMarker696"/>wizard form is opened, the <code>checkout_ids</code> field will be automatically populated with the records that have been selected. Next, the logic for the form's <strong class="bold">Send Messages</strong> button needs to be implemented.</p>
			<p>Upon inspecting the form XML code, we can see that <code>button_send</code> is the name of the function that's called by the button. It should be defined in the <code>wizard/checkout_mass_message.py</code> file, as shown in the following code:</p>
			<pre>    def button_send(self):
        self.ensure_one()
        for checkout in self.checkout_ids:
            checkout.message_post(
                body=self.message_body,
                subject=self.message_subject,
                subtype='mail.mt_comment',
            )
        return True</pre>
			<p>The method is designed to work with a single record and would not work correctly if <code>self</code> was a recordset instead of a singleton. To make this explicit, <code>self.ensure_one()</code> is being used.</p>
			<p>Here, <code>self</code> represents the wizard record data, which was created when the button was pressed. It contains the data that was entered on the wizard form. Validation is performed to ensure a message body text is provided by the user.</p>
			<p>The <code>checkout_id</code> field is accessed, and a loop iterates through each of its records. For each checkout record, a message is posted using the <code>mail.thread</code> API. The <code>mail.mt_comment</code> subtype must be used for a notification email to be sent to the record followers. The message's <code>body</code> and <code>subject</code> are taken from the <code>self</code> record fields.</p>
			<p>It is good <a id="_idIndexMarker697"/>practice for methods to always return something – the <code>True</code> value at the very least. The sole reason for this is that some XML-RPC clients don't support <code>None</code> values. When a Python function has no explicit <code>return</code>, it implicitly returns the <code>None</code> value. In practice, you may not be aware of the issue because the web client uses JSON-RPC, not XML-RPC, but it is still a good practice to follow.</p>
			<p>Wizards are the most complex tools in our business logic toolbox and close out the list of techniques that will be presented in this chapter.</p>
			<p>Business logic also involves testing if the right conditions are being met before or after running some operation. The next section explains how to trigger exceptions when this doesn't happen.</p>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor258"/>Raising exceptions</h1>
			<p>There are times where the <a id="_idIndexMarker698"/>inputs are inappropriate for the task to perform, and the code needs to warn the user about it and interrupt the program's execution with an error message. This is done by raising an exception. Odoo provides exception classes that should be used in these situations.</p>
			<p>The most useful Odoo exceptions are as follows:</p>
			<pre>from odoo import exceptions
raise exceptions.ValidationError("Inconsistent data")
raise exceptions.UserError("Wrong input")</pre>
			<p>The <code>ValidationError</code> exception should be used for validations in Python code, such as the ones in <code>@api.constrains</code> decorated methods.</p>
			<p>The <code>UserError</code> exception should be used in all other cases where some action should not be allowed because it goes against business logic.</p>
			<p>As a general rule, all data manipulation that's done during method execution is done in a database transaction and rolled back when an exception occurs. This means that, when an exception is raised, all of the previous data changes are canceled.</p>
			<p>Let's look at an example of using the wizard's <code>button_send</code> method. If we think about it, it doesn't make any sense to run the send message's logic if no checkout document was selected. And it doesn't make sense to send messages with no message body. Let's warn the user if any of these things happen.</p>
			<p>To do so, edit the <code>button_send()</code> method<a id="_idIndexMarker699"/> and add the following highlighted code:</p>
			<pre>    def button_send(self):
        self.ensure_one()
<strong class="bold">        if not self.checkout_ids:</strong>
<strong class="bold">            raise exceptions.UserError(</strong>
<strong class="bold">                "No Checkouts were selected."</strong>
<strong class="bold">            )</strong>
<strong class="bold">        if not self.message_body:</strong>
<strong class="bold">            raise exceptions.UserError(</strong>
<strong class="bold">                "A message body is required"</strong>
<strong class="bold">            )</strong>
        for checkout in self.checkout_ids:
            checkout.message_post(
                body=self.message_body,
                subject=self.message_subject,
                subtype='mail.mt_comment',
            )
        return True</pre>
			<p>When you're using exceptions, make sure that the <code>from odoo import exceptions</code> instruction is added to the top of the code file. Adding validations is as simple as checking that <a id="_idIndexMarker700"/>some conditions have been met and raising an exception if they haven't been.</p>
			<p>The next section discusses the development tools that every Odoo developer should be familiar with. We will start with automated tests.</p>
			<h1 id="_idParaDest-255"><a id="_idTextAnchor259"/>Writing unit tests</h1>
			<p>Automated tests are generally accepted as a best practice in software. They not only help ensure code is correctly implemented, but more importantly, they provide a safety net for future code changes or rewrites.</p>
			<p>In the case of <a id="_idIndexMarker701"/>dynamic programming languages, such as Python, there is no compilation step and syntax errors can go unnoticed. Ensuring there's test code coverage is particularly important for detecting code writing mistakes, such as a mistyped identifier name.</p>
			<p>These two goals provide a guiding light to test writing. One goal should be test coverage – writing test cases that run all your lines of code.</p>
			<p>This alone will usually make good progress on the second goal, which is to verify the correctness of the code. This is because, after working on code coverage tests, we will surely have a<a id="_idIndexMarker702"/> great starting point to build additional test cases for non-trivial use cases.</p>
			<p class="callout-heading">Changes in Odoo 12</p>
			<p class="callout">In earlier Odoo versions, tests could also be described using YAML data files. With Odoo 12, the YAML data file engine was removed, and this type of file is not supported anymore. The last piece of documentation on it is available at https://doc.odoo.com/v6.0/contribute/15_guidelines/coding_guidelines_testing/.</p>
			<p>Next, we will learn how to add unit tests to a module and then run them.</p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor260"/>Adding unit tests</h2>
			<p>Add-on <a id="_idIndexMarker703"/>module tests must be added to a <code>tests/</code> subdirectory. The test runner will automatically discover tests in the subdirectories with this particular name, and the module's top <code>__init__.py</code> file should <em class="italic">not</em> import them.</p>
			<p>To add tests for the wizard logic that was created in the <code>library_checkout</code> add-on module, we will start by creating the <code>tests/__init__.py</code> file and importing the test files to be used. In this case, it should contain the following line of code:</p>
			<pre>from . import test_checkout_mass_message</pre>
			<p>Then, we must create the <code>tests/test_checkout_mass_message.py</code> file and ensure it has the<a id="_idIndexMarker704"/> basic skeleton for the unit test code:</p>
			<pre>from odoo import exceptions
from odoo.tests import common
class TestWizard(common.SingleTransactionCase):
    def setUp(self, *args, **kwargs):
        super(TestWizard, self).setUp(*args, **kwargs)
        # Add test setup code here... 
    def test_01_button_send(self):
        """Send button should create messages on
           Checkouts"""
        # Add test code</pre>
			<p>Odoo provides a few classes to use for tests, as follows:</p>
			<ul>
				<li><code>TransactionCase</code> uses a different transaction for each test, which is automatically rolled back at the end.</li>
				<li><code>SingleTransactionCase</code> runs all the tests in a single transaction, which are only rolled back at the end of the last test. This can speed up tests significantly, but the individual tests need to be written in such a way that they are compatible.</li>
			</ul>
			<p>These test classes are wrappers around the <code>unittest</code> test cases, which are part of the Python standard library. For more details on this, you can refer to the official documentation at https://docs.python.org/3/library/unittest.html.</p>
			<p>The <code>setUp()</code> method is where test data is prepared and is usually stored as class attributes so that it is available to the test methods.</p>
			<p>Tests are<a id="_idIndexMarker705"/> implemented as class methods, such as the <code>test_01_button_send()</code> example in the previous code. The test case method names must begin with the <code>test_</code> prefix. This is what allows them to be discovered by the test runner. Test methods are run in the order of the test function names.</p>
			<p>The <code>docstring</code> method is printed to the server log when the tests are run and should be used to provide a short description of the test that's being performed.</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor261"/>Running tests</h2>
			<p>Once the tests have been <a id="_idIndexMarker706"/>written, it is time to run them. For that, you must upgrade or install the modules to test (<code>-I</code> or <code>-u</code>) and add the–<code>-test-enable</code> option to the Odoo <code>server</code> command.</p>
			<p>The command will look like this:</p>
			<pre>(env15) $ odoo -c library.conf --test-enable -u library_checkout --stop-after-init</pre>
			<p>Only the installed or upgraded modules will be tested – that's why the <code>-u</code> option was used. If some dependencies need to be installed, their tests will run too. If you don't want this to happen, then install the new modules and then run the tests while upgrading (<code>-u</code>) the module to test.</p>
			<p>Although the<a id="_idIndexMarker707"/> module contains testing code, this code doesn't test anything yet and should run successfully. If we take a closer look at the server log, there should be <code>INFO</code> messages reporting the test runs, similar to this:</p>
			<pre>INFO library odoo.modules.module: odoo.addons.library_checkout.tests.test_checkout_mass_message running tests.</pre>
			<p>The test code skeleton is ready. Now, the actual testing code needs to be added. We should start with setting up the data.</p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor262"/>Setting up tests</h2>
			<p>The first step when <a id="_idIndexMarker708"/>writing tests is to prepare the data to use. This is typically done in the <code>setUp</code> method. For our example, a checkout record is needed so that it can be used in the wizard tests.</p>
			<p>It is convenient to perform the test actions as a specific user to also test that access control has been configured properly. This can be achieved using the <code>sudo(&lt;user&gt;)</code> model method. Recordsets carry that information with them, so after being created using <code>sudo()</code>, later operations in the same recordset will be performed using that same context.</p>
			<p>This is the code for the <code>setUp</code> method:</p>
			<pre>from odoo import exceptions
from odoo.tests import common
class TestWizard(common.SingleTransactionCase):
    def setUp(self, *args, **kwargs):
        super().setUp(*args, **kwargs)
        # Setup test data
        admin_user = self.env.ref('base.user_admin')
        self.Checkout = self.env['library.checkout']\
            .with_user(admin_user)
        self.Wizard = self.env[
          'library.checkout.massmessage']\
            .with_user(admin_user)
        a_member = self.env['library.member']\
            .create({'partner_id': 
               admin_user.partner_id.id})
        self.checkout0 = self.Checkout\
            .create({'member_id': a_member.id})</pre>
			<p>Now, we <a id="_idIndexMarker709"/>can use the <code>self.checkout0</code> record and the <code>self.Wizard</code> model for our tests.</p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor263"/>Writing test cases</h2>
			<p>Now, let's expand <a id="_idIndexMarker710"/>the <code>test_button_test()</code> method that we saw in the initial skeleton to implement the tests.</p>
			<p>A basic test runs some code on the tested object, gets a result, and then uses an <code>assert</code> statement to compare it with an expected result. The message posting logic does not return any value to check, so a different approach is needed.</p>
			<p>The <code>button_send()</code> method adds a message to the message history. One way to check if this happened is to count the number of messages before and after running the method. The test code can count the number of messages before and after the wizard. The following code adds this:</p>
			<pre>    def test_01_button_send(self):
        """Send button creates messages on Checkouts"""
        count_before = len(self.checkout0.message_ids)
        # TODO: run wizard
<strong class="bold">        count_after = len(self.checkout0.message_ids)</strong>
<strong class="bold">        self.assertEqual(</strong>
<strong class="bold">            count_before + 1,</strong>
<strong class="bold">            count_after,</strong>
<strong class="bold">            "Expected one additional message in the </strong>
<strong class="bold">             Checkout.",</strong>
<strong class="bold">        )</strong></pre>
			<p>The check for verifying whether the test succeeded or failed is the <code>self.assertEqual</code> statement. It compares the number of messages before and after running the wizard. It is expected to find one more message than it did previously. The last parameter provides an optional but recommended message that's printed when the test fails.</p>
			<p>The <code>assertEqual</code> function is just one of the assert methods that's available. The appropriate assert function should be selected for the check to perform. The <code>unittest</code> documentation provides a good reference for all of the methods. It can be found at https://docs.python.org/3/library/unittest.html#test-cases.</p>
			<p>Running the wizard is not straightforward, and the user interface workflow needs to be mimicked. Recall that the environment's context is used to pass data to the wizard, on the <code>active_ids</code> key. We must create a wizard record with the values that have been filled in the wizard <a id="_idIndexMarker711"/>form for the message subject and body and then run the <code>button_send</code> method.</p>
			<p>The complete code looks like this:</p>
			<pre>    def test_01_button_send(self):
        """Send button creates messages on Checkouts"""
        count_before = len(self.checkout0.message_ids)
        <strong class="bold">Wizard0 = self.Wizard\</strong>
<strong class="bold">            .with_context(active_ids=self.checkout0.ids)</strong>
<strong class="bold">        wizard0 = Wizard0.create({</strong>
<strong class="bold">            "message_subject": "Hello",</strong>
<strong class="bold">            "message_body": "This is a message.",</strong>
<strong class="bold">        })</strong>
<strong class="bold">        wizard0.button_send()</strong>
        count_after = len(self.checkout0.message_ids)
        self.assertEqual(
            count_before + 1,
            count_after,
            "Expected one additional message in the 
             Checkout.",
        )</pre>
			<p>The <code>with_context</code> model method is used to add <code>active_ids</code> to the environment's context. Then, the <code>create()</code> method is used to create the wizard record and add the user-entered data. Finally, the <code>button_send</code> method is called.</p>
			<p>More test cases are added with additional methods for the test class. Remember, with <code>TransactionCase</code> tests, a rollback is done at the end of each test and the operations that were <a id="_idIndexMarker712"/>performed in the previous test are reverted. With <code>SingleTransactionCase</code>, tests build each other up, and the test run sequence is important. Since tests are run in alphabetical order, the names that are chosen for the test methods are relevant. To make this clearer, it is a good practice to add a number at the beginning of the test method names, as we did in the preceding example.</p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor264"/>Testing exceptions</h2>
			<p>In some cases, the code is<a id="_idIndexMarker713"/> expected to raise an exception, and that should also be tested. For example, we can test whether validation is being performed correctly.</p>
			<p>Continuing with the wizard tests, validation is performed to check for an empty message body. A test can be added to check that this validation is done properly.</p>
			<p>To check whether an exception has been raised, the corresponding code must be placed inside a <code>with self.assertRaises()</code> code block.</p>
			<p>Another method should be added for this test, as follows:</p>
			<pre>    def test_02_button_send_empty_body(self):
        """Send button errors on empty body message"""
        Wizard0 = self.Wizard\
            .with_context(active_ids=self.checkout0.ids)
        wizard0 = Wizard0.create({})
        with self.assertRaises(exceptions.UserError) as e:
            wizard0.button_send()</pre>
			<p>If the <code>button_send()</code> method doesn't raise <code>UserException</code>, the test will fail. If it does raise that exception, the test will succeed. The exception that's raised is stored in the <code>e</code> variable, which<a id="_idIndexMarker714"/> could be inspected by additional method commands – for example, to verify the content of the error message.</p>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor265"/>Using log messages</h1>
			<p>Writing <a id="_idIndexMarker715"/>messages to the log file is useful for monitoring and auditing running systems. It can also help with code maintenance, making it easier to get debug information from running processes, without the need to change code.</p>
			<p>To use logging in Odoo code, first, a logger object must be prepared. For this, add the following code lines at the top of the <code>library_checkout/wizard/checkout_mass_message.py</code> file:</p>
			<pre>import logging
_logger = logging.getLogger(__name__)</pre>
			<p>The <code>logging</code> Python standard library module is being used here. The <code>_logger</code> object is initialized using the name of the current code file, <code>__name__</code>. With this, the log messages will include information about the file that generated them.</p>
			<p>There are several levels available for log messages. These are as follows:</p>
			<pre>_logger.debug('A DEBUG message') 
_logger.info('An INFO message') 
_logger.warning('A WARNING message') 
_logger.error('An ERROR message')</pre>
			<p>We can now use the logger to write messages to the Odoo server log.</p>
			<p>This log can be added to the <code>button_send</code> wizard method. Add the following instruction before the ending line; that is, <code>return True</code>:</p>
			<pre>        _logger.info(
            "Posted %d messages to the Checkouts: %s",
            len(self.checkout_ids),
            str(self.checkout_ids),
        )</pre>
			<p>With<a id="_idIndexMarker716"/> this code, when the wizard is used to send messages, a message similar to the following will be printed to the server log:</p>
			<pre>INFO library odoo.addons.library_checkout.wizard.checkout_mass_message: Posted 2 messages to the Checkouts: [3, 4]</pre>
			<p>Notice that Python string interpolation – that is, using the <code>%</code> operator – was not used in the log message. More specifically, instead of <code>_logger.info("Hello %s" % "World")</code>, what was used was something like <code>_logger.info("Hello %s", "World")</code>. Not using interpolation means one less task for the code to perform at runtime, which makes logging more efficient. So, the variables should always be provided as additional log parameters.</p>
			<p>The timestamps of server log messages always use UTC. This may come as a surprise and comes from the fact that the Odoo server internally handles all dates in UTC.</p>
			<p>For debug-level log messages, <code>_logger.debug()</code> is used. As an example, add the following debug log message right after the <code>checkout.message_post()</code> instruction:</p>
			<pre>            _logger.debug(
                "Message on %d to followers: %s",
                checkout.id,
                checkout.message_follower_ids)</pre>
			<p>By default, this won't print anything to the server log, since the default log level is <code>INFO</code>. The log level needs to be set to <code>DEBUG</code> for the debug messages to be printed to the log.</p>
			<p>The Odoo <code>--log-level</code> command option sets the general log level. For example, adding <code>--log-level=debug</code> to the command line enables all debug log messages.</p>
			<p>This can be fine-tuned and have a specific log level set only for particular modules. To enable debug messages only for this wizard code, use the <code>--log-handler</code> option. This can be used several times to set the log level for several modules.</p>
			<p>For example, the Python module for the wizard is <code>odoo.addons.library_checkout.wizard.checkout_mass_message</code>, as shown in the <code>INFO</code> log messages. To set a debug log level for it, use the following command-line option:</p>
			<pre>--log-handler=
odoo.addons.library_checkout.wizard.checkout_mass_message:DEBUG</pre>
			<p>The<a id="_idIndexMarker717"/> complete reference to the Odoo server logging options can be found in the official documentation: <a href="https://www.odoo.com/documentation/15.0/developer/misc/other/cmdline.html">https://www.odoo.com/documentation/15.0/developer/misc/other/cmdline.html</a>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you want to get into the nitty-gritty details of Python logging, the official documentation is a good place to start: <a href="https://docs.python.org/3/library/logging.html">https://docs.python.org/3/library/logging.html</a>.</p>
			<p>Logging is a useful tool, but it's short when it comes to debugging. There are a few tools and techniques that are available to help developers with their work. We'll look at these in the next section.</p>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor266"/>Learning about the available developer tools</h1>
			<p>There are a few tools to ease developers' work. The web interface's <strong class="bold">Developer Mode</strong>, which we introduced earlier in this book, is one of them. A server developer mode option is also available that provides some developer-friendly features. It will be explained in more detail next. After that, we will discuss how to debug code on the server.</p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor267"/>Server development options</h2>
			<p>The Odoo server provides a <code>--dev</code> option, which enables developer features to speed up the development cycle, such as the following:</p>
			<ul>
				<li>Entering the debugger<a id="_idIndexMarker718"/> when an exception is found in an add-on module. This is done by setting a debugger. <code>pdb</code> is the default one.</li>
				<li>Reloading Python code automatically when a Python code file is saved, avoiding a manual server restart. This can be enabled with the <code>reload</code> option.</li>
				<li>Reading view definitions directly from XML files, avoiding manual module upgrades. This can be enabled with the <code>xml</code> option.</li>
				<li>A Python debugging interface is used directly in the web browser. This can be enabled with the <code>werkzeug</code> option.</li>
			</ul>
			<p>The <code>--dev</code> option accepts a comma-separated list of options. The <code>all</code> option can be used to conveniently enable all of these options using <code>--dev=all</code>.</p>
			<p>When you're enabling a debugger, the Odoo server will use <code>pdb</code> by default, but other options can be used if they've been installed in your system. The supported alternatives are as follows:</p>
			<ul>
				<li><code>ipdb</code>; see <a href="https://pypi.org/project/ipdb">https://pypi.org/project/ipdb</a> for <a id="_idIndexMarker719"/>details.</li>
				<li><code>pudb</code>; see <a href="https://pypi.org/project/pudb">https://pypi.org/project/pudb</a> for <a id="_idIndexMarker720"/>details.</li>
				<li><code>wdb</code>; see <a href="https://pypi.org/project/wdb">https://pypi.org/project/wdb</a> for <a id="_idIndexMarker721"/>details.</li>
			</ul>
			<p>When you're editing Python code, the server needs to be restarted every time the code is changed so that the latest code is reloaded and used by Odoo. The <code>--dev=reload</code> option automates this reloading. When enabled, the Odoo server detects changes that have been made to code files and automatically triggers code reloading, making the code changes effective immediately.</p>
			<p>For the code reload to work, the <code>watchdog</code> Python package is required. It can be installed with the<a id="_idIndexMarker722"/> following command:</p>
			<pre>(env15) $ pip3 install watchdog</pre>
			<p>The <code>--dev=all</code> server command option also enables <code>reload</code>, and it is what is used most of the time:</p>
			<pre>(env15) $ odoo -c library.conf --dev=all</pre>
			<p>Note that this is only useful for Python code changes. For other changes, such as changing the model's data structure, a module upgrade is needed; reloading it is not enough.</p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor268"/>Debugging</h2>
			<p>A big part of a developer's work is debugging code. For this, it is convenient to be able to set breakpoints and run the code step by step.</p>
			<p>Odoo is a server<a id="_idIndexMarker723"/> that runs Python code that waits for client requests, which are processed by the relevant server code, and then returns a response to the client. This means that Python code debugging is done on the server side. Breakpoints are activated in the server, pausing the server's execution on that line of code. So, the developer needs access to the terminal window running the server both to set breakpoints and to operate the debugger when those breakpoints are triggered.</p>
			<h3>The Python debugger</h3>
			<p>The simplest debugging tool that's available is the <a id="_idIndexMarker724"/>Python integrated debugger, <code>pdb</code>. However, other <a id="_idIndexMarker725"/>options are available that provide a richer user interface, closer to what sophisticated IDEs usually provide.</p>
			<p>There are two ways a debugger prompt can be triggered.</p>
			<p>One is when an unhandled exception is raised and the <code>--dev=all</code> option is enabled. The debugger will stop the code's execution at the instruction causing the exception. The developer can then inspect the variables and program state at that moment, to gain a better understanding of what is causing it.</p>
			<p>The other way is to manually set a breakpoint by editing the code and adding the following line where the execution should pause:</p>
			<pre>import pdb; pdb.set_trace()</pre>
			<p>This does not require the <code>–dev</code> mode to be enabled. An Odoo server reload is needed for the changed code to be used. When the program execution reaches the <code>pdb.set_trace()</code> command, a <code>(pdb)</code> Python prompt will be shown in the server's terminal window, waiting for input.</p>
			<p>The <code>(pdb)</code> prompt<a id="_idIndexMarker726"/> works as a Python shell and can run any expression or <a id="_idIndexMarker727"/>command in the current execution context. This means that the current variables can be inspected and even modified.</p>
			<p>A few debugger-specific commands are also available. These are the most important commands that are available:</p>
			<ul>
				<li><code>h</code> (help) displays a summary of the available <code>pdb</code> commands.</li>
				<li><code>p</code> (print) evaluates and prints an expression.</li>
				<li><code>pp</code> (pretty-print) is useful to print data structures, such as dictionaries or lists.</li>
				<li><code>l</code> (list) lists the code around the instruction to be executed next.</li>
				<li><code>n</code> (next) steps over to the next instruction.</li>
				<li><code>s</code> (step) steps into the current instruction.</li>
				<li><code>c</code> (continue) continues execution normally.</li>
				<li><code>u</code> (up) moves up in the execution stack.</li>
				<li><code>d</code> (down) moves down in the execution stack.</li>
				<li><code>bt</code> (backtrace) shows the current execution stack.</li>
			</ul>
			<p>The Python official documentation includes a complete description of the <code>pdb</code> commands: <a href="https://docs.python.org/3/library/pdb.html#debugger-commands">https://docs.python.org/3/library/pdb.html#debugger-commands</a>.</p>
			<h3>A sample debugging session</h3>
			<p>To understand how to use the debugger's features, let's see what a<a id="_idIndexMarker728"/> debugging session looks like.</p>
			<p>Start by adding a debugger breakpoint to the first line of the <code>button_send()</code> wizard method, as follows:</p>
			<pre>    def button_send(self):
<strong class="bold">        import pdb; pdb.set_trace()</strong>
        self.ensure_one()
        # ...</pre>
			<p>After performing a server reload, open the <code>button_send()</code> method on the server, which will pause at the breakpoint. The web client will stay in a <strong class="bold">Loading…</strong> state while it is waiting for the server's response.</p>
			<p>At that point, the terminal window where the server is running should display something similar to this:</p>
			<pre>&gt; /home/daniel/work15/library/library_checkout/wizard
/checkout_mass_message.py(29)button_send()
-&gt; self.ensure_one()
(Pdb)</pre>
			<p>This is the <code>pdb</code> debugger<a id="_idIndexMarker729"/> prompt, and the two previous lines provide information about where the Python code execution was paused. The first line shows the file, line number, and function name, while the second line is the code in that line that will be run next.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">During a debug session, server log messages can creep in. Most of these are from the <code>werkzeug</code> module. They can be silenced by adding the <code>--log-handler=werkzeug:WARNING</code> option to the Odoo command. Another option is to lower the general log verbosity using <code>--log-level=warn</code>.</p>
			<p>Typing <code>h</code> shows a quick reference of the available commands. Typing <code>l</code> shows the current line of code and the surrounding lines of code.</p>
			<p>Typing <code>n</code> runs the current line of code and moves to the next one. Pressing <em class="italic">Enter</em> repeats the previous command.</p>
			<p>The <code>p</code> debug command prints out the result of an expression, while <code>pp</code> does the same but formats the output to be more readable, especially the <code>dict</code> and <code>list</code> data structures. For example, to print the value for the <code>checkout_ids</code> field that's used in the wizard, type the following:</p>
			<pre>(pdb) self.checkout_ids
library.checkout(1,)
(Pdb)</pre>
			<p>The debug prompt can run Python commands and expressions. Any Python expressions are allowed, even variable assignments.</p>
			<p>When you're done with a <a id="_idIndexMarker730"/>debugging session, type <code>c</code> to continue the normal program execution. In some cases, you may want to interrupt the execution, and <code>q</code> can be used to quit.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">When you go back from the debugger to the terminal prompt, the terminal may look unresponsive, and any typed text won't be printed to the terminal. This can be solved by using the <code>reset</code> command; that is, by typing <code>&lt;enter&gt;reset&lt;enter&gt;</code>.</p>
			<h3>Alternative Python debuggers</h3>
			<p>While <code>pdb</code> has the advantage of being available out of the box, it can be quite terse. Fortunately, a few more comfortable options exist.</p>
			<p>The IronPython debugger, <code>ipdb</code>, is a<a id="_idIndexMarker731"/> popular choice that uses the same commands as <code>pdb</code> but adds improvements such as tab completion and syntax highlighting for more comfortable usage. It can be installed with the following command:</p>
			<pre>$ pip3 install ipdb</pre>
			<p>To add a breakpoint, use the following command:</p>
			<pre>import ipdb; ipdb.set_trace()</pre>
			<p>Another alternative debugger is <code>pudb</code>. It also <a id="_idIndexMarker732"/>supports the same commands as <code>pdb</code> and works in text terminals, but it uses a window-like graphical display. Useful information, such as the variables in the current context and their values, is readily available on the screen in separate windows.</p>
			<p>It can be installed either through the system package manager or through <code>pip</code>, as shown here:</p>
			<pre>$ sudo apt-get install python-pudb  # using Debian OS packages
$ pip3 install pudb  # or using pip, possibly in a virtualenv</pre>
			<p>A breakpoint can be added in a way similar to <code>pdb</code>:</p>
			<pre>import pudb; pudb.set_trace()</pre>
			<p>A short version is also available:</p>
			<pre>import pudb; pu.db</pre>
			<p>The preceding code can be typed faster and also provides the intended effect – to add a code execution breakpoint.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Since Python 3.7, breakpoints can be simplified by using the <code>breakpoint()</code> function instead of <code>pdb.set_trace()</code>. Debugging libraries can overwrite the <code>breakpoint()</code> behavior to directly call them. However, at the time of writing, <code>pudb</code> and <code>ipdb</code> aren't doing this, so there is no benefit to using <code>breakpoint()</code> with them.</p>
			<h3>Printing messages and logging</h3>
			<p>Sometimes, we just need to<a id="_idIndexMarker733"/> inspect the values of some variables or check whether some code blocks are being executed. A Python <code>print()</code> instruction can do the job perfectly without stopping the flow of execution. Note that the printed text is sent to the standard output and won't be stored in the server log if it is being written to a file.</p>
			<p>The <code>print()</code> function<a id="_idIndexMarker734"/> is only being used as a development aid and should not make its way to the final code, ready to be deployed. If the <code>print</code> statements can also help investigate issues in a production system, consider converting them into debug-level log <a id="_idIndexMarker735"/>messages.</p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor269"/>Inspecting and killing running processes</h2>
			<p>There are also a few tricks <a id="_idIndexMarker736"/>that allow us to inspect running Odoo processes.</p>
			<p>First, find the server instance's <strong class="bold">process ID</strong> (<strong class="bold">PID</strong>). This number is printed with each log message, right after the timestamp. Another way to find the PID is to run the following command in another terminal window:</p>
			<pre>$ ps ax | grep odoo</pre>
			<p>Here is a sample output:</p>
			<pre> 2650 pts/5  S+   0:00 grep --color=auto odoo
21688 pts/4  Sl+  0:05 python3 /home/daniel/work15/env15/bin/odoo</pre>
			<p>The first column in the output is the PID of the processes. In this example, <code>21688</code> is the Odoo process PID.</p>
			<p>Now that we know the process PID, signals can be sent to that Odoo server process. The <code>kill</code> command is used to<a id="_idIndexMarker737"/> send these signals. By default, <code>kill</code> sends a signal to terminate a process, but it can also send other, friendlier signals.</p>
			<p>The Odoo server will print out the stack trace at the code currently being executed if it's sent a <code>SIGQUIT</code> or <code>-3</code> signal:</p>
			<pre>$ kill -3 &lt;PID&gt;</pre>
			<p>After sending <code>SIGQUIT</code>, the Odoo server log will display a stack trace. This can be useful for understanding what code was being executed at that point. This information is printed for each of the threads being used.</p>
			<p>It is used by some code profiling approaches to track where the server is spending time and profile the code's execution. Some useful information on code profiling is given in the official documentation at <a href="https://www.odoo.com/documentation/15.0/howtos/profilecode.html">https://www.odoo.com/documentation/15.0/howtos/profilecode.html</a>.</p>
			<p>Other signals we can send to the Odoo server process include <code>HUP</code>, to reload the server, and <code>INT</code> or <code>TERM</code> to force the server to shut down, as follows:</p>
			<pre>$ kill -HUP &lt;PID&gt;
$ kill -TERM &lt;PID&gt;</pre>
			<p>The HUP signal can be particularly useful for reloading the Odoo configuration without stopping the server.</p>
			<h1 id="_idParaDest-266"><a id="_idTextAnchor270"/>Summary</h1>
			<p>In this chapter, we explored the various features of the ORM API and how to use them to create dynamic applications that react to users, which helps them avoid errors and automate tedious tasks.</p>
			<p>The model validations and computed fields can cover a lot of use cases, but not all. We learned how to extend the API's create, write, and unlink methods to cover further use cases.</p>
			<p>For rich user interaction, we used the <code>mail</code> core add-on mixins to add features for users to communicate about documents and plan activities on them. Wizards allow the application to dialogue with the user and gather the data that's needed to run particular processes. Exceptions allow the application to abort incorrect operations, informing the user of the problem and rolling back intermediate changes, keeping the system consistent.</p>
			<p>We also discussed the tools that are available for developers to create and maintain their applications: logging messages, debugging tools, and unit tests.</p>
			<p>In the next chapter, we will still be working with the ORM, but we will be looking at this from the point of view of an external application: we will be working with the Odoo server as a backend for storing data and running business processes.</p>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor271"/>Further reading</h1>
			<p>The following are the most relevant reference materials for the topics that were discussed in this chapter:</p>
			<ul>
				<li>ORM reference: <a href="https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html">https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html</a></li>
				<li>Message and activities features: <a href="https://www.odoo.com/documentation/15.0/developer/reference/backend/mixins.html">https://www.odoo.com/documentation/15.0/developer/reference/backend/mixins.html</a></li>
				<li>Odoo tests reference: <a href="https://www.odoo.com/documentation/15.0/developer/reference/backend/testing.html">https://www.odoo.com/documentation/15.0/developer/reference/backend/testing.html</a></li>
				<li>Python <code>unittest</code> reference: <a href="https://docs.python.org/3/library/unittest.html#module-unittest">https://docs.python.org/3/library/unittest.html#module-unittest</a></li>
			</ul>
		</div>
	</div></body></html>