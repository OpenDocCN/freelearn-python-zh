<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer064">
			<h1 id="_idParaDest-223"><em class="italic"><a id="_idTextAnchor227"/></em><a href="B16119_08_Final_PD_ePub.xhtml#_idTextAnchor227"><em class="italic">Chapter 8</em></a>: Business Logic – Supporting Business Processes</h1>
			<p>In the previous chapters, we learned how to use models to build the application data structures, and then how to explore and interact with that data using the ORM API and recordsets.</p>
			<p>In this chapter, we will put all this together to implement business logic patterns that are common in applications. We will learn about the several ways business logic can be triggered, as well as some common patterns that are used to support them. We will also learn about important development techniques, such as logging, debugging, and testing.</p>
			<p>We'll cover the following topics in this chapter:</p>
			<ul>
				<li>Learning project – the book checkout module</li>
				<li>Ways to trigger business logic</li>
				<li>Understanding ORM method decorators for recordsets</li>
				<li>Exploring useful data model patterns</li>
				<li>Using the ORM built-in methods</li>
				<li>Adding onchange user interface logic</li>
				<li>The message and activity features</li>
				<li>Creating a wizard</li>
				<li>Raising exceptions</li>
				<li>Writing unit tests</li>
				<li>Using log messages</li>
				<li>Learning about the available developer tools</li>
			</ul>
			<p>By the end of this chapter, you should be confident in designing and implementing business logic automation and know how to test and debug your code.</p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor228"/>Technical requirements</h1>
			<p>In this chapter, we will create a new <strong class="source-inline">library_checkout</strong> add-on module. It depends on the <strong class="source-inline">library_app</strong> and <strong class="source-inline">library_member</strong> add-on modules, which we created in the previous chapters.</p>
			<p>The code for these add-on modules can be found in this book's GitHub repository, at <a href="https://github.com/PacktPublishing/Odoo-15-Development-Essentials-Fifth-Edition">https://github.com/PacktPublishing/Odoo-15-Development-Essentials-Fifth-Edition</a>, in the <strong class="source-inline">ch08</strong> directory.</p>
			<p>Both of these add-on modules need to be available in the Odoo add-ons path so that they can be installed and used.</p>
			<h1 id="_idParaDest-225"><a id="_idTextAnchor229"/>Learning project – the book checkout module</h1>
			<p>The master data<a id="_idIndexMarker589"/> structures for the library application are in place. Now, we want to add transactions to our system. We would like library members to be able to borrow books. This means we should keep track of book availability and returns.</p>
			<p>Each book checkout has a life cycle, from the moment they are created to the moment when the books are returned. It is a simple workflow that can be represented as a Kanban board, where the several stages are presented as columns, and the work items from the left-hand column are sent to the right until they are completed.</p>
			<p>This chapter focuses on the data model and business logic that are needed to support this feature.</p>
			<p>The basic user interface will be discussed in <a href="B16119_10_Final_PD_ePub.xhtml#_idTextAnchor287"><em class="italic">Chapter 10</em></a>, <em class="italic">Backend Views – Designing the User Interface</em>, while the Kanban views will be discussed in <a href="B16119_11_Final_PD_ePub.xhtml#_idTextAnchor324"><em class="italic">Chapter 11</em></a>, <em class="italic">Kanban Views and Client-Side QWeb</em>. Let's quickly have a rundown of the data model.</p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor230"/>Preparing the data model</h2>
			<p>The first thing we must do is plan the <a id="_idIndexMarker590"/>data model that's needed for the book checkout feature.</p>
			<p>The <strong class="bold">book checkout</strong> model should have the following fields:</p>
			<ul>
				<li><strong class="bold">Library member</strong> borrowing books (required)</li>
				<li><strong class="bold">Checkout date</strong> (defaults to today)</li>
				<li><strong class="bold">Responsible person</strong> for the checkout (defaults to the current user)</li>
				<li><strong class="bold">Checkout lines</strong>, with the books requested (one or more)</li>
			</ul>
			<p>To support the book checkout life cycle, we will also have the following:</p>
			<ul>
				<li><strong class="bold">Stage</strong> of the request—draft, open, borrowed, returned, or canceled</li>
				<li><strong class="bold">Due date</strong>, when the books are due to be returned</li>
				<li><strong class="bold">Returned date</strong>, when the books were returned</li>
			</ul>
			<p>We will start by<a id="_idIndexMarker591"/> creating the new <strong class="source-inline">library_checkout</strong> module and implementing an initial version of the library checkout model. This will not introduce anything new compared to the previous chapters but will provide the foundation to build the features that are relevant for this chapter.</p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor231"/>Creating the module</h2>
			<p>The <strong class="source-inline">library_checkout</strong> module <a id="_idIndexMarker592"/>needs to be created, similar to what we did in the previous chapters. Follow these steps to do this:</p>
			<ol>
				<li>Create a new <strong class="source-inline">library_checkout</strong> directory in the same directory as the other add-on modules of the library project. This is where the following files should be added.</li>
				<li>Add the <strong class="source-inline">__manifest__.py</strong>  file and ensure it has the following content:<p class="source-code">{ "name": "Library Book Checkout",</p><p class="source-code">  "description": "Members can borrow books from the </p><p class="source-code">    library.",</p><p class="source-code">  "author": "Daniel Reis",</p><p class="source-code">  "depends": ["library_member"],</p><p class="source-code">  "data": [</p><p class="source-code">    "security/ir.model.access.csv",</p><p class="source-code">    "views/library_menu.xml",</p><p class="source-code">    "views/checkout_view.xml",</p><p class="source-code">  ],</p><p class="source-code">}</p></li>
				<li>Add the main <strong class="source-inline">__init__.py</strong> file with the following line of code:<p class="source-code">from . import models</p></li>
				<li>Add the <strong class="source-inline">models/__init__.py</strong> file with the following line of code:<p class="source-code">from . import library_checkout</p></li>
				<li>Add the model <a id="_idIndexMarker593"/>definition file, <strong class="source-inline">models/library_checkout.py</strong>, as follows:<p class="source-code">from odoo import fields, models</p><p class="source-code">class Checkout(models.Model):</p><p class="source-code">    _name = "library.checkout"</p><p class="source-code">    _description = "Checkout Request"</p><p class="source-code">    member_id = fields.Many2one(</p><p class="source-code">        "library.member",</p><p class="source-code">        required=True,</p><p class="source-code">    )</p><p class="source-code">    user_id = fields.Many2one(</p><p class="source-code">        "res.users",</p><p class="source-code">        "Librarian",</p><p class="source-code">        default=lambda s: s.env.user,</p><p class="source-code">    )</p><p class="source-code">    request_date = fields.Date(</p><p class="source-code">        default=lambda s: fields.Date.today(),</p><p class="source-code">    )</p></li>
			</ol>
			<p>Next, we should add the data files, including the access rule, the menu items, and some basic views so that the module can be used.</p>
			<ol>
				<li value="1">Add the access security configuration to the <strong class="source-inline">security/ir.model.access.</strong><strong class="source-inline">csv</strong> file:<p class="source-code">id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink</p><p class="source-code">checkout_user,Checkout User,model_library_checkout,library_app.library_group_user,1,1,1,1</p></li>
				<li>Next, the <strong class="source-inline">views/library_menu.xml</strong> file needs to be added for implementing<a id="_idIndexMarker594"/> the menu items:<p class="source-code">&lt;odoo&gt;</p><p class="source-code">  &lt;record id="action_library_checkout" </p><p class="source-code">          model="ir.actions.act_window"&gt;</p><p class="source-code">    &lt;field name="name"&gt;Checkouts&lt;/field&gt;</p><p class="source-code">    &lt;field name="res_model"&gt;library.checkout&lt;/field&gt;</p><p class="source-code">    &lt;field name="view_mode"&gt;tree,form&lt;/field&gt;</p><p class="source-code">  &lt;/record&gt;</p><p class="source-code">  &lt;menuitem id="menu_library_checkout"</p><p class="source-code">            name="Checkout"</p><p class="source-code">            action="action_library_checkout"</p><p class="source-code">            parent="library_app.menu_library"</p><p class="source-code">  /&gt;</p><p class="source-code">&lt;/odoo&gt;</p></li>
				<li>The views are<a id="_idIndexMarker595"/> implemented in the <strong class="source-inline">views/checkout_view.xml</strong> file:<p class="source-code">&lt;odoo&gt;</p><p class="source-code">  &lt;record id="view_tree_checkout" model="ir.ui.view"&gt;</p><p class="source-code">    &lt;field name="name"&gt;Checkout Tree&lt;/field&gt;</p><p class="source-code">    &lt;field name="model"&gt;library.checkout&lt;/field&gt;</p><p class="source-code">    &lt;field name="arch" type="xml"&gt;</p><p class="source-code">        &lt;tree&gt;</p><p class="source-code">            &lt;field name="request_date" /&gt;</p><p class="source-code">            &lt;field name="member_id" /&gt;</p><p class="source-code">        &lt;/tree&gt;</p><p class="source-code">    &lt;/field&gt;</p><p class="source-code">  &lt;/record&gt;</p><p class="source-code">  &lt;record id="view_form_checkout" model="ir.ui.view"&gt;</p><p class="source-code">    &lt;field name="name"&gt;Checkout Form&lt;/field&gt;</p><p class="source-code">    &lt;field name="model"&gt;library.checkout&lt;/field&gt;</p><p class="source-code">    &lt;field name="arch" type="xml"&gt;</p><p class="source-code">      &lt;form&gt;</p><p class="source-code">        &lt;sheet&gt;</p><p class="source-code">          &lt;group&gt;</p><p class="source-code">            &lt;field name="member_id" /&gt;</p><p class="source-code">            &lt;field name="request_date" /&gt;</p><p class="source-code">            &lt;field name="user_id" /&gt;</p><p class="source-code">          &lt;/group&gt;</p><p class="source-code">        &lt;/sheet&gt;</p><p class="source-code">      &lt;/form&gt;</p><p class="source-code">    &lt;/field&gt;</p><p class="source-code">  &lt;/record&gt;</p><p class="source-code">&lt;/odoo&gt;</p></li>
			</ol>
			<p>Now that the<a id="_idIndexMarker596"/> module contains the preceding files, it can be installed in our development database:</p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="Images/Figure_8.1_B16119.jpg" alt="Figure 8.1 – The initial Library Checkout feature&#13;&#10;" width="1078" height="280"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – The initial Library Checkout feature</p>
			<p>Now, we can start adding more interesting features.</p>
			<p>Throughout this project, we will be adding pieces of business logic to different places to showcase the several possibilities that Odoo provides. The next section will discuss these options.</p>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor232"/>Exploring ways to trigger business logic</h1>
			<p>Once the data model is in place, business logic is needed to perform some automatic actions on it. Business logic can either be directly initiated by the user, with an action such as a button click, or it can be triggered automatically when an event occurs, such as a write on a record.</p>
			<p>Much of this <a id="_idIndexMarker597"/>business logic will involve reading and writing on recordsets. The details and techniques for this were discussed in <a href="B16119_07_Final_PD_ePub.xhtml#_idTextAnchor194"><em class="italic">Chapter 7</em></a>, <em class="italic">Recordsets – Working with Model Data</em>, where we provided the tools for the actual business logic implementation.</p>
			<p>The next question is how the business logic should be triggered. This will depend on when and why the business logic should be triggered. Here is a summary of the several options.</p>
			<p>Some business logic is tightly connected to the model field definitions. Some of the instances of <strong class="bold">model definition-related business logic</strong> are as follows:</p>
			<ul>
				<li><strong class="bold">Data validation rules</strong>, to <a id="_idIndexMarker598"/>enforce conditions that the data should meet. These are methods that are decorated with <strong class="source-inline">@api.constrains</strong>.</li>
				<li><strong class="bold">Automatic computations</strong>, which are implemented as fields – virtual or stored – that<a id="_idIndexMarker599"/> have their values computed by a method. These are methods that are decorated with <strong class="source-inline">@api.depends</strong> and assigned to the <strong class="source-inline">compute</strong> field attribute.</li>
				<li><strong class="bold">Default values</strong>, which <a id="_idIndexMarker600"/>can be dynamically computed, are methods that are decorated with <strong class="source-inline">@api.model</strong> and assigned to the <strong class="source-inline">default</strong> field attribute.</li>
			</ul>
			<p>This model definition logic was discussed in detail in <a href="B16119_06_Final_PD_ePub.xhtml#_idTextAnchor164"><em class="italic">Chapter 6</em></a>, <em class="italic">Models – Structuring the Application Data</em>. Some examples can be found in the <em class="italic">Data model patterns</em> section. The <em class="italic">ORM method decorators for recordsets</em> section provides a recap of the several ORM decorators mentioned here.</p>
			<p>We also have <strong class="bold">model event-related business logic</strong>, which<a id="_idIndexMarker601"/> is related to business workflows. It can be attached to the following record-related events:</p>
			<ul>
				<li><strong class="bold">Create, write, and unlink</strong> business logic can be added to these events, for the cases where the other, more elegant approaches are not possible.</li>
				<li><strong class="bold">Onchange</strong> logic can be applied to user interface views so that we have some field values that are changed as a consequence of changes being made to other fields.</li>
			</ul>
			<p>For actions that are directly initiated by the user, the following options are available:</p>
			<ul>
				<li>A <strong class="source-inline">button</strong> view element for calling an object method. The button can be on a form or tree of the Kanban view.</li>
				<li>A <strong class="source-inline">server</strong> action, which is available from a menu item or in the <strong class="source-inline">Action</strong> context menu.</li>
				<li>A <strong class="source-inline">window</strong> action for opening a wizard form, where input can be collected from the user and a button will call the business logic. This allows for richer user interaction.</li>
			</ul>
			<p>These techniques will be presented throughout this chapter. The supporting methods will often use API decorators, so it is important to understand the different available ones. For clarity, the next section provides an overview of them.</p>
			<h1 id="_idParaDest-229"><a id="_idTextAnchor233"/>Understanding ORM method decorators for recordsets</h1>
			<p>The <a id="_idIndexMarker602"/>method definition can be preceded by an <strong class="source-inline">@</strong>, which applies a decorator to it. These decorators add specific behaviors for these methods and depending on the purpose of a method, different decorators can be used.</p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor234"/>Decorators for computed fields and validation methods</h2>
			<p>A few decorators are<a id="_idIndexMarker603"/> useful for validation logic and computed fields. They <a id="_idIndexMarker604"/>are listed here:</p>
			<ul>
				<li><strong class="source-inline">@api.depends(fld1,...)</strong> is used for computed field functions to identify what changes the (re)calculation should be triggered on. It must set values on the computed fields; otherwise, an error will be shown.</li>
				<li><strong class="source-inline">@api.constrains(fld1,...)</strong> is used for model validation functions and performs checks for when any of the mentioned fields are changed. It should not write changes in the data. If the checks fail, an exception should be raised.</li>
			</ul>
			<p>These were discussed in detail in <a href="B16119_06_Final_PD_ePub.xhtml#_idTextAnchor164"><em class="italic">Chapter 6</em></a>, <em class="italic">Models – Structuring the Application Data</em>.</p>
			<p>Another group of decorators affect the <strong class="source-inline">self</strong> recordset behavior and are relevant when you're implementing other kinds of business logic.</p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor235"/>Decorators that affect the self recordset</h2>
			<p>By default, methods are <a id="_idIndexMarker605"/>expected to act on a recordset that's provided by the self <strong class="source-inline">first</strong> argument. The method code will usually include a <strong class="source-inline">for</strong> statement that loops through each of the records in the <strong class="source-inline">self</strong> recordset.</p>
			<p class="callout-heading">Changes in Odoo 14</p>
			<p class="callout">The <strong class="source-inline">@api.multi</strong> decorator was removed from Odoo 14. In previous Odoo versions, it was used to explicitly signal that the decorated method expects a recordset in the <strong class="source-inline">self</strong> parameter. This is already the default behavior for methods, so its use is only for clarity. The <strong class="source-inline">@api.one</strong> decorator has been deprecated since Odoo 9 and was also removed in Odoo 14. It handled the record loop for you so that the method code would be called once for each record, and the <strong class="source-inline">self</strong> argument would always be a singleton. Since Odoo 14, both decorators must be removed from the code since they are not supported anymore.</p>
			<p>In some cases, the method is expected to work at the class level and not on particular records, behaving like a <strong class="bold">static method</strong>. These methods are decorated with <strong class="source-inline">@api.model</strong> and, in this case, the <strong class="source-inline">self</strong> method parameter should be used as a reference to the model; it is not expected to contain records.</p>
			<p>For example, the <strong class="source-inline">create()</strong> method uses <strong class="source-inline">@api.model</strong> – it does not expect records as input, only a<a id="_idIndexMarker606"/> values dictionary, which will be used to create and return a record. The methods that are used to calculate default values should also use the <strong class="source-inline">@api.model</strong> decorator.</p>
			<p>Before we can go deeper into the business logic's implementation, we must add more depth to the data model and, in the process, provide examples of a couple of common data model patterns.</p>
			<h1 id="_idParaDest-232"><a id="_idTextAnchor236"/>Exploring useful data model patterns</h1>
			<p>There are a few data <a id="_idIndexMarker607"/>structures that are often needed for models that represent business documents. These can be seen in several Odoo apps, such as <strong class="bold">Sales Orders</strong> or <strong class="bold">Invoices</strong>.</p>
			<p>A common pattern is the header/lines data structure. It will be used for a checkout request so that you can have several books. Another pattern is to use states or stages. These two have differences, and we will discuss them and provide a reference implementation shortly.</p>
			<p>Finally, the ORM API provides a few methods that are relevant for the user interface. These will also be discussed in this section.</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor237"/>Using header and lines models</h2>
			<p>A common need for<a id="_idIndexMarker608"/> form views is to have header-line data structures. For example, a sales order includes several lines for the ordered items. In the case of the checkout feature, a checkout request can have several request lines, one for each of the borrowed items.</p>
			<p>With Odoo, it is simple to implement this. Two models are needed for a header-line form view – one for the document header and another for the document lines. The line model has a many-to-one field to identify the header it belongs to, while the header model has a one-to-many <a id="_idIndexMarker609"/>field listing the lines in that document.</p>
			<p>The <strong class="source-inline">library_checkout</strong> module was already added to the checkout model, so now, we want to add the lines. Follow these steps to do so:</p>
			<ol>
				<li value="1">Edit the <strong class="source-inline">models/library_checkout.py</strong> file to add the one-to-many field for the checkout lines:<p class="source-code">    line_ids = fields.One2many(</p><p class="source-code">        "library.checkout.line",</p><p class="source-code">        "checkout_id",</p><p class="source-code">        string="Borrowed Books",</p><p class="source-code">    )</p></li>
				<li>Add the file for the<a id="_idIndexMarker610"/> new model to <strong class="source-inline">models/__init__.py</strong>, as <a id="_idIndexMarker611"/>follows:<p class="source-code">from . import library_checkout</p><p class="source-code"><strong class="bold">from . import library_checkout_line</strong></p></li>
				<li>Next, add the Python file for declaring the checkout lines model, <strong class="source-inline">models/library_checkout_line.py</strong>, with the following content:<p class="source-code">from odoo import api, exceptions, fields, models</p><p class="source-code">class CheckoutLine(models.Model):</p><p class="source-code">    _name = "library.checkout.line"</p><p class="source-code">    _description = "Checkout Request Line"</p><p class="source-code">    checkout_id = fields.Many2one(</p><p class="source-code">        "library.checkout",</p><p class="source-code">        required=True,</p><p class="source-code">    )</p><p class="source-code">    book_id = fields.Many2one("library.book", </p><p class="source-code">      required=True)</p><p class="source-code">    note = fields.Char("Notes")</p></li>
				<li>We must also add access <a id="_idIndexMarker612"/>security configuration. Edit the <strong class="source-inline">security/ir.model.access.csv</strong> file and add the following highlighted line:<p class="source-code">id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink</p><p class="source-code">checkout_user,Checkout User,model_library_checkout,library_app.library_group_user,1,1,1,1</p><p class="source-code"><strong class="bold">checkout_line_user,Checkout Line User,model_library_checkout,library_app.library_group_user,1,1,1,1</strong></p></li>
				<li>Next, we want<a id="_idIndexMarker613"/> to add the checkout lines to the form. We will be adding it as the first page of a notebook widget. Edit the <strong class="source-inline">views/checkout_view.xml</strong> file and, just before the <strong class="source-inline">&lt;/sheet&gt;</strong> element, add the following code:<p class="source-code">          &lt;notebook&gt;</p><p class="source-code">            &lt;page name="lines"&gt;</p><p class="source-code">              &lt;field name="line_ids"&gt;</p><p class="source-code">                &lt;tree editable="bottom"&gt;</p><p class="source-code">                  &lt;field name="book_id" /&gt;</p><p class="source-code">                  &lt;field name="note" /&gt;</p><p class="source-code">                &lt;/tree&gt;</p><p class="source-code">              &lt;/field&gt;</p><p class="source-code">            &lt;/page&gt;</p><p class="source-code">          &lt;/notebook&gt;</p></li>
			</ol>
			<p>The Checkouts form will look as follows:</p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="Images/Figure_8.2_B16119.jpg" alt="Figure 8.2 – The Checkouts form with the notebook widget&#13;&#10;" width="1169" height="542"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – The Checkouts form with the notebook widget</p>
			<p>The line's <a id="_idIndexMarker614"/>one-to-many field displays a list view that's nested in the parent form view. By <a id="_idIndexMarker615"/>default, Odoo will look up a list view definition to use for rendering, which is typical for any list view. If none are found, a default one will be automatically generated.</p>
			<p>It is also possible to declare specific views inside <strong class="source-inline">&lt;field&gt;</strong>. We did this in the preceding code. Inside the <strong class="source-inline">line_ids</strong> field element, there is a nested <strong class="source-inline">&lt;tree&gt;</strong> view definition that will be used for this form.</p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor238"/>Using stages and states for document-centered workflows</h2>
			<p>In Odoo, we can<a id="_idIndexMarker616"/> implement workflows that are<a id="_idIndexMarker617"/> centered on documents. What we<a id="_idIndexMarker618"/> refer to as documents can be things<a id="_idIndexMarker619"/> such as sales orders, project tasks, or HR applicants. All of these are expected to follow a certain life cycle since they're created until they conclude. Each work item is recorded in a document that will progress through a list of possible stages until it is completed.</p>
			<p>If we present these stages as columns in a board, and the documents as items in those columns, we get a Kanban board, providing a quick view of all the work in progress.</p>
			<p>There are two approaches to implementing these progress steps – <strong class="bold">states</strong> and <strong class="bold">stages</strong>:</p>
			<ul>
				<li><strong class="bold">States</strong> is a<a id="_idIndexMarker620"/> closed selection list of predefined options. This is convenient for implementing business rules since the possible states are fixed and known ahead of time. Models and views have special support for the <strong class="source-inline">state</strong> special field name, making it convenient to use. The closed states list is a disadvantage, in that it can't easily accommodate custom process steps.</li>
				<li><strong class="bold">Stages</strong> is a<a id="_idIndexMarker621"/> flexible list of process steps that are implemented through a related stages model that can be configured to process specific needs. It is usually implemented using a <strong class="source-inline">stage_id</strong> field name. The list of available stages is easy to modify as you can remove, add, or reorder them. It has the disadvantage of not being reliable for process automation. Since the list of stages can be changed, automation rules can't rely on particular stage IDs or descriptions.</li>
			</ul>
			<p>When we're <a id="_idIndexMarker622"/>designing the data model, we need <a id="_idIndexMarker623"/>to decide whether it should use stages or states. If triggering business logic is more important than the ability to configure the process steps, states should be preferred; otherwise, stages should be the preferred choice.</p>
			<p>If you can't decide, there <a id="_idIndexMarker624"/>is an approach that can provide<a id="_idIndexMarker625"/> the best of both worlds: we can use stages and map each stage to a corresponding state. The list of process steps can easily be configured by users, and since each stage will be linked to some reliable state code, it can also be confidently used to automate business logic.</p>
			<p>This combined approach will be used for the library checkout feature. To implement the checkout stages, we will add the <strong class="source-inline">library.checkout.stage</strong> model. The fields that are needed to describe a stage are as follows:</p>
			<ul>
				<li><strong class="bold">Name</strong>, or title.</li>
				<li><strong class="bold">Sequence</strong>, which is used to order the stage columns.</li>
				<li><strong class="bold">Fold</strong>, to be used by the Kanban view to decide what columns should be folded by default. We usually want to set this on inactive item columns, such as <em class="italic">Done</em> or <em class="italic">Canceled</em>.</li>
				<li><strong class="bold">Active</strong>, to allow archived or no-longer-used stages, in case the process is changed.</li>
				<li><strong class="bold">State</strong>, a closed selection list, which is used to map each stage to a fixed state.</li>
			</ul>
			<p>To implement <a id="_idIndexMarker626"/>the preceding fields, we should start<a id="_idIndexMarker627"/> adding the <strong class="bold">Stages</strong> model, including the model definition, views, menus, and access security:</p>
			<ol>
				<li value="1">Add the <strong class="source-inline">models/library_checkout_stage.py</strong> file and ensure it contains the following model definition code:<p class="source-code">from odoo import fields, models</p><p class="source-code">class CheckoutStage(models.Model):</p><p class="source-code">    _name = "library.checkout.stage"</p><p class="source-code">    _description = "Checkout Stage"</p><p class="source-code">    _order = "sequence"</p><p class="source-code">    name = fields.Char()</p><p class="source-code">    sequence = fields.Integer(default=10)</p><p class="source-code">    fold = fields.Boolean()</p><p class="source-code">    active = fields.Boolean(default=True)</p><p class="source-code">    state = fields.Selection(</p><p class="source-code">        [("new","Requested"),</p><p class="source-code">         ("open","Borrowed"),</p><p class="source-code">         ("done","Returned"),</p><p class="source-code">         ("cancel", "Canceled")],</p><p class="source-code">        default="new",</p><p class="source-code">    )</p><p>The preceding code shouldn't be surprising to you. Stages have a logical sequence, so the order in which they are presented is important. This is ensured by <strong class="source-inline">_order="sequence"</strong>. We can also see the <strong class="source-inline">state</strong> field mapping each stage to a basic state, which can be safely used by the business logic.</p></li>
				<li>As usual, the <a id="_idIndexMarker628"/>new code file must be <a id="_idIndexMarker629"/>added to the <strong class="source-inline">models/__init__.py</strong> file, which should then look like this:<p class="source-code"><strong class="bold">from . import library_checkout_stage</strong></p><p class="source-code">from . import library_checkout</p><p class="source-code">from . import library_checkout_line</p></li>
				<li>Access security rules are also needed. Stages contain setup data, and it should only be editable by the <strong class="bold">Manager</strong> user group. Regular users should have read-only access. For this, add the following highlighted lines to the <strong class="source-inline">security/ir.model.access.csv</strong> file:<p class="source-code">id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink</p><p class="source-code">checkout_user,Checkout User,model_library_checkout,library_app.library_group_user,1,1,1,1</p><p class="source-code">checkout_line_user,Checkout Line</p><p class="source-code">User,model_library_checkout,library_app.library_group_user,1,1,1,1</p><p class="source-code"><strong class="bold">checkout_stage_user,Checkout Stage User,model_library_checkout_stage,library_app.library_group_user,1,0,0,0</strong></p><p class="source-code"><strong class="bold">checkout_stage_manager,Checkout Stage Manager,model_library_checkout_stage,library_app.library_group_manager,1,1,1,1</strong></p></li>
				<li>Next, a<a id="_idIndexMarker630"/> menu item is needed, to <a id="_idIndexMarker631"/>navigate to the stage's setup. This should be under the <strong class="bold">Configurations</strong> menu in the app. The <strong class="source-inline">library_app</strong> module does not provide one yet, so let's edit it to add this. Edit the <strong class="source-inline">library_app/views/library_menu.xml</strong> file and add the following XML:<p class="source-code">  &lt;menuitem id="menu_library_configuration"</p><p class="source-code">            name="Configuration"</p><p class="source-code">            parent="menu_library"</p><p class="source-code">  /&gt;</p></li>
				<li>Now, the <strong class="bold">Stages</strong> menu item can be added under the <strong class="bold">Configurations</strong> menu. Edit the <strong class="source-inline">library_checkout/views/library_menu.xml</strong> file and add the following XML:<p class="source-code">  &lt;record id="action_library_stage" </p><p class="source-code">          model="ir.actions.act_window"&gt;</p><p class="source-code">    &lt;field name="name"&gt;Stages&lt;/field&gt;</p><p class="source-code">    &lt;field name="res_model"&gt;</p><p class="source-code">      library.checkout.stage&lt;/field&gt;</p><p class="source-code">    &lt;field name="view_mode"&gt;tree,form&lt;/field&gt;</p><p class="source-code">  &lt;/record&gt;</p><p class="source-code">  &lt;menuitem id="menu_library_stage"</p><p class="source-code">            name="Stages"</p><p class="source-code">            action="action_library_stage"</p><p class="source-code">            parent=</p><p class="source-code">             "library_app.menu_library_configuration" </p><p class="source-code">  /&gt;</p></li>
				<li>We need<a id="_idIndexMarker632"/> some stages to work with, so <a id="_idIndexMarker633"/>let's add some default data to the module. Create the <strong class="source-inline">data/library_checkout_stage.xml</strong> file with the following code:<p class="source-code">&lt;odoo noupdate="1"&gt;</p><p class="source-code">  &lt;record id="stage_new" model=</p><p class="source-code">    "library.checkout.stage"&gt;</p><p class="source-code">      &lt;field name="name"&gt;Draft&lt;/field&gt;</p><p class="source-code">      &lt;field name="sequence"&gt;10&lt;/field&gt;</p><p class="source-code">      &lt;field name="state"&gt;new&lt;/field&gt;</p><p class="source-code">  &lt;/record&gt;</p><p class="source-code">  &lt;record id="stage_open" model=</p><p class="source-code">    "library.checkout.stage"&gt;</p><p class="source-code">      &lt;field name="name"&gt;Borrowed&lt;/field&gt;</p><p class="source-code">      &lt;field name="sequence"&gt;20&lt;/field&gt;</p><p class="source-code">      &lt;field name="state"&gt;open&lt;/field&gt;</p><p class="source-code">  &lt;/record&gt;</p><p class="source-code">  &lt;record id="stage_done" model=</p><p class="source-code">    "library.checkout.stage"&gt;</p><p class="source-code">      &lt;field name="name"&gt;Completed&lt;/field&gt;</p><p class="source-code">      &lt;field name="sequence"&gt;90&lt;/field&gt;</p><p class="source-code">      &lt;field name="state"&gt;done&lt;/field&gt;</p><p class="source-code">  &lt;/record&gt;</p><p class="source-code">  &lt;record id="stage_cancel" model=</p><p class="source-code">    "library.checkout.stage"&gt;</p><p class="source-code">      &lt;field name="name"&gt;Canceled&lt;/field&gt;</p><p class="source-code">      &lt;field name="sequence"&gt;95&lt;/field&gt;</p><p class="source-code">      &lt;field name="state"&gt;cancel&lt;/field&gt;</p><p class="source-code">  &lt;/record&gt;</p><p class="source-code">&lt;/odoo&gt;</p></li>
				<li>Before this <a id="_idIndexMarker634"/>can take effect, it needs to be<a id="_idIndexMarker635"/> added to the <strong class="source-inline">library_checkout/__manifest__.py</strong> file, as follows:<p class="source-code">  "data": [</p><p class="source-code">    "security/ir.model.access.csv",</p><p class="source-code">    "views/library_menu.xml",</p><p class="source-code">    "views/checkout_view.xml",</p><p class="source-code"><strong class="bold">    "data/library_checkout_stage.xml",</strong></p><p class="source-code">  ],</p></li>
			</ol>
			<p>The following screenshot shows what the Stages list view is expected to look like:</p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="Images/Figure_8.3_B16119.jpg" alt="Figure 8.3 – The Stages list view&#13;&#10;" width="1177" height="292"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – The Stages list view</p>
			<p>This takes care of all the components that are needed to add the Stages model to <strong class="source-inline">library_checkout</strong> and allow users to configure it.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor239"/>Adding stage workflow support to models</h2>
			<p>Next, the stage <a id="_idIndexMarker636"/>field should be added to the library<a id="_idIndexMarker637"/> checkout model. For a proper user experience, two more things should be taken care of:</p>
			<ul>
				<li>The default stage to assign should be the first with a <strong class="source-inline">new</strong> state.</li>
				<li>When grouping by stage, all the available stages should be present, even if there are no checkouts in each of the stages.</li>
			</ul>
			<p>These should be added to the <strong class="source-inline">library_checkout/models/library_checkout.py</strong> file, in the <strong class="source-inline">Checkout</strong> class.</p>
			<p>The function for finding the default stage should return the record that will be used as the default value:</p>
			<p class="source-code">    @api.model</p>
			<p class="source-code">    def _default_stage_id(self):</p>
			<p class="source-code">        Stage = self.env["library.checkout.stage"]</p>
			<p class="source-code">        return Stage.search([("state", "=", "new")], </p>
			<p class="source-code">          limit=1)</p>
			<p>This returns the first record in the stage model. Since the stage model is ordered by sequence, it will return the one with the lowest sequence number.</p>
			<p>When we're grouping by stages, we would like to see all the possible stages rather than only the ones with checkout records. The method that's used for this should return a recordset to use for the groups. In this case, it is appropriate to return all the active stages:</p>
			<p class="source-code">    @api.model</p>
			<p class="source-code">    def _group_expand_stage_id(self, stages, domain, </p>
			<p class="source-code">      order):</p>
			<p class="source-code">        return stages.search([], order=order)</p>
			<p>Finally, the <strong class="source-inline">stage_id</strong> field we wish to add to the checkout model can use the preceding methods for the <strong class="source-inline">default</strong> and <strong class="source-inline">group_expand</strong> attributes:</p>
			<p class="source-code">    stage_id = fields.Many2one(</p>
			<p class="source-code">        "library.checkout.stage",</p>
			<p class="source-code">        default=_default_stage_id,</p>
			<p class="source-code">        group_expand="_group_expand_stage_id")</p>
			<p class="source-code">    state = fields.Selection(related="stage_id.state")</p>
			<p><strong class="source-inline">stage_id</strong> has a many-to-one relationship with the stages model. The default value is calculated by the <strong class="source-inline">_default_stage_id</strong> method function, and the groupby on <strong class="source-inline">stage_id</strong> will <a id="_idIndexMarker638"/>use the result of the <strong class="source-inline">_group_expand_stage_id</strong> method <a id="_idIndexMarker639"/>function.</p>
			<p class="callout-heading">Changes in Odoo 10</p>
			<p class="callout">The <strong class="source-inline">group_expand</strong> field attribute was introduced in Odoo 10 and is not available in previous versions.</p>
			<p>The <strong class="source-inline">group_expand</strong> parameter overrides the way grouping works on the field. The default behavior for grouping operations is to only see the stages that are being used; the stages with no checkout document won't be shown. But in the case of the <strong class="source-inline">stage_id</strong> field, we want to see all the available stages, even if some don't have any items.</p>
			<p>The <strong class="source-inline">_group_expand_stage_id()</strong> helper function returns the list of group records that the grouping operation should use. In this case, it returns all the existing stages, regardless of having library checkouts in that stage or not.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">group_expand</strong> attribute must be a string with a method name. This is unlike other attributes, such as <strong class="source-inline">default</strong>, which can be either strings or direct references to the method name.</p>
			<p>The <strong class="source-inline">state</strong> field was also added. It simply makes the stage-related <strong class="source-inline">state</strong> field in this model available so that it can be used in views. This will use the special support for <strong class="source-inline">state</strong> that views have available.</p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor240"/>Methods to support the user interface</h2>
			<p>The following methods are mostly used by the web client to render the user interface and perform basic interaction:</p>
			<ul>
				<li><strong class="source-inline">name_get()</strong> computes<a id="_idIndexMarker640"/> the <strong class="bold">display name</strong>, which is the text that represents each record that's used on views to display related records. It returns a list of <strong class="source-inline">(ID, name)</strong> tuples, along with the ID. It is the default computation for the <strong class="source-inline">display_name</strong> value and can be extended to implement custom display representations, such as displaying an identifier code along with the record name.</li>
				<li><strong class="source-inline">name_search(name="", args=None, operator="ilike", limit=100)</strong> performs a search on the display name. It is used on views when the user is typing in a relationship field to produce a list containing the suggested records that match the typed text. It returns a list of <strong class="source-inline">(ID, name)</strong> tuples.</li>
				<li><strong class="source-inline">name_create(name)</strong> creates a new record that only has a name as input. It is used in Kanban views with <strong class="source-inline">on_create="quick_create"</strong>, where you can quickly create a related record by just providing its name. It can be extended to provide specific defaults for the new records that are created through this feature.</li>
				<li><strong class="source-inline">default_get([fields])</strong> returns the default values for a new record to be created, as a dictionary. The default values may depend on variables, such as the current user or the session context. This can be extended to add additional default values.</li>
				<li><strong class="source-inline">fields_get()</strong> is used to describe the model's field definitions.</li>
				<li><strong class="source-inline">fields_view_get()</strong> is used by the web client to retrieve the structure of the UI view to render. It can be given the ID of the view as an argument, or the type of view we want using <strong class="source-inline">view_type="form"</strong>. For example, <strong class="source-inline">self.fields_view_get(view_type="tree")</strong> will return the tree view XML architecture <a id="_idIndexMarker641"/>to be rendered for the <strong class="source-inline">self</strong> model.</li>
			</ul>
			<p>These built-in ORM models can be helpful as extension points to implement model-specific business logic.</p>
			<p>The next section will discuss how business logic can be triggered by record operations, such as creating or writing on a record.</p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor241"/>Using the ORM built-in methods</h1>
			<p>The model<a id="_idIndexMarker642"/> definition-related methods can do many things, but some business logic is not possible through them, so it needs to be attached to the ORM record writing operations.</p>
			<p>ORM provides methods to perform <strong class="bold">Create</strong>, <strong class="bold">Read</strong>, <strong class="bold">Update</strong>, and <strong class="bold">Delete</strong> (<strong class="bold">CRUD</strong>) operations<a id="_idIndexMarker643"/> on our model data. Let's explore these write operations and how they can be extended to support custom logic.</p>
			<p>To read data, the main methods that are provided are <strong class="source-inline">search()</strong> and <strong class="source-inline">browse()</strong>, as discussed in <a href="B16119_07_Final_PD_ePub.xhtml#_idTextAnchor194"><em class="italic">Chapter 7</em></a>, <em class="italic">Recordsets – Working with Model Data</em>.</p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor242"/>Methods for writing model data</h2>
			<p>The ORM provides three<a id="_idIndexMarker644"/> methods for the three basic write operations, shown as follows:</p>
			<ul>
				<li><strong class="source-inline">&lt;Model&gt;.create(values)</strong> creates a new record on the model. It returns the created record. <strong class="source-inline">values</strong> can be a dictionary or a list of dictionaries for mass-creating records.</li>
				<li><strong class="source-inline">&lt;Recordset&gt;.write(values)</strong> updates the recordset with the <strong class="source-inline">values</strong> dictionary. It returns nothing.</li>
				<li><strong class="source-inline">&lt;Recordset&gt;.unlink()</strong> deletes the records from the database. It returns nothing.</li>
			</ul>
			<p>The <strong class="source-inline">values</strong> argument<a id="_idIndexMarker645"/> is a dictionary that maps field names to values to write. These methods are decorated with <strong class="source-inline">@api.multi</strong>, except for the <strong class="source-inline">create()</strong> method, which is decorated with <strong class="source-inline">@api.model</strong>.</p>
			<p class="callout-heading">Changes in Odoo 12</p>
			<p class="callout">Being able to use <strong class="source-inline">create()</strong> to access a list of dictionaries, instead of a single dictionary object, was introduced in Odoo 12. This also allows us to create records in batches. This capability is supported through the special <strong class="source-inline">@api.model_create_multi</strong> decorator.</p>
			<p>In some cases, these methods need to be extended to run some specific business logic when they are triggered. This business logic can be run before or after the main method operations are executed.</p>
			<h3>Example of extending create()</h3>
			<p>Let's look at an <a id="_idIndexMarker646"/>example that makes use of this. We want to prevent new checkout records from being created directly in the <strong class="source-inline">Borrowed</strong> or <strong class="source-inline">Returned</strong> states. Usually, validations should be implemented in specific methods that are decorated with <strong class="source-inline">@api.constrains</strong>. But this particular case is tied to the create record event and is hard to implement as a regular validation.</p>
			<p>Edit the <strong class="source-inline">library_checkout/models/library_checkout.py</strong> file and add the <strong class="source-inline">create()</strong> extension method:</p>
			<p class="source-code">    @api.model </p>
			<p class="source-code">    def create(self, vals):</p>
			<p class="source-code">        # Code before create: should use the 'vals' dict</p>
			<p class="source-code">        new_record = super().create(vals) </p>
			<p class="source-code">        # Code after create: can use the 'new_record' </p>
			<p class="source-code">        # created </p>
			<p class="source-code">        if new_record.stage_id.state in ("open", "close"):</p>
			<p class="source-code">            raise exceptions.UserError(</p>
			<p class="source-code">                "State not allowed for new checkouts."</p>
			<p class="source-code">            )</p>
			<p class="source-code">        return new_record</p>
			<p>The new record is created by the <strong class="source-inline">super().create()</strong> call. Before this, the new record is not available to use in the business logic – only the <strong class="source-inline">values</strong> dictionary can be used, or even changed, to force values on the to-be-created record.</p>
			<p>The code after <strong class="source-inline">super().create()</strong> does have access to the new record that's been created and can use record features, such as accessing related records using dot-notation chains. The <a id="_idIndexMarker647"/>preceding example uses <strong class="source-inline">new_record.stage_id.state</strong> to access the state that corresponds to the new record stage. States are not user-configurable and provide a reliable list of values to use in business logic. So, we can look for <strong class="source-inline">open</strong> or <strong class="source-inline">done</strong> states and raise an error if any of them are found.</p>
			<h3>Example of extending write()</h3>
			<p>Let's look <a id="_idIndexMarker648"/>at another example. The <strong class="source-inline">Checkout</strong> model should keep track of the date when the books were borrowed, <strong class="source-inline">Checkout Date</strong>, and the date when they were returned, <strong class="source-inline">Close Date</strong>. This can't be done using computed fields. Instead, the <strong class="source-inline">write()</strong> method should be extended to detect changes on the checkout state and then update the dates that have been filed at the right moment: when changing into the <strong class="source-inline">open</strong> or <strong class="source-inline">close</strong> states.</p>
			<p>Before we implement this logic, the two date fields must be created. Edit the <strong class="source-inline">library_checkout/models/library_checkout.py</strong> file and add the following code:</p>
			<p class="source-code">    checkout_date = fields.Date(readonly=True)</p>
			<p class="source-code">    close_date = fields.Date(readonly=True)</p>
			<p>When a record is modified, the <strong class="source-inline">checkout_date</strong> and <strong class="source-inline">close_date</strong> fields should be set when the checkout record enters the appropriated states. For this, we will use a custom <strong class="source-inline">write()</strong> method, as follows:</p>
			<p class="source-code">    def write(self, vals):</p>
			<p class="source-code">        # Code before write: 'self' has the old values </p>
			<p class="source-code"><strong class="bold">        if "stage_id" in vals:</strong></p>
			<p class="source-code"><strong class="bold">            Stage = self.env["library.checkout.stage"]</strong></p>
			<p class="source-code"><strong class="bold">            </strong><strong class="bold">old_state = self.stage_id.state</strong></p>
			<p class="source-code"><strong class="bold">            new_state = </strong></p>
			<p class="source-code"><strong class="bold">              Stage.browse(vals["stage_id"]).state</strong></p>
			<p class="source-code"><strong class="bold">            if new_state != old_state and new_state == </strong></p>
			<p class="source-code"><strong class="bold">              "open":</strong></p>
			<p class="source-code"><strong class="bold">                vals['checkout_date'] = fields.Date.today()</strong></p>
			<p class="source-code"><strong class="bold">            if new_state != old_state and new_state == </strong></p>
			<p class="source-code"><strong class="bold">               "done":</strong></p>
			<p class="source-code"><strong class="bold">                vals['close_date'] = fields.Date.today()</strong></p>
			<p class="source-code">        super().write(vals)</p>
			<p class="source-code">        # Code after write: can use 'self' with the updated </p>
			<p class="source-code">        # values</p>
			<p class="source-code">        return True</p>
			<p>In the preceding <a id="_idIndexMarker649"/>example, the extension code was added before the <strong class="source-inline">super()</strong> call; so, <em class="italic">before</em> the write operation is done on the <strong class="source-inline">self</strong> record. To know what change is about to be made to the record, we can inspect the <strong class="source-inline">vals</strong> parameter. The <strong class="source-inline">stage_id</strong> value in the <strong class="source-inline">vals</strong> dictionary is an ID number, not a record, so it needs to be browsed to get the corresponding record, and then read the corresponding <strong class="source-inline">state</strong>.</p>
			<p>The old and<a id="_idIndexMarker650"/> new states are compared to trigger the date value update at the appropriate moment. Whenever possible, we prefer to change the values to write before the <strong class="source-inline">super().write()</strong> instruction and modify the <strong class="source-inline">vals</strong> dictionary instead of setting the field value directly. We'll see why in the next section.</p>
			<h3>Example of extending write() that sets values on fields</h3>
			<p>The previous <a id="_idIndexMarker651"/>code only modifies the values to use for the write; it does not assign values directly to the model fields. This is safe to do, but it may not be enough in some cases.</p>
			<p>Assigning a model field value inside a <strong class="source-inline">write()</strong> method leads to an infinite recursion loop: the assignment triggers the write method again, which then repeats the assignment, triggering yet another write call. This will repeat until Python returns a recursion error.</p>
			<p>There is a technique to avoid this recursion loop, making it possible for <strong class="source-inline">write()</strong> methods to set values on its record fields. The trick is to set a unique marker in the environment's <strong class="source-inline">context</strong> before setting the values, and only run the setting values code when that marker is not present.</p>
			<p>An example will help make this clear. Let's rewrite the previous example so that the updates are done after calling <strong class="source-inline">super()</strong>, rather than before:</p>
			<p class="source-code">    def write(self, vals):</p>
			<p class="source-code">        # Code before write: 'self' has the old values </p>
			<p class="source-code">        old_state = self.stage_id.state</p>
			<p class="source-code">        super().write(vals)</p>
			<p class="source-code">        # Code after write: can use 'self' with the updated </p>
			<p class="source-code">        # values</p>
			<p class="source-code">        new_state = self.stage_id.state </p>
			<p class="source-code">        <strong class="bold">if not self.env.context.get("_checkout_write"):</strong></p>
			<p class="source-code">            if new_state != old_state and new_state == "open":</p>
			<p class="source-code">                self<strong class="bold">.with_context(</strong></p>
			<p class="source-code"><strong class="bold">                  _checkout_write=True)</strong>.write(</p>
			<p class="source-code">                    {"checkout_date": fields.Date.today()})</p>
			<p class="source-code">            if new_state != old_state and new_state == </p>
			<p class="source-code">              "done":</p>
			<p class="source-code">                self<strong class="bold">.with_context(</strong></p>
			<p class="source-code"><strong class="bold">                  _checkout_write=True)</strong>.write(</p>
			<p class="source-code">                    {"close_date": fields.Date.today()})</p>
			<p class="source-code">        return True</p>
			<p>With this technique, the extension code is guarded by an <strong class="source-inline">if</strong> statement and only runs if a specific marker is not found in the context. Furthermore, the additional <strong class="source-inline">self.write()</strong> operations use the <strong class="source-inline">with_context</strong> method to set that marker before doing the write. This<a id="_idIndexMarker652"/> combination ensures that the custom login inside the <strong class="source-inline">if</strong> statement runs only once and is not triggered on further <strong class="source-inline">write()</strong> calls, avoiding the infinite loop.</p>
			<h3>When (not) to extend the create() and write() methods</h3>
			<p>Extending the <strong class="source-inline">create()</strong> or <strong class="source-inline">write()</strong> methods should be carefully considered.</p>
			<p>In most cases, some <a id="_idIndexMarker653"/>validation must be performed, or some value must be automatically computed when the record is saved. For these common cases, there are better options, as listed here:</p>
			<ul>
				<li>For field values that are automatically calculated based on other fields, use computed fields. For example, you should calculate a header total when the values of the lines are changed.</li>
				<li>For non-fixed field default values, use a function as the default field value. It will be evaluated and used to assign the default value.</li>
				<li>To have other field values change when some field is changed, use the <strong class="source-inline">onchange</strong> methods, if this is expected to be done on the user interface, or use the new <strong class="bold">computed writable fields</strong>, if this needs to be done at the server side. For example, when the user selects a customer, you can automatically set the price list to the customer's one, though this price list selection can be changed by the user later. When you're using the <strong class="source-inline">onchange</strong> methods, this only works on form view interaction, not on direct write calls, though computed writable fields work in both cases. The <em class="italic">Adding onchange user interface logic</em> section will provide more detail about this.</li>
				<li>For validations, use <strong class="source-inline">constraint</strong> functions. These are automatically triggered when the<a id="_idIndexMarker654"/> field value changes and are expected to raise errors if the validation conditions fail.</li>
			</ul>
			<p>There are still cases where none of these options will work and extending <strong class="source-inline">create()</strong> or <strong class="source-inline">write()</strong> is needed, such as when the default values to set depend on the other fields of the record that's being created. In this case, a default value function won't work because it does not have access to the other field values of the new record.</p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor243"/>Methods for data import and export</h2>
			<p>Data import and export, as discussed in <a href="B16119_05_Final_PD_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 5</em></a>, <em class="italic">Importing, Exporting, and Module Data</em>, is also available from the ORM API, through the following methods:</p>
			<ul>
				<li><strong class="source-inline">load([fields], [data])</strong> is<a id="_idIndexMarker655"/> used to import data and is used by Odoo when importing CSV or spreadsheet data into Odoo. The first argument is the list of fields to import, and it maps directly to a CSV top row. The second argument is a list of records, where each record is a list of string values to parse and import. It maps directly to the CSV data rows and columns and implements the features of CSV data import, such as external identifiers support.</li>
				<li><strong class="source-inline">export_data([fields])</strong> is used by<a id="_idIndexMarker656"/> the web client's <strong class="source-inline">Export</strong> function. It returns a dictionary with a <strong class="source-inline">datas</strong> key containing the data; that is, a list of rows. The field names can use the <strong class="source-inline">.id</strong> and <strong class="source-inline">/id</strong> suffixes that are used in CSV files, and the data is in a format that's compatible with an importable CSV file.</li>
			</ul>
			<p>It is also possible to implement automation on the user interface, while the user is editing data. We'll learn about this in the next section.</p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor244"/>Adding onchange user interface logic</h1>
			<p>It is possible to <a id="_idIndexMarker657"/>make changes to the web client view while the user is editing it. This <a id="_idIndexMarker658"/>mechanism is known as <strong class="bold">onchange</strong>. It is implemented through methods decorated with <strong class="source-inline">@api.onchange</strong>, and they are triggered by the user interface view when the user edits a value on a particular field.</p>
			<p>Since Odoo 13, the same effect can be achieved by using a particular form of computed fields, called <strong class="bold">computed writable fields</strong>. This <a id="_idIndexMarker659"/>ORM improvement aims to avoid some limitations of the classic onchange mechanism, and in the long run, it should replace it completely.</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor245"/>Classic onchange methods</h2>
			<p>Onchange methods<a id="_idIndexMarker660"/> can change other field values in the form, perform a validation, show a message to the user, or set a domain filter in relation fields, limiting the available options.</p>
			<p>The onchange method is called asynchronously and returns data that's being used by the web client to update the fields in the current view.</p>
			<p>Onchange methods are linked to the triggering fields, which are passed as arguments to the <strong class="source-inline">@api.onchange("fld1", "fld2", ...)</strong> decorator.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">api.onchange</strong> arguments do not support dot notation; for example, <strong class="source-inline">"partner_id.name"</strong>. If used, it will be ignored.</p>
			<p>Inside the method, the <strong class="source-inline">self</strong> argument is a virtual record that contains the current form data. It is virtual because it can be a new or changed record that is still being edited and hasn't been saved to the database yet. If values are set on this <strong class="source-inline">self</strong> record, these will be changed on the user interface form. Notice that it doesn't write to database records; instead, it provides information so that you can change the data in the UI form.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Other restrictions apply to onchange methods, as documented at <a href="https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html#odoo.api.onchange">https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html#odoo.api.onchange</a>.Computed writable fields can be used as a full-featured alternative to onchanges. See the <em class="italic">The new onchange, with computed writable fields</em> section for more information.</p>
			<p>No return value is needed, but a <strong class="source-inline">dict</strong> structure may be returned with a warning message to display in the user interface, or a domain filter to be set on form fields.</p>
			<p>Let's work with an <a id="_idIndexMarker661"/>example. On the checkout form, when the library member is selected, the request date will be set to <strong class="source-inline">today</strong>. If the date changed, a warning message will be shown to the user, alerting them about it.</p>
			<p>To implement this, edit the <strong class="source-inline">library_checkout/models/library_checkout.py</strong> file and add the following method:</p>
			<p class="source-code">    @api.onchange("member_id")</p>
			<p class="source-code">    def onchange_member_id(self):</p>
			<p class="source-code">        today_date = fields.Date.today()</p>
			<p class="source-code">        if self.request_date != today_date:</p>
			<p class="source-code">            self.request_date = today_date</p>
			<p class="source-code">            return {</p>
			<p class="source-code">                "warning": {</p>
			<p class="source-code">                    "title": "Changed Request Date",</p>
			<p class="source-code">                    "message": "Request date changed to </p>
			<p class="source-code">                      today!",</p>
			<p class="source-code">                }</p>
			<p class="source-code">            }</p>
			<p>The previous <strong class="source-inline">onchange</strong> method is triggered when the <strong class="source-inline">member_id</strong> field is set on the user interface. The actual method name is not relevant, but the convention is for its name to begin with the <strong class="source-inline">onchange_</strong> prefix.</p>
			<p>Inside an <strong class="source-inline">onchange</strong> method, <strong class="source-inline">self</strong> represents a single virtual record containing all of the fields that have currently been set in the record being edited, and we can interact with them.</p>
			<p>The method code checks whether the current <strong class="source-inline">request_date</strong> needs to be changed. If it does, <strong class="source-inline">request_date</strong> is set to today so that the user will see that change in the form. Then, a non-blocking warning message is returned to the user.</p>
			<p>The <strong class="source-inline">onchange</strong> methods do not need to return anything, but they can return a dictionary containing a <a id="_idIndexMarker662"/>warning or a domain key, as follows:</p>
			<ul>
				<li>The warning key should describe a message to show in a dialog window, such as <strong class="source-inline">{"title": "Message Title", "message": "Message Body"}</strong>.</li>
				<li>The domain key can set or change the domain attribute of other fields. This allows you to build more user-friendly interfaces; having a to-many field only makes the options that make sense at that moment available. The value for the domain key looks like <strong class="source-inline">{"user_id": [("email", "!=", False)]}</strong>.</li>
			</ul>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor246"/>The new onchange, with computed writable fields</h2>
			<p>The classic onchange mechanism has <a id="_idIndexMarker663"/>a key role in the user experience that's provided by the Odoo framework. However, it has a few important limitations.</p>
			<p>One is that it works disconnected from the server-side events. Onchange is only played when requested by the form view and is not called as a consequence of an actual <strong class="source-inline">write()</strong> value change. This forces the server-side business logic to explicitly replay the relevant onchange methods.</p>
			<p>Another limitation is that onchange is attached to the triggering fields and not to the change-affected fields. In non-trivial cases, this becomes hard to extend and makes it difficult to track the source of the changes.</p>
			<p>To address these issues, the <a id="_idIndexMarker664"/>Odoo framework expanded the computed field capabilities so that it can also address the onchange use case. We will call this technique <strong class="bold">computed writable fields</strong>. The classic onchange is still supported and used, but it is expected to be replaced by computed fields and become deprecated in future versions.</p>
			<p class="callout-heading">Changes in Odoo 13</p>
			<p class="callout">Computed writable fields were introduced in Odoo 13 and are available for that version and later ones.</p>
			<p>Computed writable fields have compute methods assigned to them, must be stored, and must have the <strong class="bold">readonly=False</strong> attribute.</p>
			<p>Let's implement the previous onchange using this technique instead. This is how the <strong class="source-inline">request_date</strong> field definition should be changed:</p>
			<p class="source-code">    request_date = fields.Date(</p>
			<p class="source-code">        default=lambda s: fields.Date.today(),</p>
			<p class="source-code"><strong class="bold">        compute="_compute_request_date_onchange",</strong></p>
			<p class="source-code"><strong class="bold">        store=True,</strong></p>
			<p class="source-code"><strong class="bold">        readonly=False,</strong></p>
			<p class="source-code">    )</p>
			<p>This is a <a id="_idIndexMarker665"/>regular stored and writable field, but it has attached a compute method that can be triggered in particular conditions. For example, the computed method should be triggered when the <strong class="source-inline">member_id</strong> field changes.</p>
			<p>This is the code for the compute method, <strong class="source-inline">_compute_request_date_onchange</strong>:</p>
			<p class="source-code"><strong class="bold">    @api.depends("member_id")</strong></p>
			<p class="source-code"><strong class="bold">    def _compute_request_date_onchange(self):</strong></p>
			<p class="source-code">        today_date = fields.Date.today()</p>
			<p class="source-code">        if self.request_date != today_date:</p>
			<p class="source-code">            self.request_date = today_date</p>
			<p class="source-code">            return {</p>
			<p class="source-code">                "warning": {</p>
			<p class="source-code">                    "title": "Changed Request Date",</p>
			<p class="source-code">                    "message": "Request date changed to </p>
			<p class="source-code">                      today!",</p>
			<p class="source-code">                }</p>
			<p class="source-code">            }</p>
			<p><strong class="source-inline">@api.depends</strong> works as usual for computed fields and declares the fields to watch for changes. The actual field list to provide is the same as the one that's used by the classic <strong class="source-inline">@api.onchange</strong>.</p>
			<p>The method code can be very similar to the equivalent onchange method. In this particular case, it is identical. Note that the computed field is not ensured to be set a value on every method call. This <a id="_idIndexMarker666"/>only happens when some conditions are met. In this case, the original request date is different from today's date. This goes against regular computed field rules but is allowed for computed writable fields.</p>
			<p>Particularly relevant to business processes is the ability to send emails or notify users. The next section discusses the features that Odoo provides for this.</p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor247"/>The message and activity features</h1>
			<p>Odoo has global messaging and activity planning features available, all of which are provided by the <strong class="bold">Discuss</strong> application, and a <strong class="source-inline">mail</strong> technical name.</p>
			<p>The messaging features<a id="_idIndexMarker667"/> are added by the <strong class="source-inline">mail.thread</strong> model and make a message widget on form views available, also known as C<em class="italic">hatter</em>. This widget allows you to log notes or send messages to other people. It also keeps a history of the messages that have been sent, and it is also used by automatic processes to log progress tracking messages.</p>
			<p>The same app also provides activity management features<a id="_idIndexMarker668"/> through the <strong class="source-inline">mail.activity.mixin</strong> model. The activity widget can be added to the form view to allow users to schedule and track the history of activities.</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor248"/>Adding message and activity features</h2>
			<p>The mail module provides the <strong class="source-inline">mail.thread</strong> abstract class, which is used to add the messaging<a id="_idIndexMarker669"/> features to any model, and <strong class="source-inline">mail.activity.mixin</strong>, which does the same for the planned<a id="_idIndexMarker670"/> activity features. In <a href="B16119_04_Final_PD_ePub.xhtml#_idTextAnchor119"><em class="italic">Chapter 4</em></a>, <em class="italic">Extending Modules</em>, we explained how to add these inherited features to models using the inheritance from mixin abstract classes.</p>
			<p>Let's go through the necessary steps:</p>
			<ol>
				<li value="1">Add the <strong class="source-inline">mail</strong> module dependency to the <strong class="source-inline">library_checkout</strong> add-on module by editing the <strong class="source-inline">'depends'</strong> key in the <strong class="source-inline">library_checkout/__manifest__.py </strong>file, as follows:<p class="source-code">  "depends": ["library_member", <strong class="bold">"mail"</strong>],</p></li>
				<li>To have the <strong class="source-inline">library.checkout</strong> model inherit from the message and activity abstract classes, edit the <strong class="source-inline">library_checkout/models/library_checkout.py </strong>files, as follows:<p class="source-code">class Checkout(models.Model): </p><p class="source-code">    _name = "library.checkout"</p><p class="source-code">    _description = "Checkout Request"</p><p class="source-code">    <strong class="bold">_inherit = ["mail.thread", "mail.activity.mixin"]</strong></p></li>
				<li>To add the message and activity fields to the checkout form view, edit the <strong class="source-inline">library_checkout/</strong> and <strong class="source-inline">views/checkout_view.xml</strong> files:<p class="source-code">  &lt;record id="view_form_checkout" model="ir.ui.view"&gt;</p><p class="source-code">    &lt;field name="name"&gt;Checkout Form&lt;/field&gt;</p><p class="source-code">    &lt;field name="model"&gt;library.checkout&lt;/field&gt;</p><p class="source-code">    &lt;field name="arch" type="xml"&gt;</p><p class="source-code">      &lt;form&gt;</p><p class="source-code">        &lt;sheet&gt;</p><p class="source-code">          &lt;group&gt;</p><p class="source-code">            &lt;field name="member_id" /&gt;</p><p class="source-code">            &lt;field name="request_date" /&gt;</p><p class="source-code">            &lt;field name="user_id" /&gt;</p><p class="source-code">          &lt;/group&gt;</p><p class="source-code">          &lt;notebook&gt;</p><p class="source-code">            &lt;page name="lines"&gt;</p><p class="source-code">              &lt;field name="line_ids"&gt;</p><p class="source-code">                &lt;tree editable="bottom"&gt;</p><p class="source-code">                  &lt;field name="book_id" /&gt;</p><p class="source-code">                  &lt;field name="note" /&gt;</p><p class="source-code">                &lt;/tree&gt;</p><p class="source-code">              &lt;/field&gt;</p><p class="source-code">            &lt;/page&gt;</p><p class="source-code">          &lt;/notebook&gt;</p><p class="source-code">        &lt;/sheet&gt;</p><p class="source-code"><strong class="bold">        &lt;div class="oe_chatter"&gt;</strong></p><p class="source-code"><strong class="bold">          &lt;field name="message_follower_ids"</strong></p><p class="source-code"><strong class="bold">                 widget="mail_followers" /&gt;</strong></p><p class="source-code"><strong class="bold">          &lt;field name="activity_ids"</strong></p><p class="source-code"><strong class="bold">                 widget="mail_activity"/&gt;</strong></p><p class="source-code"><strong class="bold">          &lt;field name="message_ids"</strong></p><p class="source-code"><strong class="bold">                 widget="mail_thread" /&gt;</strong></p><p class="source-code"><strong class="bold">        </strong><strong class="bold">&lt;/div&gt;</strong></p><p class="source-code">      &lt;/form&gt;</p><p class="source-code">    &lt;/field&gt;</p><p class="source-code">  &lt;/record&gt;</p><p class="source-code">&lt;/odoo&gt;</p></li>
			</ol>
			<p>Having done this, the checkout model will have the message and activity fields and their features available.</p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor249"/>Message and activity fields and models</h2>
			<p>The message and activity features add new fields to the models that inherit the <strong class="source-inline">mail.thread</strong> and <strong class="source-inline">mail.activity.mixin</strong> classes, along with all the supporting models for these features. These are the basic data structures that have been added.</p>
			<p>The <strong class="source-inline">mail.thread</strong> mixin class makes two new fields available:</p>
			<ul>
				<li><strong class="bold">Followers</strong>: <strong class="source-inline">message_follower_ids</strong> has a <a id="_idIndexMarker671"/>one-to-many relationship with <strong class="source-inline">mail.followers</strong> and stores the message followers that should receive notifications. Followers can either be partners or <a id="_idIndexMarker672"/>channels. A <strong class="bold">partner</strong> represents a specific person or organization. A <strong class="bold">channel</strong> is not a particular person and instead represents a<a id="_idIndexMarker673"/> subscription list.</li>
				<li><strong class="bold">Messages</strong>: <strong class="source-inline">message_ids</strong> has a<a id="_idIndexMarker674"/> one-to-many relationship with <strong class="source-inline">mail.message</strong> records and lists the record message history.</li>
			</ul>
			<p>The <strong class="source-inline">mail.activity.mixin</strong> mixin class adds the following new field:</p>
			<ul>
				<li><strong class="bold">Activities</strong>: <strong class="source-inline">activity_ids</strong> has a one-to-many relationship with <strong class="source-inline">mail.activity</strong> and stores activities<a id="_idIndexMarker675"/> that have been completed or planned.</li>
			</ul>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor250"/>Message subtypes</h2>
			<p>Messages can be <a id="_idIndexMarker676"/>assigned a <strong class="bold">subtype</strong>. Subtypes can identify particular events, such as a task being created or closed, and are useful for fine-tuning what notifications should be sent to whom.</p>
			<p>Subtypes are stored in the <strong class="source-inline">mail.message.subtype</strong> model and can be configured in the <strong class="bold">Settings</strong> | <strong class="bold">Technical</strong> | <strong class="bold">Email</strong> | <strong class="bold">Subtypes</strong> menu.</p>
			<p>The basic message subtypes that are available are as follows:</p>
			<ul>
				<li><strong class="bold">Discussions</strong>, with<a id="_idIndexMarker677"/> the <strong class="source-inline">mail.mt_comment</strong> XML ID, are used for the messages that are sent through the <strong class="bold">Send message</strong> option in the message widget. Followers will be sent a message notification about this.</li>
				<li><strong class="bold">Note</strong>, with<a id="_idIndexMarker678"/> the <strong class="source-inline">mail.mt_note</strong> XML ID, is used by the messages that are created with the <strong class="bold">Log note</strong> XML ID, which do not send out notifications.</li>
				<li><strong class="bold">Activities</strong>, with <a id="_idIndexMarker679"/>the <strong class="source-inline">mail.mt_activities</strong> XML ID, are used for the messages that are created with the <strong class="source-inline">Schedule activity</strong> link. It is not intended to send a notification.</li>
			</ul>
			<p>Apps can add their own subtypes, which are usually linked to relevant events. For example, the <strong class="bold">Sales</strong> app adds two subtypes: <strong class="source-inline">Quotation sent</strong> and <strong class="source-inline">Sales Order Confirmed</strong>. These are used by the app's business logic when you're logging these events in the message history.</p>
			<p>Subtypes allow you to determine when notifications should be sent out and to whom. The followers menu, at the top right of the messages widget, allows you to add or remove followers, as well as selecting the particular subtypes they will receive notifications about. The following screenshot shows the subtype selection form for a specific follower – <em class="italic">Deco Addict</em>, in this case:</p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="Images/Figure_8.4_B16119.jpg" alt="Figure 8.4 – Followers widget to select the active message subtypes&#13;&#10;" width="1284" height="546"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – Followers widget to select the active message subtypes</p>
			<p>The subtype<a id="_idIndexMarker680"/> subscription flags can be edited manually, and their default value is configured on editing the <strong class="bold">Subtype</strong> definition to check the <strong class="bold">Default</strong> field. When it is set, the followers on new records will receive notifications by default.</p>
			<p>Other than the built-in subtypes, add-on modules add their own subtypes. A subtype can be global or intended for a particular model. In the latter case, the subtype's <strong class="source-inline">res_model</strong> field identifies the model it applies to.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor251"/>Posting messages</h2>
			<p>Module business<a id="_idIndexMarker681"/> logic can make use of the messaging system to send notifications to users.</p>
			<p>The <strong class="source-inline">message_post()</strong> method is used to post a message. Here is an example:</p>
			<p class="source-code">self.message_post("Hello!")</p>
			<p>The preceding code adds a simple text message but sends no notification to the followers. This is because, by default, messages are posted using <strong class="bold">Log a Note</strong>, with the <strong class="source-inline">subtype="mail.mt_note"</strong> parameter.</p>
			<p>To have the message send a notification as well, the <strong class="source-inline">mail.mt_comment</strong> subtype should be used, as shown in the following example:</p>
			<p class="source-code">self.message_post(</p>
			<p class="source-code">    "Hello again!",</p>
			<p class="source-code">    subject="Hello",</p>
			<p class="source-code">    subtype='mail.mt_comment",</p>
			<p class="source-code">)</p>
			<p>The message body <a id="_idIndexMarker682"/>is HTML, so we can include markup for text effects, such as <strong class="source-inline">&lt;b&gt;</strong> for bold text or <strong class="source-inline">&lt;i&gt;</strong> for italics. </p>
			<p>The message body will be sanitized for security reasons, so some particular HTML elements may not make it to the final message.</p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor252"/>Adding followers</h2>
			<p>Also useful<a id="_idIndexMarker683"/> from a business logic viewpoint is the ability to automatically <a id="_idIndexMarker684"/>add followers to a document so that they can then get the corresponding notifications. There are a few methods available to add followers, as follows:</p>
			<ul>
				<li><strong class="source-inline">message_subscribe(partner_ids=&lt;list of int IDs&gt;)</strong> adds partners</li>
				<li><strong class="source-inline">message_subscribe(channel_ids=&lt;list of int IDs&gt;)</strong> adds channels</li>
				<li><strong class="source-inline">message_subscribe_users(user_ids=&lt;list of int IDs&gt;)</strong> adds users</li>
			</ul>
			<p>The default subtypes will be applied to each subscriber. To force a user to subscribe to a specific list of subtypes, you can add the <strong class="source-inline">subtype_ids=&lt;list of int IDs&gt;</strong> attribute, which lists the specific subtypes to enable for the subscription. If this is used, it will also reset the existing follower-subscribed subtypes to the specified ones.</p>
			<h1 id="_idParaDest-249"><a id="_idTextAnchor253"/>Creating a wizard</h1>
			<p><strong class="bold">Wizards</strong> are <a id="_idIndexMarker685"/>user interface patterns that provide rich interaction for the user, usually to provide input for an automated process.</p>
			<p>As an example, the <a id="_idIndexMarker686"/><strong class="source-inline">checkout</strong> module will provide a wizard for library users to mass email borrowers. For example, they could select the oldest checkouts with borrowed books and send them all a message, requesting for the books to be returned.</p>
			<p>Users start by going to the checkouts list view, selecting the checkout records to use, and then selecting a <strong class="bold">Send Messages</strong> option from the <strong class="bold">Action</strong> context menu. This will open the wizard form, allowing them to write the message subject and body. Clicking the <strong class="bold">Send</strong> button will send an email to each person that borrowed the selected checkouts.</p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor254"/>The wizard model</h2>
			<p>A wizard<a id="_idIndexMarker687"/> displays a form view to the user, usually as a dialog window, with some fields to be filled in and buttons to trigger some business logic. These will then be used for the wizard's logic.</p>
			<p>This is implemented using the same model/view architecture that's used for regular views, but the supporting model is based on <strong class="source-inline">models.TransientModel</strong> instead of <strong class="source-inline">models.Model</strong>. This type of model has a database representation too, which is used to store the wizard's state. The wizard data is temporary, to allow the wizard to complete its work. A scheduled job regularly cleans up the old data from the wizard database tables.</p>
			<p>The <strong class="source-inline">library_checkout/wizard/library_checkout_massmessage.py</strong> file will create the model data structure that's needed for the user interaction: the list of checkout records to be notified, the message subject, and the message body.</p>
			<p>Follow these steps to add the wizard to the <strong class="source-inline">library_checkout</strong> module:</p>
			<ol>
				<li value="1">First, edit the <strong class="source-inline">library_checkout/__init__.py</strong> file to import the code into the <strong class="source-inline">wizard/</strong> subdirectory, as follows:<p class="source-code">from . import models</p><p class="source-code"><strong class="bold">from . import wizard</strong></p></li>
				<li>Add the <strong class="source-inline">wizard/__init__.py</strong> file with the following line of code:<p class="source-code">from . import checkout_mass_message</p></li>
				<li>Then, create the actual <strong class="source-inline">wizard/checkout_mass_message.py</strong> file, as follows:<p class="source-code">from odoo import api, exceptions, fields, models</p><p class="source-code">class CheckoutMassMessage(models.TransientModel): </p><p class="source-code">    _name = "library.checkout.massmessage"</p><p class="source-code">    _description = "Send Message to Borrowers"</p><p class="source-code">    checkout_ids = fields.Many2many(</p><p class="source-code">        "library.checkout",</p><p class="source-code">        string="Checkouts",</p><p class="source-code">    )</p><p class="source-code">    message_subject = fields.Char()</p><p class="source-code">    message_body = fields.Html()</p></li>
			</ol>
			<p>With that, we have<a id="_idIndexMarker688"/> prepared the basic data structures that are needed for the wizard.</p>
			<p>Note that regular models shouldn't have relationship fields that use transient models.</p>
			<p>The consequence of this is that transient models shouldn't have one-to-many relationships with regular models. The reason for this is that the one-to-many relationship on the transient model would require the regular model to have the inverse many-to-one relationship with the transient model, which would cause issues with automatically cleaning up transient records.</p>
			<p>The alternative to this is to use a many-to-many relationship. Many-to-many relationships are stored in a dedicated table, and the rows in this table are automatically deleted when either side of the relationship is deleted.</p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor255"/>The wizard's access security</h2>
			<p>Just like regular<a id="_idIndexMarker689"/> models, transient models also need access security rules to be defined on them. This is done in the same way as it is for regular modules – usually, in the <strong class="source-inline">security/ir.model.access.csv</strong> file.</p>
			<p class="callout-heading">Changes in Odoo 13</p>
			<p class="callout">Up until Odoo 12, transient models did not need access security rules. This changed in Odoo 13, so now, transient models require access rules, just like regular models do.</p>
			<p>To add ACLs for the wizard's model, edit the <strong class="source-inline">security/ir.model.access.csv</strong> file and add the following highlighted line:</p>
			<p class="source-code">id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink</p>
			<p class="source-code">checkout_user,Checkout User,model_library_checkout,library_app.library_group_user,1,1,1,1</p>
			<p class="source-code">checkout_line_user,Checkout Line</p>
			<p class="source-code">checkout_user,Checkout User,model_library_checkout,library_app.library_group_user,1,1,1,1</p>
			<p class="source-code">checkout_stage_user,Checkout Stage User,model_library_checkout_stage,library_app.library_group_user,1,0,0,0</p>
			<p class="source-code">checkout_stage_manager,Checkout Stage Manager,model_library_checkout_stage,library_app.library_group_manager,1,1,1,1</p>
			<p class="source-code"><strong class="bold">checkout_massmessage_user,Checkout Mass Message User,model_library_checkout_massmessage,library_app.library_group_user,1,1,1,1</strong></p>
			<p>Adding one <a id="_idIndexMarker690"/>line is enough to add full access to the Library User group; no specific access rights are needed for the Library Manager group.</p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor256"/>The wizard form</h2>
			<p>The wizard form<a id="_idIndexMarker691"/> views are defined in the same way as they are for regular models, except for two specific elements:</p>
			<ul>
				<li>A <strong class="source-inline">&lt;footer&gt;</strong> section can be used to replace the action buttons.</li>
				<li>A <strong class="source-inline">special="cancel"</strong> button is available to interrupt the wizard without performing any action.</li>
			</ul>
			<p>The following is the content of the <strong class="source-inline">wizard/checkout_mass_message_wizard_view.xml</strong> file:</p>
			<p class="source-code">&lt;odoo&gt;</p>
			<p class="source-code">  &lt;record id="view_form_checkout_message" </p>
			<p class="source-code">    model="ir.ui.view"&gt;</p>
			<p class="source-code">    &lt;field name="name"&gt;Library Checkout Mass Message </p>
			<p class="source-code">      Wizard&lt;/field&gt;</p>
			<p class="source-code">    &lt;field name="model"&gt;</p>
			<p class="source-code">      library.checkout.massmessage&lt;/field&gt;</p>
			<p class="source-code">    &lt;field name="arch" type="xml"&gt;</p>
			<p class="source-code">      &lt;form&gt;</p>
			<p class="source-code">        &lt;group&gt;</p>
			<p class="source-code">          &lt;field name="message_subject" /&gt;</p>
			<p class="source-code">          &lt;field name="message_body" /&gt;</p>
			<p class="source-code">          &lt;field name="checkout_ids" /&gt;</p>
			<p class="source-code">        &lt;/group&gt;</p>
			<p class="source-code">        &lt;footer&gt;</p>
			<p class="source-code">          &lt;button type="object"</p>
			<p class="source-code">            name="button_send"</p>
			<p class="source-code">            string="Send Messages" /&gt;</p>
			<p class="source-code">          &lt;button special="cancel" </p>
			<p class="source-code">            string="Cancel" </p>
			<p class="source-code">            class="btn-secondary" /&gt;</p>
			<p class="source-code">        &lt;/footer&gt;</p>
			<p class="source-code">      &lt;/form&gt;</p>
			<p class="source-code">    &lt;/field&gt;</p>
			<p class="source-code">  &lt;/record&gt;</p>
			<p class="source-code">  &lt;record id="action_checkout_message"</p>
			<p class="source-code">          model="ir.actions.act_window"&gt;</p>
			<p class="source-code">    &lt;field name="name"&gt;Send Messages&lt;/field&gt;</p>
			<p class="source-code">    &lt;field name="res_model"&gt;</p>
			<p class="source-code">      library.checkout.massmessage&lt;/field&gt;</p>
			<p class="source-code">    &lt;field name="view_mode"&gt;form&lt;/field&gt;</p>
			<p class="source-code">    &lt;field name="binding_model_id"</p>
			<p class="source-code">           ref="model_library_checkout" /&gt;</p>
			<p class="source-code">    &lt;field name="binding_view_types"&gt;form,list&lt;/field&gt;</p>
			<p class="source-code">    &lt;field name="target"&gt;new&lt;/field&gt;</p>
			<p class="source-code">  &lt;/record&gt;</p>
			<p class="source-code">&lt;/odoo&gt;</p>
			<p>The previous XML code adds two data records – one for the wizard form view and another for the action to open the wizard.</p>
			<p>The <strong class="source-inline">ir.actions.act_window</strong> window action record is made available in the <strong class="bold">Action</strong> context menu using the <strong class="source-inline">binding_model_id</strong> field value.</p>
			<p>Remember to<a id="_idIndexMarker692"/> add this file to the manifest file:</p>
			<p class="source-code">  "data": [</p>
			<p class="source-code">    "security/ir.model.access.csv",</p>
			<p class="source-code"><strong class="bold">    "wizard/checkout_mass_message_wizard_view.xml",</strong></p>
			<p class="source-code">    "views/library_menu.xml",</p>
			<p class="source-code">    "views/checkout_view.xml",</p>
			<p class="source-code">    "data/library_checkout_stage.xml",</p>
			<p class="source-code">  ],</p>
			<p>The wizard form will look as follows:</p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="Images/Figure_8.5_B16119.jpg" alt="Figure 8.5 – The Send Messages wizard form&#13;&#10;" width="1179" height="547"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – The Send Messages wizard form</p>
			<p>To open the <a id="_idIndexMarker693"/>wizard, the user should select one or more records on the checkout list view and choose the <strong class="bold">Send Messages</strong> option via the <strong class="bold">Action</strong> menu, which is available at the top of the list view.</p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor257"/>The wizard business logic</h2>
			<p>At this point, the <a id="_idIndexMarker694"/>action opens the wizard form, but it is not capable of performing any operations on the records yet. To start with, we would like the wizard to present the list of records that were selected in the checkout list view.</p>
			<p>When the wizard form is opened, it displays an empty form. It is not a record yet; this will only happen when you click on a button that's calling a method.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When the wizard form is opened, we have an empty record. The <strong class="source-inline">create()</strong> method hasn't been invoked yet; this will only happen when we press a button. So, it can't be used to set the initial values to be presented in a wizard form.</p>
			<p>It is still possible to populate data on the empty form by setting default values on the fields. <strong class="source-inline">default_get()</strong> is an ORM API method that's in charge of computing the default values for a record. It can be extended to add custom logic, like so:</p>
			<p class="source-code">    @api.model</p>
			<p class="source-code">    def default_get(self, field_names):</p>
			<p class="source-code">        defaults_dict = super().default_get(field_names)</p>
			<p class="source-code">        # Add values to the defaults_dict here</p>
			<p class="source-code">        return defaults_dict</p>
			<p>The preceding method function can be used to add the default value for the <strong class="source-inline">checkout_ids</strong> field. But we still need to know how to access the list of records that will be selected in the origin list view.</p>
			<p>When you're <a id="_idIndexMarker695"/>navigating from a client window to the next, the web client stores some data about the origin view in the environment's <strong class="source-inline">context</strong>. This data is as follows:</p>
			<ul>
				<li><strong class="source-inline">Active_model</strong>, which is the technical name of the model</li>
				<li><strong class="source-inline">Active_id</strong>, which is the ID of the form active record or the tree view's first record, if you're navigating from a list</li>
				<li><strong class="source-inline">active_ids</strong>, which is a list that contains the selected records or just one element if you're navigating from a form</li>
				<li><strong class="source-inline">active_domain</strong>, if the action is triggered from a form view</li>
			</ul>
			<p>In this case, <strong class="source-inline">active_ids</strong> can be used to get the record IDs that have been selected in the list view and set the default value on the <strong class="source-inline">checkout_ids</strong> field. This is what the <strong class="source-inline">default_get</strong> method looks like:</p>
			<p class="source-code">    @api.model</p>
			<p class="source-code">    def default_get(self, field_names):</p>
			<p class="source-code">        defaults_dict = super().default_get(field_names)</p>
			<p class="source-code"><strong class="bold">        checkout_ids = self.env.context["active_ids"]</strong></p>
			<p class="source-code"><strong class="bold">        defaults_dict["checkout_ids"] = checkout_ids</strong></p>
			<p class="source-code">        return defaults_dict</p>
			<p>First, <strong class="source-inline">super()</strong> is used to call the framework's <strong class="source-inline">default_get()</strong> implementation, which returns a dictionary containing default values. Then, the <strong class="source-inline">checkout_id</strong> key is added to <strong class="source-inline">defaults_dict</strong>, with the <strong class="source-inline">active_ids</strong> value read from the environment's context.</p>
			<p>With this, when the <a id="_idIndexMarker696"/>wizard form is opened, the <strong class="source-inline">checkout_ids</strong> field will be automatically populated with the records that have been selected. Next, the logic for the form's <strong class="bold">Send Messages</strong> button needs to be implemented.</p>
			<p>Upon inspecting the form XML code, we can see that <strong class="source-inline">button_send</strong> is the name of the function that's called by the button. It should be defined in the <strong class="source-inline">wizard/checkout_mass_message.py</strong> file, as shown in the following code:</p>
			<p class="source-code">    def button_send(self):</p>
			<p class="source-code">        self.ensure_one()</p>
			<p class="source-code">        for checkout in self.checkout_ids:</p>
			<p class="source-code">            checkout.message_post(</p>
			<p class="source-code">                body=self.message_body,</p>
			<p class="source-code">                subject=self.message_subject,</p>
			<p class="source-code">                subtype='mail.mt_comment',</p>
			<p class="source-code">            )</p>
			<p class="source-code">        return True</p>
			<p>The method is designed to work with a single record and would not work correctly if <strong class="source-inline">self</strong> was a recordset instead of a singleton. To make this explicit, <strong class="source-inline">self.ensure_one()</strong> is being used.</p>
			<p>Here, <strong class="source-inline">self</strong> represents the wizard record data, which was created when the button was pressed. It contains the data that was entered on the wizard form. Validation is performed to ensure a message body text is provided by the user.</p>
			<p>The <strong class="source-inline">checkout_id</strong> field is accessed, and a loop iterates through each of its records. For each checkout record, a message is posted using the <strong class="source-inline">mail.thread</strong> API. The <strong class="source-inline">mail.mt_comment</strong> subtype must be used for a notification email to be sent to the record followers. The message's <strong class="source-inline">body</strong> and <strong class="source-inline">subject</strong> are taken from the <strong class="source-inline">self</strong> record fields.</p>
			<p>It is good <a id="_idIndexMarker697"/>practice for methods to always return something – the <strong class="source-inline">True</strong> value at the very least. The sole reason for this is that some XML-RPC clients don't support <strong class="source-inline">None</strong> values. When a Python function has no explicit <strong class="source-inline">return</strong>, it implicitly returns the <strong class="source-inline">None</strong> value. In practice, you may not be aware of the issue because the web client uses JSON-RPC, not XML-RPC, but it is still a good practice to follow.</p>
			<p>Wizards are the most complex tools in our business logic toolbox and close out the list of techniques that will be presented in this chapter.</p>
			<p>Business logic also involves testing if the right conditions are being met before or after running some operation. The next section explains how to trigger exceptions when this doesn't happen.</p>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor258"/>Raising exceptions</h1>
			<p>There are times where the <a id="_idIndexMarker698"/>inputs are inappropriate for the task to perform, and the code needs to warn the user about it and interrupt the program's execution with an error message. This is done by raising an exception. Odoo provides exception classes that should be used in these situations.</p>
			<p>The most useful Odoo exceptions are as follows:</p>
			<p class="source-code">from odoo import exceptions</p>
			<p class="source-code">raise exceptions.ValidationError("Inconsistent data")</p>
			<p class="source-code">raise exceptions.UserError("Wrong input")</p>
			<p>The <strong class="source-inline">ValidationError</strong> exception should be used for validations in Python code, such as the ones in <strong class="source-inline">@api.constrains</strong> decorated methods.</p>
			<p>The <strong class="source-inline">UserError</strong> exception should be used in all other cases where some action should not be allowed because it goes against business logic.</p>
			<p>As a general rule, all data manipulation that's done during method execution is done in a database transaction and rolled back when an exception occurs. This means that, when an exception is raised, all of the previous data changes are canceled.</p>
			<p>Let's look at an example of using the wizard's <strong class="source-inline">button_send</strong> method. If we think about it, it doesn't make any sense to run the send message's logic if no checkout document was selected. And it doesn't make sense to send messages with no message body. Let's warn the user if any of these things happen.</p>
			<p>To do so, edit the <strong class="source-inline">button_send()</strong> method<a id="_idIndexMarker699"/> and add the following highlighted code:</p>
			<p class="source-code">    def button_send(self):</p>
			<p class="source-code">        self.ensure_one()</p>
			<p class="source-code"><strong class="bold">        if not self.checkout_ids:</strong></p>
			<p class="source-code"><strong class="bold">            raise exceptions.UserError(</strong></p>
			<p class="source-code"><strong class="bold">                "No Checkouts were selected."</strong></p>
			<p class="source-code"><strong class="bold">            )</strong></p>
			<p class="source-code"><strong class="bold">        if not self.message_body:</strong></p>
			<p class="source-code"><strong class="bold">            raise exceptions.UserError(</strong></p>
			<p class="source-code"><strong class="bold">                "A message body is required"</strong></p>
			<p class="source-code"><strong class="bold">            )</strong></p>
			<p class="source-code">        for checkout in self.checkout_ids:</p>
			<p class="source-code">            checkout.message_post(</p>
			<p class="source-code">                body=self.message_body,</p>
			<p class="source-code">                subject=self.message_subject,</p>
			<p class="source-code">                subtype='mail.mt_comment',</p>
			<p class="source-code">            )</p>
			<p class="source-code">        return True</p>
			<p>When you're using exceptions, make sure that the <strong class="source-inline">from odoo import exceptions</strong> instruction is added to the top of the code file. Adding validations is as simple as checking that <a id="_idIndexMarker700"/>some conditions have been met and raising an exception if they haven't been.</p>
			<p>The next section discusses the development tools that every Odoo developer should be familiar with. We will start with automated tests.</p>
			<h1 id="_idParaDest-255"><a id="_idTextAnchor259"/>Writing unit tests</h1>
			<p>Automated tests are generally accepted as a best practice in software. They not only help ensure code is correctly implemented, but more importantly, they provide a safety net for future code changes or rewrites.</p>
			<p>In the case of <a id="_idIndexMarker701"/>dynamic programming languages, such as Python, there is no compilation step and syntax errors can go unnoticed. Ensuring there's test code coverage is particularly important for detecting code writing mistakes, such as a mistyped identifier name.</p>
			<p>These two goals provide a guiding light to test writing. One goal should be test coverage – writing test cases that run all your lines of code.</p>
			<p>This alone will usually make good progress on the second goal, which is to verify the correctness of the code. This is because, after working on code coverage tests, we will surely have a<a id="_idIndexMarker702"/> great starting point to build additional test cases for non-trivial use cases.</p>
			<p class="callout-heading">Changes in Odoo 12</p>
			<p class="callout">In earlier Odoo versions, tests could also be described using YAML data files. With Odoo 12, the YAML data file engine was removed, and this type of file is not supported anymore. The last piece of documentation on it is available at https://doc.odoo.com/v6.0/contribute/15_guidelines/coding_guidelines_testing/.</p>
			<p>Next, we will learn how to add unit tests to a module and then run them.</p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor260"/>Adding unit tests</h2>
			<p>Add-on <a id="_idIndexMarker703"/>module tests must be added to a <strong class="source-inline">tests/</strong> subdirectory. The test runner will automatically discover tests in the subdirectories with this particular name, and the module's top <strong class="source-inline">__init__.py</strong> file should <em class="italic">not</em> import them.</p>
			<p>To add tests for the wizard logic that was created in the <strong class="source-inline">library_checkout</strong> add-on module, we will start by creating the <strong class="source-inline">tests/__init__.py</strong> file and importing the test files to be used. In this case, it should contain the following line of code:</p>
			<p class="source-code">from . import test_checkout_mass_message</p>
			<p>Then, we must create the <strong class="source-inline">tests/test_checkout_mass_message.py</strong> file and ensure it has the<a id="_idIndexMarker704"/> basic skeleton for the unit test code:</p>
			<p class="source-code">from odoo import exceptions</p>
			<p class="source-code">from odoo.tests import common</p>
			<p class="source-code">class TestWizard(common.SingleTransactionCase):</p>
			<p class="source-code">    def setUp(self, *args, **kwargs):</p>
			<p class="source-code">        super(TestWizard, self).setUp(*args, **kwargs)</p>
			<p class="source-code">        # Add test setup code here... </p>
			<p class="source-code">    def test_01_button_send(self):</p>
			<p class="source-code">        """Send button should create messages on</p>
			<p class="source-code">           Checkouts"""</p>
			<p class="source-code">        # Add test code</p>
			<p>Odoo provides a few classes to use for tests, as follows:</p>
			<ul>
				<li><strong class="source-inline">TransactionCase</strong> uses a different transaction for each test, which is automatically rolled back at the end.</li>
				<li><strong class="source-inline">SingleTransactionCase</strong> runs all the tests in a single transaction, which are only rolled back at the end of the last test. This can speed up tests significantly, but the individual tests need to be written in such a way that they are compatible.</li>
			</ul>
			<p>These test classes are wrappers around the <strong class="source-inline">unittest</strong> test cases, which are part of the Python standard library. For more details on this, you can refer to the official documentation at https://docs.python.org/3/library/unittest.html.</p>
			<p>The <strong class="source-inline">setUp()</strong> method is where test data is prepared and is usually stored as class attributes so that it is available to the test methods.</p>
			<p>Tests are<a id="_idIndexMarker705"/> implemented as class methods, such as the <strong class="source-inline">test_01_button_send()</strong> example in the previous code. The test case method names must begin with the <strong class="source-inline">test_</strong> prefix. This is what allows them to be discovered by the test runner. Test methods are run in the order of the test function names.</p>
			<p>The <strong class="source-inline">docstring</strong> method is printed to the server log when the tests are run and should be used to provide a short description of the test that's being performed.</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor261"/>Running tests</h2>
			<p>Once the tests have been <a id="_idIndexMarker706"/>written, it is time to run them. For that, you must upgrade or install the modules to test (<strong class="source-inline">-I</strong> or <strong class="source-inline">-u</strong>) and add the–<strong class="source-inline">-test-enable</strong> option to the Odoo <strong class="source-inline">server</strong> command.</p>
			<p>The command will look like this:</p>
			<p class="source-code">(env15) $ odoo -c library.conf --test-enable -u library_checkout --stop-after-init</p>
			<p>Only the installed or upgraded modules will be tested – that's why the <strong class="source-inline">-u</strong> option was used. If some dependencies need to be installed, their tests will run too. If you don't want this to happen, then install the new modules and then run the tests while upgrading (<strong class="source-inline">-u</strong>) the module to test.</p>
			<p>Although the<a id="_idIndexMarker707"/> module contains testing code, this code doesn't test anything yet and should run successfully. If we take a closer look at the server log, there should be <strong class="source-inline">INFO</strong> messages reporting the test runs, similar to this:</p>
			<p class="source-code">INFO library odoo.modules.module: odoo.addons.library_checkout.tests.test_checkout_mass_message running tests.</p>
			<p>The test code skeleton is ready. Now, the actual testing code needs to be added. We should start with setting up the data.</p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor262"/>Setting up tests</h2>
			<p>The first step when <a id="_idIndexMarker708"/>writing tests is to prepare the data to use. This is typically done in the <strong class="source-inline">setUp</strong> method. For our example, a checkout record is needed so that it can be used in the wizard tests.</p>
			<p>It is convenient to perform the test actions as a specific user to also test that access control has been configured properly. This can be achieved using the <strong class="source-inline">sudo(&lt;user&gt;)</strong> model method. Recordsets carry that information with them, so after being created using <strong class="source-inline">sudo()</strong>, later operations in the same recordset will be performed using that same context.</p>
			<p>This is the code for the <strong class="source-inline">setUp</strong> method:</p>
			<p class="source-code">from odoo import exceptions</p>
			<p class="source-code">from odoo.tests import common</p>
			<p class="source-code">class TestWizard(common.SingleTransactionCase):</p>
			<p class="source-code">    def setUp(self, *args, **kwargs):</p>
			<p class="source-code">        super().setUp(*args, **kwargs)</p>
			<p class="source-code">        # Setup test data</p>
			<p class="source-code">        admin_user = self.env.ref('base.user_admin')</p>
			<p class="source-code">        self.Checkout = self.env['library.checkout']\</p>
			<p class="source-code">            .with_user(admin_user)</p>
			<p class="source-code">        self.Wizard = self.env[</p>
			<p class="source-code">          'library.checkout.massmessage']\</p>
			<p class="source-code">            .with_user(admin_user)</p>
			<p class="source-code">        a_member = self.env['library.member']\</p>
			<p class="source-code">            .create({'partner_id': </p>
			<p class="source-code">               admin_user.partner_id.id})</p>
			<p class="source-code">        self.checkout0 = self.Checkout\</p>
			<p class="source-code">            .create({'member_id': a_member.id})</p>
			<p>Now, we <a id="_idIndexMarker709"/>can use the <strong class="source-inline">self.checkout0</strong> record and the <strong class="source-inline">self.Wizard</strong> model for our tests.</p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor263"/>Writing test cases</h2>
			<p>Now, let's expand <a id="_idIndexMarker710"/>the <strong class="source-inline">test_button_test()</strong> method that we saw in the initial skeleton to implement the tests.</p>
			<p>A basic test runs some code on the tested object, gets a result, and then uses an <strong class="source-inline">assert</strong> statement to compare it with an expected result. The message posting logic does not return any value to check, so a different approach is needed.</p>
			<p>The <strong class="source-inline">button_send()</strong> method adds a message to the message history. One way to check if this happened is to count the number of messages before and after running the method. The test code can count the number of messages before and after the wizard. The following code adds this:</p>
			<p class="source-code">    def test_01_button_send(self):</p>
			<p class="source-code">        """Send button creates messages on Checkouts"""</p>
			<p class="source-code">        count_before = len(self.checkout0.message_ids)</p>
			<p class="source-code">        # TODO: run wizard</p>
			<p class="source-code"><strong class="bold">        count_after = len(self.checkout0.message_ids)</strong></p>
			<p class="source-code"><strong class="bold">        self.assertEqual(</strong></p>
			<p class="source-code"><strong class="bold">            count_before + 1,</strong></p>
			<p class="source-code"><strong class="bold">            count_after,</strong></p>
			<p class="source-code"><strong class="bold">            "Expected one additional message in the </strong></p>
			<p class="source-code"><strong class="bold">             Checkout.",</strong></p>
			<p class="source-code"><strong class="bold">        )</strong></p>
			<p>The check for verifying whether the test succeeded or failed is the <strong class="source-inline">self.assertEqual</strong> statement. It compares the number of messages before and after running the wizard. It is expected to find one more message than it did previously. The last parameter provides an optional but recommended message that's printed when the test fails.</p>
			<p>The <strong class="source-inline">assertEqual</strong> function is just one of the assert methods that's available. The appropriate assert function should be selected for the check to perform. The <strong class="source-inline">unittest</strong> documentation provides a good reference for all of the methods. It can be found at https://docs.python.org/3/library/unittest.html#test-cases.</p>
			<p>Running the wizard is not straightforward, and the user interface workflow needs to be mimicked. Recall that the environment's context is used to pass data to the wizard, on the <strong class="source-inline">active_ids</strong> key. We must create a wizard record with the values that have been filled in the wizard <a id="_idIndexMarker711"/>form for the message subject and body and then run the <strong class="source-inline">button_send</strong> method.</p>
			<p>The complete code looks like this:</p>
			<p class="source-code">    def test_01_button_send(self):</p>
			<p class="source-code">        """Send button creates messages on Checkouts"""</p>
			<p class="source-code">        count_before = len(self.checkout0.message_ids)</p>
			<p class="source-code">        <strong class="bold">Wizard0 = self.Wizard\</strong></p>
			<p class="source-code"><strong class="bold">            .with_context(active_ids=self.checkout0.ids)</strong></p>
			<p class="source-code"><strong class="bold">        wizard0 = Wizard0.create({</strong></p>
			<p class="source-code"><strong class="bold">            "message_subject": "Hello",</strong></p>
			<p class="source-code"><strong class="bold">            "message_body": "This is a message.",</strong></p>
			<p class="source-code"><strong class="bold">        })</strong></p>
			<p class="source-code"><strong class="bold">        wizard0.button_send()</strong></p>
			<p class="source-code">        count_after = len(self.checkout0.message_ids)</p>
			<p class="source-code">        self.assertEqual(</p>
			<p class="source-code">            count_before + 1,</p>
			<p class="source-code">            count_after,</p>
			<p class="source-code">            "Expected one additional message in the </p>
			<p class="source-code">             Checkout.",</p>
			<p class="source-code">        )</p>
			<p>The <strong class="source-inline">with_context</strong> model method is used to add <strong class="source-inline">active_ids</strong> to the environment's context. Then, the <strong class="source-inline">create()</strong> method is used to create the wizard record and add the user-entered data. Finally, the <strong class="source-inline">button_send</strong> method is called.</p>
			<p>More test cases are added with additional methods for the test class. Remember, with <strong class="source-inline">TransactionCase</strong> tests, a rollback is done at the end of each test and the operations that were <a id="_idIndexMarker712"/>performed in the previous test are reverted. With <strong class="source-inline">SingleTransactionCase</strong>, tests build each other up, and the test run sequence is important. Since tests are run in alphabetical order, the names that are chosen for the test methods are relevant. To make this clearer, it is a good practice to add a number at the beginning of the test method names, as we did in the preceding example.</p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor264"/>Testing exceptions</h2>
			<p>In some cases, the code is<a id="_idIndexMarker713"/> expected to raise an exception, and that should also be tested. For example, we can test whether validation is being performed correctly.</p>
			<p>Continuing with the wizard tests, validation is performed to check for an empty message body. A test can be added to check that this validation is done properly.</p>
			<p>To check whether an exception has been raised, the corresponding code must be placed inside a <strong class="source-inline">with self.assertRaises()</strong> code block.</p>
			<p>Another method should be added for this test, as follows:</p>
			<p class="source-code">    def test_02_button_send_empty_body(self):</p>
			<p class="source-code">        """Send button errors on empty body message"""</p>
			<p class="source-code">        Wizard0 = self.Wizard\</p>
			<p class="source-code">            .with_context(active_ids=self.checkout0.ids)</p>
			<p class="source-code">        wizard0 = Wizard0.create({})</p>
			<p class="source-code">        with self.assertRaises(exceptions.UserError) as e:</p>
			<p class="source-code">            wizard0.button_send()</p>
			<p>If the <strong class="source-inline">button_send()</strong> method doesn't raise <strong class="source-inline">UserException</strong>, the test will fail. If it does raise that exception, the test will succeed. The exception that's raised is stored in the <strong class="source-inline">e</strong> variable, which<a id="_idIndexMarker714"/> could be inspected by additional method commands – for example, to verify the content of the error message.</p>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor265"/>Using log messages</h1>
			<p>Writing <a id="_idIndexMarker715"/>messages to the log file is useful for monitoring and auditing running systems. It can also help with code maintenance, making it easier to get debug information from running processes, without the need to change code.</p>
			<p>To use logging in Odoo code, first, a logger object must be prepared. For this, add the following code lines at the top of the <strong class="source-inline">library_checkout/wizard/checkout_mass_message.py</strong> file:</p>
			<p class="source-code">import logging</p>
			<p class="source-code">_logger = logging.getLogger(__name__)</p>
			<p>The <strong class="source-inline">logging</strong> Python standard library module is being used here. The <strong class="source-inline">_logger</strong> object is initialized using the name of the current code file, <strong class="source-inline">__name__</strong>. With this, the log messages will include information about the file that generated them.</p>
			<p>There are several levels available for log messages. These are as follows:</p>
			<p class="source-code">_logger.debug('A DEBUG message') </p>
			<p class="source-code">_logger.info('An INFO message') </p>
			<p class="source-code">_logger.warning('A WARNING message') </p>
			<p class="source-code">_logger.error('An ERROR message')</p>
			<p>We can now use the logger to write messages to the Odoo server log.</p>
			<p>This log can be added to the <strong class="source-inline">button_send</strong> wizard method. Add the following instruction before the ending line; that is, <strong class="source-inline">return True</strong>:</p>
			<p class="source-code">        _logger.info(</p>
			<p class="source-code">            "Posted %d messages to the Checkouts: %s",</p>
			<p class="source-code">            len(self.checkout_ids),</p>
			<p class="source-code">            str(self.checkout_ids),</p>
			<p class="source-code">        )</p>
			<p>With<a id="_idIndexMarker716"/> this code, when the wizard is used to send messages, a message similar to the following will be printed to the server log:</p>
			<p class="source-code">INFO library odoo.addons.library_checkout.wizard.checkout_mass_message: Posted 2 messages to the Checkouts: [3, 4]</p>
			<p>Notice that Python string interpolation – that is, using the <strong class="source-inline">%</strong> operator – was not used in the log message. More specifically, instead of <strong class="source-inline">_logger.info("Hello %s" % "World")</strong>, what was used was something like <strong class="source-inline">_logger.info("Hello %s", "World")</strong>. Not using interpolation means one less task for the code to perform at runtime, which makes logging more efficient. So, the variables should always be provided as additional log parameters.</p>
			<p>The timestamps of server log messages always use UTC. This may come as a surprise and comes from the fact that the Odoo server internally handles all dates in UTC.</p>
			<p>For debug-level log messages, <strong class="source-inline">_logger.debug()</strong> is used. As an example, add the following debug log message right after the <strong class="source-inline">checkout.message_post()</strong> instruction:</p>
			<p class="source-code">            _logger.debug(</p>
			<p class="source-code">                "Message on %d to followers: %s",</p>
			<p class="source-code">                checkout.id,</p>
			<p class="source-code">                checkout.message_follower_ids)</p>
			<p>By default, this won't print anything to the server log, since the default log level is <strong class="source-inline">INFO</strong>. The log level needs to be set to <strong class="source-inline">DEBUG</strong> for the debug messages to be printed to the log.</p>
			<p>The Odoo <strong class="source-inline">--log-level</strong> command option sets the general log level. For example, adding <strong class="source-inline">--log-level=debug</strong> to the command line enables all debug log messages.</p>
			<p>This can be fine-tuned and have a specific log level set only for particular modules. To enable debug messages only for this wizard code, use the <strong class="source-inline">--log-handler</strong> option. This can be used several times to set the log level for several modules.</p>
			<p>For example, the Python module for the wizard is <strong class="source-inline">odoo.addons.library_checkout.wizard.checkout_mass_message</strong>, as shown in the <strong class="source-inline">INFO</strong> log messages. To set a debug log level for it, use the following command-line option:</p>
			<p class="source-code">--log-handler=</p>
			<p class="source-code">odoo.addons.library_checkout.wizard.checkout_mass_message:DEBUG</p>
			<p>The<a id="_idIndexMarker717"/> complete reference to the Odoo server logging options can be found in the official documentation: <a href="https://www.odoo.com/documentation/15.0/developer/misc/other/cmdline.html">https://www.odoo.com/documentation/15.0/developer/misc/other/cmdline.html</a>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you want to get into the nitty-gritty details of Python logging, the official documentation is a good place to start: <a href="https://docs.python.org/3/library/logging.html">https://docs.python.org/3/library/logging.html</a>.</p>
			<p>Logging is a useful tool, but it's short when it comes to debugging. There are a few tools and techniques that are available to help developers with their work. We'll look at these in the next section.</p>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor266"/>Learning about the available developer tools</h1>
			<p>There are a few tools to ease developers' work. The web interface's <strong class="bold">Developer Mode</strong>, which we introduced earlier in this book, is one of them. A server developer mode option is also available that provides some developer-friendly features. It will be explained in more detail next. After that, we will discuss how to debug code on the server.</p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor267"/>Server development options</h2>
			<p>The Odoo server provides a <strong class="source-inline">--dev</strong> option, which enables developer features to speed up the development cycle, such as the following:</p>
			<ul>
				<li>Entering the debugger<a id="_idIndexMarker718"/> when an exception is found in an add-on module. This is done by setting a debugger. <strong class="source-inline">pdb</strong> is the default one.</li>
				<li>Reloading Python code automatically when a Python code file is saved, avoiding a manual server restart. This can be enabled with the <strong class="source-inline">reload</strong> option.</li>
				<li>Reading view definitions directly from XML files, avoiding manual module upgrades. This can be enabled with the <strong class="source-inline">xml</strong> option.</li>
				<li>A Python debugging interface is used directly in the web browser. This can be enabled with the <strong class="source-inline">werkzeug</strong> option.</li>
			</ul>
			<p>The <strong class="source-inline">--dev</strong> option accepts a comma-separated list of options. The <strong class="source-inline">all</strong> option can be used to conveniently enable all of these options using <strong class="source-inline">--dev=all</strong>.</p>
			<p>When you're enabling a debugger, the Odoo server will use <strong class="source-inline">pdb</strong> by default, but other options can be used if they've been installed in your system. The supported alternatives are as follows:</p>
			<ul>
				<li><strong class="source-inline">ipdb</strong>; see <a href="https://pypi.org/project/ipdb">https://pypi.org/project/ipdb</a> for <a id="_idIndexMarker719"/>details.</li>
				<li><strong class="source-inline">pudb</strong>; see <a href="https://pypi.org/project/pudb">https://pypi.org/project/pudb</a> for <a id="_idIndexMarker720"/>details.</li>
				<li><strong class="source-inline">wdb</strong>; see <a href="https://pypi.org/project/wdb">https://pypi.org/project/wdb</a> for <a id="_idIndexMarker721"/>details.</li>
			</ul>
			<p>When you're editing Python code, the server needs to be restarted every time the code is changed so that the latest code is reloaded and used by Odoo. The <strong class="source-inline">--dev=reload</strong> option automates this reloading. When enabled, the Odoo server detects changes that have been made to code files and automatically triggers code reloading, making the code changes effective immediately.</p>
			<p>For the code reload to work, the <strong class="source-inline">watchdog</strong> Python package is required. It can be installed with the<a id="_idIndexMarker722"/> following command:</p>
			<p class="source-code">(env15) $ pip3 install watchdog</p>
			<p>The <strong class="source-inline">--dev=all</strong> server command option also enables <strong class="source-inline">reload</strong>, and it is what is used most of the time:</p>
			<p class="source-code">(env15) $ odoo -c library.conf --dev=all</p>
			<p>Note that this is only useful for Python code changes. For other changes, such as changing the model's data structure, a module upgrade is needed; reloading it is not enough.</p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor268"/>Debugging</h2>
			<p>A big part of a developer's work is debugging code. For this, it is convenient to be able to set breakpoints and run the code step by step.</p>
			<p>Odoo is a server<a id="_idIndexMarker723"/> that runs Python code that waits for client requests, which are processed by the relevant server code, and then returns a response to the client. This means that Python code debugging is done on the server side. Breakpoints are activated in the server, pausing the server's execution on that line of code. So, the developer needs access to the terminal window running the server both to set breakpoints and to operate the debugger when those breakpoints are triggered.</p>
			<h3>The Python debugger</h3>
			<p>The simplest debugging tool that's available is the <a id="_idIndexMarker724"/>Python integrated debugger, <strong class="source-inline">pdb</strong>. However, other <a id="_idIndexMarker725"/>options are available that provide a richer user interface, closer to what sophisticated IDEs usually provide.</p>
			<p>There are two ways a debugger prompt can be triggered.</p>
			<p>One is when an unhandled exception is raised and the <strong class="source-inline">--dev=all</strong> option is enabled. The debugger will stop the code's execution at the instruction causing the exception. The developer can then inspect the variables and program state at that moment, to gain a better understanding of what is causing it.</p>
			<p>The other way is to manually set a breakpoint by editing the code and adding the following line where the execution should pause:</p>
			<p class="source-code">import pdb; pdb.set_trace()</p>
			<p>This does not require the <strong class="source-inline">–dev</strong> mode to be enabled. An Odoo server reload is needed for the changed code to be used. When the program execution reaches the <strong class="source-inline">pdb.set_trace()</strong> command, a <strong class="source-inline">(pdb)</strong> Python prompt will be shown in the server's terminal window, waiting for input.</p>
			<p>The <strong class="source-inline">(pdb)</strong> prompt<a id="_idIndexMarker726"/> works as a Python shell and can run any expression or <a id="_idIndexMarker727"/>command in the current execution context. This means that the current variables can be inspected and even modified.</p>
			<p>A few debugger-specific commands are also available. These are the most important commands that are available:</p>
			<ul>
				<li><strong class="source-inline">h</strong> (help) displays a summary of the available <strong class="source-inline">pdb</strong> commands.</li>
				<li><strong class="source-inline">p</strong> (print) evaluates and prints an expression.</li>
				<li><strong class="source-inline">pp</strong> (pretty-print) is useful to print data structures, such as dictionaries or lists.</li>
				<li><strong class="source-inline">l</strong> (list) lists the code around the instruction to be executed next.</li>
				<li><strong class="source-inline">n</strong> (next) steps over to the next instruction.</li>
				<li><strong class="source-inline">s</strong> (step) steps into the current instruction.</li>
				<li><strong class="source-inline">c</strong> (continue) continues execution normally.</li>
				<li><strong class="source-inline">u</strong> (up) moves up in the execution stack.</li>
				<li><strong class="source-inline">d</strong> (down) moves down in the execution stack.</li>
				<li><strong class="source-inline">bt</strong> (backtrace) shows the current execution stack.</li>
			</ul>
			<p>The Python official documentation includes a complete description of the <strong class="source-inline">pdb</strong> commands: <a href="https://docs.python.org/3/library/pdb.html#debugger-commands">https://docs.python.org/3/library/pdb.html#debugger-commands</a>.</p>
			<h3>A sample debugging session</h3>
			<p>To understand how to use the debugger's features, let's see what a<a id="_idIndexMarker728"/> debugging session looks like.</p>
			<p>Start by adding a debugger breakpoint to the first line of the <strong class="source-inline">button_send()</strong> wizard method, as follows:</p>
			<p class="source-code">    def button_send(self):</p>
			<p class="source-code"><strong class="bold">        import pdb; pdb.set_trace()</strong></p>
			<p class="source-code">        self.ensure_one()</p>
			<p class="source-code">        # ...</p>
			<p>After performing a server reload, open the <strong class="bold">Send Message</strong> wizard form and click on the <strong class="bold">Send Messages</strong> button. This will trigger the <strong class="source-inline">button_send()</strong> method on the server, which will pause at the breakpoint. The web client will stay in a <strong class="bold">Loading…</strong> state while it is waiting for the server's response.</p>
			<p>At that point, the terminal window where the server is running should display something similar to this:</p>
			<p class="source-code">&gt; /home/daniel/work15/library/library_checkout/wizard</p>
			<p class="source-code">/checkout_mass_message.py(29)button_send()</p>
			<p class="source-code">-&gt; self.ensure_one()</p>
			<p class="source-code">(Pdb)</p>
			<p>This is the <strong class="source-inline">pdb</strong> debugger<a id="_idIndexMarker729"/> prompt, and the two previous lines provide information about where the Python code execution was paused. The first line shows the file, line number, and function name, while the second line is the code in that line that will be run next.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">During a debug session, server log messages can creep in. Most of these are from the <strong class="source-inline">werkzeug</strong> module. They can be silenced by adding the <strong class="source-inline">--log-handler=werkzeug:WARNING</strong> option to the Odoo command. Another option is to lower the general log verbosity using <strong class="source-inline">--log-level=warn</strong>.</p>
			<p>Typing <strong class="source-inline">h</strong> shows a quick reference of the available commands. Typing <strong class="source-inline">l</strong> shows the current line of code and the surrounding lines of code.</p>
			<p>Typing <strong class="source-inline">n</strong> runs the current line of code and moves to the next one. Pressing <em class="italic">Enter</em> repeats the previous command.</p>
			<p>The <strong class="source-inline">p</strong> debug command prints out the result of an expression, while <strong class="source-inline">pp</strong> does the same but formats the output to be more readable, especially the <strong class="source-inline">dict</strong> and <strong class="source-inline">list</strong> data structures. For example, to print the value for the <strong class="source-inline">checkout_ids</strong> field that's used in the wizard, type the following:</p>
			<p class="source-code">(pdb) self.checkout_ids</p>
			<p class="source-code">library.checkout(1,)</p>
			<p class="source-code">(Pdb)</p>
			<p>The debug prompt can run Python commands and expressions. Any Python expressions are allowed, even variable assignments.</p>
			<p>When you're done with a <a id="_idIndexMarker730"/>debugging session, type <strong class="source-inline">c</strong> to continue the normal program execution. In some cases, you may want to interrupt the execution, and <strong class="source-inline">q</strong> can be used to quit.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">When you go back from the debugger to the terminal prompt, the terminal may look unresponsive, and any typed text won't be printed to the terminal. This can be solved by using the <strong class="source-inline">reset</strong> command; that is, by typing <strong class="source-inline">&lt;enter&gt;reset&lt;enter&gt;</strong>.</p>
			<h3>Alternative Python debuggers</h3>
			<p>While <strong class="source-inline">pdb</strong> has the advantage of being available out of the box, it can be quite terse. Fortunately, a few more comfortable options exist.</p>
			<p>The IronPython debugger, <strong class="source-inline">ipdb</strong>, is a<a id="_idIndexMarker731"/> popular choice that uses the same commands as <strong class="source-inline">pdb</strong> but adds improvements such as tab completion and syntax highlighting for more comfortable usage. It can be installed with the following command:</p>
			<p class="source-code">$ pip3 install ipdb</p>
			<p>To add a breakpoint, use the following command:</p>
			<p class="source-code">import ipdb; ipdb.set_trace()</p>
			<p>Another alternative debugger is <strong class="source-inline">pudb</strong>. It also <a id="_idIndexMarker732"/>supports the same commands as <strong class="source-inline">pdb</strong> and works in text terminals, but it uses a window-like graphical display. Useful information, such as the variables in the current context and their values, is readily available on the screen in separate windows.</p>
			<p>It can be installed either through the system package manager or through <strong class="source-inline">pip</strong>, as shown here:</p>
			<p class="source-code">$ sudo apt-get install python-pudb  # using Debian OS packages</p>
			<p class="source-code">$ pip3 install pudb  # or using pip, possibly in a virtualenv</p>
			<p>A breakpoint can be added in a way similar to <strong class="source-inline">pdb</strong>:</p>
			<p class="source-code">import pudb; pudb.set_trace()</p>
			<p>A short version is also available:</p>
			<p class="source-code">import pudb; pu.db</p>
			<p>The preceding code can be typed faster and also provides the intended effect – to add a code execution breakpoint.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Since Python 3.7, breakpoints can be simplified by using the <strong class="source-inline">breakpoint()</strong> function instead of <strong class="source-inline">pdb.set_trace()</strong>. Debugging libraries can overwrite the <strong class="source-inline">breakpoint()</strong> behavior to directly call them. However, at the time of writing, <strong class="source-inline">pudb</strong> and <strong class="source-inline">ipdb</strong> aren't doing this, so there is no benefit to using <strong class="source-inline">breakpoint()</strong> with them.</p>
			<h3>Printing messages and logging</h3>
			<p>Sometimes, we just need to<a id="_idIndexMarker733"/> inspect the values of some variables or check whether some code blocks are being executed. A Python <strong class="source-inline">print()</strong> instruction can do the job perfectly without stopping the flow of execution. Note that the printed text is sent to the standard output and won't be stored in the server log if it is being written to a file.</p>
			<p>The <strong class="source-inline">print()</strong> function<a id="_idIndexMarker734"/> is only being used as a development aid and should not make its way to the final code, ready to be deployed. If the <strong class="source-inline">print</strong> statements can also help investigate issues in a production system, consider converting them into debug-level log <a id="_idIndexMarker735"/>messages.</p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor269"/>Inspecting and killing running processes</h2>
			<p>There are also a few tricks <a id="_idIndexMarker736"/>that allow us to inspect running Odoo processes.</p>
			<p>First, find the server instance's <strong class="bold">process ID</strong> (<strong class="bold">PID</strong>). This number is printed with each log message, right after the timestamp. Another way to find the PID is to run the following command in another terminal window:</p>
			<p class="source-code">$ ps ax | grep odoo</p>
			<p>Here is a sample output:</p>
			<p class="source-code"> 2650 pts/5  S+   0:00 grep --color=auto odoo</p>
			<p class="source-code">21688 pts/4  Sl+  0:05 python3 /home/daniel/work15/env15/bin/odoo</p>
			<p>The first column in the output is the PID of the processes. In this example, <strong class="source-inline">21688</strong> is the Odoo process PID.</p>
			<p>Now that we know the process PID, signals can be sent to that Odoo server process. The <strong class="source-inline">kill</strong> command is used to<a id="_idIndexMarker737"/> send these signals. By default, <strong class="source-inline">kill</strong> sends a signal to terminate a process, but it can also send other, friendlier signals.</p>
			<p>The Odoo server will print out the stack trace at the code currently being executed if it's sent a <strong class="source-inline">SIGQUIT</strong> or <strong class="source-inline">-3</strong> signal:</p>
			<p class="source-code">$ kill -3 &lt;PID&gt;</p>
			<p>After sending <strong class="source-inline">SIGQUIT</strong>, the Odoo server log will display a stack trace. This can be useful for understanding what code was being executed at that point. This information is printed for each of the threads being used.</p>
			<p>It is used by some code profiling approaches to track where the server is spending time and profile the code's execution. Some useful information on code profiling is given in the official documentation at <a href="https://www.odoo.com/documentation/15.0/howtos/profilecode.html">https://www.odoo.com/documentation/15.0/howtos/profilecode.html</a>.</p>
			<p>Other signals we can send to the Odoo server process include <strong class="source-inline">HUP</strong>, to reload the server, and <strong class="source-inline">INT</strong> or <strong class="source-inline">TERM</strong> to force the server to shut down, as follows:</p>
			<p class="source-code">$ kill -HUP &lt;PID&gt;</p>
			<p class="source-code">$ kill -TERM &lt;PID&gt;</p>
			<p>The HUP signal can be particularly useful for reloading the Odoo configuration without stopping the server.</p>
			<h1 id="_idParaDest-266"><a id="_idTextAnchor270"/>Summary</h1>
			<p>In this chapter, we explored the various features of the ORM API and how to use them to create dynamic applications that react to users, which helps them avoid errors and automate tedious tasks.</p>
			<p>The model validations and computed fields can cover a lot of use cases, but not all. We learned how to extend the API's create, write, and unlink methods to cover further use cases.</p>
			<p>For rich user interaction, we used the <strong class="source-inline">mail</strong> core add-on mixins to add features for users to communicate about documents and plan activities on them. Wizards allow the application to dialogue with the user and gather the data that's needed to run particular processes. Exceptions allow the application to abort incorrect operations, informing the user of the problem and rolling back intermediate changes, keeping the system consistent.</p>
			<p>We also discussed the tools that are available for developers to create and maintain their applications: logging messages, debugging tools, and unit tests.</p>
			<p>In the next chapter, we will still be working with the ORM, but we will be looking at this from the point of view of an external application: we will be working with the Odoo server as a backend for storing data and running business processes.</p>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor271"/>Further reading</h1>
			<p>The following are the most relevant reference materials for the topics that were discussed in this chapter:</p>
			<ul>
				<li>ORM reference: <a href="https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html">https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html</a></li>
				<li>Message and activities features: <a href="https://www.odoo.com/documentation/15.0/developer/reference/backend/mixins.html">https://www.odoo.com/documentation/15.0/developer/reference/backend/mixins.html</a></li>
				<li>Odoo tests reference: <a href="https://www.odoo.com/documentation/15.0/developer/reference/backend/testing.html">https://www.odoo.com/documentation/15.0/developer/reference/backend/testing.html</a></li>
				<li>Python <strong class="source-inline">unittest</strong> reference: <a href="https://docs.python.org/3/library/unittest.html#module-unittest">https://docs.python.org/3/library/unittest.html#module-unittest</a></li>
			</ul>
		</div>
	</div></body></html>