- en: Chapter 5. Interacting with Social Media Using Requests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 使用Requests与社交媒体交互
- en: In this contemporary world, our lives are woven with a lot of interactions and
    collaborations with social media. The information that is available on the web
    is very valuable and it is being used by abundant resources. For instance, the
    news that is trending in the world can be spotted easily from a Twitter hashtag
    and this can be achieved by interacting with the Twitter API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个当代世界中，我们的生活与社交媒体的互动和协作紧密相连。网络上的信息非常宝贵，并且被大量资源所利用。例如，世界上的热门新闻可以通过Twitter标签轻松找到，这可以通过与Twitter
    API的交互来实现。
- en: Using natural language processing, we can classify emotion of a person by grabbing
    the Facebook status of an account. All this stuff can be accomplished easily with
    the help of Requests using the concerned APIs. Requests is a perfect module, if
    we want to reach out API frequently, as it supports pretty much everything, like
    caching, redirection, proxies, and so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用自然语言处理，我们可以通过抓取账户的Facebook状态来分类一个人的情绪。所有这些都可以通过使用Requests和相关的API轻松完成。如果我们要频繁地调用API，Requests是一个完美的模块，因为它几乎支持所有功能，如缓存、重定向、代理等等。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中将涵盖以下主题：
- en: Interacting with Twitter
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Twitter互动
- en: Interacting with Facebook
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Facebook互动
- en: Interacting with reddit
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Reddit 互动
- en: API introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 简介
- en: Before diving into details, let us have a quick look at what exactly is an **Application
    Programming Interface** (**API**).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入细节之前，让我们快速了解一下**应用程序编程接口**（**API**）究竟是什么。
- en: 'A web API is a set of rules and specifications. It assists us to communicate
    with different software. There are different types of APIs, and REST API is the
    subject matter here. **REpresentational State Transfer** (**REST**) is an architecture
    containing guidelines for building scalable web services. An API which adheres
    to the guidelines and conforms to the constraints of REST is called a **RESTful**
    **API**. In a nutshell, the constraints are:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 网络API是一套规则和规范。它帮助我们与不同的软件进行通信。API有不同类型，而本例中讨论的是REST API。**表征状态转移**（**REST**）是一种包含构建可扩展网络服务指南的架构。遵循这些指南并符合REST约束的API被称为**RESTful
    API**。简而言之，约束包括：
- en: Client-server
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端-服务器
- en: Stateless
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态
- en: Cacheable
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可缓存
- en: Layered system
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分层系统
- en: Uniform interface
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统一接口
- en: Code on demand
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按需编码
- en: Google Maps API, Twitter API, and GitHub API are various examples RESTful APIs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Google Maps API、Twitter API 和 GitHub API 是各种 RESTful API 的示例。
- en: Let us understand much more about an API. Take an instance of getting all tweets
    from Twitter with the hashtag "worldtoday" which includes the process of authenticating,
    sending requests and receiving responses from different URLs, and dealing with
    different methods. All the said processes and the procedures will be specified
    in the API of Twitter. By following these procedures, we can collaborate with
    the web smoothly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解API。以获取带有“worldtoday”标签的所有Twitter推文为例，这包括认证过程、向不同URL发送请求并接收响应，以及处理不同的方法。所有这些过程和步骤都将由Twitter的API指定。通过遵循这些步骤，我们可以与网络顺利协作。
- en: Getting started with the Twitter API
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Twitter API 入门
- en: To get started with Twitter API we should first obtain an API key. It is a code
    which is passed by the computer programs while calling an API. The basic purpose
    of the API key is that it uniquely identifies the program that it is trying to
    interact with. It also serves us in the process of authentication with its token.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Twitter API，我们首先需要获取一个API密钥。这是一个在调用API时由计算机程序传递的代码。API密钥的基本目的是它能够唯一地识别它试图与之交互的程序。它还通过其令牌在我们进行身份验证的过程中为我们提供服务。
- en: The next step involves the process of creating an authentication request which
    will give us access to the Twitter account. Once we have authenticated successfully,
    we will be free to deal with tweets, followers, trends, searches, and stuff. Let
    us get to know more about the steps to follow.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步涉及创建一个认证请求的过程，这将使我们能够访问Twitter账户。一旦我们成功认证，我们将可以自由地处理推文、关注者、趋势、搜索等内容。让我们来了解一下需要遵循的步骤。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that, we will be using the Twitter API 1.1 version in all the examples.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在所有示例中，我们将使用Twitter API 1.1版本。
- en: Obtaining an API Key
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取API密钥
- en: 'Getting an API key is pretty simple. You need to follow the steps prescribed
    in the following section:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 获取API密钥非常简单。您需要遵循以下章节中规定的步骤：
- en: At first, you need to sign into the page [https://apps.twitter.com/](https://apps.twitter.com/)
    with your your Twitter credentials.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要使用您的Twitter凭证登录到页面[https://apps.twitter.com/](https://apps.twitter.com/)。
- en: Click on **Create New App** button.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建新应用**按钮。
- en: 'Now, you need to fill the following fields to set up a new application:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您需要填写以下字段以设置新的应用程序：
- en: '**Name**: Specify your application name. This is used to attribute the source
    of a tweet and in user-facing authorization screens.'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：指定您的应用程序名称。这用于归因于推文的来源以及在面向用户的授权屏幕中。'
- en: '**Description**: Enter a short description of your application. This will be
    shown when a user faces the authorization screens.'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：输入您应用的简短描述。当用户面对授权界面时，将显示此描述。'
- en: '**Website**: Specify your fully qualified website URL. A fully qualified URL
    includes http:// or https:// and will not have a trailing slash in the end (for
    example: `http://example.com` or `http://www.example.com`).'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网站**: 指定您的完整网站URL。一个完整的URL包括http://或https://，并且末尾不会带有斜杠（例如：`http://example.com`或`http://www.example.com`）。'
- en: '**Callback URL**: This field answers the question—where should we return after
    successfully authenticating.'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回调 URL**：此字段回答了问题——在成功认证后我们应该返回哪里。'
- en: '**Developer Agreement**: Read the **Developer Agreement** carefully and then
    check the checkbox **Yes, I agree**.'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发者协议**：仔细阅读**开发者协议**，然后勾选**是，我同意**。'
- en: Now, by clicking on **Create your Twitter application,** a new application will
    be created for us with the previously specified details.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过点击**创建您的Twitter应用**，将为我们创建一个包含之前指定详情的新应用。
- en: After the successful creation, we'll be redirected to a page where the **Details**
    tab is selected by default. Now, select the **Keys and Access Tokens** tab. We
    should click on **Create my access token** button to generate our access token.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功创建后，我们将被重定向到一个页面，其中默认选中了**详情**标签页。现在，请选择**密钥和访问令牌**标签页。我们应该点击**创建我的访问令牌**按钮来生成我们的访问令牌。
- en: Lastly, make a note of the **Consumer Key (API Key)**, **Consumer Secret (API
    Secret)**, **Access Token** and **Access Token Secret**.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，记下**消费者密钥（API密钥）**、**消费者密钥（API密钥）**、**访问令牌**和**访问令牌密钥**。
- en: Creating an authentication Request
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个认证请求
- en: If we remember the theme of the third chapter, we learned different kinds of
    authentication with `requests`, such as Basic authentication, Digest authentication,
    and OAuth authentication. Time to apply all that stuff in real time!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还记得第三章的主题，我们学习了使用 `requests` 进行不同类型的身份验证，例如基本身份验证、摘要身份验证和 OAuth 身份验证。现在是时候将这些知识应用到实际中了！
- en: 'Now, we will be using OAuth1 authentication to get the access to the Twitter
    API. In the first step of obtaining a key, we got access to Consumer key, Consumer
    secret, Access token and Access token secret, now we should use them to authenticate
    our application. The following commands show how we can accomplish the process:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用OAuth1认证来获取访问Twitter API的权限。在获取密钥的第一步中，我们获得了消费者密钥、消费者密钥密钥、访问令牌和访问令牌密钥，现在我们应该使用它们来验证我们的应用程序。以下命令展示了我们如何完成这个过程：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding lines, we have sent our keys and tokens to the API and got
    ourselves authenticated and stored them in the variable `auth`. Now, we can do
    all sorts of interactions with the API using this. Let us start to interact with
    the Twitter API.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的行中，我们已经将我们的密钥和令牌发送到API，并完成了身份验证，并将它们存储在变量`auth`中。现在，我们可以使用这个变量进行各种与API的交互。让我们开始与Twitter
    API进行交互。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Keep in mind that, all the twitter interacting examples that are depicted after
    this will be using the "auth" value obtained in the previous section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在此之后展示的所有推特互动示例都将使用上一节中获得的“auth”值。
- en: Getting your favorite tweet
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取你喜欢的推文
- en: 'Let us grab some favorite tweets of the authenticated user first. For this,
    we should send a request to the Twitter API to access the favorite tweets. The
    request can be sent with a `Resource URL` by specifying the parameters. The `Resource
    URL` for getting the favorite list looks like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们获取认证用户的几个喜欢的推文。为此，我们应该向Twitter API发送请求以访问喜欢的推文。可以通过指定参数通过`资源URL`发送请求。获取喜欢的列表的`资源URL`看起来像这样：
- en: '`https://api.twitter.com/1.1/favorites/list.json`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://api.twitter.com/1.1/favorites/list.json`'
- en: We can also send some optional parameters to the URL like `user_id`, `screen_name`,
    `count`, `since_id`, `max_id`, `include_identities` to accomplish our needs. Let
    us get one favorite tweet now.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以向URL发送一些可选参数，如`user_id`、`screen_name`、`count`、`since_id`、`max_id`、`include_identities`，以满足我们的需求。现在让我们获取一条喜欢的推文。
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the first step, we sent a `get` request with the parameter `count` and the
    authentication `auth` to the resource URL. In the next step, we accessed the response
    within the JSON format which gave us my favorite tweet, and it is that simple.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们向资源URL发送了一个带有参数`count`和认证`auth`的`get`请求。在下一步中，我们访问了以JSON格式返回的响应，其中包含了我最喜欢的推文，就这么简单。
- en: As we have specified the count parameter as `1` in the request, we happened
    to see the result with one favorite tweet. By default, if we don't specify the
    optional parameter `count,` the request will result in `20` most recent favorite
    tweets.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在请求中指定了计数参数为`1`，我们偶然看到了一条喜欢的推文的结果。默认情况下，如果我们没有指定可选参数`count`，请求将返回`20`条最近的喜欢的推文。
- en: Performing a simple search
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行简单搜索
- en: 'We shall make a search with a Twitter''s API now. For this, we will be making
    use of `Search API` of Twitter. The basic URL structure for searching has the
    following syntax:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用Twitter的API进行搜索。为此，我们将利用Twitter的`Search API`。搜索的基本URL结构具有以下语法：
- en: '`https://api.twitter.com/1.1/search/tweets.json?q=%40twitterapi`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://api.twitter.com/1.1/search/tweets.json?q=%40twitterapi`'
- en: It has got additional parameters like `Result type`, `Geolocation`, `language`,
    `Iterating in a result set`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 它还增加了额外的参数，如`结果类型`、`地理位置`、`语言`、`在结果集中迭代`。
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, we tried to search for tweets with the words `python`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们尝试搜索包含单词`python`的推文。
- en: Accessing the list of followers
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问关注者列表
- en: 'Let us access the followers of a specified user. By default, when we query
    for the list of followers, it returns the `20` most recent following users. The
    resource URL looks like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们访问指定用户的关注者。默认情况下，当我们查询关注者列表时，它返回最近的`20`位关注用户。资源URL看起来像这样：
- en: '`https://api.twitter.com/1.1/followers/list.json`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://api.twitter.com/1.1/followers/list.json`'
- en: 'It returns a cursored collection of user objects for users following the specified
    user:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回指定用户关注的用户对象的带光标集合：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Retweets
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转发
- en: 'A tweet which has been reposted is called a **retweet**. To access the most
    recent retweets that have been authored by the authenticated user, we will be
    using the following URL:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 被转发过的推文称为**转发推文**。要访问由认证用户创建的最新转发推文，我们将使用以下网址：
- en: '`https://api.twitter.com/1.1/statuses/retweets_of_me.json`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://api.twitter.com/1.1/statuses/retweets_of_me.json`'
- en: The optional parameters that can be sent with it are `count`, `since_id`, `max_id`,
    `trim_user`, `include_entites`, `include_user_entities`
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可以与其一起发送的可选参数有 `count`、`since_id`、`max_id`、`trim_user`、`include_entities`、`include_user_entities`
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Accessing available trends
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问可用趋势
- en: 'Twitter trends are hashtag-driven subject matter that is popular at a specific
    time. Take an instance of getting a location of the available trends in Twitter.
    For that, we will use the following URL:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter的热门话题是由标签驱动的特定时间内的主题。以获取Twitter中可用趋势的位置为例。为此，我们将使用以下网址：
- en: '`https://api.twitter.com/1.1/trends/available.json`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://api.twitter.com/1.1/trends/available.json`'
- en: 'The response of the resource URL is an array of locations in encoded form:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 资源URL的响应是一个以编码形式表示的位置数组：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding lines of code, we searched for the locations of the `available_trends`.
    Then, we learned that the number of locations having `available_trends` is `467`.
    Later, we tried to access the tenth location's data and it resulted in a response
    with the location information which is encoded with **woeid**. This is a unique
    identifier called **Where on Earth ID**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，我们搜索了`available_trends`的位置。然后，我们了解到拥有`available_trends`的位置数量是`467`。后来，我们尝试访问第十个位置的数据，结果返回了一个包含位置信息的响应，该信息是用**woeid**编码的。这是一个称为**Where
    on Earth ID**的唯一标识符。
- en: Updating user status
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新用户状态
- en: To update the authenticated user's current status, which is also known as tweeting,
    we follow the following procedure.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更新认证用户的当前状态，这通常被称为发推文，我们遵循以下程序。
- en: For each update attempt, the update text is compared with the authenticating
    user's recent tweets. Any attempt that would result in duplication will be blocked,
    resulting in a `403 error`. Therefore, a user cannot submit the same status twice
    in a row.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每次更新尝试，更新文本将与认证用户的最近推文进行比较。任何可能导致重复的尝试都将被阻止，从而导致`403错误`。因此，用户不能连续两次提交相同的状态。
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Interacting with Facebook
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Facebook互动
- en: The Facebook API platform helps third-party developers like us to create our
    own applications and services that access data on Facebook.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook API 平台帮助我们这样的第三方开发者创建自己的应用程序和服务，以便访问 Facebook 上的数据。
- en: Let us draw the Facebook data using the Facebook API. Facebook provides two
    types of APIs; that is, Graph API and Ads API. Graph API is a RESTful JSON API
    with which we can access the different resources from Facebook like statuses,
    likes, pages, photos, and so on. The Ads API basically deals with managing access
    to add campaigns, audiences and so on.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Facebook API来绘制Facebook数据。Facebook提供了两种类型的API；即Graph API和Ads API。Graph
    API是一个RESTful JSON API，通过它可以访问Facebook的不同资源，如状态、点赞、页面、照片等。Ads API主要处理管理对广告活动、受众等访问的权限。
- en: In this chapter, we are going to use the Facebook Graph API to interact with
    Facebook. It is named after its manner of representation with nodes and edges.
    The nodes represent the *things*, which means a user, a photo, a page; and the
    edges represent the connection between the things; that is page's photos, photo's
    comments.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Facebook Graph API与Facebook进行交互。它以节点和边的方式命名，表示其表示方式。节点代表*事物*，这意味着一个用户、一张照片、一个页面；而边则代表事物之间的连接；即页面的照片、照片的评论。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: All the examples in this section will be using the Graph API version 2.2
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的所有示例都将使用Graph API版本2.2
- en: Getting started with the Facebook API
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用 Facebook API
- en: 'To get started with the Facebook API, we need an opaque string called access
    token which is used by Facebook to identify a user, app, or page. It is followed
    by the steps of obtaining a key. We will be sending almost all our requests to
    the API at `graph.facebook.com` except the video upload stuff. The procedure to
    send a request takes place using the unique id of the node in the following way:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Facebook API，我们需要一个被称为访问令牌的不透明字符串，该字符串由 Facebook 用于识别用户、应用或页面。其后是获取密钥的步骤。我们将几乎向
    API 发送所有请求到 `graph.facebook.com`，除了视频上传相关的内容。发送请求的流程是通过使用以下方式中的节点唯一标识符来进行的：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And in the same way, we can POST in the following way:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们可以这样进行 POST 操作：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Obtaining a key
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取一个密钥
- en: The tokens of Facebook API are portable and can be used to make calls from a
    mobile client, a web browser or from a server.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook API的令牌是可移植的，可以从移动客户端、网页浏览器或服务器进行调用。
- en: 'There are four different types of Access tokens:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种不同类型的访问令牌：
- en: '**User Access Token**: This is the most commonly used type of access token
    which needs the authorization of users. This token can be used to access the user
    information and to post data on the user''s timeline.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户访问令牌**：这是最常用的一种访问令牌，需要用户的授权。此令牌可用于访问用户信息和在用户的动态时间轴上发布数据。'
- en: '**App Access Token**: This token comes into the picture when dealing at the
    Application level. This token doesn''t help in getting access to the user''s data,
    but it gives access to read the stream.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用访问令牌**：当在应用级别处理时，这个令牌就会出现。这个令牌并不能帮助获取用户的访问权限，但它可以用来读取流。'
- en: '**Page Access Token**: This token can used while accessing and managing a Facebook
    page.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**页面访问令牌**：此令牌可用于访问和管理Facebook页面。'
- en: '**Client Token**: This token can be embedded in an application to get access
    to the app-level API''s.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端令牌**：此令牌可以嵌入到应用程序中以获取对应用级API的访问权限。'
- en: In this tutorial, we will be using the App access token which consists of App
    Id and App Secret to get access to the resources.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将使用应用访问令牌，该令牌由应用ID和应用密钥组成，以获取对资源的访问权限。
- en: 'Follow the below steps to obtain an App access token:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤获取应用访问令牌：
- en: Create an application using the developer console of Facebook at [https://developers.facebook.com/developer-console/](https://developers.facebook.com/developer-console/).
    Note that we should login to [http://developers.facebook.com](http://developers.facebook.com)
    so that we can attain the permission to create an application.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用位于[https://developers.facebook.com/developer-console/](https://developers.facebook.com/developer-console/)的Facebook开发者控制台创建一个应用程序。请注意，我们应该登录到[http://developers.facebook.com](http://developers.facebook.com)，以便我们能够获得创建应用程序的权限。
- en: Once we are done with the creation of the application, we can get the access
    to App Id and App Secret on the application page of our [http://developers.facebook.com](http://developers.facebook.com)
    account.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们完成了应用程序的创建，我们就可以在我们的[http://developers.facebook.com](http://developers.facebook.com)账户的应用程序页面上获取App
    Id和App Secret的访问权限。
- en: That's all; obtaining a key is that simple. We don't need to create any authentication
    request to send messages, as opposed to how it is on Twitter. The App Id and App
    Secret are enough to give us permission to access the resources.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些；获取密钥就这么简单。我们不需要创建任何认证请求来发送消息，与Twitter上的情况不同。App ID和App Secret就足以赋予我们访问资源的权限。
- en: Getting a user profile
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取用户资料
- en: We can access the current user profile of the person who is logged into the
    site, using the API URL `https://graph.facebook.com/me` with a GET request. We
    need to pass the previously obtained access token as a parameter, while we are
    making any Graph API call using requests.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 API URL `https://graph.facebook.com/me` 通过 GET 请求访问已登录网站的人的当前用户资料。在通过
    requests 使用任何 Graph API 调用时，我们需要传递之前获得的访问令牌作为参数。
- en: 'Firstly, we need to import the requests module and then we have to store the
    access token into a variable. The process works in the following way:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要导入requests模块，然后我们必须将访问令牌存储到一个变量中。这个过程按照以下方式进行：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the next step, we should send the required graph API call, in the following
    way:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步，我们应该以以下方式发送所需的图形API调用：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we have a `requests.Response` object called `me`. The `me.text` returns
    a JSON response string. To access various elements (example, `id`, `name`, `last_name`,
    `hometown`, `work`) of the retrieved user profile, we need to convert the `json`
    `response` string into a `json object` string. We can achieve this by calling
    the method `me.json()`. The `me.json.keys()` results all the keys in the dictionary:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个名为 `me` 的 `requests.Response` 对象。`me.text` 返回一个 JSON 响应字符串。要访问检索到的用户配置文件中的各种元素（例如，`id`、`name`、`last_name`、`hometown`、`work`），我们需要将
    `json` `response` 字符串转换为 `json object` 字符串。我们可以通过调用方法 `me.json()` 来实现这一点。`me.json.keys()`
    返回字典中的所有键：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A user's `id` is a unique number which is used to identify the user on Facebook.
    We can access the current profile ID from the user profile in the following way.
    We'll use this ID in the subsequent examples to retrieve the current user's friends,
    feed and albums.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 用户的`id`是一个唯一的数字，用于在Facebook上识别用户。我们可以通过以下方式从用户资料中获取当前资料ID。在后续的示例中，我们将使用此ID来检索当前用户的友人、动态和相册。
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Retrieving a friends list
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取朋友列表
- en: Let us gather the friends list of a specific user. To achieve this, we should
    make an API call to `https://graph.facebook.com/<user-id>/friends`, and replace
    the `user-id` with the value of user's ID.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们收集特定用户的好友列表。为了实现这一点，我们应该向`https://graph.facebook.com/<user-id>/friends`发起API调用，并将`user-id`替换为用户的ID值。
- en: 'Now, let us obtain the friends list of the user id that we retrieved in the
    former example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们获取在前一个示例中检索到的用户ID的朋友列表：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The response for the API call contains a JSON object string. The friend's information
    is stored in the `data` attribute of the `response json` object, which is a list
    of friend objects containing friends' IDs and names as keys.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: API调用的响应包含一个JSON对象字符串。朋友的信息存储在`response json`对象的`data`属性中，这是一个包含朋友ID和名称作为键的朋友对象列表。
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Retrieving feed
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取推送内容
- en: In order to retrieve the feed of posts which includes status updates and links
    published by the current user, or by others on the current user's profile, we
    should use the feed parameter in the request.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检索包括当前用户或他人发布在当前用户个人资料中的状态更新和链接的帖子流，我们应该在请求中使用feed参数。
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding example, we sent a request to get the feeds of a specific user
    with user ID `10203783798823031`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们发送了一个请求以获取具有用户ID `10203783798823031`的特定用户的动态。
- en: Retrieving albums
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索专辑
- en: 'Let us access the photo albums created by the current logged-in user. It can
    be achieved in the following way:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们访问当前登录用户创建的相册。这可以通过以下方式实现：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding example, we sent a request to graph API to get access to the
    albums of the user with `user-id` `10203783798823031`. And then we tried to access
    the response data through JSON.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们向图API发送了一个请求，以获取具有`user-id` `10203783798823031`的用户的专辑。然后我们尝试通过JSON访问响应数据。
- en: Interacting with reddit
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Reddit 互动
- en: Reddit is one of the popular social networking, entertainment and news websites
    where registered members can submit content, such as text posts or direct links.
    It allows the registered users to vote the submissions either "up" or "down" to
    rank the posts on the site's pages. Each content entry is categorized by area
    of interest called **SUBREDDITS**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Reddit 是一个流行的社交网络、娱乐和新闻网站，注册会员可以提交内容，例如文本帖子或直接链接。它允许注册用户对提交的内容进行“赞同”或“反对”的投票，以在网站页面上对帖子进行排名。每个内容条目都按兴趣领域分类，称为
    **SUBREDDITS**。
- en: In this section, we are going to access the reddit API directly, using the Python
    requests library. We are going to cover the topics of a basic overview of reddit
    API, getting data related to our own reddit account, and using the search API
    to retrieve the links.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将直接访问reddit API，使用Python的requests库。我们将涵盖以下主题：对reddit API的基本概述、获取与我们自己的reddit账户相关的数据，以及使用搜索API检索链接。
- en: Getting started with the reddit API
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用reddit API
- en: 'The reddit API consists of four important parts that we need to get familiar
    with before starting to interact with it. The four parts are:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Reddit API 由四个重要的部分组成，在开始与之交互之前，我们需要熟悉这四个部分。这四个部分是：
- en: '**listings**: The endpoints in reddit are called listings. They contain parameters
    like `after`/`before`, `limit`, `count`, `show`.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**列表**: Reddit 中的端点被称为列表。它们包含诸如 `after`/`before`、`limit`、`count`、`show` 等参数。'
- en: '**modhashes**: This is a token which is used to prevent the **cross site request
    forgery**(**CSRF**) exploit. We can get the modhash for us by using `GET /api/me.json`.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**modhashes**：这是一个用于防止**跨站请求伪造**（**CSRF**）攻击的令牌。我们可以通过使用`GET /api/me.json`来获取我们的modhash。'
- en: '**fullnames**: A fullname is a combination of a thing''s type and its unique
    ID which forms a compact encoding of a globally unique ID on reddit.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**fullnames**: 全名是一个事物的类型和其唯一ID的组合，它构成了Reddit上全局唯一ID的紧凑编码。'
- en: '**account**: This deals with the user''s account. Using this we can register,
    login, set force https, update the account, update email and so on.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**账户**: 这涉及到用户的账户。使用它我们可以注册、登录、设置强制HTTPS、更新账户、更新电子邮件等等。'
- en: Registering a new account
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册新账户
- en: 'Registering a new account on reddit is easy. First, we need to reach the reddit
    site—[https://www.reddit.com/](https://www.reddit.com/), and then have to fill
    up the registration form which pops up when we click on **sign in or create an
    account** link in the top right corner. The Registration form includes:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在reddit上注册新账户很简单。首先，我们需要访问reddit网站——[https://www.reddit.com/](https://www.reddit.com/)，然后点击右上角的**登录或创建账户**链接，就会出现注册表单。注册表单包括：
- en: '**username**: Used to identify the reddit community member uniquely'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户名**：用于唯一标识 Reddit 社区成员'
- en: '**email**: An optional field used to communicate directly with a user'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电子邮件**：用于直接与用户沟通的可选字段'
- en: '**password**: Secure password to login into the reddit platform'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码**：登录 Reddit 平台的加密密码'
- en: '**verify password**: This field should be the same as the password field'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证密码**：此字段应与密码字段相同'
- en: '**captcha**: This field is used to check whether the user who is trying to
    login is a human or a programmable bot'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证码**: 此字段用于检查尝试登录的用户是真人还是可编程的机器人'
- en: Let us create a new account with a username and a password of our choice. For
    now, leave the email field empty. We are going to add it in the next section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新账户，使用我们选择的用户名和密码。目前，请将电子邮件字段留空。我们将在下一节中添加它。
- en: In the following examples, I'm assuming that the username and password we created
    before are `OUR_USERNAME` and `OUR_PASSWORD` respectively.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我假设我们之前创建的用户名和密码分别是`OUR_USERNAME`和`OUR_PASSWORD`。
- en: Modifying account information
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改账户信息
- en: Now, let's add an email to our account's profile which we intentionally left
    undone while creating the account in the previous section.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的账户资料中添加一封电子邮件，这是我们在上一个部分创建账户时故意未完成的。
- en: Let us begin the process by creating a session object, which allows us to maintain
    certain parameters and cookies across all requests.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个会话对象开始这个过程，它允许我们在所有请求中维护某些参数和cookie。
- en: '[PRE17]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let us create a `DATA` attribute with the `'user'`, `'passwd'` and `'api type'`
    attributes.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个具有`'user'`、`'passwd'`和`'api type'`属性的`DATA`属性。
- en: '[PRE18]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can access our reddit account by making a `post` request call to the URL—[https://ssl.reddit.com/api/login](https://ssl.reddit.com/api/login)
    with the login credentials stored in the `DATA` attribute.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过向URL发起一个`post`请求调用来访问我们的Reddit账户——[https://ssl.reddit.com/api/login](https://ssl.reddit.com/api/login)，其中登录凭证存储在`DATA`属性中。
- en: '[PRE19]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The reddit api response to the above post request will be stored in the `response`
    variable. The `response` object contains the `data` and `errors` information as
    shown in the following example:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Reddit API 对上述帖子请求的响应将被存储在 `response` 变量中。`response` 对象包含 `data` 和 `errors`
    信息，如下例所示：
- en: '[PRE20]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We need to send the `modhash` value obtained in the previous response to perform
    an update call to change our `email`. Now, let us call the reddit''s update API
    as shown in the following example:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将前一个响应中获得的`modhash`值发送，以执行更新调用以更改我们的`email`。现在，让我们调用以下示例中的reddit更新API：
- en: '[PRE21]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The response to the update call is stored in `r`. If there are no errors, then
    the `status_code` will be `200` and `errors` attributes value will be an empty
    list as shown in the following example:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新调用响应存储在 `r` 中。如果没有错误，则 `status_code` 将为 `200`，`errors` 属性的值将是一个空列表，如下例所示：
- en: '[PRE22]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, let us check whether the `email` field is set by getting info about the
    currently authenticated user. If the `has_mail` attribute is `True`, then we can
    assume that the email is successfully updated.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过获取当前认证用户的详细信息来检查`email`字段是否已设置。如果`has_mail`属性为`True`，那么我们可以假设电子邮件已成功更新。
- en: '[PRE23]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Performing a simple search
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行简单搜索
- en: We can use reddit's search API to search the entire site or in a subreddit.
    In this section we'll look at making a search API request. Proceed with the following
    steps to make a search request.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Reddit 的搜索 API 来搜索整个网站或特定子版块。在本节中，我们将探讨如何发起一个搜索 API 请求。按照以下步骤进行，以发起一个搜索请求。
- en: To make a search api call, we need to send a get request to `http://www.reddit.com/search.json`
    url with a search query `q` in the parameters.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行搜索API调用，我们需要向`http://www.reddit.com/search.json` URL发送一个带有搜索查询参数`q`的GET请求。
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The response to search is stored in the `search` variable which is a `requests.Response`
    object. The search results are stored in the `children` attribute of the `data`
    attribute. We can access `title`, `author`, `score` or another item in the search
    results as shown in the following example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索响应存储在`search`变量中，它是一个`requests.Response`对象。搜索结果存储在`data`属性的`children`属性中。我们可以像以下示例中那样访问搜索结果中的`title`、`author`、`score`或其他项目：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Searching subreddits
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索 subreddits
- en: Searching in reddit's subreddits by title and description is same as searching
    in reddit. For that, we need to send a get request to `http://www.reddit.com/search.json`
    URL with a search query `q` in the parameters.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在reddit的子版块中通过标题和描述进行搜索与在reddit中进行搜索相同。为此，我们需要向`http://www.reddit.com/search.json`
    URL发送一个带有搜索查询参数`q`的GET请求。
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The response to search is stored in the `search` variable which is a `requests.Response`
    object. The search results are stored in the `data` attribute.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索响应存储在`search`变量中，它是一个`requests.Response`对象。搜索结果存储在`data`属性中。
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter serves as a guide to interact with some of the most popular social
    media with Python using requests. We started by learning about the definition
    and importance of an API in the real world. Then we interacted with some of the
    most popular social networking sites like Twitter, Facebook and reddit. Each section
    about a social network will provide a hands on experience using a limited set
    of examples.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在指导您使用Python和requests库与一些最受欢迎的社交媒体平台进行交互。我们首先学习了在现实世界中API的定义和重要性。然后，我们与一些最受欢迎的社会化媒体网站，如Twitter、Facebook和Reddit进行了交互。每个关于社交网络的章节都将通过一组有限的示例提供实际操作经验。
- en: In the next chapter, we are going to learn step by step about Web scraping with
    requests and BeautifulSoup libraries.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将逐步学习使用requests和BeautifulSoup库进行网络爬取。
