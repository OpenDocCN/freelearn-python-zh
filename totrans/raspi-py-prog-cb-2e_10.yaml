- en: Chapter 10. Interfacing with Technology
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。与技术接口
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Automating your home with remote sockets
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用远程插座自动化您的家庭
- en: Using SPI to control an LED matrix
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SPI 控制LED矩阵
- en: Communicating using a serial interface
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用串行接口进行通信
- en: Controlling the Raspberry Pi over Bluetooth
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过蓝牙控制Raspberry Pi
- en: Controlling USB devices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制USB设备
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: One of the key aspects of the Raspberry Pi that differentiates it from an average
    computer is its ability to interface with and control hardware. In this chapter,
    we use the Raspberry Pi to control remotely activated mains sockets, send commands
    over serial connections from another computer, and control the GPIO remotely.
    We make use of SPI (another useful protocol) to drive an 8 x 8 LED matrix display.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 与普通计算机区别的关键之一是其与硬件接口和控制的能 力。在本章中，我们使用 Raspberry Pi 远程控制带电插座，从另一台计算机通过串行连接发送命令，并远程控制
    GPIO。我们利用 SPI（另一个有用的协议）来驱动 8 x 8 LED 矩阵显示屏。
- en: We also use a Bluetooth module to connect with a smartphone, allowing information
    to be transferred wirelessly between devices. Finally, we take control of USB
    devices by tapping into the commands sent over USB.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用蓝牙模块与智能手机连接，允许设备之间无线传输信息。最后，我们通过 USB 发送的命令来控制 USB 设备。
- en: Tip
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Be sure to check out the *Hardware list* section in the [Appendix](apa.html
    "Appendix A. Hardware and Software List"), *Hardware and Software List*; it lists
    all the items used in this chapter and the places you can obtain them from.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必查看[附录](apa.html "附录 A. 硬件和软件列表")中的*硬件和软件列表*部分，*硬件和软件列表*；它列出了本章中使用的所有项目及其获取地点。
- en: Automating your home with remote sockets
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用远程插座自动化您的家庭
- en: The Raspberry Pi can make an excellent tool for home automation by providing
    accurate timing, control, and the ability to respond to commands, button inputs,
    environmental sensors, or messages from the Internet.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 可以通过提供精确的时间、控制和响应命令、按钮输入、环境传感器或来自互联网的消息的能力，成为家庭自动化的优秀工具。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Great care must be taken when controlling devices that use electricity from
    the mains since high voltages and currents are often involved.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制使用市电的设备时必须格外小心，因为通常涉及高电压和电流。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Never attempt to modify or alter devices that are connected to mains electricity
    without proper training. You must never directly connect any homemade devices
    to the mains supply. All electronics must undergo rigorous safety testing to ensure
    that there will be no risk or harm to people or property in the event of a failure.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有适当培训的情况下，切勿尝试修改或更改连接到市电的设备。您绝对不能将任何自制的设备直接连接到市电。所有电子设备都必须经过严格的安全测试，以确保在发生故障的情况下不会对人员或财产造成风险或伤害。
- en: 'In this example, we will use remote controlled **radio frequency** (**RF**)
    plug-in sockets; these use a separate remote unit to send a specific RF signal
    to switch any electrical device that is plugged into it on or off. This allows
    us to modify the remote control and use the Raspberry Pi to activate the switches
    safely, without interfering with dangerous voltages:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将使用遥控射频（RF）插头插座；这些插座使用一个独立的遥控单元发送特定的 RF 信号来切换连接到其上的任何电气设备的开/关。这允许我们修改遥控器，并使用
    Raspberry Pi 安全地激活开关，而不会干扰危险的电压：
- en: '![Getting ready](img/6623OT_10_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/6623OT_10_01.jpg)'
- en: Remote control and remote mains socket
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 遥控器和远程插座
- en: The particular remote control used in this example has six buttons on it to
    directly switch three different sockets on or off and is powered by a 12V battery.
    It can be switched into four different channels, which would allow you to control
    a total of 12 sockets (each socket has a similar selector that will be used to
    set the signal it will respond to).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中使用的特定遥控器上有六个按钮，可以直接切换三个不同的插座的开/关，并由 12V 电池供电。它可以切换到四个不同的频道，这将允许您控制总共 12 个插座（每个插座都有一个类似的选择器，将用于设置它将响应的信号）。
- en: '![Getting ready](img/6623OT_10_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/6623OT_10_02.jpg)'
- en: Inside the remote control
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 遥控器内部
- en: The remote buttons, when pressed, will broadcast a specific RF signal (this
    one uses a transmission frequency of 433.92 MHz). This will trigger any socket(s)
    that is set to the corresponding channel (A, B, C, or D) and number (1, 2, or
    3).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下遥控按钮时，将广播一个特定的 RF 信号（本例使用 433.92 MHz 的传输频率）。这将触发设置为相应频道（A、B、C 或 D）和数字（1、2
    或 3）的任何插座。
- en: Internally, each of the buttons connects two separate signals to ground, the
    number (1, 2, or 3), and state (on or off). This triggers the correct broadcast
    that is to be made by the remote control.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，每个按钮将两个不同的信号连接到地，数字（1、2或3）和状态（开启或关闭）。这触发了遥控器要发出的正确广播。
- en: '![Getting ready](img/6623OT_10_03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6623OT_10_03.jpg)'
- en: Connect the wires to ON, OFF, 1, 2, 3, and GND at suitable points on the remote's
    PCB (only ON, OFF, 1, and GND are connected in the image)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将电线连接到遥控器PCB板上的ON、OFF、1、2、3和GND合适的位置（图中只连接了ON、OFF、1和GND）
- en: It is recommended that you do not connect anything to your sockets that could
    cause a hazard if switched on or off. The signals sent by the remote are not unique
    (there are only four different channels available). This therefore makes it possible
    for someone else nearby who has a similar set of sockets to unknowingly activate/deactivate
    one of your sockets. It is recommended that you select a channel other than the
    default, A, which will slightly reduce the chance of someone else accidentally
    using the same channel.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您不要将任何可能因开启或关闭而造成危险的物品连接到您的插座上。遥控器发送的信号不是唯一的（只有四个不同的频道可用）。因此，这使附近有类似插座组合的人无意中激活/关闭您的其中一个插座成为可能。建议您选择除默认的A以外的频道，这将略微降低他人意外使用相同频道的机会。
- en: To allow the Raspberry Pi to simulate the button presses of the remote, we will
    need five relays to allow us to select the number (1, 2, or 3) and state (on or
    off).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许树莓派模拟遥控器的按钮按下，我们需要五个继电器来选择数字（1、2或3）和状态（开启或关闭）。
- en: '![Getting ready](img/6623OT_10_04.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6623OT_10_04.jpg)'
- en: A prebuilt Relay Module can be used to switch the signals
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用预制的继电器模块来切换信号
- en: Alternatively, the transistor and relay circuit from [Chapter 9](ch09.html "Chapter 9. Building
    Robots"), *Building Robots*, can be used to simulate the button presses.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用[第9章](ch09.html "第9章。构建机器人")中的晶体管和继电器电路来模拟按钮按下。
- en: 'Wire the relay control pins to the Raspberry Pi GPIO and connect the socket
    remote control to each relay output as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将继电器控制引脚连接到树莓派GPIO，并将插座遥控器连接到每个继电器输出，如下所示：
- en: '![Getting ready](img/6623OT_10_05.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/6623OT_10_05.jpg)'
- en: The socket remote control circuit
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 插座遥控电路
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although the remote socket requires both the number (1, 2, or 3) and the state
    (on or off) to activate a socket, it is the state signal that activates the RF
    transmission. To avoid draining the remote's battery, we must ensure that we have
    turned off the state signal.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然遥控器插座需要数字（1、2或3）和状态（开启或关闭）来激活插座，但激活射频传输的是状态信号。为了避免耗尽遥控器的电池，我们必须确保我们已经关闭了状态信号。
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create the following `socketControl.py` script:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下`socketControl.py`脚本：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The socket control script performs a quick test by switching the first socket
    on for 5 seconds and then turning it off again.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 插座控制脚本通过开启第一个插座5秒然后再次关闭来进行快速测试。
- en: 'To control the rest of the sockets, create a GUI menu as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制其余的插座，创建以下GUI菜单：
- en: '![How to do it...](img/6623OT_10_06.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/6623OT_10_06.jpg)'
- en: Remote Switches GUI
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 遥控开关GUI
- en: 'Create the following `socketMenu.py` script:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下`socketMenu.py`脚本：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first script defines a class called `Switch`; it sets up the GPIO pins required
    to control the five relays (within the setup function). It also defines the `__enter__`
    and `__exit__` functions, which are special functions used by the `with..as` statement.
    When a class is created using `with..as`, it uses `__enter__` to perform any extra
    initialization or setup (if required), and then it performs any cleanup by calling
    `__exit__`. When the `Switch` class has been executed, all the relays are switched
    off to preserve the remote's battery and `GPIO.cleanup()` is called to release
    the GPIO pins. The parameters of the `__exit__` function (`type`, `value`, and
    `traceback`) allow the handling of any specific exceptions that may have occurred
    when the class was being executed within the `with..as` statement (if required).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个脚本定义了一个名为 `Switch` 的类；它在 `setup` 函数中设置了控制五个继电器所需的 GPIO 引脚。它还定义了 `__enter__`
    和 `__exit__` 函数，这些是 `with..as` 语句使用的特殊函数。当使用 `with..as` 创建类时，它使用 `__enter__` 来执行任何额外的初始化或设置（如果需要），然后通过调用
    `__exit__` 来执行任何清理。当 `Switch` 类执行完毕后，所有继电器都关闭以保护遥控器的电池，并调用 `GPIO.cleanup()` 来释放
    GPIO 引脚。`__exit__` 函数的参数（`type`、`value` 和 `traceback`）允许处理在 `with..as` 语句中执行类时可能发生的任何特定异常（如果需要）。
- en: To control the sockets, create two functions that will switch the relevant relays
    on or off to activate the remote control to send the required signal to the sockets.
    Then, shortly after, turn the relays off again using `clear()`. To make controlling
    the switches even easier, create a `message` function that will allow a switch
    number and state to be specified.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制插座，创建两个函数，这些函数将切换相关的继电器以激活遥控器，并发送所需的信号到插座。然后，稍后使用 `clear()` 再次关闭继电器。为了使控制开关更加容易，创建一个
    `message` 函数，允许指定开关号和状态。
- en: We make use of the `socketControl.py` script by creating a Tkinter GUI menu.
    The menu is made up of three sets of controls (one for each of the switches) that
    are defined by the `swButtons` class.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个 Tkinter GUI 菜单来使用 `socketControl.py` 脚本。菜单由 `swButtons` 类定义的三组控制组成（每个开关一组）。
- en: The `swButtons` class creates a `Tkinter` button and two `Radiobutton` controls.
    Each `swButtons` object is given an index and a reference to the `mySwitches`
    object. This allows us to set a name for the button and control a particular switch
    when it is pressed. The socket is activated/deactivated by calling `message()`,
    with the required switch number and state set by the `Radiobutton` controls.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`swButtons` 类创建一个 `Tkinter` 按钮，以及两个 `Radiobutton` 控制器。每个 `swButtons` 对象都分配一个索引和
    `mySwitches` 对象的引用。这允许我们为按钮设置一个名称，并在按下时控制特定的开关。通过调用 `message()` 来激活/停用插座，所需的开关号和状态由
    `Radiobutton` 控制器设置。'
- en: There's more...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The previous example allows you to rewire the remotes of most remote controlled
    sockets, but another option is to emulate the signals to control it directly.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子允许你重新布线大多数遥控插座的遥控器，但另一个选项是模拟信号以直接控制它。
- en: Sending RF control signals directly
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接发送射频控制信号
- en: 'Instead of rewiring the remote control, you can replicate the remote''s RF
    signals using a transmitter that uses the same frequency as your sockets (these
    particular units use 433.94 MHz). This will depend on the particular sockets and
    sometimes your location—some countries prohibit the use of certain frequencies—as
    you may require certification before making your own transmissions:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以不重新布线遥控器，而是使用与你的插座相同频率的发射器来复制遥控器的射频信号（这些特定的单元使用 433.94 MHz）。这取决于特定的插座和有时你的位置——一些国家禁止使用某些频率，你可能需要在发送自己的传输之前获得认证：
- en: '![Sending RF control signals directly](img/6623OT_10_07.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![直接发送射频控制信号](img/6623OT_10_07.jpg)'
- en: The 433.94 MHz RF transmitter (left) and receiver (right)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 433.94 MHz 射频发射器（左侧）和接收器（右侧）
- en: The signals sent by the RF remote control can be recreated using 433Utils created
    by [http://ninjablocks.com](http://ninjablocks.com). The 433Utils uses WiringPi
    and are written in C++, allowing high speed capture and replication of the RF
    signals.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用由 [http://ninjablocks.com](http://ninjablocks.com) 创建的 433Utils 来重新创建射频遥控器发送的信号。433Utils
    使用 WiringPi，并使用 C++ 编写，允许高速捕获和复制射频信号。
- en: 'Obtain the code using the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令获取代码：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we need to wire up our RF transmitter (so we can control the switches)
    and RF receiver (so we can determine the control codes) to the Raspberry Pi.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将我们的射频发射器（以便我们可以控制开关）和射频接收器（以便我们可以确定控制代码）连接到 Raspberry Pi。
- en: The transmitter (the smaller square module) has three pins, which are power
    (VCC), ground (GND), and data out (ATAD). The voltage supplied on the power pin
    will govern the transmission range (we will use 5V supply from the Raspberry Pi,
    but you could replace this with 12V, as long as you ensure you connect the ground
    pin to both your 12V supply and the Raspberry Pi).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 发射器（较小的方形模块）有三个引脚，分别是电源（VCC）、地（GND）和数据输出（ATAD）。电源引脚上的电压将控制传输范围（我们将使用来自树莓派的5V电源，但你也可以将其替换为12V，只要确保将地引脚连接到你的12V电源和树莓派）。
- en: Although the receiver has four pins, there is a power pin (VCC), ground pin
    (GND), and two data out pins (DATA), which are wired together, so we only need
    to connect three wires to the Raspberry Pi.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管接收器有四个引脚，但有一个电源引脚（VCC）、地引脚（GND）和两个数据输出引脚（DATA），它们是连接在一起的，所以我们只需要连接三根线到树莓派。
- en: '| RF Tx | RPi GPIO pin |   | RF Rx | RPi GPIO pin |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| RF 发射器 | RPi GPIO 引脚 |   | RF 接收器 | RPi GPIO 引脚 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| VCC (5V) | 2 |   | VCC (3V3) | 1 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| VCC (5V) | 2 |   | VCC (3V3) | 1 |'
- en: '| Data out | 11 |   | Data in | 13 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 数据输出 | 11 |   | 数据输入 | 13 |'
- en: '| GND | 6 |   | GND | 9 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| GND | 6 |   | GND | 9 |'
- en: Before we use the programs within the `RPi_Utils`, we will make a few adjustments
    to ensure our RX and TX pins are set correctly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用 `RPi_Utils` 内的程序之前，我们将进行一些调整以确保我们的RX和TX引脚设置正确。
- en: 'Locate `codesend.cpp` in `433Utils-master/RPi_utils/` to make the required
    changes:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `433Utils-master/RPi_utils/` 中定位 `codesend.cpp` 以进行必要的更改：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Change `int PIN = 0;` (located at around line 24) to `int PIN = 11;` (RPi physical
    pin number).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `int PIN = 0;`（位于大约第24行）改为 `int PIN = 11;`（RPi 物理引脚编号）。
- en: 'Change `wiringPi` to use physical pin numbering (located around line 27) by
    replacing `wiringPiSetup()` with `wiringPiSetupPhy()`. Otherwise, the default
    is WiringPi GPIO numbers; for more details, see [http://wiringpi.com/reference/setup/](http://wiringpi.com/reference/setup/).
    Find the following line:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `wiringPi` 改为使用物理引脚编号（位于大约第27行），通过将 `wiringPiSetup()` 替换为 `wiringPiSetupPhy()`。否则，默认是WiringPi
    GPIO编号；更多详情请见[http://wiringpi.com/reference/setup/](http://wiringpi.com/reference/setup/)。找到以下行：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Change it to this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 改成这样：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Save and exit `nano` using *Ctrl* + *X*, *Y*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *Ctrl* + *X*, *Y* 保存并退出 `nano`。
- en: 'Make similar adjustments to `RFSniffer.cpp`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `RFSniffer.cpp` 进行类似的调整：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Find the following line (located at around line 25):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 找到以下行（位于大约第25行）：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Change it to this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 改成这样：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Find the following line (located at around line 27:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 找到以下行（位于大约第27行）：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Change it to this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 改成这样：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Save and exit `nano` using *Ctrl* + *X*, *Y*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *Ctrl* + *X*, *Y* 保存并退出 `nano`。
- en: 'Build the code using the following command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令构建代码：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This should build without errors, as shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 应该可以无错误地构建，如下所示：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we have our RF modules connected to the Raspberry Pi and our code
    ready, we can capture the control signals from our remote. Run the following command
    and take note of the reported output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将RF模块连接到树莓派，并且代码已经准备好了，我们可以捕获来自遥控器的控制信号。运行以下命令并注意报告的输出：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Get the output by pressing Button 1 OFF with the remote set to channel A (note
    we may get a few that pick up random noise):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将遥控器设置为频道A并按下按钮1 OFF来获取输出（注意我们可能会接收到一些随机噪声）：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can now send out the signals using the `sendcode` command to switch the
    sockets OFF (`1381716`) and ON (`1381719`):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用 `sendcode` 命令发送信号来切换插座关闭（`1381716`）和开启（`1381719`）：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You could even set up the Raspberry Pi to use the receiver module to detect
    signals from the remote (on an unused channel) and act upon them to start processes,
    control other hardware, or perhaps trigger a software shutdown/reboot.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以设置树莓派使用接收器模块来检测来自遥控器的信号（在未使用的频道上）并对它们做出反应以启动进程、控制其他硬件或可能触发软件关闭/重启。
- en: Extending the range of the RF Transmitter
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展射频发射器的范围
- en: The range of the transmitter is very limited when it is powered by 5V and without
    an additional antenna. However, it is worth testing everything before you make
    any modifications.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当由5V供电且没有附加天线时，发射器的范围非常有限。然而，在做出任何修改之前测试一切是值得的。
- en: Simple wire antenna can be made from 25 cm of single core wire, 17 mm side connected
    to the antenna solder point, then 16 turns (made using a thin screwdriver shaft
    or similar) and the remaining wire on top (approximately 53 mm). This is described
    in more detail at .
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用25厘米的单芯线制作简单的线状天线，将17毫米侧连接到天线焊接点，然后绕16圈（使用细螺丝刀柄或类似物品），剩余的线在上面（大约53毫米）。更详细的描述请见
    。
- en: '![Extending the range of the RF Transmitter](img/6623OT_10_08.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![扩展射频发射器的范围](img/6623OT_10_08.jpg)'
- en: The transmitter range is vastly improved with a simple antenna
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单的天线，发射器的范围得到了极大的改善
- en: Determining the structure of the remote control codes
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定遥控器代码的结构
- en: 'Recording the codes this for each of the buttons, we can determine the codes
    for each (and break down the structure):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 记录每个按钮的代码，我们可以确定每个按钮的代码（并分解结构）：
- en: '![Determining the structure of the remote control codes](img/Table_new.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![确定遥控器代码的结构](img/Table_new.jpg)'
- en: To select channel A, B, C, or D, set the two bits to 00\. Similarly, for button
    1, 2, or 3, set the two bits to 00 to select that button. Finally, set the last
    two bits to 11 for ON or 00 for OFF.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择通道A、B、C或D，将两个位设置为00。同样，对于按钮1、2或3，将两个位设置为00以选择该按钮。最后，将最后两个位设置为11以开启，或设置为00以关闭。
- en: See [https://arduinodiy.wordpress.com/2014/08/12/433-mhz-system-foryour-arduino/](https://arduinodiy.wordpress.com/2014/08/12/433-mhz-system-foryour-arduino/),
    which analyses these and other similar RF remote controls.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://arduinodiy.wordpress.com/2014/08/12/433-mhz-system-foryour-arduino/](https://arduinodiy.wordpress.com/2014/08/12/433-mhz-system-foryour-arduino/)，该页面分析了这些以及其他类似的射频遥控器。
- en: Using SPI to control an LED matrix
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SPI控制LED矩阵
- en: In [Chapter 7](ch07.html "Chapter 7. Sense and Display Real-World Data"), *Sense
    and Display Real-World Data*, we connected to devices using a bus protocol called
    I²C. The Raspberry Pi also supports another chip-to-chip protocol called **SPI**
    (**Serial Peripheral Interface**). The SPI bus differs from I²C because it uses
    two single direction data lines (where I²C uses one bidirectional data line).
    Although SPI requires more wires (I²C uses two bus signals, SDA and SCL), it supports
    the simultaneous sending and receiving of data and much higher clock speeds than
    I²C.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章. 感知和显示现实世界数据")中，我们使用名为I²C的总线协议连接到设备。树莓派还支持另一种称为**SPI**（**串行外围接口**）的芯片间协议。SPI总线与I²C的不同之处在于它使用两条单方向数据线（而I²C使用一条双向数据线）。尽管SPI需要更多的线（I²C使用两个总线信号，SDA和SCL），但它支持数据的同步发送和接收，并且比I²C具有更高的时钟速度。
- en: '![Using SPI to control an LED matrix](img/6623OT_10_09.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![使用SPI控制LED矩阵](img/6623OT_10_09.jpg)'
- en: General connections of SPI devices with the Raspberry Pi
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: SPI设备与树莓派的通用连接
- en: 'The SPI bus consists of the following four signals:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: SPI总线由以下四个信号组成：
- en: '**SCLK**: This provides the clock edges to read/write data on the input/output
    lines; it is driven by the master device. As the clock signal changes from one
    state to another, the SPI device will check the state of the MOSI signal to read
    a single bit. Similarly, if the SPI device is sending data, it will use the clock
    signal edges to synchronize when it sets the state of the MISO signal.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SCLK**：它提供时钟边缘以在输入/输出线上读写数据；由主设备驱动。当时钟信号从一个状态变化到另一个状态时，SPI设备将检查MOSI信号的状态以读取一个比特。同样，如果SPI设备正在发送数据，它将使用时钟信号边缘来同步设置MISO信号状态的时刻。'
- en: '**CE**: This refers to Chip Enable (typically, a separate Chip Enable is used
    for each slave device on the bus). The master device will set the Chip Enable
    signal to low for the device that it wants to communicate with. When the Chip
    Enable signal is set to high, it ignores any other signals on the bus. This signal
    is sometimes called **Chip Select** (**CS**) or **Slave Select** (**SS**).'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CE**：这指的是芯片使能（通常，每个从设备在总线上都使用一个单独的芯片使能）。主设备将芯片使能信号设置为低，以便与它想要通信的设备通信。当芯片使能信号设置为高时，它将忽略总线上的任何其他信号。此信号有时被称为**芯片选择**（**CS**）或**从选择**（**SS**）。'
- en: '**MOSI**: This stands for Master Output, Slave Input (it connects to Data Out
    of the master device and Data In of the slave device).'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MOSI**：这代表主输出，从输出（它连接到主设备的数据输出和从设备的数据输入）。'
- en: '**MISO**: This stands for Master Input, Slave Output (it provides a response
    from the slave).'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MISO**：这代表主输入，从输出（它提供从从设备响应）。'
- en: 'The following diagram shows each of the signals:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了每个信号：
- en: '![Using SPI to control an LED matrix](img/6623OT_10_10.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![使用SPI控制LED矩阵](img/6623OT_10_10.jpg)'
- en: 'The SPI signals: SCLK (1), CE(2), MOSI(3), and MISO(4)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: SPI信号：SCLK（1）、CE（2）、MOSI（3）和MISO（4）
- en: 'The previous scope trace shows two bytes being sent over SPI. Each byte is
    clocked into the SPI device using the **SCLK (1)** signal. A byte is signified
    by a burst of eight clock cycles (a low and then high period on the **SCLK (1)**
    signal), where the value of a specific bit is read when the clock state changes.
    The exact sample point is determined by the clock mode; in the following diagram,
    it is when the clock goes from low to high:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的范围跟踪显示了通过SPI发送的两个字节。每个字节都使用**SCLK (1)**信号将时钟输入到SPI设备中。一个字节由八个时钟周期的一串（**SCLK
    (1)**信号上的低电平和随后的高电平）表示，当时钟状态改变时读取特定位的值。确切的采样点由时钟模式确定；在下面的图中，它是在时钟从低电平变为高电平时：
- en: '![Using SPI to control an LED matrix](img/6623OT_10_11.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![使用SPI控制LED矩阵](img/6623OT_10_11.jpg)'
- en: The first data byte sent by the Raspberry Pi to the SPI device on the MOSI(3)
    signal
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派通过MOSI(3)信号发送的第一个数据字节
- en: The first byte sent is 0x01 (all the bits are low, except **Bit 0**) and the
    second sent is 0x03 (only **Bit 1** and **Bit 0** are high). At the same time,
    the **MOSI (4)** signal returns data from the SPI device—in this case, 0x08 (**Bit
    3** is high) and 0x00 (all the bits are low). The **SCLK (1)** signal is used
    to sync everything, even the data being sent from the SPI device.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 发送的第一个字节是0x01（所有位都是低电平，除了**位0**）和第二个发送的是0x03（只有**位1**和**位0**是高电平）。同时，**MOSI
    (4)**信号从SPI设备返回数据——在这种情况下，0x08（**位3**是高电平）和0x00（所有位都是低电平）。**SCLK (1)**信号用于同步一切，包括从SPI设备发送的数据。
- en: The **CE (2)** signal is held low while the data is being sent to instruct that
    particular SPI device to listen to the **MOSI (4)** signal. When the **CE (2)**
    signal is set to high again, it indicates to the SPI device that the transfer
    has been completed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据被发送到特定SPI设备时，**CE (2)**信号保持低电平，以指示该设备监听**MOSI (4)**信号。当**CE (2)**信号再次设置为高电平时，它表示SPI设备传输已完成。
- en: 'The following is an image of an 8 x 8 LED matrix that is controlled via the
    **SPI Bus**:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下图是一个通过**SPI总线**控制的8 x 8 LED矩阵的图像：
- en: '![Using SPI to control an LED matrix](img/6623OT_10_12.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![使用SPI控制LED矩阵](img/6623OT_10_12.jpg)'
- en: An 8 x 8 LED module displaying the letter K
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显示字母K的8 x 8 LED模块
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备中
- en: The `wiringPi` library that we used previously for I²C also supports SPI. Ensure
    that wiringPi is installed (see [Chapter 7](ch07.html "Chapter 7. Sense and Display
    Real-World Data"), *Sense and Display Real-World Data*, for details) so that we
    can use it here.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前用于I²C的`wiringPi`库也支持SPI。确保wiringPi已安装（有关详细信息，请参阅[第7章](ch07.html "第7章. 感知和显示现实世界数据")，*感知和显示现实世界数据*），这样我们就可以在这里使用它。
- en: 'Next, we need to enable SPI if we didn''t do so when we enabled I²C previously:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果我们之前在启用I²C时没有这样做，我们需要启用SPI：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Remove the `#` before #dtparam=spi=on to enable it, so it reads, and save (*Ctrl*
    + *X*, *Y*, *Enter*):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 取消`#`前的注释以启用它，然后按(*Ctrl* + *X*, *Y*, *Enter*)保存：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can confirm that the SPI is active by listing all the running modules using
    the following command and locating `spi_bcm2835`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用以下命令列出所有正在运行的模块并定位`spi_bcm2835`来确认SPI是激活的：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can test the SPI with the following `spiTest.py` script:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下`spiTest.py`脚本来测试SPI：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Connect inputs 19 and 21 to create an SPI loopback for testing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将输入19和21连接起来以创建一个用于测试的SPI环回。
- en: '![Getting ready](img/6623OT_10_13.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/6623OT_10_13.jpg)'
- en: The SPI loopback test
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: SPI环回测试
- en: 'You should get the following result:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下结果：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The example that follows uses an LED 8 x 8 matrix display that is being driven
    by an SPI-controlled **MAX7219 LED driver**:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子使用了一个由SPI控制的**MAX7219 LED驱动器**驱动的8 x 8 LED矩阵显示器：
- en: '![Getting ready](img/6623OT_10_14.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/6623OT_10_14.jpg)'
- en: An LED Controller MAX7219 pin-out, LED matrix pin-out, and LED matrix internal
    wiring (left to right)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: LED控制器MAX7219引脚图，LED矩阵引脚图，以及LED矩阵内部布线（从左到右）
- en: 'Although the device has been designed to control eight separate 7-segment LED
    digits, we can use it for our LED matrix display. When used for digits, each of
    the seven segments (plus a decimal place) is wired to one of the SEG pins, and
    the COM connection of each of the digits is wired to the DIG pins. The controller
    then switches each of the segments on as required, while setting the relevant
    digit COM low to enable it. The controller can quickly cycle through each of the
    digits using the DIG pin fast enough that all eight appear to be lit at the same
    time:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管该设备已被设计用于控制八个独立的7段LED数字，但我们可以用它来制作我们的LED矩阵显示屏。当用作数字时，每个七段（加上小数点）都连接到一个SEG引脚上，每个数字的COM连接都连接到DIG引脚上。控制器随后根据需要打开每个段，同时将相关数字的COM置低以启用它。控制器可以通过快速切换DIG引脚来快速循环每个数字，以至于所有八个数字看起来同时点亮：
- en: '![Getting ready](img/6623OT_10_15.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/6623OT_10_15.jpg)'
- en: A 7-segment LED digit uses segments A to G, plus DP (decimal place)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一个7段LED数字使用段A到G，加上小数点DP（decimal place）
- en: We use the controller in a similar way, except each SEG pin will connect to
    a column in the matrix and the DIG pins will enable/disable a row.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以类似的方式使用控制器，除了每个SEG引脚将连接到矩阵中的一列，而DIG引脚将启用/禁用一行。
- en: 'We use an 8 x 8 module connected to the MAX7219 chip as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个8 x 8模块，连接到MAX7219芯片，如下所示：
- en: '![Getting ready](img/6623OT_10_16.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/6623OT_10_16.jpg)'
- en: The MAX7219 LED controller driving an 8 x 8 LED matrix display
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: MAX7219 LED控制器驱动8 x 8 LED矩阵显示屏
- en: How to do it…
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To control an LED matrix connected to an SPI MAX7219 chip, create the following
    `matrixControl.py` script:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制连接到SPI MAX7219芯片的LED矩阵，创建以下`matrixControl.py`脚本：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Running the script (`python3 matrixControl.py`) displays the letter K.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本（`python3 matrixControl.py`）显示字母K。
- en: 'We can use a GUI to control the output of the LED matrix using `matrixMenu.py`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用GUI通过`matrixMenu.py`来控制LED矩阵的输出：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The Matrix GUI allows us to switch each of the LEDs on/off by clicking on each
    of the squares (or by directly entering the hexadecimal value) to create the required
    pattern.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Matrix GUI允许我们通过点击每个方块（或直接输入十六进制值）来切换每个LED的开/关，以创建所需的图案。
- en: '![How to do it…](img/6623OT_10_17.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/6623OT_10_17.jpg)'
- en: The Matrix GUI to control the 8 x 8 LED matrix
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 控制8 x 8 LED矩阵的Matrix GUI
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Initially, we defined addresses for each of the control registers used by the
    MAX7219 device. View the datasheet at for more information.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们为MAX7219设备使用的每个控制寄存器定义了地址。查看数据表以获取更多信息。
- en: We created a class called `matrix` that will allow us to control the module.
    The `__init__()` function sets up the SPI of the Raspberry Pi (using `SPI_CS`
    as pin 26 CS1 and `SPI_SPEED` as 100 kHz).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`matrix`的类，这将使我们能够控制该模块。`__init__()`函数设置树莓派的SPI（使用`SPI_CS`作为引脚26 CS1和`SPI_SPEED`作为100
    kHz）。
- en: 'The key function in our `matrix` class is the `sendCmd()` function; it uses
    `wiringpi.wiringPiSPIDataRW(SPI_CS,buff)` to send `buffer` (which is the raw byte
    data that we want to send) over the SPI bus (while also setting the `SPI_CS` pin
    low when the transfer occurs). Each command consists of two bytes: the first specifies
    the address of the register, and the second sets the data that needs to be put
    into it. To display a row of lights, we send the address of one of the `ROW` registers
    (`MC.MAX7219_DIGIT`) and the bit-pattern we want to display (as a byte).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`matrix`类中的关键函数是`sendCmd()`函数；它使用`wiringpi.wiringPiSPIDataRW(SPI_CS,buff)`通过SPI总线发送`buffer`（这是我们想要发送的原始字节数据，同时当传输发生时将`SPI_CS`引脚置低）。每个命令由两个字节组成：第一个指定寄存器的地址，第二个设置需要放入的数据。要显示一排灯光，我们发送一个`ROW`寄存器（`MC.MAX7219_DIGIT`）的地址和我们想要显示的位模式（作为一个字节）。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: After the `wiringpi.wiringPiSPIDataRW()` function is called, `buffer` contains
    the result of whatever is received on the MISO pin (which is read simultaneously
    as the data is sent via the MOSI pin). If connected, this will be the output of
    the LED module (a delayed copy of the data that was sent). Refer to the following
    *There's more…* section regarding daisy-chained SPI configurations to learn how
    the chip output can be used.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`wiringpi.wiringPiSPIDataRW()`函数后，`buffer`包含从MISO引脚接收到的结果（该引脚在数据通过MOSI引脚发送的同时被读取）。如果连接，这将是从LED模块输出的结果（发送数据的延迟副本）。有关有关菊花链SPI配置的更多信息，请参阅以下*更多内容…*部分，了解如何使用芯片输出。
- en: To initialize the MAX7219, we need to ensure that it is configured in the correct
    mode. First, we set the **Scan Limit** field to `7` (which enables all the DIG0
    - DIG7 outputs). Next, we disable the built-in digit decoding since we are using
    the raw output for the display (and don't want it to try to display digits). We
    also want to ensure that the `MAX7219_DISPLAYTEST` register is disabled (if enabled,
    it would turn on all the LEDs).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化 MAX7219，我们需要确保它配置在正确的模式。首先，我们将 **扫描限制** 字段设置为 `7`（这将启用所有 DIG0 - DIG7 输出）。接下来，我们禁用了内置的数字解码，因为我们正在使用原始输出显示（并且不希望它尝试显示数字）。我们还希望确保
    `MAX7219_DISPLAYTEST` 寄存器被禁用（如果启用，它将点亮所有 LED）。
- en: We ensure the display is cleared by calling our own `clear()` function, which
    sends `0` to each of the `MAX7219_DIGIT` registers to clear each of the rows.
    Finally, we use the `MAX7219_INTENSITY` register to set the brightness of the
    LEDs. The brightness is controlled using a PWM output to make the LEDs appear
    brighter or darker according to the brightness that is required.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用自己的 `clear()` 函数来确保显示被清除，该函数将 `0` 发送到每个 `MAX7219_DIGIT` 寄存器以清除每一行。最后，我们使用
    `MAX7219_INTENSITY` 寄存器设置 LED 的亮度。亮度通过 PWM 输出控制，以根据所需的亮度使 LED 看起来更亮或更暗。
- en: Within the `main()` function, we perform a quick test to display the letter
    K on the grid by sending a set of 8 bytes (`0x0066763e1e366646`).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们通过发送一组 8 个字节（`0x0066763e1e366646`）来在网格上快速测试显示字母 K。
- en: '![How it works...](img/6623OT_10_18.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: 每个 8 x 8 模式由 8 字节中的 8 位组成（每列一位，使每个字节成为显示中的一行）
- en: Each 8 x 8 pattern consists of 8 bits in 8 bytes (one bit for each column, making
    each byte a row in the display)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![工作原理...](img/6623OT_10_18.jpg)'
- en: The `matrixGUI` class creates a canvas object that is populated with a grid
    of rectangle objects to represent the 8 x 8 grid of LEDs we want to control (these
    are kept in `self.light`). We also add a text entry box to display the resulting
    bytes that we will send to the LED matrix module. We then bind the `<Button-1>`
    mouse event to the canvas so that `mouseClick` is called whenever a mouse click
    occurs within the area of the canvas.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`matrixGUI` 类创建了一个画布对象，该对象填充了一个矩形对象的网格，以表示我们想要控制的 8 x 8 LED 网格（这些保存在 `self.light`
    中）。我们还添加了一个文本输入框来显示我们将发送到 LED 矩阵模块的结果字节。然后我们将 `<Button-1>` 鼠标事件绑定到画布，以便在画布区域内发生鼠标点击时调用
    `mouseClick`。'
- en: We attach a function called `changedCode()` to the `codeText` variable using
    `trace`, a special Python function, which allows us to monitor specific variables
    or functions. If we use the `'w'` value with the `trace` function, the Python
    system will call the callback function whenever the value is written to.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用特殊的 Python 函数 `trace` 将一个名为 `changedCode()` 的函数附加到 `codeText` 变量上，这允许我们监控特定的变量或函数。如果我们使用
    `trace` 函数的 `'w'` 值，Python 系统将在值被写入时调用回调函数。
- en: When the `mouseClick()` function is called, we use the `event.x` and `event.y`
    coordinates to identify the object that is located there. If an item is detected,
    then the ID of the item is used (via `toggleLight()`) to toggle the corresponding
    bit in the `self.lightStatus` value, and the color of the light in the display
    changes accordingly (via `setLight()`). The `codeText` variable is also updated
    with the new hexadecimal representation of the `lightStatus` value.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `mouseClick()` 函数被调用时，我们使用 `event.x` 和 `event.y` 坐标来识别该位置的对象。如果检测到项目，则使用项目的
    ID（通过 `toggleLight()`）来切换 `self.lightStatus` 值中的相应位，并且显示中的灯光颜色相应改变（通过 `setLight()`）。`codeText`
    变量也更新为 `lightStatus` 值的新十六进制表示。
- en: The `changeCode()` function allows us to use the `codeText` variable and translate
    it into an integer. This allows us to check whether it is a valid value. Since
    it is possible to enter text here freely, we must validate it. If we are unable
    to convert it to an integer, the `codeValue` text is refreshed using the `lightStatus`
    value. Otherwise, we check if it is too large, in which case we perform a bit-shift
    by four to divide it by 16 until it is within a valid range. We update the `lightStatus`
    value, the GUI lights, the `codeText` variable, and also the hardware (by calling
    `updateHardware()`).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`changeCode()` 函数允许我们使用 `codeText` 变量并将其转换为整数。这允许我们检查它是否是一个有效的值。由于可以在这里自由输入文本，我们必须对其进行验证。如果我们无法将其转换为整数，则使用
    `lightStatus` 值刷新 `codeValue` 文本。否则，我们检查它是否太大，在这种情况下，我们通过四位位移操作将其除以 16，直到它在有效范围内。我们更新
    `lightStatus` 值、GUI 灯光、`codeText` 变量，以及硬件（通过调用 `updateHardware()`）。'
- en: The `updateHardware()` function makes use of the `myMatrixHW` object that was
    created using the `MC.matrix` class. We send the bytes that we want to display
    to the matrix hardware one byte at a time (along with the corresponding `MAX7219_DIGIT`
    value to specify the row).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateHardware()`函数利用使用`MC.matrix`类创建的`myMatrixHW`对象。我们一次发送一个字节，我们想要显示到矩阵硬件的字节（以及相应的`MAX7219_DIGIT`值以指定行）。'
- en: There's more...
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The SPI bus allows us to control multiple devices on the same bus by using the
    Chip Enable signal. Some devices, such as the MAX7219, also allow what is known
    as a daisy-chain SPI configuration.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: SPI总线允许我们通过使用芯片使能信号来控制同一总线上多个设备。一些设备，如MAX7219，还允许所谓的菊花链SPI配置。
- en: Daisy-chain SPI configuration
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Daisy-chain SPI configuration
- en: 'You may have noticed that the `matrix` class also returns a byte when we send
    the data on the MOSI line. This is the data output from the MAX7219 controller
    on the DOUT connection. The MAX7219 controller actually passes all the DIN data
    through to DOUT, which is one set of instructions behind the DIN data. In this
    way, the MAX7219 can be daisy-chained (with each DOUT feeding into the next DIN).
    By keeping the CE signal low, multiple controllers can be loaded with data by
    being passed though one another. The data is ignored while CE is set to low, the
    outputs will only be changed when we set it high again. In this way, you can clock
    in all the data for each of the modules in the chain and then set CE to high to
    update them:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，当我们通过MOSI线发送数据时，`matrix`类也会返回一个字节。这是从MAX7219控制器DOUT连接输出的数据。MAX7219控制器实际上将所有DIN数据传递到DOUT，这比DIN数据晚一集指令。这样，MAX7219可以通过菊花链（每个DOUT输入到下一个DIN）连接。通过保持CE信号低，可以通过相互传递数据来向多个控制器加载数据。当CE设置为低时，数据将被忽略，输出只有在再次将其设置为高时才会改变。这样，你可以为链中的每个模块时钟所有数据，然后设置CE为高以更新它们：
- en: '![Daisy-chain SPI configuration](img/6623OT_10_19.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![菊花链SPI配置](img/6623OT_10_19.jpg)'
- en: The daisy-chain SPI configuration
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 菊花链SPI配置
- en: We need to do this for each row that we wish to update (or use `MAX7219_NOOP`
    if we want to keep the current row the same). This is known as a daisy-chain SPI
    configuration, supported by some SPI devices, where data is passed through each
    device on the SPI bus to the next one, which allows the use of three bus control
    signals for multiple devices.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为每个我们希望更新的行做这件事（或者如果我们想保持当前行不变，可以使用`MAX7219_NOOP`）。这被称为菊花链SPI配置，由一些SPI设备支持，其中数据通过SPI总线上的每个设备传递到下一个设备，这允许使用三个总线控制信号来控制多个设备。
- en: Communicating using a serial interface
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用串行接口进行通信
- en: Traditionally, serial protocols such as RS232 are a common way to connect devices
    such as printers and scanners as well as joysticks and mouse devices to computers.
    Now, despite being superseded by USB, many peripherals still make use of this
    protocol for internal communication between components, to transfer data, and
    to update firmware. For electronics hobbyists, RS232 is a very useful protocol
    for debugging and controlling other devices while avoiding the complexities of
    USB.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，串行协议如RS232是连接打印机、扫描仪以及游戏手柄和鼠标设备等设备的常用方式。现在，尽管被USB取代，但许多外围设备仍然使用此协议进行组件之间的内部通信、数据传输和固件更新。对于电子爱好者来说，RS232是一个非常有用的协议，用于调试和控制其他设备，同时避免了USB的复杂性。
- en: The two scripts in this example allow for the control of the GPIO pins to illustrate
    how we can remotely control the Raspberry Pi through the serial port. The serial
    port could be connected to a PC, another Raspberry Pi, or even an embedded microcontroller
    (such as Arduino, PIC, or similar).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中的两个脚本允许控制GPIO引脚，以说明我们如何通过串行端口远程控制树莓派。串行端口可以连接到PC、另一个树莓派，甚至嵌入式微控制器（如Arduino、PIC或类似设备）。
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The easiest way to connect to the Raspberry Pi via a serial protocol will depend
    on whether your computer has a built-in serial port or not. The serial connection,
    software, and test setup are described in the following three steps:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通过串行协议连接到树莓派的最简单方法取决于你的计算机是否有内置串行端口。串行连接、软件和测试设置在以下三个步骤中描述：
- en: 'Create an RS232 serial connection between your computer and the Raspberry Pi.
    For this, you need one of the following setups:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的计算机和树莓派之间创建一个RS232串行连接。为此，你需要以下配置之一：
- en: If your computer has a built-in serial port available, you can use a Null-Modem
    cable with an RS232 to USB adaptor to connect to the Raspberry Pi:![Getting ready](img/6623OT_10_20.jpg)
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的计算机有内置的串行端口可用，您可以使用RS232到USB适配器和Null-Modem线连接到树莓派：![准备就绪](img/6623OT_10_20.jpg)
- en: USB for an RS232 adaptor
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于RS232适配器的USB
- en: 'A Null-Modem is a serial cable/adaptor that has the TX and RX wires crossed
    over so that one side is connected to the TX pin of the serial port, whereas the
    other side is connected to the RX pin:'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Null-Modem是一种串行线/适配器，其TX和RX线交叉连接，使得一边连接到串行端口的TX引脚，而另一边连接到RX引脚：
- en: '![Getting ready](img/6623OT_10_21.jpg)'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![准备就绪](img/6623OT_10_21.jpg)'
- en: A PC serial port connected to the Raspberry Pi via a Null-Modem cable and an
    RS232 to USB adaptor
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过Null-Modem线和RS232到USB适配器连接到树莓皮的PC串行端口
- en: Note
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A list of supported USB to RS232 devices is available at the following link:
    [http://elinux.org/RPi_VerifiedPeripherals#USB_UART_and_USB_to_Serial_.28RS-232.29_adapters](http://elinux.org/RPi_VerifiedPeripherals#USB_UART_and_USB_to_Serial_.28RS-232.29_adapters)'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 支持的USB到RS232设备列表可在以下链接中找到：[http://elinux.org/RPi_VerifiedPeripherals#USB_UART_and_USB_to_Serial_.28RS-232.29_adapters](http://elinux.org/RPi_VerifiedPeripherals#USB_UART_and_USB_to_Serial_.28RS-232.29_adapters)
- en: Refer to the *There's more…* section for details on how to set them up.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请参阅*更多内容…*部分以获取有关如何设置的详细信息。
- en: If you do not have a serial port built into your computer, you can use another
    USB to RS232 adaptor to connect to the PC/laptop, converting the RS232 to the
    more common USB connection.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您的计算机没有内置的串行端口，您可以使用另一个USB到RS232适配器连接到PC/笔记本电脑，将RS232转换为更常见的USB连接。
- en: If you do not have any available USB ports on the Raspberry Pi, you can use
    the GPIO serial pins directly with either a Serial Console Cable or a Bluetooth
    serial module (refer to the *There's more…* section for details). Both of these
    will require some additional setup.
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果树莓派上没有可用的USB端口，您可以直接使用串行控制线或蓝牙串行模块的GPIO串行引脚（有关详细信息，请参阅*更多内容…*部分）。这两者都需要一些额外的设置。
- en: For all cases, you can use an RS232 loopback to confirm that everything is working
    and set up correctly (again, refer to the *There's more…* section).
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于所有情况，您可以使用RS232环回确认一切正常且设置正确（再次，请参阅*更多内容…*部分）。
- en: Next, prepare the software you need for this example.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，准备您需要的软件。
- en: You will need to install pySerial so we can use the serial port with Python
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要安装pySerial，以便我们可以使用Python使用串行端口
- en: 'Install pySerial with the following command (you will also need PIP installed;
    refer to [Chapter 3](ch03.html "Chapter 3. Using Python for Automation and Productivity"),
    *Using Python for Automation and Productivity*, for details):'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装pySerial（您还需要安装PIP；有关详细信息，请参阅[第3章](ch03.html "第3章。使用Python进行自动化和生产率")，*使用Python进行自动化和生产率*）：
- en: '[PRE23]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Refer to the `pySerial` site for further documentation: [https://pyserial.readthedocs.io/en/latest/](https://pyserial.readthedocs.io/en/latest/).'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请参阅pySerial网站以获取更多文档：[https://pyserial.readthedocs.io/en/latest/](https://pyserial.readthedocs.io/en/latest/)
- en: In order to demonstrate the RS232 serial control, you will require some example
    hardware attached to the Raspberry Pi's GPIO pins.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了演示RS232串行控制，您需要将一些示例硬件连接到树莓派的GPIO引脚。
- en: 'The `serialMenu.py` script allows the GPIO pins to be controlled through commands
    sent through the serial port. To fully test this, you can connect suitable output
    devices (such as LEDs) to each of the GPIO pins. You can ensure that the total
    current is kept low using 470 ohm resistors for each of the LEDs so that the maximum
    GPIO current that the Raspberry Pi can supply is not exceeded:'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`serialMenu.py`脚本允许通过串行端口发送的命令来控制GPIO引脚。为了完全测试这一点，您可以将适当的输出设备（如LED）连接到每个GPIO引脚。您可以使用每个LED的470欧姆电阻来确保总电流保持较低，这样树莓皮可以提供的最大GPIO电流就不会超过：'
- en: '![Getting ready](img/6623OT_10_22.jpg)'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![准备就绪](img/6623OT_10_22.jpg)'
- en: A test circuit to test the GPIO output via serial control
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个用于通过串行控制测试GPIO输出的测试电路
- en: How to do it...
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create the following `serialControl.py` script:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下`serialControl.py`脚本：
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Ensure that the `serName` element is correct for the serial port we want to
    use (such as `/dev/ttyAMA0` for the GPIO pins or `/dev/ttyUSB0` for a USB RS232
    adaptor).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 确保使用`serName`元素正确设置我们想要使用的串行端口（例如，对于GPIO引脚是`/dev/ttyAMA0`，对于USB RS232适配器是`/dev/ttyUSB0`）。
- en: Connect the other end to a serial port on your laptop or computer (the serial
    port can be another USB to RS232 adaptor).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 将另一端连接到笔记本电脑或计算机的串行端口（串行端口可以是另一个USB到RS232适配器）。
- en: Monitor the serial port on your computer using a serial program such as HyperTerminal
    or RealTerm () for Windows or Serial Tools for OS X. You will need to ensure that
    you have the correct COM port set and a baud rate of 9600 bps (`Parity=None`,
    `Data Bits=8`, `Stop Bits=1`, and `Hardware Flow Control=None`).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用串行程序（如 Windows 的 HyperTerminal 或 RealTerm 或 OS X 的 Serial Tools）监控你计算机上的串行端口。你需要确保设置了正确的
    COM 端口，并设置了 9600 bps 的波特率（`奇偶校验=None`、`数据位=8`、`停止位=1` 和 `硬件流控制=None`）。
- en: The script will send a request for data from the user and wait for a response.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将向用户发送请求数据，并等待响应。
- en: To send data to the Raspberry Pi, write some text on the other computer and
    press *Enter* to send it over to the Raspberry Pi.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要向树莓派发送数据，请在另一台计算机上输入一些文本，然后按 *Enter* 键将其发送到树莓派。
- en: 'You will see output similar to the following on the Raspberry Pi terminal:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在树莓派终端上看到类似以下输出：
- en: '![How to do it...](img/6623OT_10_23.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/6623OT_10_23.jpg)'
- en: The text "Switch on LED 1" has been sent via a USB to RS232 cable from a connected
    computer
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 文本 "打开 LED 1" 已通过连接的计算机的 USB 到 RS232 电缆发送
- en: 'You will also see output similar to the following on the serial monitoring
    program:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你也会在串行监控程序中看到类似以下输出：
- en: '![How to do it...](img/6623OT_10_24.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/6623OT_10_24.jpg)'
- en: RealTerm displaying typical output from the connected serial port
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: RealTerm 显示连接的串行端口的典型输出
- en: Press *Ctrl* + *C* on the Raspberry Pi to stop the script.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在树莓派上按 *Ctrl* + *C* 停止脚本。
- en: 'Now, create a GPIO control menu. Create `serialMenu.py`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个 GPIO 控制菜单。创建 `serialMenu.py`：
- en: '[PRE25]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When you run the script (`sudo python3 serialMenu.py`), type the control messages
    within the serial monitoring program:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行脚本（`sudo python3 serialMenu.py`）时，在串行监控程序中输入控制消息：
- en: '![How to do it...](img/6623OT_10_25.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/6623OT_10_25.jpg)'
- en: The GPIO Serial Control menu
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO 串行控制菜单
- en: 'The terminal output on the Raspberry Pi will be similar to the following screenshot,
    and the LEDs should respond accordingly:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派上的终端输出将类似于以下截图，LED灯应该相应地响应：
- en: '![How to do it...](img/6623OT_10_26.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/6623OT_10_26.jpg)'
- en: The GPIO Serial Control menu
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO 串行控制菜单
- en: The Raspberry Pi validates the commands received from the serial connection
    and switches the LEDs connected to the GPIO pins 7 and 11 on and then off.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派验证从串行连接接收到的命令，并切换连接到 GPIO 引脚 7 和 11 的 LED 灯的开和关。
- en: How it works...
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first script, `serialControl.py`, provides us with a `serPort` class. We
    define the class with the following functions:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个脚本 `serialControl.py` 为我们提供了一个 `serPort` 类。我们使用以下函数定义该类：
- en: '`__init__(self,serName="/dev/ttyAMA0")`: This function will create a new serial
    device using `serName`—the default of `"/dev/ttyAMA0`" is the ID for the GPIO
    serial pins (see the *There''s more...* section). After it is initialized, information
    about the device is displayed.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__(self,serName="/dev/ttyAMA0")`：此函数将使用 `serName` 创建一个新的串行设备——默认的 `"/dev/ttyAMA0"`
    是 GPIO 串行引脚的 ID（见 *更多内容* 部分）。初始化后，将显示设备信息。'
- en: '`__enter__(self)`: This is a dummy function that allows us to use the `with…as`
    method.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__enter__(self)`：这是一个虚拟函数，允许我们使用 `with…as` 方法。'
- en: '`send(self,message)`: This is used to check that the serial port is open and
    not in use; if so, it will then send a message (after converting it to raw bytes
    using the `s2b()` function).'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send(self,message)`：此函数用于检查串行端口是否打开且未被使用；如果是，它将使用 `s2b()` 函数将消息转换为原始字节后发送消息。'
- en: '`receive(self, chars=1, echo=True, terminate="\r")`: After checking whether
    the serial port is open and not in use, this function then waits for data through
    the serial port. The function will collect data until the terminate characters
    are detected, and then the full message is returned.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`receive(self, chars=1, echo=True, terminate="\r")`：在检查串行端口是否打开且未被使用后，此函数将等待通过串行端口接收数据。该函数将收集数据，直到检测到终止字符，然后返回完整消息。'
- en: '`__exit__(self,type,value,traceback)`: This function is called when the `serPort`
    object is no longer required by the `with…as` method, so we can close the port
    at this point.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__exit__(self,type,value,traceback)`：当 `serPort` 对象不再需要 `with…as` 方法时，将调用此函数，因此我们可以在此处关闭端口。'
- en: The `main()` function in the script performs a quick test of the class by sending
    a prompt for data through the serial port to a connected computer and then waiting
    for input that will be followed by the terminate character(s).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本中的 `main()` 函数通过通过串行端口向连接的计算机发送数据提示并等待带有终止字符的输入来对类进行快速测试。
- en: The next script, `serialMenu.py`, allows us to make use of the `serPort` class.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个脚本`serialMenu.py`允许我们使用`serPort`类。
- en: The `main()` function sets up the GPIO pins as outputs (via `gpioSetup()`),
    creates a new `serPort` object, and finally, waits for commands through the serial
    port. Whenever a new command is received, the `handleCmd()` function is used to
    parse the message to ensure that it is correct before acting on it.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数设置GPIO引脚为输出（通过`gpioSetup()`），创建一个新的`serPort`对象，并最终通过串行端口等待命令。每当接收到新命令时，`handleCmd()`函数用于解析消息以确保它在采取行动之前是正确的。'
- en: The script will switch a particular GPIO pin on or off as commanded through
    the serial port using the `GPIO` command keyword. We could add any number of command
    keywords and control (or read) whatever device (or devices) we attached to the
    Raspberry Pi. We now have a very effective way to control the Raspberry Pi using
    any devices connected via a serial link.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本将根据通过串行端口接收到的命令切换特定的GPIO引脚的开或关，使用`GPIO`命令关键字。我们可以添加任意数量的命令关键字并控制（或读取）我们连接到Raspberry
    Pi的任何设备（或设备）。我们现在有一种非常有效的方法来通过串行链路连接的任何设备控制Raspberry Pi。
- en: There's more...
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In addition to the serial transmit and receive, the RS232 serial standard includes
    several other control signals. To test it, you can use a serial loopback to confirm
    if the serial ports are set up correctly.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 除了串行发送和接收之外，RS232串行标准还包括其他几个控制信号。为了测试它，您可以使用串行环回以确认串行端口是否设置正确。
- en: Configuring a USB to RS232 device for the Raspberry Pi
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为Raspberry Pi配置USB到RS232设备
- en: 'Once you have connected the USB to RS232 device to the Raspberry Pi, check
    to see if a new serial device is listed by typing the following command:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您将USB到RS232设备连接到Raspberry Pi，请通过输入以下命令来检查是否列出了新的串行设备：
- en: '[PRE26]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `dmesg` command lists events that occur on the system; using `grep`, we
    can filter any messages that mention `tty`, as shown in the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`dmesg`命令列出了系统上发生的事件；使用`grep`，我们可以过滤出任何提及`tty`的消息，如下面的代码所示：'
- en: '[PRE27]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This shows that a PL2303-based USB-RS232 device was attached (2,409 seconds
    after startup) and allocated the `ttyUSB0` identity. You will see that a new serial
    device has been added within the `/dev/` directory (usually `/dev/ttyUSB0` or
    something similar).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明基于PL2303的USB-RS232设备已连接（启动后2,409秒）并分配了`ttyUSB0`标识。您将看到在`/dev/`目录下已添加了一个新的串行设备（通常是`/dev/ttyUSB0`或类似）。
- en: If the device has not been detected, you can try steps similar to the ones used
    in [Chapter 1](ch01.html "Chapter 1. Getting Started with a Raspberry Pi Computer"),
    *Getting Started with a Raspberry Pi Computer*, to locate and install suitable
    drivers (if they are available).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备未被检测到，您可以尝试与[第1章](ch01.html "第1章。使用Raspberry Pi计算机入门")中使用的步骤类似的步骤，即*使用Raspberry
    Pi计算机入门*，以定位和安装合适的驱动程序（如果可用）。
- en: RS232 signals and connections
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: RS232信号和连接
- en: The RS232 serial standard has lots of variants and includes six additional control
    signals.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: RS232串行标准有很多变体，包括六个额外的控制信号。
- en: 'The Raspberry Pi GPIO serial drivers (and the Bluetooth TTL module used in
    the following example) only support RX and TX signals. If you require support
    for other signals, such as DTR that is often used for a reset prior to the programming
    of AVR/Arduino devices, then alternative GPIO serial drivers may be needed to
    set these signals via other GPIO pins. Most RS232 to USB adaptors should support
    the standard signals; however, ensure that anything you connect is able to handle
    standard RS232 voltages:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi GPIO串行驱动程序（以及以下示例中使用的蓝牙TTL模块）仅支持RX和TX信号。如果您需要支持其他信号，例如常用于AVR/Arduino设备编程前的重置的DTR，则可能需要其他GPIO串行驱动程序来通过其他GPIO引脚设置这些信号。大多数RS232到USB适配器应支持标准信号；然而，请确保您连接的任何设备都能处理标准RS232电压：
- en: '![RS232 signals and connections](img/6623OT_10_27.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![RS232信号和连接](img/6623OT_10_27.jpg)'
- en: The RS232 9-Way D Connector pin-out and signals
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: RS232 9-Way D连接器引脚排列和信号
- en: 'For more details on the RS232 serial protocol and to know how these signals
    are used, visit the following link [http://en.wikipedia.org/wiki/Serial_port](http://en.wikipedia.org/wiki/Serial_port):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '有关RS232串行协议的更多详细信息以及了解这些信号如何使用，请访问以下链接[http://en.wikipedia.org/wiki/Serial_port](http://en.wikipedia.org/wiki/Serial_port):'
- en: Using the GPIO built-in serial pins
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用GPIO内置的串行引脚
- en: 'Standard RS232 signals can range from -15V to +15V, so you must never directly
    connect any RS232 device to the GPIO serial pins. You must use an RS232 to TTL
    voltage-level converter (such as a MAX232 chip) or a device that uses TTL-level
    signals (such as another microcontroller or a TTL serial console cable):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the GPIO built-in serial pins](img/6623OT_10_28.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: A USB to TTL serial console cable
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi has TTL-level serial pins on the GPIO header that allow the
    connection of a TTL serial USB cable. The wires will connect to the Raspberry
    Pi GPIO pins, and the USB will plug in to your computer and be detected like a
    standard RS232 to USB cable.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the GPIO built-in serial pins](img/6623OT_10_29.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
- en: Connection of a USB to TTL serial console cable to the Raspberry Pi GPIO
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to provide power from the USB port to the 5V pin; however, this
    will bypass the built-in polyfuse, so it is not recommended for general use (just
    leave the 5V wire disconnected and power as normal through the micro-USB).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: By default, these pins are set up to allow remote terminal access, allowing
    you to connect to the COM port via PuTTY and create a serial SSH session.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A serial SSH session can be helpful if you want to use the Raspberry Pi without
    a display attached to it.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: However, a serial SSH session is limited to text-only terminal access since
    it does not support X10 Forwarding, as used in the *Connecting remotely to Raspberry
    Pi over the network using SSH (and X11 Forwarding)* section of [Chapter 1](ch01.html
    "Chapter 1. Getting Started with a Raspberry Pi Computer"), *Getting Started with
    a Raspberry Pi Computer*.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: In order to use it as a standard serial connection, we have to disable the serial
    console so it is available for us to use.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to edit `/boot/cmdline.txt` to remove the first `console` and
    `kgboc` options (do not remove the other `console=tty1` option, which is the default
    terminal when you switch on):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The previous command line becomes the following (ensure that this is still
    a single command line):'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We also have to remove the task that runs the `getty` command (the program
    that handles the text terminal for the serial connection) by commenting it out
    with `#`. This is set in `/etc/inittab` as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The previous command line becomes the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To reference the GPIO serial port in our script, we use its name, `/dev/ttyAMA0`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: The RS232 loopback
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can check whether the serial port connections are working correctly using
    a serial loopback.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple loopback consists of connecting RXD and TXD together. These are pins
    8 and 10 on the Raspberry Pi GPIO header, or pins 2 and 3 on the standard RS232
    D9 connector on the USB-RS232 adaptor:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '![The RS232 loopback](img/6623OT_10_30.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
- en: Serial loopback connections to test the Raspberry Pi GPIO (left) and RS232 9-Way
    D Connector (right)
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: An RS232 full loopback cable also connects pin 4 (DTR) and pin 6 (DSR) as well
    as pin 7 (RTS) and pin 8 (CTS) on the RS232 adaptor. However, this is not required
    for most situations, unless these signals are used. By default, no pins are allocated
    on the Raspberry Pi specifically for these additional signals.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: RS232全环回电缆还连接了RS232适配器上的4号引脚（DTR）和6号引脚（DSR），以及7号引脚（RTS）和8号引脚（CTS）。然而，在大多数情况下，这并不是必需的，除非使用这些信号。默认情况下，Raspberry
    Pi上没有为这些额外信号分配引脚。
- en: '![The RS232 loopback](img/6623OT_10_31.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![RS232环回测试](img/6623OT_10_31.jpg)'
- en: RS232 full loopback
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: RS232全环回
- en: 'Create the following `serialTest.py` script:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下`serialTest.py`脚本：
- en: '[PRE32]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When a loopback is connected, you will observe that the message is echoed back
    to the screen (when removed, `No data Received` will be displayed):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当环回连接时，你会观察到消息被回显到屏幕上（当移除时，将显示`No data Received`）：
- en: '![The RS232 loopback](img/6623OT_10_32.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![RS232环回测试](img/6623OT_10_32.jpg)'
- en: An RS232 loopback test on GPIO serial pins
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在GPIO串行引脚上进行的RS232环回测试
- en: 'If we require non-default settings, they can be defined when the serial port
    is initialized (the pySerial documentation at [https://pyserial.readthedocs.io/en/latest/](https://pyserial.readthedocs.io/en/latest/)
    provides full details of all the options), as shown in the following code:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要非默认设置，它们可以在初始化串行端口时定义（pySerial文档在[https://pyserial.readthedocs.io/en/latest/](https://pyserial.readthedocs.io/en/latest/)提供了所有选项的完整详情），如下面的代码所示：
- en: '[PRE33]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Controlling the Raspberry Pi over Bluetooth
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过蓝牙控制Raspberry Pi
- en: 'Serial data can also be sent through Bluetooth by connecting a HC-05 Bluetooth
    module that supports the **Serial Port Profile** (**SPP**) to the GPIO serial
    RX/TX pins. This allows the serial connection to become wireless, which allows
    Android tablets or smartphones to be used to control things and read data from
    the Raspberry Pi:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 通过连接支持**串行端口配置文件**（**SPP**）的HC-05蓝牙模块到GPIO串行RX/TX引脚，串行数据也可以通过蓝牙发送。这允许串行连接无线化，从而可以使用Android平板电脑或智能手机来控制事物并从Raspberry
    Pi读取数据：
- en: '![Controlling the Raspberry Pi over Bluetooth](img/6623OT_10_33.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![通过蓝牙控制Raspberry Pi](img/6623OT_10_33.jpg)'
- en: The HC-05 Bluetooth module for the TLL serial
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: TLL串行HC-05蓝牙模块
- en: Note
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While it is possible to achieve a similar result using a USB Bluetooth dongle,
    additional configuration would be required depending on the particular dongle
    used. The TTL Bluetooth module provides a drop-in replacement for a physical cable,
    requiring very little additional configuration.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用USB蓝牙适配器实现类似的结果，但根据所使用的特定适配器，可能需要额外的配置。TTL蓝牙模块为物理电缆提供了一个即插即用的替代品，需要非常少的额外配置。
- en: Getting ready
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that the serial console has been disabled (see the previous *There's
    more…* section).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 确保串行控制台已被禁用（参见之前的*更多内容…*部分）。
- en: 'The module should be connected using the following pins:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 模块应使用以下引脚连接：
- en: '![Getting ready](img/6623OT_10_34.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/6623OT_10_34.jpg)'
- en: Connection to a Bluetooth module for the TLL serial
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到TLL串行的蓝牙模块
- en: How to do it...
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: With the Bluetooth module configured and connected, we can pair the module with
    a laptop or smartphone to send and receive commands wirelessly. Bluetooth SPP
    Pro provides an easy way to use a serial connection over Bluetooth to control
    or monitor the Raspberry Pi for Android devices.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝牙模块配置并连接后，我们可以将模块与笔记本电脑或智能手机配对，以无线发送和接收命令。蓝牙SPP Pro为Android设备提供了一个简单的方法，通过蓝牙使用串行连接来控制或监控Raspberry
    Pi。
- en: 'Alternatively, you may be able to set up a Bluetooth COM port on your PC/laptop
    and use it in the same way as the previous wired example:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可能在PC/笔记本电脑上设置一个蓝牙COM端口，并以与之前有线示例相同的方式使用它：
- en: When the device is connected initially, the LED flashes quickly to indicate
    that it is waiting to be paired. Enable Bluetooth on your device and select the
    **HC-05** device:![How to do it...](img/6623OT_10_35.jpg)
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当设备首次连接时，LED快速闪烁以指示它正在等待配对。在您的设备上启用蓝牙并选择**HC-05**设备：![如何操作...](img/6623OT_10_35.jpg)
- en: The HC-05 Bluetooth module viewable in Bluetooth SPP Pro
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在蓝牙SPP Pro中可查看的HC-05蓝牙模块
- en: Click on the **Pair** button to begin the pairing process and enter the device's
    **PIN** (the default is `1234`):![How to do it...](img/6623OT_10_36.jpg)
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**配对**按钮开始配对过程并输入设备的**PIN**（默认为`1234`）：![如何操作...](img/6623OT_10_36.jpg)
- en: Pair the Bluetooth device with the PIN code (1234)
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用PIN码（1234）配对蓝牙设备
- en: If the pairing was successful, you will be able to connect with the device and
    send and receive messages to and from the Raspberry Pi:![How to do it...](img/6623OT_10_37.jpg)
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果配对成功，您将能够连接到设备，并向Raspberry Pi发送和接收消息：![如何操作...](img/6623OT_10_37.jpg)
- en: Connect to the device and select the control method
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 连接到设备并选择控制方法
- en: In **Keyboard mode**, you can define actions for each of the buttons to send
    suitable commands when pressed.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**键盘模式**下，您可以定义每个按钮的动作，以便在按下时发送合适的命令。
- en: For example, **Pin12 ON** can be set to send `gpio 12 on`, and **Pin12 OFF**
    can be set to send `gpio 12 off`.
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，**Pin12 ON**可以设置为发送`gpio 12 on`，而**Pin12 OFF**可以设置为发送`gpio 12 off`。
- en: Ensure that you set the end flag to `\r\n` via the menu options.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保通过菜单选项设置结束标志为`\r\n`。
- en: 'Ensure that `menuSerial.py` is set to use the GPIO serial connection:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将`menuSerial.py`设置为使用GPIO串行连接：
- en: '[PRE34]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run the `menuSerial.py` script (with the LEDs attached):'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`menuSerial.py`脚本（连接LED）：
- en: '[PRE35]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Check that the Bluetooth serial app displays the `GPIO Serial Control` menu
    as shown in the following screenshot:![How to do it...](img/6623OT_10_38.jpg)
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认蓝牙串行应用显示的`GPIO Serial Control`菜单，如下面的截图所示：![如何操作...](img/6623OT_10_38.jpg)
- en: GPIO control over Bluetooth
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过蓝牙进行GPIO控制
- en: We can see from the output in the following screenshot that the commands have
    been received and the LED connected to pin 12 has been switched on and off as
    required.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下截图的输出中我们可以看到，命令已被接收，连接到12号引脚的LED已按需打开和关闭。
- en: '![How to do it...](img/6623OT_10_39.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/6623OT_10_39.jpg)'
- en: The Raspberry Pi receiving GPIO control over Bluetooth
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi通过蓝牙接收GPIO控制
- en: How it works...
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By default, the Bluetooth module is set up to act like a TTL serial slave device,
    so we can simply plug it in to the GPIO RX and TX pins. Once the module is paired
    with a device, it will transfer the serial communication over the Bluetooth connection.
    This allows us to send commands and receive data via Bluetooth and control the
    Raspberry Pi using a smart phone or PC.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，蓝牙模块被设置为类似于TTL串行从设备，因此我们可以直接将其插入GPIO RX和TX引脚。一旦模块与设备配对，它将通过蓝牙连接传输串行通信。这使得我们可以通过蓝牙发送命令和接收数据，并使用智能手机或PC控制Raspberry
    Pi。
- en: This means you can attach a second module to another device (such as an Arduino)
    that has TTL serial pins and control it using the Raspberry Pi (either by pairing
    it with another TTL Bluetooth module or suitably configuring a USB Bluetooth dongle).
    If the module is set up as a master device, then you will need to reconfigure
    it to act as a slave (see the *There's more…* section).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您可以将第二个模块连接到另一个具有TTL串行引脚的设备（例如Arduino），并使用Raspberry Pi（通过与其他TTL蓝牙模块配对或适当配置USB蓝牙适配器）来控制它。如果模块被设置为主设备，那么您需要重新配置它以作为从设备（请参阅*还有更多…*部分）。
- en: There's more...
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Now, let's understand how to configure the Bluetooth settings.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解如何配置蓝牙设置。
- en: Configuring Bluetooth module settings
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置蓝牙模块设置
- en: The Bluetooth module can be set in two different modes using the KEY pin.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用KEY引脚将蓝牙模块设置为两种不同的模式。
- en: In a normal operation, serial messages are sent over Bluetooth; however, if
    we need to change the settings of the Bluetooth module itself, we can do so by
    connecting the KEY pin to 3V3 and putting it into AT mode.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常操作中，串行消息通过蓝牙发送；然而，如果我们需要更改蓝牙模块本身的设置，我们可以通过将KEY引脚连接到3V3并将其置于AT模式来实现。
- en: AT mode allows us to directly configure the module, allowing us to change the
    baud rate, the pairing code, the device name, or even set it up as a master/slave
    device.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: AT模式允许我们直接配置模块，允许我们更改波特率、配对码、设备名称，甚至将其设置为主/从设备。
- en: 'You can use `miniterm`, which is part of pySerial, to send the required messages,
    as shown in the following code:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用pySerial的一部分`miniterm`发送所需的消息，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `miniterm` program, when started, will prompt for the port to use:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当启动`miniterm`程序时，将提示使用端口：
- en: '[PRE37]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can send the following commands (you will need to do this quickly, or paste
    them, as the module will time out if there is a gap and respond with an error):'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以发送以下命令（您需要快速完成此操作，或者粘贴它们，因为如果存在间隔，模块将超时并响应错误）：
- en: '`AT`: This command should respond with **OK**.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AT`：此命令应响应**OK**。'
- en: '`AT+UART?`: This command will report the current settings as `UART=<Param1>,<Param2>,<Param3>`.
    The output of this command will be **OK**.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AT+UART?`：此命令将报告当前设置，格式为`UART=<Param1>,<Param2>,<Param3>`。此命令的输出将是**OK**。'
- en: To change the current settings, use `AT+UART=<Param1>,<Param2>,<Param3>`, that
    is, `AT+UART=19200,0,0`.![Configuring Bluetooth module settings](img/6623OT_10_40.jpg)
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要更改当前设置，使用`AT+UART=<Param1>,<Param2>,<Param3>`，即`AT+UART=19200,0,0`。![配置蓝牙模块设置](img/6623OT_10_40.jpg)
- en: HC-05 AT mode AT+UART command parameters
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: HC-05 AT模式AT+UART命令参数
- en: 'For details on how to configure modules as paired master and slave devices
    (for example, between two Raspberry Pi devices), Zak Kemble has written an excellent
    guide. It is available at the following link: [http://blog.zakkemble.co.uk/getting-bluetooth-modules-talking-to-each-other/](http://blog.zakkemble.co.uk/getting-bluetooth-modules-talking-to-each-other/).'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何配置模块作为成对的从主设备（例如，两个树莓派设备之间）的详细信息，Zak Kemble已经编写了一个优秀的指南。它可在以下链接找到：[http://blog.zakkemble.co.uk/getting-bluetooth-modules-talking-to-each-other/](http://blog.zakkemble.co.uk/getting-bluetooth-modules-talking-to-each-other/)。
- en: 'For additional documentation on the HC-05 module, visit the following link:
    [http://www.robotshop.com/media/files/pdf/rb-ite-12-bluetooth_hc05.pdf](http://www.robotshop.com/media/files/pdf/rb-ite-12-bluetooth_hc05.pdf).'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 关于HC-05模块的更多文档，请访问以下链接：[http://www.robotshop.com/media/files/pdf/rb-ite-12-bluetooth_hc05.pdf](http://www.robotshop.com/media/files/pdf/rb-ite-12-bluetooth_hc05.pdf)。
- en: Controlling USB devices
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制USB设备
- en: The **Universal Serial Bus** (**USB**) is used extensively by computers to provide
    additional peripherals and expansion through a common standard connection. We
    will use the **PyUSB** Python library to send custom commands to connected devices
    over USB.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用串行总线**（**USB**）被计算机广泛用于通过通用标准连接提供额外的外围设备和扩展。'
- en: 'The following example controls a USB toy missile launcher, which in turn allows
    it to be controlled by our Python control panel. We see that the same principle
    can be applied to other USB devices, such as a robotic arm, using similar techniques,
    and the controls can be activated using a sensor connected to the Raspberry Pi
    GPIO:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例控制一个USB玩具导弹发射器，反过来它允许通过我们的Python控制面板进行控制。我们看到同样的原理可以应用于其他USB设备，例如机械臂，使用类似的技术，并且可以通过连接到树莓派GPIO的传感器激活控制：
- en: '![Controlling USB devices](img/6623OT_10_41.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![控制USB设备](img/6623OT_10_41.jpg)'
- en: The USB Tenx Technology SAM missile launcher
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: USB Tenx Technology SAM导弹发射器
- en: Getting ready
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will need to install PyUSB for Python 3 using `pip-3.2` as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用`pip-3.2`以下方式为Python 3安装PyUSB：
- en: '[PRE38]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can test whether PyUSB has installed correctly by running the following:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令来测试PyUSB是否已正确安装：
- en: '[PRE39]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This should allow you to view the package information if it was installed correctly.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该允许你在安装正确的情况下查看软件包信息。
- en: How to do it...
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will create the following `missileControl.py` script, which will include
    two classes and a default `main()` function to test it:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建以下`missileControl.py`脚本，它将包括两个类和一个默认的`main()`函数以进行测试：
- en: 'Import the required modules as follows:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下方式导入所需的模块：
- en: '[PRE40]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Define the `SamMissile()` class, which provides the specific commands for the
    USB device, as follows:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`SamMissile()`类，它提供USB设备的特定命令，如下所示：
- en: '[PRE41]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Define the `Missile()` class, which allows us to detect the USB device and
    provide command functions, as follows:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`Missile()`类，它允许我们检测USB设备并提供命令功能，如下所示：
- en: '[PRE42]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, create a `main()` function, which provides a quick test of our `missileControl.py`
    module if the file is run directly, as follows:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个`main()`函数，如果文件直接运行，它将提供一个快速测试我们的`missileControl.py`模块，如下所示：
- en: '[PRE43]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When the script is run using the following command, you should see the missile
    launcher move downwards and then up again:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用以下命令运行脚本时，你应该看到导弹发射器向下移动然后再向上：
- en: '[PRE44]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To provide easy control of the device, create the following GUI:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供对设备的简单控制，创建以下GUI：
- en: '![How to do it...](img/6623OT_10_42.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/6623OT_10_42.jpg)'
- en: The Missile Command GUI
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Missile Command GUI
- en: Although simple commands have been used here, you could use a series of preset
    commands if desired.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里使用了简单的命令，但如果需要，可以使用一系列预设命令。
- en: 'Create the GUI for the `missileMenu.py` missile command:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 为`missileMenu.py`导弹命令创建GUI：
- en: '[PRE45]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The control script consists of two classes: one called `Missile` that provides
    a common interface for the control, and another called `SamMissile` that provides
    all the specific details of the particular USB device being used.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 控制脚本由两个类组成：一个称为`Missile`的类，它为控制提供通用接口，另一个称为`SamMissile`的类，它提供了特定USB设备的所有详细信息。
- en: In order to drive a USB device, we need a lot of information about the device,
    such as its USB identification, its protocol, and the control messages it requires
    to be controlled.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 为了驱动 USB 设备，我们需要大量有关设备的信息，例如其 USB 标识、其协议以及控制消息，这些消息是控制设备所需的。
- en: The USB ID for the Tenx Technology SAM missile device is determined by the vendor
    ID (`0x1130`) and the product ID (`0x0202`). This is the same identification information
    you would see within **Device Manager** in Windows. These IDs are usually registered
    with [www.usb.org](http://www.usb.org); therefore, each device should be unique.
    Again, you can use the `dmesg | grep usb` command to discover these.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: Tenx Technology SAM 导弹设备的 USB ID 由供应商 ID (`0x1130`) 和产品 ID (`0x0202`) 确定。这是你可以在
    Windows 的 **设备管理器** 中看到的相同标识信息。这些 ID 通常在 [www.usb.org](http://www.usb.org) 注册；因此，每个设备应该是唯一的。再次提醒，你可以使用
    `dmesg | grep usb` 命令来发现这些。
- en: We use the device IDs to find the USB device using `usb.core.find`; then, we
    can send messages using `ctrl_transfer()`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用设备 ID 通过 `usb.core.find` 查找 USB 设备；然后，我们可以使用 `ctrl_transfer()` 发送消息。
- en: 'The USB message has five parts:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: USB 消息有五个部分：
- en: '**Request type** (`0x21`): This defines the type of the message request, such
    as the message direction (Host to Device), its type (Vendor), and the recipient
    (Interface)'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求类型** (`0x21`): 这定义了消息请求的类型，例如消息方向（主机到设备）、其类型（供应商）和接收者（接口）'
- en: '**Request** (`0x09`): This is the set configuration'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求** (`0x09`): 这是设置配置'
- en: '**Value** (`0x02`): This is the configuration value'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值** (`0x02`): 这是配置值'
- en: '**Index** (`0x01`): This is the command we want to send'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**索引** (`0x01`): 这是我们要发送的命令'
- en: '**Data**: This is the command we want to send (as described next)'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据**：这是我们想要发送的命令（如以下所述）'
- en: 'The `SamMissile` device requires the following commands to move:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`SamMissile` 设备需要以下命令来移动：'
- en: It requires two initialization messages (`INITA` and `INITB`).
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要两个初始化消息（`INITA` 和 `INITB`）。
- en: It also requires the control message. This consists of the `CMD`, which includes
    one of the control bytes that has been set to `1` for the required component.
    The `CMD` is then added to `CMDFILL` to complete the message.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它也需要控制消息。这包括 `CMD`，它包含一个设置为 `1` 的控制字节，用于所需的组件。然后，`CMD` 被添加到 `CMDFILL` 以完成消息。
- en: You will see that the other missile devices and the robot arm (see the following
    *There's more…* section) have similar message structures.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现其他导弹装置和机械臂（见下文 *更多内容…* 部分）具有类似的消息结构。
- en: For each device, we created the `__init__()` and `move()` functions and defined
    values for each of the valid commands, which the `missile` class will use whenever
    the `left()`, `right()`, `up()`, `down()`, `fire()`, and `stop()` functions are
    called.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个装置，我们创建了 `__init__()` 和 `move()` 函数，并为每个有效命令定义了值，当调用 `left()`、`right()`、`up()`、`down()`、`fire()`
    和 `stop()` 函数时，`missile` 类将使用这些值。
- en: For the control GUI for our missile launcher, we create a small Tkinter window
    with five buttons, each of which will send a command to the missile device.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的导弹发射器的控制 GUI，我们创建了一个带有五个按钮的小 Tkinter 窗口，每个按钮都会向导弹设备发送一个命令。
- en: We import `missileControl` and create a `missile` object called `myMissile`
    that will be controlled by each of the buttons.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入 `missileControl` 并创建一个名为 `myMissile` 的 `missile` 对象，该对象将由每个按钮控制。
- en: There's more...
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The example only shows how to control one particular USB device; however, it
    is possible to extend this to support several types of missile devices and even
    other USB devices in general.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 示例仅展示了如何控制一个特定的 USB 设备；然而，可以将此扩展以支持多种类型的导弹装置，甚至是一般意义上的其他 USB 设备。
- en: Controlling similar missile-type devices
  id: totrans-401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控制类似导弹类型的装置
- en: There are several variants of USB missile-type devices, each with their own
    USB IDs and USB commands. We can add support for these other devices by defining
    their own classes to handle them.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种 USB 导弹类型装置的变体，每种都有自己的 USB ID 和 USB 命令。我们可以通过定义它们自己的类来处理这些其他设备，以支持这些设备。
- en: Use `lsusb -vv` to determine the vendor and product ID that matches your device.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `lsusb -vv` 确定与你的设备匹配的供应商和产品 ID。
- en: 'For `Chesen Electronics/Dream Link`, we have to add the following code:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Chesen Electronics/Dream Link`，我们必须添加以下代码：
- en: '[PRE46]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'For `Dream Cheeky Thunder`, we need the following code:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Dream Cheeky Thunder`，我们需要以下代码：
- en: '[PRE47]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, adjust the script to use the required class as follows:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调整脚本以使用所需的类如下：
- en: '[PRE48]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Robot arm
  id: totrans-410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 机械臂
- en: Another device that can be controlled in a similar manner is the OWI Robotic
    Arm with a USB interface.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以用类似方式控制的设备是具有 USB 接口的 OWI 机器人臂。
- en: '![Robot arm](img/6623OT_10_43.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![机器人臂](img/6623OT_10_43.jpg)'
- en: The OWI Robotic Arm with a USB interface (image courtesy of Chris Stagg)
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: OWI USB接口机器人臂（图片由Chris Stagg提供）
- en: This has featured in *The MagPi* magazine several times, thanks to Stephen Richards'
    articles on Skutter; the USB control has been explained in detail in issue 3 (page
    14) at [https://issuu.com/themagpi/docs/the_magpi_issue_3_final/14](https://issuu.com/themagpi/docs/the_magpi_issue_3_final/14).
    It can also be found at [https://www.raspberrypi.org/magpi/issues/3/](https://www.raspberrypi.org/magpi/issues/3/).
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这在*The MagPi*杂志中多次出现，多亏了Stephen Richards关于Skutter的文章；USB控制已在第3期（第14页）中详细解释，可在[https://issuu.com/themagpi/docs/the_magpi_issue_3_final/14](https://issuu.com/themagpi/docs/the_magpi_issue_3_final/14)找到。它也可以在[https://www.raspberrypi.org/magpi/issues/3/](https://www.raspberrypi.org/magpi/issues/3/)找到。
- en: 'The robotic arm can be controlled using the following class. Remember that
    you will also need to adjust the commands from `UP`, `DOWN`, and so on when calling
    the `move()` function, as shown in the following code:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人臂可以通过以下类进行控制。记住，在调用`move()`函数时，你还需要调整`UP`、`DOWN`等命令，如下面的代码所示：
- en: '[PRE49]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Taking USB control further
  id: totrans-417
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 深入USB控制
- en: The theory and method of control used for the USB missile device can be applied
    to very complex devices such as the Xbox 360's Kinect (a special 3D camera add-on
    for the Xbox game console) as well.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 用于USB导弹设备的理论和控制方法也可以应用于非常复杂的设备，如Xbox 360的Kinect（Xbox游戏控制台的特殊3D摄像头附加设备）。
- en: Adafruit's website has a very interesting tutorial written by Limor Fried (also
    known as Ladyada) on how to analyze and investigate USB commands; access it at
    [http://learn.adafruit.com/hacking-the-kinect](http://learn.adafruit.com/hacking-the-kinect).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: Adafruit的网站上有一篇由Limor Fried（也称为Ladyada）撰写的非常有趣的教程，介绍了如何分析和调查USB命令；可在[http://learn.adafruit.com/hacking-the-kinect](http://learn.adafruit.com/hacking-the-kinect)访问。
- en: This is well worth a look if you intend to reverse engineer other USB items.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算逆向工程其他USB设备，这非常值得一看。
