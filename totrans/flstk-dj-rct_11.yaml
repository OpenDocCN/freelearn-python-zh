- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Effective UI Testing for React Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already been introduced to testing with Python and Django in [*Chapter
    5*](B18221_05.xhtml#_idTextAnchor091)*, Testing the REST API*. In this chapter,
    the context is different as we will work with JavaScript and React to test the
    frontend components we have designed and implemented. This chapter will show you
    what to test in a frontend application and how to write tests for React UI components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Component testing in React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jest and the **React Testing** **Library** (**RTL**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing form components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing `post` components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Snapshot testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure to have VS Code and an updated browser installed and configured on
    your machine. You can find the code from this chapter at [https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap11](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap11).
  prefs: []
  type: TYPE_NORMAL
- en: Component testing in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already understand that the frontend is the client-side section of an application.
    Concerning the tests we wrote in [*Chapter 5*](B18221_05.xhtml#_idTextAnchor091)*,
    Testing the REST API*, in our Django applications, we mostly tested whether the
    database stored the right data passed to the viewsets, serializers, and models.
    However, we didn’t test the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a React developer, you might be thinking: what do I test in my frontend
    application? Well, let’s respond to this question by understanding why a frontend
    test is needed and what needs to be tested.'
  prefs: []
  type: TYPE_NORMAL
- en: The necessity of testing your frontend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When developing an application, it’s important to ensure that your application
    works as expected in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: The frontend also represents the interface the user will use to interact with
    your backend. For a good user experience, it’s crucial to write tests that ensure
    that your components are behaving as expected.
  prefs: []
  type: TYPE_NORMAL
- en: What to test in your React application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are coming from a backend viewpoint, you might be a little bit confused
    about what to test in your frontend application. From a basic aspect, it’s not
    different from testing your backend. If you have classes or methods in your application,
    you can write tests. Frontend testing includes testing different aspects of the
    UI such as formatting, visible text, graphics, and the functional parts of the
    applications such as buttons, forms, or clickable links.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the difference is that your React frontend is made of UI components, taking
    props for displaying data to the user. The React ecosystem provides testing tools
    that easily help you write tests for your components.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will start with a small introduction to Jest and the
    RTL and then we will write tests for our authentication forms.
  prefs: []
  type: TYPE_NORMAL
- en: Jest, the RTL, and fixtures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Jest** is a JavaScript framework for writing, running, and structuring tests.
    It comes with all the tools needed to check code coverage, easily mock functions,
    and imported functions, and write simple and great exceptions. The RTL is a library
    for actually testing React applications. It focuses on testing components from
    a user experience point of view rather than testing the implementation and logic
    of the React components themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When writing tests, you will often need to ensure that some values or variables
    meet certain conditions. This was done in [*Chapter 5*](B18221_05.xhtml#_idTextAnchor091)*,
    Testing the REST API*, of this book, using `assert` when writing tests for the
    Django application using pytest. Working with Jest, the term changes from assertion
    to exceptions. When doing frontend testing with Jest, we are expecting the value
    to meet a condition. For example, if the user enters and clicks on a button that
    will reset a form, we expect the form to be reset after the click action is made
    on the button.
  prefs: []
  type: TYPE_NORMAL
- en: The RTL is not separated from Jest as you need both to write tests for your
    frontend application. Jest will help you write the testing blocks while the RTL
    will provide tools to select components, render the components, and trigger common
    user events such as clicking and typing. These tools are already installed by
    default when creating a React project, so there is no need to add other packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only packages we will need are `faker.js` and the JavaScript `uuid` package
    to generate UUID4 identifiers. Faker is a JavaScript package used to generate
    fake, but realistic, data. In the React project, use the following command to
    install the package as a development dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With the packages installed, we can now add some important fixtures for the
    components we are going to test in the next lines.
  prefs: []
  type: TYPE_NORMAL
- en: Writing testing fixtures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `src/helpers` directory, create a new directory called `fixtures`. This
    directory will contain JavaScript files containing functions that return fixtures
    that can be used for testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by writing fixtures for a user. So, in the `fixtures` directory,
    create a new file called `user.js`. This file will contain code for a function
    that returns realistic data for a user object. Let’s start with the imports of
    functions from the `faker.js` and `uuid` packages to create a fixture:'
  prefs: []
  type: TYPE_NORMAL
- en: src/helpers/fixtures/user.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With the imports and the structure of the `userFixtures` function written,
    we can now return the object fixture:'
  prefs: []
  type: TYPE_NORMAL
- en: src/helpers/fixtures/user.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Faker provides a lot of modules with methods to return data. In the previous
    code block, we are working with `faker.name` to generate random names, `faker.lorem`
    to generate random lorem texts, and `faker.date` to generate a recent date. The
    object returned by `userFixtures` now has the closest structure to a user object
    returned by the Django API we have created, and this is exactly what we want.
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into component testing, let’s make sure our testing environment
    is well configured.
  prefs: []
  type: TYPE_NORMAL
- en: Running the first test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a React application is created, the `App.js` file comes with a test file
    called `App.test.js`, which you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: src/App.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let me explain the code. Here, we are importing the `render` and `screen` methods
    from the RTL. These modules will be used to render a component and make interactions
    with the components easier by providing methods to select DOM elements, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the `test` method. It’s simply a Jest keyword used to write tests.
    It takes two parameters: a string describing the test, and the callback function
    where you write the testing logic. Inside the callback function, the `App` component
    is rendered first. Then, `linkElement` is retrieved from the screen by using the
    `learn react` text. Once it’s retrieved, we can then check whether the `linkElement`
    exists in the rendered document.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run this test with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You should have a similar output in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Running the yarn test command](img/Figure_11.01_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Running the yarn test command
  prefs: []
  type: TYPE_NORMAL
- en: The test has failed. But why? You can somewhat see why in the preceding output.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Reason for failing the App.js test](img/Figure_11.02_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Reason for failing the App.js test
  prefs: []
  type: TYPE_NORMAL
- en: 'The `App` component in our project uses `react-router-dom` components, such
    as `Routes`, that in turn use the `useRoutes` Hook. This Hook makes use of the
    context that a router component provides, so we need to wrap it inside a Router,
    in this case, the `BrowserRouter` component. Let’s correct this, but let’s also
    change the text from which we will retrieve the link element:'
  prefs: []
  type: TYPE_NORMAL
- en: src/App.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the tests again and everything should work correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Passing tests](img/Figure_11.03_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Passing tests
  prefs: []
  type: TYPE_NORMAL
- en: But we still have a problem. A lot of components in the React application use
    Hooks from the `react-router-dom` library. That means that for each test, we will
    need to wrap the component inside `BrowserRouter`. Following the DRY principle,
    let’s rewrite the render method from the RTL to automatically wrap our components
    inside the `BrowserRouter`.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the RTL render method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside the `src/helpers` directory, create a file called `test-utils.jsx`.
    Once the file is created, add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: src/helpers/test-utils.jsx
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the code, we first import the needed tools. Notice the import of the render
    method as `rtlRender`? It’s for the purpose of avoiding a naming collision as
    we are also writing a render function. Next, we create a function called `Wrapper`,
    where we pass the children’s argument, then wrap it inside a `BrowserRouter` component.
    Then, we return a render object with the UI, `wrapper`, and other render options
    if specified.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The render method from the RTL provides render options other than the wrapper.
    You can also pass a container, queries, and a lot more. You can check more rendering
    options in the official documentation at [https://testing-library.com/docs/react-testing-library/api/#render-options](https://testing-library.com/docs/react-testing-library/api/#render-options).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s use this method in `App.test.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: src/App.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Run the testing command again and everything should be green. With the testing
    environment ready and set up to quickly write tests, we can now move on to testing
    the components of the React project.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'While running tests, you might encounter an error coming from the `axios` package.
    At the time of writing of this book, we are using the 0.26.0 version of `axios`
    to avoid bugs when running tests. You can also modify the test command in the
    `package.json` file to the following: `"test": "react-scripts test --transformIgnorePatterns
    "node_modules/(?!axios)/""`. Learn more about this issue at [https://github.com/axios/axios/issues/5101](https://github.com/axios/axios/issues/5101).'
  prefs: []
  type: TYPE_NORMAL
- en: Testing authentication components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing forms in React might seem complicated but it is quite simple when using
    Jest and the RTL. We will begin writing tests in the React project, starting with
    the authentication components. I’ll show you how you can write a test for the
    **Login** form, and after that, you should be able to write the registration form
    test suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a better structured code base, create a new directory called `__tests__`
    in the `src/components/authentication` directory. This directory will contain
    tests for the components in the `components/authentication` directory. Inside
    the newly created directory, create a file called `LoginForm.test.js` and add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: src/components/authentication/__tests__/LoginForm.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have added the required imports to write the test
    and defined the structure of the testing function. We will first render the `LoginForm`
    component and set up the user object to trigger user behavior events using `userEvent`
    `method:src/components/authentication/__tests__/LoginForm.test.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '`userEvent` and `fireEvent` are both methods used for simulating user interactions
    with a website in the context of testing. They can be used to test the behavior
    of a website when a user performs certain actions, such as clicking a button or
    filling out a form.'
  prefs: []
  type: TYPE_NORMAL
- en: '`userEvent` is a method provided by the `@testing-library/user-event` library,
    which is designed to make it easier to test user interactions with a website.
    It is a utility function that simulates user events by using the `fireEvent` method
    provided by the `@testing-library/react` library. `userEvent` allows you to specify
    the type of event you want to simulate, such as a click or a keypress, and it
    will automatically dispatch the appropriate event for you.'
  prefs: []
  type: TYPE_NORMAL
- en: '`fireEvent` is a method provided by the `@testing-library/react` library, which
    can be used to dispatch events to a DOM element. It allows you to specify the
    type of event you want to dispatch, as well as any additional event data that
    you want to include. `fireEvent` is a more low-level method than `userEvent`,
    and it requires you to manually specify the details of the event you want to dispatch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we can start by testing that the form and the inputs are rendered
    in the document:'
  prefs: []
  type: TYPE_NORMAL
- en: src/components/authentication/__tests__/LoginForm.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can ensure that the inputs can receive texts and values as we have
    already selected the username and password fields:'
  prefs: []
  type: TYPE_NORMAL
- en: src/components/authentication/__tests__/LoginForm.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you run the test command again, it will fail. That’s normal, as here we are
    retrieving elements using the `getByTestId` method. The RTL looks in the rendered
    DOM for an element with a `data-testid` attribute with the value passed to the
    `screen.getByTestId` function. We need to add the attribute to the elements we
    want to select and test.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, in `src/components/authentication/LoginForm.js`, add the following
    `data-testid` attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: src/components/authentication/LoginForm.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Once done, re-run the testing command. Everything should work.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to write tests for the registration form component. It’ll be
    similar to the tests on the login form component, so you can handle this small
    exercise. You can find the solution at [https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/main/social-media-react/src/components/authentication/__tests__/RegistrationForm.test.js](https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/main/social-media-react/src/components/authentication/__tests__/RegistrationForm.test.js).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript also possesses default naming conventions for the testing files.
    The naming conventions for test files in a JavaScript project are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '- `<``TestFileName>.test.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '- `<``TestFileName>.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have had a solid introduction to testing in React, let’s continue
    with writing tests for the Post components.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Post components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The functionalities to create, read, update, and delete posts are core features
    of the Postagram application, so it’s important to make sure that they work as
    expected. Let’s start with a simple test for the `Post` component.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking the localStorage object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before writing a test for the `Post` component, it’s important to understand
    how the Post components work. Basically, it takes a prop called `post` and makes
    a call to `localStorage` to retrieve information about the user. Unfortunately,
    `localStorage` can’t be mocked by Jest. There are a lot of workarounds to allow
    your tests to work with `localStorage` and to make it simple and have less boilerplate,
    we’ll use the `jest-localstorage-mock` JavaScript package. The package can be
    used with Jest to run frontend tests that rely on `localStorage`. To add the package,
    add the following line to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the package is installed, we need to do some configurations. In the `src/setupTests.js`
    file, add this line to load the `jest-localstorage-mock` package:'
  prefs: []
  type: TYPE_NORMAL
- en: src/setupTests.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, override the default Jest configuration in the `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: package.json
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With the configuration ready, we can move to add a function to generate post
    fixtures.
  prefs: []
  type: TYPE_NORMAL
- en: Writing post fixtures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `src/helpers/fixtures` directory, create a new file called `post.js`.
    This file will contain a function that returns fake data from a post object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start writing the code in this file by adding the imports and defining
    the `postFixtures` function that will return a generated post object:'
  prefs: []
  type: TYPE_NORMAL
- en: src/helpers/fixtures/post.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s add the body of the `postFixtures` function:'
  prefs: []
  type: TYPE_NORMAL
- en: src/helpers/fixtures/post.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are passing either a generated `userFixtures` or a user object if it’s
    defined. This is important if we want to make sure that the author of the post
    is the same user registered in `localStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: With the post fixtures written, we can write the test suite for the `Post` component.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests for the Post component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To write the test suite in the `src/components/posts` directory, create a new
    folder called `__tests__`. Inside the newly created folder, add a new file called
    `Post.test.js`. Inside, add the imports, create the data we need, and set user
    data returned by the `userFixtures` function in the local storage using the `setUserData`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: src/components/posts/__tests__/Post.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `beforeEach` method is a Jest method that runs before every test. It takes
    a callback function as a parameter, where you can execute lines of code that should
    run before the tests. Here, we are clearing the local storage first to avoid memory
    leaking (with `localStorage.clear`) and finally, we set user data retrieved from
    the `userFixtures` function in the local storage.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: A memory leak occurs when a program creates a memory in heap and forgets to
    delete it. In a worst-case scenario, if too much memory is allocated and not used
    correctly, this can reduce the computer’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write the test for the `Post` component now:'
  prefs: []
  type: TYPE_NORMAL
- en: src/components/posts/__tests__/Post.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the test command, it’ll fail. This is normal because there is no
    `data-testid` attribute with the value `post-test` set in the JSX of the `Post`
    component. Let’s fix this by adding a `data-testid` attribute in the `Post` component
    :'
  prefs: []
  type: TYPE_NORMAL
- en: src/components/posts/Post.jsx
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Run the testing command again and everything should be green. Let’s move on
    to actually writing a test for the `CreatePost` component.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the CreatePost component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `src/components/posts/__tests__` directory, create a new file called
    `CreatePost.test.js`. We’ll start with the necessary imports and the definition
    of the `test` function:'
  prefs: []
  type: TYPE_NORMAL
- en: src/components/posts/__tests__/CreatePost.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can notice the introduction of the `async` keyword before the callback function.
    To create a post, the user performs typing operations on text inputs and finally
    a button click to submit the post. These actions are asynchronous. The functions,
    such as `fireEvent`, that we will use to simulate user interactions should be
    used in an asynchronous scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before writing the test logic, let’s remember how the `CreatePost` component
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: The user clicks on the input to add a new post.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A modal is shown containing a form where the user can enter the text of the
    post. Meanwhile, the submit button is disabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once there is enough text in the field, the submit button is enabled and the
    user can click to send the post.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We must ensure that we respect this logic when writing the tests. Now, let’s
    start writing the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we render the form that displays the form modal to create a post:'
  prefs: []
  type: TYPE_NORMAL
- en: src/components/posts/__tests__/CreatePost.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now simulate a click event using `fireEvent.click` on `showModalForm`
    to display the form for creating a post:'
  prefs: []
  type: TYPE_NORMAL
- en: src/components/posts/__tests__/CreatePost.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We then make sure that the body field is rendered and the submit button is
    disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: src/components/posts/__tests__/CreatePost.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can then type some text in the body field, test whether the
    text typed is what we expect, and ensure that the button is enabled after that:'
  prefs: []
  type: TYPE_NORMAL
- en: src/components/posts/__tests__/CreatePost.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! We have a solid testing suite and we can now add the `data-testid` attributes
    to the `CreatePost` component to make the tests pass:'
  prefs: []
  type: TYPE_NORMAL
- en: src/components/posts/CreatePost.jsx
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Run the test command again and everything should work. The next step is to write
    unit tests for the `UpdatePost` component.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the UpdatePost component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `src/components/posts/__tests__` directory, create a new file called
    `UpdatePost.test.js`. Let’s start with the necessary imports and the definition
    of the `test` function:'
  prefs: []
  type: TYPE_NORMAL
- en: src/components/posts/__tests__/UpdatePost.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Before writing the test logic, let’s remember how the `UpdatePost` component
    works from a user’s perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: The user clicks on the drop-down item to modify a post.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A modal is shown containing a form where the user can modify the text of the
    post.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the modification, the user can submit the form with the updated post.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We must ensure that we respect that logic when writing the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, first, we render the form that displays the form modal to update a post:'
  prefs: []
  type: TYPE_NORMAL
- en: src/components/posts/__tests__/UpdatePost.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We then want to trigger a click event to display the modal with the form to
    update the post:'
  prefs: []
  type: TYPE_NORMAL
- en: src/components/posts/__tests__/UpdatePost.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We then select the post body field and the submit button to ensure that they
    are rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: src/components/posts/__tests__/UpdatePost.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can now trigger a typing event in the post body field and ensure
    that the user is submitting the right data:'
  prefs: []
  type: TYPE_NORMAL
- en: src/components/posts/__tests__/UpdatePost.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is now to add the `data-testid` attributes on the post form,
    the post body input, and the submit button in the `UpdatePost` component to make
    the tests pass:'
  prefs: []
  type: TYPE_NORMAL
- en: src/components/posts/UpdatePost.jsx
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Run the test command again and everything should work.
  prefs: []
  type: TYPE_NORMAL
- en: With this introduction to complex tests with Jest and the RTL, you can easily
    write the tests for the comment’s components. You can find the solution for these
    tests at [https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/main/social-media-react/src/components/comments/__tests__](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/main/social-media-react/src/components/comments/__tests__).
    Good luck!
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discover what snapshot testing is.
  prefs: []
  type: TYPE_NORMAL
- en: Snapshot testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Snapshot tests are a very useful tool when you want to make sure that your
    UI does not change unexpectedly. A snapshot test case follows these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It renders the UI component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then takes a snapshot and compares it to a reference snapshot file stored
    alongside the test file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If both states are the same, the snapshot test is successful. Otherwise, you
    will get errors and need to decide whether you need to update the snapshot tests
    or fix your components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Snapshot tests are great to prevent UI regression and ensure that the application
    adheres to the code quality and values of your development team.
  prefs: []
  type: TYPE_NORMAL
- en: There is a minor setback with snapshot tests, however. Snapshot testing doesn’t
    work best with dynamic components. For example, the `Post` component uses `timeago`
    to display a human-readable time. This means that a snapshot of this component
    at time `t` will be different from a snapshot of the same component at time `t
    + 1`. However, there are some static components in the React application such
    as `LoginForm`, `RegistrationForm`, `ProfileDetails`, `ProfileCard`, `CreatePost`,
    and much more.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity, we will write a snapshot test for the `ProfileCard`
    components, which are straightforward and can be replicated easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `src/components/profile` directory, create a new directory called `__tests__`.
    Then, create a new file called `ProfileCard.test.js`. For a snapshot test, we
    don’t want the data to change so we will use a static user fixture because using
    `userFixtures` to generate a fixture will create random data every time a snapshot
    test is run. In the newly created file, let’s add the imports needed to create
    a snapshot test and define a fixture object called `userData`:'
  prefs: []
  type: TYPE_NORMAL
- en: src/components/profile/__tests__/ProfileCard.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'With the needed imports added and the `userData` fixtures written, we can now
    write the testing function:'
  prefs: []
  type: TYPE_NORMAL
- en: src/components/profile/__tests__/ProfileCard.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the test command, you’ll notice that a snapshot directory is created
    in the `__tests__` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Snapshots directory created](img/Figure_11.04_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Snapshots directory created
  prefs: []
  type: TYPE_NORMAL
- en: If you check the content of `ProfileCard.test.js.snap`, it is basically the
    rendered code of the `ProfileCard` component. The content of this file will be
    compared each time the test function for the snapshot test runs.
  prefs: []
  type: TYPE_NORMAL
- en: Now have covered the essential unit tests for a React application, we are mostly
    done adding features to the application. Our full stack application is now ready
    for production! Yay, but don’t celebrate too soon. We still need to prepare our
    application for production in terms of the security, quality, and performance
    aspects and this is what we’ll be doing in *Part 3* of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned about frontend unit testing. We discovered
    why it is important to write unit tests in the frontend application and what to
    test exactly. We have also written tests for components in the Postagram application,
    seen how we can extend testing tools modules and methods, how to write generate
    fixtures for the tests, and how to make the tests closer to user interactions
    by triggering user events. We have also made some introductions to snapshot testing.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapters in *Part 3* of this book will focus on deploying the backend
    and the frontend on the cloud using AWS services, GitHub, and GitHub Actions.
    Lastly, we will see how to improve the full stack application in terms of performance,
    security, and quality.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the render method of the RTL?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Jest?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the role of the `data-tested` attribute?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the drawbacks of snapshot testing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the modules used to trigger user events on a React test suite?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Part 3: Deploying Django and React on AWS'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deployment is one of the last important steps in software development. Your
    application is running locally and everything is working fine. But how do you
    get your code on a public server? How do you host your frontend? How do you make
    changes to your code and make deployment and testing automatic? In this part of
    the book, we’ll explore topics such as CI/CD, GitHub, Docker, and the best deployment
    practices while deploying the Django application on AWS EC2 and the React application
    on AWS S3\. We’ll also talk about security and performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B18221_12.xhtml#_idTextAnchor239), *Deployment Basics – Git,
    GitHub, and AWS*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B18221_13.xhtml#_idTextAnchor252), *Dockerizing the Django Project*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B18221_14.xhtml#_idTextAnchor286), *Automating Deployment on
    AWS*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B18221_15.xhtml#_idTextAnchor330), *Deploying Our React App
    on AWS*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 16*](B18221_16.xhtml#_idTextAnchor352), *Performance, Optimization,
    and Security*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
