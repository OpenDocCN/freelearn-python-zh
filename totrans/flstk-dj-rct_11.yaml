- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Effective UI Testing for React Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React组件的有效UI测试
- en: We have already been introduced to testing with Python and Django in [*Chapter
    5*](B18221_05.xhtml#_idTextAnchor091)*, Testing the REST API*. In this chapter,
    the context is different as we will work with JavaScript and React to test the
    frontend components we have designed and implemented. This chapter will show you
    what to test in a frontend application and how to write tests for React UI components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第5章*](B18221_05.xhtml#_idTextAnchor091)*，测试REST API*中介绍了使用Python和Django进行测试。在本章中，情境不同，我们将使用JavaScript和React来测试我们设计和实现的前端组件。本章将展示在前端应用程序中应该测试什么以及如何为React
    UI组件编写测试。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Component testing in React
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React中的组件测试
- en: Jest and the **React Testing** **Library** (**RTL**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jest和**React测试库**（**RTL**）
- en: Testing form components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试表单组件
- en: Testing `post` components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试`post`组件
- en: Snapshot testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快照测试
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Make sure to have VS Code and an updated browser installed and configured on
    your machine. You can find the code from this chapter at [https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap11](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap11).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的机器上已安装并配置了VS Code和更新的浏览器。你可以从本章找到代码：[https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap11](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap11)。
- en: Component testing in React
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React中的组件测试
- en: We already understand that the frontend is the client-side section of an application.
    Concerning the tests we wrote in [*Chapter 5*](B18221_05.xhtml#_idTextAnchor091)*,
    Testing the REST API*, in our Django applications, we mostly tested whether the
    database stored the right data passed to the viewsets, serializers, and models.
    However, we didn’t test the user interface.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到前端是应用程序的客户端部分。关于我们在[*第5章*](B18221_05.xhtml#_idTextAnchor091)*，测试REST
    API*中编写的测试，在我们的Django应用程序中，我们主要测试了数据库是否存储了传递给视图集、序列化和模型的数据。然而，我们没有测试用户界面。
- en: 'As a React developer, you might be thinking: what do I test in my frontend
    application? Well, let’s respond to this question by understanding why a frontend
    test is needed and what needs to be tested.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名React开发者，你可能正在思考：在我的前端应用程序中我应该测试什么？好吧，让我们通过了解为什么需要前端测试以及需要测试什么来回答这个问题。
- en: The necessity of testing your frontend
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试前端的重要性
- en: When developing an application, it’s important to ensure that your application
    works as expected in a production environment.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，确保你的应用程序在生产环境中按预期工作是很重要的。
- en: The frontend also represents the interface the user will use to interact with
    your backend. For a good user experience, it’s crucial to write tests that ensure
    that your components are behaving as expected.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 前端也代表了用户将用来与你的后端交互的界面。为了良好的用户体验，编写确保你的组件按预期行为的测试是至关重要的。
- en: What to test in your React application
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在你的React应用程序中应该测试什么
- en: If you are coming from a backend viewpoint, you might be a little bit confused
    about what to test in your frontend application. From a basic aspect, it’s not
    different from testing your backend. If you have classes or methods in your application,
    you can write tests. Frontend testing includes testing different aspects of the
    UI such as formatting, visible text, graphics, and the functional parts of the
    applications such as buttons, forms, or clickable links.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自后端视角，你可能在你的前端应用程序中测试什么方面可能会有些困惑。从基本的角度来看，它与测试后端并没有不同。如果你的应用程序中有类或方法，你可以编写测试。前端测试包括测试UI的不同方面，如格式、可见文本、图形以及应用程序的功能部分，如按钮、表单或可点击链接。
- en: Now, the difference is that your React frontend is made of UI components, taking
    props for displaying data to the user. The React ecosystem provides testing tools
    that easily help you write tests for your components.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，区别在于你的React前端是由UI组件构成的，这些组件接收属性以向用户显示数据。React生态系统提供了测试工具，这些工具可以轻松帮助你为你的组件编写测试。
- en: In the next section, we will start with a small introduction to Jest and the
    RTL and then we will write tests for our authentication forms.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将从对Jest和RTL的简要介绍开始，然后我们将为我们的认证表单编写测试。
- en: Jest, the RTL, and fixtures
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jest、RTL和固定数据
- en: '**Jest** is a JavaScript framework for writing, running, and structuring tests.
    It comes with all the tools needed to check code coverage, easily mock functions,
    and imported functions, and write simple and great exceptions. The RTL is a library
    for actually testing React applications. It focuses on testing components from
    a user experience point of view rather than testing the implementation and logic
    of the React components themselves.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jest** 是一个用于编写、运行和结构化测试的 JavaScript 框架。它包含所有检查代码覆盖率、轻松模拟函数和导入函数以及编写简单且出色的异常所需的工具。RTL
    是一个用于实际测试 React 应用的库。它专注于从用户体验的角度测试组件，而不是测试 React 组件本身的实现和逻辑。'
- en: Important note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When writing tests, you will often need to ensure that some values or variables
    meet certain conditions. This was done in [*Chapter 5*](B18221_05.xhtml#_idTextAnchor091)*,
    Testing the REST API*, of this book, using `assert` when writing tests for the
    Django application using pytest. Working with Jest, the term changes from assertion
    to exceptions. When doing frontend testing with Jest, we are expecting the value
    to meet a condition. For example, if the user enters and clicks on a button that
    will reset a form, we expect the form to be reset after the click action is made
    on the button.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试时，您通常会需要确保某些值或变量满足某些条件。这在本书的 [*第 5 章*](B18221_05.xhtml#_idTextAnchor091)*，测试
    REST API* 中已经完成，使用 `assert` 在使用 pytest 编写 Django 应用程序的测试时。与 Jest 一起工作时，术语从断言变为异常。在使用
    Jest 进行前端测试时，我们期望值满足条件。例如，如果用户输入并点击一个将重置表单的按钮，我们期望在按钮上的点击动作之后表单被重置。
- en: The RTL is not separated from Jest as you need both to write tests for your
    frontend application. Jest will help you write the testing blocks while the RTL
    will provide tools to select components, render the components, and trigger common
    user events such as clicking and typing. These tools are already installed by
    default when creating a React project, so there is no need to add other packages.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: RTL（右对齐文本）与 Jest 并未分离，因为您需要两者来为您的前端应用程序编写测试。Jest 将帮助您编写测试块，而 RTL 将提供选择组件、渲染组件和触发常见用户事件（如点击和输入）的工具。这些工具在创建
    React 项目时已默认安装，因此无需添加其他包。
- en: 'The only packages we will need are `faker.js` and the JavaScript `uuid` package
    to generate UUID4 identifiers. Faker is a JavaScript package used to generate
    fake, but realistic, data. In the React project, use the following command to
    install the package as a development dependency:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的唯一包是 `faker.js` 和 JavaScript 的 `uuid` 包来生成 UUID4 标识符。Faker 是一个用于生成虚假但逼真数据的
    JavaScript 包。在 React 项目中，使用以下命令将包作为开发依赖项安装：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With the packages installed, we can now add some important fixtures for the
    components we are going to test in the next lines.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了这些包之后，我们现在可以为下一行中将要测试的组件添加一些重要的固定值。
- en: Writing testing fixtures
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写测试固定值
- en: In the `src/helpers` directory, create a new directory called `fixtures`. This
    directory will contain JavaScript files containing functions that return fixtures
    that can be used for testing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/helpers` 目录下，创建一个名为 `fixtures` 的新目录。此目录将包含包含函数的 JavaScript 文件，这些函数返回可用于测试的固定值。
- en: 'We’ll start by writing fixtures for a user. So, in the `fixtures` directory,
    create a new file called `user.js`. This file will contain code for a function
    that returns realistic data for a user object. Let’s start with the imports of
    functions from the `faker.js` and `uuid` packages to create a fixture:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写用户的固定值。因此，在 `fixtures` 目录下，创建一个名为 `user.js` 的新文件。此文件将包含返回用户对象真实数据的函数的代码。让我们从从
    `faker.js` 和 `uuid` 包中导入函数以创建固定值开始：
- en: src/helpers/fixtures/user.js
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: src/helpers/fixtures/user.js
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With the imports and the structure of the `userFixtures` function written,
    we can now return the object fixture:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写了导入和 `userFixtures` 函数的结构之后，我们现在可以返回对象固定值：
- en: src/helpers/fixtures/user.js
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: src/helpers/fixtures/user.js
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Faker provides a lot of modules with methods to return data. In the previous
    code block, we are working with `faker.name` to generate random names, `faker.lorem`
    to generate random lorem texts, and `faker.date` to generate a recent date. The
    object returned by `userFixtures` now has the closest structure to a user object
    returned by the Django API we have created, and this is exactly what we want.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Faker 提供了许多模块和返回数据的函数。在上一个代码块中，我们使用 `faker.name` 生成随机姓名，使用 `faker.lorem` 生成随机
    lorem 文本，以及使用 `faker.date` 生成最近日期。`userFixtures` 返回的对象现在与 Django API 返回的用户对象结构最接近，这正是我们想要的。
- en: Before diving into component testing, let’s make sure our testing environment
    is well configured.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Running the first test
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a React application is created, the `App.js` file comes with a test file
    called `App.test.js`, which you can see here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: src/App.test.js
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let me explain the code. Here, we are importing the `render` and `screen` methods
    from the RTL. These modules will be used to render a component and make interactions
    with the components easier by providing methods to select DOM elements, respectively.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the `test` method. It’s simply a Jest keyword used to write tests.
    It takes two parameters: a string describing the test, and the callback function
    where you write the testing logic. Inside the callback function, the `App` component
    is rendered first. Then, `linkElement` is retrieved from the screen by using the
    `learn react` text. Once it’s retrieved, we can then check whether the `linkElement`
    exists in the rendered document.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run this test with the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You should have a similar output in the terminal.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Running the yarn test command](img/Figure_11.01_B18221.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Running the yarn test command
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The test has failed. But why? You can somewhat see why in the preceding output.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Reason for failing the App.js test](img/Figure_11.02_B18221.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Reason for failing the App.js test
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'The `App` component in our project uses `react-router-dom` components, such
    as `Routes`, that in turn use the `useRoutes` Hook. This Hook makes use of the
    context that a router component provides, so we need to wrap it inside a Router,
    in this case, the `BrowserRouter` component. Let’s correct this, but let’s also
    change the text from which we will retrieve the link element:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: src/App.test.js
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, run the tests again and everything should work correctly:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Passing tests](img/Figure_11.03_B18221.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Passing tests
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: But we still have a problem. A lot of components in the React application use
    Hooks from the `react-router-dom` library. That means that for each test, we will
    need to wrap the component inside `BrowserRouter`. Following the DRY principle,
    let’s rewrite the render method from the RTL to automatically wrap our components
    inside the `BrowserRouter`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Extending the RTL render method
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside the `src/helpers` directory, create a file called `test-utils.jsx`.
    Once the file is created, add the following lines of code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: src/helpers/test-utils.jsx
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the code, we first import the needed tools. Notice the import of the render
    method as `rtlRender`? It’s for the purpose of avoiding a naming collision as
    we are also writing a render function. Next, we create a function called `Wrapper`,
    where we pass the children’s argument, then wrap it inside a `BrowserRouter` component.
    Then, we return a render object with the UI, `wrapper`, and other render options
    if specified.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: The render method from the RTL provides render options other than the wrapper.
    You can also pass a container, queries, and a lot more. You can check more rendering
    options in the official documentation at [https://testing-library.com/docs/react-testing-library/api/#render-options](https://testing-library.com/docs/react-testing-library/api/#render-options).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: RTL 提供的渲染方法除了包装器之外，还提供了其他渲染选项。您还可以传递一个容器、查询等更多内容。您可以在官方文档中查看更多渲染选项，网址为 [https://testing-library.com/docs/react-testing-library/api/#render-options](https://testing-library.com/docs/react-testing-library/api/#render-options)。
- en: 'Now, let’s use this method in `App.test.js`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 `App.test.js` 中使用这个方法：
- en: src/App.test.js
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: src/App.test.js
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Run the testing command again and everything should be green. With the testing
    environment ready and set up to quickly write tests, we can now move on to testing
    the components of the React project.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试命令，一切应该都是绿色的。当测试环境准备就绪并设置好以便快速编写测试时，我们现在可以继续测试 React 项目的组件。
- en: Important note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'While running tests, you might encounter an error coming from the `axios` package.
    At the time of writing of this book, we are using the 0.26.0 version of `axios`
    to avoid bugs when running tests. You can also modify the test command in the
    `package.json` file to the following: `"test": "react-scripts test --transformIgnorePatterns
    "node_modules/(?!axios)/""`. Learn more about this issue at [https://github.com/axios/axios/issues/5101](https://github.com/axios/axios/issues/5101).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '在运行测试时，您可能会遇到来自 `axios` 包的错误。在撰写本书时，我们使用 `axios` 的 0.26.0 版本来避免在运行测试时出现错误。您也可以将
    `package.json` 文件中的测试命令修改为以下内容：`"test": "react-scripts test --transformIgnorePatterns
    "node_modules/(?!axios)/""`。更多关于此问题的信息，请参阅 [https://github.com/axios/axios/issues/5101](https://github.com/axios/axios/issues/5101)。'
- en: Testing authentication components
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试认证组件
- en: Testing forms in React might seem complicated but it is quite simple when using
    Jest and the RTL. We will begin writing tests in the React project, starting with
    the authentication components. I’ll show you how you can write a test for the
    **Login** form, and after that, you should be able to write the registration form
    test suite.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中测试表单可能看起来很复杂，但使用 Jest 和 RTL 时却相当简单。我们将开始在 React 项目中编写测试，从认证组件开始。我会向您展示如何编写
    **登录** 表单的测试，之后您应该能够编写注册表单的测试套件。
- en: 'For a better structured code base, create a new directory called `__tests__`
    in the `src/components/authentication` directory. This directory will contain
    tests for the components in the `components/authentication` directory. Inside
    the newly created directory, create a file called `LoginForm.test.js` and add
    the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有更好的代码结构，在 `src/components/authentication` 目录中创建一个新的目录名为 `__tests__`。这个目录将包含
    `components/authentication` 目录中组件的测试。在新建的目录中，创建一个名为 `LoginForm.test.js` 的文件，并添加以下代码：
- en: src/components/authentication/__tests__/LoginForm.test.js
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/authentication/__tests__/LoginForm.test.js
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, we have added the required imports to write the test
    and defined the structure of the testing function. We will first render the `LoginForm`
    component and set up the user object to trigger user behavior events using `userEvent`
    `method:src/components/authentication/__tests__/LoginForm.test.js`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了编写测试所需的导入，并定义了测试函数的结构。我们将首先渲染 `LoginForm` 组件，并设置用户对象以使用 `userEvent`
    方法触发用户行为事件：`method:src/components/authentication/__tests__/LoginForm.test.js`
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Important note
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`userEvent` and `fireEvent` are both methods used for simulating user interactions
    with a website in the context of testing. They can be used to test the behavior
    of a website when a user performs certain actions, such as clicking a button or
    filling out a form.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`userEvent` 和 `fireEvent` 都是用于在测试环境中模拟网站用户交互的方法。它们可以用来测试当用户执行某些操作（如点击按钮或填写表单）时网站的行为。'
- en: '`userEvent` is a method provided by the `@testing-library/user-event` library,
    which is designed to make it easier to test user interactions with a website.
    It is a utility function that simulates user events by using the `fireEvent` method
    provided by the `@testing-library/react` library. `userEvent` allows you to specify
    the type of event you want to simulate, such as a click or a keypress, and it
    will automatically dispatch the appropriate event for you.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`userEvent` 是由 `@testing-library/user-event` 库提供的方法，旨在使测试网站的用户交互更容易。这是一个实用函数，它通过使用
    `@testing-library/react` 库提供的 `fireEvent` 方法来模拟用户事件。`userEvent` 允许您指定要模拟的事件类型，例如点击或按键，并且它会自动为您派发适当的事件。'
- en: '`fireEvent` is a method provided by the `@testing-library/react` library, which
    can be used to dispatch events to a DOM element. It allows you to specify the
    type of event you want to dispatch, as well as any additional event data that
    you want to include. `fireEvent` is a more low-level method than `userEvent`,
    and it requires you to manually specify the details of the event you want to dispatch.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`fireEvent` 是由 `@testing-library/react` 库提供的，可以用来向 DOM 元素派发事件。它允许你指定你想要派发的事件类型，以及你想要包含的任何附加事件数据。`fireEvent`
    是一个比 `userEvent` 更低级的方法，它需要你手动指定你想要派发的事件的详细信息。'
- en: 'After that, we can start by testing that the form and the inputs are rendered
    in the document:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以开始测试表单和输入是否已渲染到文档中：
- en: src/components/authentication/__tests__/LoginForm.test.js
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/authentication/__tests__/LoginForm.test.js
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we can ensure that the inputs can receive texts and values as we have
    already selected the username and password fields:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以确保输入可以接收文本和值，因为我们已经选择了用户名和密码字段：
- en: src/components/authentication/__tests__/LoginForm.test.js
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/authentication/__tests__/LoginForm.test.js
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you run the test command again, it will fail. That’s normal, as here we are
    retrieving elements using the `getByTestId` method. The RTL looks in the rendered
    DOM for an element with a `data-testid` attribute with the value passed to the
    `screen.getByTestId` function. We need to add the attribute to the elements we
    want to select and test.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次运行测试命令，它将失败。这是正常的，因为在这里我们正在使用 `getByTestId` 方法检索元素。RTL 在渲染的 DOM 中查找具有 `data-testid`
    属性且其值传递给 `screen.getByTestId` 函数的元素。我们需要将此属性添加到我们想要选择和测试的元素上。
- en: 'To do so, in `src/components/authentication/LoginForm.js`, add the following
    `data-testid` attributes:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，在 `src/components/authentication/LoginForm.js` 中添加以下 `data-testid` 属性：
- en: src/components/authentication/LoginForm.js
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/authentication/LoginForm.js
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once done, re-run the testing command. Everything should work.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，重新运行测试命令。一切应该都会正常工作。
- en: The next step is to write tests for the registration form component. It’ll be
    similar to the tests on the login form component, so you can handle this small
    exercise. You can find the solution at [https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/main/social-media-react/src/components/authentication/__tests__/RegistrationForm.test.js](https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/main/social-media-react/src/components/authentication/__tests__/RegistrationForm.test.js).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为注册表单组件编写测试。它将与登录表单组件上的测试类似，所以你可以处理这个小练习。你可以在[https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/main/social-media-react/src/components/authentication/__tests__/RegistrationForm.test.js](https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/main/social-media-react/src/components/authentication/__tests__/RegistrationForm.test.js)找到解决方案。
- en: Important note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'JavaScript also possesses default naming conventions for the testing files.
    The naming conventions for test files in a JavaScript project are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 也具有测试文件的默认命名约定。JavaScript 项目的测试文件命名约定如下：
- en: '- `<``TestFileName>.test.js`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '- `<``TestFileName>.test.js`'
- en: '- `<``TestFileName>.spec.js`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '- `<``TestFileName>.spec.js`'
- en: Now that we have had a solid introduction to testing in React, let’s continue
    with writing tests for the Post components.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对 React 中的测试有了坚实的介绍，让我们继续编写帖子组件的测试。
- en: Testing Post components
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试帖子组件
- en: The functionalities to create, read, update, and delete posts are core features
    of the Postagram application, so it’s important to make sure that they work as
    expected. Let’s start with a simple test for the `Post` component.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 创建、读取、更新和删除帖子的功能是 Postagram 应用程序的核心功能，因此确保它们按预期工作非常重要。让我们从对 `Post` 组件的简单测试开始。
- en: Mocking the localStorage object
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟 localStorage 对象
- en: 'Before writing a test for the `Post` component, it’s important to understand
    how the Post components work. Basically, it takes a prop called `post` and makes
    a call to `localStorage` to retrieve information about the user. Unfortunately,
    `localStorage` can’t be mocked by Jest. There are a lot of workarounds to allow
    your tests to work with `localStorage` and to make it simple and have less boilerplate,
    we’ll use the `jest-localstorage-mock` JavaScript package. The package can be
    used with Jest to run frontend tests that rely on `localStorage`. To add the package,
    add the following line to the file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写`Post`组件的测试之前，理解`Post`组件的工作方式非常重要。基本上，它接受一个名为`post`的属性，并调用`localStorage`来检索有关用户的信息。不幸的是，`localStorage`不能被Jest模拟。有许多解决方案可以让你的测试与`localStorage`一起工作，并且使它简单且减少样板代码，我们将使用`jest-localstorage-mock`JavaScript包。该包可以与Jest一起使用来运行依赖于`localStorage`的前端测试。要添加该包，请将以下行添加到文件中：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once the package is installed, we need to do some configurations. In the `src/setupTests.js`
    file, add this line to load the `jest-localstorage-mock` package:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了包，我们需要做一些配置。在`src/setupTests.js`文件中，添加以下行以加载`jest-localstorage-mock`包：
- en: src/setupTests.js
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: src/setupTests.js
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After that, override the default Jest configuration in the `package.json` file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在`package.json`文件中覆盖默认的Jest配置：
- en: package.json
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: package.json
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With the configuration ready, we can move to add a function to generate post
    fixtures.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 配置就绪后，我们可以添加一个生成帖子固定数据的函数。
- en: Writing post fixtures
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写帖子固定数据
- en: In the `src/helpers/fixtures` directory, create a new file called `post.js`.
    This file will contain a function that returns fake data from a post object.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/helpers/fixtures`目录中，创建一个名为`post.js`的新文件。该文件将包含一个从帖子对象返回假数据的函数。
- en: 'We will start writing the code in this file by adding the imports and defining
    the `postFixtures` function that will return a generated post object:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始编写此文件中的代码，添加导入并定义将返回生成帖子对象的`postFixtures`函数：
- en: src/helpers/fixtures/post.js
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: src/helpers/fixtures/post.js
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s add the body of the `postFixtures` function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加`postFixtures`函数的主体：
- en: src/helpers/fixtures/post.js
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: src/helpers/fixtures/post.js
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we are passing either a generated `userFixtures` or a user object if it’s
    defined. This is important if we want to make sure that the author of the post
    is the same user registered in `localStorage`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们传递一个生成的`userFixtures`或一个已定义的用户对象。如果我们想确保帖子的作者与在`localStorage`中注册的用户相同，这是很重要的。
- en: With the post fixtures written, we can write the test suite for the `Post` component.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写帖子固定数据后，我们可以为`Post`组件编写测试套件。
- en: Writing tests for the Post component
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写`Post`组件的测试
- en: 'To write the test suite in the `src/components/posts` directory, create a new
    folder called `__tests__`. Inside the newly created folder, add a new file called
    `Post.test.js`. Inside, add the imports, create the data we need, and set user
    data returned by the `userFixtures` function in the local storage using the `setUserData`
    function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`src/components/posts`目录中编写测试套件，创建一个名为`__tests__`的新文件夹。在新建的文件夹中，添加一个名为`Post.test.js`的新文件。在文件中，添加导入，创建所需的数据，并使用`setUserData`函数在本地存储中设置`userFixtures`函数返回的用户数据：
- en: src/components/posts/__tests__/Post.test.js
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/posts/__tests__/Post.test.js
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `beforeEach` method is a Jest method that runs before every test. It takes
    a callback function as a parameter, where you can execute lines of code that should
    run before the tests. Here, we are clearing the local storage first to avoid memory
    leaking (with `localStorage.clear`) and finally, we set user data retrieved from
    the `userFixtures` function in the local storage.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`beforeEach`方法是一个Jest方法，它在每个测试之前运行。它接受一个回调函数作为参数，其中可以执行应该在测试之前运行的代码行。在这里，我们首先清除本地存储以避免内存泄漏（使用`localStorage.clear`），最后，我们将从`userFixtures`函数检索的用户数据设置在本地存储中。'
- en: Important note
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A memory leak occurs when a program creates a memory in heap and forgets to
    delete it. In a worst-case scenario, if too much memory is allocated and not used
    correctly, this can reduce the computer’s performance.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序在堆中创建内存并忘记删除它时，会发生内存泄漏。在最坏的情况下，如果分配了太多内存且未正确使用，这可能会降低计算机的性能。
- en: 'Let’s write the test for the `Post` component now:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写`Post`组件的测试：
- en: src/components/posts/__tests__/Post.test.js
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/posts/__tests__/Post.test.js
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you run the test command, it’ll fail. This is normal because there is no
    `data-testid` attribute with the value `post-test` set in the JSX of the `Post`
    component. Let’s fix this by adding a `data-testid` attribute in the `Post` component
    :'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行测试命令，它将失败。这是正常的，因为在`Post`组件的JSX中没有设置值为`post-test`的`data-testid`属性。让我们通过在`Post`组件中添加`data-testid`属性来修复这个问题：
- en: src/components/posts/Post.jsx
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/posts/Post.jsx
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Run the testing command again and everything should be green. Let’s move on
    to actually writing a test for the `CreatePost` component.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试命令，一切应该都是绿色的。让我们继续编写`CreatePost`组件的测试。
- en: Testing the CreatePost component
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试CreatePost组件
- en: 'In the `src/components/posts/__tests__` directory, create a new file called
    `CreatePost.test.js`. We’ll start with the necessary imports and the definition
    of the `test` function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/components/posts/__tests__`目录下，创建一个名为`CreatePost.test.js`的新文件。我们将从必要的导入和`test`函数的定义开始：
- en: src/components/posts/__tests__/CreatePost.test.js
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/posts/__tests__/CreatePost.test.js
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can notice the introduction of the `async` keyword before the callback function.
    To create a post, the user performs typing operations on text inputs and finally
    a button click to submit the post. These actions are asynchronous. The functions,
    such as `fireEvent`, that we will use to simulate user interactions should be
    used in an asynchronous scope.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以注意到在回调函数之前引入了`async`关键字。为了创建帖子，用户在文本输入框中进行输入操作，最后点击按钮提交帖子。这些操作是异步的。我们将使用来模拟用户交互的函数，如`fireEvent`，应该在异步作用域中使用。
- en: 'Before writing the test logic, let’s remember how the `CreatePost` component
    works:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试逻辑之前，让我们回顾一下`CreatePost`组件是如何工作的：
- en: The user clicks on the input to add a new post.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户点击输入框以添加新的帖子。
- en: A modal is shown containing a form where the user can enter the text of the
    post. Meanwhile, the submit button is disabled.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示一个包含表单的模态框，用户可以输入帖子的文本。同时，提交按钮处于禁用状态。
- en: Once there is enough text in the field, the submit button is enabled and the
    user can click to send the post.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当字段中有足够的文本时，提交按钮被启用，用户可以点击发送帖子。
- en: We must ensure that we respect this logic when writing the tests. Now, let’s
    start writing the tests.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保在编写测试时尊重这个逻辑。现在，让我们开始编写测试。
- en: 'First, we render the form that displays the form modal to create a post:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们渲染显示创建帖子模态框的表单：
- en: src/components/posts/__tests__/CreatePost.test.js
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/posts/__tests__/CreatePost.test.js
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can now simulate a click event using `fireEvent.click` on `showModalForm`
    to display the form for creating a post:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用`fireEvent.click`在`showModalForm`上模拟点击事件来显示创建帖子的表单：
- en: src/components/posts/__tests__/CreatePost.test.js
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/posts/__tests__/CreatePost.test.js
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We then make sure that the body field is rendered and the submit button is
    disabled:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保正文字段被渲染，提交按钮被禁用：
- en: src/components/posts/__tests__/CreatePost.test.js
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/posts/__tests__/CreatePost.test.js
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After that, we can then type some text in the body field, test whether the
    text typed is what we expect, and ensure that the button is enabled after that:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以在正文字段中输入一些文本，测试输入的文本是否符合预期，并确保之后按钮处于启用状态：
- en: src/components/posts/__tests__/CreatePost.test.js
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/posts/__tests__/CreatePost.test.js
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Great! We have a solid testing suite and we can now add the `data-testid` attributes
    to the `CreatePost` component to make the tests pass:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们有一个可靠的测试套件，现在我们可以向`CreatePost`组件添加`data-testid`属性以使测试通过：
- en: src/components/posts/CreatePost.jsx
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/posts/CreatePost.jsx
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Run the test command again and everything should work. The next step is to write
    unit tests for the `UpdatePost` component.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试命令，一切应该正常工作。下一步是编写`UpdatePost`组件的单元测试。
- en: Testing the UpdatePost component
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试UpdatePost组件
- en: 'In the `src/components/posts/__tests__` directory, create a new file called
    `UpdatePost.test.js`. Let’s start with the necessary imports and the definition
    of the `test` function:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/components/posts/__tests__`目录下，创建一个名为`UpdatePost.test.js`的新文件。让我们从必要的导入和`test`函数的定义开始：
- en: src/components/posts/__tests__/UpdatePost.test.js
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/posts/__tests__/UpdatePost.test.js
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Before writing the test logic, let’s remember how the `UpdatePost` component
    works from a user’s perspective:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试逻辑之前，让我们回顾一下从用户的角度来看`UpdatePost`组件是如何工作的：
- en: The user clicks on the drop-down item to modify a post.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户点击下拉菜单项来修改帖子。
- en: A modal is shown containing a form where the user can modify the text of the
    post.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示一个包含表单的模态框，用户可以修改帖子的文本。
- en: After the modification, the user can submit the form with the updated post.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改后，用户可以使用更新后的帖子提交表单。
- en: We must ensure that we respect that logic when writing the tests.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保在编写测试时尊重这种逻辑。
- en: 'So, first, we render the form that displays the form modal to update a post:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，我们渲染显示更新帖子表单的表单模态：
- en: src/components/posts/__tests__/UpdatePost.test.js
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/posts/__tests__/UpdatePost.test.js
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We then want to trigger a click event to display the modal with the form to
    update the post:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们希望触发一个点击事件来显示用于更新帖子的表单模态：
- en: src/components/posts/__tests__/UpdatePost.test.js
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/posts/__tests__/UpdatePost.test.js
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We then select the post body field and the submit button to ensure that they
    are rendered:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们选择帖子正文字段和提交按钮，以确保它们被渲染：
- en: src/components/posts/__tests__/UpdatePost.test.js
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/posts/__tests__/UpdatePost.test.js
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After that, we can now trigger a typing event in the post body field and ensure
    that the user is submitting the right data:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们现在可以在帖子正文字段中触发一个输入事件，并确保用户提交了正确的数据：
- en: src/components/posts/__tests__/UpdatePost.test.js
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/posts/__tests__/UpdatePost.test.js
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The next step is now to add the `data-testid` attributes on the post form,
    the post body input, and the submit button in the `UpdatePost` component to make
    the tests pass:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将`data-testid`属性添加到`UpdatePost`组件中的帖子表单、帖子正文输入和提交按钮，以便测试通过：
- en: src/components/posts/UpdatePost.jsx
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/posts/UpdatePost.jsx
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Run the test command again and everything should work.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试命令，一切应该都会正常工作。
- en: With this introduction to complex tests with Jest and the RTL, you can easily
    write the tests for the comment’s components. You can find the solution for these
    tests at [https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/main/social-media-react/src/components/comments/__tests__](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/main/social-media-react/src/components/comments/__tests__).
    Good luck!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对Jest和RTL的复杂测试的介绍，您可以轻松编写评论组件的测试。您可以在[https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/main/social-media-react/src/components/comments/__tests__](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/main/social-media-react/src/components/comments/__tests__)找到这些测试的解决方案。祝您好运！
- en: In the next section, we will discover what snapshot testing is.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解快照测试是什么。
- en: Snapshot testing
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快照测试
- en: 'Snapshot tests are a very useful tool when you want to make sure that your
    UI does not change unexpectedly. A snapshot test case follows these steps:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想确保UI不会意外改变时，快照测试是一个非常有用的工具。一个快照测试案例遵循以下步骤：
- en: It renders the UI component.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它渲染UI组件。
- en: It then takes a snapshot and compares it to a reference snapshot file stored
    alongside the test file.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它将捕获一个快照并将其与存储在测试文件旁边的参考快照文件进行比较。
- en: If both states are the same, the snapshot test is successful. Otherwise, you
    will get errors and need to decide whether you need to update the snapshot tests
    or fix your components.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个状态相同，快照测试就成功了。否则，您将得到错误，并需要决定是否需要更新快照测试或修复您的组件。
- en: Snapshot tests are great to prevent UI regression and ensure that the application
    adheres to the code quality and values of your development team.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 快照测试非常有助于防止UI回归并确保应用程序遵守您的开发团队的代码质量和价值观。
- en: There is a minor setback with snapshot tests, however. Snapshot testing doesn’t
    work best with dynamic components. For example, the `Post` component uses `timeago`
    to display a human-readable time. This means that a snapshot of this component
    at time `t` will be different from a snapshot of the same component at time `t
    + 1`. However, there are some static components in the React application such
    as `LoginForm`, `RegistrationForm`, `ProfileDetails`, `ProfileCard`, `CreatePost`,
    and much more.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，快照测试存在一个小问题。快照测试与动态组件配合得不是很好。例如，`Post`组件使用`timeago`来显示可读时间。这意味着在时间`t`的该组件的快照将不同于在时间`t
    + 1`的同一组件的快照。然而，在React应用程序中也有一些静态组件，例如`LoginForm`、`RegistrationForm`、`ProfileDetails`、`ProfileCard`、`CreatePost`等等。
- en: For the sake of simplicity, we will write a snapshot test for the `ProfileCard`
    components, which are straightforward and can be replicated easily.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们将为`ProfileCard`组件编写一个快照测试，这些组件简单直接，并且可以轻松复制。
- en: 'In the `src/components/profile` directory, create a new directory called `__tests__`.
    Then, create a new file called `ProfileCard.test.js`. For a snapshot test, we
    don’t want the data to change so we will use a static user fixture because using
    `userFixtures` to generate a fixture will create random data every time a snapshot
    test is run. In the newly created file, let’s add the imports needed to create
    a snapshot test and define a fixture object called `userData`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/components/profile`目录下，创建一个名为`__tests__`的新目录。然后，创建一个名为`ProfileCard.test.js`的新文件。对于快照测试，我们不希望数据发生变化，因此我们将使用静态用户固定值，因为使用`userFixtures`生成固定值会在每次运行快照测试时创建随机数据。在新建的文件中，让我们添加创建快照测试所需的导入，并定义一个名为`userData`的固定值对象：
- en: src/components/profile/__tests__/ProfileCard.test.js
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/profile/__tests__/ProfileCard.test.js
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With the needed imports added and the `userData` fixtures written, we can now
    write the testing function:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了所需的导入并编写了`userData`固定值之后，我们现在可以编写测试函数：
- en: src/components/profile/__tests__/ProfileCard.test.js
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/profile/__tests__/ProfileCard.test.js
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you run the test command, you’ll notice that a snapshot directory is created
    in the `__tests__` directory:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行测试命令，你会注意到在`__tests__`目录下创建了一个快照目录：
- en: '![Figure 11.4 – Snapshots directory created](img/Figure_11.04_B18221.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4 – 创建了快照目录](img/Figure_11.04_B18221.jpg)'
- en: Figure 11.4 – Snapshots directory created
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – 创建了快照目录
- en: If you check the content of `ProfileCard.test.js.snap`, it is basically the
    rendered code of the `ProfileCard` component. The content of this file will be
    compared each time the test function for the snapshot test runs.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查`ProfileCard.test.js.snap`的内容，它基本上是`ProfileCard`组件的渲染代码。每次快照测试的测试函数运行时，都会比较这个文件的内容。
- en: Now have covered the essential unit tests for a React application, we are mostly
    done adding features to the application. Our full stack application is now ready
    for production! Yay, but don’t celebrate too soon. We still need to prepare our
    application for production in terms of the security, quality, and performance
    aspects and this is what we’ll be doing in *Part 3* of this book.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了React应用程序的基本单元测试，我们主要完成了添加功能的工作。我们的全栈应用程序现在已准备好投入生产！太好了，但不要过早庆祝。我们仍然需要在安全、质量和性能方面为我们的应用程序做好生产准备，这正是本书第三部分将要做的。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned about frontend unit testing. We discovered
    why it is important to write unit tests in the frontend application and what to
    test exactly. We have also written tests for components in the Postagram application,
    seen how we can extend testing tools modules and methods, how to write generate
    fixtures for the tests, and how to make the tests closer to user interactions
    by triggering user events. We have also made some introductions to snapshot testing.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了前端单元测试。我们发现了为什么在前端应用程序中编写单元测试很重要，以及确切要测试什么。我们还为Postagram应用程序中的组件编写了测试，看到了如何扩展测试工具模块和方法，如何编写测试的生成固定值，以及如何通过触发用户事件使测试更接近用户交互。我们还对快照测试做了一些介绍。
- en: The next chapters in *Part 3* of this book will focus on deploying the backend
    and the frontend on the cloud using AWS services, GitHub, and GitHub Actions.
    Lastly, we will see how to improve the full stack application in terms of performance,
    security, and quality.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本书第三部分的下一章将重点介绍使用AWS服务、GitHub和GitHub Actions在云上部署后端和前端。最后，我们将看到如何从性能、安全性和质量方面改进全栈应用程序。
- en: Questions
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the render method of the RTL?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RTL的渲染方法是什么？
- en: What is Jest?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jest是什么？
- en: What is the role of the `data-tested` attribute?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`data-tested`属性的作用是什么？'
- en: What are the drawbacks of snapshot testing?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快照测试的缺点是什么？
- en: What are the modules used to trigger user events on a React test suite?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于在React测试套件中触发用户事件的模块有哪些？
- en: 'Part 3: Deploying Django and React on AWS'
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：在AWS上部署Django和React
- en: Deployment is one of the last important steps in software development. Your
    application is running locally and everything is working fine. But how do you
    get your code on a public server? How do you host your frontend? How do you make
    changes to your code and make deployment and testing automatic? In this part of
    the book, we’ll explore topics such as CI/CD, GitHub, Docker, and the best deployment
    practices while deploying the Django application on AWS EC2 and the React application
    on AWS S3\. We’ll also talk about security and performance.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 部署是软件开发中最后的重要步骤之一。您的应用程序在本地运行且一切正常。但您如何将代码部署到公共服务器上？您如何托管前端？您如何修改代码并使部署和测试自动化？在本书的这一部分，我们将探讨在
    AWS EC2 上部署 Django 应用和在 AWS S3 上部署 React 应用时涉及的 CI/CD、GitHub、Docker 以及最佳部署实践等主题。我们还将讨论安全和性能问题。
- en: 'This section comprises the following chapters:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含以下章节：
- en: '[*Chapter 12*](B18221_12.xhtml#_idTextAnchor239), *Deployment Basics – Git,
    GitHub, and AWS*'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B18221_12.xhtml#_idTextAnchor239)，*部署基础 – Git、GitHub 和 AWS*'
- en: '[*Chapter 13*](B18221_13.xhtml#_idTextAnchor252), *Dockerizing the Django Project*'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B18221_13.xhtml#_idTextAnchor252)，*将 Django 项目容器化*'
- en: '[*Chapter 14*](B18221_14.xhtml#_idTextAnchor286), *Automating Deployment on
    AWS*'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B18221_14.xhtml#_idTextAnchor286)，*在 AWS 上自动化部署*'
- en: '[*Chapter 15*](B18221_15.xhtml#_idTextAnchor330), *Deploying Our React App
    on AWS*'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B18221_15.xhtml#_idTextAnchor330)，*在 AWS 上部署我们的 React 应用*'
- en: '[*Chapter 16*](B18221_16.xhtml#_idTextAnchor352), *Performance, Optimization,
    and Security*'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第16章*](B18221_16.xhtml#_idTextAnchor352)，*性能、优化和安全*'
