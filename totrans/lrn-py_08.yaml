- en: Chapter 8. The Edges – GUIs and Scripts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。边缘 – GUI和脚本
- en: '|   | *"A user interface is like a joke. If you have to explain it, it''s not
    that good."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"用户界面就像一个笑话。如果你不得不解释它，那就不是很好。" |   |'
- en: '|   | --*Martin LeBlanc* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*马丁·勒布兰* |'
- en: In this chapter, we're going to work on a project together. We're going to prepare
    a very simple HTML page with a few images, and then we're going to scrape it,
    in order to save those images.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将一起完成一个项目。我们将准备一个非常简单的HTML页面，其中包含一些图片，然后我们将爬取它，以便保存这些图片。
- en: We're going to write a script to do this, which will allow us to talk about
    a few concepts that I'd like to run by you. We're also going to add a few options
    to save images based on their format, and to choose the way we save them. And,
    when we're done with the script, we're going to write a GUI application that does
    basically the same thing, thus killing two birds with one stone. Having only one
    project to explain will allow me to show a wider range of topics in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个脚本来完成这项工作，这将使我们能够讨论一些我想向您介绍的概念。我们还将添加一些选项，根据图片的格式保存图片，并选择保存的方式。完成脚本后，我们将编写一个GUI应用程序，它基本上做同样的事情，一石二鸟。只有一个项目来解释将使我能够在本章中展示更广泛的主题。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A **graphical user interface** (**GUI**) is a type of interface that allows
    the user to interact with an electronic device through graphical icons, buttons
    and widgets, as opposed to text-based or command-line interfaces, which require
    commands or text to be typed on the keyboard. In a nutshell, any browser, any
    office suite such as LibreOffice, and, in general, anything that pops up when
    you click on an icon, is a GUI application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**图形用户界面**（**GUI**）是一种允许用户通过图形图标、按钮和小部件与电子设备交互的界面，与基于文本或命令行界面相反，后者需要在键盘上输入命令或文本。简而言之，任何浏览器、任何办公套件如LibreOffice，以及您点击图标时弹出的任何东西，都是一个GUI应用程序。'
- en: 'So, if you haven''t already done so, this would be the perfect time to start
    a console and position yourself in a folder called `ch8` in the root of your project
    for this book. Within that folder, we''ll create two Python modules (`scrape.py`
    and `guiscrape.py`) and one standard folder (`simple_server`). Within `simple_server`,
    we''ll write our HTML page (`index.html`) in `simple_server`. Images will be stored
    in `ch8/simple_server/img`. The structure in `ch8` should look like this:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您还没有这样做，现在开始一个控制台并将自己定位在项目根目录下的一个名为`ch8`的文件夹中，这将是一个完美的时机。在那个文件夹中，我们将创建两个Python模块（`scrape.py`和`guiscrape.py`）和一个标准文件夹（`simple_server`）。在`simple_server`中，我们将编写我们的HTML页面（`index.html`），图片将存储在`ch8/simple_server/img`。`ch8`中的结构应该如下所示：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you're using either Linux or Mac, you can do what I do and put the code to
    start the HTTP server in a `serve.sh` file. On Windows, you'll probably want to
    use a batch file.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Linux或Mac，您可以像我所做的那样，将启动HTTP服务器的代码放入一个`serve.sh`文件中。在Windows上，您可能想使用批处理文件。
- en: 'The HTML page we''re going to scrape has the following structure:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要爬取的HTML页面具有以下结构：
- en: '`simple_server/index.html`'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`simple_server/index.html`'
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It's an extremely simple page, so let's just note that we have five images,
    three of which are PNGs and two are JPGs (note that even though they are both
    JPGs, one ends with `.jpg` and the other with `.jpeg`, which are both valid extensions
    for this format).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个非常简单的页面，所以我们只需注意我们有五张图片，其中三张是PNG格式，两张是JPG格式（注意，尽管它们都是JPG格式，一个以`.jpg`结尾，另一个以`.jpeg`结尾，这两种都是该格式的有效扩展名）。
- en: 'So, Python gives you a very simple HTTP server for free that you can start
    with the following command (in the `simple_server` folder):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Python免费提供了一个非常简单的HTTP服务器，您可以使用以下命令启动（在`simple_server`文件夹中）：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The last line is the log you get when you access `http://localhost:8000`, where
    our beautiful page will be served. Alternatively, you can put that command in
    a file called `serve.sh`, and just run that with this command (make sure it''s
    executable):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行是您访问`http://localhost:8000`时得到的日志，我们的美丽页面将在这里提供服务。或者，您可以将该命令放入一个名为`serve.sh`的文件中，然后使用以下命令运行它（确保它是可执行的）：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It will have the same effect. If you have the code for this book, your page
    should look something like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它将产生相同的效果。如果您有这本书的代码，您的页面应该看起来像这样：
- en: '![The Edges – GUIs and Scripts](img/4715_08_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![The Edges – GUIs and Scripts](img/4715_08_01.jpg)'
- en: Feel free to use any other set of images, as long as you use at least one PNG
    and one JPG, and that in the `src` tag you use relative paths, not absolute. I
    got those lovely owls from [https://openclipart.org/](https://openclipart.org/).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自由地使用任何其他图像集，只要您至少使用一个PNG和一个JPG，并且在`src`标签中使用相对路径，而不是绝对路径。我得到了那些可爱的猫头鹰来自[https://openclipart.org/](https://openclipart.org/)。
- en: First approach – scripting
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一种方法 – 脚本
- en: 'Now, let''s start writing the script. I''ll go through the source in three
    steps: imports first, then the argument parsing logic, and finally the business
    logic.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始编写脚本。我将分三步进行源代码的审查：首先是导入，然后是参数解析逻辑，最后是业务逻辑。
- en: The imports
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入
- en: '`scrape.py (Imports)`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`scrape.py (导入)`'
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Going through them from the top, you can see that we'll need to parse the arguments.
    which we'll feed to the script itself (`argparse`). We will need the `base64`
    library to save the images within a JSON file (`base64` and `json`), and we'll
    need to open files for writing (`os`). Finally, we'll need `BeautifulSoup` for
    scraping the web page easily, and `requests` to fetch its content. `requests`
    is an extremely popular library for performing HTTP requests, built to avoid the
    difficulties and quirks of using the standard library `urllib` module. It's based
    on the fast `urllib3` third-party library.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始查看，我们可以看到我们需要解析参数，这些参数将被提供给脚本本身（`argparse`）。我们需要`base64`库来在JSON文件中保存图像（`base64`和`json`），我们还需要打开文件进行写入（`os`）。最后，我们需要`BeautifulSoup`来轻松抓取网页，以及`requests`来获取其内容。`requests`是一个执行HTTP请求的极其流行的库，它基于快速的第三方库`urllib3`。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will explore the HTTP protocol and `requests` mechanism in [Chapter 10](ch10.html
    "Chapter 10. Web Development Done Right"), *Web Development Done Right* so, for
    now, let's just (simplistically) say that we perform an HTTP request to fetch
    the content of a web page. We can do it programmatically using a library such
    as `requests`, and it's more or less the equivalent of typing a URL in your browser
    and pressing *Enter* (the browser then fetches the content of a web page and also
    displays it to you).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第10章[Web Development Done Right](ch10.html "第10章。正确进行Web开发")中探索HTTP协议和`requests`机制，因此，现在我们只需（简单地）说，我们执行一个HTTP请求来获取网页内容。我们可以使用像`requests`这样的库来程序化地完成它，这大致相当于在浏览器中输入一个URL并按*Enter*键（浏览器随后获取网页内容并显示给您）。
- en: 'Of all these imports, only the last two don''t belong to the Python standard
    library, but they are so widely used throughout the world that I dare not exclude
    them in this book. Make sure you have them installed:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些导入中，只有最后两个不属于Python标准库，但它们在全球范围内被广泛使用，我不敢在这本书中排除它们。请确保您已安装它们：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Of course, the version numbers might be different for you. If they''re not
    installed, use this command to do so:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，版本号可能对您来说有所不同。如果它们尚未安装，请使用以下命令进行安装：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At this point, the only thing that I reckon might confuse you is the `base64/json`
    couple, so allow me to spend a few words on that.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我认为可能让您感到困惑的唯一事情是`base64/json`这对，因此请允许我花几句话来解释这一点。
- en: As we saw in the previous chapter, JSON is one of the most popular formats for
    data exchange between applications. It's also widely used for other purposes too,
    for example, to save data in a file. In our script, we're going to offer the user
    the ability to save images as image files, or as a JSON single file. Within the
    JSON, we'll put a dictionary with keys as the images names and values as their
    content. The only issue is that saving images in the binary format is tricky,
    and this is where the `base64` library comes to the rescue. **Base64** is a very
    popular binary-to-text encoding scheme that represents binary data in an ASCII
    string format by translating it into a radix-64 representation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，JSON是应用程序之间数据交换最流行的格式之一。它也被广泛用于其他目的，例如，在文件中保存数据。在我们的脚本中，我们将为用户提供保存图像为图像文件或JSON单个文件的能力。在JSON中，我们将放置一个字典，键为图像名称，值为内容。唯一的问题是，以二进制格式保存图像有点棘手，这就是`base64`库发挥作用的地方。**Base64**是一种非常流行的二进制到文本编码方案，通过将其转换为基数64表示来以ASCII字符串格式表示二进制数据。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **radix-64** representation uses the letters *A*-*Z*, *a*-*z*, and the digits
    *0*-*9*, plus the two symbols *+* and */* for a grand total of 64 symbols altogether.
    Therefore, not surprisingly, the Base64 alphabet is made up of these 64 symbols.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**radix-64**表示法使用字母*A*-*Z*、*a*-*z*和数字*0*-*9*，以及两个符号*+*和*/*，总共64个符号。因此，不出所料，Base64字母表由这64个符号组成。'
- en: If you think you have never used it, think again. Every time you send an email
    with an image attached to it, the image gets encoded with Base64 before the email
    is sent. On the recipient side, images are automatically decoded into their original
    binary format so that the email client can display them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为你从未使用过它，那么再想想。每次你发送带有图片的电子邮件时，图片在发送邮件之前都会被Base64编码。在接收方，图片会自动解码成原始的二进制格式，以便电子邮件客户端可以显示它们。
- en: Parsing arguments
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析参数
- en: Now that the technicalities are out of the way, let's see the second section
    of our script (it should be at the end of the `scrape.py` module).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在技术细节已经解决，让我们看看脚本的第二部分（它应该在`scrape.py`模块的末尾）。
- en: '`scrape.py (Argument parsing and scraper triggering)`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`scrape.py (参数解析和抓取触发器)`'
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Look at that first line; it is a very common idiom when it comes to scripting.
    According to the official Python documentation, the string `'__main__'` is the
    name of the scope in which top-level code executes. A module's `__name__` is set
    equal to `'__main__'` when read from standard input, a script, or from an interactive
    prompt.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 看看第一行；当涉及到脚本编写时，这是一个非常常见的习语。根据官方Python文档，字符串`'__main__'`是顶级代码执行的命名空间的名字。当从标准输入、脚本或交互式提示符读取模块时，模块的`__name__`会被设置为`'__main__'`。
- en: Therefore, if you put the execution logic under that `if`, the result is that
    you will be able to use the module as a library should you need to import any
    of the functions or objects defined in it, because when importing it from another
    module, `__name__` won't be `'__main__'`. On the other hand, when you run the
    script directly, like we're going to, `__name__` will be `'__main__'`, so the
    execution logic will run.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你将执行逻辑放在那个`if`下面，结果是你可以将模块作为库使用，如果你需要导入其中定义的任何函数或对象，因为当你从另一个模块导入它时，`__name__`不会是`'__main__'`。另一方面，当你直接运行脚本，就像我们即将要做的那样，`__name__`将是`'__main__'`，所以执行逻辑将会运行。
- en: The first thing we do then is define our parser. I would recommend using the
    standard library module, `argparse`, which is simple enough and quite powerful.
    There are other options out there, but in this case, `argparse` will provide us
    with all we need.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的事情是定义我们的解析器。我建议使用标准库模块`argparse`，它足够简单且功能强大。还有其他选择，但在这个情况下，`argparse`将为我们提供所有需要的东西。
- en: 'We want to feed our script three different data: the type of images we want
    to save, the format in which we want to save them, and the URL for the page to
    be scraped.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望向我们的脚本提供三种不同的数据：我们想要保存的图像类型、我们想要保存它们的格式以及要抓取的页面的URL。
- en: The type can be PNG, JPG or both (default), while the format can be either image
    or JSON, image being the default. URL is the only mandatory argument.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 类型可以是PNG、JPG或两者（默认），而格式可以是图像或JSON，图像是默认格式。URL是唯一的必填参数。
- en: So, we add the `-t` option, allowing also the long version `--type`. The choices
    are `'all'`, `'png'`, and `'jpg'`. We set the default to `'all'` and we add a
    help message.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们添加了`-t`选项，也允许长版本`--type`。选项有`'all'`、`'png'`和`'jpg'`。我们将默认值设置为`'all'`并添加了帮助信息。
- en: We do a similar procedure for the `format` argument allowing both the short
    and long syntax (`-f` and `--format`), and finally we add the `url` argument,
    which is the only one that is specified differently so that it won't be treated
    as an option, but rather as a positional argument.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`format`参数执行类似的操作，允许使用简短和长格式（`-f`和`--format`），最后我们添加了`url`参数，这是唯一一个指定方式不同的参数，因此它不会被当作选项处理，而是作为一个位置参数。
- en: In order to parse all the arguments, all we need is `parser.parse_args()`. Very
    simple, isn't it?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析所有参数，我们只需要`parser.parse_args()`。非常简单，不是吗？
- en: The last line is where we trigger the actual logic, by calling the `scrape`
    function, passing all the arguments we just parsed. We will see its definition
    shortly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行是我们触发实际逻辑的地方，通过调用`scrape`函数，传递我们刚刚解析的所有参数。我们很快就会看到它的定义。
- en: 'The nice thing about `argparse` is that if you call the script by passing `-h`,
    it will print a nice **usage text** for you automatically. Let''s try it out:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`argparse`的好处是，如果你通过传递`-h`来调用脚本，它会自动为你打印出漂亮的**使用文本**。让我们试试：'
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you think about it, the one true advantage of this is that we just need to
    specify the arguments and we don't have to worry about the usage text, which means
    we won't have to keep it in sync with the arguments' definition every time we
    change something. This is precious.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细想想，这个真正的优势就是我们只需要指定参数，我们不必担心使用文本，这意味着我们不必每次更改时都将其与参数定义保持同步。这是宝贵的。
- en: 'Here''s a few different ways to call our `scrape.py` script, which demonstrate
    that `type` and `format` are optional, and how you can use the short and long
    syntax to use them:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些调用我们的`scrape.py`脚本的不同方法，展示了`type`和`format`是可选的，以及如何使用简短和长语法来使用它们：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first one is using default values for `type` and `format`. The second one
    will save only PNG images, and the third one will save only JPGs, but in JSON
    format.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个使用`type`和`format`的默认值。第二个只会保存PNG图像，而第三个只会保存JPG，但以JSON格式保存。
- en: The business logic
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 业务逻辑
- en: 'Now that we''ve seen the scaffolding, let''s dive deep into the actual logic
    (if it looks intimidating don''t worry; we''ll go through it together). Within
    the script, this logic lies after the imports and before the parsing (before the
    `if __name__` clause):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了脚手架，让我们深入到实际的逻辑中（如果看起来令人生畏，不要担心；我们会一起走过）。在脚本中，这个逻辑位于导入之后和解析之前（在`if
    __name__`子句之前）：
- en: '`scrape.py (Business logic)`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`scrape.py (业务逻辑)`'
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's start with the `scrape` function. The first thing it does is fetch the
    page at the given `url` argument. Whatever error may happen while doing this,
    we trap it in the `RequestException rex` and we print it. The `RequestException`
    is the base exception class for all the exceptions in the `requests` library.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`scrape`函数开始。它首先做的事情是获取给定的`url`参数指定的页面。在这个过程中可能发生的任何错误，我们都会在`RequestException
    rex`中捕获它并打印出来。`RequestException`是`requests`库中所有异常的基类。
- en: However, if things go well, and we have a page back from the `GET` request,
    then we can proceed (`else` branch) and feed its content to the `BeautifulSoup`
    parser. The `BeautifulSoup` library allows us to parse a web page in no time,
    without having to write all the logic that would be needed to find all the images
    in a page, which we really don't want to do. It's not as easy as it seems, and
    reinventing the wheel is never good. To fetch images, we use the `_fetch_images`
    function and we filter them with `_filter_images`. Finally, we call `_save` with
    the result.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果一切顺利，并且我们从`GET`请求中得到了一个页面，那么我们可以继续（`else`分支）并将其内容传递给`BeautifulSoup`解析器。`BeautifulSoup`库允许我们快速解析网页，而无需编写所有用于在页面中找到所有图像的逻辑，我们真的不想这样做。这并不像看起来那么简单，重新发明轮子从来都不是一个好的选择。为了获取图像，我们使用`_fetch_images`函数，并通过`_filter_images`过滤它们。最后，我们使用结果调用`_save`。
- en: Splitting the code into different functions with meaningful names allows us
    to read it more easily. Even if you haven't seen the logic of the `_fetch_images`,
    `_filter_images,` and `_save` functions, it's not hard to predict what they do,
    right?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码拆分成具有意义名称的不同函数，使我们更容易阅读。即使你没有看到`_fetch_images`、`_filter_images`和`_save`函数的逻辑，也不难预测它们的作用，对吧？
- en: '`_fetch_images` takes a `BeautifulSoup` object and a base URL. All it does
    is looping through all of the images found on the page and filling in the `''name''`
    and `''url''` information about them in a dictionary (one per image). All dictionaries
    are added to the `images` list, which is returned at the end.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`_fetch_images`函数接受一个`BeautifulSoup`对象和一个基础URL。它所做的一切就是遍历页面上找到的所有图像，并在字典中填充它们的`''name''`和`''url''`信息（每个图像一个字典）。所有字典都添加到`images`列表中，并在最后返回。'
- en: There is some trickery going on when we get the name of an image. What we do
    is split the `img_url` (`http://localhost:8000/img/my_image_name.png`) string
    using `'/'` as a separator, and we take the last item as the image name. There
    is a more robust way of doing this, but for this example it would be overkill.
    If you want to see the details of each step, try to break this logic down into
    smaller steps, and print the result of each of them to help yourself understand.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们获取图像名称时，有一些技巧在起作用。我们做的是使用`'/'`作为分隔符拆分`img_url`（`http://localhost:8000/img/my_image_name.png`）字符串，并取最后一个项目作为图像名称。有一种更健壮的方法来做这件事，但在这个例子中可能会有些过度。如果你想看到每个步骤的细节，试着将这个逻辑分解成更小的步骤，并打印出每个步骤的结果来帮助自己理解。
- en: Towards the end of the book, I'll show you another technique to debug in a much
    more efficient way.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在书的结尾，我会向你展示另一种更高效地调试的技术。
- en: 'Anyway, by just adding `print(images)` at the end of the `_fetch_images` function,
    we get this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，只需在`_fetch_images`函数的末尾添加`print(images)`，我们就能得到这个结果：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I truncated the result for brevity. You can see each dictionary has a `'url'`
    and `'name'` key/value pair, which we can use to fetch, identify and save our
    images as we like. At this point, I hear you asking what would happen if the images
    on the page were specified with an absolute path instead of a relative one, right?
    Good question!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我为了简洁起见截断了结果。你可以看到每个字典都有一个 `'url'` 和 `'name'` 键/值对，我们可以使用它来获取、识别并按我们的喜好保存图像。在这个时候，我听到你在问，如果页面上的图像使用绝对路径而不是相对路径指定会发生什么，对吧？好问题！
- en: The answer is that the script will fail to download them because this logic
    expects relative paths. I was about to add a bit of logic to solve this issue
    when I thought that, at this stage, it would be a nice exercise for you to do
    it, so I'll leave it up to you to fix it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，脚本将无法下载它们，因为这种逻辑期望相对路径。我正准备添加一些逻辑来解决这个问题时，我想这个阶段，这对你来说将是一个很好的练习，所以我会把它留给你来修复。
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Hint: inspect the start of that `src` variable. If it starts with `''http''`,
    then it''s probably an absolute path.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：检查那个 `src` 变量的开头。如果它以 `'http'` 开头，那么它可能是一个绝对路径。
- en: I hope the body of the `_filter_images` function is interesting to you. I wanted
    to show you how to check on multiple extensions by using a mapping technique.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望 `_filter_images` 函数的主体对你来说很有趣。我想向你展示如何通过使用映射技术来检查多个扩展名。
- en: In this function, if `type_` is `'all'`, then no filtering is required, so we
    just return all the images. On the other hand, when `type_` is not `'all'`, we
    get the allowed extensions from the `ext_map` dictionary, and use it to filter
    the images in the list comprehension that ends the function body. You can see
    that by using another helper function, `_matches_extension`, I have made the list
    comprehension simpler and more readable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，如果 `type_` 是 `'all'`，则不需要过滤，所以我们只需返回所有图像。另一方面，当 `type_` 不是 `'all'` 时，我们从
    `ext_map` 字典中获取允许的扩展名，并使用它来过滤函数体末尾的列表推导式中的图像。你可以看到，通过使用另一个辅助函数 `_matches_extension`，我已经使列表推导式更简单、更易读。
- en: All `_matches_extension` does is split the name of the image getting its extension
    and checking whether it is within the list of allowed ones. Can you find one micro
    improvement (speed-wise) that could be done to this function?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`_matches_extension` 函数所做的只是将图像名称与其扩展名分开，并检查它是否在允许的列表中。你能找到对这个函数进行（从速度方面）微优化的方法吗？'
- en: I'm sure that you're wondering why I have collected all the images in the list
    and then removed them, instead of checking whether I wanted to save them before
    adding them to the list. The first reason is that I needed `_fetch_images` in
    the GUI app as it is now. A second reason is that combining, fetching, and filtering
    would produce a longer and a bit more complicated function, and I'm trying to
    keep the complexity level down. A third reason is that this could be a nice exercise
    for you to do. Feels like we're pairing here...
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我确信你一定在想，为什么我把所有图像收集到列表中然后再删除，而不是在将它们添加到列表之前检查我是否想要保存它们。第一个原因是，我需要现在的 GUI 应用程序中的
    `_fetch_images`。第二个原因是，组合、获取和过滤会产生一个更长且稍微复杂一些的函数，而我正在尝试保持复杂性水平。第三个原因是，这可能是一个很好的练习给你做。感觉我们像是在结对编程...
- en: Let's keep going through the code and inspect the `_save` function. You can
    see that, when `images` isn't empty, this basically acts as a dispatcher. We either
    call `_save_images` or `_save_json`, depending on which information is stored
    in the `format_` variable.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续查看代码，并检查 `_save` 函数。你可以看到，当 `images` 不为空时，它基本上充当一个分发器。我们根据 `format_` 变量中存储的信息，要么调用
    `_save_images`，要么调用 `_save_json`。
- en: We are almost done. Let's jump to `_save_images`. We loop on the `images` list
    and for each dictionary we find there we perform a `GET` request on the image
    URL and save its content in a file, which we name as the image itself. The one
    important thing to note here is how we save that file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了。让我们跳转到 `_save_images`。我们遍历 `images` 列表，并对每个找到的字典执行对图像 URL 的 `GET` 请求，并将内容保存到文件中，我们将其命名为图像本身。这里需要注意的一个重要问题是文件是如何保存的。
- en: We use a **context manager**, represented by the keyword `with`, to do that.
    Python's `with` statement supports the concept of a runtime context defined by
    a context manager. This is implemented using a pair of methods (`contextmanager.__enter__()`
    and `contextmanager.__exit__(exc_type, exc_val, exc_tb)`) that allow user-defined
    classes to define a runtime context that is entered before the statement body
    is executed and exited when the statement ends.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用**上下文管理器**，通过关键字`with`来执行这个操作。Python的`with`语句支持由上下文管理器定义的运行时上下文的概念。这是通过一对方法（`contextmanager.__enter__()`和`contextmanager.__exit__(exc_type,
    exc_val, exc_tb)`）实现的，允许用户定义的类定义一个在语句体执行之前进入并在语句结束时退出的运行时上下文。
- en: In our case, using a context manager, in conjunction with the open function,
    gives us the guarantee that if anything bad were to happen while writing that
    file, the resources involved in the process will be cleaned up and released properly
    regardless of the error. Have you ever tried to delete a file on Windows, only
    to be presented with an alert that tells you that you cannot delete the file because
    there is another process that is holding on to it? We're avoiding that sort of
    very annoying thing.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，使用上下文管理器，结合open函数，确保如果在写入文件时发生任何错误，涉及该过程的资源将被清理并正确释放，无论错误如何。你有没有尝试在Windows上删除一个文件，结果弹出一个警告告诉你，你不能删除该文件，因为另一个进程正在占用它？我们正在避免这种非常讨厌的事情。
- en: When we open a file, we get a handler for it and, no matter what happens, we
    want to be sure we release it when we're done with the file. A context manager
    is the tool we need to make sure of that.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打开一个文件时，我们会得到一个处理它的句柄，无论发生什么情况，我们都想确保在完成文件操作后释放它。上下文管理器是我们确保这一点的工具。
- en: 'Finally, let''s now step into the `_save_json` function. It''s very similar
    to the previous one. We basically fill in the `data` dictionary. The image name
    is the *key*, and the Base64 representation of its binary content is the *value*.
    When we''re done populating our dictionary, we use the `json` library to dump
    it in the `images.json` file. I''ll give you a small preview of that:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们现在进入`_save_json`函数。它与之前的函数非常相似。我们基本上填写`data`字典。图像名称是*键*，其二进制内容的Base64表示是*值*。当我们完成字典的填充后，我们使用`json`库将其写入`images.json`文件。我将给你一个小的预览：
- en: '`images.json (truncated)`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`images.json (截断)`'
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And that''s it! Now, before proceeding to the next section, make sure you play
    with this script and understand well how it works. Try and modify something, print
    out intermediate results, add a new argument or functionality, or scramble the
    logic. We''re going to migrate it into a GUI application now, which will add a
    layer of complexity simply because we''ll have to build the GUI interface, so
    it''s important that you''re well acquainted with the business logic: it will
    allow you to concentrate on the rest of the code.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在，在进入下一节之前，请确保你玩转这个脚本，并很好地理解它是如何工作的。尝试修改一些内容，打印出中间结果，添加新的参数或功能，或者打乱逻辑。我们现在将把它迁移到一个GUI应用程序中，这将增加一层复杂性，仅仅因为我们需要构建GUI界面，所以你熟悉业务逻辑是很重要的：这将允许你专注于代码的其他部分。
- en: Second approach – a GUI application
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二种方法——GUI应用程序
- en: There are several libraries to write GUI applications in Python. The most famous
    ones are **tkinter**, **wxPython**, **PyGTK**, and **PyQt**. They all offer a
    wide range of tools and widgets that you can use to compose a GUI application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中编写GUI应用程序有几个库。最著名的是**tkinter**、**wxPython**、**PyGTK**和**PyQt**。它们都提供了一系列的工具和控件，你可以使用它们来构建GUI应用程序。
- en: The one I'm going to use for the rest of this chapter is tkinter. **tkinter**
    stands for **Tk interface** and it is the standard Python interface to the Tk
    GUI toolkit. Both Tk and tkinter are available on most Unix platforms, Mac OS
    X, as well as on Windows systems.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本章剩余部分使用的工具是tkinter。**tkinter**代表**Tk界面**，它是Tk GUI工具包的标准Python接口。Tk和tkinter在大多数Unix平台、Mac
    OS X以及Windows系统上都是可用的。
- en: 'Let''s make sure that `tkinter` is installed properly on your system by running
    this command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行以下命令来确保`tkinter`在你的系统上安装正确：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It should open a dialog window demonstrating a simple `Tk` interface. If you
    can see that, then we're good to go. However, if it doesn't work, please search
    for `tkinter` in the Python official documentation. You will find several links
    to resources that will help you get up and running with it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该打开一个对话框，展示一个简单的`Tk`界面。如果你能看到它，那么我们就没问题了。然而，如果它不起作用，请在Python官方文档中搜索`tkinter`。你将找到几个链接到资源，这些资源将帮助你开始使用它。
- en: We're going to make a very simple GUI application that basically mimics the
    behavior of the script we saw in the first part of this chapter. We won't add
    the ability to save JPGs or PNGs singularly, but after you've gone through this
    chapter, you should be able to play with the code and put that feature back in
    by yourself.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将制作一个非常简单的GUI应用程序，它基本上模仿了我们在本章第一部分看到的脚本的行为。我们不会添加保存JPG或PNG图片的功能，但当你完成本章后，你应该能够自己玩弄代码并添加这个功能。
- en: 'So, this is what we''re aiming for:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是我们追求的目标：
- en: '![Second approach – a GUI application](img/4715_08_02.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![第二种方法 – 一个GUI应用程序](img/4715_08_02.jpg)'
- en: Gorgeous, isn't it? As you can see, it's a very simple interface (this is how
    it should look on Ubuntu). There is a frame (that is, a container) for the **URL**
    field and the **Fetch info** button, another frame for the **Listbox** to hold
    the image names and the radio button to control the way we save them, and finally
    there is a **Scrape!** button at the bottom. We also have a status bar, which
    shows us some information.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 美丽，不是吗？正如你所见，它是一个非常简单的界面（这就是它在Ubuntu上应该看起来样子）。有一个用于**URL**字段和**获取信息**按钮的框架（即容器），另一个用于**列表框**以存放图片名称和单选按钮以控制我们保存图片的方式的框架，最后在底部有一个**抓取！**按钮。我们还有一个状态栏，它显示一些信息。
- en: 'In order to get this layout, we could just place all the widgets on a root
    window, but that would make the layout logic quite messy and unnecessarily complicated.
    So, instead, we will divide the space using frames and place the widgets in those
    frames. This way we will achieve a much nicer result. So, this is the draft for
    the layout:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到这个布局，我们本可以将所有小部件都放在根窗口上，但这样会使布局逻辑变得相当混乱且不必要地复杂。因此，我们将使用框架来划分空间，并将小部件放置在这些框架中。这样我们就能得到一个更好的结果。所以，这是布局的草案：
- en: '![Second approach – a GUI application](img/4715_08_03.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![第二种方法 – 一个GUI应用程序](img/4715_08_03.jpg)'
- en: We have a **Root Window**, which is the main window of the application. We divide
    it into two rows, the first one in which we place the **Main Frame**, and the
    second one in which we place the **Status Frame** (which will hold the status
    bar). The **Main Frame** is subsequently divided into three rows itself. In the
    first one we place the **URL Frame**, which holds the **URL** widgets. In the
    second one we place the **Img Frame**, which will hold the **Listbox** and the
    **Radio Frame**, which will host a label and the radio button widgets. And finally
    a third one, which will just hold the **Scrape** button.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个**根窗口**，它是应用程序的主窗口。我们将其分为两行，第一行放置**主框架**，第二行放置**状态框架**（它将包含状态栏）。**主框架**随后本身也分为三行。在第一行中，我们放置**URL框架**，它包含**URL**小部件。在第二行中，我们放置**图片框架**，它将包含**列表框**和**单选框架**，后者将托管标签和单选按钮小部件。最后是第三行，它将仅包含**抓取**按钮。
- en: In order to lay out frames and widgets, we will use a layout manager called
    *grid*, that simply divides up the space into rows and columns, as in a matrix.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了布局框架和小部件，我们将使用一个名为*grid*的布局管理器，它简单地像矩阵一样将空间划分为行和列。
- en: 'Now, all the code I''m going to write comes from the `guiscrape.py` module,
    so I won''t repeat its name for each snippet, to save space. The module is logically
    divided into three sections, not unlike the script version: imports, layout logic,
    and business logic. We''re going to analyze them line by line, in three chunks.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将要写的所有代码都来自`guiscrape.py`模块，所以为了节省空间，我不会在每个代码片段中重复其名称。该模块逻辑上分为三个部分，与脚本版本类似：导入、布局逻辑和业务逻辑。我们将逐行分析它们，分为三个部分。
- en: The imports
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We're already familiar with most of these. The interesting bit here is those
    first two lines. The first one is quite common practice, although it is bad practice
    in Python to import using the *star syntax.* You can incur in name collisions
    and, if the module is too big, importing everything would be expensive.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了其中大部分。这里有趣的部分是前两行。第一行是一种相当常见的做法，尽管在Python中使用*星号语法*导入是坏做法。你可能会遇到名称冲突，如果模块太大，导入所有内容将会很昂贵。
- en: After that, we import `ttk`, `filedialog`, and `messagebox` explicitly, following
    the conventional approach used with this library. `ttk` is the new set of styled
    widgets. They behave basically like the old ones, but are capable of drawing themselves
    correctly according to the style your OS is set on, which is nice.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们明确地导入 `ttk`、`filedialog` 和 `messagebox`，遵循这个库中使用的传统方法。`ttk` 是一组新的样式小部件。它们的行为基本上与旧的一样，但能够根据操作系统设置的样式正确地绘制自己，这是很棒的。
- en: The rest of the imports is what we need in order to carry out the task you know
    well by now. Note that there is nothing we need to install with `pip` in this
    second part, we already have everything we need.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的导入是我们执行你现在所熟知的任务所需的。请注意，在这个第二部分中，我们不需要使用 `pip` 安装任何东西，我们已经有了一切所需。
- en: The layout logic
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局逻辑
- en: I'm going to paste it chunk by chunk so that I can explain it easily to you.
    You'll see how all those pieces we talked about in the layout draft are arranged
    and glued together. What I'm about to paste, as we did in the script before, is
    the final part of the `guiscrape.py` module. We'll leave the middle part, the
    business logic, for last.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我将分块粘贴，这样我可以更容易地向你解释。你会看到我们在布局草案中讨论的所有这些部分是如何排列和粘合在一起的。我们即将粘贴的是 `guiscrape.py`
    模块的最后一部分。我们将中间部分，即业务逻辑，留到最后。
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you know by now, we only want to execute the logic when the module is run
    directly, so that first line shouldn't surprise you.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，我们只想在模块直接运行时执行逻辑，所以第一行不应该让你感到惊讶。
- en: In the last two lines. we set up the main window, which is an instance of the
    `Tk` class. We instantiate it and give it a title. Note that I use the prepending
    underscore technique for all the names of the `tkinter` objects, in order to avoid
    potential collisions with names in the business logic. I just find it cleaner
    like this, but you're allowed to disagree.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两行中，我们设置了主窗口，它是一个 `Tk` 类的实例。我们实例化它并给它一个标题。请注意，我使用前置下划线技术为所有 `tkinter` 对象的名称，以避免与业务逻辑中的名称发生冲突。我只是觉得这样更整洁，但你可以有不同的看法。
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we set up the **Main Frame**. It's a `ttk.Frame` instance. We set `_root`
    as its parent, and give it some padding. The `padding` is a measure in pixels
    of how much space should be inserted between the inner content and the borders
    in order to let our layout breathe a little, otherwise we have the *sardine effect*,
    where widgets are packed too tightly.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了 **主框架**。它是一个 `ttk.Frame` 实例。我们将 `_root` 设置为其父对象，并给它一些填充。`填充` 是指在内部内容和边框之间插入多少像素的空间，以便让我们的布局呼吸一下，否则我们会得到
    *沙丁鱼效应*，其中小部件被紧密地打包在一起。
- en: The second line is much more interesting. We place this `_mainframe` on the
    first row (`0`) and first column (`0`) of the parent object (`_root`). We also
    say that this frame needs to extend itself in each direction by using the `sticky`
    argument with all four cardinal directions. If you're wondering where they came
    from, it's the `from tkinter import *` magic that brought them to us.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行更有趣。我们将这个 `_mainframe` 放置在父对象 `_root` 的第一行（`0`）和第一列（`0`）。我们还说这个框架需要通过使用 `sticky`
    参数向所有四个方向扩展自己。如果你想知道它们从哪里来，那就是 `from tkinter import *` 魔法将它们带到我们这里。
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, we start by placing the **URL Frame** down. This time, the parent object
    is `_mainframe`, as you will recall from our draft. This is not just a simple
    `Frame`, but it's actually a `LabelFrame`, which means we can set the text argument
    and expect a rectangle to be drawn around it, with the content of the text argument
    written in the top-left part of it (check out the previous picture if it helps).
    We position this frame at (0, 0), and say that it should expand to the left and
    to the right. We don't need the other two directions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们首先放置 **URL 框架**。这次，父对象是 `_mainframe`，正如你从我们的草案中回忆的那样。这不仅仅是一个简单的 `Frame`，而实际上是一个
    `LabelFrame`，这意味着我们可以设置文本参数，并期望围绕它绘制一个矩形，文本参数的内容将写在它的左上角（如果需要，可以查看之前的图片）。我们将这个框架放置在
    (0, 0) 位置，并说它应该向左和向右扩展。我们不需要其他两个方向。
- en: Finally, we use `rowconfigure` and `columnconfigure` to make sure it behaves
    correctly, should it need to resize. This is just a formality in our present layout.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `rowconfigure` 和 `columnconfigure` 来确保它能够正确地调整大小，如果需要的话。在我们当前的布局中，这只是一个形式。
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we have the code to lay out the URL textbox and the `_fetch` button. A
    textbox in this environment is called `Entry`. We instantiate it as usual, setting
    `_url_frame` as its parent and giving it a width. Also, and this is the most interesting
    part, we set the `textvariable` argument to be `_url`. `_url` is a `StringVar`,
    which is an object that is now connected to `Entry` and will be used to manipulate
    its content. Therefore, we don't modify the text in the `_url_entry` instance
    directly, but by accessing `_url`. In this case, we call the `set` method on it
    to set the initial value to the URL of our local web page.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有代码来布局URL文本框和`_fetch`按钮。在这个环境中，文本框被称为`Entry`。我们像往常一样实例化它，将其父级设置为`_url_frame`，并给它设置一个宽度。而且，这是最有趣的部分，我们将`textvariable`参数设置为`_url`。`_url`是一个`StringVar`对象，它现在连接到`Entry`，并将用于操作其内容。因此，我们不是直接修改`_url_entry`实例中的文本，而是通过访问`_url`来修改。在这种情况下，我们调用它的`set`方法来设置初始值为我们本地网页的URL。
- en: We position `_url_entry` at (0, 0), setting all four cardinal directions for
    it to stick to, and we also set a bit of extra padding on the left and right edges
    by using `padx`, which adds padding on the x-axis (horizontal). On the other hand,
    `pady` takes care of the vertical direction.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`_url_entry`定位在(0, 0)，使其四个正方向都粘附，并且我们还通过使用`padx`在左右边缘设置了一些额外的填充，这会在x轴（水平方向）上添加填充。另一方面，`pady`负责垂直方向。
- en: By now, you should get that every time you call the `.grid` method on an object,
    we're basically telling the grid layout manager to place that object somewhere,
    according to rules that we specify as arguments in the `grid()` call.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该明白，每次你在一个对象上调用`.grid`方法时，我们基本上是在告诉网格布局管理器根据我们在`grid()`调用中指定的参数规则将该对象放置在某个位置。
- en: Similarly, we set up and place the `_fetch` button. The only interesting parameter
    is `command=fetch_url`. This means that when we click this button, we actually
    call the `fetch_url` function. This technique is called **callback**.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们设置并放置了`_fetch`按钮。唯一有趣的参数是`command=fetch_url`。这意味着当我们点击这个按钮时，我们实际上调用的是`fetch_url`函数。这种技术被称为**回调**。
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is what we called **Img Frame** in the layout draft. It is placed on the
    second row of its parent `_mainframe`. It will hold the `Listbox` and the **Radio
    Frame**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们所说的**Img Frame**在布局草案中的样子。它放置在其父级`_mainframe`的第二行。它将包含`Listbox`和**Radio
    Frame**。
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is probably the most interesting bit of the whole layout logic. As we did
    with the `_url_entry`, we need to drive the contents of `Listbox` by tying it
    to a variable `_images`. We set up `Listbox` so that `_img_frame` is its parent,
    and `_images` is the variable it's tied to. We also pass some dimensions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是整个布局逻辑中最有趣的部分。正如我们处理`_url_entry`一样，我们需要通过将其绑定到变量`_images`来驱动`Listbox`的内容。我们设置了`Listbox`，使其父级为`_img_frame`，并绑定到变量`_images`。我们还传递了一些尺寸。
- en: The interesting bit comes from the `_scrollbar` instance. Note that, when we
    instantiate it, we set its command to `_img_listbox.yview`. This is the first
    half of the contract between a `Listbox` and a `Scrollbar`. The other half is
    provided by the `_img_listbox.configure` method, which sets the `yscrollcommand=_scrollbar.set`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的部分来自于`_scrollbar`实例。请注意，当我们实例化它时，我们将其命令设置为`_img_listbox.yview`。这是`Listbox`和`Scrollbar`之间合同的第一部分。另一部分是由`_img_listbox.configure`方法提供的，它设置了`yscrollcommand=_scrollbar.set`。
- en: By providing this reciprocal bond, when we scroll on `Listbox`, the `Scrollbar`
    will move accordingly and vice-versa, when we operate the `Scrollbar`, the Listbox
    will scroll accordingly.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供这种相互关联的绑定，当我们滚动`Listbox`时，`Scrollbar`会相应地移动，反之亦然，当我们操作`Scrollbar`时，`Listbox`会相应地滚动。
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We place the **Radio Frame**, ready to be populated. Note that the `Listbox`
    is occupying (0, 0) on `_img_frame`, the `Scrollbar` (0, 1) and therefore `_radio_frame`
    will go in (0, 2).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放置**Radio Frame**，准备填充。请注意，`Listbox`占据了`_img_frame`上的(0, 0)，`Scrollbar`在(0,
    1)，因此`_radio_frame`将放在(0, 2)。
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Firstly, we place the label, and we give it some padding. Note that the label
    and radio buttons are children of `_radio_frame`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们放置标签，并给它一些填充。请注意，标签和单选按钮是`_radio_frame`的子项。
- en: As for the `Entry` and `Listbox` objects, the `Radiobutton` is also driven by
    a bond to an external variable, which I called `_save_method`. Each `Radiobutton`
    instance sets a value argument, and by checking the value on `_save_method`, we
    know which button is selected.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 至于`Entry`和`Listbox`对象，`Radiobutton`也是通过一个与外部变量`_save_method`的绑定来驱动的。每个`Radiobutton`实例设置一个值参数，通过检查`_save_method`上的值，我们知道哪个按钮被选中。
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: On the third row of `_mainframe` we place the **Scrape** button. Its `command`
    is `save`, which saves the images to be listed in `Listbox`, after we have successfully
    parsed a web page.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在`_mainframe`的第三行，我们放置了**Scrape**按钮。它的`command`是`save`，在我们成功解析网页后，它将保存要列在`Listbox`中的图片。
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We end the layout section by placing down the status frame, which is a simple
    `ttk.Frame`. To give it a little status bar effect, we set its `relief` property
    to `'sunken'` and give it a uniform padding of 2 pixels. It needs to stick to
    the `_root` window left, right and bottom parts, so we set its `sticky` attribute
    to `(E, W, S)`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过放置一个简单的`ttk.Frame`来结束布局部分，这个`ttk.Frame`就是状态框架。为了给它一点状态栏的效果，我们将它的`relief`属性设置为`'sunken'`，并给它2像素的均匀填充。它需要粘附在`_root`窗口的左、右和底部部分，因此我们将它的`sticky`属性设置为`(E,
    W, S)`。
- en: We then place a label in it and, this time, we tie it to a `StringVar` object,
    because we will have to modify it every time we want to update the status bar
    text. You should be acquainted to this technique by now.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在其中放置一个标签，这次我们将其与一个`StringVar`对象关联起来，因为我们每次想要更新状态栏文本时都需要修改它。你现在应该已经熟悉这种技术了。
- en: Finally, on the last line, we run the application by calling the `mainloop`
    method on the `Tk` instance.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在最后一行，我们通过在`Tk`实例上调用`mainloop`方法来运行应用程序。
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Please remember that all these instructions are placed under the `if __name__
    == "__main__":` clause in the original script.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，所有这些说明都放在原始脚本中的`if __name__ == "__main__":`子句下。
- en: As you can see, the code to design our GUI application is not hard. Granted,
    at the beginning you have to play around a little bit. Not everything will work
    out perfectly at the first attempt, but I promise you it's very easy and you can
    find plenty of tutorials on the web. Let's now get to the interesting bit, the
    business logic.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，设计我们的GUI应用程序的代码并不难。当然，一开始你可能需要稍微尝试一下。并不是所有的事情都会在第一次尝试时就完美无缺，但我向你保证这非常简单，你可以在网上找到很多教程。现在让我们进入有趣的环节，业务逻辑。
- en: The business logic
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 业务逻辑
- en: We'll analyze the business logic of the GUI application in three chunks. There
    is the fetching logic, the saving logic, and the alerting logic.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分三部分分析GUI应用程序的业务逻辑。这里有获取逻辑、保存逻辑和警报逻辑。
- en: Fetching the web page
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取网页
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: First of all, let me explain that `config` dictionary. We need some way of passing
    data between the GUI application and the business logic. Now, instead of polluting
    the global namespace with many different variables, my personal preference is
    to have a single dictionary that holds all the objects we need to pass back and
    forth, so that the global namespace isn't be clogged up with all those names,
    and we have one single, clean, easy way of knowing where all the objects that
    are needed by our application are.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我解释一下这个`config`字典。我们需要一种方法在GUI应用程序和业务逻辑之间传递数据。现在，而不是用许多不同的变量污染全局命名空间，我个人的偏好是有一个单一的字典，它包含我们需要的所有需要传递和接收的对象，这样全局命名空间就不会被所有这些名称堵塞，我们有一个单一、干净、简单的方法知道所有我们应用程序需要用到的对象在哪里。
- en: In this simple example, we'll just populate the `config` dictionary with the
    images we fetch from the page, but I wanted to show you the technique so that
    you have at least an example. This technique comes from my experience with JavaScript.
    When you code a web page, you very often import several different libraries. If
    each of these cluttered the global namespace with all sorts of variables, there
    would be severe issues in making everything work, because of name clashes and
    variable overriding. They make the coder's life a living hell.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，我们只是用我们从页面获取的图片填充`config`字典，但我想要展示这个技术，这样你至少有一个例子。这个技术来源于我的JavaScript经验。当你编写一个网页时，你经常导入几个不同的库。如果每个库都把各种变量弄乱全局命名空间，那么由于名称冲突和变量覆盖，将会有严重的问题，因为所有的事情都无法正常工作。它们让程序员的生活变得非常痛苦。
- en: So, it's much better to try and leave the global namespace as clean as we can.
    In this case, I find that using one `config` variable is more than acceptable.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好尝试并尽可能保持全局命名空间尽可能干净。在这种情况下，我发现使用一个`config`变量是完全可以接受的。
- en: The `fetch_url` function is quite similar to what we did in the script. Firstly,
    we get the `url` value by calling `_url.get()`. Remember that the `_url` object
    is a `StringVar` instance that is tied to the `_url_entry` object, which is an
    `Entry`. The text field you see on the GUI is the `Entry`, but the text behind
    the scenes is the value of the `StringVar` object.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch_url`函数与我们在脚本中做的非常相似。首先，我们通过调用`_url.get()`获取`url`值。记住，`_url`对象是一个与`_url_entry`对象（一个`Entry`）相关联的`StringVar`实例。你看到的GUI中的文本字段是`Entry`，但幕后是`StringVar`对象的值。'
- en: By calling `get()` on `_url`, we get the value of the text which is displayed
    in `_url_entry`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`_url`上调用`get()`，我们获取显示在`_url_entry`中的文本值。
- en: The next step is to prepare `config['images']` to be an empty list, and to empty
    the `_images` variable, which is tied to `_img_listbox`. This, of course, has
    the effect of cleaning up all the items in `_img_listbox`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将`config['images']`准备为一个空列表，并清空`_images`变量，该变量与`_img_listbox`相关联。当然，这会清除`_img_listbox`中的所有项目。
- en: After this preparation step, we can try to fetch the page, using the same `try/except`
    logic we adopted in the script at the beginning of the chapter.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个准备步骤之后，我们可以尝试使用我们在本章开头脚本中采用的相同`try/except`逻辑来获取页面。
- en: 'The one difference is in the action we take if things go wrong. We call `_sb(str(rex))`.
    `_sb` is a helper function whose code we''ll see shortly. Basically, it sets the
    text in the status bar for us. Not a good name, right? I had to explain its behavior
    to you: food for thought.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的不同之处在于，如果出现问题，我们调用`_sb(str(rex))`。`_sb`是一个辅助函数，我们很快就会看到它的代码。基本上，它为我们设置状态栏的文本。名字不太好，对吧？我不得不向你解释它的行为：供你思考。
- en: If we can fetch the page, then we create the `soup` instance, and fetch the
    images from it. The logic of `fetch_images` is exactly the same as the one explained
    before, so I won't repeat myself here.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以获取页面，那么我们创建`soup`实例，并从中获取图片。`fetch_images`的逻辑与之前解释的完全相同，所以这里不再重复。
- en: If we have images, using a quick tuple comprehension (which is actually a generator
    expression fed to a tuple constructor) we feed the `_images` `StringVar` and this
    has the effect of populating our `_img_listbox` with all the image names. Finally,
    we update the status bar.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有图片，使用一个快速的元组推导（实际上是一个传递给元组构造函数的生成器表达式）我们向`_images` `StringVar`提供数据，这会将所有图片名称填充到我们的`_img_listbox`中。最后，我们更新状态栏。
- en: If there were no images, we still update the status bar, and at the end of the
    function, regardless of how many images were found, we update `config['images']`
    to hold the `images` list. In this way, we'll be able to access the images from
    other functions by inspecting `config['images']` without having to pass that list
    around.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有图片，我们仍然更新状态栏，并且在函数的末尾，无论找到多少图片，我们都更新`config['images']`以持有图片列表。这样，我们可以通过检查`config['images']`来访问其他函数中的图片，而无需传递该列表。
- en: Saving the images
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存图片
- en: 'The logic to save the images is pretty straightforward. Here it is:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 保存图片的逻辑非常直接。如下所示：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When the user clicks the **Scrape** button, the `save` function is called using
    the callback mechanism.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**抓取**按钮时，使用回调机制调用`save`函数。
- en: The first thing that this function does is check whether there are actually
    any images to be saved. If not, it alerts the user about it, using another helper
    function, `_alert`, whose code we'll see shortly. No further action is performed
    if there are no images.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数首先检查是否真的有要保存的图片。如果没有，它使用另一个辅助函数`_alert`提醒用户，我们很快就会看到这个函数的代码。如果没有图片，则不执行任何进一步的操作。
- en: On the other hand, if the `config['images']` list is not empty, `save` acts
    as a dispatcher, and it calls `_save_images` or `_save_json`, according to which
    value is held by `_same_method`. Remember, this variable is tied to the radio
    buttons, therefore we expect its value to be either `'img'` or `'json'`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果`config['images']`列表不为空，`save`作为调度器，根据`_same_method`持有的值调用`_save_images`或`_save_json`。记住，这个变量与单选按钮相关联，因此我们期望它的值是`'img'`或`'json'`。
- en: This dispatcher is a bit different from the one in the script. According to
    which method we have selected, a different action must be taken.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调度器与脚本中的调度器略有不同。根据我们选择的方法，必须采取不同的操作。
- en: If we want to save the images as images, we need to ask the user to choose a
    directory. We do this by calling `filedialog.askdirectory` and assigning the result
    of the call to the variable `dirname`. This opens up a nice dialog window that
    asks us to choose a directory. The directory we choose must exist, as specified
    by the way we call the method. This is done so that we don't have to write code
    to deal with a potentially missing directory when saving the files.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将图片保存为图片，我们需要让用户选择一个目录。我们通过调用`filedialog.askdirectory`并分配调用结果到变量`dirname`来实现这一点。这打开了一个漂亮的对话框，要求我们选择一个目录。我们选择的目录必须存在，因为我们调用方法的方式指定了这一点。这样做是为了我们不必编写处理保存文件时可能缺失目录的代码。
- en: 'Here''s how this dialog should look on Ubuntu:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是在Ubuntu上这个对话框应该看起来是怎样的：
- en: '![Saving the images](img/4715_08_04.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![保存图片](img/4715_08_04.jpg)'
- en: If we cancel the operation, `dirname` will be set to `None`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们取消操作，`dirname`将被设置为`None`。
- en: Before finishing analyzing the logic in `save`, let's quickly go through `_save_images`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成`save`中的逻辑分析之前，让我们快速浏览一下`_save_images`。
- en: It's very similar to the version we had in the script so just note that, at
    the beginning, in order to be sure that we actually have something to do, we check
    on both `dirname` and the presence of at least one image in `config['images']`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 它与脚本中的版本非常相似，只需注意，在开始时，为了确保我们确实有事情要做，我们检查了`dirname`和`config['images']`中至少有一个图片的存在。
- en: If that's the case, it means we have at least one image to save and the path
    for it, so we can proceed. The logic to save the images has already been explained.
    The one thing we do differently this time is to join the directory (which means
    the complete path) to the image name, by means of `os.path.join`. In the `os.path`
    module there's plenty of useful methods to work with paths and filenames.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，这意味着我们至少有一个图片需要保存及其路径，因此我们可以继续。保存图片的逻辑已经解释过了。这次我们唯一不同的地方是使用`os.path.join`将目录（即完整路径）与图片名称连接起来。在`os.path`模块中有很多有用的方法可以用来处理路径和文件名。
- en: At the end of `_save_images`, if we saved at least one image, we alert the user
    that we're done.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在`_save_images`的末尾，如果我们至少保存了一个图片，我们将通知用户我们已经完成了。
- en: 'Let''s go back now to the other branch in `save`. This branch is executed when
    the user selects the **As JSON** radio button before pressing the **Scrape** button.
    In this case, we want to save a file; therefore, we cannot just ask for a directory.
    We want to give the user the ability to choose a filename as well. Hence, we fire
    up a different dialog: `filedialog.asksaveasfilename`.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到`save`函数中的另一个分支。当用户在按下**Scrape**按钮之前选择**As JSON**单选按钮时，这个分支会被执行。在这种情况下，我们想要保存一个文件；因此，我们不仅需要请求一个目录。我们希望用户能够选择一个文件名。因此，我们启动了一个不同的对话框：`filedialog.asksaveasfilename`。
- en: We pass an initial filename, which is proposed to the user with the ability
    to change it if they don't like it. Moreover, because we're saving a JSON file,
    we're forcing the user to use the correct extension by passing the `filetypes`
    argument. It is a list with any number of 2-tuples *(description, extension)*
    that runs the logic of the dialog.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递一个初始文件名，这个文件名被建议给用户，如果他们不喜欢，可以更改它。此外，因为我们正在保存JSON文件，所以我们通过传递`filetypes`参数强制用户使用正确的扩展名。它是一个包含任意数量2元组的列表*(描述，扩展名)*，该列表运行对话框的逻辑。
- en: 'Here''s how this dialog should look on Ubuntu:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是在Ubuntu上这个对话框应该看起来是怎样的：
- en: '![Saving the images](img/4715_08_05.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![保存图片](img/4715_08_05.jpg)'
- en: Once we have chosen a place and a filename, we can proceed with the saving logic,
    which is the same as it was in the previous script. We create a JSON object from
    a Python dictionary (`data`) that we populate with key/value pairs made by the
    `images` name and Base64 encoded content.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们选择了位置和文件名，我们就可以继续保存逻辑，这与之前的脚本中的逻辑相同。我们从一个Python字典(`data`)创建一个JSON对象，并用`images`的名称和Base64编码的内容创建键/值对。
- en: In `_save_json` as well, we have a little check at the beginning that makes
    sure that we don't proceed unless we have a file name and at least one image to
    save.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在`_save_json`中，我们也在开始时进行了一个小检查，确保我们只有在有文件名和至少一个要保存的图片时才继续。
- en: This ensures that if the user presses the **Cancel** button, nothing bad happens.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了如果用户按下**取消**按钮，不会发生任何坏事。
- en: Alerting the user
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通知用户
- en: Finally, let's see the alerting logic. It's extremely simple.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看通知逻辑。它非常简单。
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That's it! To change the status bar message all we need to do is to access `_status_msg`
    `StringVar`, as it's tied to the `_status` label.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！要更改状态栏消息，我们只需要访问 `_status_msg` `StringVar`，因为它与 `_status` 标签相关联。
- en: 'On the other hand, if we want to show the user a more visible message, we can
    fire up a message box. Here''s how it should look on Ubuntu:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们想向用户显示一个更明显的消息，我们可以弹出一个消息框。以下是在 Ubuntu 上的样子：
- en: '![Alerting the user](img/4715_08_06.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![提醒用户](img/4715_08_06.jpg)'
- en: The `messagebox` object can also be used to warn the user (`messagebox.showwarning`)
    or to signal an error (`messagebox.showerror`). But it can also be used to provide
    dialogs that ask us if we're sure that we want to proceed or if we really want
    to delete that file, and so on.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`messagebox` 对象还可以用来警告用户（`messagebox.showwarning`）或表示错误（`messagebox.showerror`）。但它也可以用来提供对话框，询问我们是否确实想要继续，或者是否真的想要删除那个文件，等等。'
- en: If you inspect `messagebox` by simply printing out what `dir(messagebox)` returns,
    you'll find methods like `askokcancel`, `askquestion`, `askretrycancel`, `askyesno`,
    and `askyesnocancel`, as well as a set of constants to verify the response of
    the user, such as `CANCEL`, `NO`, `OK`, `OKCANCEL`, `YES`, `YESNOCANCEL`, and
    so on. You can compare these to the user's choice so that you know what the next
    action to execute when the dialog closes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过简单地打印出 `dir(messagebox)` 返回的内容来检查 `messagebox`，你会找到像 `askokcancel`、`askquestion`、`askretrycancel`、`askyesno`
    和 `askyesnocancel` 这样的方法，以及一组用于验证用户响应的常量，如 `CANCEL`、`NO`、`OK`、`OKCANCEL`、`YES`、`YESNOCANCEL`
    等。你可以将这些与用户的选项进行比较，以便你知道在对话框关闭时执行的下一步操作。
- en: How to improve the application?
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何改进应用程序？
- en: Now that you're accustomed to the fundamentals of designing a GUI application,
    I'd like to give you some suggestions on how to make ours better.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经习惯了设计GUI应用程序的基础知识，我想给你一些建议，让你 ours 更好。
- en: We can start from the code quality. Do you think this code is good enough, or
    would you improve it? If so, how? I would test it, and make sure it's robust and
    caters for all the various scenarios that a user might create by clicking around
    on the application. I would also make sure the behavior is what I would expect
    when the website we're scraping is down for any reason.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从代码质量开始。你认为这段代码足够好吗，或者你会改进它？如果是的话，你会怎么做？我会测试它，并确保它是健壮的，能够应对用户可能通过在应用程序中点击创建的所有各种场景。我还会确保当我们要抓取的网站因任何原因关闭时，行为是我预期的。
- en: Another thing that we could improve is the naming. I have prudently named all
    the components with a leading underscore, both to highlight their somewhat "private"
    nature, and to avoid having name clashes with the underlying objects they are
    linked to. But in retrospect, many of those components could use a better name,
    so it's really up to you to refactor until you find the form that suits you best.
    You could start by giving a better name to the `_sb` function!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以改进的一点是命名。我谨慎地用前导下划线命名了所有组件，既是为了突出它们的某种“私有”性质，也是为了避免与它们所链接的底层对象发生名称冲突。但回顾起来，许多这些组件可能需要一个更好的名称，所以这完全取决于你，直到你找到最适合你的形式。你可以从给
    `_sb` 函数起一个更好的名字开始！
- en: For what concerns the user interface, you could try and resize the main application.
    See what happens? The whole content stays exactly where it is. Empty space is
    added if you expand, or the whole widgets set disappears gradually if you shrink.
    This behavior isn't exactly nice, therefore one quick solution could be to make
    the root window fixed (that is, unable to resize).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 关于用户界面，你可以尝试调整主应用程序的大小。看看会发生什么？整个内容都保持在原地。如果你扩展，会添加空空间；如果你缩小，整个小部件集会逐渐消失。这种行为并不完美，因此一个快速的解决方案可能是使根窗口固定（即无法调整大小）。
- en: 'Another thing that you could do to improve the application is to add the same
    functionality we had in the script, to save only PNGs or JPGs. In order to do
    this, you could place a combo box somewhere, with three values: All, PNGs, JPGs,
    or something similar. The user should be able to select one of those options before
    saving the files.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过添加我们在脚本中已有的相同功能来改进应用程序，即只保存 PNG 或 JPG 文件。为了做到这一点，你可以在某个地方放置一个组合框，有三个值：所有、PNGs、JPGs
    或类似的内容。在保存文件之前，用户应该能够选择这些选项之一。
- en: Even better, you could change the declaration of `Listbox` so that it's possible
    to select multiple images at the same time, and only the selected ones will be
    saved. If you manage to do this (it's not as hard as it seems, believe me), then
    you should consider presenting the `Listbox` a bit better, maybe providing alternating
    background colors for the rows.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，你可以更改 `Listbox` 的声明，使其能够同时选择多个图像，并且只有选中的图像将被保存。如果你能完成这个任务（它并不像看起来那么难，相信我），那么你应该考虑更好地展示
    `Listbox`，也许为行提供交替的背景颜色。
- en: 'Another nice thing you could add is a button that opens up a dialog to select
    a file. The file must be one of the JSON files the application can produce. Once
    selected, you could run some logic to reconstruct the images from their Base64-encoded
    version. The logic to do this is very simple, so here''s an example:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以添加一个按钮，打开一个对话框来选择文件。该文件必须是应用程序可以生成的 JSON 文件之一。一旦选择，你可以运行一些逻辑来从其 Base64 编码版本中重建图像。执行此操作的逻辑非常简单，所以这里有一个例子：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, we need to open `images.json` in read mode, and grab the `data`
    dictionary. Once we have it, we can loop through its items, and save each image
    with the Base64 decoded content. I'll leave it up to you to tie this logic to
    a button in the application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们需要以读取模式打开 `images.json` 文件，并获取 `data` 字典。一旦我们有了它，我们就可以遍历其项，并将每个图像保存为
    Base64 解码的内容。我将把这个逻辑连接到应用程序中的按钮上留给你来做。
- en: Another cool feature that you could add is the ability to open up a preview
    pane that shows any image you select from the `Listbox`, so that the user can
    take a peek at the images before deciding to save them.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以添加一个酷炫的功能，那就是打开一个预览窗格，显示从 `Listbox` 中选择的任何图像，这样用户在决定保存之前可以查看图像。
- en: Finally, one last suggestion for this application is to add a menu. Maybe even
    a simple menu with **File** and **?** to provide the usual **Help** or **About**.
    Just for fun. Adding menus is not that complicated; you can add text, keyboard
    shortcuts, images, and so on.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于这个应用程序，我还有一个建议，那就是添加一个菜单。也许甚至是一个简单的菜单，包含 **文件** 和 **?**，以提供通常的 **帮助** 或
    **关于**。只是为了好玩。添加菜单并不复杂；你可以添加文本、键盘快捷键、图像等。
- en: Where do we go from here?
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们接下来该做什么？
- en: If you are interested in digging deeper into the world of GUIs, then I'd like
    to offer you the following suggestions.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣，想要更深入地挖掘 GUI 世界，那么我想给你以下建议。
- en: The tkinter.tix module
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: tkinter.tix 模块
- en: Exploring `tkinter` and its themed widget set, `tkinter.ttk`, will take you
    some time. There's much to learn and play with. Another interesting module to
    explore, when you'll be familiar with this technology, is `tkinter.tix`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 探索 `tkinter` 及其主题小部件集 `tkinter.ttk` 将需要一些时间。有很多东西可以学习和玩耍。当你熟悉这项技术时，另一个有趣的模块是
    `tkinter.tix`。
- en: The `tkinter.tix` (**Tk Interface Extension**) module provides an additional
    very rich set of widgets. The need for them stems from the fact that the widgets
    in the standard `Tk` library are far from complete.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`tkinter.tix` （**Tk 接口扩展**）模块提供了一组非常丰富的额外小部件。它们的需求源于标准 `Tk` 库中的小部件远非完整。'
- en: The `tkinter.tix` library allows us to solve this problem by providing widgets
    like HList, ComboBox, Control (or SpinBox), and various scrollable widgets. Altogether,
    there are more than 40 widgets. They allow you to introduce different interaction
    techniques and paradigms into your applications, thus improving their quality
    and usability.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`tkinter.tix` 库允许我们通过提供 HList、ComboBox、Control（或 SpinBox）以及各种可滚动小部件等小部件来解决此问题。总共有超过
    40 个小部件。它们允许你将不同的交互技术和范例引入你的应用程序中，从而提高其质量和可用性。'
- en: The turtle module
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 海龟模块
- en: The `turtle` module is an extended reimplementation of the eponymous module
    from the Python standard distribution up to version Python 2.5\. It's a very popular
    way to introduce children to programming.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`turtle` 模块是对 Python 标准分布中同名模块的扩展实现，直到 Python 2.5 版本。它是一种非常流行的向儿童介绍编程的方式。'
- en: It's based on the idea of an imaginary turtle starting at (0, 0) in the Cartesian
    plane. You can programmatically command the turtle to move forward and backwards,
    rotate, and so on. and by combining together all the possible moves, all sorts
    of intricate shapes and images can be drawn.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 它基于一个想象中的海龟在笛卡尔平面上从 (0, 0) 点开始的概念。你可以通过编程命令海龟前进和后退，旋转等。通过组合所有可能的移动，可以绘制出各种复杂的形状和图像。
- en: It's definitely worth checking out, if only to see something different.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 它绝对值得一看，只是为了看看一些不同的东西。
- en: wxPython, PyQt, and PyGTK
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: wxPython、PyQt 和 PyGTK
- en: 'After you have explored the vastness of the `tkinter` realm, I''d suggest you
    to explore other GUI libraries: **wxPython**, **PyQt**, and **PyGTK**. You may
    find out one of these works better for you, or it makes easier for you to code
    the application you need.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在你已经探索了`tkinter`领域的广阔天地之后，我建议你探索其他的GUI库：**wxPython**、**PyQt**和**PyGTK**。你可能会发现其中之一更适合你，或者它会使你编写所需的应用程序变得更加容易。
- en: I believe that coders can realize their ideas only when they are conscious about
    what tools they have available. If your toolset is too narrow, your ideas may
    seem impossible or extremely hard to realize, and they risk remaining exactly
    what they are, just ideas.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为，只有当程序员意识到他们有哪些可用的工具时，他们才能实现他们的想法。如果你的工具集太窄，你的想法可能看起来不可能实现，或者极其难以实现，它们的风险就是保持原样，仅仅是想法。
- en: Of course, the technological spectrum today is humongous, so knowing everything
    is not possible; therefore, when you are about to learn a new technology or a
    new subject, my suggestion is to grow your knowledge by exploring breadth first.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，今天的科技领域非常庞大，因此不可能知道一切；因此，当你即将学习一项新技术或新主题时，我的建议是通过广泛探索来增长你的知识。
- en: Investigate several things not too deeply, and then go deep with the one or
    the few that looked most promising. This way you'll be able to be productive with
    at least one tool, and when the tool no longer fits your needs, you'll know where
    to dig deeper, thanks to your previous exploration.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对几件事情进行不太深入的调查研究，然后对看起来最有希望的一个或几个进行深入研究。这样你将能够至少使用一个工具来提高生产力，当这个工具不再满足你的需求时，你将知道在哪里进行更深入的挖掘，这要归功于你之前的探索。
- en: The principle of least astonishment
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小惊讶原则
- en: When designing an interface, there are many different things to bear in mind.
    One of them, which for me is the most important, is the law or **principle of
    least astonishment**. It basically states that if in your design a necessary feature
    has a high astonishing factor, it may be necessary to redesign your application.
    To give you one example, when you're used to working with Windows, where the buttons
    to minimize, maximize and close a window are on the top-right corner, it's quite
    hard to work on Linux, where they are at the top-left corner. You'll find yourself
    constantly going to the top-right corner only to discover once more that the buttons
    are on the other side.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计界面时，有许多不同的事情需要考虑。其中之一，对我来说是最重要的，就是“最小惊讶原则”。它基本上表明，如果你的设计中一个必要的功能具有很高的惊讶因素，那么可能需要重新设计你的应用程序。举一个例子，当你习惯于在Windows上工作，其中最小化、最大化窗口和关闭窗口的按钮位于右上角时，在Linux上工作会相当困难，因为它们位于左上角。你会发现你不断地走向右上角，只是为了再次发现按钮在另一边。
- en: If a certain button has become so important in applications that it's now placed
    in a precise location by designers, please don't innovate. Just follow the convention.
    Users will only become frustrated when they have to waste time looking for a button
    that is not where it's supposed to be.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个按钮在应用程序中变得如此重要，以至于设计师将其放置在精确的位置，请不要创新。只需遵循惯例。当用户不得不浪费时间寻找本应存在的按钮时，他们只会感到沮丧。
- en: The disregard for this rule is the reason why I cannot work with products like
    Jira. It takes me minutes to do simple things that should require seconds.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 忽视这条规则是为什么我无法使用像Jira这样的产品的原因。做一些简单的事情需要我花费几分钟，而这些事情本应只需要几秒钟。
- en: Threading considerations
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程考虑事项
- en: This topic is beyond the scope of an introductory book like this, but I do want
    to mention it. In a nutshell, a **thread** of execution is the smallest sequence
    of programmed instructions that can be managed independently by a **scheduler**.
    The reason we have the perception that modern computers can do many things at
    the same time is not only due to the fact that they have multiple processors.
    They also subdivide the work in different threads, which are then worked on in
    sequence. If their lifecycle is sufficiently short, threads can be worked on in
    one single go, but typically, what happens is that the OS works on a thread for
    a little time, then switches to another one, then to another one, then back to
    the first one, and so on. The order in which they are worked on depends on different
    factors. The end result is that, because computers are extremely fast in doing
    this switching, we perceive many things happening at the same time.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主题超出了这样一本入门书的范围，但我确实想提一下。简单来说，**执行线程**是能够被**调度器**独立管理的最小程序指令序列。我们之所以有现代计算机可以同时做很多事情的感知，不仅仅是因为它们有多个处理器。它们还将工作细分到不同的线程中，然后按顺序处理这些线程。如果它们的生命周期足够短，线程可以一次性处理，但通常情况下，操作系统会先在一个线程上工作一段时间，然后切换到另一个线程，然后又切换到另一个线程，然后回到第一个线程，如此循环。它们被处理的顺序取决于不同的因素。最终结果是，因为计算机在切换上的速度非常快，所以我们感知到许多事情同时发生。
- en: If you are coding a GUI application that needs to perform a long running operation
    when a button is clicked, you will see that your application will probably freeze
    until the operation has been carried out. In order to avoid this, and maintain
    the application's responsiveness, you may need to run that time-expensive operation
    in a different thread so that the OS will be able to dedicate a little bit of
    time to the GUI every now and then, to keep it responsive.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写一个当按钮被点击时需要执行长时间运行操作的GUI应用程序，你会发现你的应用程序可能会在操作执行完毕之前冻结。为了避免这种情况，并保持应用程序的响应性，你可能需要在不同的线程中运行这个耗时操作，这样操作系统就可以时不时地为GUI分配一点时间，以保持其响应性。
- en: Threads are an advanced topic, especially in Python. Gain a good grasp of the
    fundamentals first, and then have fun exploring them!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是一个高级话题，尤其是在Python中。首先掌握基础知识，然后尽情探索它们吧！
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we worked on a project together. We have written a script that
    scrapes a very simple web page and accepts optional commands that alter its behavior
    in doing so. We also coded a GUI application to do the same thing by clicking
    buttons instead of typing on a console. I hope you enjoyed reading it and following
    along as much as I enjoyed writing it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们一起完成了一个项目。我们编写了一个脚本，它可以抓取一个非常简单的网页，并接受可选的命令来改变其行为。我们还编写了一个GUI应用程序，通过点击按钮而不是在控制台输入来执行相同的功能。我希望你阅读它并跟随我的思路，就像我写作时一样享受。
- en: We saw many different concepts like context managers, working with files, performing
    HTTP requests, and we've talked about guidelines for usability and design.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了许多不同的概念，如上下文管理器、文件操作、执行HTTP请求，我们还讨论了可用性和设计的指导原则。
- en: I have only been able to scratch the surface, but hopefully, you have a good
    starting point from which to expand your exploration.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我只能触及表面，但希望你能从中获得一个良好的起点，以便进一步拓展你的探索。
- en: Throughout the chapter, I have pointed you in several different ways on how
    to improve the application, and I have challenged you with a few exercises and
    questions. I hope you have taken the time to play with those ideas. One can learn
    a lot just by playing around with fun applications like the one we've coded together.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我以几种不同的方式指导你如何改进应用程序，并挑战你完成一些练习和问题。我希望你已经花时间尝试了那些想法。仅仅通过玩一些有趣的应用程序，比如我们一起编写的应用程序，就能学到很多东西。
- en: In the next chapter, we're going to talk about data science, or at least about
    the tools that a Python programmer has when it comes to facing this subject.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论数据科学，或者至少是当Python程序员面对这个主题时所拥有的工具。
