<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-113"><a id="_idTextAnchor114"/>7</h1>
<h1 id="_idParaDest-114"><a id="_idTextAnchor115"/>Technical Analysis and Its Implementation in Python</h1>
<p>In the previous chapter, we considered fundamental factors and saw how they may impact market prices. We noted that, although such an impact may be significant and potentially quite lucrative for trading, most of the time, it’s difficult to suggest a quantitative model that could generate unambiguous trading rules (when to enter the market, to which direction, and when to exit it) that wouldn’t require human discretion. For clarity’s sake, let’s note that there exist various fully quantitative approaches to evaluating fundamental factors, even political ones, but they are based on complex cross-discipline subjects, such as semantic analysis, and thus require solid knowledge of respective sciences. Is it possible to avoid this complexity and find a method to analyze market behavior using only price data? Or, maybe, some additional data, but only in numeric form?</p>
<p>The answer is yes, and this kind of market analysis is called <strong class="bold">technical analysis</strong>. In this chapter, we will consider its premises, learn about the most common technical indicators, and discover how they may be used to quantitatively describe various processes that go on in the market. We will also consider the implementations of key technical indicators in Python and introduce the concept of the sliding window, which will be used throughout all future codes.</p>
<p>In this chapter, you will learn about the following topics:</p>
<ul>
<li>Technical analysis – ideal for computing, but missing real market processes</li>
<li>Momentum and RSI as indicators to measure the velocity of the market</li>
<li>Digital filters and moving averages</li>
<li>Range indicators</li>
<li>Volatility indicators</li>
<li>Implementation of technical indicators in Python</li>
</ul>
<h1 id="_idParaDest-115"><a id="_idTextAnchor116"/>Technical analysis – ideal for computing, but missing real market processes</h1>
<p>The main idea that<a id="_idIndexMarker372"/> lies in the foundation of <strong class="bold">technical analysis</strong>, or <strong class="bold">TA</strong> for short, is that <em class="italic">price includes everything in itself</em>. From this standpoint, if we see a price movement up or down, large or small, we don’t really want to know the reason behind this movement; instead, we just acknowledge that it was caused by some fundamental factors and try to focus on the future price development in regard to the observed price movement only.</p>
<p>Of course, TA can analyze a <em class="italic">series</em> of data and not just a single data point. In this regard, TA studies help in identifying <em class="italic">patterns</em> or repeating sequences in price time series that bear resemblance to each other. TA suggests that if we observe a pattern that we already saw in the past, then the following price development will also be similar to what happened in the past; therefore, we can be prepared and exploit it.</p>
<p>With TA, we don’t want and don’t need to know the actual fundamental factors that affected the price, we are only looking for <em class="italic">footprints</em> of something that happened behind the scenes and will then take action depending on the form of these footprints.</p>
<p>Now that we understand the difference in the foundations of fundamental and technical analyses, let’s see how this difference impacts the two main practical points of any market analysis: its time horizon and precision.</p>
<p>Fundamental analysis focuses on macroeconomic factors, which are always longer term by nature, so the time horizon for fundamental forecasts is normally days and above, up to years. On the contrary, technical studies may analyze extremely short-living processes (for example, momentary imbalances in the order book), and therefore, it’s normal that technical studies may have a forecast horizon of 1 second, 1 millisecond, and sometimes even a few microseconds.</p>
<p>The main differences between fundamental and technical analyses are summarized in the following table:</p>
<table class="T---Table" id="table001-1">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="T---Table">
<td class="T---Table T---Body T---Body"/>
<td class="T---Table T---Body T---Body">
<p><strong class="bold">Fundamental analysis</strong></p>
</td>
<td class="T---Table T---Body T---Body">
<p><strong class="bold">Technical analysis</strong></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p>Key focus</p>
</td>
<td class="T---Table T---Body T---Body">
<p>Macroeconomics, politics, industry news, and the sentiment of investors</p>
</td>
<td class="T---Table T---Body T---Body">
<p>Price, volume, open interest, spreads, liquidity, and other quantitative parameters</p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p>Forecast horizon</p>
</td>
<td class="T---Table T---Body T---Body">
<p>Days to years</p>
</td>
<td class="T---Table T---Body T---Body">
<p>Microseconds to days, and rarely, weeks and months</p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p>Forecast precision</p>
</td>
<td class="T---Table T---Body T---Body">
<p>Very volatile</p>
</td>
<td class="T---Table T---Body T---Body">
<p>Depends on the timeframe</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 7.1 – Key differences between fundamental and technical analyses</p>
<p>The building <a id="_idIndexMarker373"/>block <a id="_idIndexMarker374"/>of any TA study is<a id="_idIndexMarker375"/> an <strong class="bold">indicator</strong>. It is a combination of price, time, volume, and/or any other market data that can be quantitatively measured.</p>
<p>Indicators are usually <a id="_idIndexMarker376"/>plotted as lines, dots, histograms, and other graphical objects <em class="italic">on</em> a price chart, <em class="italic">below</em> a price chart, or both. Normally, technical analysts use two to five indicators, each of them showing a particular feature of the examined price time series. <em class="italic">Figure 7</em><em class="italic">.1</em> shows a typical example of such a combination of TA indicators in a single chart:</p>
<div><div><img alt="Figure 7.1 – Typical layout of TA indicators with a price chart" src="img/B19145_7_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Typical layout of TA indicators with a price chart</p>
<p>Excessive<a id="_idIndexMarker377"/> use of TA indicators may lead to a mess when it’s really hard to understand what each of them shows and what the author of this mess really wanted to achieve. You probably can’t believe it, but the example in the following figure is not my fantasy, but something similar to what I saw with my own eyes so many times on various trading forums!</p>
<div><div><img alt="Figure 7.2 – How the excessive use of TA indicators may lead to ﻿abuse" src="img/B19145_7_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – How the excessive use of TA indicators may lead to abuse</p>
<p>There is one thing common<a id="_idIndexMarker378"/> for all TA indicators – their values are always synchronized with the original price time series on which they are based.</p>
<p>This means that if we build an indicator based on a 1-minute chart, then the values of this indicator will be updated every minute; for an hourly chart, the values will be updated every hour, and so on.</p>
<p>As you can see, if we use a tick chart as the source data to calculate the values of a TA indicator, then these values will be updated on every tick. When we work with live data feeds, TA indicators show fixed, unchanged values for all historical bars (well, we can’t change history, can we?), but update the latest reading with every new tick that comes in for a bar that is not completed yet.</p>
<p>Regardless of their <a id="_idIndexMarker379"/>complexity, almost all TA indicators can be classified into four major groups: velocity of the market, digital filters, range indicators, and volatility indicators. Let’s consider each of them.</p>
<p class="callout-heading">An important note before we proceed</p>
<p class="callout">In all the following discussions about technical indicators, we will use the term <strong class="bold">current bar</strong>. This<a id="_idIndexMarker380"/> doesn’t mean that we are talking only about the last (rightmost) bar on the chart. This means that when we plot charts, indicators, backtest strategies, and so on, we always move (imaginarily) from left to right, from historically older data to historically present, and we calculate anything <em class="italic">on every bar that we encounter</em>. This bar, for which we are calculating any values <em class="italic">at the moment</em>, is referred to as the <strong class="bold">current bar</strong>. We use this term because when we go live with our developments, the current bar will actually mean the price data that we receive <em class="italic">at this very moment</em>, so we don’t have to modify anything in our study or strategy code.</p>
<p>With this important note in mind, let’s go ahead.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor117"/>Velocity of the market</h2>
<p>These <a id="_idIndexMarker381"/>indicators <a id="_idIndexMarker382"/>try to answer the question, <em class="italic">How fast is the price moving?</em>. Indeed, if we compare a normal average day in the FX market with a release of important economic news or a political event, then we clearly see the difference. And of course, it would be nice to assess this difference quantitatively. We will consider only the two most well-known indicators of this kind – momentum and RSI – but any more sophisticated market speed indicator will be inevitably built on the same principles.</p>
<h3>Momentum</h3>
<p>This is <a id="_idIndexMarker383"/>probably<a id="_idIndexMarker384"/> the oldest technical indicator and definitely the simplest. It is really hard to imagine a simpler formula:</p>
<p><img alt="" src="img/Formula_B19145_07_001.png"/></p>
<p>Here, <em class="italic">C</em>0 means the current closing price and <em class="italic">C</em>-1 means the closing price of the previous bar.</p>
<p>If we <a id="_idIndexMarker385"/>calculate these differences for every bar, store<a id="_idIndexMarker386"/> them in an array, and plot the indicator below the chart, we will see that its values no longer follow the price movements and, overall, it looks more like noise rather than a clear trending price pattern. However, this noise is quite informative. Even from a quick glance at the chart in <em class="italic">Figure 7</em><em class="italic">.3</em>, we can conclude a number of important points:</p>
<div><div><img alt="Figure 7.3 – Basic momentum plotted below a price chart" src="img/B19145_7_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Basic momentum plotted below a price chart</p>
<p>First, we can see that the readings of momentum seldom remain in the positive or negative zone for more than two or three data points in a row. Since the momentum’s value is the difference between the current and the previous closing prices of just two adjacent bars, we can<a id="_idIndexMarker387"/> say that it’s not usual for this market that the price grew or declined steadily for more than three bars in a row. In other words, if we see more than two bars closing up, we may expect a bar to close down rather than another bar closing up. Technical analysts call these bars <strong class="bold">corrections</strong>; they <a id="_idIndexMarker388"/>may even appear inside quite long and steady trends, as in <em class="italic">Figure 7</em><em class="italic">.3</em>, but they do not break the trend. So, overall, we can say that this market is really prone to corrections.</p>
<p>Second, if we<a id="_idIndexMarker389"/> estimate the amplitude of the momentum indicator, we can see that it is different during different market regimes. While the market remained more or less <em class="italic">flat</em> (at the beginning of the chart), the amplitude of the momentum hardly exceeded 0.002 points, but as the uptrend was developing, its values increased to 0.004 by absolute value – that is, two times the <em class="italic">idle</em> market. So, we can assume that the <em class="italic">market speed</em> has some correlation with the market regime and could potentially use it in our own studies.</p>
<p>Normally, the momentum indicator has one parameter – the number of bars between which we calculate the difference. In the classical formula at the beginning of this section, we compared the closing prices of two adjacent bars; of course, we can compare the price of the current bar with that of any bar in the past. If we continue doing that for every bar, we will get to a modified formula:</p>
<p><img alt="" src="img/Formula_B19145_07_002.png"/></p>
<p>Here, <em class="italic">n</em> means the number of bars <em class="italic">back</em> from the current bar.</p>
<p>For example, if we set <em class="italic">n</em> to 24, then we calculate the difference in closing prices between the current bar and 24 bars ago (which, for an hourly chart, means the price strictly 24 hours or 1 day ago), we will see a somewhat different picture, as shown in <em class="italic">Figure 7</em><em class="italic">.4</em>:</p>
<div><div><img alt="Figure 7.4 – A 24-bar momentum based on a 1-hour chart means the price rate of change for 24 hours" src="img/B19145_7_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – A 24-bar momentum based on a 1-hour chart means the price rate of change for 24 hours</p>
<p>We can see<a id="_idIndexMarker390"/> that the <em class="italic">market speed</em>, or the price rate of <a id="_idIndexMarker391"/>change for 24 hours, looks totally different from the preceding chart, where we considered the difference in closing prices of just two neighbor bars. There’s no <em class="italic">noise</em> here anymore; instead, we observe longer-term changes in the momentum values. But the observations we made previously (regarding the corrections and correlations between <em class="italic">market speed</em> and range/trend markets) remain valid, as only the scale and proportions of these phenomena increased.</p>
<p>So, to summarize, the momentum indicator is useful to determine the idle market phases (when its readings are close to zero) and the highly active market (when its readings exceed a certain threshold). However, I hope you can see the evident shortcoming of this indicator in its present form – to decide whether the present market is active or not, we must specify this very <em class="italic">certain threshold</em> we just mentioned.</p>
<p>What is this threshold? In the first example (<em class="italic">Figure 7</em><em class="italic">.3</em>), the momentum values never exceeded 0.006, while in the second one (<em class="italic">Figure 7</em><em class="italic">.4</em>), it reaches almost 0.02, which is <em class="italic">a order of magnitude</em> greater. So, if we say that market speed above 0.004 is <em class="italic">abnormally big</em>, then we have to agree that<a id="_idIndexMarker392"/> in the second example, the market is in <em class="italic">abnormally big</em> mode half of the time.</p>
<p>It becomes clear <a id="_idIndexMarker393"/>that for the classical momentum indicator, there is no such threshold as a single unique numeric value. It depends on the market, the data resolution, and the momentum period. And it would be great if we could adjust the threshold value automatically, without the need for doing that manually every time, and consequently, eliminating possible human discretion bias.</p>
<p>So, how can we get rid of subjectivity when setting such a threshold?</p>
<h3>RSI</h3>
<p>The <a id="_idIndexMarker394"/>problem<a id="_idIndexMarker395"/> of answering the key question, <em class="italic">Is it big enough or still small</em> discussed in the previous section was solved for the momentum indicator by<em class="italic"> J.</em><em class="italic"> Welles Wilder Jr.</em> in 1978. In his book, <em class="italic">New Concepts in Technical Trading Systems</em>, he introduced the <strong class="bold">relative strength index</strong> (<strong class="bold">RSI</strong>), a new TA indicator that he suggested using in order to determine the <em class="italic">overbought</em> and <em class="italic">oversold</em> states of the market. In his terminology, <em class="italic">overbought</em> corresponds to the situation when prices grow <em class="italic">too quickly</em>, basically meaning that the market speed we discussed previously is too high. <em class="italic">Oversold</em> zones correspond to situations when prices fall <em class="italic">too quickly</em>, meaning the momentum is still greater than average by its absolute value but has a negative sign.</p>
<p>RSI solves the problem of specifying a universal threshold for the momentum indicator by <em class="italic">normalizing</em> its values. Normalization is a process of scaling data so that all values fit into a certain range. For example, we have two datasets:</p>
<pre class="source-code">
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
{0, 0.1, 0.4, 0.05, 0.1, 0.3, 0.2}</pre>
<p>We want to be able to compare <em class="italic">apples to apples</em>, and thus we want to scale both of them so the minimum and the maximum values of each dataset are the same. Typically, a range of 0 to 100 is used (it’s convenient: if we normalize data to this range we can then consider the values as a percentage). So, if we scale the first dataset to the range <em class="italic">0:100</em>, we will get an obvious sequence:</p>
<pre class="source-code">
{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100}</pre>
<p>But when we scale the second one, then <code>0</code> remains <code>0</code>, and the maximum value, which is <code>0.4</code>, becomes <code>100</code>, so the scaling coefficient is <em class="italic">100/0.4 = 250</em>. Then, the normalized dataset will look as follows:</p>
<pre class="source-code">
{0, 25, 100, 12.5, 25, 75, 50}</pre>
<p>Now<a id="_idIndexMarker396"/> we <a id="_idIndexMarker397"/>can compare, for example, the rate of change of data points in both datasets using the same metrics, despite the fact that, originally, the second dataset contains values of <em class="italic">a order of magnitude smaller</em> than values in the first one.</p>
<p>So, the idea of the normalization of TA indicators is to scale them <em class="italic">automatically</em> so that their values always remain in the <em class="italic">0:100</em> range, or sometimes, <em class="italic">-100:100</em>. Let’s do it for the momentum.</p>
<p>Welles Wilder suggests calculating RSI in two steps: first, we <a id="_idIndexMarker398"/>calculate the <strong class="bold">relative strength</strong> (<strong class="bold">RS</strong>), and second, the RSI.</p>
<p class="callout-heading">Note</p>
<p class="callout">Don’t forget that as with any other TA indicator, RSI uses <em class="italic">period</em>, a parameter that determines the number of data points we take into consideration. In the first example of the momentum indicator from the previous section, the period was just 1, and in the second example, it was 24.</p>
<p>To calculate the RS, we <a id="_idIndexMarker399"/>should first calculate the <em class="italic">gains</em> and <em class="italic">losses</em> for the period. A gain, in Wilder’s terminology, happened when a bar closed up, and a loss when a bar closed down. Then, we calculate the average of gains and the average of losses separately. And finally, we calculate the relative strength for the period:</p>
<div><div><img alt="" src="img/Formula_B19145_07_003.jpg"/>
</div>
</div>
<p>This formula is similar to the original momentum, only the momentum measures the <em class="italic">difference</em> between prices, and the RS measures the <em class="italic">ratio</em>. Using ratios is always preferred when <a id="_idIndexMarker400"/>we want to become independent of the original value range, where subtracting 0.01 from 0.1 will result in 0.09, while subtracting 10 from 100 results in 90, and it’s evident <a id="_idIndexMarker401"/>that 90 and 0.09 differ by <em class="italic">4 orders of magnitude</em>, so it’s impossible to compare them directly. However, dividing 0.01 by 0.1 and dividing 10 by 100 produces exactly the same value, that is, 0.1, so in terms of market speed, this value is indeed the same.</p>
<p>Now, we normalize the RS by keeping it always within the range of 0 to 100:</p>
<div><div><img alt="" src="img/Formula_B19145_07_004.jpg"/>
</div>
</div>
<p>If we now plot the RSI along with the momentum on the same chart, we can see that the two indicators are very similar:</p>
<div><div><img alt="Figure 7.5 – Momentum (top) and RSI (bottom) plotted on the same price chart" src="img/B19145_7_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Momentum (top) and RSI (bottom) plotted on the same price chart</p>
<p>Since RSI is <a id="_idIndexMarker402"/>normalized to a range of 0 to 100, typically, the values above 70 are considered an <em class="italic">overbought</em> market, while values below 30 are<a id="_idIndexMarker403"/> spoken of as <em class="italic">oversold</em>. In the preceding chart, the <em class="italic">overbought</em> market corresponds to an uptrend, and absence of <em class="italic">oversold</em> state can be interpreted as a strong upside bias in the market sentiment.</p>
<p>There are more market speed indicators than momentum and RSI, but all of them are used to determine the following market regimes:</p>
<ul>
<li>Idle versus active market (prices move slowly or quickly)</li>
<li>Overbought/oversold zones (prices went <em class="italic">too high</em> or <em class="italic">too low</em>)</li>
<li>Sharp bursts of prices mostly caused by liquidity issues (<em class="italic">spikes</em> on momentum charts)</li>
</ul>
<p>So, momentum is good for detecting relatively short-living market situations. But what about something longer-term? Are there indicators that could show us a more global sentiment, a long-term tendency? Let’s move on to another class of TA indicators that is normally used for this very purpose.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor118"/>Digital filters</h2>
<p>If <a id="_idIndexMarker404"/>you listen to music of any genre, and I hope you do, there’s a good <a id="_idIndexMarker405"/>chance that you are familiar with high-pass filters, low-pass filters, and equalizers. Any car audio, desktop, or mobile audio player offers this functionality. And I do hope that if you played with audio settings at least once in your life, you will remember what happens if you turn off treble and boost the bass to the maximum – that is, instead of music, you now hear only <em class="italic">boom-boom-boom</em>.</p>
<p>However, cutting off higher frequencies can also be quite useful if you want to focus on the rhythm, on the bass line, and probably on the chords and base (as opposed to harmonics) tones. And this is what lots of technical analysts dream of – to strip away all the <em class="italic">noise</em> from the market prices, leaving only the <em class="italic">bass line</em> or <em class="italic">rhythm</em>, – that is, the key trends and major price movements that last relatively long and, potentially, bring profits.</p>
<p>Surprisingly, or not, all TA indicators that do this job work <em class="italic">exactly</em> the same as low or high-pass filters in audio because they are based on <em class="italic">exactly the same</em> mathematical principles. That’s why we put them all in one section: digital filters.</p>
<h3>Moving averages</h3>
<p>A <a id="_idIndexMarker406"/>moving average<a id="_idIndexMarker407"/> is also one of the oldest technical indicators. It is calculated as the average of prices for the period and<a id="_idIndexMarker408"/> recalculated on every bar.</p>
<p class="callout-heading">Note</p>
<p class="callout">When we discuss TA indicators, we always use two terms: <em class="italic">period</em> and <em class="italic">current bar</em>. So let me just quickly remind you that a <em class="italic">period</em> means a number of data points (ticks, bars, any other samples from a time series) that the TA indicator analyzes, and the <em class="italic">current bar</em> changes one by one, left to right, as we reconstruct the historical values of the indicator, along with the historical values of the market price itself.</p>
<p>To give you a simple example, let’s consider the following dataset:</p>
<pre class="source-code">
A = {0, 1, 2, 3, 2, 1, 0, 1, 2, 3}</pre>
<p>Let’s <a id="_idIndexMarker409"/>calculate an average of three data points starting from <a id="_idIndexMarker410"/>the leftmost one. For the first element in the original dataset, it’s impossible to do because we have only one data point and we require three. The same for the second data point. So, we can start calculating the moving average from the third data point, and its value will be as follows:</p>
<div><div><img alt="" src="img/Formula_B19145_07_005.jpg"/>
</div>
</div>
<p>Then, we move on to the fourth data point and again calculate the value of the moving average, but this time, we start calculating from the second element in our dataset:</p>
<div><div><img alt="" src="img/Formula_B19145_07_006.jpg"/>
</div>
</div>
<p>Proceeding in this way, we will get a new dataset that represents the average values of three data points in a row, recalculated for each data point from left to right. Therefore, for the first two data points, we don’t have any value (as the number of original data points was insufficient to calculate a three-point average):</p>
<pre class="source-code">
<img alt="" src="img/Formula_B19145_07_007.png"/>= {NaN, NaN, 1, 2, 2.33, 2, 1, 0.66, 1, 2}</pre>
<p class="callout-heading">Note</p>
<p class="callout">I hope you got the point: we always take three samples from the dataset, calculate the average, store this value in a new dataset, and move on to the next sample. This technique is called the <strong class="bold">moving window</strong> and<a id="_idIndexMarker411"/> is the basis for the calculation of all TA indicators.</p>
<p>Normally, <strong class="bold">moving averages</strong> (<strong class="bold">MAs</strong>) are calculated based on the closing prices of bars, but nothing <a id="_idIndexMarker412"/>prevents us from using them with any other price (such as high, low, or trade) or non-price data (such as volume, liquidity, and so on).</p>
<p>It’s evident<a id="_idIndexMarker413"/> that an MA with a period of one equals the original time series. How will values of MAs with greater periods correspond to the original data?</p>
<p>Let’s plot the original price time series in form of just dots, not bars, where each dot will denote a closing price of the bar. And let’s plot 3 different MAs along with the original series with periods of 2, 3, 5, and 10, respectively:</p>
<div><div><img alt="Figure 7.6 – 3, 7, and 13-period MAs on top of a 1-hour chart of EURUSD" src="img/B19145_7_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – 3, 7, and 13-period MAs on top of a 1-hour chart of EURUSD</p>
<p><em class="italic">Figure 7</em><em class="italic">.6</em> plots the original time series as bars, and 3, 7, and 13-period MAs as dashes, crosses, and solid lines, respectively. We can see that the smaller the period of an MA, the closer its values are to the original series, and the greater the period, the <em class="italic">smoother</em> the change in the MA’s values.</p>
<p>This <em class="italic">smoothing</em> is the very effect of a low-pass filter. Surprisingly, an MA, calculated using simple mathematics, <em class="italic">is</em> a digital filter, pretty close to those used in audio processing. The greater the period of the MA, the lower the maximum frequency passed by such a filter. So, if applied to an audio signal, such a filter will leave us with <em class="italic">boom-boom</em>, and now we can see this <em class="italic">boom-boom</em> in the market prices. Ultimately, using MAs with a <a id="_idIndexMarker414"/>period of 20, 50, or 200 will show only longer-term changes in the market prices, considering minor price movements as high-frequency noise.</p>
<p><em class="italic">Figure 7</em><em class="italic">.7</em> shows <a id="_idIndexMarker415"/>the same hourly chart of EURUSD with closing prices only, plotted as big black dots, and 20-, 50-, and 200-period MAs on top of it:</p>
<div><div><img alt="Figure 7.7 – 20, 50, and 200-period MAs plotted over a 1-hour chart of closing prices of EURUSD" src="img/B19145_7_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – 20, 50, and 200-period MAs plotted over a 1-hour chart of closing prices of EURUSD</p>
<p>In this example, we can see that the MA with the greatest period (200) only grows with slight changes in the growth rate, while MAs with shorter periods grow and decline, and the smaller the period of the MA, the closer its values are to the original series.</p>
<p>So, MAs are<a id="_idIndexMarker416"/> the simplest digital filters and are designed to detect <em class="italic">tendencies</em> rather than immediate activity. They are used in TA to solve the following problems:</p>
<ul>
<li>To determine long- and medium-term trends</li>
<li>To distinguish bullish and bearish markets (normally, when daily prices close above the 200-period MA, the market is considered bullish, and vice versa)</li>
<li>To smoothen <em class="italic">occasional</em> or <em class="italic">abnormal</em> sharp price movements</li>
</ul>
<p>Very <a id="_idIndexMarker417"/>frequently, MAs are used in combination with momentum indicators – for example, an MA can be used to determine whether the market is bullish (closing prices above 200-period MA), and momentum can determine the moment when the market speed is high, so potentially, it could be a good time to buy.</p>
<p>However, you probably already heard about traders who lost their fortune buying when prices were already too high or selling when prices were already too low. I hope now that we have so thoroughly examined the design of market speed indicators and digital filters, you have already spotted the bottleneck here – <em class="italic">too high</em> or <em class="italic">too low</em>. But how do we decide that it’s already <em class="italic">too</em> high or still <em class="italic">not so</em> high? The answer is in the following section.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor119"/>Range indicators</h2>
<p>One<a id="_idIndexMarker418"/> of the<a id="_idIndexMarker419"/> most common methods to solve the problem of identifying whether the current price is in any extreme zone (too high or too low) is using range indicators. Normally, a <strong class="bold">price range</strong> is a<a id="_idIndexMarker420"/> difference between the maximum price and the minimum price for, well (I’m sure I heard you say that), a <em class="italic">period</em>. As always, with technical indicators, we’re bound to a certain timespan, a moving window that we slide along the chart from left to right. So, when we talk about range, we have to define the period for which this range is calculated.</p>
<p>Let’s look at the chart shown in <em class="italic">Figure 7</em><em class="italic">.8</em>. The rectangle shows the maximum and minimum <a id="_idIndexMarker421"/>price of a 24-bar span (since it’s an hourly chart, this means the rectangle corresponds to 1 day):</p>
<div><div><img alt="Figure 7.8 – A 24-hour price range with 2 closing prices shown as percentage of range, EURUSD, 1-hour" src="img/B19145_7_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – A 24-hour price range with 2 closing prices shown as percentage of range, EURUSD, 1-hour</p>
<p>Two closing<a id="_idIndexMarker422"/> prices are marked with small arrows. Horizontal lines are drawn through these closing prices to visualize the price levels relative to the range rather than absolute values. So, for the first (left to right) closing price, the absolute value is 1.1260, but relative to the range, it’s right at 50% of it. The second closing price is 1.1292, but relative to the range, it’s about 85% of it.</p>
<p>Got the point? We can replace absolute price values that don’t say much with relative price levels, which could be interpreted pretty much as we interpreted RSI values (see the <em class="italic">RSI</em> section). For example, we can say that when the price is above 80% of the range level, then<a id="_idIndexMarker423"/> the price is <em class="italic">too high</em>, and when the price is <a id="_idIndexMarker424"/>below 20% of the range level, then the price is <em class="italic">too low</em>.</p>
<p>The first and the most well-known range indicator is the <strong class="bold">stochastic oscillator</strong>.</p>
<h3>Stochastic oscillator</h3>
<p><strong class="bold">Stochastic</strong> is <a id="_idIndexMarker425"/>quite a popular word among traders, but unfortunately, it is often used improperly. In mathematics, the term <em class="italic">stochastic</em> means a variety of random processes. To understand what it means, let’s consider an example.</p>
<p>If you go out <a id="_idIndexMarker426"/>to buy some bread, then you will most likely go down the same streets, end your route at the same local grocery store, and spend more or less the same amount of time as usual. This is an example of a <em class="italic">deterministic process</em> – although there can be some <em class="italic">fluctuations</em> or deviations down the road (for example, you decide to walk on this or that side of the street), the overall route and destination remain the same.</p>
<p>Now, imagine that you go out with no particular goal in mind and stop at any shop, bar, or movie theater you like, spend any amount of time in each, and decide where to go next by tossing a coin. Every time you take such a trip, its trajectory, destinations, and time spent, both on each leg and the entire journey, will differ. Although the area where you’re traveling is confined and you visit the same places, the map of your actual movements will be different because of the <em class="italic">randomness</em> of your decisions. Such a process is called <em class="italic">stochastic</em> or <em class="italic">random</em> or <em class="italic">probabilistic</em>.</p>
<p>Market price movements are also considered random or stochastic processes by many researchers, who have suggested various probabilistic models that describe price behavior. Although this standpoint can also be criticized, such an academic debate is definitely outside the scope of this book, so the main points we should take away from this brief <em class="italic">lyrical digression</em> are as follows:</p>
<ul>
<li>Processes with a definite trajectory, target, and time are called <strong class="bold">deterministic</strong></li>
<li>Processes where every next step has just some probability and you never know for sure where and when it reaches any target are called <strong class="bold">stochastic</strong></li>
<li>Changes in market prices can be considered a <strong class="bold">stochastic process</strong></li>
<li>The stochastic oscillator has nothing in common with <strong class="bold">stochastic processes</strong></li>
</ul>
<p>The<a id="_idIndexMarker427"/> stochastic oscillator <a id="_idIndexMarker428"/>in its original form shows exactly what we considered at the very end of the previous section – it shows where the current price is as a percentage of a certain price range. So, in order to <a id="_idIndexMarker429"/>calculate the stochastic oscillator, we should choose a period (number of data points), then find the maximum and the minimum price for this period, and then calculate the value of the stochastic oscillator:</p>
<div><div><img alt="" src="img/Formula_B19145_07_008.jpg"/>
</div>
</div>
<p>Here, <em class="italic">P</em>0 means the current price, <em class="italic">L</em> means the lowest price for the period, and <em class="italic">H</em> means the highest price for the period.</p>
<p>Let’s again open an hourly chart of a currency pair, but this time, the Japanese yen for a change, and let’s plot this indicator with a period of 24 below it (thus tracking changes in price as a percentage of a day’s range):</p>
<div><div><img alt="Figure 7.9 – Basic 24-period stochastic oscillator below the 1-hour chart of USDJPY" src="img/B19145_7_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 – Basic 24-period stochastic oscillator below the 1-hour chart of USDJPY</p>
<p>In <em class="italic">Figure 7</em><em class="italic">.9</em>, we <a id="_idIndexMarker430"/>can see that the stochastic oscillator indeed <em class="italic">oscillates</em> in a range from 0 to 100 (what a surprise). During trends (right half of the picture), it tends to stay above 50, and in sideways markets (middle part of the picture) it can oscillate full scale.</p>
<p>So, what’s the possible application of the stochastic oscillator?</p>
<p>First and foremost, it’s used <a id="_idIndexMarker431"/>to answer the question of whether the price is <em class="italic">too high</em> or <em class="italic">too low</em> (I hope you remember this Shakespearean question from the end of the previous section). We can say, for example, that when the price is above the level of 80 – which means that the price is greater than 80% of the price range – then it is indeed <em class="italic">too high</em>. Likewise, being under 20% of the range could mean that the price is <em class="italic">too low</em>.</p>
<p>Second, some technical traders like to use stochastic and similar oscillators to determine trends. We already saw that, during trends, the stochastic oscillator tends to remain above (for uptrends) or below (for downtrends) 50% of the range for quite a long time. It’s no wonder that trends are special market regimes where corrections in prices are much smaller and last for a much shorter time than the movements in the direction of the trend. So, prices will indeed remain in the upper or lower half of the range for many hours, days, or sometimes even weeks.</p>
<p>There are <a id="_idIndexMarker432"/>numerous modifications of the stochastic oscillator. For<a id="_idIndexMarker433"/> example, adding an MA to its values (and we remember that we can add an MA to any time series, not necessarily price) gives us a so-called <em class="italic">slow stochastic</em>. Some authors suggest using the original indicator and the averaged one on the same chart, but the essence remains the same – this is a range oscillator and can, therefore, be used to solve the following problems:</p>
<ul>
<li>Identifying whether the price is <em class="italic">too high</em> or <em class="italic">too low</em></li>
<li>Identifying trends as long-term periods when prices are above or below 50% of the range</li>
<li>Suggesting buy signals when the oscillator starts going up from <em class="italic">too </em><em class="italic">low</em> levels</li>
<li>Suggesting sell signals when the oscillator starts going down from <em class="italic">too </em><em class="italic">high</em> levels</li>
</ul>
<p>Now that we have a speed indicator (momentum or RSI) that tells us that the market is moving fast, a digital filter (MAs) that confirms that the main tendency in the market is still positive, and a range indicator (stochastic) that shows that the asset is currently oversold, it may look like it’s a good time to buy.</p>
<p>But!</p>
<p>Even if we calculated the timing of our entry with the highest degree of perfection, markets still remain stochastic processes (remember what we started with at the beginning of this section?) and it is normal that price may go against you for some time. The key question here is whether this adverse price movement is only a small correction and it’s wise to just wait till red turns green, or you were wrong with your trading decision (which, by the way, is also absolutely normal) and should liquidate your losing position before it drains your account completely.</p>
<p>Normally, this problem is solved by adding volatility studies to the trading strategy logic.</p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor120"/>Volatility indicators</h2>
<p>If we<a id="_idIndexMarker434"/> look up the definition of volatility in Merriam-Webster, the first suggested <a id="_idIndexMarker435"/>meaning would be <em class="italic">a tendency to change quickly and unpredictably</em>. Sounds good, but how can we measure this tendency, this ability to change?</p>
<p>Wikipedia (<a href="https://en.wikipedia.org/wiki/Volatility_(finance)">https://en.wikipedia.org/wiki/Volatility_(finance)</a>) suggests a different definition: <em class="italic">“volatility (usually denoted by σ) is the degree of variation of a trading price series over time, usually measured by the standard deviation of logarithmic returns.”</em> If you are not familiar with mathematical statistics, this may sound like a foreign language to you, but don’t worry, let’s take a quick tour of the theory of probability.</p>
<p>Let’s use the same example with a random walk around bars and movie theaters. Let’s measure the distance between the starting point (your home, presumably) and the ending point (where you decide to finish your walk for the day). Every day, we will get different values because you make your travel decisions randomly. However, we can calculate the average value and say that, on average, you walk, say, three kilometers per walk.</p>
<p>The devil is always in the details, and the devil of averaging is<a id="_idIndexMarker436"/> called <strong class="bold">dispersion</strong>. This is a measure of how much the actual values of a certain random variable differ from the average, or <em class="italic">mean</em> value. Let’s consider two examples.</p>
<p>First, let’s go back to a deterministic process when you go out to a local grocery. We record travel distances for each trip and put them into a dataset:</p>
<pre class="source-code">
S = {1.8, 1.9, 1.85, 1.79, 1.78, 1.81, 1.85, 1.82, 1.89, 1.2}</pre>
<p>Now, let’s calculate the mean value of this dataset:</p>
<div><div><img alt="" src="img/Formula_B19145_07_009.jpg"/>
</div>
</div>
<p>Now, subtract this mean value from each element of the original dataset:</p>
<pre class="source-code">
D = {0.03, 0.13, 0.08, 0.02, 0.01, 0.04, 0.08, 0.05, 0.12, -0.57}</pre>
<p>We can see that <a id="_idIndexMarker437"/>the difference between almost all recorded values and their mean is <em class="italic">a order of magnitude smaller</em> than the mean itself. The only exception is the last values in the <code>D</code> dataset: the difference between it and the mean is comparable to the value itself. Such a value is called <a id="_idIndexMarker438"/>an <strong class="bold">outlier</strong> and is most likely explained by incorrect measurements or something exceptional that happened to you down the road.</p>
<p>Now, let’s <a id="_idIndexMarker439"/>record the distances traveled each time you took a random walk around the local bars and movie theaters. In some cases, you found a nice place to stay almost as soon as you left your house; in other cases, you walked quite a lot and still returned home unsatisfied, hence the difference in the distance you traveled each time. We will get a dataset like this:</p>
<pre class="source-code">
S1 = {0.7, 2, 1.5, 0.3, 2.6, 1.1, 1.8, 0.45, 3.1, 2.9}</pre>
<p>Its mean value is 1.645. If we now do the same as previously (that is, subtract this mean from each element of the dataset), we will see that the differences now are quite comparable to the mean value, and in some cases, nearly exceed it:</p>
<pre class="source-code">
D = {-0.94, 0.35, -0.14, -1.34, 0.95, -0.54, 0.15, -1.19, 1.45, 1.25}</pre>
<p>The process in which the differences between values and their mean are way smaller than the values themselves is a <em class="italic">deterministic process</em>, and now we have a more math-looking definition of it (although it’s still not formally correct). Conversely, the process where the differences between values and their mean are comparable to the mean itself is a <em class="italic">stochastic</em> or <em class="italic">random</em> process.</p>
<p>So, back to the market stuff. If we do the same math with prices (for example, recording the changes in price for each bar and then calculating their mean value and the difference), then we can use this difference as the measure of <em class="italic">volatility</em>. It will indeed match the Merriam-Webster definition – the greater the differences in question, the less predictable the values and the quicker the possible changes in prices.</p>
<p>In practice, a bit more complex calculation is used to determine market volatility. One of the commonly used metrics that estimate <em class="italic">how far the values of a dataset are from their mean</em> is called <strong class="bold">standard deviation</strong>. If <a id="_idIndexMarker440"/>you are interested in learning more about it and the <a id="_idIndexMarker441"/>mathematics behind the concept of volatility, I encourage you to first read the basics about mathematical statistics to get familiar with the terminology and the key concepts. The article in Wikipedia (<a href="https://en.wikipedia.org/wiki/Mathematical_statistics">https://en.wikipedia.org/wiki/Mathematical_statistics</a>) could be a good starting point. In the <a id="_idIndexMarker442"/>meantime, we continue in a somewhat informal manner and remember that standard deviation is used to estimate the volatility in any stochastic process and market prices in particular.</p>
<p>I am sure you now perfectly understand that <strong class="bold">standard deviation</strong> (or <strong class="bold">stddev</strong> for short) also requires a period quite like any other TA indicator. This period is the length of the dataset for which we measure the volatility. So, what we’re plotting is as follows:</p>
<pre class="source-code">
S = stddev(close, 24)</pre>
<p>This can be shown in the form of an equation like so:</p>
<div><div><img alt="" src="img/Formula_B19145_07_010.jpg"/>
</div>
</div>
<p>Here, <em class="italic">c</em>i means the closing price of the <em class="italic">i</em>-th bar, <img alt="" src="img/Formula_B19145_07_011.png"/> denotes the mean value, and <em class="italic">24</em> means the number of data points (closing prices of bars) for which we calculate <code>stddev</code>.</p>
<p><em class="italic">Figure 7</em><em class="italic">.10</em> shows the same 1-hour chart of GBPUSD as in the previous example, but now with the 24-period standard deviation indicator below it:</p>
<div><div><img alt="Figure 7.10 – Hourly chart of GBPUSD with a standard deviation of closing prices" src="img/B19145_7_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10 – Hourly chart of GBPUSD with a standard deviation of closing prices</p>
<p>We can see<a id="_idIndexMarker443"/> that volatility is something that doesn’t have any <a id="_idIndexMarker444"/>evident relationships with the direction of the market prices or with trend/sideways market regimes. What we <em class="italic">can</em> see though is a number of important observations:</p>
<ul>
<li>Standard deviation is always positive; it disregards the direction of the price movement</li>
<li>A sudden increase in the market activity does increase values of the standard deviation of closing prices</li>
<li>The longer the price remains at new levels (see the jump in price on July 27 and a congestion zone following it the next day), the greater the increase in values of the standard deviation</li>
<li>Maximums and minimums in the <code>stddev</code> indicator do not correspond to maximums and minimums in the price chart</li>
</ul>
<p>Interesting picture, but there’s one questionable assumption here, and I hope you already exclaimed, “<em class="italic">Wait! But we measure the standard deviation of an incorrect dataset! Why do we measure it for the price itself when we should have done that for </em><em class="italic">price increments?</em>”.</p>
<p>Indeed, the <a id="_idIndexMarker445"/>market process can be considered a stochastic process from a <a id="_idIndexMarker446"/>number of standpoints. We can consider every closing price as an independent value of a random process, or we can look at price movements as a random walk process, where we’re interested only in how much the price changed since the last observation (bar). So instead of calculating the standard deviation of <em class="italic">closing prices</em>, we should rather calculate the standard deviation of <em class="italic">changes in price</em> for each bar:</p>
<div><div><img alt="" src="img/Formula_B19145_07_012.jpg"/>
</div>
</div>
<p>Here, <em class="italic">C</em>i means the current bar, <em class="italic">C</em>i-1 means the previous bar, and the delta symbol means the price increment per bar (positive or negative – and this is the key difference from calculating standard deviations for prices, as they can only be positive).</p>
<p>Let’s see whether there’s any difference between the standard deviation of closing prices and the standard deviation of <em class="italic">differences</em> of closing prices. <em class="italic">Figure 7</em><em class="italic">.11</em> still shows the same chart of GBPUSD with both standard deviations plotted below it:</p>
<div><div><img alt="Figure 7.11 – Two versions of the standard deviation-based volatility indicator" src="img/B19145_7_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11 – Two versions of the standard deviation-based volatility indicator</p>
<p>The <a id="_idIndexMarker447"/>difference is pathetic! There are no longer <em class="italic">smooth</em> changes in <a id="_idIndexMarker448"/>volatility. Instead, we observe periods of high and low volatility abruptly switching from one to another. Now the picture is more adequate to what we observe in the market itself:</p>
<ul>
<li>Sharp price movements always and immediately cause our volatility indicator to jump</li>
<li>High volatility often means a reversal in price</li>
<li>Longer-term trends (the right part of the chart) are accompanied by low volatility (surprise!)</li>
</ul>
<p>The fact that sharp price movements cause volatility to also increase sharply is used in <em class="italic">volatility breakout</em> strategies; the idea is buying or selling the asset in the direction of the already started <a id="_idIndexMarker449"/>sharp price movement. And the fact that the volatility is relatively low during<a id="_idIndexMarker450"/> trends is used in various <em class="italic">trend-following</em> or <em class="italic">mean-reversion</em> strategies.</p>
<p>Our study on volatility would definitely be incomplete without one of the most well-known and popular TA indicators, Bollinger bands.</p>
<h3>Bollinger bands</h3>
<p>This<a id="_idIndexMarker451"/> indicator was introduced by John Bollinger in the 1980s. The idea<a id="_idIndexMarker452"/> is to determine whether the price of an asset lies outside of the <em class="italic">normal</em> range. In this indicator, the <em class="italic">normal</em> range is defined as the mean value plus or minus two standard deviations (or two <em class="italic">sigma</em>). Therefore, Bollinger bands consist of <em class="italic">two</em> lines, one always going above the price (<em class="italic">B+</em>) and the other, always below (<em class="italic">B-</em>):</p>
<p>B+ =<img alt="" src="img/Formula_B19145_07_013.png"/></p>
<p>B- = <img alt="" src="img/Formula_B19145_07_014.png"/></p>
<p>Why two <em class="italic">stddev</em>, not one? If you want to learn the correct, formal answer, I would recommend that you refer to any book on mathematical statistics or the same Wikipedia article as earlier. Without going into details, let us just take it for granted that for a stochastic process, 90% of data points fall into the mean <em class="italic">± 2</em> sigma range. So, the idea of Bollinger bands is that drawing lines in a <em class="italic">2</em> sigma distance from the mean could help isolate outliers – that is, the prices that lie outside the <em class="italic">±2</em> stddev range.</p>
<p>Let’s see what it looks like in reality. <em class="italic">Figure 7</em><em class="italic">.12</em> shows a 1-minute chart of AUDUSD with 20-period Bollinger bands on it:</p>
<div><div><img alt="Figure 7.12 – 1-minute chart of AUDUSD with Bollinger bands﻿" src="img/B19145_7_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12 – 1-minute chart of AUDUSD with Bollinger bands</p>
<p>This chart <a id="_idIndexMarker453"/>represents the mean or moving average (solid line in the middle) and two Bollinger bands (gray lines above and below). Bold black dots mark the closing prices that lie above the upper band or below the lower band. Both are <em class="italic">outliers</em>.</p>
<p>Technical traders use <a id="_idIndexMarker454"/>Bollinger bands for various purposes as other TA indicators as well, though:</p>
<ul>
<li>Outliers can be interpreted as breakouts – moments when the price starts its movement to a certain direction – so can be used in strategies that attempt to buy or sell <em class="italic">along with</em> the movement</li>
<li>Outliers can be interpreted as liquidity issues and thus considered as good points for mean reversion – so can be used as entry points to buy or sell <em class="italic">against</em> the current price movement</li>
</ul>
<h2 id="_idParaDest-120"><a id="_idTextAnchor121"/>Key takeaways – what TA indicators are all about and how to use them</h2>
<p>The world of technical indicators is really vast. However, most of them are just variations of the same old classical indicators of the four main types:</p>
<ul>
<li>Momentum, or <em class="italic">market speed</em></li>
<li>Digital filters</li>
<li>Range</li>
<li>Volatility</li>
</ul>
<p>Don’t forget this when you stumble upon a new <em class="italic">unique</em> indicator that promises <em class="italic">fantastic</em> results. Give it a thorough examination first and you will see what it actually shows.</p>
<p>Don’t forget that no indicator can build you a robust trading strategy. They serve only to quantitatively identify various situations in the market, and it is still up to you as the trading strategy developer how you actually exploit these situations in the logic of your code.</p>
<p>Now, it’s time to see how we can implement technical indicators in native Python code.</p>
<h1 id="_idParaDest-121"><a id="_idTextAnchor122"/>Implementation of TA indicators in Python</h1>
<p>I am sure you <a id="_idIndexMarker455"/>remember that any TA indicator uses a certain period as a parameter. This period means a number of data points that we take into consideration. To calculate an indicator on every bar, we start from the oldest one (the leftmost on the chart) and then move one by one, updating our dataset with each new bar.</p>
<p>Since we are talking about an absolutely essential thing that lies in the foundation of all TA, let me be very detailed here – probably too detailed – but I want to leave no place for ambiguity or misunderstanding in the following concepts and code samples.</p>
<p>Let’s start with the core concept of time series processing: the sliding window.</p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor123"/>Sliding windows</h2>
<p>Let’s go<a id="_idIndexMarker456"/> back to the example of a random walk (around bars and movies) that we considered in the previous section. The entire dataset, or historical data, consists of 10 data points:</p>
<pre class="source-code">
S1 = {0.7, 2, 1.5, 0.3, 2.6, 1.1, 1.8, 0.45, 3.1, 2.9}</pre>
<p>Now, if we are interested in analyzing the activity only for the last 3 days, then we get the following subsets:</p>
<pre class="source-code">
S1_1 = {0.7, 2, 1.5}
S1_2 = {2, 1.5, 0.3}
...
S1_8 = {0.45, 3.1, 2.9}</pre>
<p>Then, we apply a TA indicator to each subset, one by one, left to right, older to newer.</p>
<p>This<a id="_idIndexMarker457"/> technique is known as the <strong class="bold">sliding window</strong>, and is the cornerstone of all technical trading, from plotting simple indicators to backtesting and optimization.</p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor124"/>Peeking ahead</h2>
<p>The<a id="_idIndexMarker458"/> main problem of working with<a id="_idIndexMarker459"/> historical data while using sliding windows is the potential ability to <em class="italic">peek ahead</em>, or look into the future (see <a href="B19145_04.xhtml#_idTextAnchor073"><em class="italic">Chapter 4</em></a>, <em class="italic">Trading Application – What’s Inside?</em>, in the <em class="italic">Trading logic – this is where a small mistake may cost a fortune</em> section, for the discussion on the peeking ahead issue). If we reconstruct your random walk movements from the <code>S1</code> dataset (see the <em class="italic">Stochastic oscillator</em> section in this chapter), we should take particular care about <em class="italic">not</em> using data from <em class="italic">tomorrow</em> when we analyze what happened <em class="italic">today</em>. Let’s add dates to our data samples to give them more clarity:</p>
<pre class="source-code">
S1 =  {{01/01/2001,0.7}
      {01/02/2001, 2}
      {01/03/2001, 1.5}
      {01/04/2001, 0.3}
      {01/05/2001, 2.6}
      {01/06/2001, 1.1}
      {01/07/2001, 1.8}
      {01/08/2001, 0.45}
      {01/09/2001, 3.1}
      {01/10/2001, 2.9}}</pre>
<p>If we<a id="_idIndexMarker460"/> reconstruct what happened on or before January 6, 2001, we are allowed to take into consideration only data from the prior period. We <em class="italic">cannot, should not, and have no right</em> to use data from January 7 or later. If we do, we face this peek-ahead issue.</p>
<p>Now, imagine<a id="_idIndexMarker461"/> that you’re developing a trading strategy and want to test it using past data. The goal of such a test is to reconstruct what <em class="italic">would have happened</em> on that particular day at that particular time <em class="italic">if</em> your strategy actually worked then. If you reconstruct what your strategy would have done on January 6, you have no right to peek ahead and use data from January 7, even 1 second past the test date, because you have no time machine (or so I assume) and when you run your strategy <em class="italic">live</em>, you will be also unable to retrieve data from the future.</p>
<p>However, peeking ahead is, surprisingly, quite a common mistake, and this is why I go into so much detail on this issue here. Remember that <em class="italic">if your strategy delivers unrealistically good returns, then most likely, they are indeed not realistic and are caused by </em><em class="italic">peeking ahead.</em></p>
<p>How is it possible to peek ahead non-intentionally, occasionally? Well, it’s very easy if you store price time series in a list or any similar iterable structure, and retrieve data to do calculations by an index. In the previous example, I can get data from January 7 while testing a strategy for January 6 simply by calling <code>S1[4:7]</code>. Even if you use dictionaries, you can get erroneous data by retrieving it with an incorrectly specified datetime index.</p>
<p>But having said all that, is there a method to guarantee that your code will never try to retrieve data from the future? Let’s find out!</p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor125"/>The ultimate solution to the peek-ahead issue</h2>
<p>To <a id="_idIndexMarker462"/>suggest such a solution, we should recall that when we use <em class="italic">live</em> data, we are physically unable to get data from the<a id="_idIndexMarker463"/> future because ticks or any other data packets arrive at your trading application one by one. So, if we want to fully guarantee no peeking ahead during the testing phase of the development, we may want to emulate the very incoming data stream and write the rest of the code as if we plan to work with live data, not historical data stored on disk.</p>
<p>The first step toward this universal architecture was made in <a href="B19145_05.xhtml#_idTextAnchor086"><em class="italic">Chapter 5</em></a>, <em class="italic">Retrieving and Handling Market Data with Python</em>, where we suggested using queues and threads to accommodate for receiving large amounts of incoming ticks. Now, let’s look at the problem of calculating TA indicators from the same standpoint.</p>
<p>I’m sure you remember that <em class="italic">any</em> TA indicator analyzes a subset of price time series, and the length of this subset is<a id="_idIndexMarker464"/> called a <strong class="bold">period</strong>. When we looked at charts, we always noted that for the reconstruction of the indicator’s values on historical price data, we need to move this period from left to right, from the oldest to the newest data points. We called this approach a <strong class="bold">sliding window</strong>.</p>
<p>But now let’s think about what we should do in case we try to build the indicator’s values <em class="italic">on the fly</em>, live, as market data is coming in. There’s no history, no stored values, only live ticks. So how can we create such a sliding window?</p>
<p>The answer is obvious: we do create a <em class="italic">window</em>, but we don’t create a <em class="italic">sliding</em> window because there’s nothing to slide on.</p>
<p>Let’s recall how a queue works (see also <a href="B19145_05.xhtml#_idTextAnchor086"><em class="italic">Chapter 5</em></a>, <em class="italic">Retrieving and Handling Market Data with Python</em>). Generally speaking, a queue is a list with the following properties:</p>
<ul>
<li>When a new element comes in, it is added to the end of the queue</li>
<li>When we retrieve an element from the queue, it is taken from the beginning and removed</li>
</ul>
<p>Now, let’s create a special queue where the oldest elements (those at the beginning) are not retrieved, but automatically removed as soon as a new element is added. Let’s look at the diagram in <em class="italic">Figure 7</em><em class="italic">.13</em> to see how it works:</p>
<div><div><img alt="Figure 7.13 – Queue with a fixed length and automatic removal of the oldest element upon arrival of a new element" src="img/B19145_7_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.13 – Queue with a fixed length and automatic removal of the oldest element upon arrival of a new element</p>
<p>Now, let’s <a id="_idIndexMarker465"/>start filling this queue with<a id="_idIndexMarker466"/> price time series, starting from the oldest data points. What do we get then?</p>
<p>Let’s do it with our <code>S1</code> sample data from the preceding example. Imagine that we created such a queue with a length of three. Then, we start pushing data points to this queue, removing the oldest points as new points come in. We will get the following subsets:</p>
<pre class="source-code">
S1_1 = {{01/01/2001,0.7}
      {01/02/2001, 2}
      {01/03/2001, 1.5}}
S1_2 = {{01/02/2001, 2}
      {01/03/2001, 1.5}
      {01/04/2001, 0.3}}
S1_3 = {{01/03/2001, 1.5}
      {01/04/2001, 0.3}
      {01/05/2001, 2.6}}
...</pre>
<p>And so on.</p>
<p>What are these subsets now?</p>
<p>Wow, these are exactly what we got using a sliding window!</p>
<p>Now, instead <a id="_idIndexMarker467"/>of storing data in a database or any other storage and then retrieving it for the purpose of building a TA indicator, we do that <em class="italic">on the fly</em> as new data is coming in. In this case, we will never be able to peek ahead because we will never be able to receive data from the future. All we need to do is emulate the data feed using historical data.</p>
<p>This solution has another <a id="_idIndexMarker468"/>evident and huge benefit: if we develop our application using an emulated data feed, then we can switch to a live data feed <em class="italic">without changing a single line of code</em>. So, this approach not only guarantees that the results of our tests are always honest but also that we save a massive amount of time by developing a <em class="italic">universal</em> application from the very beginning.</p>
<p>Enough talk, let’s get to coding.</p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor126"/>Sliding window as a queue</h2>
<p>Now, we’re<a id="_idIndexMarker469"/> ready to implement <a id="_idIndexMarker470"/>the sliding window using a Python queue:</p>
<ol>
<li>Let’s create a class for our sliding windows first:<pre class="source-code">
class sliding_window:</pre><pre class="source-code">
    def __init__(self, length):</pre><pre class="source-code">
        self.data = ([0]*length)</pre></li>
</ol>
<p>Here, we create a container for our sliding window and fill it with zeros.</p>
<ol>
<li value="2">Now, let’s add the only method that appends a new element to this window and immediately deletes the oldest one:<pre class="source-code">
    def add(self, element):</pre><pre class="source-code">
        self.data.append(element)</pre><pre class="source-code">
        self.data.pop(0)</pre></li>
<li>Now, create <a id="_idIndexMarker471"/>an instance<a id="_idIndexMarker472"/> of this class with a length of just <code>5</code> (for demo purposes):<pre class="source-code">
sw = sliding_window(5)</pre></li>
</ol>
<p>That’s it!</p>
<ol>
<li value="4">Now, let’s use the code that we created in <a href="B19145_05.xhtml#_idTextAnchor086"><em class="italic">Chapter 5</em></a>, <em class="italic">Retrieving and Handling Market Data with Python</em>. It already contains the global queue (data stream) that can be used to transfer any data from any object or module to any other. All we want now is to add two functions: one that reads data from a compressed file (bars) and sends it to the global data stream, and the other that reads bars from this data stream and pushes them to the sliding window:<pre class="source-code">
def get_sample(f):</pre><pre class="source-code">
    sample = {}</pre><pre class="source-code">
    values = f.readline().rstrip("\n").split(",")</pre><pre class="source-code">
    timestamp_string = "0" + values[0] + " " + values[1]</pre><pre class="source-code">
    ts = datetime.strptime(timestamp_string, "%m/%d/%Y %H:%M:%S")</pre><pre class="source-code">
    sample["open"] = float(values[2])</pre><pre class="source-code">
    sample["high"] = float(values[3])</pre><pre class="source-code">
    sample["low"]  = float(values[4])</pre><pre class="source-code">
    sample["close"]= float(values[5])</pre><pre class="source-code">
    sample["UpVolume"] = int(values[6])</pre><pre class="source-code">
    sample["DownVolume"] = int(values[7])</pre><pre class="source-code">
    sample["Datetime"] = ts</pre><pre class="source-code">
    return sample</pre></li>
</ol>
<p>You can see that we have completely reused the function that we created in <a href="B19145_05.xhtml#_idTextAnchor086"><em class="italic">Chapter 5</em></a>, <em class="italic">Retrieving and Handling Market Data with Python</em>, when we learned how <a id="_idIndexMarker473"/>to handle data stored in files. Here, we read a bar from a CSV ASCII file, parse it, and convert it into a dictionary.</p>
<ol>
<li value="5">Now, let’s <a id="_idIndexMarker474"/>send this sample to the global queue:<pre class="source-code">
def emulate_bar_stream():</pre><pre class="source-code">
    while True:</pre><pre class="source-code">
        time.sleep(1)</pre><pre class="source-code">
        datastream.put(get_sample(f))</pre></li>
</ol>
<p>Again, this is similar to what we did in the previous chapter, the only difference is that we now use a different function that gets data from a file. Anyway, the result is the same: we put the new sample into the global data stream.</p>
<p class="callout-heading">Note</p>
<p class="callout">Don’t forget that the delay here is added only for the sake of debugging and demonstration to emulate samples arriving at the application one by one.</p>
<p>Now, we have finished the code that emulates the incoming data. Let’s look at it: any code written from this point and retrieving data from the global queue will be <em class="italic">independent</em> of any particular data source. If you want to replace the source or<a id="_idIndexMarker475"/> switch from testing to live trading, then all you need to do is to re-write the <code>emulate_bar_stream()</code> function. The rest of the code will remain unchanged.</p>
<p>Finally, we need a function that reads from the global data queue and does something meaningful.</p>
<ol>
<li value="6">In our <a id="_idIndexMarker476"/>present case, we will take only the closing price of the bar, push it to the sliding window, and then call any function that calculates a TA indicator:<pre class="source-code">
def retrieve_bars():</pre><pre class="source-code">
    while True:</pre><pre class="source-code">
        sw.add(datastream.get()["close"])</pre><pre class="source-code">
        # calling a TA indicator function here</pre><pre class="source-code">
        print(sw.data)</pre></li>
</ol>
<p>Making output to the console from a function is definitely a bad practice, but it’s added here only temporarily, to quickly check the correctness of the code during debugging.</p>
<ol>
<li value="7">Now, let’s start two threads: one that reads data from a file (or, in the future, from any other source) and the other that processes the received data. Don’t forget to import the <code>threading</code> module:<pre class="source-code">
import threading</pre><pre class="source-code">
data_source_thread = threading.Thread(target = emulate_bar_stream)</pre><pre class="source-code">
data_receiver_thread = threading.Thread(target = retrieve_bars)</pre><pre class="source-code">
data_source_thread.start()</pre><pre class="source-code">
data_receiver_thread.start()</pre></li>
</ol>
<p>If you did everything correctly, you should see something like this in the console:</p>
<pre class="source-code">
[0, 0, 0, 0, 1.12949]
[0, 0, 0, 1.12949, 1.12941]
[0, 0, 1.12949, 1.12941, 1.12965]
[0, 1.12949, 1.12941, 1.12965, 1.12883]
[1.12949, 1.12941, 1.12965, 1.12883, 1.12894]
[1.12941, 1.12965, 1.12883, 1.12894, 1.12925]</pre>
<p>You can see <a id="_idIndexMarker477"/>now how our sliding window is <a id="_idIndexMarker478"/>being filled with values from right to left, pushing older values out – <em class="italic">exactly</em> like a bar or tick chart on screen. So at any given moment, we have a <em class="italic">ready</em> sliding window of the specified length filled with any data we need to calculate an indicator – or to do any other thing we only could imagine.</p>
<p>Let’s now see how easily we can build indicators using this approach.</p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor127"/>Moving average – implementation</h2>
<p>To<a id="_idIndexMarker479"/> calculate an MA with our <a id="_idIndexMarker480"/>setup, we only need to calculate an average of all values in the window:</p>
<pre class="source-code">
def moving_average(data):
    return sum(data) / len(data)</pre>
<p>It is indeed that simple! We don’t have to worry about any parameters because we already specified the length of the sliding window when we instantiated from the <code>sliding_window</code> class and specified the type of data (in our example, closing prices) when we fill the window with data.</p>
<p>If we run our program now, we will get something like the following:</p>
<pre class="source-code">
0.225898
0.45178
0.67771
0.903476
1.129264
1.129216
1.129208</pre>
<p>This<a id="_idIndexMarker481"/> explains why we always <a id="_idIndexMarker482"/>disregard the first <em class="italic">N-1</em> values from a sliding window with a length of <em class="italic">N</em>; until <em class="italic">all</em> elements of the window are filled with meaningful data, the indicator’s value is meaningless and should be ignored. So, since in our example <em class="italic">N == 5</em>, we disregard the first 4 values.</p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor128"/>Stochastic oscillator – implementation</h2>
<p>Let’s now<a id="_idIndexMarker483"/> see how we calculate <a id="_idIndexMarker484"/>a range indicator like a stochastic oscillator. Since this indicator requires three values per bar (<code>high</code>, <code>low</code>, and <code>close</code>), we may want to modify our code slightly:</p>
<ol>
<li value="1">First, let’s replace the generic name of our sliding window from <code>sw</code> to <code>close</code> and add two more sliding windows for highs and lows:<pre class="source-code">
close = sliding_window(5)</pre><pre class="source-code">
high = sliding_window(5)</pre><pre class="source-code">
low = sliding_window(5)</pre></li>
<li>Now, let’s write the function that calculates the stochastic indicator:<pre class="source-code">
def stochastic(high, low, close):</pre><pre class="source-code">
    max_price = max(high)</pre><pre class="source-code">
    min_price = min(low)</pre><pre class="source-code">
    return (close[-1] - min_price) / (max_price - min_price)</pre></li>
</ol>
<p>Here, <code>close[-1]</code> stands for the last available closing price (the one we will just receive if we run the code in real time).</p>
<ol>
<li value="3">And <a id="_idIndexMarker485"/>finally, let’s slightly modify the <code>retrieve_bars()</code> function so it adds data points to all <a id="_idIndexMarker486"/>three sliding windows (<code>high</code>, <code>low</code>, and <code>close</code>) and calculates the values of the stochastic indicator:<pre class="source-code">
def retrieve_bars():</pre><pre class="source-code">
    while True:</pre><pre class="source-code">
        data_point = datastream.get()</pre><pre class="source-code">
        close.add(data_point["close"])</pre><pre class="source-code">
        high.add(data_point["high"])</pre><pre class="source-code">
        low.add(data_point["low"])</pre><pre class="source-code">
        ma = moving_average(close.data)</pre><pre class="source-code">
        stoch = stochastic(high.data, low.data,</pre><pre class="source-code">
                           close.data)</pre><pre class="source-code">
        print(close.data[-1], ma, stoch)</pre></li>
</ol>
<p>If we run our code now, we will get something similar to the following:</p>
<pre class="source-code">
(1.12949, 0.22589800000000002, 0.9999911465250112)
(1.12941, 0.45178, 0.9998406501473985)
(1.12965, 0.67771, 0.9999557404620697)
(1.12883, 0.9034760000000001, 0.9992298840400107)
(1.12894, 1.129264, 0.1914893617022131)
(1.12925, 1.129216, 0.5212765957448215)
(1.12937, 1.129208, 0.6489361702128061)</pre>
<p>Again, as always, we <a id="_idIndexMarker487"/>should <a id="_idIndexMarker488"/>disregard the first <em class="italic">N-1</em> values, so reasonable readings start from <em class="italic">line 5</em>.</p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor129"/>Summary</h1>
<p>Well, it’s been a long and – I hope – interesting trip, so it’s time now to summarize what we learned.</p>
<p>Technical analysis assumes that price includes everything in itself and attempts to find repeating patterns of behavior, suggesting that the price action following a similar pattern will also be similar to what already happened in the past.</p>
<p>There are just four major classes of technical studies, despite their visual diversity at first glance: market speed or momentum, digital filters, range, and volatility. Each type of study can be used to detect a certain situation in the market, but none of them can produce a ready profitable trading strategy on its own.</p>
<p>The cornerstone of all technical studies is the sliding window, and the bane of technical trading is peeking ahead during development and testing. Using queues to emulate incoming data streams and to organize sliding windows solves the problem of peeking ahead once and for all.</p>
<p>Besides that, this approach makes your application scalable, flexible, and modular with the ability to connect to a live data source after testing without rewriting your trading code.</p>
<p>Now that we have plenty of data points, we definitely want to visualize all of them to be able to quickly check the results or even trade live. So, let’s move on to the next chapter.</p>
</div>
</body></html>