["```py\n# decorators/time.measure.start.py\nfrom time import sleep, time\ndef f():\n    sleep(0.3)\ndef g():\n    sleep(0.5)\nt = time()\nf()\nprint(\"f took:\", time() - t)  # f took: 0.3028988838195801\nt = time()\ng()\nprint(\"g took:\", time() - t)  # g took: 0.507941722869873 \n```", "```py\n# decorators/time.measure.dry.py\nfrom time import sleep, time\ndef f():\n    sleep(0.3)\ndef g():\n    sleep(0.5)\ndef measure(func):\n    t = time()\n    func()\n    print(func.__name__, \"took:\", time() - t)\nmeasure(f)  # f took: 0.3043971061706543\nmeasure(g)  # g took: 0.5050859451293945 \n```", "```py\n# decorators/time.measure.arguments.py\nfrom time import sleep, time\ndef f(sleep_time=0.1):\n    sleep(sleep_time)\ndef measure(func, *args, **kwargs):\n    t = time()\n    func(*args, **kwargs)\n    print(func.__name__, \"took:\", time() - t)\nmeasure(f, sleep_time=0.3)  # f took: 0.30092811584472656\nmeasure(f, 0.2)  # f took: 0.20505475997924805 \n```", "```py\n# decorators/time.measure.deco1.py\nfrom time import sleep, time\ndef f(sleep_time=0.1):\n    sleep(sleep_time)\ndef measure(func):\n    def wrapper(*args, **kwargs):\n        t = time()\n        func(*args, **kwargs)\n        print(func.__name__, \"took:\", time() - t)\n    return wrapper\nf = measure(f)  # decoration point\nf(0.2)  # f took: 0.20128178596496582\nf(sleep_time=0.3)  # f took: 0.30509519577026367\nprint(f.__name__)  # wrapper  <- ouch! \n```", "```py\n# decorators/syntax.py\ndef func(arg1, arg2, ...):\n    pass\nfunc = decorator(func)\n# is equivalent to the following:\n@decorator\ndef func(arg1, arg2, ...):\n    pass \n```", "```py\n# decorators/syntax.py\ndef func(arg1, arg2, ...):\n    pass\nfunc = deco1(deco2(func))\n# is equivalent to the following:\n@deco1\n@deco2\ndef func(arg1, arg2, ...):\n    pass \n```", "```py\n# decorators/time.measure.deco1.py\ndef measure(func):\n    def wrapper(*args, **kwargs):\n        …\n    return wrapper\nf = measure(f)  # decoration point\n**print****(f.__name__)** **# wrapper  <- ouch!** \n```", "```py\n# decorators/time.measure.deco2.py\nfrom time import sleep, time\n**from** **functools** **import** **wraps**\ndef measure(func):\n    **@wraps(****func****)**\n    def wrapper(*args, **kwargs):\n        t = time()\n        func(*args, **kwargs)\n        print(func.__name__, \"took:\", time() - t)\n    return wrapper\n@measure\ndef f(sleep_time=0.1):\n    \"\"\"I'm a cat. I love to sleep!\"\"\"\n    sleep(sleep_time)\nf(sleep_time=0.3)  # f took: 0.30042004585266113\nprint(f.__name__)  # f\nprint(f.__doc__ )  # I'm a cat. I love to sleep! \n```", "```py\n# decorators/two.decorators.py\nfrom time import time\nfrom functools import wraps\ndef measure(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        t = time()\n        result = func(*args, **kwargs)\n        print(func.__name__, \"took:\", time() - t)\n        return result\n    return wrapper\ndef max_result(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        result = func(*args, **kwargs)\n        if result > 100:\n            print(\n                f\"Result is too big ({result}). \"\n                \"Max allowed is 100.\"\n            )\n        return result\n    return wrapper\n@measure\n@max_result\ndef cube(n):\n    return n**3\nprint(cube(2))\nprint(cube(5)) \n```", "```py\n$ python two.decorators.py\ncube took: 9.5367431640625e-07\n8\nResult is too big (125). Max allowed is 100.\ncube took: 3.0994415283203125e-06\n125 \n```", "```py\n# decorators/syntax.py\ndef func(arg1, arg2, ...):\n    pass\nfunc = decoarg(arg_a, arg_b)(func)\n# is equivalent to the following:\n@decoarg(arg_a, arg_b)\ndef func(arg1, arg2, ...):\n    pass \n```", "```py\n# decorators/decorators.factory.py\nfrom functools import wraps\ndef max_result(threshold):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            result = func(*args, **kwargs)\n            if result > threshold:\n                print(\n                    f\"Result is too big ({result}).\"\n                    f\"Max allowed is {threshold}.\"\n                )\n            return result\n        return wrapper\n    return decorator\n@max_result(75)\ndef cube(n):\n    return n**3 \n```", "```py\n$ python decorators.factory.py\nResult is too big (125). Max allowed is 75.\n125 \n```", "```py\n# decorators/decorators.factory.py\n@max_result(**75**)\ndef cube(n):\n    return n**3\n@max_result(**100**)\ndef square(n):\n    return n**2\n@max_result(**1000**)\ndef multiply(a, b):\n    return a * b \n```", "```py\n# oop/simplest.class.py\nclass Simplest:\n    pass\nprint(type(Simplest))  # **what type is this object?**\nsimp = Simplest()  # we create an instance of Simplest: simp\nprint(type(simp))  # what type is simp?\n# is simp an instance of Simplest?\nprint(type(simp) is Simplest)  # There's a better way to do this \n```", "```py\n$ python simplest.class.py\n<class 'type'>\n<class '__main__.Simplest'>\nTrue \n```", "```py\n# oop/class.namespaces.py\nclass Person:\n    species = \"Human\"\nprint(Person.species)  # Human\nPerson.alive = True  # Added dynamically!\nprint(Person.alive)  # True\nman = Person()\nprint(man.species)  # Human (inherited)\nprint(man.alive)  # True (inherited)\nPerson.alive = False\nprint(man.alive)  # False (inherited)\nman.name = \"Darth\"\nman.surname = \"Vader\"\nprint(man.name, man.surname)  # Darth Vader \n```", "```py\n# oop/class.attribute.shadowing.py\nclass Point:\n    x = 10\n    y = 7\np = Point()\nprint(p.x)  # 10 (from class attribute)\nprint(p.y)  # 7 (from class attribute)\np.x = 12  # p gets its own `x` attribute\nprint(p.x)  # 12 (now found on the instance)\nprint(Point.x)  # 10 (class attribute still the same)\ndel p.x  # we delete instance attribute\nprint(p.x)  # 10 (now search has to go again to find class attr)\np.z = 3  # let's make it a 3D point\nprint(p.z)  # 3\nprint(Point.z)\n# AttributeError: type object 'Point' has no attribute 'z' \n```", "```py\n# oop/class.self.py\nclass Square:\n    side = 8\n    def area(self):  # self is a reference to an instance\n        return self.side**2\nsq = Square()\nprint(sq.area())  # 64 (side is found on the class)\nprint(Square.area(sq))  # 64 (equivalent to sq.area())\nsq.side = 10\nprint(sq.area())  # 100 (side is found on the instance) \n```", "```py\n# oop/class.price.py\nclass Price:\n    def final_price(self, vat, discount=0):\n        \"\"\"Returns price after applying vat and fixed discount.\"\"\"\n        return (self.net_price * (100 + vat) / 100) - discount\np1 = Price()\np1.net_price = 100\nprint(Price.final_price(p1, 20, 10))  # 110 (100 * 1.2 - 10)\nprint(p1.final_price(20, 10))  # equivalent \n```", "```py\n# oop/class.init.py\nclass Rectangle:\n    def __init__(self, side_a, side_b):\n        self.side_a = side_a\n        self.side_b = side_b\n    def area(self):\n        return self.side_a * self.side_b\nr1 = Rectangle(10, 4)\nprint(r1.side_a, r1.side_b)  # 10 4\nprint(r1.area())  # 40\nr2 = Rectangle(7, 3)\nprint(r2.area())  # 21 \n```", "```py\n# oop/class_inheritance.py\nclass Engine:\n    def start(self):\n        pass\n    def stop(self):\n        pass\nclass ElectricEngine(Engine):  # Is-A Engine\n    pass\nclass V8Engine(Engine):  # Is-A Engine\n    pass \n```", "```py\nclass Car:\n    engine_cls = Engine\n    def __init__(self):\n        self.engine = self.engine_cls()  # Has-A Engine\n    def start(self):\n        print(\n            f\"Starting {self.engine.__class__.__name__} for \"\n            f\"{self.__class__.__name__}... Wroom, wroom!\"\n        )\n        self.engine.start()\n    def stop(self):\n        self.engine.stop()\nclass RaceCar(Car):  # Is-A Car\n    engine_cls = V8Engine\nclass CityCar(Car):  # Is-A Car\n    engine_cls = ElectricEngine\nclass F1Car(RaceCar):  # Is-A RaceCar and also Is-A Car\n    pass  # engine_cls same as parent\ncar = Car()\nracecar = RaceCar()\ncitycar = CityCar()\nf1car = F1Car()\ncars = [car, racecar, citycar, f1car]\nfor car in cars:\n    car.start() \n```", "```py\n$ python class_inheritance.py\nStarting Engine for Car... Wroom, wroom!\nStarting V8Engine for RaceCar... Wroom, wroom!\nStarting ElectricEngine for CityCar... Wroom, wroom!\nStarting V8Engine for F1Car... Wroom, wroom! \n```", "```py\n# oop/class.issubclass.isinstance.py\nfrom class_inheritance import Car, RaceCar, F1Car\ncar = Car()\nracecar = RaceCar()\nf1car = F1Car()\ncars = [(car, \"car\"), (racecar, \"racecar\"), (f1car, \"f1car\")]\ncar_classes = [Car, RaceCar, F1Car]\nfor car, car_name in cars:\n    for class_ in car_classes:\n        belongs = isinstance(car, class_)\n        msg = \"is a\" if belongs else \"is not a\"\n        print(car_name, msg, class_.__name__)\n\"\"\" Prints:\n… (starting enging messages omitted)\n**car** **is** **a Car**\ncar is not a RaceCar\ncar is not a F1Car\n**racecar** **is** **a Car**\n**racecar** **is** **a RaceCar**\nracecar is not a F1Car\n**f1car** **is** **a Car**\n**f1car** **is** **a RaceCar**\n**f1car** **is** **a F1Car**\n\"\"\" \n```", "```py\n# oop/class.issubclass.isinstance.py\nfor class1 in car_classes:\n    for class2 in car_classes:\n        is_subclass = issubclass(class1, class2)\n        msg = \"{0} a subclass of\".format(\n            \"is\" if is_subclass else \"is not\"\n        )\n        print(class1.__name__, msg, class2.__name__)\n\"\"\" Prints:\n**Car** **is** **a subclass of Car**\nCar is not a subclass of RaceCar\nCar is not a subclass of F1Car\n**RaceCar** **is** **a subclass of Car**\n**RaceCar** **is** **a subclass of RaceCar**\nRaceCar is not a subclass of F1Car\n**F1Car** **is** **a subclass of Car**\n**F1Car** **is** **a subclass of RaceCar**\n**F1Car** **is** **a subclass of F1Car**\n\"\"\" \n```", "```py\n# oop/super.duplication.py\nclass Book:\n    def __init__(self, title, publisher, pages):\n        self.title = title\n        self.publisher = publisher\n        self.pages = pages\nclass Ebook(Book):\n    def __init__(self, title, publisher, pages, format_):\n        self.title = title\n        self.publisher = publisher\n        self.pages = pages\n        self.format_ = format_ \n```", "```py\n# oop/super.explicit.py\nclass Book:\n    def __init__(self, title, publisher, pages):\n        self.title = title\n        self.publisher = publisher\n        self.pages = pages\nclass Ebook(Book):\n    def __init__(self, title, publisher, pages, format_):\n        Book.__init__(self, title, publisher, pages)\n        self.format_ = format_\nebook = Ebook(\n    \"Learn Python Programming\", \"Packt Publishing\", 500, \"PDF\"\n)\nprint(ebook.title)  # Learn Python Programming\nprint(ebook.publisher)  # Packt Publishing\nprint(ebook.pages)  # 500\nprint(ebook.format_)  # PDF \n```", "```py\n# oop/super.implicit.py\nclass Book:\n    def __init__(self, title, publisher, pages):\n        self.title = title\n        self.publisher = publisher\n        self.pages = pages\nclass Ebook(Book):\n    def __init__(self, title, publisher, pages, format_):\n        super().__init__(title, publisher, pages)\n        # Another way to do the same thing is:\n        # super(Ebook, self).__init__(title, publisher, pages)\n        self.format_ = format_\nebook = Ebook(\n    \"Learn Python Programming\", \"Packt Publishing\", 500, \"PDF\"\n)\nprint(ebook.title)  # Learn Python Programming\nprint(ebook.publisher)  # Packt Publishing\nprint(ebook.pages)  # 500\nprint(ebook.format_)  # PDF \n```", "```py\n# oop/multiple.inheritance.py\nclass Shape:\n    geometric_type = \"Generic Shape\"\n    def area(self):  # This acts as placeholder for the interface\n        raise NotImplementedError\n    def get_geometric_type(self):\n        return self.geometric_type\nclass Plotter:\n    def plot(self, ratio, topleft):\n        # Imagine some nice plotting logic here...\n        print(\"Plotting at {}, ratio {}.\".format(topleft, ratio))\nclass Polygon(Shape, Plotter):  # base class for polygons\n    geometric_type = \"Polygon\"\nclass RegularPolygon(Polygon):  # Is-A Polygon\n    geometric_type = \"Regular Polygon\"\n    def __init__(self, side):\n        self.side = side\nclass RegularHexagon(RegularPolygon):  # Is-A RegularPolygon\n    geometric_type = \"RegularHexagon\"\n    def area(self):\n        return 1.5 * (3**0.5 * self.side**2)\nclass Square(RegularPolygon):  # Is-A RegularPolygon\n    geometric_type = \"Square\"\n    def area(self):\n        return self.side * self.side\nhexagon = RegularHexagon(10)\nprint(hexagon.area())  # 259.8076211353316\nprint(hexagon.get_geometric_type())  # RegularHexagon\nhexagon.plot(0.8, (75, 77))  # Plotting at (75, 77), ratio 0.8.\nsquare = Square(12)\nprint(square.area())  # 144\nprint(square.get_geometric_type())  # Square\nsquare.plot(0.93, (74, 75))  # Plotting at (74, 75), ratio 0.93. \n```", "```py\n# oop/multiple.inheritance.py\nprint(square.__class__.__mro__)\n# prints:\n# (<class '__main__.Square'>, <class '__main__.RegularPolygon'>,\n#  <class '__main__.Polygon'>, <class '__main__.Shape'>,\n#  <class '__main__.Plotter'>, <class 'object'>) \n```", "```py\n# oop/mro.simple.py\nclass A:\n    label = \"a\"\nclass B(A):\n    label = \"b\"\nclass C(A):\n    label = \"c\"\nclass D(B, C):\n    pass\nd = D()\nprint(d.label)  # Hypothetically this could be either 'b' or 'c' \n```", "```py\n# oop/mro.py\nclass A:\n    label = \"a\"\nclass B(A):\n    pass  # was: label = 'b'\nclass C(A):\n    label = \"c\"\nclass D(B, C):\n    pass\nd = D()\nprint(d.label)  # 'c'\nprint(d.__class__.mro())  # notice another way to get the MRO\n# prints:\n# [<class '__main__.D'>, <class '__main__.B'>,\n#  <class '__main__.C'>, <class '__main__.A'>, <class 'object'>] \n```", "```py\n# oop/static.methods.py\nclass StringUtil:\n    @staticmethod\n    def is_palindrome(s, case_insensitive=True):\n        # we allow only letters and numbers\n        s = \"\".join(c for c in s if c.isalnum())  # Study this!\n        # For case insensitive comparison, we lower-case s\n        if case_insensitive:\n            s = s.lower()\n        for c in range(len(s) // 2):\n            if s[c] != s[-c - 1]:\n                return False\n        return True\n    @staticmethod\n    def get_unique_words(sentence):\n        return set(sentence.split())\nprint(\n    StringUtil.is_palindrome(\"Radar\", case_insensitive=False)\n)  # False: Case Sensitive\nprint(StringUtil.is_palindrome(\"A nut for a jar of tuna\"))  # True\nprint(StringUtil.is_palindrome(\"Never Odd, Or Even!\"))  # True\nprint(\n    StringUtil.is_palindrome(\n        \"In Girum Imus Nocte Et Consumimur Igni\"\n    )  # Latin palindrome\n)  # True\nprint(\n    StringUtil.get_unique_words(\n        \"I love palindromes. I really really love them!\"\n    )\n)\n# {'them!', 'palindromes.', 'I', 'really', 'love'} \n```", "```py\n# oop/class.methods.factory.py\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    @classmethod\n    def from_tuple(cls, coords):  # cls is Point\n        return cls(*coords)\n    @classmethod\n    def from_point(cls, point):  # cls is Point\n        return cls(point.x, point.y)\np = Point.from_tuple((3, 7))\nprint(p.x, p.y)  # 3 7\nq = Point.from_point(p)\nprint(q.x, q.y)  # 3 7 \n```", "```py\n# oop/class.methods.split.py\nclass StringUtil:\n    @classmethod\n    def is_palindrome(cls, s, case_insensitive=True):\n        s = cls._strip_string(s)\n        # For case insensitive comparison, we lower-case s\n        if case_insensitive:\n            s = s.lower()\n        return cls._is_palindrome(s)\n    @staticmethod\n    def _strip_string(s):\n        return \"\".join(c for c in s if c.isalnum())\n    @staticmethod\n    def _is_palindrome(s):\n        for c in range(len(s) // 2):\n            if s[c] != s[-c - 1]:\n                return False\n        return True\n    @staticmethod\n    def get_unique_words(sentence):\n        return set(sentence.split())\nprint(StringUtil.is_palindrome(\"radar\"))  # True\nprint(StringUtil.is_palindrome(\"not a palindrome\"))  # False \n```", "```py\n# oop/private.attrs.py\nclass A:\n    def __init__(self, factor):\n        self._factor = factor\n    def op1(self):\n        print(\"Op1 with factor {}...\".format(self._factor))\nclass B(A):\n    def op2(self, factor):\n        self._factor = factor\n        print(\"Op2 with factor {}...\".format(self._factor))\nobj = B(100)\nobj.op1()  # Op1 with factor 100...\nobj.op2(42)  # Op2 with factor 42...\nobj.op1()  # Op1 with factor 42...  <- This is BAD \n```", "```py\n# oop/private.attrs.fixed.py\nclass A:\n    def __init__(self, factor):\n        self.__factor = factor\n    def op1(self):\n        print(\"Op1 with factor {}...\".format(self.__factor))\nclass B(A):\n    def op2(self, factor):\n        self.__factor = factor\n        print(\"Op2 with factor {}...\".format(self.__factor))\nobj = B(100)\nobj.op1()  # Op1 with factor 100...\nobj.op2(42)  # Op2 with factor 42...\nobj.op1()  # Op1 with factor 100...  <- Now it's good! \n```", "```py\n# oop/private.attrs.py\nprint(obj.__dict__.keys())\n# dict_keys(['_factor']) \n```", "```py\n# oop/private.attrs.fixed.py\nprint(obj.__dict__.keys())\n# dict_keys(['_A__factor', '_B__factor']) \n```", "```py\n# oop/property.py\nclass Person:\n    def __init__(self, age):\n        self.age = age  # anyone can modify this freely\nclass PersonWithAccessors:\n    def __init__(self, age):\n        self._age = age\n    def get_age(self):\n        return self._age\n    def set_age(self, age):\n        if 18 <= age <= 99:\n            self._age = age\n        else:\n            raise ValueError(\"Age must be within [18, 99]\")\nclass PersonPythonic:\n    def __init__(self, age):\n        self._age = age\n    @property\n    def age(self):\n        return self._age\n    @age.setter\n    def age(self, age):\n        if 18 <= age <= 99:\n            self._age = age\n        else:\n            raise ValueError(\"Age must be within [18, 99]\")\nperson = PersonPythonic(39)\nprint(person.age)  # 39 - Notice we access as data attribute\nperson.age = 42  # Notice we access as data attribute\nprint(person.age)  # 42\nperson.age = 100  # ValueError: Age must be within [18, 99] \n```", "```py\n# oop/cached.property.py\nclass Client:\n    def __init__(self):\n        print(\"Setting up the client...\")\n    def query(self, **kwargs):\n        print(f\"Performing a query: {kwargs}\")\nclass Manager:\n    @property\n    def client(self):\n        return Client()\n    def perform_query(self, **kwargs):\n        return self.client.query(**kwargs) \n```", "```py\n# oop/cached.property.py\nclass ManualCacheManager:\n    @property\n    def client(self):\n        if not hasattr(self, \"_client\"):\n            self._client = Client()\n        return self._client\n    def perform_query(self, **kwargs):\n        return self.client.query(**kwargs) \n```", "```py\n# oop/cached.property.py\nfrom functools import cached_property\nclass CachedPropertyManager:\n    @cached_property\n    def client(self):\n        return Client()\n    def perform_query(self, **kwargs):\n        return self.client.query(**kwargs)\nmanager = CachedPropertyManager()\nmanager.perform_query(object_id=42)\nmanager.perform_query(name_ilike=\"%Python%\")\ndel manager.client  # This causes a new Client on next call\nmanager.perform_query(age_gte=18) \n```", "```py\n$ python cached.property.py\nSetting up the client...                         # New Client\nPerforming a query: {'object_id': 42}            # first query\nPerforming a query: {'name_ilike': '%Python%'}   # second query\nSetting up the client...                         # Another Client\nPerforming a query: {'age_gte': 18}              # Third query \n```", "```py\n# oop/operator.overloading.py\nclass Weird:\n    def __init__(self, s):\n        self._s = s\n    def __len__(self):\n        return len(self._s)\n    def __bool__(self):\n        return \"42\" in self._s\nweird = Weird(\"Hello! I am 9 years old!\")\nprint(len(weird))  # 24\nprint(bool(weird))  # False\nweird2 = Weird(\"Hello! I am 42 years old!\")\nprint(len(weird2))  # 25\nprint(bool(weird2))  # True \n```", "```py\n# oop/dataclass.py\nfrom dataclasses import dataclass\n@dataclass\nclass Body:\n    \"\"\"Class to represent a physical body.\"\"\"\n    name: str\n    mass: float = 0.0  # Kg\n    speed: float = 1.0  # m/s\n    def kinetic_energy(self) -> float:\n        return (self.mass * self.speed**2) / 2\nbody = Body(\"Ball\", 19, 3.1415)\nprint(body.kinetic_energy())  # 93.755711375 Joule\nprint(body)  # Body(name='Ball', mass=19, speed=3.1415) \n```", "```py\n# iterators/iterator.py\nclass OddEven:\n    def __init__(self, data):\n        self._data = data\n        self.indexes = list(range(0, len(data), 2)) + list(\n            range(1, len(data), 2)\n        )\n    def __iter__(self):\n        return self\n    def __next__(self):\n        if self.indexes:\n            return self._data[self.indexes.pop(0)]\n        raise StopIteration\noddeven = OddEven(\"0123456789\")\nprint(\"\".join(c for c in oddeven))  # 0246813579\noddeven = OddEven(\"ABCD\")  # or manually...\nit = iter(oddeven)  # this calls oddeven.__iter__ internally\nprint(next(it))  # A\nprint(next(it))  # C\nprint(next(it))  # B\nprint(next(it))  # D \n```"]