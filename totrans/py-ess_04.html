<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Variables, Assignment and Scoping Rules"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Variables, Assignment and Scoping Rules</h1></div></div></div><p>An expression creates objects; we can assign objects to variables to preserve them for future use. Python offers a number of variations on the theme of assignment. In addition to simply assigning a single variable, we can assign items from a tuple to multiple variables. We can also combine an operator with assignment, which updates a mutable object.</p><p>In this chapter, we'll also look at the <code class="literal">input()</code> function as a way to introduce new objects into a running script. This is limited—it doesn't compare with a proper <span class="strong"><strong>graphical user interface</strong></span> (<span class="strong"><strong>GUI</strong></span>). It will, however, help us learn more Python programming techniques before we<a class="indexterm" id="id247"/> introduce how to read data from files and the filesystem in <a class="link" href="ch10.html" title="Chapter 10. Files, Databases, Networks, and Contexts">Chapter 10</a>, <span class="emphasis"><em>Files, Databases, Networks, and Contexts</em></span>.</p><p>We'll also look at some important Python language concepts. We'll look at the way Python programs are always written generically, without specific bindings to data types or classes. We'll also look at the general concept of a namespace, and how this is applied widely in various Python language constructs. It defines the scope in which an identifier is visible; something that will become increasingly important as our programs become more complex.</p><div class="section" title="Simple assignment and variables"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Simple assignment and variables</h1></div></div></div><p>We've seen<a class="indexterm" id="id248"/> a few examples of the essential Python assignment <a class="indexterm" id="id249"/>statement in previous chapters. The statement includes a variable, <code class="literal">=</code>, and an expression. Since a single object is an expression, we can write:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; pi = 3.14</pre></div><p>This will create the floating-point literal <code class="literal">3.14</code> and assign this object to a variable named <code class="literal">pi</code>.</p><p>Variable names must follow the rules in section 2.3, <span class="emphasis"><em>Identifiers and Keywords</em></span>, of the <span class="emphasis"><em>Python Language Reference</em></span>. The reference manual uses the Unicode character class definitions provided in the <code class="literal">unicodedata</code> module.</p><p>Interesting<a class="indexterm" id="id250"/> background information on the problem of programming<a class="indexterm" id="id251"/> language identifiers is available in Unicode Standard Annex 31, <span class="emphasis"><em>Unicode Identifier and Pattern Syntax</em></span>. This shows how the Python problem of how "what is an identifier?" fits into the larger context of other programming languages and the variety of natural languages used around the world.</p><p>In Python, identifiers have a small set of start characters; these are chosen to allow a lexical scanner to determine what kinds of characters can follow. If identifiers began with digits, it would be rather complex to distinguish identifiers from numbers. Consequently, identifiers must begin with a letter or <code class="literal">_</code>. After the initial character, Python allows an identifier to continue with characters that may come from a larger set of characters: letters, digits, and <code class="literal">_</code>.</p><p>What do we really mean by "letter" or "digit"? In earlier versions of Python, these terms were defined by the Latin-based ASCII alphabet. Using Unicode means that the terms now have more inclusive definitions.</p><p>Python defines the identifier starting character as belonging to the following Unicode categories: uppercase letters (<code class="literal">Lu</code>), lowercase letters (<code class="literal">Ll</code>), title case letters (<code class="literal">Lt</code>), modifier letters (<code class="literal">Lm</code>), other letters (<code class="literal">Lo</code>), and letter numbers (<code class="literal">Nl</code>). Python also includes the small set of characters in the <code class="literal">Other_ID_Start</code> category. The set of characters defined by these categories is large. Latin letters in the ranges <code class="literal">a-z</code> and <code class="literal">A-Z</code>, for example, are in this set. When writing more mathematically-oriented programs, the Greek letters <code class="literal">α-ω</code> and <code class="literal">A-Ω</code> can also be used as identifier start characters. We can write this:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; π = 355/113</pre></div><p>This assigns the result of the expression to the variable, <code class="literal">π</code>. Some programmers find that their OS keyboard interface makes letters outside a single national alphabet awkward to use; consequently, they suggest focusing on Latin letters for programming.</p><p>Identifiers can continue with any of the letters defined in the previous paragraph, the <code class="literal">_</code> character, and characters from the following categories: nonspacing marks (<code class="literal">Mn</code>), spacing combining marks (<code class="literal">Mc</code>), decimal numbers (<code class="literal">Nd</code>), and connector punctuations (<code class="literal">Pc</code>). This allows us to include ordinary decimal digits as well as other "combining" marks that modify the previous character. For example:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; <img alt="Simple assignment and variables" src="graphics/B03671_04_01_New.jpg"/>=p_2+0.5*p_1</pre></div><p>This <a class="indexterm" id="id252"/>shows the character <span class="strong"><strong>GREEK SMALL LETTER PI</strong></span> followed by the <span class="strong"><strong>COMBINING DIACRITICAL CIRCUMFLEX</strong></span> to create<a class="indexterm" id="id253"/> a "pi-hat" variable, <span class="inlinemediaobject"><img alt="Simple assignment and variables" src="graphics/B03671_04_01.jpg"/></span>. It may be awkward to type for some developers, but it also may fit nicely with a population genomics formulae which use this symbol combination. The Inheritance By Descent estimator, for example, uses <span class="inlinemediaobject"><img alt="Simple assignment and variables" src="graphics/B03671_04_01.jpg"/></span>. The expression shown earlier involves two other variables, <code class="literal">p_2</code> and <code class="literal">p_1</code>, which use more common Latin letters, <code class="literal">_,</code> and digits.</p><p>Note that variable names that begin and end with <code class="literal">__</code> (two underscores) are reserved by Python for special purposes. For example, we have global variables such as <code class="literal">__name__</code>, <code class="literal">__debug__</code>, and <code class="literal">__file__</code> which are set when our script starts running.</p><p>There's no <a class="indexterm" id="id254"/>reason for our application to ever create new names<a class="indexterm" id="id255"/> which begin and end with <code class="literal">__</code>. We're not prohibited from creating such variables, but any name that we might adopt could be used by some internal feature of Python.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>It's best to assume that at all names beginning and ending with <code class="literal">__</code> (double underscore) are reserved by Python and do something special. Even if the name is not used in the current release, that doesn't mean it won't be used in a future release.</p></div></div></div></div>
<div class="section" title="Multiple assignment"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Multiple assignment</h1></div></div></div><p>We looked<a class="indexterm" id="id256"/> at tuples in <a class="link" href="ch02.html" title="Chapter 2. Simple Data Types">Chapter 2</a>, <span class="emphasis"><em>Simple Data Types</em></span>. One of the important reasons for using a tuple is that it has a fixed number of items. Since a tuple is a kind of sequence, we can refer to items within a tuple using numeric indices.</p><p>Consider the following RGB triple:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; brick_red = (203, 65, 84)</pre></div><p>We can use <code class="literal">brick_red[0]</code> to get the red element of this triple.</p><p>We can also do this:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; r, g, b = brick_red
&gt;&gt;&gt; r
203</pre></div><p>We've used multiple assignment to decompose the RGB three-tuple into three individual variables.</p><p>This works when the number of variables on the left side of the <code class="literal">=</code> matches the number of items in the collection on the right side. When working with fixed-sized tuples, this is an easy condition to guarantee.</p><p>When working with mutable collections such as <code class="literal">list</code>, <code class="literal">set</code>, or <code class="literal">dict</code>, this kind of assignment may not work out well. If we can't guarantee the number of elements in a mutable collection, we may wind up with a <code class="literal">ValueError</code> exception because our collection doesn't match the number of variables.</p><p>Note that Python's syntax flexibility means that we can also do things like this:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; n, d = 355, 113</pre></div><p>It isn't absolutely<a class="indexterm" id="id257"/> necessary to wrap a tuple in <code class="literal">()</code>. It's generally a best practice to use <code class="literal">()</code> around a tuple. However, in a few cases, the statement is perfectly clear without the additional parentheses.</p><div class="section" title="Using repeated assignment"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec37"/>Using repeated assignment</h2></div></div></div><p>Python<a class="indexterm" id="id258"/> allows us to write statements<a class="indexterm" id="id259"/> like this: <code class="literal">a = b = 0</code>. This must be used carefully, because a single object is now shared by two variables. When working with immutable objects like numbers, strings, and tuples, multiple variables share a reference to a common object.</p><p>When we look at mutable objects in <a class="link" href="ch06.html" title="Chapter 6. More Complex Data Types">Chapter 6</a>, <span class="emphasis"><em>More Complex Data Types</em></span>, we'll see that this kind of repeated assignment can become a source of confusion. While this assignment is legal, it must be used only with immutable objects like numbers, strings, or tuples.</p></div></div>
<div class="section" title="Using the head, *tail assignment"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Using the head, *tail assignment</h1></div></div></div><p>When <a class="indexterm" id="id260"/>working with sequences, there are some algorithms which work by<a class="indexterm" id="id261"/> separating the head of the sequence from the rest of the sequence. We can do this with a variation on the assignment statement. We like to call this the <code class="literal">head, *tail =</code> assignment statement.</p><p>Let's say that we have an input string with a list of values, something like this:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; line = "255  73 108 Radical Red"
&gt;&gt;&gt; line.split()
['255', '73', '108', 'Radical', 'Red']</pre></div><p>We have split the string into space-delimited words with <code class="literal">line.split()</code>. In this case, the head of the list is the first three fields of the red, green, and blue elements of a color. The tail is all the remaining fields, which is the name parsed into separate words.</p><p>We can use <code class="literal">head, *tail =</code> assignment to split the first three fields from the remaining files. </p><p>It looks like this:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; r, g, b, *name = line.split()
&gt;&gt;&gt; g
'73'
&gt;&gt;&gt; name
['Radical', 'Red']</pre></div><p>We've assigned the first three items to three separate variables, <code class="literal">r</code>, <code class="literal">g</code>, and <code class="literal">b</code>. The <code class="literal">*</code> means that all of the remaining items will be collected into a single variable, <code class="literal">name</code>.</p><p>We can<a class="indexterm" id="id262"/> reconstruct the original name with the <code class="literal">join()</code> method, with a space<a class="indexterm" id="id263"/> as the separator string:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; " ".join(name)
'Radical Red'</pre></div><p>We've used a space to join the elements of the sequence named <code class="literal">name</code>. This will reconstruct the original color name as a single string instead of a list of words.</p></div>
<div class="section" title="Augmented assignment"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Augmented assignment</h1></div></div></div><p>The<a class="indexterm" id="id264"/> augmented assignment statement combines an operator with assignment. A common example is this:</p><div class="informalexample"><pre class="programlisting">a += 1</pre></div><p>This is equivalent to</p><div class="informalexample"><pre class="programlisting">a = a + 1</pre></div><p>When working with immutable objects (numbers, strings, and tuples) the idea of an augmented assignment is syntactic sugar. It allows us to write the updated variable just once. The statement <code class="literal">a += 1</code> always creates a fresh new number object, and replaces the value of <span class="emphasis"><em>a</em></span> with the new number object.</p><p>Any of the operators can be combined with assignment. The means that <code class="literal">+=</code>, <code class="literal">-=</code>, <code class="literal">*=</code>, <code class="literal">/=</code>, <code class="literal">//=</code>, <code class="literal">%=</code>, <code class="literal">**=</code>, <code class="literal">&gt;&gt;=</code>, <code class="literal">&lt;&lt;=</code>, <code class="literal">&amp;=</code>,<code class="literal">^=</code>, and <code class="literal">|=</code> are all assignment operators. We can see obvious parallels between sums using <code class="literal">+=</code>, and products using <code class="literal">*=</code>.</p><p>In the case of mutable objects, this augmented assignment can take on special significance. When we look at <code class="literal">list</code> objects in <a class="link" href="ch06.html" title="Chapter 6. More Complex Data Types">Chapter 6</a>, <span class="emphasis"><em>More Complex Data Types</em></span>, we'll see how we can append an item to a <code class="literal">list</code> object. Here's a forward-looking example:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; some_list = [1, 1, 2, 3]</pre></div><p>This assigns a <code class="literal">list</code> object, a variable-length sequence of items, to the variable <code class="literal">some_list</code>.</p><p>We can update this <code class="literal">list</code> object with an augmented assignment statement:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; some_list += [5]
&gt;&gt;&gt; some_list
[1, 1, 2, 3, 5]</pre></div><p>In this case, we're actually mutating a single <code class="literal">list</code> object, changing its internal state by extending it with items from another <code class="literal">list</code> instance. The existing object was updated; this does not create a new object. It is equivalent to using the <code class="literal">extend()</code> method:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; some_list.extend( [8] )
&gt;&gt;&gt; some_list
[1, 1, 2, 3, 5, 8]</pre></div><p>We've <a class="indexterm" id="id265"/>mutated the <code class="literal">list</code> object a second time, extending it with items from another single-item <code class="literal">list</code> object.</p><p>This optimization of a <code class="literal">list</code> object is something that we'll look at in <a class="link" href="ch06.html" title="Chapter 6. More Complex Data Types">Chapter 6</a>, <span class="emphasis"><em>More Complex Data Types</em></span>.</p></div>
<div class="section" title="The input() function"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec37"/>The input() function</h1></div></div></div><p>For simple<a class="indexterm" id="id266"/> applications, the <code class="literal">input()</code> function can be used to gather input from a user. This function writes a prompt and accepts input. The returned value is a string. We might use this in a script file as follows:</p><div class="informalexample"><pre class="programlisting">c= float(input("Temperature, C: "))
print("f =", 32+9*c/5)</pre></div><p>This will write a simple prompt on the console, and accept a string as input. The string value will be converted to a floating-point number, if possible. If the string is not a valid number, the <code class="literal">float()</code> function will raise an exception. This will then print a line of output.</p><p>Here's how it looks when we run it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>MacBookPro-SLott:Code slott$ python3 Chapter_4/ex_1.py</strong></span>
<span class="strong"><strong>Temperature, C: 11</strong></span>
<span class="strong"><strong>f = 51.8</strong></span>
</pre></div><p>We've highlighted the command, which is entered after the OS shell prompt. The statements in the script file, named as part of the command, are executed in order. </p><p>Our input to Python, <code class="literal">11</code>, is also highlighted, to show how the <code class="literal">input()</code> function supports simple interaction.</p><p>The <code class="literal">input()</code> function only returns a Unicode string. Our script is responsible for any further parsing, validation, or conversion.</p><p>When working on simple console applications, there are some additional libraries which may prove helpful. There is a <code class="literal">getpass</code> module which helps to get passwords by suppressing the character echo that's a default feature of console input. This is highly recommended as an alternative to plain passwords in a parameter file or the passwords provided on the command line.</p><p>We can include the <code class="literal">readline</code> module to provide a comprehensive history of input that makes it easier for interactive users to recover previous inputs. Additionally, the <code class="literal">rlcompleter</code> module can be used to provide auto-complete features so that users only need to enter partial commands.</p><p>Beyond this, Python can include an implementation of the Linux <code class="literal">curses</code> library for building richly interactive <span class="strong"><strong>character user interface</strong></span> (<span class="strong"><strong>CUI</strong></span>) applications. This is sometimes<a class="indexterm" id="id267"/> used to provide colored output on the console, something that can make a complex log easier to read.</p><p>Python is<a class="indexterm" id="id268"/> used in a wide variety of application contexts. When building a web server, for example, the idea of console or command-line input is utterly out of place. Similarly, the <code class="literal">input()</code> function isn't going to be part of a GUI application.</p></div>
<div class="section" title="Python language concepts"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Python language concepts</h1></div></div></div><p>We'll introduce<a class="indexterm" id="id269"/> a few central concepts of the Python language before looking at more complex examples in later chapters. The first of the central concepts is that everything in Python is an object. Several popular languages have <span class="strong"><strong>primitive</strong></span> types<a class="indexterm" id="id270"/> which escape the object-oriented nature of the language. Python doesn't have this feature. Even simple integers are objects, with defined methods.</p><p>Because everything is an object, we're assured of consistent behavior with no special cases. In some languages, the <code class="literal">==</code> operator works in one way for primitive types and in another way for objects. Python lacks this divergent behavior. All built-in classes implement the <code class="literal">==</code> operator consistently; unless we make specific (and pathological) implementation choices, our own classes will also behave consistently.</p><p>This consistency is particularly pleasant when working with strings. In Python, we always compare strings for equality using something like <code class="literal">txt.lower() = "hours"</code>. This will make the expected character-by-character comparison between the value of <code class="literal">txt.lower()</code> and the literal <code class="literal">"hours"</code>.</p><p>Less commonly, we can see if two variables are references to the same underlying object using the <code class="literal">is</code> comparison operator. This is generally used to compare a variable with the <code class="literal">None</code> object. We use <code class="literal">is None</code> because the <code class="literal">None</code> object is a proper singleton; there can be only one instance of <code class="literal">None</code>. We'll look at this again in <a class="link" href="ch05.html" title="Chapter 5. Logic, Comparisons, and Conditions">Chapter 5</a>, <span class="emphasis"><em>Logic, Comparisons, and Conditions</em></span>.</p><div class="section" title="Object types versus variable declarations"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec38"/>Object types versus variable declarations</h2></div></div></div><p>In <a class="indexterm" id="id271"/>Python, we specify the processing generically with respect to type. We may write a sequence of statements with the implicit understanding that floating-point values should be used. We can formalize this to an extent using an explicit <code class="literal">float()</code> conversion function.</p><p>In some languages, each variable has a statically defined type. Only objects of the named type can be assigned to the variable.</p><p>In contrast to languages with statically defined variables, a Python variable can be understood as a name which is attached to an object. We can attach a name to any object of any class. We don't statically declare a narrow range of allowed types for a variable.</p><p>Python<a class="indexterm" id="id272"/> allows us to assign multiple names to the same object by assigning the object to several variables. For example, when we evaluate a function, the function parameter variable names are assigned to the argument objects. (We'll look at this in more depth in <a class="link" href="ch07.html" title="Chapter 7. Basic Function Definitions">Chapter 7</a>, <span class="emphasis"><em>Basic Function Definitions</em></span>.) This means that each object may have two variables referring to it: one parameter variable inside the function and another variable outside the function.</p><p>We can use the internal <code class="literal">id()</code> function to see if two variables refer to the same underlying object:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; a = "string"
&gt;&gt;&gt; b = a
&gt;&gt;&gt; id(a)
4301974472
&gt;&gt;&gt; id(b)
4301974472</pre></div><p>From this, we can see that Python variables <code class="literal">a</code> and <code class="literal">b</code> have references to the underlying object, not copies of the object.</p><p>In the rare cases that object copying is necessary, we must do it explicitly. Details vary, based on the general kind of class. For example, sequences are trivially cloned by creating a slice that includes the entire sequence. Some classes offer a <code class="literal">copy()</code> method. Objects can also be cloned via functions in the <code class="literal">copy</code> library.</p><p>The lack of a fixed type declaration for a variable has several consequences:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It's trivial to introduce a variable to decompose a complex expression. Here's a complex expression:<div class="informalexample"><pre class="programlisting">a = some_function( some_complex_function( another_function( b ) ) )</pre></div></li><li class="listitem" style="list-style-type: disc">We can trivially rewrite this by pulling out subexpressions and assigning them to variables:<div class="informalexample"><pre class="programlisting">af = another_function(b)
scf = some_complex_function(af)
a = some_function(scf)</pre></div><p>We've extracted each subexpression and assigned them to separate variables. We never need to know what the intermediate result types are.</p></li><li class="listitem" style="list-style-type: disc">All algorithms are written generically. When we run a script, we apply our generic Python code to concrete objects. Our canonical example of this binding is based on the numeric tower. We can apply the same expression, <code class="literal">32+9*c/5</code>, to objects of the classes <code class="literal">complex</code>, <code class="literal">float</code>, <code class="literal">int</code>, <code class="literal">Decimal</code>, and <code class="literal">Fraction</code>. All of these classes provide the necessary implementations of the various operators. However, a string object won't implement all of the arithmetic operations required, and won't work. Similarly, we can execute statements like <code class="literal">head, *tail = sequence</code> for a wide variety of sequence-like classes, including <code class="literal">list</code>, <code class="literal">str</code>, <code class="literal">bytes</code>, and <code class="literal">tuple</code>. However, if we assign a numeric value to the variable named <code class="literal">sequence</code>, the statement won't work.</li></ul></div><p>Avoiding <a class="indexterm" id="id273"/>the declaration of variables with static types is a great simplification. We can introduce variables as needed. We can write clear, simple, generic software and leave it to the Python runtime processing to determine if the runtime objects have the required implementations for operators and methods.</p></div><div class="section" title="Avoiding confusion when naming variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec39"/>Avoiding confusion when naming variables</h2></div></div></div><p>Without <a class="indexterm" id="id274"/>variable declarations, there's a small possibility of creating programs which are confusing if we use vague, generic variables. A variable with a vague name like <code class="literal">list_of_items</code> might get used more than once in a longish sequence of statements. Worse, of course, are variables with names like <code class="literal">t</code> or <code class="literal">temp</code>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>Name variables as specifically as possible. Avoid vague, generic names.</p></div></div><p>The other aspect of overusing variable names is the idea of a "longish" sequence of statements. If the body of a function is so long that generically-named variables could get reused accidentally, the size of the function has become a problem. No stretch of Python code should be so long that the variables used within it are confusing.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>Keep sequences of code short and focused. Avoid long sequences of code where variables might get reused incorrectly.</p></div></div><p>It's import to name variables simply and clearly. In Python, the use of <span class="emphasis"><em>Hungarian notation</em></span> to decorate a variable name with type information is considered deplorable. The original concept of Hungarian notation was to place a few characters as a prefix on a variable to indicate the type. In Python, we do not name a variable <code class="literal">lst_str_names</code> using a prefix to indicate that the variable refers to a list of string values.</p><p>Because Python code is written generically, a well-written function can apply to many different data types. If we try to encode data type information in variable names, we may actually be sowing confusion: the algorithm may work for types not explicitly stated in the variable name.</p><p>In some<a class="indexterm" id="id275"/> situations, we need to distinguish between a collection of items and an individual item. We might have a <code class="literal">name_list</code> and an individual <code class="literal">name</code>. Or we might have a <code class="literal">name_iter</code>, when working with generator functions, and an individual <code class="literal">name</code>. A small, clear naming convention like this is better than elaborately misleading Hungarian notation.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>Avoid complex Hungarian notation in variable names.</p></div></div><p>In a more complex program, we might have a dictionary that maps integer keys to sets associated with those keys; each set may have a collection of individual strings. It's difficult to summarize this with a Hungarian prefix or suffix. Would we want to try and call this <code class="literal">map_int_set_str_something</code>?</p><p>Looking ahead to <a class="link" href="ch07.html" title="Chapter 7. Basic Function Definitions">Chapter 7</a>, <span class="emphasis"><em>Basic Function Definitions</em></span> and <a class="link" href="ch11.html" title="Chapter 11. Class Definitions">Chapter 11</a>, <span class="emphasis"><em>Class Definitions</em></span>, we'll often use <code class="literal">docstring</code> comments in functions, classes, and modules to capture the details of what kind of structure is appropriate for a function. We may even include test cases in the <code class="literal">docstring</code> comments; test cases are perhaps the clearest and most precise way to describe data.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>Write <code class="literal">docstring</code> comments in every context that allows them: function, class, module, and package.</p></div></div><p>One consequence of Python's use of variables is that we rely on unit test cases to ensure that results are of the expected types as well as being correct. Programmers who work in languages with statically-typed variables are very aware that unit test cases are essential for correctness, even when a compiler does type checking of all variable declarations. In Python, the test cases are just as important as in languages that have static type checking. If it is necessary to clarify the intent of a function or class, we can include type checking in the test cases.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip13"/>Tip</h3><p>Write unit tests; use the <code class="literal">unittest</code> module, the <code class="literal">doctest</code> module, or both.</p></div></div></div><div class="section" title="Garbage collection via reference counting"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec40"/>Garbage collection via reference counting</h2></div></div></div><p>We've <a class="indexterm" id="id276"/>seen how expressions create new objects. Even something as simple as <code class="literal">2**2024</code> creates a new integer object. What happens to these objects? When will we run out of memory?</p><p>Python uses reference counting to determine how many times an object is being used when we do something like this:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; 2**2024
192624...497216</pre></div><p>The resulting object is a very large integer; it is assigned to the variable <code class="literal">_</code> automatically. The object, shown as <code class="literal">192624...497216</code>, has a single reference; this keeps it alive in memory.</p><p>When we do this, next:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; 2**2025
385248...994432</pre></div><p>We get a new object, and it is assigned to the variable <code class="literal">_</code>. The large integer value formerly assigned to <code class="literal">_</code> has no more references. Since it's no longer being used, it's garbage, and the memory it occupied can be reused.</p><p>Each time we assign an object to a variable, the reference count goes up by one. Each time the variable's value is reassigned, the previous object that is no longer in use has its reference count decreased by one. </p><p>When a variable is no longer required, the variable is removed, and the objects referred to by the variable also have their reference counts reduced by one.</p><p>Variables belong to namespaces. Most of our early examples used the global namespace. In <a class="link" href="ch07.html" title="Chapter 7. Basic Function Definitions">Chapter 7</a>, <span class="emphasis"><em>Basic Function Definitions</em></span>, we'll see local namespaces. To summarize: when a namespace is removed, all of the variables in that namespace are removed, and all of the object references are decremented by one.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip14"/>Tip</h3><p>When the number of references to an object reaches zero, the object is no longer needed. The memory occupied by that object can be reclaimed.</p></div></div><p>We can easily create two complex objects which refer to each other. In the presence of these kinds of circular references, of course, the counts can never reach zero. The objects may never get removed from memory. We can use the <code class="literal">gc</code> module to discover more about this.</p><p>In the case where we must have objects with mutual references, we need to leverage the <code class="literal">weakref</code> module. This module provides references among objects that do not interfere with reference counting, allowing a large data structure of multiple objects to gracefully vanish<a class="indexterm" id="id277"/> from memory when no longer in use.</p></div><div class="section" title="The little-used del statement"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec41"/>The little-used del statement</h2></div></div></div><p>We <a class="indexterm" id="id278"/>can remove variables manually with the <code class="literal">del</code> statement. Here's an example:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; a = 2**2024
&gt;&gt;&gt; del a</pre></div><p>We've created an integer object, and assigned it to the variable <code class="literal">a</code>. When we remove the variable, this will reduce the reference count on the integer object. The memory occupied by the big integer is now eligible to be reclaimed.</p><p>This kind of thing is done very rarely. Python's ordinary reference counting does almost everything we need. It's generally best not to waste brain calories tying to micro-manage memory allocation.</p></div></div>
<div class="section" title="The Python namespace concept"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec39"/>The Python namespace concept</h1></div></div></div><p>We've<a class="indexterm" id="id279"/> already seen two applications of the Python namespace. When we assign variables at the <code class="literal">&gt;&gt;&gt;</code> prompt, we're introducing the variable into the global namespace. When we import a module, the module creates its own namespace within the global namespace. </p><p>That's why we can then use qualified names like <code class="literal">math.sqrt()</code> to refer to objects inside the module's namespace.</p><p>When we look at functions and class definitions, we'll see additional use, of namespaces. In particular, when evaluating a function or a class method, a local namespace is created, and all variables are part of that local namespace. When the function evaluation finishes (because of an explicit <code class="literal">return</code> statement or the end of the indented block,) the local namespace is dropped, removing all local variables and reducing the reference count on all objects assigned to those local variables.</p><p>Additionally, the <code class="literal">types</code> module includes the <code class="literal">SimpleNamespace</code> class. An instance of this class allows us to build a complex object without a formal class definition. Here's an example:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; from types import SimpleNamespace
&gt;&gt;&gt; red_violet= SimpleNamespace(red=192, green=68, blue=143)
&gt;&gt;&gt; red_violet
namespace(blue=143, green=68, red=192)
&gt;&gt;&gt; red_violet.blue
143</pre></div><p>We've imported the <code class="literal">SimpleNamespace</code> class. We created an instance of that class, assigning three local variables, <code class="literal">red</code>, <code class="literal">green</code>, and <code class="literal">blue</code>, that are part of the new <code class="literal">SimpleNamespace</code> object. When we examine the object as a whole, we see that it has three internal variables.</p><p>We can use syntax like <code class="literal">red_violet.blue</code> to see the <code class="literal">blue</code> variable inside the <code class="literal">red_violet</code> namespace.</p><p>The <code class="literal">argparse</code> module is<a class="indexterm" id="id280"/> used by command-line programs to parse the command-line arguments. This module also contains a <code class="literal">Namespace</code> class definition. An instance of <code class="literal">Namespace</code> is used to collect the various arguments parsed from the command line. An application can set additional variables in the <code class="literal">Namespace</code> object to handle particularly complex parsing and configuration issues.</p><div class="section" title="Globals and locals"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec42"/>Globals and locals</h2></div></div></div><p>When we use a variable name in an expression, Python searches two namespaces to resolve the<a class="indexterm" id="id281"/> name and locate the object to which it refers. First, it <a class="indexterm" id="id282"/>checks the local namespace. If the name is not found, it will check the global namespace. This two-step search will ensure that local variables used inside a function or class method are used before global variables with the same name.</p><p>When working from the <code class="literal">&gt;&gt;&gt;</code> prompt using the REPL, we can only create and use global variables. Further examples will have to wait until <a class="link" href="ch07.html" title="Chapter 7. Basic Function Definitions">Chapter 7</a>, <span class="emphasis"><em>Basic Function Definitions</em></span>.</p><p>When we use the <code class="literal">locals()</code> and <code class="literal">globals()</code> functions at the <code class="literal">&gt;&gt;&gt;</code> prompt, we can see that they have the same results. At the <code class="literal">&gt;&gt;&gt;</code> prompt, and at the top-level of a script file, the local namespace is the global namespace. When evaluating a function, however, the function works in a separate, local namespace.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Summary</h1></div></div></div><p>We've looked at how we assign objects to variables. We've looked at the simple assignment statement, as well as multiple assignment and augmented assignment. With augmented assignment, we can update a variable by applying an operator and an operand. This is a handy syntactic shortcut.</p><p>We've also addressed the <code class="literal">input()</code> function, which is a way to create new objects based on user input. It's very handy for simple command-line scripts. More sophisticated GUIs, of course, will have considerably more sophisticated input mechanisms.</p><p>The concept of a namespace, and how variables are tracked via a namespace, is central to Python. When a namespace is no longer needed, it's discarded, removing all of the variables. This will also reduce the reference count on all of the objects referred to by the variables. Once an object's reference count is reduced to zero, the object can be removed from memory. This is a tidy and simple way to handle variables.</p><p>In <a class="link" href="ch05.html" title="Chapter 5. Logic, Comparisons, and Conditions">Chapter 5</a>, <span class="emphasis"><em>Logic, Comparisons, and Conditions</em></span>, we'll look at another fundamental data type: Boolean. We'll look at Python's approach to Boolean values and the logical operators of <code class="literal">and</code>, <code class="literal">or</code>, <code class="literal">not</code>, and <code class="literal">if-else</code>. We'll also look at the various comparison operators.</p><p>We'll look at several kinds of Python statements, include the <code class="literal">if-elif-else</code> statement, the <code class="literal">pass</code> statement, and the <code class="literal">assert</code> statement. This will allow us to write somewhat more sophisticated scripts.</p></div></body></html>