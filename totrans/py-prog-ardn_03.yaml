- en: Chapter 3. The First Project – Motion-triggered LEDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapter, you learned the basics of Python-Arduino interfacing.
    We went through some exercises to provide hands-on experience with a useful Arduino
    protocol, Firmata, and the Python library. Now, it's time for your first 'Python
    + Arduino' project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start this chapter by discussing the project goals and the required
    components to design the software flow and the hardware layout for the project.
    Just like any other microcontroller-based hardware project, you can use code and
    implement the entire logic of your project on Arduino itself. However, the goal
    of this book is to help you to utilize Python in such a way that you can simplify
    and extend your hardware projects. Although we will be using a hybrid approach
    with a Python program assisted by an Arduino sketch in the upcoming chapters,
    we would like you to get familiar with both ways of programming. As this is your
    first experience of building a hardware project, the chapter provides you with
    two different programming methods for the project: just using an Arduino sketch
    and using a Python program with the Firmata protocol on Arduino. The method with
    the Arduino sketch is included so that you get the complete experience with the
    Arduino components such as I/O pins and serial communication.'
  prefs: []
  type: TYPE_NORMAL
- en: Motion-triggered LEDs – the project description
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you start learning any programming language, in most cases, you will be
    writing code to print 'Hello World!'. Meanwhile, in hardware projects, the majority
    of tutorials begin by helping a user to write the code to blink an LED. These
    exercises or projects are useful for developers to get started with the language,
    but mostly, they do not carry any importance towards real-world applications.
    However, we don't want to overwhelm you with a complex and sophisticated project
    that might require you to have a good amount of domain knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: While working with the Firmata protocol in the previous chapter, we already
    blinked an LED on the Arduino board. To keep the tradition alive (of having a
    blinking LED as a first major project) and also build excitement towards the project,
    let's put a twist in the blinking LED project. In this project, we will blink
    two different LEDs, but instead of performing these actions in a random manner,
    we will do it for events that are measured using a motion sensor. Although the
    difficultly level of the project is simple since it is your first project, it
    carries real-world application value and can be used as a simple application in
    your day-to-day life.
  prefs: []
  type: TYPE_NORMAL
- en: The project goal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The project goal can be described in one sentence as follows: "Generate an
    alert using a red LED for any detected motion and display the normal condition
    using a green LED." In comprehensive list of goals, you will have to perform the
    following tasks to satisfy the mentioned project goal:'
  prefs: []
  type: TYPE_NORMAL
- en: Detect any motion in the environment as an event using a **passive infrared**
    (**PIR**) sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform a blink action using a red LED for this event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, perform a blink action using a green LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep the system in loop after the action has been performed and wait for the
    next event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The project can be implemented as a DIY application or as part of other projects
    with minor modifications. The following are some examples where the concepts from
    this project can be utilized:'
  prefs: []
  type: TYPE_NORMAL
- en: As a DIY security system, to monitor movement in a room ([http://www.instructables.com/id/PIR-Sensor-Security/](http://www.instructables.com/id/PIR-Sensor-Security/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In smart home applications, it can be used to automatically turn off lights
    if no one is present ([http://www.instructables.com/id/Arduino-Home-Monitor-System/](http://www.instructables.com/id/Arduino-Home-Monitor-System/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be used in automatic garage door opener applications with the support
    of additional hardware components and appropriate code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In DIY wildlife recording projects, it can be used to trigger a camera instead
    of an LED when any motion is detected ([http://www.instructables.com/id/Motion-triggered-camera/](http://www.instructables.com/id/Motion-triggered-camera/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous chapter, we only used an LED for programming using Arduino,
    an Arduino USB cable, and a computer. The major hardware component required for
    this project is a PIR motion sensor. You will also need an additional LED. We
    recommend that you have a different colored LED than the one that you already
    have. The description of the necessary components is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PIR sensors**: These are widely used as motion detection sensors for DIY
    projects. They are small, inexpensive, consume less power, and are compatible
    with hardware platforms such as Arduino. A PIR sensor uses a pair of pyroelectric
    sensors that detect infrared radiation. If there is no motion, the output of these
    sensors cancels each other out. Any movement in the environment will produce different
    levels of infrared radiation by these pyroelectric sensors and the difference
    will trigger an output that is `HIGH` (+5 volts). We will be using the PIR sensor
    that is sold by SparkFun, and you can obtain it from [https://www.sparkfun.com/products/8630](https://www.sparkfun.com/products/8630).
    The PIR sensor comes equipped with the required printed circuit board (PCB). It
    has range of up to 20 feet (6 meters), which is sufficient for the project. The
    following image displays the PIR sensor available on the SparkFun website:![The
    list of components](img/5938OS_03_01.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Source: Sparkfun Inc.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**LEDs**: We recommend that you use green and red LEDs for the project. If
    they are unavailable, you can use any two LEDs with different colors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wires, resistors, and the breadboard**: You will require a bunch of wires
    and a breadboard to complete the connections. As a best practice, have at least
    three different colors of wire connectors to represent power, ground, and signal.
    You will also need two 220 ohm and one 10 kilo-ohm pull resistors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Arduino board**: The Arduino Uno board is sufficient for the project
    requirements. You can also use Arduino Mega or any other Arduino board for this
    project. The project requires only three I/O pins and any available Arduino board
    is equipped with more than three I/O pins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A USB cable**: You will need a USB cable to upload the Arduino code and perform
    serial communication with the Arduino board.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A computer**: We have already configured a computer with Python and the Arduino
    IDE for your favorite operating system in the previous chapters. You will need
    this computer for the project. Make sure that you have all the software components
    that we installed and configured in the previous chapters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The software flow design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step, before jumping to work on any hardware system, is to design
    the project flow using logic. We recommend that you have your project sketched
    as a flowchart to better understand the layout of the components and the flow
    of the code. The following diagram shows the flow of the project where you can
    see that the project runs in loops once motion is detected and the appropriate
    LED actions are performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The software flow design](img/5938OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the program logic starts by detecting the state of the PIR sensor
    and performs the appropriate actions accordingly. With a single Arduino instruction,
    you can only turn the LED on or off. To perform the blinking operation, we will
    need to repeatedly perform the turning-on and turning-off actions with a time
    delay between the actions. We will also insert a delay between the execution of
    each successive loop so that the PIR sensor output can settle down. Note that
    we will use the same flow when writing the code for both the programming methods.
  prefs: []
  type: TYPE_NORMAL
- en: The hardware system design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Designing a diagram for your software flow helps you to write the program and
    also assists you in identifying actions and events for the project. The process
    of hardware system design includes circuit connections, schematic design, simulation,
    verification, and testing. This design process provides a detailed understanding
    of the project and the hardware components. It also helps in preliminary verification
    and testing of the project architecture. Before we jump to the hardware design
    process of this project, let's get ourselves familiar with the helpful tools.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Fritzing – a hardware prototyping software
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You are not required to design the hardware system for this project. By and
    large, in this book, the hardware system designs will be provided, as the primary
    focus of the book is on programming rather than hardware design.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in system design or rapid prototyping of the hardware
    components, the open source software tool used for this purpose is called **Fritzing**.
    The schematics for your projects can be designed using Fritzing and it can be
    obtained from [http://fritzing.org/download/](http://fritzing.org/download/).
  prefs: []
  type: TYPE_NORMAL
- en: Fritzing is a community-supported electronic design automation software initiative
    for designers, artists, and hobbyists. It lets you convert your hardware sketch
    from paper to software as a circuit diagram. Fritzing also provides you with a
    tool to create PCB layouts from your designs. Fritzing extensively supports Arduino
    and other popular open source DIY hardware platforms. You can explore Fritzing
    via built-in example projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install and run Fritzing. The following screenshot shows one of the default
    projects that are displayed after opening Fritzing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing Fritzing – a hardware prototyping software](img/5938OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, a toolbox containing virtual hardware components is located
    to the right of the opened window. The main editing space, located in the center,
    lets the user drag and drop components from the toolbox and also allows the user
    to complete connections between these components. You can learn more about the
    features provided by Fritzing and go through some hands-on tutorials at [http://fritzing.org/learning/](http://fritzing.org/learning/).
  prefs: []
  type: TYPE_NORMAL
- en: Working with the breadboard
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you are familiar with Fritzing, you have the flexibility to create your
    own circuits, or you can always use the Fritzing files provided with the book.
    However, there is another challenge, that is, porting your virtual circuit to
    a physical one. One of the fundamental components used by electronics projects
    that let you implement connections and build the physical circuit is the **breadboard**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The breadboard contains intelligently organized metal rows hidden under an
    assembly containing plastic holes. This assembly helps the user to connect wires
    without going through any soldering work. It is really easy to insert and remove
    wires or electronics components through the holes. The following figure shows
    a small breadboard with a couple of components and a few wire connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with the breadboard](img/5938OS_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Find out more about breadboards and the tutorials to use them at [http://learn.sparkfun.com/tutorials/how-to-use-a-breadboard](http://learn.sparkfun.com/tutorials/how-to-use-a-breadboard).
  prefs: []
  type: TYPE_NORMAL
- en: 'A breadboard mostly has two types of connection strips: terminal strips and
    power rails. As displayed in the preceding figure, terminal strips are vertical
    columns with electrically shorted holes. In simple words, once you connect any
    component to one of the terminal strips, the component will be electrically connected
    to each hole in the column. The columns of terminal strips are separated by the
    **Dual in-line Package** (**DIP**) support gap. (DIP is a common housing for electronics
    components.) In the same column, terminal strips above and below the DIP support
    gap are electrically independent. Meanwhile, the power rails are shorted horizontally
    throughout the entire row of the breadboard. The power rails are mostly used to
    connect positive and ground connections from the power supply, so it can be distributed
    easily to all components.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**History of breadboards**'
  prefs: []
  type: TYPE_NORMAL
- en: In the early years of electronics, people used actual breadboards (that were
    used to cut bread) to connect their large components with just nails and wires.
    Once electronics components started getting smaller, the board to assemble circuits
    also became better. The term stuck through this evolution, and we still call the
    modern boards breadboards. If you are interested, you can check out [http://www.instructables.com/id/Use-a-real-Bread-Board-for-prototyping-your-circui/](http://www.instructables.com/id/Use-a-real-Bread-Board-for-prototyping-your-circui/),
    which provides instructions to assemble a circuit using the original breadboards.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the hardware prototype
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It''s time to collect the hardware components mentioned earlier and start building
    the system. The next figure shows the circuit for the project that has been developed
    using Fritzing. If you have prior experience of working with circuit assembly,
    go ahead and connect the components as displayed in the figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the hardware prototype](img/5938OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If this is your first experience of working with sensors and the breadboard,
    use the following steps to complete the circuit assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect VCC (+5V) and ground from the Arduino to the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the anode (long lead) of the red LED to digital pin 12 of the Arduino
    board. Connect the cathode (short lead) of the red LED to ground with 220 ohm
    resistors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the anode (long lead) of the green LED to digital pin 13 of the Arduino
    board. Connect the cathode (short lead) of the green LED to ground with 220 ohm
    resistors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect VDD of the PIR sensor to VCC on the breadboard. Use the same wire color
    to represent the same category of connections. This will greatly help in troubleshooting
    the circuit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the signal (middle pin) of the PIR sensor to Arduino digital pin 7 with
    a 10 kilo-ohm pull-up resistor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The majority of experts prefer a schematic diagram instead of the prototype
    diagram that we used previously. Schematic diagrams are useful when you are using
    compatible components instead of the exact components from the prototype diagram.
    The following is a schematic diagram of the electronics circuit that we designed
    earlier. This diagram is also obtained using Fritzing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the hardware prototype](img/5938OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Your system is now ready to run the Arduino program. As we will be using the
    same hardware for both the programming methods, you are almost done working with
    electronics unless you encounter a problem. Just to make sure that everything
    is connected perfectly, let's check out these connections in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that pull-up resistors are used to make sure that the output signal from
    a PIR sensor settles at the expected logic level.
  prefs: []
  type: TYPE_NORMAL
- en: Testing hardware connections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the circuit connections are complete, you can go directly to the programming
    sections. As a best practice, we recommend that you verify the circuit connections
    and check the sensor's status. We are assuming that your Arduino board is already
    equipped with the **StandardFirmata** sketch that we discussed in the previous
    chapter. Otherwise, refer to the previous chapter and upload the **StandardFirmata**
    sketch to your Arduino board.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to verify our circuit implementation is to use the Firmata test
    program that we used in the previous chapter. According to the project setup,
    the PIR sensor provides event inputs to Arduino pin 7\. In the test program, change
    the type of pin 7 to **Input** and wave your hand over the sensor, and you should
    be able to see the status of the pin as **High**, as displayed in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing hardware connections](img/5938OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Check the LED connections by setting up pins 12 and 13 as output pins and toggling
    the buttons to set the status of the pins. If you see the LEDs blinking while
    you are toggling the button, then your connections are working perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: If you cannot successfully perform these checks, verify and repeat the design
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: Method 1 – using a standalone Arduino sketch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed in the previous chapters, a project can be implemented by creating
    project-specific native Arduino code or by using a Python-Arduino hybrid approach.
  prefs: []
  type: TYPE_NORMAL
- en: The native Arduino sketches are useful in applications where negligible or no
    communication with a computer system is required. Although this type of standalone
    project enables continuous operation in the absence of serial connectivity, it
    is difficult to keep updating and uploading an Arduino sketch for minor modifications.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the various applications of this project, you will notice that
    only a few of them require the project to be implemented as a standalone system
    that just detects motion and blinks LEDs. This type of system can be easily implemented
    by a simple Arduino sketch.
  prefs: []
  type: TYPE_NORMAL
- en: The project setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we go ahead with the project, make sure that you have the following
    things in place:'
  prefs: []
  type: TYPE_NORMAL
- en: The hardware components are set up and are functioning correctly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your Arduino is connected to the computer using a USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your computer has the Arduino IDE and you can access the connected Arduino board
    through the IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Arduino sketch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section describes the Arduino code for the project. Before we get into
    a step-by-step description of the code, let''s first follow these steps to run
    the project:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Arduino IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **File** menu, open a new sketchbook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the following Arduino code to the sketch and save it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and upload the sketch to the Arduino board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you have completed your project with the first programming method and successfully
    deployed it to your hardware. It should be running the designed algorithm to detect
    motion events and perform the blink action.
  prefs: []
  type: TYPE_NORMAL
- en: 'As your project is functioning properly, it''s time to understand the code.
    Like any other Arduino program, the code has two mandatory functions: `setup()`
    and `loop()`. It also has a custom function, `blinkLED()`, for a specific action
    that will be explained later.'
  prefs: []
  type: TYPE_NORMAL
- en: The setup() function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you can see in the preceding code snippet, we assigned variables to the
    Arduino pin at the beginning of the program. In the `setup()` function, we configured
    these variables to be defined as input or output pins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `pirPin`, `redLedPin`, and `greenLedPin` are digital pins 7, 12, and
    13 respectively. In the same function, we also configured the Arduino board to
    provide serial connectively at the baud rate of 9600 bps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The loop() function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the `loop()` function, we are repeatedly monitoring the input from the `pirPin`
    digital pin to detect motion. The output of this pin is `HIGH` when motion is
    detected and `LOW` otherwise. This logic is implemented using a simple `if-else`
    statement. When this condition is satisfied, the function calls a user-defined
    function, `blinkLED()`, to perform the appropriate action on the LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: User-defined functions are a very important aspect of any programming language.
    Let's spend some time learning how you can create your own Arduino functions to
    perform various actions.
  prefs: []
  type: TYPE_NORMAL
- en: Working with custom Arduino functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions are used when a segment of code is repeatedly executed to perform
    the same action. A user can create a custom function to organize the code or perform
    reoccurring actions. To successfully utilize a custom function, a user needs to
    call them from mandatory Arduino functions such as `loop()`, `setup()`, or any
    other function that leads to these mandatory functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding Arduino function framework, `return-type` can be any Arduino
    data type such as `int`, `float`, `string`, and so on, or `void` if the code is
    not returning anything. The following is the custom function that we used in our
    project code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In our project, the `blinkLED()` function is not retuning any value when it
    is called from the `loop()` function. Hence, `return-type` is `void`. When calling
    the function, we pass the pin number and a message as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: These parameters are then utilized in the performed action (writing a message
    on a serial port and setting up the LED status) by the `blinkLED()` function.
    This function also introduces a delay to perform the blink action by using the
    `delay()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We verified the designed system in the *Testing hardware connection* section
    using manual inputs via the Firmata test program. As we have now implemented the
    software design, we need to verify that the project is performing objective tasks
    autonomously and repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the USB port connected to the computer, open the serial monitoring tool
    from the Arduino IDE by navigating to **Tools** | **Serial Monitor** or by pressing
    *Ctrl* + *Shift* + *M*. You should start seeing a message similar to the one displayed
    in the following screenshot on the **Serial Monitor** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing](img/5938OS_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While writing the `blinkLED()` function to perform actions, we included an action
    to write a string via a serial port. Move your hand over the PIR sensor in such
    a way that the PIR sensor can detect motion. This event should trigger the system
    to blink the red LED and display a string, `Motion detected`, on the serial monitor.
    Once you stay steady and avoid any motion for a while, you will be able to see
    the green LED blinking until the next movement gets detected via the PIR sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Troubleshooting is an important process if anything goes awry. These are a
    few example problems and the troubleshooting steps for them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Serial output is correct, but there are no blinking LEDs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the LED connections on the breadboard
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The LED blinks, but there is no serial output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the port on which the serial monitor is configured
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether the baud rate in the serial monitor is correct (9600 bps)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is no serial output and no blinking LEDs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the PIR sensor connection and make sure that you are getting signal from
    the PIR sensor
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Check your Arduino code
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Check power and ground connections
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Method 2 – using Python and Firmata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed the benefits of using Python programming
    that is assisted by Firmata over using native Arduino sketches. The Python-based
    programming approach provides tangible experience when performing any algorithmic
    or parametric changes. In this section, we are going to explore these benefits
    and also learn important Python programming paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: The project setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s make sure that you have done the following before we go ahead with Python
    programming:'
  prefs: []
  type: TYPE_NORMAL
- en: Made sure that the hardware components are set up, as described in the system
    design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connected the Arduino to your computer using a USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploaded the **StandardFirmata** sketch back to Arduino
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Made sure that you have Python and the Python packages (`pySerial` and `pyFirmata`)
    installed on your computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtained a text editor to write Python codes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Python executable files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapters, we explored Python programming using the interactive
    Python interpreter. However, when working with large projects, it is very difficult
    to keep using the Python interactive interpreter for repetitive tasks. Like other
    programming languages, the preferred method is to create Python executable files
    and run them from the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python executable files carry the `.py` extension and are formatted as plain
    text. Any text editor can be used to create these files. The popular editors used
    to create and edit Python files are Notepad++, nano, vi, and so on. This list
    also includes the default editor that is shipped with the Python setup files called
    IDLE. You can use the editor of your choice, but make sure that you save the files
    with the `.py` extension. Let''s copy the following lines of code in a new file
    and save it as `test.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To run this file, execute the following command on the terminal where the `test.py`
    file is saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be able to see the text `Python Programming` printed on the terminal.
    As you can see, the file starts with `#!/usr/bin/python`, which is the default
    Python installation location. By adding this line in your Python code, you can
    directly execute a Python file from the terminal. In Unix-based operating systems,
    you need to make the `test.py` file executable through the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as your file is executable, you can directly run the file using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For Unix-based operating systems, an alternative way to provide the Python
    interpreter location is to use the following line of code instead of the one that
    we used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In Windows operating systems, Python files automatically become executable because
    of the `.py` extension. You can just run the program files by double-clicking
    and opening them.
  prefs: []
  type: TYPE_NORMAL
- en: The Python code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you now know how to create and run Python code, let''s create a new Python
    file with the following code snippet and run it. Make sure to change the value
    of the `port` variable according to your operating system, as described in the
    previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You have successfully created and executed your first Arduino project using
    Python. There are two main programming components in this code: `pyFirmata` methods
    and the Python function to perform the blinking action. The program repeatedly
    detects the motion events and performs the blinking action. In the previous section,
    this problem was solved by using the default Arduino function `loop()`. In this
    method, we have implemented the `while` statement to keep the program in loop
    until the code is manually terminated by the user. You can terminate the code
    using the keyboard combination *Ctrl* + *C*.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with pyFirmata methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As part of working with the Arduino board and the Firmata protocol, you have
    to start by initializing the Arduino board as a variable. The `pyFirmata` method
    that lets a user assign the board to a Python variable is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the value of the variable is assigned, you can perform various actions
    such as reading a pin or sending a signal to the pin using that variable. To assign
    a role to a pin, the `get_pin()` method is used. In the following line of code,
    `d` represents the digital pin, `7` is the pin number, and `i` represents that
    the type of pin is an input pin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a pin and its role are assigned to a variable, that variable can be used
    to read or write values on the pin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'One can directly write data to a specific pin, as described in following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `write(1)` method sends a `HIGH` signal to the pin. We will be learning
    additional `pyFirmata` methods in the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Python functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Python function begins with the `def` keyword followed by the function name
    and the input parameters or arguments. The function definition ends with a colon
    (`:`) and it is indented afterwards. The `return` statement terminates the function.
    It also passes the expression to the place where the function is called. If the
    `return` statement is kept without an expression, it is considered to pass the
    return value `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding framework can be used to create custom functions to perform recurring
    tasks. In our project, we have the `blinkLED(pin, message)` function to perform
    the blinking LED action. This function sends `1` (`HIGH`) and `0` (`LOW`) value
    to the specified digital pin while also printing `message` on the terminal. It
    also introduces delay to simulate the blinking action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can start testing the project as soon as you run the Python code on the
    terminal. If everything goes according to design, you should be able to see the
    following output in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing](img/5938OS_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You should be able to see the `Motion Detected` string on the terminal when
    any motion is detected by the PIR sensor. If you find any abnormal behavior in
    the output, then please check the Python code.
  prefs: []
  type: TYPE_NORMAL
- en: A benefit of using Python is that minor modifications such as changing the blinking
    speed or swapping roles of the LEDs can be performed by just changing the Python
    code, without dealing with the Arduino or the electrical circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you run the project, you might require troubleshooting for the following
    probable problems:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Serial output is correct, but there are no blinking LEDs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the LED connections on the breadboard
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The LED blinks, but there is no serial output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether you have successfully installed the standard Firmata sketch to
    the board
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is no serial output and no blinking LEDs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether any program other than Python is using the serial port. Close
    any program that might be using that serial port, including the Arduino IDE.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify all the circuit connections.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that the port name specified in the Python code is correct.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Between the two programming methods that you learned in this chapter, the method
    that uses just an Arduino sketch represents the traditional paradigm of programming
    a microcontroller. While this method is simple to implement, it lacks the extensiveness
    that is achieved by Python-Arduino interfacing. Although we will use extensive
    Arduino coding in all the projects beginning from now, exercises and projects
    will have Python-Arduino interfacing as the primary way of programming.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from the next chapter, we are going to explore the additional aspects
    of Python programming that can extend the usability of an Arduino-based hardware
    project while keeping the programming difficulty levels to a minimum. We will
    begin with Python-Arduino prototyping and then create graphical interfaces for
    user interaction, before stopping for the second project that utilizes these concepts.
  prefs: []
  type: TYPE_NORMAL
