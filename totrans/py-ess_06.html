<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. More Complex Data Types</h1></div></div></div><p>We'll look at a number of built-in and standard library collection types. These collections offer more features than the simple tuple collection. We'll look at the <code class="literal">for</code> and <code class="literal">while</code> statements which allow us to process the individual items of a collection.</p><p>We'll look at some functions which we can use to work with collections of data; these include the <code class="literal">map()</code>, <code class="literal">filter()</code>, and <code class="literal">functools.reduce()</code> functions. By using these, we don't need to write an explicit <code class="literal">for</code> statement to process a collection. We'll also look at more specific kinds of reductions such as <code class="literal">max()</code>, <code class="literal">min()</code>, <code class="literal">len()</code>, and <code class="literal">sum()</code>.</p><p>We'll also look at the <code class="literal">break</code> and <code class="literal">continue</code> statements; these modify a <code class="literal">for</code> or <code class="literal">while</code> loop to allow skipping items or exiting before the loop has processed all items. This is a fundamental change in the semantics of a collection-processing statement.</p><p>The concepts of mutability and immutability are part of understanding how an object behaves. The built-in types in this chapter are all mutable. This is quite different from the way that immutable objects like strings and tuples behave.</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec51"/>The mutability and immutability distinction</h1></div></div></div><p>In <a class="link" href="ch02.html" title="Chapter 2. Simple Data Types">Chapter 2</a>, <em>Simple Data Types</em>, we looked at the immutability issue. This is an important <a class="indexterm" id="id324"/>characteristic of Python objects. We'll need to look at some more <a class="indexterm" id="id325"/>aspects of mutability in <a class="link" href="ch07.html" title="Chapter 7. Basic Function Definitions">Chapter 7</a>, <em>Basic Function Definitions</em>. We'll look at how we can create our own mutable classes in <a class="link" href="ch11.html" title="Chapter 11. Class Definitions">Chapter 11</a>, <em>Class Definitions</em>.</p><p>We've seen that Python's various classes include those which create mutable objects and those which create immutable objects. The immutable classes include all of the number classes, strings, bytes, and tuples. The <code class="literal">tuple (247, 83, 148)</code> object cannot be changed: we cannot assign a new value to an item with an index of 1. </p><p>A <code class="literal">tuple</code> object has the structure of <code class="literal">Sequence</code>: we can extract items based on their position. However, we cannot change the internal state of a <code class="literal">tuple</code> object.</p><p>A <code class="literal">list</code> is also<a class="indexterm" id="id326"/> a subclass of the <code class="literal">Sequence</code> class. We can, however, change the state of a <code class="literal">list</code> object without creating a new <code class="literal">list</code> instance.</p><p>The abstract base class definitions for <code class="literal">Sequence</code> and <code class="literal">MutableSequence</code> are in the <code class="literal">collections.abc</code> module. The documentation for this module shows how the various complex <a class="indexterm" id="id327"/>types<a class="indexterm" id="id328"/> relate to each other.</p><p>While some of the features of <code class="literal">list</code> and <code class="literal">tuple</code> are similar, they address different use cases. The <a class="indexterm" id="id329"/>benefits of immutability are simplicity, reduced storage demands, and higher-performance for some kinds of processing. The benefit mutability is <a class="indexterm" id="id330"/>that a single object can undergo an internal state change.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec52"/>Using the list collection</h1></div></div></div><p>Python's <code class="literal">list</code> collection<a class="indexterm" id="id331"/> is its built-in mutable sequence. We can create list objects easily using a literal display that simply provides expressions enclosed in <code class="literal">[]</code>. It looks like this:</p><div><pre class="programlisting">fib_list = [1, 1, 3, 5, 8]</pre></div><p>As with tuples, the items are identified by their position in the <code class="literal">list</code> collection. Positions are numbered from the left starting from zero. Positions are also numbered from the right, using negative numbers. The last value in a list is at position -1, the next-to-last value at position -2.</p><div><div><h3 class="title"><a id="tip17"/>Tip</h3><p>Index values begin with zero. Index position 0 is the first item. Index values can be done in reverse with negative numbers. Index position -1 is the last item.</p></div></div><p>We can also create lists using the <code class="literal">list()</code> function. This will convert many kinds of collections into <code class="literal">list</code> objects. Used without arguments, <code class="literal">list()</code> creates an empty <code class="literal">list</code> just like <code class="literal">[]</code>. Since the <code class="literal">list()</code> function is so versatile at converting collections into <code class="literal">list</code> objects, we'll use it much more in later chapters.</p><p>We can update a <code class="literal">list</code> collection using methods like <code class="literal">append()</code>:</p><div><pre class="programlisting">fib_list.append(fib_list[-2] + fib_list[-1])</pre></div><p>In this example, the value of <code class="literal">fib_list[-1]</code> is the last element in the list, and <code class="literal">fib_list[-2]</code> is the penultimate value. The expression creates a new number, which can be appended to the <code class="literal">fib_list</code> object.</p><p>We can manipulate a single element in a list using a subscription, such as those shown in the previous example. The value in the <code class="literal">[]</code> must be a single integer, which identifies an item in the list. It looks like this:</p><div><pre class="programlisting">&gt;&gt;&gt; fib_list[2]
3</pre></div><p>The item in position two (the third item in the list) has a value of 3.</p><p>We can extract a sublist using slicing notation. A slicing uses a multi-part value in the <code class="literal">[]</code>. The result <a class="indexterm" id="id332"/>of a slicing is always a list built from the original list object. There are several ways to specify slicings, we'll show a number of examples:</p><div><pre class="programlisting">&gt;&gt;&gt; fib_list[2:5]
[3, 5, 8]
&gt;&gt;&gt; fib_list[2:]
[3, 5, 8, 13]
&gt;&gt;&gt; fib_list[:-1]
[1, 1, 3, 5, 8]</pre></div><p>The first slicing, <code class="literal">[2:5]</code>, starts at the index of 2 and stops just before the index of 5. This means that the index values of 2, 3, and 4 are sliced out of the original list. Since lists are indexed from zero, an index of 2 is the third position in the list. It's essential to think of a slicing as a "half-open" interval.</p><div><div><h3 class="title"><a id="tip18"/>Tip</h3><p>Most of Python uses "half-open" intervals.</p><p>When we write the slice expression <code class="literal">[a:b]</code>, position <em>a</em> is included while position <em>b</em> is not included. This slice specifies all index values, <em>i</em>, such that <img alt="Using the list collection" src="img/B03671_06_01.jpg"/>. There are <img alt="Using the list collection" src="img/B03671_06_02.jpg"/> values in the slice.</p></div></div><p>The second slicing, <code class="literal">[2:]</code>, omits the ending, which means that it starts at an index of 2 and includes all items to the end of the list.</p><p>The third slicing, <code class="literal">[:-1]</code>, omits the starting position, which means that it starts at an index of 0. The ending is given as -1, the last item in the list. Since slicings stop short of the given final position, this slicing will omit the last item from the list.</p><p>We can use <code class="literal">[:]</code> as a degenerate case where the start and end are both omitted. This works very well when making a shallow copy of an entire <code class="literal">list</code> object.</p><p>Slicings can be extended to include a third parameter. This allows us to specify a <em>start</em>, <em>stop</em>, and a <em>step</em> value. We can do things like this:</p><div><pre class="programlisting">&gt;&gt;&gt; fib_list[::2]
[1, 3, 8]
&gt;&gt;&gt; fib_list[1::2]
[1, 5, 13]</pre></div><p>In the first example, the start and stop are omitted, so we'll use the entire list. The step value is 2, so we'll extract a new list using the even-numbered indexes: 0, 2, 4, …, and so on.</p><p>In the second<a class="indexterm" id="id333"/> example, we provided a start and a step value. This will begin with index 1, and increment by 2. It will extract a list built from the odd-numbered indices: 1, 3, 5, …, and so on.</p><p>We can use a negative step value to visit a list in reverse order. This can be confusing, but it works very nicely.</p><p>List objects have a few operators, including <code class="literal">+</code> and <code class="literal">*</code>. We'll also look at the various kinds of list assignment statements we can use that involve slicing expressions on the left side of the assignment statement. These can mutate a list by changing some of the values.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec49"/>Using list operators</h2></div></div></div><p>We can<a class="indexterm" id="id334"/> use the <code class="literal">+</code> operator to concatenate two list objects: <code class="literal">[1, 1] + [2, 3, 5]</code> for example. If we want to extend a list, we can use this augmented assignment statement:</p><div><pre class="programlisting">&gt;&gt;&gt; fib_list += [ fib_list[-2] + fib_list[-1] ]</pre></div><p>Note that we had to create a singleton <code class="literal">list</code> collection so that the <code class="literal">+</code> operator would concatenate the new <code class="literal">list</code> to an existing <code class="literal">list</code>.</p><p>Since a <code class="literal">list</code> object is mutable, this <code class="literal">+=</code> assignment will update a <code class="literal">list</code> object; it is extended with the new <code class="literal">list</code> collection. Contrast this with a <code class="literal">tuple</code>, where a new <code class="literal">tuple</code> must be created from the two original tuples, and assigned to the variable.</p><p>In <a class="link" href="ch05.html" title="Chapter 5. Logic, Comparisons, and Conditions">Chapter 5</a>, <em>Logic, Comparisons, and Conditions</em>, we noted that sequences like <code class="literal">list</code> and <code class="literal">tuple</code> are compared item-by-item. This means that <code class="literal">[1, 1, 2] &lt; [1, 2]</code> will be <code class="literal">True</code>.</p><p>Lists and other sequences also support the <code class="literal">in</code> operator. We can ask if a specific value is in a <code class="literal">list</code> collection. We can also confirm that a given value is not in a <code class="literal">list</code> collection. These are simple Boolean expressions that look like this:</p><div><pre class="programlisting">&gt;&gt;&gt; 13 in fib_list
True
&gt;&gt;&gt; 12 not in fib_list
True</pre></div><p>We've used the <code class="literal">in</code> operator to confirm that the value 13 is in the <code class="literal">fib_list</code> variable and the value 12 is not in that <code class="literal">list</code> object.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec50"/>Mutating a list with subscripts</h2></div></div></div><p>We can<a class="indexterm" id="id335"/> change an item in a <code class="literal">list</code> collection using a subscription or slicing on the left side of an assignment statement. A subscription uses <code class="literal">[]</code> and a single integer value to identify an item within a <code class="literal">list</code>. We can replace an item like this:</p><div><pre class="programlisting">fib_list[0]= 1</pre></div><p>We will replace the item at index 0 (the first item) with a value of 1. If we mention an index value which is not in the list, an <code class="literal">IndexError</code> will be raised.</p><p>We can replace any simple slice of a list with a different list. The replacement list does not have to be the same size. Indeed, it can be an empty list, which will effectively remove items from the list. Here's an example where we mutate a long slice by providing a shorter replacement:</p><div><pre class="programlisting">fib_list[2:5]= [3]</pre></div><p>We've specified a slicing which contains three items—index values of 2, 3, and 4—and replaced these items with a list that has only a single item. The resulting list will look like this:</p><div><pre class="programlisting">[1, 1, 3, 13]</pre></div><p>Positions 0 and 1 remain untouched. Also positions from 5 to the end of the original list are also left untouched.</p><p>We can replace an extended slicing—one that includes a step value—but the replacement must be the same size. If we don't provide the proper number of replacement values, we'll get a <code class="literal">ValueError</code> exception.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec51"/>Mutating a list with method functions</h2></div></div></div><p>We can mutate a <code class="literal">list</code> object with any of a large number of method functions. The mutator<a class="indexterm" id="id336"/> methods of a list almost always return a value of <code class="literal">None</code>. With the exception of the <code class="literal">pop()</code> method, mutators don't return a meaningful value.</p><p>There are also method functions which provide information about a list; these must return a value. We'll look at access-only method functions.</p><p>The mutator methods of a list include <code class="literal">append()</code>, <code class="literal">clear()</code>, <code class="literal">extend()</code>, <code class="literal">insert()</code>, <code class="literal">pop()</code>, <code class="literal">remove()</code>, <code class="literal">reverse()</code>, and <code class="literal">sort()</code>. Here are some examples:</p><div><pre class="programlisting">&gt;&gt;&gt; fib_list
[1, 1, 3, 5, 8, 13]
&gt;&gt;&gt; fib_list.extend( [21, 34] )
&gt;&gt;&gt; fib_list
[1, 1, 3, 5, 8, 13, 21, 34]
&gt;&gt;&gt; fib_list.insert(0, 0)
&gt;&gt;&gt; fib_list
[0, 1, 1, 3, 5, 8, 13, 21, 34]
&gt;&gt;&gt; fib_list.remove(34)
&gt;&gt;&gt; fib_list
[0, 1, 1, 3, 5, 8, 13, 21]
&gt;&gt;&gt; fib_list.pop()
21
&gt;&gt;&gt; fib_list.pop(0)
0</pre></div><p>We've<a class="indexterm" id="id337"/> shown our initial list with six items. We extended the list with a second list that has two more items, <code class="literal">[21, 34]</code>. The result is a single list composed of the two original lists.</p><p>The <code class="literal">insert()</code> method<a class="indexterm" id="id338"/> has a value and a position. In this example, both were zero. When we use <code class="literal">help(list.insert)</code> we see that the index position is the first argument value. The value to be inserted before that position is provided as the second argument value.</p><p>When we remove an item from a list, we provide the item value to remove. For very large lists, this may involve a significant amount of time searching for the required item.</p><p>The <code class="literal">pop()</code> method<a class="indexterm" id="id339"/> does two things. It removes an item by position, and returns that item as the result value. The default position is the last item, -1. We can also remove items from the beginning of a list, using index position 0.</p><p>We can also use the <code class="literal">del</code> statement to remove items from a list. The statement <code class="literal">del fib_list[0]</code> will remove the first item from a list.</p><p>We haven't shown the <code class="literal">reverse()</code> and <code class="literal">sort()</code> methods which change the order of the items in the list. The <code class="literal">sort()</code> method<a class="indexterm" id="id340"/> can be quite a bit more sophisticated than these methods. We'll look into sorting in <a class="link" href="ch08.html" title="Chapter 8. More Advanced Functions">Chapter 8</a>, <em>More Advanced Functions</em>.</p><p>We didn't give an example of the <code class="literal">clear()</code> method. This removes all of the items from the list.</p><p>Note that, with the exception of <code class="literal">pop()</code>, we must explicitly request a display of the <code class="literal">fib_list</code> object to see any output from Python's REPL. These mutator methods only return a value of <code class="literal">None</code>. It's too common a mistake to see <code class="literal">a = a.append(x)</code>; this statement always sets the variable <code class="literal">a</code> to <code class="literal">None</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec52"/>Accessing a list</h2></div></div></div><p>As shown <a class="indexterm" id="id341"/>previously, we can access a list using a subscription as well as a slicing. A subscription gives us a single item. A slicing, on the other hand, makes a shallow copy of the items in the original list.</p><p>The method functions for accessing a list include <code class="literal">count()</code>, <code class="literal">index()</code>, and <code class="literal">copy()</code>. Here are some examples to show how these functions work:</p><div><pre class="programlisting">&gt;&gt;&gt; fib_list.count(1)
2
&gt;&gt;&gt; fib_list.index(5)
3</pre></div><p>The <code class="literal">count()</code> method<a class="indexterm" id="id342"/> counts all the items which are equal to the given value. In this case, there were two items equal to 1 in the list. If the given value is not found in the list, the count will be zero.</p><p>The <code class="literal">index()</code> method<a class="indexterm" id="id343"/> locates the given item value, and returns the index position of that value in the list. If the value does not exist, a <code class="literal">ValueError</code> exception is raised.</p><p>The <code class="literal">copy()</code> method<a class="indexterm" id="id344"/> of a list object does the same thing as the empty slicing. The expressions, <code class="literal">fib_list[:]</code> and <code class="literal">fib_list.copy()</code>, are both copies of the original list.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Using collection functions</h1></div></div></div><p>Python <a class="indexterm" id="id345"/>offers a number of functions which work with any kind of collection. These include <code class="literal">sorted()</code>, <code class="literal">max()</code>, <code class="literal">min()</code>, and <code class="literal">sum()</code>. We also have some higher-order functions, <code class="literal">map()</code>, <code class="literal">filter()</code>, and the entire <code class="literal">itertools</code> module. We'll address additional higher-order functions in <a class="link" href="ch08.html" title="Chapter 8. More Advanced Functions">Chapter 8</a>, <em>More Advanced Functions</em>.</p><p>The <code class="literal">sorted()</code> function<a class="indexterm" id="id346"/> returns a sorted list from a collection. It transforms the given collection into a <code class="literal">list</code> collection as part of the sorting process. If the collection doesn't define the proper iterator methods, it can't be easily sorted by using this function.</p><p>The <code class="literal">max()</code> and <code class="literal">min()</code> functions reduce a collection to a single value: either the largest or the<a class="indexterm" id="id347"/> smallest value in the collection. This reduction presumes<a class="indexterm" id="id348"/> that the items can be meaningfully compared. Consider a <code class="literal">tuple</code> that has mixed values in it:</p><div><pre class="programlisting">((255, 73, 108), 'Radical Red')</pre></div><p>We can't meaningfully evaluate <code class="literal">max()</code> or <code class="literal">min()</code> on a collection of mixed values like this. The functions will be forced to compare a tuple of numbers against a string. This will raise a <code class="literal">TypeError</code> exception.</p><p>The <code class="literal">sum()</code> function reduces a collection of numbers to a single value. It can be used on almost <a class="indexterm" id="id349"/>any kind of object that implements the <code class="literal">+</code> operator; we can amalgamate a list of lists to create a very long list. Here's an example of using these collection functions with a simple <code class="literal">set</code> object:</p><div><pre class="programlisting">&gt;&gt;&gt; some_set = {7, 2, 3, 5}
&gt;&gt;&gt; sorted(some_set)
[2, 3, 5, 7]
&gt;&gt;&gt; max(some_set)
7
&gt;&gt;&gt; min(some_set)
2
&gt;&gt;&gt; sum(some_set)
17</pre></div><p>We've created<a class="indexterm" id="id350"/> a set with four integers in it. When we evaluate the <code class="literal">sorted()</code> function, we get a <code class="literal">list</code> object which contains the items sorted into ascending order. When we evaluate <code class="literal">max()</code> or <code class="literal">min()</code> functions, we get the largest or smallest value in the collection. The <code class="literal">sum()</code> function adds up the values in the set collection.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec54"/>Using the set collection</h1></div></div></div><p>All of the <a class="indexterm" id="id351"/>collections we've looked at previously have been sequences: <code class="literal">str</code>, <code class="literal">bytes</code>, <code class="literal">tuple</code>, and <code class="literal">list</code> have items which can be accessed by their position within the collection. A <code class="literal">set</code> collection is an unordered collection where items are present or absent.</p><p>Items in a <code class="literal">set</code> collection must be immutable; they must provide a proper hash value as well as an equality test. This means that we can create sets of numbers, strings, and tuples. We can't easily create a set of lists or a set of sets.</p><p>The syntax of a <code class="literal">set</code> display is a sequence of expressions wrapped in <code class="literal">{}</code>. </p><p>Here's an example <code class="literal">set</code> built using numbers:</p><div><pre class="programlisting">&gt;&gt;&gt; fib_set = {1, 1, 3, 5, 8}
&gt;&gt;&gt; fib_set
{8, 1, 3, 5}</pre></div><p>We've created a <code class="literal">set</code> object by enclosing the values in <code class="literal">{}</code>. This syntax looks very similar to the syntax for creating <code class="literal">list</code> or <code class="literal">tuple</code>. Note that the elements in the <code class="literal">set</code> collection are displayed in a different order. There's no guarantee what the order will be; different implementations may show different orders.</p><p>It's important to note that we tried to include two instances of the integer 1 in the <code class="literal">set</code> collection. Since an item is either present in the <code class="literal">set</code> collection or absent, the item cannot be included a second time. Duplicate items are silently ignored.</p><p>We can also create a <code class="literal">set</code> collection by applying the <code class="literal">set()</code> function to a collection of values. We can create a <code class="literal">set</code> collection from a <code class="literal">list</code> or <code class="literal">tuple</code> collection. We can also create a <code class="literal">set</code> collection from a simple string: each individual character will become an item in the resulting set. We can use <code class="literal">set([1, 1, 3, 5, 8])</code> to apply the <code class="literal">set()</code> function to a literal list object.</p><p>The syntax <code class="literal">{}</code>, interestingly, does not create an empty <code class="literal">set</code>. This actually creates an empty <code class="literal">dict</code> class. To create an empty <code class="literal">set</code>, we must use the <code class="literal">set()</code> function.</p><p>We have a fairly large number of operators for set objects. In addition to the operators, we also have a large number of method functions. These can be categorized as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Mutators</strong>: These <a class="indexterm" id="id352"/>modify a <code class="literal">set</code> object</li><li class="listitem" style="list-style-type: disc"><strong>Accessors</strong>: These <a class="indexterm" id="id353"/>access a list and return a fact about that <code class="literal">set</code> object.</li></ul></div><p>The <a class="indexterm" id="id354"/>mutator methods of a <code class="literal">set</code> collection almost always return a value of <code class="literal">None</code>. With the exception of the <code class="literal">pop()</code> method, mutators don't return a value. The accessors, which provide information about a list, must return a value. We'll look at the operators first.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec53"/>Using set operators</h2></div></div></div><p>Sets<a class="indexterm" id="id355"/> have a large number of operators which closely parallel mathematical operators for sets. The mapping leverages the bit-oriented operators; it interprets them to mean set membership instead of bits in an integer value.</p><p>We have the following operators: <code class="literal">|</code>, <code class="literal">&amp;</code>, <code class="literal">-</code>, and <code class="literal">^</code>, which stand for union (<img alt="Using set operators" src="img/B03671_06_03.jpg"/>), intersection (<img alt="Using set operators" src="img/B03671_06_04.jpg"/>), difference (<img alt="Using set operators" src="img/B03671_06_05.jpg"/>), and symmetric difference (<img alt="Using set operators" src="img/B03671_06_06.jpg"/>).</p><p>Examples of these two sets are:</p><div><pre class="programlisting">&gt;&gt;&gt; words = set("How I wish".split())
{'How', 'I', 'wish'}
&gt;&gt;&gt; more = set("I could recollect pi".split())
{'recollect', 'pi', 'I', 'could'}</pre></div><p>Each set is built by splitting a string into individual space-separated words. The results contain the proper elements; the order, however, may vary. Here are examples of each of the operators:</p><div><pre class="programlisting">&gt;&gt;&gt; words | more
{'wish', 'could', 'pi', 'I', 'How', 'recollect'}
&gt;&gt;&gt; words &amp; more
{'I'}
&gt;&gt;&gt; words - more
{'How', 'wish'}
&gt;&gt;&gt; words ^ more
{'recollect', 'wish', 'pi', 'How', 'could'}</pre></div><p>The union operator creates a new set with elements that are drawn from both sets. We could say that the union of <code class="literal">a | b</code> creates a set of elements, {<em>x</em>}, where each element is either an element of <em>a</em> <strong>or</strong> an element of <em>b</em>. There's a tidy parallel between the concept of the Boolean <strong>or</strong> operator and the set union.</p><p>The intersection operator, <code class="literal">a &amp; b</code>, finds the items which are an element of <em>a</em> <strong>and</strong> an element of <em>b</em>. Again, there's<a class="indexterm" id="id356"/> a close parallel between the Boolean <strong>and</strong> operator and set intersection.</p><p>The set <a class="indexterm" id="id357"/>difference operator will remove items from the left set which are in the right set. We could say that the resulting elements are elements of <em>a</em> and not elements of <em>b</em>. There's no commonly-used Boolean operator which parallels the definition of set difference.</p><p>The symmetric difference operators are the items unique to both sets; the common items have been<a class="indexterm" id="id358"/> removed. This corresponds to the <strong>exclusive or</strong> Boolean operation. We could say that the result is members of <em>a</em> or members of <em>b</em> but not members of both sets.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec54"/>Mutating a set with method functions</h2></div></div></div><p>Sets<a class="indexterm" id="id359"/> have some mutators which parallel those of a <code class="literal">list</code> collection. These methods include <code class="literal">add()</code>, <code class="literal">remove()</code>, <code class="literal">discard()</code>, and <code class="literal">clear()</code>. Since the methods are mutators, they do not return a useful value. The <code class="literal">add()</code> method parallels <code class="literal">list.append()</code>: it adds a single item to the set. </p><p>The <code class="literal">remove()</code> and <code class="literal">discard()</code> methods will remove an item from a set; the <code class="literal">remove()</code> method will raise an exception if the item is not in the set, the <code class="literal">discard()</code> method always succeeds, even if the item is not in the set. The <code class="literal">clear()</code> method discards all items from the set.</p><p>We can, for example, update our <code class="literal">fib_set</code> variable like this:</p><div><pre class="programlisting">f_n = max(fib_set)
f_n1 = max(fib_set-{f_n})
fib_set.add(f_n+f_n1)</pre></div><p>We've located the largest value in the set, and assigned this to the <code class="literal">f_n</code> variable. We used the set difference operator to create a new set without the maximum value. When we evaluate <code class="literal">max()</code> on this new set, we'll get the next-to-largest value. Finally, we mutated the set with the <code class="literal">add()</code> method to insert a value into the set.</p><p>The set difference operator, <code class="literal">-</code>, does not mutate the set: like all arithmetic operators, it creates a new object from the operands. The <code class="literal">add()</code> method, however, does mutate the given set.</p><p>Note that Fibonacci numbers aren't the best use of a <code class="literal">set</code> collection. The first two Fibonacci numbers are both one.</p><p>The <code class="literal">pop()</code> method<a class="indexterm" id="id360"/> is unique; it is a mutator which also returns a value. The value popped from the set will be selected arbitrarily. There's no easy way to predict which item will be removed and returned.</p><p>Each of the operators has a method function that matches the operator. The following operators: <code class="literal">|</code>, <code class="literal">&amp;</code>, <code class="literal">-</code>, and <code class="literal">^</code> correspond to<a class="indexterm" id="id361"/> the <code class="literal">update()</code>, <code class="literal">intersection()</code>, <code class="literal">difference()</code>, and <code class="literal">symmetric_difference()</code> methods. We can write <code class="literal">a | b</code> or we can write <code class="literal">a.update(b)</code>. Both have the same results.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec55"/>Using augmented assignment with sets</h2></div></div></div><p>The <a class="indexterm" id="id362"/>augmented assignment statements also work well with sets. We can use <code class="literal">|=</code>, <code class="literal">&amp;=</code>, <code class="literal">-=</code>, and <code class="literal">^=</code>, to update a set based on elements from another set. For example, consider this statement:</p><div><pre class="programlisting">words |= more</pre></div><p>The <code class="literal">words</code> set will be mutated to include all the items from the <code class="literal">more</code> set.</p><p>Each of the augmented assignment statements also has a corresponding update method. The method names for these mutators are <code class="literal">update()</code>, <code class="literal">intersection_update()</code>, <code class="literal">difference_update()</code>, and <code class="literal">symmetric_difference_update()</code>. These methods are mutators which match the augmented assignment statements.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec56"/>Accessing a set with operators and method functions</h2></div></div></div><p>There<a class="indexterm" id="id363"/> are a few operators which count as <a class="indexterm" id="id364"/>set accessors. Perhaps the most fundamental method for accessing a set is the <code class="literal">in</code> operator; this will check to see if a particular element exists in a set.</p><div><pre class="programlisting">&gt;&gt;&gt; 'I' in words
True</pre></div><p>The comparison operators for sets implement basic set theory operations. When we use <code class="literal">&lt;</code>, <code class="literal">&lt;=</code>, <code class="literal">&gt;</code>, or <code class="literal">&gt;=</code> between two sets, we're doing subset and superset comparisons. For example:</p><div><pre class="programlisting">&gt;&gt;&gt; {'I'} &lt; words
True
&gt;&gt;&gt; {'How', 'I', 'wish'} &lt;= words
True</pre></div><p>In the first case, the set <code class="literal">{'I'}</code> is a proper subset of the set in the words variable. In the second case, the improper subset comparison was <code class="literal">True</code>, because the two sets are actually equal.</p><p>We also have method functions that match the various comparison operators. We can use <code class="literal">isdisjoint()</code>, <code class="literal">issubset()</code>, and <code class="literal">issuperset()</code> in addition to the <code class="literal">!=</code>, <code class="literal">&lt;</code>, and <code class="literal">&gt;</code> operators.</p><p>There's little practical difference between <code class="literal">item in set</code> and <code class="literal">{item} &lt;= set</code>. It's also true that <code class="literal">set–{item} != set</code> would be true when the given <code class="literal">item</code> is in the <code class="literal">set</code>. These mathematical<a class="indexterm" id="id365"/> equivalences are interesting, but<a class="indexterm" id="id366"/> often involve extra computation.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec55"/>Mappings</h1></div></div></div><p>Python <a class="indexterm" id="id367"/>has a number of mapping collections. A mapping is an association between a key and a value. The built-in mapping collection is the <code class="literal">dict</code> class. The other mappings are defined in the <code class="literal">collections</code> library, and must be imported.</p><p>Items that are keys within a mapping must be immutable; they must provide a proper hash value as well as a matching equality test. The values within a mapping have no restrictions; they can be mutable or immutable. The order of the keys is not maintained by the <code class="literal">dict</code> class.</p><p>We can create a simple <code class="literal">dict</code> display using <code class="literal">{}</code>; each key and value are separated by the <code class="literal">:</code> character. </p><p>Here's an example of a simple mapping:</p><div><pre class="programlisting">sieve = {2: True, 3: True, 4: False, 5: True, 6: None, 7: None}</pre></div><p>We've created a simple mapping with keys that are all integers, and values which are a mixture of Boolean and <code class="literal">None</code> values.</p><p>We can also create a dictionary using the <code class="literal">dict()</code> function. This function can build a dictionary from a variety of sources. We can provide an existing dictionary as an argument; the <code class="literal">dict()</code> function will make a shallow copy of that source dictionary. We can provide a sequence of <code class="literal">(key, value)</code> two-tuples. It would look like this:</p><div><pre class="programlisting">&gt;&gt;&gt; sieve = dict(
... [(2, True), (3, True), (4, False), (5, True), (6, None), (7, None)]
... )</pre></div><p>This example created a dictionary from a list of <code class="literal">(key, value)</code> two-tuples. The resulting dictionary object that's created will match the literal display shown in the preceding example.</p><p>We can also create dictionaries with string keys using the <code class="literal">dict()</code> function. When we provide keyword arguments, they become the keys.</p><div><pre class="programlisting">&gt;&gt;&gt; cadaeic= dict( poe=3, e=1, near=4, a=1, raven=5, midnights= 9 )
&gt;&gt;&gt; cadaeic
{'raven': 5, 'e': 1, 'near': 4, 'midnights': 9, 'poe': 3, 'a': 1}</pre></div><p>It's important to repeat the observation that the order of the keys in a built-in <code class="literal">dict</code> object is not defined.</p><p>We can also build a dictionary from a set of keys, providing a single default value. We can do this as follows:</p><div><pre class="programlisting">&gt;&gt;&gt; sieve = dict.fromkeys( range(2,10) )
&gt;&gt;&gt; sieve
{2: None, 3: None, 4: None, 5: None, 6: None, 7: None, 8: None, 9: None}</pre></div><p>We've <a class="indexterm" id="id368"/>used the <code class="literal">range()</code> function to iterate through a series of numbers which start with two and end just before ten. These numbers are then used to create keys for a dictionary. The value associated with each key is the default of <code class="literal">None</code>.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec57"/>Using dictionary operators</h2></div></div></div><p>All Python <a class="indexterm" id="id369"/>mappings, including the built-in <code class="literal">dict</code>, use a key in [] to get, set, and delete items. The syntax looks like this:</p><div><pre class="programlisting">&gt;&gt;&gt; cadaeic['poe']
3
&gt;&gt;&gt; cadaeic['so']= 2
&gt;&gt;&gt; del cadaeic['so']</pre></div><p>We've provided literal strings to show how we can get an item, set an item, and use the <code class="literal">del</code> statement to delete an item.</p><p>Note that dictionary comparisons are difficult to define in a general way. It's not perfectly clear if an ordering comparison should compare only the keys, only the values, or a combination of keys and values. Consequently, only <code class="literal">==</code> and <code class="literal">!=</code> comparisons among dictionaries are defined.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec58"/>Using dictionary mutators</h2></div></div></div><p>We<a class="indexterm" id="id370"/> can use <code class="literal">dict[key]</code> on the left side of an assignment statement to modify a dictionary. This will insert the given key and value if the key does not exist; if the key already exists, it will change the value associated with the key.</p><p>We also have a number of methods that we can use to mutate a dictionary object. These methods include <code class="literal">clear()</code>, <code class="literal">pop()</code>, <code class="literal">popitem()</code>, <code class="literal">setdefault()</code>, and <code class="literal">update()</code> to modify a dictionary object.</p><p>The <code class="literal">clear()</code> and <code class="literal">update()</code> methods don't return a useful value. The <code class="literal">clear()</code> method will empty the dictionary. The <code class="literal">update()</code> method will fold additional data into an existing dictionary. This method will accept the same variety of arguments as the <code class="literal">dict()</code> function that creates a dictionary. The first positional argument can be a dictionary object or a sequence of <code class="literal">(key, value)</code> two-tuples. Additionally, we can provide any number of keyword arguments; the keywords will become keys in the updated dictionary.</p><p>Here are two examples that show some of the different ways in which the <code class="literal">update()</code> method can be used:</p><div><pre class="programlisting">&gt;&gt;&gt; cadaeic.update( {'so':2, 'dreary':6} )
&gt;&gt;&gt; cadaeic.update( [('tired',5), ('and',3)], weary=5 )
&gt;&gt;&gt; cadaeic
{'a': 1, 'weary': 5, 'near': 4, 'dreary': 6, 'e': 1,
'raven': 5, 'midnights': 9, 'and': 3, 'so': 2, 'poe': 3,
'tired': 5}</pre></div><p>We've <a class="indexterm" id="id371"/>updated the <code class="literal">cadaeic</code> dictionary object using another dictionary with two items. Then we applied further updates using a sequence of <code class="literal">(key, value)</code> two-tuples. The second example also included an additional keyword argument, which inserted the key <code class="literal">'weary'</code> into the dictionary.</p><p>The <code class="literal">setdefault()</code> method function is an interesting special case. This is a variation on the <code class="literal">get()</code> accessor. The <code class="literal">get()</code> method (and the <code class="literal">pop()</code> method) has a provision for a default value. The <code class="literal">setdefault()</code> method doesn't merely return the default value if the key is missing—paralleling what <code class="literal">get()</code> does. The <code class="literal">setdefault()</code> method updates the dictionary to be sure that the default value is now in the dictionary. All subsequent <code class="literal">setdefault()</code> or <code class="literal">get()</code> methods will find the key in the dictionary.</p><p>The sequence of operations might look something like this:</p><div><pre class="programlisting">&gt;&gt;&gt; counter = {}
&gt;&gt;&gt; counter.setdefault('a',0)
0
&gt;&gt;&gt; counter['a'] += 1
&gt;&gt;&gt; counter
{'a': 1}</pre></div><p>We've created an empty dictionary and assigned it to the <code class="literal">counter</code> variable. When we use <code class="literal">counter.setdefault('a',0)</code>, we'll get the value associated with a key of <code class="literal">'a'</code>, or we'll get the default value of zero. In addition to returning, the default value will also be used to update the dictionary, assuring that there is a value associated with the given key.</p><p>We can then do a simple, easy-to-understand <code class="literal">counter['a'] += 1</code> knowing that the key, <code class="literal">'a'</code>, has a value in the dictionary. Either the key already existed, and the <code class="literal">setdefault()</code> function did nothing or the key did not exist, and the <code class="literal">setdefault()</code> function provided that default value.</p><p>Since <code class="literal">setdefault()</code> returns a value, we can optimize this into something like this:</p><div><pre class="programlisting">&gt;&gt;&gt; counter['b'] = counter.setdefault('b',0) + 1</pre></div><p>This <code class="literal">setdefault()</code> process is so common that there are two closely-related classes in <code class="literal">collections</code>. The <code class="literal">defaultdict</code> class simply treats all <code class="literal">get()</code> operations like <code class="literal">setdefault()</code>. The <code class="literal">Counter</code> class will implicitly do the <code class="literal">count[key]+=1</code> process for any iterable, building on the <code class="literal">defaultdict</code> class.</p><p>There are two variations on the <code class="literal">pop()</code> method. The typical implementation of <code class="literal">pop()</code> will remove a given key and return the value associated with that key. Beyond this, the <code class="literal">popitem()</code> method will remove and return one <code class="literal">(key, value)</code> pair from a dictionary. The pair will <a class="indexterm" id="id372"/>be chosen arbitrarily. In both cases, the dictionary is updated to remove the value.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec59"/>Using methods for accessing items in a mapping</h2></div></div></div><p>We<a class="indexterm" id="id373"/> have a number of methods to access items in a mapping. First and foremost, we have the <code class="literal">dict[key]</code> construct which locates the value associated with the given key. If the key does not exist, the <code class="literal">KeyError</code> exception is raised.</p><p>The <code class="literal">get()</code> method will also return the value associated with a key in the dictionary. The <code class="literal">get()</code> method can also provide a default value. We can use <code class="literal">cadaeic.get("word",4)</code> to locate the key (<code class="literal">"word"</code> in this example). If the key is not found the default, <code class="literal">4</code>, is returned.</p><p>The <code class="literal">copy()</code> method returns a shallow copy of the dictionary. We can do <code class="literal">a=dict(d)</code> or <code class="literal">a= d.copy()</code> to make a new dictionary, which is a copy of an original dictionary. Both are equivalent.</p><p>There are three methods which expose important features of a mapping:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">keys()</code> is the sequence of keys from the mapping. By default, this is used when<a class="indexterm" id="id374"/> converting a mapping to another collection. If we use <code class="literal">set(cadaeic)</code> or <code class="literal">list(cadaiec)</code>, we'll see just the key values in the set or list object. The value of <code class="literal">sorted(cadaeic)</code> is the same as <code class="literal">sorted(cadaeic.keys())</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">values()</code> is<a class="indexterm" id="id375"/> the sequence of values from the mapping.</li><li class="listitem" style="list-style-type: disc"><code class="literal">items()</code> is<a class="indexterm" id="id376"/> the sequence of <code class="literal">(key, value)</code> pairs from the mapping. This list of two-tuples can be used to rebuild the dictionary. If we use <code class="literal">tuple(cadaeic.items())</code>, we've created a tuple of two-tuples. This tuple is immutable, and can be used as a key to another mapping or as an item in a set. This is a way of "freezing" a dictionary to create an immutable copy.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec60"/>Using extensions from the collections module</h2></div></div></div><p>The <em>Python Standard Library</em> includes the <code class="literal">collections</code> module. This module offers us a <a class="indexterm" id="id377"/>number of alternatives to the built-in collections. This module has the following additional collections:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We can import the <code class="literal">namedtuple</code> function and use this to create variations on the basic <code class="literal">tuple</code> that includes named attributes in addition to attributes identified by their positional index.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">deque</code> class defines a double-ended queue, like a <code class="literal">list</code> collection that can perform fast <code class="literal">append()</code> and <code class="literal">pop()</code> functions on either end. A subset of the features of this class will create single-ended stack (LIFO) or queue (FIFO) structures.</li><li class="listitem" style="list-style-type: disc">In some cases, we can use a <code class="literal">ChainMap</code> instead of merging mappings, via <code class="literal">update()</code>. The result is a view of multiple mappings rather than a single, updated mapping. This can be built very quickly; a search takes longer than a single mapping.</li><li class="listitem" style="list-style-type: disc">An <code class="literal">OrderedDict</code> mapping is a mapping which maintains the order in which the keys were created.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">defaultdict</code> class is a subclass of the built-in <code class="literal">dict</code> that uses a factory function to provide values for missing keys.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Counter</code> class is a <code class="literal">dict</code> subclass that counts objects to create frequency tables. It is also used as a more sophisticated data structure called a multiset or bag.</li></ul></div><p>We can create letter frequencies using a <code class="literal">Counter</code> class quite simply. A <code class="literal">Counter</code> will count the occurrences of items in the sequence. Given a string, which is an iterable sequence of characters, creating a <code class="literal">Counter</code> leads directly to a frequency table. Here's an example:</p><div><pre class="programlisting">&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; text = """Poe, E.
... Near a Raven
...
... Midnights so dreary, tired and weary,
... Silently pondering volumes extolling all by-now obsolete lore.
... During my rather long nap - the weirdest tap!
... An ominous vibrating sound disturbing my chamber's antedoor.
... "This", I whispered quietly, "I ignore"."""
&gt;&gt;&gt; freq= Counter(text)
&gt;&gt;&gt; freq.most_common(5)
[(' ', 35), ('e', 23), ('n', 18), ('r', 17), ('i', 17)]</pre></div><p>We've imported the <code class="literal">Counter</code> class from the <code class="literal">collections</code> module. We've also set a variable, <code class="literal">text</code>, to a piece of a poem by Mike Keith. For more of this poem, see <a class="ulink" href="http://www.cadaeic.net/naraven.htm">http://www.cadaeic.net/naraven.htm</a>.</p><p>We created a <code class="literal">Counter</code> object using the string of characters as the source. A <code class="literal">Counter</code> object will iterate through each item in the sequence, counting the number of occurrences of that item. When we use the <code class="literal">most_common()</code> method, we'll see the five most common items in the collection. If we were to simply print the value of the <code class="literal">freq</code> variable, we'd see all of the character frequencies.</p><p>Each of these collections offers unique features. If the built-in <code class="literal">dict</code>, <code class="literal">list</code>, or <code class="literal">tuple</code> doesn't meet our needs, one of these additional collections may be more suitable for the problem<a class="indexterm" id="id378"/> we're tying to solve.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec56"/>Processing collections with the for statement</h1></div></div></div><p>The <code class="literal">for</code> statement is an extremely versatile way to process every item in a collection. We do this by <a class="indexterm" id="id379"/>defining a target variable, a source of items, and a <a class="indexterm" id="id380"/>suite of statements. The <code class="literal">for</code> statement will iterate through the source of items, assigning each item to the target variable, and also execute the suite of statements. All of the collections in Python provide the necessary methods, which means that we can use <em>anything</em> as the source of items in a <code class="literal">for</code> statement.</p><p>Here's some sample data that we'll work with. This is part of Mike Keith's poem, <em>Near a Raven</em>. We'll remove the punctuation to make the text easier to work with:</p><div><pre class="programlisting">&gt;&gt;&gt; text = '''Poe, E.
...      Near a Raven
...
... Midnights so dreary, tired and weary.'''
&gt;&gt;&gt; text = text.replace(",","").replace(".","").lower()</pre></div><p>This will put the original text, with uppercase and lowercase and punctuation into the <code class="literal">text</code> variable. We used some method functions from <a class="link" href="ch02.html" title="Chapter 2. Simple Data Types">Chapter 2</a>, <em>Simple Data Types</em>, to remove the common punctuation marks and return a version of the entire string entirely composed of lowercase letters.</p><p>When we use <code class="literal">text.split()</code>, we get a sequence of individual words. The <code class="literal">for</code> loop can iterate through this sequence of words so that we can process each one. The syntax looks like this:</p><div><pre class="programlisting">&gt;&gt;&gt; cadaeic= {}
&gt;&gt;&gt; for word in text.split():
...     cadaeic[word]= len(word)</pre></div><p>We've created an empty dictionary, and assigned it to the <code class="literal">cadaeic</code> variable. The expression in the <code class="literal">for</code> loop, <code class="literal">text.split()</code>, will create a sequence of substrings. Each of these substrings will be assigned to the <code class="literal">word</code> variable. The <code class="literal">for</code> loop body—a single assignment statement—will be executed once for each value assigned to <code class="literal">word</code>.</p><p>The resulting dictionary might look like this (irrespective of ordering):</p><div><pre class="programlisting">{'raven': 5, 'midnights': 9, 'dreary': 6, 'e': 1,
'weary': 5, 'near': 4, 'a': 1, 'poe': 3, 'and': 3,
'so': 2, 'tired': 5}</pre></div><p>There's no guaranteed order for mappings or sets. Your results may differ slightly.</p><p>In addition to iterating over a sequence, we can also iterate over the keys in a dictionary.</p><div><pre class="programlisting">&gt;&gt;&gt; for word in sorted(cadaeic):
...    print(word,  cadaeic[word])</pre></div><p>When we use <code class="literal">sorted()</code> on a <code class="literal">tuple</code> or a <code class="literal">list</code>, an interim list is created with sorted items. When <a class="indexterm" id="id381"/>we apply <code class="literal">sorted()</code> to a mapping, the sorting<a class="indexterm" id="id382"/> applies to the keys of the mapping, creating a sequence of sorted keys. This loop will print a list in alphabetical order of the various <em>pilish</em> words used in this poem.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>Pilish is a subset of English where the word lengths are important: they're used as mnemonic aids.</p></div></div><p>A <code class="literal">for</code> statement corresponds to the "for all" logical quantifier, <img alt="Processing collections with the for statement" src="img/B03671_06_12.jpg"/>. At the end of a simple <code class="literal">for</code> loop we can assert that all items in the source collection have been processed. In order to build the "there exists" quantifier, <img alt="Processing collections with the for statement" src="img/B03671_06_13.jpg"/>, we can either use the <code class="literal">while</code> statement, or the <code class="literal">break</code> statement inside the body of a <code class="literal">for</code> statement.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec61"/>Using literal lists in a for statement</h2></div></div></div><p>We <a class="indexterm" id="id383"/>can apply the <code class="literal">for</code> statement to a sequence of literal values. One of the most common ways to present literals is as a <code class="literal">tuple</code>. It might look like this:</p><div><pre class="programlisting">for scheme in 'http', 'https', 'ftp':
    do_something(scheme)</pre></div><p>This will assign three different values to the <code class="literal">scheme</code> variable. For each of those values, it will evaluate the <code class="literal">do_something()</code> function.</p><p>From this, we can see that, strictly-speaking, the <code class="literal">()</code> are not required to delimit a <code class="literal">tuple</code> object. If the sequence of values grows, however, and we need to span more than one physical <a class="indexterm" id="id384"/>line, we'll want to <code class="literal">add ()</code>, making the <code class="literal">tuple</code> literal more explicit.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec62"/>Using the range() and enumerate() functions</h2></div></div></div><p>The<a class="indexterm" id="id385"/> <code class="literal">range()</code> object will provide a sequence <a class="indexterm" id="id386"/>of numbers, often used in a <code class="literal">for</code> loop. The <code class="literal">range()</code> object is iterable, it's not itself a sequence object. It's a generator, which will produce items when required. If we use <code class="literal">range()</code> outside a <code class="literal">for</code> statement, we need to use a function like <code class="literal">list(range(x))</code> or <code class="literal">tuple(range(a,b))</code> to consume all of the generated values and create a new sequence object.</p><p>The <code class="literal">range()</code> object <a class="indexterm" id="id387"/>has three commonly-used forms:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">range(n)</code> produces ascending numbers including 0 but not including <code class="literal">n</code> itself. This is a half-open interval. We could say that <code class="literal">range(n)</code> produces numbers, <em>x</em>, such that <img alt="Using the range() and enumerate() functions" src="img/B03671_06_07.jpg"/>. The expression <code class="literal">list(range(5))</code> returns <code class="literal">[0, 1, 2, 3, 4]</code>. This produces <em>n</em> values including 0 and <em>n</em> - 1.
</li><li class="listitem" style="list-style-type: disc"><code class="literal">range(a,b)</code> produces ascending numbers starting from <code class="literal">a</code> but not including <code class="literal">b</code>. The<a class="indexterm" id="id388"/> expression <code class="literal">tuple(range(-1,3))</code> will return <code class="literal">(-1, 0, 1, 2)</code>. This produces <em>b</em> - <em>a</em> values <a class="indexterm" id="id389"/>including <em>a</em> and <em>b </em>- 1.</li><li class="listitem" style="list-style-type: disc"><code class="literal">range(x,y,z)</code> produces ascending numbers in the sequence <img alt="Using the range() and enumerate() functions" src="img/B03671_06_08.jpg"/>. This produces (<em>y</em>-<em>x</em>)//<em>z</em> values.
</li></ul></div><p>We can use the <code class="literal">range()</code> object like this:</p><div><pre class="programlisting">for n in range(1, 21):
    status= str(n)
    if n % 5 == 0: status += " fizz"
    if n % 7 == 0: status += " buzz"
    print(status)</pre></div><p>In this example, we've used a <code class="literal">range()</code> object to produce values, <em>n</em>, such that <img alt="Using the range() and enumerate() functions" src="img/B03671_06_09.jpg"/>.</p><p>We use the <code class="literal">range()</code> object to generate the index values for all items in a list:</p><div><pre class="programlisting">for n in range(len(some_list)):
    print(n, some_list[n])</pre></div><p>We've used the <code class="literal">range()</code> function to generate values between 0 and the length of the sequence object named <code class="literal">some_list</code>.</p><p>The <code class="literal">for</code> statement allows multiple target variables. The rules for multiple target variables are the same as for a multiple variable assignment statement: a sequence object will be decomposed and items assigned to each variable. Because of that, we can leverage the <code class="literal">enumerate()</code> function to iterate through a sequence and assign the index values at the same time. It looks like this:</p><div><pre class="programlisting">for n, v in enumerate(some_list):
     print(n, v)</pre></div><p>The <code class="literal">enumerate()</code> function is a generator function which iterates through the items in source <a class="indexterm" id="id390"/>sequence and yields a sequence of two-tuple <a class="indexterm" id="id391"/>pairs with the index and the item. Since we've provided two variables, the two-tuple is decomposed and assigned to each variable.</p><p>There are numerous use cases for this multiple-assignment <code class="literal">for</code> loop. We often have list-of-tuples data structures that can be handled very neatly with this multiple-assignment feature. In <a class="link" href="ch08.html" title="Chapter 8. More Advanced Functions">Chapter 8</a>, <em>More Advanced Functions</em>, we'll look at a number of these design patterns.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec57"/>Iterating with the while statement</h1></div></div></div><p>The <code class="literal">while</code> statement is a more general iteration than the <code class="literal">for</code> statement. We'll use a <code class="literal">while</code> loop<a class="indexterm" id="id392"/> in two situations. We'll use this in cases where we don't have a finite collection to impose an upper bound on the loop's iteration; we may suggest an upper bound in the <code class="literal">while</code> clause itself. We'll also use this when writing a "search" or "there exists" kind of loop; we aren't processing all items in a collection.</p><p>A desktop application that accepts input from a user, for example, will often have a <code class="literal">while</code> loop. The application runs until the user decides to quit; there's no upper bound on the number of user interactions. For this, we generally use a <code class="literal">while True:</code> loop. Infinite iteration is recommended.</p><p>If we want to write a character-mode user interface, we could do it like this:</p><div><pre class="programlisting">quit_received= False
while not quit_received:
    command= input("prompt&gt; ")
    quit_received= process(command)</pre></div><p>This will iterate until the <code class="literal">quit_received</code> variable is set to <code class="literal">True</code>. This will process indefinitely; there's no upper boundary on the number of iterations.</p><p>This <code class="literal">process()</code> function might use some kind of command processing. This should include a statement like this:</p><div><pre class="programlisting">if command.lower().startswith("quit"): return True</pre></div><p>When the user enters <code class="literal">"quit"</code>, the <code class="literal">process()</code> function will return <code class="literal">True</code>. This will be assigned to the <code class="literal">quit_received</code> variable. The <code class="literal">while</code> expression, <code class="literal">not quit_received</code>, will become <code class="literal">False</code>, and the loop ends.</p><p>A "there exists" loop will iterate through a collection, stopping at the first item that meets certain criteria. This can look complex because we're forced to make two details of loop processing explicit.</p><p>Here's an example of searching for the first value that meets a condition. This example assumes that we have a function, <code class="literal">condition()</code>, which will eventually be <code class="literal">True</code> for some number. Here's how we can use a <code class="literal">while</code> statement to locate the minimum for which this function is <code class="literal">True</code>:</p><div><pre class="programlisting">&gt;&gt;&gt; n = 1
&gt;&gt;&gt; while n != 101 and not condition(n):
...     n += 1
&gt;&gt;&gt; assert n == 101 or condition(n)</pre></div><p>The <code class="literal">while</code> statement will terminate when <code class="literal">n == 101</code> or the <code class="literal">condition(n)</code> is <code class="literal">True</code>. If this expression is <code class="literal">False</code>, we can advance the <code class="literal">n</code> variable to the next value in the sequence of values. Since we're iterating through the values in order from the smallest to the largest, we know that <code class="literal">n</code> will be the smallest value for which the <code class="literal">condition()</code> function is true.</p><p>At the <a class="indexterm" id="id393"/>end of the <code class="literal">while</code> statement we have included a formal assertion that either <code class="literal">n</code> is 101 or the <code class="literal">condition()</code> function is <code class="literal">True</code> for the given value of <code class="literal">n</code>. Writing an assertion like this can help in design as well as debugging because it will often summarize the loop invariant condition.</p><p>We can also write this kind of loop using the <code class="literal">break</code> statement in a <code class="literal">for</code> loop, something we'll look at in the next section.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec58"/>The continue and break statements</h1></div></div></div><p>The <code class="literal">continue</code> statement is<a class="indexterm" id="id394"/> helpful for skipping items<a class="indexterm" id="id395"/> without writing deeply-nested <code class="literal">if</code> statements. The effect of executing a <code class="literal">continue</code> statement is to skip the rest of the loop's suite. In a <code class="literal">for</code> loop, this means that the next item will be taken from the source iterable. In a <code class="literal">while</code> loop, this must be used carefully to avoid an otherwise infinite iteration.</p><p>We might see file processing that looks like this:</p><div><pre class="programlisting">for line in some_file:
    clean = line.strip()
    if len(clean) == 0:
        continue
    data, _, _ = clean.partition("#")
    data = data.rstrip()
    if len(data) == 0:
        continue
    process(data)</pre></div><p>In this loop, we're relying on the way files act like sequences of individual lines. For each line in the file, we've stripped whitespace from the input line, and assigned the resulting string to the <code class="literal">clean</code> variable. If the length of this string is zero, the line was entirely whitespace, and we'll continue the loop with the next line. The <code class="literal">continue</code> statement skips the remaining statements in the body of the loop.</p><p>We'll partition the line into three pieces: a portion in front of any <code class="literal">"#"</code>, the <code class="literal">"#"</code> (if present), and the portion after any <code class="literal">"#"</code>. We've assigned the <code class="literal">"#"</code> character and any text after the <code class="literal">"#"</code> character to the same easily-ignored variable, <code class="literal">_</code>, because we don't have any use for these two results of the <code class="literal">partition()</code> method. We can then strip any trailing whitespace from the string assigned to the <code class="literal">data</code> variable. If the resulting string has a length of zero, then the line is entirely filled with <code class="literal">"#"</code> and any trailing comment text. Since there's no useful data, we can continue the loop, ignoring this line of input.</p><p>If the line passes the two <code class="literal">if</code> conditions, we can process the resulting data. By using the <code class="literal">continue</code> statement, we have avoided complex-looking, deeply-nested <code class="literal">if</code> statements. We'll examine files in detail in <a class="link" href="ch10.html" title="Chapter 10. Files, Databases, Networks, and Contexts">Chapter 10</a>, <em>Files, Databases, Networks, and Contexts</em>.</p><p>It's important to <a class="indexterm" id="id396"/>note that a <code class="literal">continue</code> statement must <a class="indexterm" id="id397"/>always be part of the suite inside an <code class="literal">if</code> statement, inside a <code class="literal">for</code> or <code class="literal">while</code> loop. The condition on that <code class="literal">if</code> statement becomes a filter condition that applies to the collection of data being processed. <code class="literal">continue</code> always applies to the innermost loop.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec63"/>Breaking early from a loop</h2></div></div></div><p>The <code class="literal">break</code> statement is a profound change in the semantics of the loop. An ordinary <code class="literal">for</code> statement can<a class="indexterm" id="id398"/> be summarized by "for all." We can comfortably say that "for all items in a collection, the suite of statements was processed."</p><p>When we use a <code class="literal">break</code> statement, a loop is no longer summarized by "for all." We need to change our perspective to "there exists". A <code class="literal">break</code> statement asserts that at least one item in the collection matches the condition that leads to the execution of the <code class="literal">break</code> statement.</p><p>Here's a simple example of a <code class="literal">break</code> statement:</p><div><pre class="programlisting">for n in range(1, 100):
    factors = []
    for x in range(1,n):
        if n % x == 0: factors.append(x)
    if sum(factors) == n:
        break</pre></div><p>We've written a loop that is bound by <img alt="Breaking early from a loop" src="img/B03671_06_10.jpg"/>. This loop includes a <code class="literal">break</code> statement, so it will not process all values of <code class="literal">n</code>. Instead, it will determine the smallest value of <code class="literal">n</code>, for which <code class="literal">n</code> is equal to the sum of its factors. Since the loop doesn't examine all values, it shows that at least one such number exists within the given range.</p><p>We've used a nested loop to determine the factors of the number <code class="literal">n</code>. This nested loop creates a sequence, <code class="literal">factors</code>, for all values of <code class="literal">x</code> in the range <img alt="Breaking early from a loop" src="img/B03671_06_11.jpg"/>, such that <code class="literal">x,</code> is a factor of the number <code class="literal">n</code>. This inner loop doesn't have a <code class="literal">break</code> statement, so we are sure it examines all values in the given range.</p><p>The least value for which this is true is the number six.</p><p>It's important to note that a <code class="literal">break</code> statement must always be part of the suite inside an <code class="literal">if</code> statement inside a <code class="literal">for</code> or <code class="literal">while</code> loop. If the break isn't in an <code class="literal">if</code> suite, the loop will always terminate while processing the first item. The condition on that <code class="literal">if</code> statement becomes the "where exists" condition that summarizes the loop as a whole. Clearly, multiple <code class="literal">if</code> statements<a class="indexterm" id="id399"/> with multiple <code class="literal">break</code> statements mean that the overall loop can have a potentially confusing and difficult-to-summarize post-condition.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec59"/>Using the else clause on a loop</h1></div></div></div><p>Python's <code class="literal">else</code> clause<a class="indexterm" id="id400"/> can be used on a <code class="literal">for</code> or <code class="literal">while</code> statement as well as on an <code class="literal">if</code> statement. The <code class="literal">else</code> clause executes after the loop body if there was no <code class="literal">break</code> statement executed. To see this, here's a contrived example:</p><div><pre class="programlisting">&gt;&gt;&gt; for item in 1,2,3:
...     print(item)
...     if item == 2:
...         print("Found",item)
...         break
... else:
...     print("Found Nothing")</pre></div><p>The <code class="literal">for</code> statement here will iterate over a short list of literal values. When a specific target value has been found, a message is printed. Then, the <code class="literal">break</code> statement will end the loop, avoiding the <code class="literal">else</code> clause.</p><p>When we run this, we'll see three lines of output, like this:</p><div><pre class="programlisting">1
2
Found 2</pre></div><p>The value of three isn't shown, nor is the "Found Nothing" message in the <code class="literal">else</code> clause.</p><p>If we change the target value in the <code class="literal">if</code> statement from two to a value that won't be seen (for example, zero or four), then the output will change. If the <code class="literal">break</code> statement is not executed, then the <code class="literal">else</code> clause will be executed.</p><p>The idea<a class="indexterm" id="id401"/> here is to allow us to write contrasting <code class="literal">break</code> and non-<code class="literal">break</code> suites of statements. An <code class="literal">if</code> statement suite that includes a <code class="literal">break</code> statement can do some processing in the suite before the <code class="literal">break</code> statement ends the loop. An <code class="literal">else</code> clause allows some processing at the end of the loop when none of the <code class="literal">break</code>-related suites statements were executed.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec60"/>Summary</h1></div></div></div><p>We've looked at three mutable collections: lists, sets and dictionaries. The built-in dictionary class is only one of many mappings available in Python, the others are defined in the collections module of the standard library. The list allows us to collect items which are identified by their positions in the list. The set allows us to collect a set of unique items, in which each item is simply identified by itself. A mapping allows us to identify items by a key.</p><p>For sets, each item must be immutable. For mappings, the object used as a key must be immutable. This means that numbers, strings, and tuples are often used as mapping keys.</p><p>We've looked at the <code class="literal">for</code> statement, which is the primary way we'll process the individual items in a collection. A simple <code class="literal">for</code> statement assures us that our processing has been done for all items in the collection. We've also looked at the general purpose <code class="literal">while</code> loop.</p><p>In <a class="link" href="ch07.html" title="Chapter 7. Basic Function Definitions">Chapter 7</a>, <em>Basic Function Definitions</em>, we'll look at how we can define our own functions. We'll also look at the wide variety of ways we can evaluate a function in Python.</p></div></body></html>