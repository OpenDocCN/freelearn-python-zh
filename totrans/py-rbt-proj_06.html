<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Bluetooth-Controlled Robotic Car</h1>
                </header>
            
            <article>
                
<p>We have come a long way; now it's time to go ahead and make something even better. The world is going all gaga over the inception of autonomous cars and within this decade this will become the new normal. There is so much going on in these vehicles. Multiple sensors, GPS, and telemetry are all calculated in real time to make sure that the car is on the right course and is being driven by the system safely on the road, so making a robotic vehicle proves to be an ideal way to learn robotics and future technologies. In this book, we will always try to make technologies that are not only as good as the present technologies but in some ways even better. So, let's go ahead and get to making this autonomous vehicle one step at a time.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>Basics of the vehicle</li>
<li>Getting the vehicle ready</li>
<li>Controlling the vehicle by Bluetooth</li>
</ul>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Basics of the vehicle</h1>
                </header>
            
            <article>
                
<p>You must be thinking: what can we possibly learn about the vehicle that we don't already know? This may be true, but there are a few that we must make sure we understand before taking on this chapter. So, let's get started. </p>
<p>First is the chassis, which we will be using: it's is a four-wheel drive chassis and all the four wheels are independently controlled by a dedicated motor. Hence, we can change the speed of every single wheels as per our needs. We have chosen a four-wheel drive drivetrain as it is harder for it to get stuck on carpets and uneven surfaces. You can also opt for a two-wheel drive drivetrain if you want to do so, as it won't make a huge difference. </p>
<p>Now, once you assemble the chassis you might see that it does not have a steering mechanism. Does this mean that the car will only go straight? Well, obviously not. There are many ways by which we can steer the direction of a car while making small vehicles. The best one is called differential turning. </p>
<p>In conventional cars, there is one engine and that engine powers up the wheels; hence in principal all the wheels turn at the same speed. Now this works fine when we are going straight but whenever the car wants to turn there comes a new problem. Refer to the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/7d25825f-2504-45ec-802c-521a0d2ade0d.png" style="width:40.67em;height:25.83em;"/></div>
<p>You will see that the wheels, which are on the inner curve, have a smaller diameter and the one on the outer edge has a larger diameter. You may remember a fact from elementary school: the larger the diameter the more the circumference, and vice a versa. Hence, the wheel towards the inner edge will be covering a shorter distance compared to the wheels on the outer edge at the same time, or in simple words, the inner wheels will be spinning slower and the outer wheels will be spinning faster.</p>
<p>This problem leads to the discovery of differentials in cars, which is a round lump at the center of the axle of the car. What this does is that it varies the rate at which the wheels are spinning based on the turning radius. Genius, isn't it? Now, you must be thinking: this is all right, but why are you telling me all this? Well, because we will do the exact opposite to turn the robot. If we change the speed of the motors on the inner and outer edge of the turning circle, then the car will try to turn towards inside and similarly if we do it for the other end then it will try to turn in the other direction. While making wheeled robot this strategy is not new at all. Steering mechanisms are complicated and implementing them on small robot is simply a challenge. Hence this is a far simpler and easy way to turn your vehicle around. </p>
<p>Not only is this way simple but it is a very efficient and simple strategy that requires minimal components. It is also better as the turning radius of the vehicle is also reduced. In fact, if we spin the opposite sides of the wheels in the opposite direction at the same speed then the vehicle will turn completely on its own axis, making the turning radius entirely zero. <span>this type of configuration is called skid-steer drive.</span> For a robot that is wheeled and works indoors, this is a killer feature.</p>
<div class="packt_infobox">To know more about it read more here: <a href="https://groups.csail.mit.edu/drl/courses/cs54-2001s/skidsteer.html"><span>https://groups.csail.mit.edu/drl/courses/cs54-2001s/skidsteer.html</span></a></div>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting the vehicle ready</h1>
                </header>
            
            <article>
                
<p>Now is the time to go ahead and make the robotic vehicle a reality. So let's unbox the vehicle chassis and screw every part together. The assembly manual generally comes along with the kit, so it won't take long for you to complete it. </p>
<p>Once you have completed building the kit, go ahead and segregate the wires for each of the motors. This is going to be a very important part of making the vehicle ready. So, once you have all the wires coming out of the vehicle, take a cell and power up each of the wheels. Notice the polarity of connection in which the wheels spin in the forward direction. All you have to do is to take a permanent marker or perhaps a nail paint and mark the wire which goes to the positive terminal when the motor is spinning in the forward direction. As all of these motors are entirely dependent on polarity for the direction, this step is key to ensure that whenever we power them up they always spin in the same direction. Trust me, this will save you a lot of headaches.</p>
<p>Now, once this is all done, connect the wires to the motor driver as shown in the following diagram (t<span>he wire marked by red is the wire that you marked earlier)</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/2025d7fc-c143-4eac-89f1-a0350ad36306.png" style="width:30.42em;height:43.08em;"/></div>
<p>Perfect! Now everything seems sorted, except for the connection of the motor driver with the power source and Raspberry Pi. So let's see how we are going to do it:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/8e028196-14dc-4537-a944-af59b1443670.png" style="width:39.25em;height:50.75em;"/></div>
<p>All right then! Time for the real deal! So the first thing we want to make sure is that all the connections are working exactly the way we planned them to. For this, we will start off with a dummy code which will simply switch all the motors on and in forward direction. So here is the code:</p>
<pre><span><span>import RPi.GPIO as GPIO<br/>import time<br/></span></span><span>GPIO.setmode(GPIO.BCM)<br/></span><span><span>Motor1a = 20</span><span><br/></span></span><span><span>Motor1b = 21<br/></span></span><span><span>Motor2a = 2<br/></span></span><span><span>Motor2b = 3</span></span><span><span><br/></span></span><span><span>GPIO.setup(Motor1a,GPIO.OUT)<br/></span></span><span><span>GPIO.setup(Motor1b,GPIO.OUT)<br/></span></span><span><span>GPIO.setup(Motor2a,GPIO.OUT)<br/></span></span><span><span>GPIO.setup(Motor2b,GPIO.OUT)<br/></span></span><span><span>GPIO.output(Motor1a,1)<br/></span></span><span><span>GPIO.output(Motor1b,0)<br/></span></span><span><span>GPIO.output(Motor2a,1)<br/></span></span><span><span>GPIO.output(Motor2b,0)<br/>time.sleep(10)<br/>GPIO.cleanup()<br/></span></span></pre>
<p>The program can't be more simple than this; all we are doing here is giving the motor driver the command to spin the motor in one single direction. There might be a chance that a set of motors will be rotating in the reverse direction, in which case you should change the polarity of connections on the motor driver. This should solve the problem. Some people might think that we can make a change to the code as well to do this, but as per my experience it starts getting complicated from there and would cause you trouble if you chose the other path. </p>
<p>All right then, everything is set and all is working well. Go ahead, try some other output permutations and combinations and see what happens to the car. Don't worry, whatever you do, you won't be able to damage the car unless it runs off the roof! </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Controlling the vehicle by Bluetooth</h1>
                </header>
            
            <article>
                
<p>Had some fun trying those combinations? Now is the time that we take this journey a step ahead and see what else is possible. We have all played with remote-controlled cars and I'm sure everyone will have had fun with those zippy little toys. We are going to do something similar but in a much more sophisticated way.</p>
<p>We all are aware of Bluetooth: this is one of the best ways to communicate with devices in close proximity. Bluetooth communication is a medium data rate, low power communication method. This is almost omnipresent in mobile devices, hence it is an ideal way to start. What we will be doing in this chapter is controlling the car via your mobile phone using Bluetooth. Now let's see how we can do it.</p>
<p>The first thing we want to do is pair up the smartphone to the robotic vehicle, and to do so we need to open the terminal on Raspberry Pi and perform the following steps:</p>
<ol>
<li>Type in the command <kbd>~ $ bluetoothctl</kbd>; this is a Bluetooth agent which allows two Bluetooth devices to communicate. Without the Bluetooth agent, the two devices will not be able to communicate with each other in the first place.<strong> </strong></li>
<li>The <kbd>[Bluetooth] # power on</kbd> command simply powers up the Bluetooth on board the Raspberry.</li>
<li>The <kbd><span>[Bluetooth] #</span> agent on</kbd> command starts up the agent which can then initiate the connection for us.</li>
<li>The <kbd><span>[Bluetooth] #</span> discoverable on</kbd> command makes Raspberry Pi's Bluetooth discoverable. The Bluetooth might be on, but we must make it discoverable to make sure that the other device can find it and connect to it.</li>
<li>The <kbd><span>[Bluetooth] #</span> pairable on</kbd> command makes the device pairable. If the Bluetooth is on, this doesn't mean your device will be able to connect, hence we need to make it pairable and this command does exactly that.</li>
<li>The <kbd><span>[Bluetooth] #</span> scan on</kbd> command starts scanning for nearby Bluetooth devices. The output of this command will be a couple of MAC addresses along with the Bluetooth name. The MAC address is a physical address of the device; this is a unique address, hence it will never ever be the same for two devices.</li>
<li>The <kbd><span>[Bluetooth] #</span> pair 94:65:2D:94:9B:D3</kbd> command helps you to pair up with the device you want. You simply need to type the mentioned command with the MAC address.</li>
</ol>
<p>Just to be clear, this what your screen should look like:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/77974b41-0787-497d-8bbe-a2ef84b5e0a8.png" style="width:43.67em;height:35.42em;"/></div>
<p>Once you have done this process, you should be able to connect Raspberry Pi to your mobile devices. Now that you are connected, it's time to go ahead and write the code through which we will be able to control the Bluetooth car just using our mobile devices. So here is the code. Go ahead, have a look, then we will get to the explanation:</p>
<div>
<pre><span><span>import bluetooth<br/>import time<br/>import RPi.GPIO as GPIO<br/>Motor1a = 20<br/>Motor1b = 21<br/>Motor2a = 2<br/>Motor2b = 3<br/>GPIO.setmode(GPIO.BCM)<br/>GPIO.setwarnings(False)<br/>GPIO.setup(Motor1a,GPIO.OUT)<br/>GPIO.setup(Motor1b,GPIO.OUT)<br/>GPIO.setup(Motor2a,GPIO.OUT)<br/>GPIO.setup(Motor2b,GPIO.OUT)<br/>server_socket=bluetooth.BluetoothSocket( bluetooth.RFCOMM )<br/>port = 1<br/>server_socket.bind(("",port))<br/>server_socket.listen(1)<br/>client_socket,address = server_socket.accept()<br/>print ("Accepted connection from "+str(address))<br/>def stop_car():<br/>  GPIO.output(Motor1a,0)<br/>  GPIO.output(Motor1b,0)<br/>  GPIO.output(Motor2a,0)<br/>  GPIO.output(Motor2b,0)<br/><br/>while True:<br/>  data = client_socket.recv(1024)<br/>  if (data == "B" or data== "b"):<br/>    GPIO.output(Motor1a,1)<br/>    GPIO.output(Motor1b,0)<br/>    GPIO.output(Motor2a,1)<br/>    GPIO.output(Motor2b,0)<br/>    time.sleep(1)<br/>    stop_car()<br/><br/>  if (data == "F" or data == "f"):<br/>    GPIO.output(Motor1a,0)<br/>    GPIO.output(Motor1b,1)<br/>    GPIO.output(Motor2a,0)<br/>    GPIO.output(Motor2b,1)<br/>    time.sleep(1)<br/>    stop_car()<br/><br/>  if (data == "R" or data == "r"):<br/>    GPIO.output(Motor1a,0)<br/>    GPIO.output(Motor1b,1)<br/>    GPIO.output(Motor2a,1)<br/>    GPIO.output(Motor2b,0)<br/>    time.sleep(1)<br/>    stop_car()<br/><br/>  if (data == "L" or data == "l"):<br/>    GPIO.output(Motor1a,1)<br/>    GPIO.output(Motor1b,0)<br/>    GPIO.output(Motor2a,0)<br/>    GPIO.output(Motor2b,1)<br/>    time.sleep(1)<br/>    stop_car()<br/><br/>  if (data == "Q" or data =="q"):<br/>    stop_car()<br/>    <br/>  if (data =='Z' or data == "z"):<br/>    client_socket.close()<br/>    server_socket.close()<br/></span></span></pre>
<p>Now let's see what this code is actually doing:</p>
</div>
<pre><span>import bluetooth</span></pre>
<p>We will be using some generic functions of Bluetooth during this program, hence we are calling the library <kbd>bluetooth</kbd> so that we are able to call those methods:</p>
<pre><span>server_socket=bluetooth.BluetoothSocket( bluetooth.RFCOMM )</span></pre>
<p>Now, whenever we connect two Bluetooth devices, we have various methods of communication; the easiest among them is radio frequency communication, herein referred to as <kbd>RFCOMM</kbd>. Now, in this line, we are using the <kbd>BluetoothSocket</kbd> method of the <kbd>bluetooth</kbd> library to define what communication protocol we are using in our program, which by now you know is <kbd>RFCOMM</kbd>. We are further storing this data in a variable called <kbd>server_socket</kbd> so that we don't have to repeat this step over and over again. Rather, whenever we need this data it will already be stored in the variable called <kbd>server_socket</kbd>:</p>
<pre><span>port = 1</span></pre>
<p>Now, Bluetooth has multiple ports; this is a very useful concept as through one single Bluetooth connection we can have various streams of data being transferred to various devices and programs. This avoids the clash of data and also makes sure that the data is securely communicated to exactly the right receiver. The program which we are using right now is extremely simple and we do not need multiple ports for data communication. Hence, we can use any of the <kbd>1</kbd> to <kbd>60</kbd> ports available to us for the communication. In this part of the program, you can write any port and your program will run just fine:</p>
<pre><span>server_socket.bind(("",port))</span></pre>
<p>Now, whenever we are connecting two devices we need to make sure that they stay connected throughout the communication. Hence, here we are writing this command: <kbd>server_socket.bind</kbd>. What this will do is that it will make sure that your Bluetooth connection is maintained during the entire communication.</p>
<p>As you can see, the first parameter inside the argument is empty. Here, we generally write the MAC address which it has to be bound with. However, as we have set this as empty it will automatically bind to the MAC address we are already paired with. The second argument we have is the port on which it has to be connected. As we know, the value of the <kbd>port</kbd> variable is set to be <kbd>1</kbd>. Hence, it will automatically connect to port number <kbd>1</kbd>:</p>
<pre><span>server_socket.listen(1)</span></pre>
<p>This is a very interesting line. As we know, we might not be the only person trying to connect to the Bluetooth device of Raspberry, hence what should Raspberry do when it receives another connection request?</p>
<p>In this line, we are defining just that: we are calling a method called <kbd>listen(1)</kbd>. In this function, we have defined the value of argument as <kbd>1</kbd>. What it means is that it will be connected to one device only. Any other device that tries to connect will not get through. If we change this argument to <kbd>2</kbd> then it will be connected to two devices, however it would stay in the queue and hence it is called <strong>queue connection</strong>:</p>
<pre><span>client_socket,address = server_socket.accept()</span></pre>
<p>Now that most of the things for the connection have been done, we also need to know if we are connected to the right address. What the method <kbd>server_socket.accept()</kbd> does is that it returns the socket number and the address it is serving to. Hence, we are storing it within two variables called <kbd>client_socket</kbd> and <kbd>address</kbd>. However, as we know, the socket will remain only as <kbd>1</kbd>, hence we will not be using it any further:</p>
<pre><span>print ("Accepted connection from "+str(address))</span></pre>
<p><span><span>In this line we are simply telling the user that the connection has been made successfully with the sue of the function <kbd>str(address)</kbd> we are printing the value of the address to which it is connected to. This way we can be double sure that the connection has been made to the right device</span></span>. </p>
<pre><span>data = client_socket.recv(1024)</span></pre>
<p>In this line, we are receiving the data from the client; also, we are defining how long that data will be. Hence, in the method <kbd>client_socket.recv(1024)</kbd> we have passed on a parameter in the argument as <kbd>1024</kbd> which basically denotes that the maximum length of the data packet will be <kbd>1024</kbd> bytes. Once the data is received, it is then passed on to the variable <kbd>data</kbd> for further use. </p>
<p>After this, the rest of the program is pretty simple. We simply need to compare the value received by the mobile device and make the car do whatever we want to do. Here, we have made the car go in all four directions, that is, forward, backward, right, and left. You may also add specific conditions as per your needs:</p>
<pre><span>        client_socket.close()</span></pre>
<p>In this line, we are closing the connection of the client socket so that the client can be disconnected and the data transfer can be terminated:</p>
<pre><span> server_socket.close()</span></pre>
<p><span>I</span><span>n the preceding line, we are closing the connection of the server socket so that </span><span>the server connection can be disconnected.</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter taught us to automate and control a car using Bluetooth interfacing via data grabbing and sharing. Next up, we will develop what we have learned so far to interface IR sensors for obstacle avoidance and patch planning.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div></body></html>