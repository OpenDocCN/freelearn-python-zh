<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Tweet-a-PowerStrip</h1></div></div></div><p>Smart power management units or strips are part of some of the most popular IoT subdomains, smart homes and smart grids. Nowadays, smart power strips are commercially available and provide a large number of features, such as remote access, smart power usage, and <a id="id1042" class="indexterm"/>power management. In this project, we are going to create a smart DIY power strip that can be controlled remotely using status messages posted on Twitter, the popular social media <a id="id1043" class="indexterm"/>website (<a class="ulink" href="http://www.twitter.com">http://www.twitter.com</a>). These messages are also known as <a id="id1044" class="indexterm"/>
<strong>tweets</strong>. Basically, just like you can control sensors remotely using a web browser, you can control them by sending a tweet. We've already worked with low-power sensors in the previous project, so let's work with AC appliances in this project. We will be implementing the same project development methods that we utilized in the previous project. This chapter avoids additional explanations about the process and sticks only to the details associated with the project.</p><div><div><div><div><h1 class="title"><a id="ch11lvl1sec73"/>Project overview</h1></div></div></div><p>This <a id="id1045" class="indexterm"/>project requires the development of a smart power strip using Arduino and Python, while the control inputs to the strips are tweets. Although we are only enabling remote access to the power strip, there are a large number of additional features that can be implemented in future to elevate this DIY project to a commercial product.</p><p>The major goals we want to achieve in this project are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The user should be able to turn the individual power ports on and off using customized tweets</li><li class="listitem" style="list-style-type: disc">The user should be able to check the status of the power ports using Twitter</li></ul></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec150"/>Project requirements</h2></div></div></div><p>Here are the initial <a id="id1046" class="indexterm"/>project requirements, derived from the goals:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The system should have 110V (or 220V) AC power ports interfaced with relays.</li><li class="listitem" style="list-style-type: disc">An Arduino-based unit should be able to control these relays, ultimately controlling the appliance connected through the power ports.</li><li class="listitem" style="list-style-type: disc">The system should be able to decode the tweets sent by the user and convert them into appropriate control messages for Arduino.</li><li class="listitem" style="list-style-type: disc">The Python-based program that processes the tweets should then publish these messages so that Arduino can complete those actions using the relays.</li><li class="listitem" style="list-style-type: disc">To sum up, the relays should be controlled in a near real-time manner using the tweets sent by the user.</li><li class="listitem" style="list-style-type: disc">The system should also understand keywords to check the status of the relays and automatically tweet the status. The system should process a tweet only once and should be able to remember the last tweet processed.<div><div><h3 class="title"><a id="note59"/>Note</h3><p>
<strong>110V versus 220V AC power</strong>
</p><p>Depending on the country, your AC power supply may have voltage ratings of 110/120V or 220/240V. Although the circuit diagram used by this project mentions a 110V AC power supply, the same circuit should also work for a 220V power supply. If you are using a 220V supply, check out the following notes before moving forward:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Ensure that the appliances you are trying to operate, such as fans, lights, and so on, are rated for similar AC power</li><li class="listitem" style="list-style-type: disc">You have to ensure that the relays used by the project are compatible with your AC power supply</li><li class="listitem" style="list-style-type: disc">Arduino works on a DC power supply, and it is not affected by any variation in AC power</li></ul></div></div></div></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec151"/>System architecture</h2></div></div></div><p>From the <a id="id1047" class="indexterm"/>preceding requirements, let's sketch <a id="id1048" class="indexterm"/>the architecture of the Tweet-a-PowerStrip system. The system architecture tries to utilize the hardware components and software tools you learned in the previous chapters, while having a relay component as the only exceptional component. As you can see in the architecture in the following diagram, we are employing the relay to control various home appliances. These appliances are usually powered by a common 110V AC power supply available in each home. Instead of controlling a single appliance, we are implementing a four-channel relay to control at least four appliances, such as a lamp, a fan, a toaster, and a coffee machine.</p><div><img src="img/5938OS_11_01.jpg" alt="System architecture"/></div><p>The relay is <a id="id1049" class="indexterm"/>controlled <a id="id1050" class="indexterm"/>using the digital pins of the Arduino Uno board, which utilizes the Ethernet Shield to connect to your home network. A computation unit that may consist of a computer, a Raspberry Pi, or a server, uses Python and its supporting libraries to access tweets. The computation unit also deploys a Mosquitto broker. This broker handles the topics from the Python program and Arduino to control the relays. The user can post tweets containing keywords from any platform, such as a phone or a browser, and the tweets are ultimately captured by the computation unit.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec152"/>Required hardware components</h2></div></div></div><p>This project will <a id="id1051" class="indexterm"/>require <a id="id1052" class="indexterm"/>the following hardware components throughout the development and the deployment stages:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Component </p>
</th><th style="text-align: left" valign="bottom">
<p>Amount</p>
</th><th style="text-align: left" valign="bottom">
<p>Website/note</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Arduino Uno</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://www.sparkfun.com/products/11021">https://www.sparkfun.com/products/11021</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Arduino Ethernet Shield</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://www.sparkfun.com/products/9026">https://www.sparkfun.com/products/9026</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Relay (four-channel, Arduino-compatible) </p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://www.amazon.com/JBtek-Channel-Module-Arduino-Raspberry/dp/B00KTEN3TM/">http://www.amazon.com/JBtek-Channel-Module-Arduino-Raspberry/dp/B00KTEN3TM/</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>PowerSwitch Tail</p>
</td><td style="text-align: left" valign="top">
<p>4 </p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://www.powerswitchtail.com/">http://www.powerswitchtail.com/</a>
</p>
<p>Alternative to relay</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Power strip</p>
</td><td style="text-align: left" valign="top">
<p>Optional</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>Breadboard</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>For development stage</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>USB cable for Arduino</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>For development stage</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Arduino power supply</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>For deployment stage</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Electric tape</p>
</td><td style="text-align: left" valign="top">
<p>As per requirements</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>Connection wires</p>
</td><td style="text-align: left" valign="top">
<p>As per requirements</p>
</td><td style="text-align: left" valign="top"> </td></tr></tbody></table></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec124"/>Relays</h3></div></div></div><p>As you can <a id="id1053" class="indexterm"/>see in the following image, we are introducing a new hardware component that was not utilized in any of the previous chapters—a relay:</p><div><img src="img/5938OS_11_02.jpg" alt="Relays"/></div><p>This is an electromagnetic device that uses electricity to be operated as a switch. A typical relay contains three contacts on the high-power side, <strong>normally connected</strong> (<strong>NC</strong>), <strong>common</strong> (<strong>C</strong>), and <strong>normally open</strong> (<strong>NO</strong>). The other side (the control side) of the relay requires an activation voltage to toggle the connection from common-NC to common-NO. This action demonstrates the switch functionalities for the connection on the high-power side. We'll use Arduino-compatible relays from manufacturers such as Keyes or SainSmart. These relays are available in single-, two- or four-channel configurations. On the high-power side, the relays support up to 250V, 10A AC power or 30V, 10A DC power. The relays are controlled using 5V DC on the low-power side, which is provided using the digital I/O pins of the Arduino board.</p></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec125"/>PowerSwitch Tail</h3></div></div></div><p>Working <a id="id1054" class="indexterm"/>with AC power can be hazardous if you haven't dealt with it previously or if you are not familiar with the necessary precautions and measurements. If you are not comfortable with working with open relays or connecting AC power to them, there is another device that you can use to replace the relay—the PowerSwitch Tail, a safely enclosed box that contains optically isolated solid-state relays and provides a convenient way to interface your AC appliance with the Arduino board. The following is an image of the <a id="id1055" class="indexterm"/>PowerSwitch Tail, which can be obtained from its official website (<a class="ulink" href="http://www.powerswitchtail.com/">http://www.powerswitchtail.com/</a>):</p><div><img src="img/5938OS_11_16.jpg" alt="PowerSwitch Tail"/></div><div><div><h3 class="title"><a id="note60"/>Note</h3><p>If you are dealing with a 220V/240V power supply, the PowerSwitch Tail website also provides an assembly kit for 200V to 240V power supply, at <a class="ulink" href="http://www.powerswitchtail.com/Pages/PowerSwitchTail240vackit.aspx">http://www.powerswitchtail.com/Pages/PowerSwitchTail240vackit.aspx</a>.</p><p>It is really easy to assemble the kit from the guidelines provided at <a class="ulink" href="http://www.powerswitchtail.com/Documents/PSSRTK%20Instructions.pdf">http://www.powerswitchtail.com/Documents/PSSRTK%20Instructions.pdf</a>.</p></div></div><p>For this project, you will need four of these devices to replace the four-channel relay that we are going to use. As you can see in the following diagram, one end of the Tail goes into the <a id="id1056" class="indexterm"/>regular power port, while you need to connect your appliance to the other port. Meanwhile, you can use the three control inputs to control the relay. We are using one of the digital I/O pins of the Arduino board to send the control signal to the Tail. When going ahead with the Tails instead of the relays, make sure that you make necessary amendments to the upcoming hardware design.</p><div><img src="img/5938OS_11_17.jpg" alt="PowerSwitch Tail"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec153"/>User experience flow</h2></div></div></div><p>From the system <a id="id1057" class="indexterm"/>architecture we have created, what <a id="id1058" class="indexterm"/>should the <strong>user experience</strong> (<strong>UX</strong>) flow while working with the Tweet-a-PowerStrip be? We have divided the UX into two separate sections: controlling the power to the appliances, and checking the status of the power strip.</p><p>In the first UX flow design, as displayed in the following diagram, the user begins by sending a tweet containing the name of the appliance (#fan, #lamp, #toaster, or #coffee) and the control command (#on or #off). The system should be able to handle the tweet from the point of parsing until the appliance has behaved as asked for. The system should also provide a hassle-free experience for the user, where the user doesn't have to perform any further actions than simply sending tweets.</p><div><img src="img/5938OS_11_04.jpg" alt="User experience flow"/></div><p>Similarly, the user <a id="id1059" class="indexterm"/>should <a id="id1060" class="indexterm"/>be able to post <strong>#status #check</strong> tweets and simply obtain the status report posted back by the system. The system should handle checking the status of the power ports, publishing it to the computation unit, and posting a tweet with the message without any additional input from the user. </p><p>The following diagram <a id="id1061" class="indexterm"/>shows the UX flow for checking the system status:</p><div><img src="img/5938OS_11_05.jpg" alt="User experience flow"/></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec154"/>Development and deployment stages</h2></div></div></div><p>According<a id="id1062" class="indexterm"/> to the architecture, we require two main development stages to complete the project. The first stage, which<a id="id1063" class="indexterm"/> interacts with the appliance through the relays, is developed using Arduino. This unit subscribes to the topics associated with the appliances, and once it receives<a id="id1064" class="indexterm"/> an appropriate message, it executes the action on the relay level. In the second stage, we deal with the individual tweets, where we parse the tweets from the Twitter account, check for duplicates, decode actions from the messages, and also post tweets with status reports. During these development stages, we are going to use a breadboard and jumper wires to test the Arduino and Python programs. At this stage, the project is still not ready to deploy as a portable unit for daily usage.</p><p>The deployment stage <a id="id1065" class="indexterm"/>contains tasks of creating a PCB for the breadboard connections and insulating wires to avoid any electric hazard. You can also buy or create an enclosure box to isolate the open hardware from physical contact. As the development stage contains everything that is required to convert the project into its working state, we are not going to dive deep into the deployment stage. You can perform addition deployment tasks according to your personal requirements.</p><p>Let's start from the hardware design stage and develop the physical section of the smart power strip using Arduino.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec74"/>Stage 1 – a smart power strip with Arduino and relays</h1></div></div></div><p>The <a id="id1066" class="indexterm"/>hardware of Tweet-a-PowerStrip contains Arduino as the main controller unit that interfaces with the relays and the Ethernet Shield to communicate with the computation unit. The Arduino code implements the MQTT client, using the <code class="literal">PubSubClient</code> library to publish and subscribe to the topics. Although we are using some example appliances to control the use of the relay, you can select any other appliance you own. You can also use a commercial power strip instead of an individual power plug.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec155"/>Hardware design</h2></div></div></div><p>While <a id="id1067" class="indexterm"/>assembling the <a id="id1068" class="indexterm"/>hardware components, as displayed in the following diagram, make sure you are precise in connecting the appliances with the AC power plugs. One wire of the AC plug is directly connected to the appliance, while the other is connected between the C and NO ports of the relay. We have connected the control side of the relay to the digital pin of our Arduino. As we are using a four-channel relay, we will have to utilize four digital IO pins from the Arduino board. Complete the remaining connections as shown here:</p><div><img src="img/5938OS_11_06.jpg" alt="Hardware design"/></div><p>Connecting the hardware unit is fairly simple, but requires a lot of precision because it involves high-power AC connections.</p><div><div><h3 class="title"><a id="tip17"/>Tip</h3><p>You should cover the open 110V AC power cords going to the relay and the appliance with electric tape to avoid any type of electrical hazard. Keeping these live wires open can be really dangerous due to the large amount of current being carried by them. In the deployment stage, a plastic cover or a box around the relay unit can also be helpful in covering the live power wires.</p></div></div><p>Once you are <a id="id1069" class="indexterm"/>ready with the connections, connect the Arduino board to your computer using a USB port, as shown in the following image:</p><div><img src="img/5938OS_11_07.jpg" alt="Hardware design"/></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec156"/>The Arduino code</h2></div></div></div><p>The <a id="id1070" class="indexterm"/>Arduino sketch<a id="id1071" class="indexterm"/> for this section is located in the folder containing the chapter code with the <code class="literal">Arduino_powerstrip.ino</code> filename. You can open the file in the Arduino IDE to explore the code. As usual, you will have to change the IP addresses of the device and the Mosquitto server to the appropriate IP addresses, while also changing the MAC address of the Ethernet Shield. The following code snippet shows the declaration of the Arduino pins and their roles in the main function, <code class="literal">setup()</code>. Make sure that you are using the same pin numbers that you have used to connect the relay. Alternatively, you can change the appliance name to that of the appliance you are using. Also, make sure whatever changes you make in the variable names should be reflected in the entire code to avoid any compilation errors:</p><div><pre class="programlisting">  pinMode(FAN, OUTPUT);
  pinMode(LAMP, OUTPUT);
  pinMode(TOASTER, OUTPUT);
  pinMode(COFFEEMAKER, OUTPUT);
  fanStatus = false;
  lampStatus = false;
  toasterStatus = false;
  coffeemakerStatus = false;
  digitalWrite(FAN, LOW);
  digitalWrite(LAMP,LOW);
  digitalWrite(TOASTER, LOW);
  digitalWrite(COFFEEMAKER, LOW);</pre></div><p>In the <a id="id1072" class="indexterm"/>
<code class="literal">setup()</code> function, the <a id="id1073" class="indexterm"/>code also subscribes to the appropriate MQTT channels so that it can receive messages from the Mosquitto broker as soon as they are available. As you can see, we are also subscribing to the <code class="literal">PowerStrip/statuscheck</code> channel to deal with the status report:</p><div><pre class="programlisting">  if (client.connect("PowerStrip")) {
    client.subscribe("PowerStrip/fan");
    client.subscribe("PowerStrip/lamp");
    client.subscribe("PowerStrip/toaster");
    client.subscribe("PowerStrip/coffeemaker");
    client.subscribe("PowerStrip/statuscheck");
  }</pre></div><p>In the <code class="literal">callback()</code> function, we use the <code class="literal">if</code> statement to match the topic with the appropriate <code class="literal">digitalWrite()</code> action. As you can see, we are setting up <code class="literal">HIGH</code> and <code class="literal">LOW</code> statuses for the digital pin when the program receives <code class="literal">on</code> and <code class="literal">off</code> messages, respectively (for that appliance). With this action, we are also changing the state of the Boolean variable associated with the appliance, which will be helpful in retrieving the status of the port. The same process is then repeated for all appliances:</p><div><pre class="programlisting">  if(topicS == "PowerStrip/fan"){
    if (payloadS.equalsIgnoreCase("on")) {
      digitalWrite(FAN, HIGH);
      fanStatus = true;
    }
    if (payloadS.equalsIgnoreCase("off")){
      digitalWrite(FAN, LOW);
      fanStatus = false;
    }
  }</pre></div><p>When the system receives a <code class="literal">get</code> message that is associated with the status check, the program creates a message using the Boolean variables that we toggled earlier. The program then publishes the status to the <code class="literal">PowerStrip/statusreport</code> channel:</p><div><pre class="programlisting">if(topicS.equals("PowerStrip/statuscheck")){
    if (payloadS.equalsIgnoreCase("get")) {
        String report = "";
        if (fanStatus) report += "Fan:on,";
        else report += "Fan:off,";

        if (lampStatus) report += "Lamp:on,";
        else report += "Lamp:off,";

        if (toasterStatus) report += "Toaster:on,";
        else report += "Toaster:off,";

        if (coffeemakerStatus) report += "Coffeemaker:on";
        else report += "Coffeemaker:off";

        report.toCharArray(reportChar, 100);
        client.publish("PowerStrip/statusreport", reportChar);
    }
  }</pre></div><p>Just as we did in <a id="id1074" class="indexterm"/>the <a id="id1075" class="indexterm"/>previous project, you can set up the code to periodically send <code class="literal">keep alive</code> messages to avoid the termination of the connection with the Mosquitto broker. Once you are ready with the code, connect the Ethernet cable, compile the code, and then upload it to your Arduino. Your Arduino should be in receiving mode now, and it will wait for the message from the subscribed channels. As we discussed in the previous the project, you need to ensure that your Mosquitto broker is running on the server IP address you specified in the Arduino code.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec75"/>Stage 2 – the Python code to process tweets</h1></div></div></div><p>As the user is <a id="id1076" class="indexterm"/>interacting with the system at the level of the Twitter application, we do not require a deployable computation or control unit for this project. Due to this, we can just use any computer capable of hosting Python and Mosquitto as the computation unit. You still need to ensure that the unit is always on and connected to the Internet, otherwise the system will not work as expected. For simplicity, you can deploy the system on the Raspberry-Pi-based control center that you developed in the previous project, or even on the Amazon AWS server. For the development stage, let's start with the regular computer that you have been using all along. We are assuming that this computer has the Mosquitto broker installed and running. Note down the IP address of this unit, as you will need it in the Arduino code that you developed in the previous section.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec157"/>Python software flow</h2></div></div></div><p>The <a id="id1077" class="indexterm"/>Python code deals <a id="id1078" class="indexterm"/>with two services during execution, the Twitter API to get or post tweets and the Mosquitto broker to relay messages to the hardware unit. The program begins by parsing the latest tweet from the user account and checking whether it has been utilized in the previous action or not. This avoids any command duplication, as the frequency of new tweets is significantly lower than the frequency of the program loop. Once the code finds a new tweet with the appropriate keywords to perform operations on the appliance (or appliances), it publishes the message to the Mosquitto broker. If the tweet contains a message to check the status, the code requests the status from your Arduino and posts a new tweet with the status after receiving it. </p><p>The following diagram shows the detailed program flow of the computation unit:</p><div><img src="img/5938OS_11_08.jpg" alt="Python software flow"/></div><p>You can <a id="id1079" class="indexterm"/>change the program flow to accommodate any other feature you want to add at the Python level. The logic behind identifying and toggling the appliance can be improvised to accommodate more complex tweet text.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec158"/>Setting up the Twitter application</h2></div></div></div><p>We are <a id="id1080" class="indexterm"/>assuming that you have a <a id="id1081" class="indexterm"/>Twitter account by now. If you don't, you can create a new account just for this project to avoid changes to your own profile. With the introduction of the latest APIs, Twitter requires you to authenticate using OAuth before accessing any information from your account. To do that, you will have to create a Twitter app using your account. Execute the following steps in order to create a new Twitter app for this project:</p><div><ol class="orderedlist arabic"><li class="listitem">Log in to your Twitter account and open the <a class="ulink" href="https://apps.twitter.com">https://apps.twitter.com</a> address in your web browser.</li><li class="listitem">Click on the <strong>Create New App</strong> icon on the page, and you will be directed to a page asking for your application details, as displayed in the following screenshot:<div><img src="img/5938OS_11_09.jpg" alt="Setting up the Twitter application"/></div></li><li class="listitem">Fill in all the required details (marked with red asterisks) and continue to the next page. Ensure that your application name is unique, as Twitter asks for a unique application name.</li><li class="listitem">Once your application is created, you can click on the <strong>API Keys</strong> tab and find the <a id="id1082" class="indexterm"/>consumer key (<strong>API key</strong>) and consumer secret (<strong>API secret</strong>) for your app. Save this information in a safe place, as you will need them to authenticate with the Twitter API.<div><img src="img/5938OS_11_11.jpg" alt="Setting up the Twitter application"/></div></li><li class="listitem">As the UX of the <a id="id1083" class="indexterm"/>Tweet-a-PowerStrip project requires the system to automatically send the system status, we need read-and-write access to our application. Go to the <strong>Permissions</strong> tab, select the <strong>Read and Write</strong> option, and save it for the changes to take effect.<div><img src="img/5938OS_11_10.jpg" alt="Setting up the Twitter application"/></div></li><li class="listitem">Once you are done with setting up the permissions for the application, go back to the API keys tab and click on the <strong>Create Access Token</strong> icon to generate a new access token for this application. After a while, you should be able to see the access token on the same page, as displayed in this screenshot:<div><img src="img/5938OS_11_18.jpg" alt="Setting up the Twitter application"/></div></li><li class="listitem">Save the <a id="id1084" class="indexterm"/><strong>Access token</strong> <a id="id1085" class="indexterm"/>and <strong>Access token secret</strong> information. Your application is now ready for use and can help you to authenticate with the Twitter API.</li></ol></div><p>Now let's move on to the Python code.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec159"/>The Python code</h2></div></div></div><p>Before you<a id="id1086" class="indexterm"/> jump into<a id="id1087" class="indexterm"/> the code, you are required to install the Twitter library for Python. Use the Setuptools or <code class="literal">pip</code> to install the library using the following command. We are assuming that you already have the latest <code class="literal">paho_mqtt</code> library installed on your computer:</p><div><pre class="programlisting">
<strong>$ sudo pip install python-twitter</strong>
</pre></div><p>The Python code for this section is located in the code folder with the <code class="literal">PythonTweetAPowerStrip.py</code> filename. Open the code in your IDE and start exploring it. The code contains two parallel threads to handle the tweets and the Mosquitto library separately.</p><p>As you can see in the following code snippet, we are using the <code class="literal">Api</code> class from the <code class="literal">python-twitter</code> library to establish a connection with the Twitter API. We are using the <code class="literal">consumer key</code>, <code class="literal">consumer secret</code>, <code class="literal">access token key</code>, and <code class="literal">access token secret</code> values for this authentication. Once the authentication is established, the <code class="literal">Api</code> class can be used to get the latest status from the timeline using the <code class="literal">GetHomeTimeline()</code> function call, and to post the new status using the <code class="literal">PostUpdate()</code> function call. The <code class="literal">GetHomeTimeline()</code> function gives an array of statuses from the user; we need the latest status, which can be fetched using <code class="literal">statuses[0]</code> (the first element of the array):</p><div><pre class="programlisting">api = twitter.Api(consumer_key='&lt;consumer-key&gt;',
                  consumer_secret='&lt;consumer-secret&gt;',
                  access_token_key='&lt;access-token-key&gt;',
                  access_token_secret='access-token-secret&gt;')</pre></div><p>Once we have retrieved the latest tweet, we need to make sure that we haven't used that tweet already. So we save the latest tweet ID in a global variable, as well as in a file in case we need to run the code again:</p><div><pre class="programlisting">with open('lastTweetID.txt', 'w+') as fh:
  lastTweetId = fh.readline()
  print "Initializing with ID: " + lastTweetId</pre></div><p>We retrieve <a id="id1088" class="indexterm"/>the ID of<a id="id1089" class="indexterm"/> the previous tweet from the <code class="literal">lastTweetID.txt</code> file to match with the latest ID. If it doesn't match, we update the <code class="literal">lastTweetID.txt</code> file with the latest ID for the next loop:</p><div><pre class="programlisting">if lastTweetId != str(currentStatus.id):
  lastTweetId = str(currentStatus.id)
  print "Updated file with ID: " + lastTweetId
  with open('lastTweetID.txt', 'w+') as fh:
    fh.write(lastTweetId)
    currentStatusText = currentStatus.text
    print currentStatusText</pre></div><p>Once we have identified the latest unique tweet, we use the Python string operation to decode the keywords for the appliance and power commands. As you can see in the following code snippet, the keyword we are looking for in the tweeted text to access the fan is <code class="literal">#fan</code>. Once we have identified that the message is directed to the fan, we check for action keywords such as <code class="literal">#on</code> and <code class="literal">#off</code>, and then take the associated action of publishing the message to the Mosquitto broker. We repeat this action for all the appliances connected to the system. Your Arduino takes an action using the published message, and completes the UX flow for the controlled appliances:</p><div><pre class="programlisting">if "#fan" in currentStatusText.lower():
  if "#on" in currentStatusText.lower():
    cli.publish("PowerStrip/fan", "on")
  if "#off" in currentStatusText.lower():
    cli.publish("PowerStrip/fan", "off")</pre></div><p>Similarly, when the code receives an update from the <code class="literal">PowerStrip/statusreport</code> topic, it obtains the status from the message payload and posts it as a new tweet to the user timeline of that Twitter account. This completes the UX flow for the status check using Twitter:</p><div><pre class="programlisting">def onMessage(mosq, obj, msg):
    if msg.topic == "PowerStrip/statusreport":
        print msg.payload
        api.PostUpdate(msg.payload)</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec76"/>Testing and troubleshooting</h1></div></div></div><p>Testing can <a id="id1090" class="indexterm"/>simply be <a id="id1091" class="indexterm"/>performed<a id="id1092" class="indexterm"/> by posting the <code class="literal">#fan #on</code> status to the Twitter account used in this project. You should be able to see the fan turning on by using the command shown here:</p><div><img src="img/5938OS_11_12.jpg" alt="Testing and troubleshooting"/></div><p>Similarly, send the <code class="literal">#fan #off</code> status to turn off the fan. You may find some lagging, as the loop used to retrieve the tweets is set with a delay of a minute.</p><div><img src="img/5938OS_11_13.jpg" alt="Testing and troubleshooting"/></div><p>To access the status of the system, post the <code class="literal">#status #get</code> status to the account, and you will be able to see the system status automatically posted by the computation unit.</p><div><img src="img/5938OS_11_14.jpg" alt="Testing and troubleshooting"/></div><p>The tweet shown in the following screenshot is generated using the Tweet-a-PowerStrip unit. It displays the status of all the connected appliances.</p><div><img src="img/5938OS_11_15.jpg" alt="Testing and troubleshooting"/></div><p>While working with the system, you will want to either avoid the following scenarios or troubleshoot them:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">'Twitter rate limit exceed' error</code>: Twitter imposes a limit on the number of requests you can make to their public API. If you are requesting the API too often (this often occurs when you reduce the sleep time between consecutive queries), your application will exit with an exception. To avoid this, set a longer sleep time in the Python program loop before requesting the API again. There is a trade-off between the frequency of requests and the response time of your appliances. You can learn about this limitation at <a class="ulink" href="http://dev.twitter.com/rest/public/rate-limiting">http://dev.twitter.com/rest/public/rate-limiting</a> and adjust your request interval accordingly. Once you have received this error, you will have to wait for some time (approximately 10 to 15 minutes) before making requests to the Twitter API again.</li><li class="listitem" style="list-style-type: disc"><code class="literal">'Read-only application cannot post' error</code>: This error will only occur if you forgot to change the permissions on your application to <strong>Read and Write</strong> from <strong>Read only</strong>. Make sure that you have performed this change. Also, Twitter takes some time for the changes to take effect.</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec77"/>Extending the project with additional features</h1></div></div></div><p>The current system can <a id="id1093" class="indexterm"/>be expanded to include multiple features:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You can start saving the time duration in which a particular appliance was on or off, and then provide a detailed analysis to the user. You can also use this information to calculate the energy being expended by these appliances.</li><li class="listitem" style="list-style-type: disc">You can utilize the current measurement sensors to calculate the power load at each port. Combining it with the time the device was on, you can calculate very comprehensive power usage to further improve power management.</li><li class="listitem" style="list-style-type: disc">You can use the system clock with the motion sensor to intelligently turn off the appliance during nights and periods of no activity.</li><li class="listitem" style="list-style-type: disc">The Tweet-a-PowerStrip project can be interfaced with the remote home monitoring system that we developed in the previous project, in order to obtain useful information from other sensors being used in the same house.</li><li class="listitem" style="list-style-type: disc">One of the modifications you can easily implement is to utilize Twitter's private messages instead of its tweets to control the appliances. This will extend the access <a id="id1094" class="indexterm"/>permissions of your system to other trusted Twitter accounts. For security reasons, you should tighten the access level and only let approved people post such messages to your account.</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec78"/>Summary</h1></div></div></div><p>You have now successfully completed two different IoT projects using just two base technologies, Arduino and Python. With the current project, it is obvious that it is very easy to interface any other technology, tool, or API with Arduino and Python. The project development methodology we used in these two projects will also help you with your DIY projects and other future products. Happy prototyping! And happy coding!</p></div></body></html>