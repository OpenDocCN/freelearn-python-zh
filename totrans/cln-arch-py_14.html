<html><head></head><body><div><div><div><h1 class="chapterNumber"><a id="_idTextAnchor250"/>11</h1>
    <h1 id="_idParaDest-235" class="chapterTitle"><a id="_idTextAnchor251"/>Legacy to Clean: Refactoring Python for Maintainability</h1>
    <p class="normal">While previous chapters demonstrated Clean Architecture principles through greenfield development, real-world systems often present a different challenge. Existing applications, built under time pressure or before architectural best practices were established, frequently violate Clean Architecture’s fundamental principles. Their domain logic becomes tangled with frameworks, business rules mix with infrastructure concerns, and dependencies flow in all directions. Yet these systems often serve critical business needs and cannot simply be replaced.</p>
    <p class="normal">Through our exploration of Clean Architecture transformation, we’ll discover how to systematically evolve legacy systems while maintaining their business value. We’ll see how Clean Architecture’s explicit boundaries and dependency rules provide clear guidance for improving existing systems, even under real-world constraints. You’ll learn how to identify architectural violations, establish clean boundaries incrementally, and maintain system stability during transformation.</p>
    <p class="normal">By the end of this chapter, you’ll understand how to apply Clean Architecture principles to legacy systems through staged implementation. You’ll be able to evaluate existing systems through Clean Architecture’s lens and implement bounded transformations that respect business constraints while maintaining system stability.</p>
    <p class="normal">In this chapter, we’re going to cover the following main topics:</p>
    <ul>
      <li class="bulletList">Evaluating and planning architectural transformation</li>
      <li class="bulletList">Progressive Clean Architecture implementation</li>
    </ul>
    <h1 id="_idParaDest-236" class="heading-1"><a id="_idTextAnchor252"/>Technical requirements</h1>
    <p class="normal">The code examples presented in this chapter and throughout the rest of the book are tested with Python 3.13. For brevity, most code examples in the chapter are only partially implemented. Complete versions of all examples can be found in the book’s accompanying GitHub repository at <a href="https://github.com/PacktPublishing/Clean-Architecture-with-Python">https://github.com/PacktPublishing/Clean-Architecture-with-Python</a>.</p>
    <h1 id="_idParaDest-237" class="heading-1"><a id="_idTextAnchor253"/>Evaluating and planning architectural transformation</h1>
    <p class="normal">Improving <a id="_idIndexMarker566"/>maintainability and reducing risk in complex applications <a id="_idIndexMarker567"/>requires a systematic approach to architectural evolution. Applications with tangled dependencies and blurred responsibilities consume disproportionate maintenance effort. Feature additions that should take days stretch into weeks; bug fixes trigger unexpected, persistent failures; and developer onboarding becomes painfully slow. These symptoms don’t just reflect technical issues; they also have direct business impacts that need addressing.</p>
    <p class="normal">Throughout previous chapters, we’ve seen how Clean Architecture<a id="_idIndexMarker568"/> naturally minimizes maintenance burdens through clear boundaries and explicit dependencies. Now, we can apply this same architectural lens to evaluate existing systems, identifying where violations occur and how to address them systematically. This doesn’t mean forcing an ideal Clean Architecture onto legacy systems all at once but, rather, taking a balanced, incremental approach that respects business constraints while progressively improving the system.</p>
    <p class="normal">By analyzing legacy code through <a id="_idIndexMarker569"/>Clean Architecture principles, we can uncover natural system boundaries waiting to be established, domain concepts ready to be isolated, and interfaces eager to emerge. This evaluation forms the foundation for our transformation strategy, guiding decisions about what to change, when to change it, and how to minimize risk throughout the process. With each incremental improvement, we reduce both the maintenance burden <a id="_idIndexMarker570"/>and the instability associated with future <a id="_idIndexMarker571"/>changes, creating measurable business value beyond the technical improvements.</p>
    <h2 id="_idParaDest-238" class="heading-2"><a id="_idTextAnchor254"/>Evaluating through a Clean Architecture lens</h2>
    <p class="normal">Transforming an existing system begins <a id="_idIndexMarker572"/>with evaluating its current state with respect to Clean Architecture principles. This evaluation isn’t about documenting every detail, but rather aims at identifying key architectural violations and gauging their business impact. Since wholesale transformation introduces unacceptable risk, we need a balanced approach that provides enough understanding to inform stakeholder discussions while enabling meaningful progress. This measured assessment creates the foundation for deeper collaborative analysis once initial stakeholder support is secured.</p>
    <h3 id="_idParaDest-239" class="heading-3"><a id="_idTextAnchor255"/>Conducting preliminary architectural analysis</h3>
    <p class="normal">Before engaging stakeholders, we <a id="_idIndexMarker573"/>need to conduct a targeted <a id="_idIndexMarker574"/>preliminary architectural analysis focused on identifying key technical issues that can be effectively communicated to non-technical audiences. This initial assessment isn’t exhaustive but provides enough insight to illustrate architectural problems in business-relevant terms.</p>
    <p class="normal">A focused preliminary analysis might include:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Architectural inventory</strong>: Identify major components and their interactions, creating a baseline understanding <a id="_idIndexMarker575"/>without documenting every detail.</li>
      <li class="bulletList"><strong class="keyWord">Dependency mapping</strong>: Sketch <a id="_idIndexMarker576"/>high-level dependency flows that reveal the most problematic circular dependencies and framework coupling that violates Clean Architecture’s principles.</li>
      <li class="bulletList"><strong class="keyWord">Framework penetration assessment</strong>: Spotlight examples where framework code has significantly<a id="_idIndexMarker577"/> permeated business logic, focusing on areas with visible impact on maintenance or flexibility.</li>
      <li class="bulletList"><strong class="keyWord">Domain logic dispersion</strong>: Identify <a id="_idIndexMarker578"/>a few clear examples where business rules are fragmented across the codebase, particularly those affecting functionality that changes frequently.</li>
    </ul>
    <p class="normal">For example, in <a id="_idIndexMarker579"/>analyzing a Python e-commerce system, we might <a id="_idIndexMarker580"/>discover that Django models contain critical business rules, validation logic is duplicated across multiple views, and payment processing code directly references native database queries. This preliminary analysis provides concrete examples that non-technical stakeholders can understand: <em class="italic">When we need to change how pricing works, we currently have to modify code in seven different places across three different modules</em>.</p>
    <p class="normal">This analysis serves as a communication tool, translated into business impact terms like increased time-to-market, elevated bug rates, and diminished ability to respond to changing requirements. By framing architectural issues in business terms before beginning the transformation, we create the foundation for stakeholder support and appropriate resource allocation.</p>
    <p class="normal">This preliminary<a id="_idIndexMarker581"/> architectural assessment serves as an entry <a id="_idIndexMarker582"/>point for transformation, not an exhaustive blueprint. Focus on identifying just enough specific violations to engage stakeholders with credible examples that illustrate business impact. Resist the temptation to diagram every relationship at this stage. Your understanding will deepen substantially during the collaborative domain analysis that follows. The goal is to gather sufficient evidence to make the case for transformation while setting the stage for deeper exploration with stakeholders.</p>
    <h2 id="_idParaDest-240" class="heading-2"><a id="_idTextAnchor256"/>Building stakeholder alignment</h2>
    <p class="normal">With the preliminary architectural <a id="_idIndexMarker583"/>analysis complete and key issues identified, the next step is communicating these findings to stakeholders and securing <a id="_idIndexMarker584"/>initial buy-in for transformation. This initial engagement isn’t about getting final approval for specific changes, but rather aims to build shared awareness of architectural issues and establish support for a more collaborative discovery process. The insights gained from our analysis must now be translated into business-impact terms that resonate with different stakeholder groups, creating the foundation for the deeper collaborative analysis that will follow.</p>
    <p class="normal">The first step is involving the right stakeholders:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Engineering teams</strong> who<a id="_idIndexMarker585"/> understand the technical details and implementation constraints</li>
      <li class="bulletList"><strong class="keyWord">Product owners</strong> who <a id="_idIndexMarker586"/>can articulate business priorities and validate the value of architectural changes</li>
      <li class="bulletList"><strong class="keyWord">Operations personnel</strong> who <a id="_idIndexMarker587"/>manage system deployment and reliability concerns</li>
      <li class="bulletList"><strong class="keyWord">End users</strong> who <a id="_idIndexMarker588"/>can share pain points related to system stability and feature delivery</li>
    </ul>
    <p class="normal">The scope of stakeholder involvement should correspond directly to the scale of transformation planned. Smaller refactorings might only require coordination with your immediate team, while system-wide architectural overhauls may need engagement all the way up to the CTO or VP of Engineering.</p>
    <p class="normal">Once you have stakeholders aligned around a shared transformation vision, the next critical step is establishing baseline measurements that will track progress and demonstrate value. These metrics create accountability and provide clear evidence of improvement throughout the transformation journey:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Maintenance metrics</strong>: time spent on bug fixes, feature delivery lead time</li>
      <li class="bulletList"><strong class="keyWord">Quality indicators</strong>: defect rates, test coverage, static analysis scores</li>
      <li class="bulletList"><strong class="keyWord">Team effectiveness</strong>: developer onboarding time, deployment frequency</li>
      <li class="bulletList"><strong class="keyWord">Business outcomes</strong>: customer satisfaction, feature adoption rates</li>
    </ul>
    <p class="normal">These metrics <a id="_idIndexMarker589"/>serve multiple purposes throughout the transformation. Initially, they justify the effort and help secure leadership support. As work <a id="_idIndexMarker590"/>progresses, they validate effectiveness and highlight areas needing adjustment. They also help define what <em class="italic">done</em> means for the transformation, recognizing that the goal is sustainable improvement rather than architectural perfection. Most importantly, metrics translate technical improvements into business value language, creating a feedback loop that keeps the transformation aligned with both technical goals and business priorities.</p>
    <h2 id="_idParaDest-241" class="heading-2"><a id="_idTextAnchor257"/>Deeper domain analysis</h2>
    <p class="normal">Business domains naturally evolve <a id="_idIndexMarker591"/>over time, making architectural transformation an ideal opportunity to realign systems with current business needs. After securing initial stakeholder support, the next step is deepening our understanding through collaborative domain discovery techniques. This phase connects our technical insights with business domain knowledge, identifying meaningful boundaries while solidifying stakeholder buy-in through active involvement. Where our preliminary analysis focused on technical issues, collaborative discovery bridges these findings with evolving business requirements, ensuring the transformed system not only has better architecture but also better serves current needs.</p>
    <p class="normal">Several collaborative approaches can help bridge technical understanding with domain expertise:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Event storming workshops</strong> to map <a id="_idIndexMarker592"/>business processes and domain events (<a href="https://www.eventstorming.com/">https://www.eventstorming.com/</a>)</li>
      <li class="bulletList"><strong class="keyWord">Domain storytelling sessions</strong> where <a id="_idIndexMarker593"/>stakeholders narrate key workflows (<a href="https://domainstorytelling.org/">https://domainstorytelling.org/</a>)</li>
      <li class="bulletList"><strong class="keyWord">Context mapping exercises </strong>to identify <a id="_idIndexMarker594"/>system boundaries and integration points (<a href="https://contextmapper.org/">https://contextmapper.org/</a>)</li>
    </ul>
    <p class="normal">Among these approaches, <strong class="keyWord">event storming</strong> stands<a id="_idIndexMarker595"/> out as particularly valuable for Clean Architecture transformations. It brings together stakeholders in facilitated workshops to validate domain understanding and identify architectural boundaries. Participants use color-coded sticky notes on a shared modeling space, creating a visual timeline of business processes. The color coding intentionally maps to Clean Architecture layers: orange domain events represent core entities at the center of the architecture, blue commands align with use cases in the Application layer, and purple business rules reflect domain rules that remain<a id="_idIndexMarker596"/> independent of external concerns. Typical domain events include <em class="italic">Order Placed</em>, while commands might include actions like <em class="italic">Process Payments</em>. This visual approach makes architectural boundaries tangible to all stakeholders, helping identify natural separation points when transforming legacy systems. While specific color schemes may vary between teams, maintaining a consistent visual language is what matters most.</p>
    <figure class="mediaobject"><img src="img/B31577_11_1.png" alt="Figure 11.1: Event storming visualization for an e-commerce system, showing domain events, commands, actors, and potential bounded contexts" width="1210" height="358"/></figure>
    <p class="packt_figref">Figure 11.1: Event storming visualization for an e-commerce system, showing domain events, commands, actors, and potential bounded contexts</p>
    <p class="normal">This collaborative approach builds directly on the domain modeling principles from <a href="Chapter_04.xhtml#_idTextAnchor091"><em class="italic">Chapter 4</em></a>, applying them to discover boundaries in existing systems. The same concepts of Entities, Value Objects, and Aggregates now help identify what the legacy system <em class="italic">should</em> have separated but didn’t. For example, an event storming session might reveal that the <em class="italic">Order Processing</em> domain contains distinct events like <em class="italic">Order Placed</em>,<em class="italic"> Payment Approved</em>,<em class="italic"> Inventory Reserved</em>, and <em class="italic">Shipment Created</em>. Be sure to separate business concerns that could be cleanly divided into discrete use cases rather than handled by a monolithic Order Controller.</p>
    <p class="normal">The resulting visual artifacts serve as powerful communication tools, helping stakeholders see how architectural <a id="_idIndexMarker597"/>boundaries translate to business benefits like faster delivery or reduced errors. This shared language often reveals insights that technical analysis alone would miss, such as Order and Payment processing having different change patterns that indicate natural separation points. With these boundaries identified through stakeholder collaboration, we can move from discovery to action, translating insights into a prioritized roadmap for architectural improvement.</p>
    <h2 id="_idParaDest-242" class="heading-2"><a id="_idTextAnchor258"/>Creating a staged implementation roadmap</h2>
    <p class="normal">With architectural <a id="_idIndexMarker598"/>boundaries identified and prioritized based on business value, the focus now shifts to tactical execution planning. Transforming legacy systems isn’t just about knowing what to change, it’s about organizing the work into manageable, low-risk increments that maintain system stability while progressively improving architecture.</p>
    <p class="normal">Effective transformation planning requires breaking down the work into distinct stages with clear deliverables. Rather than overwhelming teams with a massive refactoring effort, a staged implementation creates natural checkpoints to validate progress, gather feedback, and adjust course as <a id="_idIndexMarker599"/>needed.</p>
    <figure class="mediaobject"><img src="img/B31577_11_2.png" alt="Figure 11.2: Clean Architecture transformation stages showing progression from foundation to optimization" width="1210" height="453"/></figure>
    <p class="packt_figref">Figure 11.2: Clean Architecture transformation stages showing progression from foundation to optimization</p>
    <p class="normal">The <strong class="keyWord">foundation stage</strong> establishes<a id="_idIndexMarker600"/> core domain concepts and abstractions that serve as building blocks for later work. This often begins with creating clean entity models alongside existing implementations and defining interfaces for repositories and services. By starting with these core elements, teams establish a clear target architecture while minimizing initial changes to the running system.</p>
    <p class="normal">As the foundation takes shape, the <strong class="keyWord">interface stage</strong> focuses <a id="_idIndexMarker601"/>on implementing adapters that bridge the clean core and external concerns. This includes building repository implementations that work with existing databases, creating service adapters for third-party integrations, and developing controllers that translate between frameworks and the domain. These adapters create a protective layer around the emerging Clean Architecture.</p>
    <p class="normal">The <strong class="keyWord">integration stage</strong> gradually <a id="_idIndexMarker602"/>migrates existing functionality to the new architecture. Teams replace direct database access with repository implementations, substitute hard-coded business rules with domain services, and integrate new components with legacy systems through appropriate adapters. This stage often progresses feature by feature or domain by domain, allowing for controlled, incremental changes.</p>
    <p class="normal">Finally, the <strong class="keyWord">optimization stage</strong> refines<a id="_idIndexMarker603"/> and enhances the architecture based on real-world experience. Teams address performance considerations in repository implementations, expand test coverage, and improve error handling and resilience patterns. This stage acknowledges that the target architecture isn’t achieved in one pass, but rather through continuous refinement.</p>
    <p class="normal">Throughout this <a id="_idIndexMarker604"/>staged approach, the baseline metrics established earlier serve a crucial role in validating progress and communicating the transformation’s impact. By tracking metrics such as maintenance time, defect rates, and feature delivery speed before, during, and after each transformation stage, teams can demonstrate tangible improvements and adjust their approach based on actual results rather than assumptions. These metrics also help teams identify when they’ve reached acceptable levels of architectural improvement, allowing organizations to balance architectural refinement with ongoing business needs.</p>
    <h2 id="_idParaDest-243" class="heading-2"><a id="_idTextAnchor259"/>Approaches for doing the transformation work</h2>
    <p class="normal">The execution complexity of <a id="_idIndexMarker605"/>architectural transformation requires careful logistics planning beyond the technical aspects. Teams must decide how to organize the work alongside ongoing feature development and maintenance. Several approaches are worth considering:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Dedicated transformation iterations</strong> allocate <a id="_idIndexMarker606"/>specific sprint cycles exclusively to architectural work. This approach provides focused time for complex refactoring but may delay feature delivery. It works well for components that need significant changes but which can be completed within one or two iterations.</li>
      <li class="bulletList"><strong class="keyWord">Parallel transformation tracks</strong> create<a id="_idIndexMarker607"/> dedicated teams focused on architectural improvements while other teams continue feature development. This approach maintains delivery velocity but requires careful coordination to prevent conflicts. It’s particularly effective for larger systems where transformation will span multiple quarters.</li>
      <li class="bulletList"><strong class="keyWord">Opportunity-based transformation</strong> integrates architectural improvements with feature work in related <a id="_idIndexMarker608"/>areas. As new features touch a component, teams refactor it toward Clean Architecture. This approach minimizes isolated refactoring risk but makes progress <a id="_idIndexMarker609"/>dependent on feature priorities and may result in uneven transformation.</li>
    </ul>
    <p class="normal">Most successful transformations combine these approaches based on business priorities and team structure. Critical components might warrant dedicated efforts, while less frequently changed areas can evolve through opportunity-based transformation. The key is to explicitly plan how each component will be transformed rather than assume a one-size-fits-all approach.</p>
    <h3 id="_idParaDest-244" class="heading-3"><a id="_idTextAnchor260"/>Navigating the in-flight transformation</h3>
    <p class="normal">During transformation, the system <a id="_idIndexMarker610"/>will temporarily contain a mixture of old and new architectural approaches. Careful planning of these transitional states is crucial to maintain system stability. For each component being transformed, the plan should address:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Parallel operation strategy</strong>: How old and new implementations will coexist</li>
      <li class="bulletList"><strong class="keyWord">Verification approach</strong>: Methods to confirm functional equivalence</li>
      <li class="bulletList"><strong class="keyWord">Cutover criteria</strong>: Clear conditions for switching to the new implementation</li>
      <li class="bulletList"><strong class="keyWord">Rollback procedures</strong>: Safety mechanisms if issues emerge</li>
    </ul>
    <p class="normal">Comprehensive testing strategies are essential during these transitions. Regression test suites validate that new implementations maintain existing functionality, while interface compatibility tests ensure that transformed components correctly integrate with the broader system. <strong class="keyWord">Feature flags</strong> provide<a id="_idIndexMarker611"/> an effective cutover mechanism, allowing teams to selectively enable new implementations for specific users or scenarios while maintaining the ability to instantly revert if issues arise.</p>
    <p class="normal">It’s important to recognize that while this section outlines a general approach to transformation planning, every legacy system presents unique challenges based on its size, complexity, technology stack, and business constraints. The scale of work will differ dramatically between systems, and teams should adapt these guidelines to their specific circumstances. Additional research into techniques specific to your technology stack or domain will help you tailor this approach to your needs. The key is to maintain a pragmatic mindset, taking Clean Architecture principles as a guide rather than a rigid prescription.</p>
    <p class="normal">With a comprehensive transformation plan that addresses both the technical changes and their implementation logistics, teams are well-positioned to begin the actual transformation work. The subsequent sections will explore concrete techniques for implementing these plans, starting with establishing core domain boundaries and progressively refactoring toward a Clean Architecture.</p>
    <h1 id="_idParaDest-245" class="heading-1"><a id="_idTextAnchor261"/>Progressive Clean Architecture implementation</h1>
    <p class="normal">With our evaluation <a id="_idIndexMarker612"/>complete and transformation strategy established, we now turn to practical implementation. This section demonstrates how to progressively transform a legacy system through carefully staged improvements that deliver the greatest architectural value. Rather than attempting to cover the transformation process exhaustively, which would require a book of its own, we’ll highlight strategic refactoring patterns that establish Clean Architecture boundaries incrementally while maintaining system stability.</p>
    <p class="normal">The following examples, drawn from an order processing system rather than our previous task management application, illustrate how to apply Clean Architecture principles to legacy code in a practical manner. Each implementation stage builds on the previous one, gradually moving from tangled dependencies toward clean separation of concerns, from establishing domain boundaries to creating interfaces that bridge old and new architectures.</p>
    <h2 id="_idParaDest-246" class="heading-2"><a id="_idTextAnchor262"/>Initial system analysis</h2>
    <p class="normal">In this hypothetical scenario, you<a id="_idIndexMarker613"/> find yourself responsible for an order processing subsystem that has evolved over several years. What started as <a id="_idIndexMarker614"/>a simple Flask application for managing customer orders has grown to include payment processing and basic order fulfillment. While functionally complete, the codebase exhibits significant technical debt, with tangled dependencies, blurred responsibilities, and architectural inconsistencies that make even simple changes risky and time-consuming.</p>
    <p class="normal">The team faces recurring issues that highlight the architectural problems: a simple change to the order calculation logic requires modifications in three different files; adding a new payment method takes three weeks instead of three days; and every deployment comes with the fear of unexpected side effects. Most telling, new developers need months to become productive, frequently breaking functionality in seemingly unrelated areas when making changes.</p>
    <p class="normal">Building on the preliminary architectural analysis and domain discovery phases described in the first section of this chapter, we’ve identified key architectural issues to address in our transformation. Let’s begin by examining the current state of the system through the lens of Clean Architecture, identifying specific violations and architectural boundaries that need reinforcement.</p>
    <p class="normal">Let’s examine one <a id="_idIndexMarker615"/>such file that handles order creation—a central <a id="_idIndexMarker616"/>piece of the system’s functionality and a prime candidate for our transformation efforts:</p>
    <pre class="programlisting code"><code class="hljs-code"># order_system/app.py
from flask import Flask, request, jsonify
import sqlite3
import requests
app = Flask(__name__)
def get_db_connection():
    conn = sqlite3.connect('orders.db')
    conn.row_factory = sqlite3.Row
    return conn
@app.route('/orders', methods=['POST'])
def create_order():
    data = request.get_json()
    # Input validation mixed with business logic
    if not data or not 'customer_id' in data or not 'items' in data:
        return jsonify({'error': 'Missing required fields'}), 400
 
    # Direct database access in route handler
    conn = get_db_connection()
</code></pre>
    <p class="normal">The beginning <a id="_idIndexMarker617"/>of this file already reveals <a id="_idIndexMarker618"/>several architectural issues. The route handler imports SQLite and requests directly, establishing hard dependencies on these specific implementations. The <code class="inlineCode">get_db_connection</code> function creates a direct connection to a specific database, with no abstraction layer. These structural choices violate Clean Architecture’s Dependency Rule by allowing outer-layer concerns (web framework, database) to penetrate into business logic.</p>
    <p class="normal">Continuing down the <code class="inlineCode">create_order</code> function, let’s examine how the route handler processes orders:</p>
    <pre class="programlisting code"><code class="hljs-code"># def create_order(): &lt;continued&gt;
    # Business logic mixed with data access
    total_price = 0
    for item in data['items']:
        # Inventory check via direct database query
        product = conn.execute('SELECT * FROM products WHERE id = ?',
                              (item['product_id'],)).fetchone()
        if not product or product['stock'] &lt; item['quantity']:
            conn.close()
            return jsonify({
                'error': f'Product {item["product_id"]} out of stock'
            }), 400
     
        # Price calculation mixed with HTTP response preparation
        price = product['price'] * item['quantity']
        total_price += price
 
    # External payment service call directly in route handler
    payment_result = requests.post(
        'https://payment-gateway.example.com/process',
        json={
            'customer_id': data['customer_id'],
            'amount': total_price,
            'currency': 'USD'
        }
    )
</code></pre>
    <p class="normal">This middle <a id="_idIndexMarker619"/>section demonstrates<a id="_idIndexMarker620"/> several Clean Architecture violations. Core business logic like inventory checking and price calculation is mixed directly with database access. The payment processing logic makes direct HTTP calls to an external service, creating a hard dependency that would be difficult to test or change. These implementation details should be hidden behind interfaces, in accordance with Clean Architecture principles, not exposed directly in business logic.</p>
    <p class="normal">Finally, closing out the <code class="inlineCode">create_order</code> function, we complete the order processing:</p>
    <pre class="programlisting code"><code class="hljs-code"># def create_order(): &lt;continued&gt;
    if payment_result.status_code != 200:
        conn.close()
        return jsonify({'error': 'Payment failed'}), 400
    # Order creation directly in route handler
    order_id = conn.execute(
        'INSERT INTO orders (customer_id, total_price, status) '
        'VALUES (?, ?, ?)',
        (
            data['customer_id'],
            total_price, 'PAID'
        )
    ).lastrowid
 
    # Order items creation and inventory update
    for item in data['items']:
        conn.execute(
            'INSERT INTO order_items (order_id, product_id, '
            'quantity, price) VALUES (?, ?, ?, ?)',
            (order_id, item['product_id'], item['quantity'], price)
        )
        conn.execute( # Update inventory
            'UPDATE products SET stock = stock - ? WHERE id = ?',
            (item['quantity'], item['product_id'])
        )
    conn.commit()
    conn.close()
    return jsonify({'order_id': order_id, 'status': 'success'}), 201
</code></pre>
    <p class="normal">The code <a id="_idIndexMarker621"/>analysis reveals fundamental <a id="_idIndexMarker622"/>architectural problems throughout this handler. Direct SQL statements are intertwined with business logic, HTTP responses, and external service calls, which are all crammed into a single function with no separation of concerns. This structure violates the Single Responsibility Principle we discussed in <a href="Chapter_02.xhtml#_idTextAnchor040"><em class="italic">Chapter 2</em></a> and makes changes extremely risky, as modifications in one area frequently affect seemingly unrelated functionality.</p>
    <p class="normal">The system lacks the rich domain model we established in <a href="Chapter_04.xhtml#_idTextAnchor091"><em class="italic">Chapter 4</em></a> as orders and products exist only as database records and dictionaries rather than as proper entities with encapsulated behavior and business rules.</p>
    <figure class="mediaobject"><img src="img/B31577_11_3.png" alt="Figure 11.3: Entangled responsibilities in the current order processing handler" width="1210" height="629"/></figure>
    <p class="packt_figref">Figure 11.3: Entangled responsibilities in the current order processing handler</p>
    <p class="normal"><em class="italic">Figure 11.3</em> illustrates <a id="_idIndexMarker623"/>how a single Flask route handler<a id="_idIndexMarker624"/> encompasses multiple responsibilities that should be separated according to Clean Architecture principles. The business logic is directly connected to infrastructure concerns such as database connections and external APIs, violating the Dependency Rule we explored in <a href="Chapter_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>.</p>
    <p class="normal">Based on our analysis, we’ve identified key architectural issues to address in our transformation:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Boundary violations</strong>: The route handler crosses multiple architectural boundaries, mixing web, business logic, and infrastructure concerns</li>
      <li class="bulletList"><strong class="keyWord">Missing domain model</strong>: We need to establish proper domain entities like Order and Product as the core of our system</li>
      <li class="bulletList"><strong class="keyWord">Dependency inversion needed</strong>: Direct infrastructure dependencies should be replaced with abstractions following the principles from <a href="Chapter_02.xhtml#_idTextAnchor040"><em class="italic">Chapter 2</em></a></li>
      <li class="bulletList"><strong class="keyWord">Interface separation required</strong>: Clear interfaces between architectural layers will help maintain proper boundaries</li>
    </ul>
    <p class="normal">There are key <a id="_idIndexMarker625"/>architectural issues in our order<a id="_idIndexMarker626"/> creation process; we can see a system that evolved without architectural guidance. Business logic, data access, and external services are tightly coupled, with no clear boundaries between concerns. The system works, but its structure makes it increasingly difficult to maintain, extend, or test.</p>
    <p class="normal">With this understanding of the current system, we’re now ready to begin our transformation journey. We’ll start by establishing a clean domain model in the next section, creating proper boundaries between layers as we progressively refactor toward a Clean Architecture.</p>
    <h2 id="_idParaDest-247" class="heading-2"><a id="_idTextAnchor263"/>Stage 1: establishing domain boundaries</h2>
    <p class="normal">Having analyzed our<a id="_idIndexMarker627"/> legacy system, we begin our <a id="_idIndexMarker628"/>transformation by establishing a clean domain model that will serve as our architectural foundation. Starting with the Domain layer provides a stable core around which we can progressively rebuild the outer layers of our system.</p>
    <p class="normal">In our order processing system, we need to extract the implicit domain concepts buried in our database queries and controller logic. The most critical entities in our system appear to be:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Order</strong>: The central business entity</li>
      <li class="bulletList"><strong class="keyWord">Customer</strong>: The buyer placing the order</li>
      <li class="bulletList"><strong class="keyWord">Product</strong>: Items being purchased</li>
      <li class="bulletList"><strong class="keyWord">OrderItem</strong>: The association between orders and products</li>
    </ul>
    <p class="normal">Let’s begin by implementing the <code class="inlineCode">Order</code> entity and its related value objects:</p>
    <pre class="programlisting code"><code class="hljs-code"># order_system/domain/entities/order.py
class OrderStatus(Enum):
    CREATED = "CREATED"
    PAID = "PAID"
    FULFILLING = "FULFILLING"
    SHIPPED = "SHIPPED"
    DELIVERED = "DELIVERED"
    CANCELED = "CANCELED"
@dataclass
class OrderItem:
    product_id: UUID
    quantity: int
    price: float
 
    @property
    def total_price(self) -&gt; float:
        return self.price * self.quantity
</code></pre>
    <p class="normal">Here we’ve defined<a id="_idIndexMarker629"/> an <code class="inlineCode">OrderStatus</code> enum to replace the string constants previously used throughout the code. We’ve also created an <code class="inlineCode">OrderItem</code> value object to represent the relationship between orders and products. This approach aligns<a id="_idIndexMarker630"/> with the value object pattern we explored in <a href="Chapter_04.xhtml#_idTextAnchor091"><em class="italic">Chapter 4</em></a>, creating immutable objects that represent important domain concepts.</p>
    <p class="normal">Now let’s implement the <code class="inlineCode">Order</code> entity itself:</p>
    <pre class="programlisting code"><code class="hljs-code">@dataclass
class Order:
    customer_id: UUID
    items: List[OrderItem] = field(default_factory=list)
    id: UUID = field(default_factory=uuid4)
    status: OrderStatus = OrderStatus.CREATED
    created_at: datetime = field(default_factory=lambda: datetime.now())
    updated_at: Optional[datetime] = None
 
    @property
    def total_price(self) -&gt; float:
        return sum(item.total_price for item in self.items)
 
    def add_item(self, item: OrderItem) -&gt; None:
        self.items.append(item)
        self.updated_at = datetime.now()
 
    def mark_as_paid(self) -&gt; None:
        if self.status != OrderStatus.CREATED:
            raise ValueError(
                f"Cannot mark as paid: order is {self.status.value}"
            )
        self.status = OrderStatus.PAID
        self.updated_at = datetime.now()
</code></pre>
    <p class="normal">Our <code class="inlineCode">Order</code> entity <a id="_idIndexMarker631"/>now properly encapsulates core business<a id="_idIndexMarker632"/> concepts that were previously scattered throughout the codebase. We’ve implemented methods that enforce business rules, such as validating state transitions when marking an order as paid. These validations were previously buried in controller logic but now reside in their proper home within the entity itself.</p>
    <p class="normal">We need to create the remaining domain entities to complete our core model:</p>
    <pre class="programlisting code"><code class="hljs-code"># order_system/domain/entities/product.py
@dataclass
class Product:
    name: str
    price: float
    stock: int
    id: UUID = field(default_factory=uuid4)
 
    def decrease_stock(self, quantity: int) -&gt; None:
        if quantity &lt;= 0:
            raise ValueError("Quantity must be positive")
        if quantity &gt; self.stock:
            raise ValueError(
                f"Insufficient stock: requested {quantity}, "
                f"available {self.stock}")
        self.stock -= quantity
</code></pre>
    <p class="normal">The <code class="inlineCode">Product</code> entity <a id="_idIndexMarker633"/>now encapsulates inventory <a id="_idIndexMarker634"/>management logic that was previously spread across controller methods. It enforces business rules such as preventing negative stock or excessive withdrawals. This is an example of the <em class="italic">tell, don’t ask</em> principle that helps maintain domain integrity.</p>
    <p class="normal">With our core domain entities defined, we need to create abstractions for the supporting services and repositories. Following the Dependency Inversion Principle we’ll define interfaces that the domain needs without coupling to specific implementations:</p>
    <pre class="programlisting code"><code class="hljs-code"># order_system/domain/repositories/order_repository.py
from order_system.domain.entities.order import Order
class OrderRepository(ABC):
    @abstractmethod
    def save(self, order: Order) -&gt; None:
        """Save an order to the repository"""
        pass
 
    @abstractmethod
    def get_by_id(self, order_id: UUID) -&gt; Optional[Order]:
        """Retrieve an order by its ID"""
        pass
 
    @abstractmethod
    def get_by_customer(self, customer_id: UUID) -&gt; List[Order]:
        """Retrieve all orders for a customer"""
        pass
</code></pre>
    <p class="normal">This abstract <code class="inlineCode">OrderRepository</code> defines the operations our Domain layer needs without specifying how they’re implemented. We’ll create similar interfaces for <code class="inlineCode">ProductRepository</code> and other necessary repositories. These abstractions are a crucial element of Clean Architecture, as they allow our Domain layer to remain independent of specific persistence mechanisms.</p>
    <p class="normal">If you recall the task <a id="_idIndexMarker635"/>management system from previous <a id="_idIndexMarker636"/>chapters, we established similar repository interfaces such as <code class="inlineCode">TaskRepository</code> in <a href="Chapter_05.xhtml#_idTextAnchor123"><em class="italic">Chapter 5</em></a>. Both follow the same pattern: defining abstract methods that domain components require without specifying implementation details. This consistency demonstrates how Clean Architecture’s principles apply across different domains and applications, creating a reliable pattern for maintaining proper boundaries.</p>
    <p class="normal">Next, let’s define service interfaces for external operations like payments and notifications:</p>
    <pre class="programlisting code"><code class="hljs-code"># order_system/domain/services/payment_service.py
from order_system.domain.entities.order import Order
@dataclass
class PaymentResult:
    success: bool
    error_message: Optional[str] = None
class PaymentService(ABC):
    @abstractmethod
    def process_payment(self, order: Order) -&gt; PaymentResult:
        """Process payment for an order"""
        pass
</code></pre>
    <p class="normal">With these core domain components defined, we’ve created a clean foundation for our system. The business rules and concepts that were previously scattered across controllers and utility functions now have a proper home in a well-structured domain model. This transformation <a id="_idIndexMarker637"/>provides several immediate <a id="_idIndexMarker638"/>benefits:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Business rules centralization</strong>: Rules like <em class="italic">cannot mark a non-CREATED order as PAID</em> are now explicitly defined in the domain model</li>
      <li class="bulletList"><strong class="keyWord">Improved testability</strong>: Domain entities and services can be tested in isolation without requiring database connections or web frameworks</li>
      <li class="bulletList"><strong class="keyWord">Clearer boundaries</strong>: The separation between core business concepts and infrastructure concerns is now explicit</li>
      <li class="bulletList"><strong class="keyWord">Richer domain model</strong>: We’ve moved from anemic database records to a rich domain model with behavior</li>
    </ul>
    <p class="normal">Let’s take a moment to review this new Domain layer:</p>
    <figure class="mediaobject"><img src="img/B31577_11_4.png" alt="Figure 11.4: The newly established domain model with clean boundaries" width="1167" height="665"/></figure>
    <p class="packt_figref">Figure 11.4: The newly established domain model with clean boundaries</p>
    <p class="normal">This diagram illustrates our <a id="_idIndexMarker639"/>first major transformation step: establishing a<a id="_idIndexMarker640"/> proper Domain layer with clean boundaries. We’ve created entities, value objects, and service interfaces that encapsulate our core business concepts and rules. Comparing this with <em class="italic">Figure 11.2</em>, we can see significant progress toward untangling the responsibilities that were previously mixed in our legacy controller implementation.</p>
    <h3 id="_idParaDest-248" class="heading-3"><a id="_idTextAnchor264"/>Incremental integration strategies</h3>
    <p class="normal">In real-world transformations, a <a id="_idIndexMarker641"/>common pitfall is attempting to implement the entire Clean Architecture in isolation before integration. This <em class="italic">big bang release</em> approach introduces significant risk since by the time integration occurs, the production system may have evolved substantially, creating complex merge conflicts and unexpected behavior changes.</p>
    <p class="normal">To mitigate this risk, several incremental integration strategies can be employed:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Adapter pattern</strong>: Create adapters that bridge legacy components and new domain entities, allowing<a id="_idIndexMarker642"/> them to coexist within the running system. This enables gradual adoption without disrupting existing functionality.</li>
      <li class="bulletList"><strong class="keyWord">Parallel implementation</strong>: Implement<a id="_idIndexMarker643"/> new functionality using Clean Architecture alongside legacy code, with feature flags controlling which implementation handles requests. This provides an easy rollback mechanism if issues arise.</li>
      <li class="bulletList"><strong class="keyWord">Strangler Fig pattern</strong>: Incrementally replace pieces of the legacy application while maintaining the same external interfaces, gradually supplanting the old implementation until it can <a id="_idIndexMarker644"/>be safely removed (<a href="https://martinfowler.com/bliki/StranglerFigApplication.html">https://martinfowler.com/bliki/StranglerFigApplication.html</a>).</li>
      <li class="bulletList"><strong class="keyWord">Shadow mode</strong>: Run new<a id="_idIndexMarker645"/> implementations alongside the production code by use of a proxy that duplicates all requests. This gives the new implementation the opportunity to process its copy of the request and we compare the outputs with the legacy system. This validates behavior without affecting users.</li>
    </ul>
    <p class="normal">Throughout this incremental<a id="_idIndexMarker646"/> transformation, comprehensive <strong class="keyWord">regression testing</strong> is absolutely essential. Before making any architectural<a id="_idIndexMarker647"/> changes, establish a thorough test suite that captures existing system behavior. These tests serve multiple purposes:</p>
    <ul>
      <li class="bulletList">They verify that refactoring hasn’t broken existing functionality</li>
      <li class="bulletList">They document current system behavior for reference</li>
      <li class="bulletList">They provide confidence to stakeholders that the transformation is proceeding safely</li>
    </ul>
    <p class="normal">As we discussed in <a href="Chapter_08.xhtml#_idTextAnchor192"><em class="italic">Chapter 8</em></a>, testing provides crucial safety nets during architectural transformation. For our order processing system, we would<a id="_idIndexMarker648"/> establish <strong class="keyWord">end-to-end tests</strong> that verify complete order flows before beginning our transformation, then supplement these with more granular tests as we establish clean architectural boundaries.</p>
    <p class="normal">By adopting these incremental strategies and prioritizing regression testing, we can transform our system while<a id="_idIndexMarker649"/> maintaining stability and continuing to deliver business value. In the next section, we’ll begin implementing the production integration approach described above, building on our domain model by implementing the Interface Adapters layer.</p>
    <h2 id="_idParaDest-249" class="heading-2"><a id="_idTextAnchor265"/>Stage 2: Interface layer implementation</h2>
    <p class="normal">With our domain entities <a id="_idIndexMarker650"/>and interfaces established, we now face a critical transition challenge: integrating this clean foundation with our<a id="_idIndexMarker651"/> existing codebase. Unlike greenfield development, transformation requires us to evolve our system incrementally while maintaining continuous operation. The <strong class="keyWord">Interface layer</strong> provides our first opportunity to bridge old and new architectures.</p>
    <h3 id="_idParaDest-250" class="heading-3"><a id="_idTextAnchor266"/>Identifying transformation boundaries</h3>
    <p class="normal">The<a id="_idIndexMarker652"/> first step in our transformation is identifying viable seams where we can introduce clean interfaces without overly disrupting the existing system. Looking back at our legacy controller, the order creation process stands out as a natural boundary:</p>
    <pre class="programlisting code"><code class="hljs-code"># order_system/app.py
@app.route('/orders', methods=['POST'])
def create_order():
    data = request.get_json()
 
    # Input validation mixed with business logic
    if not data or not 'customer_id' in data or not 'items' in data:
        return jsonify({'error': 'Missing required fields'}), 400
 
    # Direct database access in route handler
    conn = get_db_connection()
 
    # Business logic implementation
    # ... existing implementation ...
 
    return jsonify({'order_id': order_id, 'status': 'success'}), 201
</code></pre>
    <p class="normal">This<a id="_idIndexMarker653"/> controller method represents a self-contained workflow with clear inputs and outputs, making it an ideal candidate for our initial transformation. Before modifying this code, we need to establish comprehensive test coverage that captures its current behavior. These tests will serve as our safety net during refactoring, ensuring we maintain functionality while improving architecture:</p>
    <pre class="programlisting code"><code class="hljs-code"># test_order_creation.py
def test_create_order_success():
    # Setup test data and expected results
    response = client.post('/orders', json={
        'customer_id': '12345',
        'items': [{'product_id': '789', 'quantity': 2}]
    })
 
    # Verify status code and response structure
    assert response.status_code == 201
    assert 'order_id' in response.json
 
    # Verify database state - order was created with correct values
    conn = get_db_connection()
    order = conn.execute('SELECT * FROM orders WHERE id = ?',
                        (response.json['order_id'],)).fetchone()
    assert order['status'] == 'PAID'
# Additional order creation test scenarios ...
</code></pre>
    <p class="normal">With tests <a id="_idIndexMarker654"/>in place, we can begin implementing the Interface layer components that will bridge our clean domain model and the existing infrastructure.</p>
    <h3 id="_idParaDest-251" class="heading-3"><a id="_idTextAnchor267"/>Implementing repository adapters</h3>
    <p class="normal">Our first step is<a id="_idIndexMarker655"/> creating <strong class="keyWord">repository adapters</strong> that satisfy our clean domain interfaces while interacting with the existing database schema. This crucial component bridges our domain entities and legacy infrastructure.</p>
    <pre class="programlisting code"><code class="hljs-code"># order_system/infrastructure/repositories/sqlite_order_repository.py
class SQLiteOrderRepository(OrderRepository):
    # ... truncated implementation
 
    def save(self, order: Order) -&gt; None:
        conn = sqlite3.connect(self.db_path)
        try:
            cursor = conn.cursor()
            # Check if order exists and perform insert or update
            if self._order_exists(conn, order.id):
                # ... SQL update operation ...
            else:
                # ... SQL insert operation ...
             
                # ... SQL operations for order items ...
            conn.commit()
        except Exception as e:
            conn.rollback()
            raise RepositoryError(f"Failed to save order: {str(e)}")
        finally:
            conn.close()
</code></pre>
    <p class="normal">This repository <a id="_idIndexMarker656"/>adapter plays a vital role in our transformation strategy. You may recall from <a href="Chapter_06.xhtml#_idTextAnchor144"><em class="italic">Chapter 6</em></a> that we introduced similar repository implementations for our task management system. Like those examples, this adapter implements our clean <code class="inlineCode">OrderRepository</code> interface (from <em class="italic">Stage 1</em>) while handling the details of our existing database schema. The adapter translates between domain entities and database records, managing the impedance mismatch between our rich domain model and the flat relational structure.</p>
    <p class="normal">We would also implement a similar <code class="inlineCode">SQLiteProductRepository</code> that follows the same pattern, implementing a clean domain interface while interacting with the existing database schema. These repository implementations handle all database access details, connection management, and error handling, providing a clean interface to the rest of our architecture.</p>
    <p class="normal">Additionally, we would implement adapters for external services like payment processing. These service adapters would follow the same pattern, implementing our clean domain interfaces while encapsulating the details of external service interactions. For brevity, we won’t show these implementations here, but the complete code is available in the book’s GitHub repository.</p>
    <p class="normal">With these infrastructure adapters in place, we now have a bridge between our clean domain model and the legacy infrastructure. This enables us to implement use cases that work with proper domain entities while seamlessly interacting with the existing database and external services via interfaces versus interacting directly with concrete implementations.</p>
    <h3 id="_idParaDest-252" class="heading-3"><a id="_idTextAnchor268"/>Building clean use cases</h3>
    <p class="normal">Now that we have repository and <a id="_idIndexMarker657"/>service adapters that connect to our existing infrastructure, we can implement the use cases that orchestrate our business logic. In <a href="Chapter_05.xhtml#_idTextAnchor123"><em class="italic">Chapter 5</em></a>, we established that use cases serve as application-specific business rules that coordinate domain entities to fulfill specific user requirements. Following this pattern, let’s look at the order creation use case that will replace our tangled legacy implementation:</p>
    <pre class="programlisting code"><code class="hljs-code"># order_system/application/use_cases/create_order.py
@dataclass
class CreateOrderRequest:
    customer_id: UUID
    items: List[Dict[str, Any]]
@dataclass
class CreateOrderUseCase:
    order_repository: OrderRepository
    product_repository: ProductRepository
    payment_service: PaymentService
 
    def execute(self, request: CreateOrderRequest) -&gt; Order:
        # Create order entity with basic information
        order = Order(customer_id=request.customer_id)
     
        # Add items to order, checking inventory
        for item_data in request.items:
            product_id = UUID(item_data['product_id'])
            quantity = item_data['quantity']
         
            # ... inventory validation logic ...
         
            # Update inventory
            product.decrease_stock(quantity)
            self.product_repository.update(product)
</code></pre>
    <p class="normal">The <code class="inlineCode">execute</code> method<a id="_idIndexMarker658"/> of our use case begins by creating an <code class="inlineCode">Order</code> entity and adds items to it, checking inventory availability in the process. Note how it works with proper domain entities rather than raw database records.</p>
    <p class="normal">Let’s now examine the remainder of the <code class="inlineCode">execute</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code"># order_system/application/use_cases/create_order.py
    # def execute &lt;continued&gt;
     
        # Process payment
        payment_result = self.payment_service.process_payment(order)
        if not payment_result.success:
            raise ValueError(
                f"Payment failed: {payment_result.error_message}"
            )
        # Mark order as paid and save
        order.mark_as_paid()
   <a id="_idTextAnchor269"/>     self.order_repository.save(order)
     
        return order
</code></pre>
    <p class="normal">The second half of our <code class="inlineCode">execute</code> method continues the order creation process by handling payment processing, updating the order status, and saving the completed order.</p>
    <p class="normal">This use case demonstrates Clean Architecture’s separation of concerns in action. It orchestrates the order creation process by:</p>
    <ol>
      <li class="numberedList" value="1">Creating an <code class="inlineCode">Order</code> entity with basic information</li>
      <li class="numberedList">Adding items to the order, checking inventory</li>
      <li class="numberedList">Processing payment</li>
      <li class="numberedList">Updating the order status and saving it</li>
    </ol>
    <p class="normal">Each step interacts with the domain model through well-defined interfaces, without knowledge of the underlying infrastructure. The use case depends on abstract <code class="inlineCode">OrderRepository</code>, <code class="inlineCode">ProductRepository</code>, and <code class="inlineCode">PaymentService</code> interfaces, not on concrete implementations.</p>
    <p class="normal">Notice how the<a id="_idIndexMarker659"/> business rules are now explicit and centralized in this use case. Inventory checking, payment processing, and order status management all flow through a clean, organized process rather than being scattered across controller methods and utility functions. This clarity makes the code more maintainable and adaptable to changing requirements.</p>
    <h3 id="_idParaDest-253" class="heading-3"><a id="_idTextAnchor270"/>Implementing clean controllers</h3>
    <p class="normal">With our repositories <a id="_idIndexMarker660"/>and use cases in place, we now implement <strong class="keyWord">controllers</strong> that bridge our web framework and application core. As we <a id="_idIndexMarker661"/>established in <a href="Chapter_06.xhtml#_idTextAnchor144"><em class="italic">Chapter 6</em></a>, controllers serve as translation layers at the boundary of our architecture, converting external request formats into inputs our use cases can process. These controllers maintain the separation between our application core and delivery mechanisms, ensuring that web-specific concerns don’t penetrate our Clean Architecture:</p>
    <pre class="programlisting code"><code class="hljs-code"># order_system/interfaces/controllers/order_controller.py
@dataclass
class OrderController:
    create_use_case: CreateOrderUseCase
 
    def handle_create_order(
        self, request_data: Dict[str, Any]
    ) -&gt; Dict[str, Any]:
        try:
            # Transform web request to domain request format
            customer_id = UUID(request_data['customer_id'])
            items = request_data['items']
         
            request = CreateOrderRequest(
                customer_id=customer_id,
                items=items
            )
         
            # Execute use case
            order = self.create_use_case.execute(request)
         
            # Transform domain response to web response format
            return {
                'order_id': str(order.id),
                'status': order.status.value
            }
        except ValueError as e:
            # ... exception logic
</code></pre>
    <p class="normal">This controller shows<a id="_idIndexMarker662"/> Clean Architecture boundaries at work, functioning as a translation layer between external requests and our domain operations. The heart of this controller is the single line <code class="inlineCode">order = self.create_use_case.execute(request)</code>, which represents the critical boundary between our Interface layer and application core. Notice how the controller doesn’t reference Flask, HTTP status codes, or JSON formatting. These web-specific concerns are handled at the framework boundary, maintaining a clean separation between our application logic and delivery mechanism. This framework independence allows our controller to remain focused on its core responsibility, transforming external requests into domain operations and translating results back to a format suitable for the caller.</p>
    <h2 id="_idParaDest-254" class="heading-2"><a id="_idTextAnchor271"/>Stage 3: integration strategy: bridging legacy and clean implementations</h2>
    <p class="normal">Now comes the crucial step: integrating our<a id="_idIndexMarker663"/> clean implementation with the existing <a id="_idIndexMarker664"/>system. Rather than immediately replacing the entire legacy route handler, we’ll modify it to delegate to our clean controller using the adapter pattern:</p>
    <pre class="programlisting code"><code class="hljs-code"># Modified route in order_system/app.py
@app.route('/orders', methods=['POST'])
def create_order():
    data = request.get_json()
 
    # Basic input validation remains in the route handler
    if not data or not 'customer_id' in data or not 'items' in data:
        return jsonify({'error': 'Missing required fields'}), 400
 
    try:
        # Feature flag to control which implementation handles the request
        if app.config.get('USE_CLEAN_ARCHITECTURE', False):
            # Use the clean implementation
            result = order_controller.handle_create_order(data)
            return jsonify(result), 201
        else:
            # ... original implementation remains here ...
    except ValidationError as e:
        return jsonify({'error': str(e)}), 400
    except SystemError:
        return jsonify({'error': 'Internal server error'}), 500
</code></pre>
    <p class="normal">The key portion of this modification is the feature flag conditional. When <code class="inlineCode">USE_CLEAN_ARCHITECTURE</code> is enabled, we delegate order processing to our new controller, which then invokes the clean use case. This creates a controlled pathway into our Clean Architecture implementation without disturbing the existing code path. The feature flag gives us a simple mechanism to toggle between implementations, either globally or for specific requests.</p>
    <p class="normal">This modified route handler demonstrates several key transformation patterns:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Feature flag control</strong>: We use a configuration setting to determine which implementation processes the request, allowing us to gradually transition traffic.</li>
      <li class="bulletList"><strong class="keyWord">Consistent interfaces</strong>: Both implementations produce identical response formats, ensuring a seamless transition from the user’s perspective.</li>
      <li class="bulletList"><strong class="keyWord">Incremental migration</strong>: The legacy code remains fully functional, serving as a fallback if issues arise with the clean implementation.</li>
      <li class="bulletList"><strong class="keyWord">Exception translation</strong>: We map domain-specific exceptions to appropriate HTTP responses at the framework boundary.</li>
    </ul>
    <p class="normal">When<a id="_idIndexMarker665"/> integrating with specific frameworks like Flask, we<a id="_idIndexMarker666"/> must attend to framework-specific details at the system boundaries. In the case of Flask, we need to configure our dependency injection container, register our Clean Architecture components, and establish the feature flagging mechanism. We create a central configuration point that instantiates all necessary components (repositories, services, use cases, and controllers) and wires them together according to Clean Architecture’s dependency rules. This configuration happens at application startup, keeping all framework-specific initialization code at the system’s edge where it belongs. We saw this in action in our task management application in <a href="Chapter_07.xhtml#_idTextAnchor168"><em class="italic">Chapter 7</em></a>.</p>
    <h3 id="_idParaDest-255" class="heading-3"><a id="_idTextAnchor272"/>Incremental transformation approach</h3>
    <p class="normal">During this transformation <a id="_idIndexMarker667"/>process, comprehensive testing is absolutely essential. We leverage our regression test suite to ensure that refactoring hasn’t broken existing functionality. These tests verify both the legacy implementation and our new Clean Architecture components, providing confidence that the transformation maintains functional parity.</p>
    <p class="normal">Each step of our<a id="_idIndexMarker668"/> transformation is carefully validated before proceeding to the next. We don’t move forward until we’ve verified that our changes maintain system behavior and stability. This incremental approach minimizes risk and allows us to deliver value continuously throughout the transformation process.</p>
    <p class="normal">At a high level, our approach aligns with the Strangler Fig pattern (<a href="https://martinfowler.com/bliki/StranglerFigApplication.html">https://martinfowler.com/bliki/StranglerFigApplication.html</a>), where we gradually replace pieces of the legacy application while maintaining the same external interfaces. This approach minimizes risk by allowing incremental validation and rollback if needed.</p>
    <figure class="mediaobject"><img src="img/B31577_11_5.png" alt="Figure 11.5: Current system architecture showing parallel implementations" width="1210" height="789"/></figure>
    <p class="packt_figref">Figure 11.5: Current system architecture showing parallel implementations</p>
    <p class="normal"><em class="italic">Figure 11.5</em> illustrates <a id="_idIndexMarker669"/>our current architectural state, with both legacy and clean implementations coexisting in the system. The legacy components represent the tangled, unstructured code that directly mixes business logic with infrastructure concerns. In contrast, the Clean Architecture implementation shows proper separation of concerns with distinct layers and well-defined interfaces.</p>
    <p class="normal">Through this incremental implementation approach, we’ve made significant progress in our transformation journey:</p>
    <ol>
      <li class="numberedList" value="1">We’ve established a clean domain model with proper entities and value objects</li>
      <li class="numberedList">We’ve implemented repository adapters that bridge our domain model and the existing database</li>
      <li class="numberedList">We’ve created use cases that orchestrate the business logic using our domain model</li>
      <li class="numberedList">We’ve built controllers that translate between web requests and our domain language</li>
      <li class="numberedList">We’ve integrated our clean implementation alongside the legacy code using the adapter <a id="_idIndexMarker670"/>pattern</li>
    </ol>
    <p class="normal">Through this incremental implementation approach, we’ve demonstrated how to transform a legacy system using Clean Architecture principles while maintaining system stability and functionality throughout the process.</p>
    <h2 id="_idParaDest-256" class="heading-2"><a id="_idTextAnchor273"/>Stage 4: optimization stage</h2>
    <p class="normal">While our example has<a id="_idIndexMarker671"/> focused primarily on the foundation, interface, and <a id="_idIndexMarker672"/>integration stages, a complete transformation would eventually include an optimization stage. This final phase typically involves performance tuning, expanded test coverage, and improved error-handling patterns based on real-world usage.</p>
    <p class="normal">Rather than providing detailed examples of this stage, we’ll note that optimization should be approached with the same incremental mindset. Teams should prioritize optimizations that deliver the greatest business value, gradually removing feature flags as clean implementations prove stable, and ultimately decommissioning legacy code paths entirely.</p>
    <p class="normal">The optimization stage acknowledges that architectural transformation is not a one-time effort but rather a continuous refinement process that balances technical excellence with business priorities. Teams should define clear metrics for when <em class="italic">good enough</em> has been achieved, avoiding the trap of endless perfectionism.</p>
    <h1 id="_idParaDest-257" class="heading-1"><a id="_idTextAnchor274"/>Summary</h1>
    <p class="normal">In this chapter, we’ve explored how to apply Clean Architecture principles to legacy systems through systematic transformation. We began by examining how to evaluate existing systems through Clean Architecture’s lens, identifying architectural violations, and creating a staged approach to transformation.</p>
    <p class="normal"> We established a framework for building stakeholder alignment by translating technical debt into business impact terms and gathering deeper domain understanding through collaborative techniques like event storming. This collaborative approach directly informed our staged implementation plan, grounding our architectural decisions in business priorities.</p>
    <p class="normal">Through our order processing example, we demonstrated a progressive implementation approach that maintains system stability while establishing clean architectural boundaries. We started with the Domain layer, creating proper entities and value objects that encapsulate business rules previously scattered throughout the codebase. We then implemented repository interfaces that protect our domain from infrastructure details, followed by use cases that orchestrate business operations.</p>
    <p class="normal">The Interface Adapters layer provided a bridge between our clean implementation and legacy code, enabling incremental adoption through feature flags and adapter patterns. This staged approach allowed us to validate our transformation while minimizing risk, demonstrating how Clean Architecture can be applied pragmatically to real-world systems.</p>
    <p class="normal">By following these transformation patterns, you can systematically improve architectural quality in existing systems, reducing maintenance costs and increasing adaptability while continuing to deliver business value. This approach embodies Clean Architecture’s core principles while recognizing the practical constraints of evolving production systems.</p>
    <h1 id="_idParaDest-258" class="heading-1"><a id="_idTextAnchor275"/>Further reading</h1>
    <ul>
      <li class="bulletList"><em class="italic">Working Effectively with Legacy Code</em> (<a href="https://www.oreilly.com/library/view/working-effectively-with/0131177052/">https://www.oreilly.com/library/view/working-effectively-with/0131177052/</a>) by Michael Feathers. Provides techniques for working with existing codebases, including strategies for safely introducing tests and making incremental improvements.</li>
      <li class="bulletList"><em class="italic">Event Storming</em> (<a href="https://www.eventstorming.com">https://www.eventstorming.com</a>). A great resource for learning more about and planning event storming sessions.</li>
    </ul>
  </div>
</div></div></body></html>