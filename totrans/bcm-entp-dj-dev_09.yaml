- en: '*Chapter 7*: Working with Messages, Email Notifications, and PDF Reports'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will work with the Django messages framework, email notifications
    and templates, and PDF documents. In order for us to know that emails are actually
    being sent from our system and that they are rendered correctly in different email
    clients, we will be using a free third-party service to capture all of our outgoing
    emails. By capturing all outgoing emails, we can prevent development and test
    emails from being sent to people who should not be seeing them yet. We will use
    HTML, CSS, and the Django template language to create email and PDF report templates.
    Both will use context data just like how we passed context into templates in [*Chapter
    4*](B17243_04_ePub.xhtml#_idTextAnchor116), *URLs, Views, and Templates*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test environment for capturing all emails sent by the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Django messages framework to create flash messages and custom message
    levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and sending HTML and/or plain text-formatted emails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating template-based emails using HTML, CSS, and the Django template language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating PDF documents using HTML, CSS, and the Django template language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To work with the code in this chapter, the following tools will need to be
    installed on your local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: Python version 3.9 – used as the underlying programming language for the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django version 4.0 – used as the backend framework of the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pip package manager – used to manage third-party Python/Django packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will continue to work with the solution created in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037),
    *Project Configuration*. However, it is not necessary to use the Visual Studio
    IDE. The main project itself can be run using another IDE or run independently
    using a terminal or command-line window from within the project root folder, which
    is where the `manage.py` file resides. Whatever editor or IDE you are using, a
    virtual environment will also be needed to work with the Django project. Instructions
    for how to create a project and virtual environment can be found in [*Chapter
    2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project Configuration*. You will
    need a database to store the data contained in your project. PostgreSQL was chosen
    for the examples in the previous chapter; however, any database type that you
    choose for your project can be used to work with the examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will not be using any data found in the `chapter_3` app data fixture but
    if that data is already loaded, don't worry! The exercises in this chapter will
    all use data that is obtained from forms that the user is interacting with and
    not data coming from within a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the code created in this chapter can be found in the GitHub repository
    for this book: [https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer](https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer).
    The bulk of the code depicted in this chapter can be found in the `/becoming_a_django_entdev/becoming_a_django_entdev/chapter_7/`
    directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/3OzpalD](https://bit.ly/3OzpalD).'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start by creating a new app in your project called `chapter_7` by following
    the steps discussed in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project
    Configuration*, in the subsection titled *Creating a Django app*. As discussed
    in that section, don't forget to change the value of the `name =` variable for
    your app class found in the `/becoming_a_django_entdev/becoming_a_django_entdev/chapter_7/apps.py`
    file to now point to the path where you installed your app. Be sure to also include
    this app in the `INSTALLED_APPS` variable found in the `settings.py` file as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main `urls.py` file of the site, add the following path, which points
    to the URL patterns of the app that we will be creating in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Copy the URL patterns, forms, fields, views, templates, CSS, and JavaScript
    files found in the `chapter_5` app directly into the newly created `chapter_7`
    app. This way, we can keep the exercises of each chapter separated, and the exercises
    of this chapter will build on the exercises of [*Chapter 5*](B17243_05_ePub.xhtml#_idTextAnchor152),
    *Django Forms*. In the code that you copied into this chapter's app, make sure
    you update all file/code references from `chapter_5`/`chapter-5` to `chapter_7`/`chapter-7`
    where needed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Mailtrap account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to work with the email examples throughout this chapter, you will need
    an email testing service that will capture all emails being sent from the system
    being built, as we run the project locally. There are numerous different third-party
    services on the market today that all provide this solution. Each service varies
    in terms of the additional testing tools and features that they provide as well
    as the cost associated with that service. You are welcome to use a service other
    than the one chosen for this book. If you choose to do so, you will have to follow
    the instructions from that service in order to configure the settings for your
    project instead of the instructions found in this section.
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of demonstrating the exercises throughout this chapter, we will
    be using a completely free service called **Mailtrap**. No credit card is required
    to create an account with them and it's free for personal side projects. This
    is not a trial-based plan; it is free for a lifetime, or at least until Mailtrap
    changes its policies and procedures. Mailtrap also offers upgraded paid plans,
    which provide additional tools and support should you and your team decide to
    use this service, which would be particularly useful in multiple development environments
    and with large testing teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create and set up your Mailtrap account:'
  prefs: []
  type: TYPE_NORMAL
- en: Visit [https://mailtrap.io/register/signup](https://mailtrap.io/register/signup)
    to create a new account. Follow the steps that they provide on their website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To activate your account, you will need to go back to your email inbox and click
    the `Junk` folder if you do not see it in your inbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once that is complete, log into your new account and you will be taken to **My
    Inbox**, with the first tab, **SMTP Settings**, selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under the `settings.py` file of your project, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Mailtrap – SMTP Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.01_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Mailtrap – SMTP Settings
  prefs: []
  type: TYPE_NORMAL
- en: Add these variables, along with the credentials that were provided in your account,
    anywhere inside your `settings.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This step is optional. To separate these variables in a production environment,
    use the following conditional statement in your `settings.py` file. The values
    of each variable are also being kept within the `.env` file of a project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to add the variables to your local `.env` file before running your
    project when using the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In order for Mailtrap to work with your project on Heroku, make sure you add
    the four email variables from your local `.env` file to the config variables of
    each Heroku app. For instructions on how to do this, refer to [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037),
    *Project Configuration*, under the subsection titled *Remote variables*. You can
    use the same connection settings for each environment and they will all go to
    the same inbox.
  prefs: []
  type: TYPE_NORMAL
- en: That's it. Mailtrap is now configured and will intercept all emails being sent
    from your Django project. Let's move on to creating flash messages with the Django
    messages framework next.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Django messages framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's begin by introducing the **Django Messages Framework**, which is a framework
    used to provide session-based messages to the user. A **flash message** is a one-time
    notification message displayed directly to the user and is the kind of message
    that this framework creates. What we can do with this is render messages to the
    user anywhere we put the code inside our templates, whether that be in a modal
    popup or a message that drops down from the top of the page or comes up from the
    bottom of the page. It can even appear above or below a form that the user is
    submitting.
  prefs: []
  type: TYPE_NORMAL
- en: The `chapter_7` `FormClassView` class will be the primary working class throughout
    this chapter, as it will be used primarily to trigger the actions we will be writing.
    We will be writing the methods to perform those actions in the corresponding `ContactForm`
    class used by that `FormClassView` class of the `chapter_7` app.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start writing those classes, we will begin by enabling the Django
    messages framework next.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the Django messages framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These settings will enable the Django messages framework. A project does not
    require this framework to operate. These settings can be removed if desired but
    are required to work with this chapter. It is likely that when you created your
    project, these settings were generated for you automatically. Double-check just
    to make sure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `settings.py` file, make sure these settings and values exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: One important thing to remember in the preceding settings is that `SessionMiddleware`
    always comes before the `MessageMiddleware` entry in the `MIDDLEWARE` list. The
    same applies to the `INSTALLED_APPS` variable; make sure the `django.contrib.sessions`
    app comes before the `django.contrib.messages` app. The Django messages framework
    context processor shown under the `TEMPLATES` configuration is also needed to
    make your Django messages framework context available from within any of your
    templates. This means that you do not have to explicitly define a variable in
    the context of each page specifically for your messages. Instead, it will be available
    via the global context of your project automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss additional configuring/enabling of the Django messages
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: Message storage backends
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`MESSAGE_STORAGE` variable in the `settings.py` file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The backend choices available for `MESSAGE_STORAGE` are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`django.contrib.messages.storage.session.SessionStorage` – stores messages
    in the requests session and will require that the `django.contrib.sessions` app
    be included in the `INSTALLED_APPS` variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django.contrib.messages.storage.fallback.FallbackStorage` – this option uses
    the now-legacy `CookieStorage` first and then, when cookie data exceeds the 2,048-byte
    threshold, instead of deleting those older cookies, as is the default action of
    the `CookieStorage` option, new messages will instead be placed in `SessionStorage`.
    `CookieStorage` is no longer supported in Django 4.0 but is still available in
    the `django.contrib.messages.storage` library. It is unknown when this storage
    method will be removed completely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django.contrib.messages.storage.base.BaseStorage` – Django provides this class
    as a way for developers to create their own storage systems. By itself, this will
    not work because this is an abstract class meant to be extended. This is considered
    an advanced topic beyond the scope of this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s go ahead and set this to use the `SessionStorage` option for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Message levels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Message levels** indicate the different severity levels of a message. These
    levels have a variable name, a lowercase tag name, and a numeric value indicating
    the severity level, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By default, Django sets the `MESSAGE_LEVEL` variable to `INFO`; more specifically,
    Django sets this to a value of `20`. This means if we try to issue a `DEBUG`-related
    message, which has a value of `10`, it will never be rendered to the page. Some
    might think this is a bug in the Django framework; however, this is by intentional
    design. The reason is that in a production setting, we do not want those messages
    to appear anywhere to the user. Any custom message levels with a value below `20`
    would also not appear. Instead, we only want developers, and maybe the testers,
    to see that message in a development or local environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable `DEBUG`-related messages in your environment, the best way to do
    this is by once again utilizing the debug conditional in your `settings.py` file,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are explicitly defining the `MESSAGE_LEVEL` setting to include `DEBUG`-related
    messages while the project's `DEBUG` variable is set to `True`. If `DEBUG` is
    set to `False`, as is done in the `.env` file of the production environment, then
    it will use the default Django setting of `messages.INFO` for this variable. We
    could just leave the `else` condition out of the equation altogether; however,
    it was written as a placeholder for illustrative purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Message tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`/becoming_a_django_entdev/chapter_7/static/chapter_7/css/site.css` file provided
    with the code of this book, there are CSS styles that do just that; they style
    each message level discussed in this chapter as a different color. Copy and paste
    these styles into your project to see the same colors depicted in these images
    within your browser.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, let''s change the tag for the `INFO` message from the original
    `info` to `information`, using the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `DEBUG`, `SUCCESS`, `WARNING`, and `ERROR` message
    tags will all continue to use their default message tag values because we did
    not include them in this list.
  prefs: []
  type: TYPE_NORMAL
- en: Custom message levels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`settings.py` file, go ahead and add three new variables with numeric values,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Each new level is defined using those numeric values. They can be named anything
    that does not conflict with other settings variables. These values can be any
    number, such as `19` or `199`, though it is best not to use any of the default
    values, such as `10`, `20`, `25`, `30`, or `40` because these values are being
    used by other levels, We also added those variables to the `MESSAGE_TAGS` variable
    because when we have events that create a new message, it will also need a message
    tag to add a CSS class to when rendering the HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the settings are configured for the Django messages framework, we can
    use that framework and create messages next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating messages is very simple. For this exercise, let's modify the `post()`
    method found in the `FormClassView` class that we duplicated into the `chapter_7`
    app. Here, we will be adding the code that will create the message when the form
    is submitted. Django provides two ways to write a message, one way using the provided
    `add_message()` method and another by explicitly adding that message to one of
    the five default message levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps demonstrate using both ways. Please use only one or the
    other:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `/chapter_7/views.py` file, add the `add_message()` statement and context
    highlighted in the following code block to the `FormClassView` class under the
    `if form.is_valid():` condition. Remember to comment out or delete the `return`
    statement found in this condition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, in the `/chapter_7/views.py` file, add the `add_message()` statement
    and context highlighted in the following code block to the `FormClassView` class
    under the `else:` condition. Remember to comment out or delete the `return` statement
    found in this condition and add the new `return` statement shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This step is not required; it just shows an alternative way of writing and
    using the messages shown previously. Use the `Success` and `Error` level statements
    highlighted in the following code block as alternatives to the ones shown previously.
    Use only one or the other:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using either of the add message examples will perform the same add message action,
    whereas using both at the same time will result in the same message being added
    twice to your storage system. In the `post()` method depicted previously, we commented
    out the old redirect statement and are now defining a success and failure message
    on form submission, using the same condition as before to check whether the form
    is valid. The message itself can accept a string and that string can contain HTML,
    as depicted in the preceding failure message. If HTML does exist in your string,
    the message would have to use the `|safe` filter when working with messages in
    a template.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's go over the extra things we can do when creating a message.
  prefs: []
  type: TYPE_NORMAL
- en: Using a custom message level
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we want to use one of the custom message levels that we created, such as
    `CRITICAL`, then we can only use the `add_message()` method. We also need to import
    `settings` to access those variables, as depicted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Messages are created in the same way, except `settings.LEVEL` is used instead
    of `messages.LEVEL`.
  prefs: []
  type: TYPE_NORMAL
- en: With extra tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can pass additional custom CSS classes for a message and that message only.
    This is done by adding that class(es) to the add message operation using the `extra_tags`
    attribute. For example, let''s render our message with two classes, the `success`
    class, which gets added automatically, and an additional class called `bold` to
    then bolden the text that is rendered, using the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'After completing the section of this chapter titled *Displaying messages*,
    when we load the page and then inspect the message, what we should see rendered
    to the screen when inspecting that particular element is both the CSS classes
    **bold** and **success**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Django messages framework – extra_tags attribute'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.02_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – Django messages framework – extra_tags attribute
  prefs: []
  type: TYPE_NORMAL
- en: That fails silently
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating a message that **fails silently** simply means creating a reusable
    app using the Django messages framework that does not require other developers
    using your app in a different project to actually have the Django messages framework
    enabled within their project. This means if they have disabled this framework
    or just do not have it enabled yet, the add message operations will not prevent
    their project from functioning properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this option, add the `fail_silently` attribute to your add message actions,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `fail_silently` attribute set to `True`, the application will run
    as normal, without errors that prevent the code from running. If the developer
    has disabled the Django messages framework and the `fail_silently` attribute is
    not included, then when running the application, that should trigger a flash message,
    where you will see a **MessageFailure** error, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Django messages framework – fail_silently attribute'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.03_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – Django messages framework – fail_silently attribute
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will render our messages into a template as HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order for messages to actually be seen by the user, we need to add some
    code to a Django template. Using the `/chapter_7/templates/chapter_7/form-class.html`
    file, which the `chapter_7` `FormClassView` class uses as its template, add the
    following code to the top of the HTML `<form>` object found inside that template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: All other code in this file can be left as is. Here, we use a simple conditional
    statement checking whether any messages exist in the storage system for this request.
    If they do, a `<ul>` list is created and then iterated through every message that
    exists, creating each one as a separate `<li>` item within that list. The message
    itself is using the `|safe` filter, allowing it to render HTML that can exist
    in the message string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visit the URL `http://www.localhost:8000/chapter-7/form-class/` and submit
    the form. Either the valid or invalid message will display, depending on whether
    or not you actually triggered a validation error with that form, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Django messages framework – displaying messages'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.04_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – Django messages framework – displaying messages
  prefs: []
  type: TYPE_NORMAL
- en: The preceding message is displayed within the browser in green, if you are using
    the CSS classes provided by the book.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have enabled the Django messages framework and added several messages
    to one of our view classes, let's practice sending an email notification instead
    of displaying a flash message next.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring email notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will help us to build actual email notifications instead of flash
    messages. We will write our logic to trigger the send email action in the same
    `FormClassView` class where we added messages inside the `post()` method. We will
    be utilizing the Mailtrap account that we created at the beginning of this chapter
    to capture all emails that are sent by our project. If you have not already done
    so, please create an account with Mailtrap and configure that connection in your
    `settings.py` file. Without doing so, you will have difficulty executing the code
    throughout this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three MIME types that exist for emails, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`text/plain`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application/rtf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text/html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While there are three MIME types, only two are used by Django when sending
    emails: plain text and HTML. Rich text emails are treated as HTML emails because
    they contain HTML markup.'
  prefs: []
  type: TYPE_NORMAL
- en: As plain text emails
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Plain text emails are just like they sound; they are just text and nothing
    else. We will be creating a method that prepares and then actually sends the email
    inside of the `ContactForm` class that we are using. The method that triggers
    the sending of an email can technically be placed in any class or any file. Follow
    these steps to create yours:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ContactForm` class that was duplicated into the `/chapter_7/forms.py`
    file, add a new method called `send_email()` using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method will handle all of the busy work involved in actually formatting
    and sending the email. Of course, this is a basic `text/plain` email consisting
    of only the phrase `msg_body` variable. The `email.content_subtype` statement
    is where we are telling Django that we want to format this email as a plain text
    email. We also imported and used the `EmailMessage` class from the `django.core.mail`
    library, used to structure the email and format headers pertaining to that email.
    Django also provides simpler method-based functions, such as `send_mail()` or
    `send_mass_mail()`, among a small handful of other methods. We will focus on just
    the `EmailMessage` class, as it will encompass every aspect of what we need to
    achieve in this chapter. To learn more about all of the email methods that Django
    provides, visit the official documentation, found here: [https://docs.djangoproject.com/en/4.0/topics/email/](https://docs.djangoproject.com/en/4.0/topics/email/).'
  prefs: []
  type: TYPE_NORMAL
- en: Because we are keeping this example extremely basic, we are only defining the
    `subject`, `body`, `from_email`, `reply_to`, and `to` attributes. Data is accessed
    by using `self.cleaned_data` and here we assign the value of the field named `email_1`
    to be the value of the `to` attributes list, as in the recipient's email address.
    If you are sending the email to multiple addresses, separate each email address
    with a comma in that list with no spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `FormClassView` class found in the `/chapter_7/views.py` file, leave
    everything as is, relating to the sending of messages in that view class. To actually
    send the email, add the following line of code to the `post()` method, as depicted
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are placing the send email operation just above the `return` statement
    and below the conditional statement that checks whether the form is valid. We
    are not separating the send operation for valid and invalid form submissions at
    this time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, visit the URL `http://www.localhost:8000/chapter-7/form-class/`and submit
    the form, in either a valid or invalid state. The page should refresh without
    programming errors. You should now see your email in the inbox of your Mailtrap
    account, found at [https://mailtrap.io/inboxes/](https://mailtrap.io/inboxes/),
    as depicted in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Mailtrap – plain text email'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.05_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – Mailtrap – plain text email
  prefs: []
  type: TYPE_NORMAL
- en: You will also notice that the email is displayed under the `text/plain`.
  prefs: []
  type: TYPE_NORMAL
- en: As HTML emails
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Configuring an HTML or rich text email is fairly easy. Using the same example
    from the previous section, *As plain text emails*, all that is needed to convert
    to an HTML email is to change two lines of code. The first line of code is to
    change the `msg_body` variable to equal `'<b>Hello World</b>'`. This way, we can
    actually pass in HTML to see whether it is working or not. The second is to change
    the value of `email.content_subtype` to equal `'html'`, and that's it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, visit the same URL, `http://www.localhost:8000/chapter-7/form-class/`,
    and submit the form. This time, when you visit your Mailtrap inbox at [https://mailtrap.io/inboxes/](https://mailtrap.io/inboxes/),
    you should see the **Hello World** text in bold, as depicted in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Mailtrap – HTML email'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.06_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – Mailtrap – HTML email
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you will also see that the email is now displayed
    in the `text/html` MIME type with no text fallback provided, meaning only HTML
    is available for this email. Clicking on the **Tech Info** tab will reveal other
    detailed information about your email. In this tab, you can verify the actual
    content type. Check if the value of the Content-Type has a MIME type that equals
    **text/html; charset=utf-8**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The value of `'html'` is used for both rich text- and HTML-formatted emails.
    They will both be sent as `text/html`. This is because we cannot explicitly tell
    Django to use `'application/rtf'` for rich text emails. Django just assumes rich
    text emails are HTML because they contain HTML markup.
  prefs: []
  type: TYPE_NORMAL
- en: As HTML emails with a plain text alternative
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTML emails that have plain text alternatives are used for email clients that
    have difficulty rendering the HTML-formatted version of the email or or if spam
    blockers only display text first. We need to use the Django-provided `EmailMultiAlternatives`
    class instead of the `EmailMessage` class to do this. `EmailMultiAlternatives`
    is an extension of the `EmailMessage` class, meaning that all of the methods and
    attributes available in the `EmailMessage` class are still available for us to
    use in this class, plus more. When using this class, what we do is format the
    email as `text/html` and then use the new `attach_alternative()` method available
    in the `EmailMultiAlternatives` class with that alternative email formatted as
    `text/plain`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the same code as in the *As HTML emails* subsection and make the following
    highlighted changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we just replaced the `EmailMessage` class with the
    new `EmailMultiAlternatives` class. Then, we added the `email.attact_alternative()`
    action statement, which formats a brand-new email as `text/plain` using the text
    that we provided, `Hello World`, and attaches that new plain text-formatted email
    to the original HTML email. We do this instead of using the `attachment` attribute
    of the `EmailMessage` class because we are actually restructuring the content
    type of the email to now be a `multipart/alternative` MIME type instead of either
    the `text/html` or `text/plain` MIME types.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it; you now have an email that is both HTML and plain text. Let''s
    verify this. Visit the same URL, `http://www.localhost:8000/chapter-7/form-class/`,
    and submit the form. This time, when you visit your Mailtrap inbox at [https://mailtrap.io/inboxes/](https://mailtrap.io/inboxes/),
    you should see the **Hello World** text in bold and also see the **Text** tab
    is now highlighted and clickable, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Mailtrap – HTML and plain text email'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.07_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – Mailtrap – HTML and plain text email
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on the **Text** tab will show you the plain text format that is available.
    The primary format is HTML and the fallback will be plain text. The order of the
    content types can be reversed in this example. When we click on the **Tech Info**
    tab, we will now see that **Content-Type** is displaying **multipart/alternative**,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Mailtrap – multipart/alternative'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.08_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.8 – Mailtrap – multipart/alternative
  prefs: []
  type: TYPE_NORMAL
- en: With file attachments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sending an email with a file attachment is also very easy. Django's `EmailMessage`
    class provides a method called `attach_file()`, which easily lets us attach a
    file by passing in the two positional arguments of that method, the path of the
    file and an optional MIME type. For this next exercise, copy the example PDF document
    that has been provided along with the code of this book in the `/becoming_a_django_entdev/chapter_7/static/chapter_7/pdf/`
    directory, called `example.pdf`. Copy that file into the same directory as your
    project before following this example, or create a dummy PDF file of your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this next example, we will continue with the last example we just completed
    in the *As HTML emails with a plain text alternative* section, and attach the
    `example.pdf` document to that email. The Django documentation depicts using the
    `attach_file()` method with a path written as `email.attach_file(''static/chapter_7/pdf/example.pdf'')`.
    This is how a path will be defined when using this method in many Django projects.
    However, due to using the `whitenoise` package, we will have to import the `settings.py`
    file and use the `STATIC_ROOT` variable, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the `STATIC_ROOT` variable in combination with the `whitenoise`
    package, we now have to run the `collectstatic` Django management command for
    that file to be found when we run the project locally. This doesn''t need to be
    done in every Django project but in ours, it must. To do so, first stop your project
    from running. In a terminal or command-line window, this can be done by pressing
    *Ctrl* + *C* on Windows or *Cmd* + *C* on a Mac with your keyboard. Then, execute
    the following commands. When prompted to do so, type the word `yes` and press
    *Enter* when it asks whether you are sure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(virtual_env) python manage.py collectstatic`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(virtual_env) python manage.py runserver`'
  prefs: []
  type: TYPE_NORMAL
- en: This is a built-in Django command that will collect static files from all apps
    loaded into your project and place a copy of them into the `STATIC_ROOT` of your
    project, which is defined as the `/becoming_a_django_entdev/staticfiles/` folder
    that we have ignored in our Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it. Now, if you visit the same URL, `http://www.localhost:8000/chapter-7/form-class/`,
    and submit the form, this time when you visit your Mailtrap inbox at [https://mailtrap.io/inboxes/](https://mailtrap.io/inboxes/),
    you should see the attached file in the top right-hand corner of that email, as
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Mailtrap – PDF attachment'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.09_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.9 – Mailtrap – PDF attachment
  prefs: []
  type: TYPE_NORMAL
- en: Mailtrap will let you click on this document to open and view it or download
    it. Open the document to see it working properly.
  prefs: []
  type: TYPE_NORMAL
- en: That fail silently
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developers can write reusable apps containing actions that send emails and have
    them fail silently just as we did when using the Django messages framework. This
    means that a project won't error out when a developer has installed your app but
    has not configured a connection to an email client yet. Django provides this option
    as an attribute of the `send()` method of the `EmailMessage` or `EmailMultiAlternatives`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate the `fail_silently` option on the send email examples that we just
    wrote, add the following attribute to the existing `send()` action, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: This prevents the `email.send()` action from displaying an error message when
    this code is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Django also provides this option when using the `send_mail()` and `send_mass_mail()`
    methods mentioned earlier. To learn more, visit [https://docs.djangoproject.com/en/4.0/topics/email/](https://docs.djangoproject.com/en/4.0/topics/email/).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a better understanding of how emails are being sent in Django,
    let's go ahead and create our own email templates to let us custom-tailor them
    for our clients.
  prefs: []
  type: TYPE_NORMAL
- en: Writing custom email templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing HTML as a string in Python can get really messy. We can write the body
    contents, such as `'<b>Hello World</b>'`, as a `.html` template file instead.
    That will allow us to organize multiple email templates into the `/templates/emails/`
    directory of the `chapter_7` app. Programming work can also be shared among developers
    in this way. Email templates can also be used for plain text-formatted emails,
    placing only the text without any HTML code inside of that `.html` file. While
    that may not sound appealing for plain text emails, this does have its benefits
    when working among a large team of developers. Let's begin with the simplest template
    using only plain text emails.
  prefs: []
  type: TYPE_NORMAL
- en: Django provides the `get_template()` method, found in the `django.template.loader`
    library. This method will be used for all the email template examples in the following
    subsections.
  prefs: []
  type: TYPE_NORMAL
- en: For plain text emails
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a template for a plain text email:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ContactForm` class that we have been working with, modify the `send_email()`
    method to now be the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we imported the `get_template()` method and used it to
    construct the template variable, which points to the `/chapter_7/emails/plain_text_format.html`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, go ahead and create that file in that same directory within your `/chapter_7/templates/`
    folder. Inside that file, just add the text `Hello World` and nothing else. If
    you place any HTML in this file, it will be rendered as a string within the plain
    text body content of that email and will not be rendered as HTML.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, visit the same URL, `http://www.localhost:8000/chapter-7/form-class/`,
    and submit the form. This time, when you visit your Mailtrap inbox at [https://mailtrap.io/inboxes/](https://mailtrap.io/inboxes/),
    you should see that the **HTML** tabs are disabled, leaving only the **Text**
    tab to view your email. This also indicates that the process was successful, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Mailtrap – plain text template'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.10_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.10 – Mailtrap – plain text template
  prefs: []
  type: TYPE_NORMAL
- en: For HTML emails
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Writing HTML templates is done in the same way as how we loaded a template
    for the plain text example previously. Only the following alterations are needed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we load a new file called `html_format.html` and change `content_subtype`
    back to `''html''`, as is highlighted here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create the `html_format.html` file in your `/chapter_7/templates/chapter_7/emails/`
    directory. Inside this file, place the following code, where we actually have
    to format the document like an HTML page, in addition to providing the marked-up
    `Hello World` text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this template, you can format your HTML `<head>` and `<body>` content as
    desired. It might even be wise to include responsive email and browser/client-supported
    syntax within this document to make sure it renders properly on every device.
    Your email test client will usually provide documentation to help you with stuff
    like that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, visit the same URL, `http://www.localhost:8000/chapter-7/form-class/`,
    and submit the form. This time, when you visit your Mailtrap inbox at [https://mailtrap.io/inboxes/](https://mailtrap.io/inboxes/),
    you should see that the **HTML** tab is now enabled and the **Text** tab is disabled.
    Again, this indicates that the process was successful, as depicted here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Mailtrap – HTML template'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.11_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.11 – Mailtrap – HTML template
  prefs: []
  type: TYPE_NORMAL
- en: Providing template context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using template-based emails can become even more useful when we introduce dynamic
    content into the equation. To do this, we need to send context into the `template.render()`
    statement. By doing this, we can even pass the form data that was already defined
    as the `data` variable directly into the template, accessing form field values
    within that template.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this next exercise, we will render a template that also displays exactly
    what the user typed for each field of that form. Follow these steps to do just
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `send_email()` method of `ContactForm`, make the following highlighted
    changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a new file called `new_contact_form_entry.html` in your `/chapter_7/templates/chapter_7/emails/`
    directory and place the following code inside that file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this template, you can use any of the tags and filters that come standard
    with the Django template language, such as writing conditional statements to check
    whether a field value equals a specific value. This means you could write a loop
    to automatically loop through all of the fields that exist in your `data` variable
    and then use the provided field labels instead of those custom labels depicted
    previously. You can also load `static` and/or custom `templatetags` using the
    load tag depicted previously, as with any other Django template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, visit the same URL, `http://www.localhost:8000/chapter-7/form-class/`,
    and submit the form. This time, when you visit your Mailtrap inbox at [https://mailtrap.io/inboxes/](https://mailtrap.io/inboxes/),
    you should see the values of each field inside the new email, as depicted here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Mailtrap – template context'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.12_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.12 – Mailtrap – template context
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's add a new action that creates a PDF document in the same spot where
    we are triggering our send email actions.
  prefs: []
  type: TYPE_NORMAL
- en: Generating PDF reports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django relies on the support of third-party packages in order to generate PDF
    documents. Their own documentation even suggests using the `reportlab` package;
    however, any third-party package that provides PDF support can be used. When using
    anything other than `reportlab`, refer to that package's documentation for instructions
    on how to use that package. The `reportlab` package even provides sample PDF invoices,
    reports, catalogs, and more for developers to get started quickly and easily,
    that is, if they are using the paid Plus version of the `reportlab` package. The
    Plus version requires the `rlextra` package, which is not available to the public.
    To learn more about what this service and package can provide, visit their documentation
    at [https://www.reportlab.com/dev/docs/](https://www.reportlab.com/dev/docs/).
  prefs: []
  type: TYPE_NORMAL
- en: For the exercises throughout this section, we will be using the `xhtml2pdf`
    package instead, which is also free but a bit simpler and easier to use when working
    with template-based PDFs. We will keep to the same idea of creating a separate
    `.html` file for the content of each static or dynamic PDF.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `xhtml2pdf` package to your `requirements.txt` file and install it
    into your virtual environment or run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: In all packages that I have worked with, I found that some have difficulty rendering
    complex HTML tables consistently. I would recommend avoiding tables altogether,
    or if you need to structure data as a table, do so with a simple structure to
    prevent rendering discrepancies and errors during document creation.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have installed a tool that generates PDF documents, let's practice
    using it.
  prefs: []
  type: TYPE_NORMAL
- en: As template-based PDFs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we will be using the same Django template language to build what we will
    call **PDF templates**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create your template:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new method called `generate_pdf()` in the `ContactForm` class and
    include the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we import the `pisa` library from within the `xhtml2pdf` package and
    use the `CreatePDF()` method. We are also using the Python `open()` method to
    specify the destination folder and filename of the document that we want to create.
    We are using the same `STATIC_ROOT` variable that we used before, most likely
    due to the `whitenoise` package in our project stack. The file being created will
    be located in the `/becoming_a_django_entdev/staticfiles/chapter_7/pdf/` directory.
    Then, we are setting the `result` variable to equal the result of running the
    `CreatePDF()` method where we pass in the rendered HTML template as the content
    of that PDF. Additional information is available in the documentation, found here:
    [https://xhtml2pdf.readthedocs.io/en/latest/format_html.html](https://xhtml2pdf.readthedocs.io/en/latest/format_html.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since we are creating this file, there is no need to run the `collectstatic`
    command as we had to before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the `post()` method of the `FormClass_View` class, where we wrote
    our `send_email()` action, let''s add the `generate_pdf()` operation just below
    that statement, as shown and highlighted here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, in the `pdf_template.html` file that we are specifying as the template
    used for the body content of the PDF, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are writing standard HTML code to create the content of the PDF. The
    preceding example creates a reusable and repeatable header and footer on every
    page of the document. We also use special vendor-specific tags to tell us things
    such as the current page or the total page count of the document, such as what
    is used in the footer of the document, `<pdf:pagenumber>` and `<pdf:pagecount>`.
    We also use the Django-provided `{% lorem %}` template tag, which generates 50
    paragraphs worth of Latin text, using the `50 p` values that we are passing into
    that function. The Latin text, represented as **Lorem Ipsum**, is used only to
    illustrate what happens when there is more than one page worth of content without
    actually writing that content.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `size` attribute is used to specify the HTML document size that we want
    to specify the physical size and orientation of the PDF document. Next, use the
    `@page` and `@frame` CSS objects to format your PDF document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `-pdf-frame-content` attribute is used to map the `@frame` object to the
    actual `<div>` with an ID attribute that matches the value specified. This must
    be `<div>` and not a `<header>` or `<footer>` HTML object or else your content
    will not render properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, visit the same URL, `http://www.localhost:8000/chapter-7/form-class/`,
    and submit the form. This time, you should see a new file called `test.pdf` in
    your `/becoming_a_django_entdev/staticfiles/chapter_7/pdf/` directory. When opening
    that document, you should see about eight pages worth of randomly generated Latin
    text, and on every page, you should see the same header and footer, as depicted
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.13 – xhmtl2pdf – static PDF'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.13_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.13 – xhmtl2pdf – static PDF
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: When opening this document to see what it looks like, particularly on Windows,
    you must close this document before submitting your form again, triggering it
    to generate a new document. You may run into permission errors stating that another
    person or application is already using that file if you don't.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add context to the PDF templates next.
  prefs: []
  type: TYPE_NORMAL
- en: Adding context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's pass the contents of the form field values into that PDF as context. This
    method does not always need to live in a form class; the same also applies to
    the `send_email()` method. They can live in a view or model class or even exist
    as a standalone utility method that can be used anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, modify the previous example to pass in context using the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same `generate_pdf()` method of the `ContactForm` class, make the changes
    highlighted here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, in the same `/chapter_7/pdfs/pdf_template.html` file, add the following
    highlighted code between the two existing lines of code, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The same code written in the *Providing template context* subsection of this
    chapter is used.
  prefs: []
  type: TYPE_NORMAL
- en: Now, visit the same URL, `http://www.localhost:8000/chapter-7/form-class/`,
    and submit the form. You should see a new file called `test_2.pdf` in the `/becoming_a_django_entdev/staticfiles/chapter_7/pdf/`
    directory on your local machine. When you open that file, there should still be
    eight pages worth of content. On the first page only, there will be a list containing
    the content of the form that we just passed into that PDF template, as depicted
    here:![Figure 7.14 – xhmtl2pdf – dynamic PDF
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.14_B17243.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.14 – xhmtl2pdf – dynamic PDF
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to build PDF templates and generate PDF documents, we can
    present data in a very clean and structured way that makes using these a valuable
    reporting tool.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the skills gained after completing the exercises found in this chapter,
    you can now create and send messages, notifications, and reports of various types.
    We now know how to use the Django messages framework to serve up flash messages
    every time a page loads or reloads. We can create and send emails of various content
    types and even use an email test client account to capture those emails, indicating
    that they are actually working. We even installed a package and began building
    our own PDF reports.
  prefs: []
  type: TYPE_NORMAL
- en: Use any combination of these tools to add value to your project. Flash messages,
    email notifications, and report generating concepts all help to keep users informed
    and engaged with your application. Always remember that too much information can
    overwhelm a user, such as having thousands of email notifications flooding their
    inbox. Use them wisely!
  prefs: []
  type: TYPE_NORMAL
- en: The Django messages framework offers a wide range of tools that can create flash
    messages for users. With a little bit of creativity, the Django messages framework
    can be used with **Asynchronous JavaScript and XML** (**AJAX**) to serve up messages
    that act more like a **Single-Page App** (**SPA**). In the next chapter, [*Chapter
    8*](B17243_08_ePub.xhtml#_idTextAnchor239), *Working with the Django REST Framework*,
    we will discuss what the Django REST framework is and how it can be used to work
    with AJAX requests.
  prefs: []
  type: TYPE_NORMAL
