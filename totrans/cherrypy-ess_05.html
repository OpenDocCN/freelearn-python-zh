<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. A Photoblog Application</h1></div></div></div><p>In this chapter, we are going to explain what the next few chapters will put in place to develop a photoblog application. In the first half of this chapter, we will review the goals and features of this application from a high-level perspective without going into too much detail. In the second half, we will define the entities that our application will manipulate and introduce the concept of object-relational mappers, which aim at reducing the impedance mismatch between relational database and object-oriented software design. We will briefly present the most common Python ORMs and then develop our application data access layer based on the Dejavu ORM.<a id="id131" class="indexterm"/>
</p><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec01"/>A Photoblog Application</h1></div></div></div><p>In the previous chapters, we have reviewed CherryPy's design and features in detail but we haven't demonstrated its use in the context of a web application. The next few chapters will undertake this task by going through the development of a photoblog application.<a id="id132" class="indexterm"/>
</p><p>A photoblog is like a regular blog except that the principal content is not text but photographs. The main reason for choosing a photoblog is that the range of features to be implemented is small enough so that we can concentrate on their design and implementation.</p><p>The goals behind going through this application are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>To see how to slice the development of a web application into meaningful layers and therefore show that a web application is not very different from a rich application sitting on your desktop.</p></li><li class="listitem"><p>To show that the separation of concerns can also be applied to the web interface itself by using principles grouped under the name of Ajax.</p></li><li class="listitem"><p>To introduce common Python packages for dealing with common aspects of web development such as database access, HTML templating, JavaScript handling, etc.</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec02"/>Photoblog Entities</h1></div></div></div><p>As mentioned earlier, the photoblog will try to stay as simple as possible in order to focus on the other aspects of developing a web application. In this section, we will briefly describe the entities our photoblog will manipulate as well as their attributes and relations with each other.<a id="id133" class="indexterm"/>
</p><p>In a nutshell our photoblog application will use the following entities and they will be associated as shown in the following figure:</p><div class="mediaobject"><img src="images/1848_05_01.jpg" alt="Photoblog Entities"/></div><p>This figure is not what our application will look like but it shows the entities our application will manipulate. One photoblog will contain several albums, which in turn will host as many films as required, which will carry the photographs.</p><p>In other words, we will design our application with the following entity structure:</p><p>
<span class="strong"><strong>Entity:</strong></span> Photoblog</p><p>
<span class="strong"><strong>Role:</strong></span> This entity will be the root of the application.</p><p>
<span class="strong"><strong>Attributes:</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
<code class="literal">name:</code> A unique identifier for the blog</p></li><li class="listitem"><p>
<code class="literal">title:</code> A public label for the blog</p></li></ul></div><p>
<span class="strong"><strong>Relations:</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>One photoblog will have zero to many albums</p></li></ul></div><p>
<span class="strong"><strong>Entity:</strong></span> Album</p><p>
<span class="strong"><strong>Role:</strong></span> An album carries a story told by the photographs as an envelope.<a id="id134" class="indexterm"/>
</p><p>
<span class="strong"><strong>Attributes:</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
<code class="literal">name:</code> A unique identifier for the album</p></li><li class="listitem"><p>
<code class="literal">title:</code> A public label for the album</p></li><li class="listitem"><p>
<code class="literal">author:</code> The name of the album's author</p></li><li class="listitem"><p>
<code class="literal">description:</code> A simple description of the album used in feeds</p></li><li class="listitem"><p>
<code class="literal">story:</code> A story attached to the album</p></li><li class="listitem"><p>
<code class="literal">created:</code> A timestamp of when the album is being created</p></li><li class="listitem"><p>
<code class="literal">modified:</code> A timestamp of when the album is being modified</p></li><li class="listitem"><p>
<code class="literal">blog_id:</code> A reference to the blog handling the album</p></li></ul></div><p>
<span class="strong"><strong>Relations:</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>One album will reference zero to several films</p></li></ul></div><p>
<span class="strong"><strong>Entity:</strong></span> Film</p><p>
<span class="strong"><strong>Role:</strong></span> A film gathers a set of photographs.</p><p>
<span class="strong"><strong>Attributes:</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
<code class="literal">name:</code> A unique identifier for the film</p></li><li class="listitem"><p>
<code class="literal">title:</code> A public label for the film</p></li><li class="listitem"><p>
<code class="literal">created:</code> A timestamp of when the film is being created</p></li><li class="listitem"><p>
<code class="literal">modified:</code> A timestamp of when the film is being modified</p></li><li class="listitem"><p>
<code class="literal">album_id:</code> A reference to the album</p></li></ul></div><p>
<span class="strong"><strong>Relations:</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A film will reference zero to several photographs</p></li></ul></div><p>
<span class="strong"><strong>Entity:</strong></span> Photo</p><p>
<span class="strong"><strong>Role:</strong></span> The unit of our application is a photograph.</p><p>
<span class="strong"><strong>Attributes:</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
<code class="literal">name:</code> A unique identifier for the photo</p></li><li class="listitem"><p>
<code class="literal">legend:</code> A legend associated with the photograph</p></li><li class="listitem"><p>
<code class="literal">filename:</code> The base name of the photograph on the hard-disk</p></li><li class="listitem"><p>
<code class="literal">filesize:</code> The size in bytes of the photograph</p></li><li class="listitem"><p>
<code class="literal">width:</code> Width of the photograph in pixels</p></li><li class="listitem"><p>
<code class="literal">height:</code> Height of the photograph in pixels</p></li><li class="listitem"><p>
<code class="literal">created:</code> A timestamp of when the photograph is being created</p></li><li class="listitem"><p>
<code class="literal">modified:</code> A timestamp of when the photograph is being modified</p></li><li class="listitem"><p>
<code class="literal">film_id:</code> A reference to the film carrying the photograph</p></li></ul></div><p>
<span class="strong"><strong>Relations:</strong></span> None</p><p>Functionally, the photoblog application will provide APIs to manipulate those entities via the traditional<span class="strong"><strong> CRUD</strong></span> interface:<span class="strong"><strong> Create, Retrieve, Update</strong></span>, and<span class="strong"><strong> Delete</strong></span>. We will elaborate more on this in<a class="link" href="ch06.html" title="Chapter 6. Web Services">Chapter 6</a>.<a id="id135" class="indexterm"/>
</p><p>Now that we have briefly introduced what kind of application we will be developing throughout the following chapters we can move on to the next section and start reviewing our options to handle the database aspect of the application. But first a quick glossary of the terms this chapter will use.</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec03"/>Vocabulary</h1></div></div></div><p>Here is a list of the terms we will be using:<a id="id136" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Persistence: Persistence is the concept of data items outliving the execution of programs manipulating them. Simply put, it is the process of storing data in long lasting memory medium such as a disk.</p></li><li class="listitem"><p>Database: A database is a collection of organized data. There are different organization models: hierarchical, network, relational, object-oriented, etc. A database holds the logical representation of its data.</p></li><li class="listitem"><p>Database Management System (DBMS): A DBMS is a group of related software applications to manipulate data in a database. A DBMS platform should offer the following among other features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Persistence of the data</p></li><li class="listitem"><p>A query language to manipulate data</p></li><li class="listitem"><p>Concurrency control</p></li><li class="listitem"><p>Security control</p></li><li class="listitem"><p>Integrity control</p></li><li class="listitem"><p>Transaction capabilities</p></li></ul></div></li></ul></div><p>We will use <span class="strong"><strong>DBMSes</strong></span> as the plural of DBMS.
</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec04"/>DBMSes Overview<a id="id137" class="indexterm"/>
</h1></div></div></div><p>In this section, we will quickly review the different kinds of existing DBMSes. The goal is to quickly introduce their main characteristics.<a id="id138" class="indexterm"/>
</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec01"/>Relational Database Management System (RDBMS)</h2></div></div></div><p>Of all DBMSes, the RDBMS is the most common, whether it is in small applications or multi-national infrastructure. An RDBMS comes with a database based on the concepts of the relational model, a mathematical model that permits the logical representation of a collection of data through relations. A relational database should be a concrete implementation of the relational model. However, modern relational databases follow the model only to a certain degree.<a id="id139" class="indexterm"/>
</p><p>The following table shows the correlation between the terms of the relational model and the relational database implementation.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col style="text-align: left" class="C1"/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Relational Model</p>
</th><th style="text-align: left" valign="bottom">
<p>Relational Database</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Relation</p>
</td><td style="text-align: left" valign="top">
<p>Table</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Attribute</p>
</td><td style="text-align: left" valign="top">
<p>Column</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Tuple</p>
</td><td style="text-align: left" valign="top">
<p>Row</p>
</td></tr></tbody></table></div><p>Relational databases support a set of types to define the domain of scope a column can use. However, there are only a limited number of supported types, which can be an issue with complex data types as allowed in objected-oriented design.</p><p>
<span class="strong"><strong>Structure Query Language</strong></span> more commonly known as<span class="strong"><strong> SQL</strong></span> is the language used to define, manipulate, or control data within a relational database.<a id="id140" class="indexterm"/>
</p><p>The following table is a quick summary of SQL keywords and their contexts.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col width="1.75069444444444" style="text-align: left" class="C1"/><col width="3.525" style="text-align: left" class="C2"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Context</p>
</th><th style="text-align: left" valign="bottom">
<p>Keywords</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Data manipulation</p>
</td><td style="text-align: left" valign="top">
<p>SELECT, INSERT, UPDATE, DELETE</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Data definition</p>
</td><td style="text-align: left" valign="top">
<p>CREATE, DROP, ALTER</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Data control</p>
</td><td style="text-align: left" valign="top">
<p>GRANT, REVOKE</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Transaction</p>
</td><td style="text-align: left" valign="top">
<p>START, COMMIT, ROLLBACK</p>
</td></tr></tbody></table></div><p>A construction of these keywords is called an SQL statement. When executed, an SQL statement returns a collection of rows of the data matching the query or nothing.</p><p>The relational model algebra uses the relation composition to compose operations across different sets; this is translated in the relational database context by<span class="strong"><strong> joins</strong></span>. Joining tables allows complex queries to be shaped to filter out data.<a id="id141" class="indexterm"/>
</p><p>SQL provides the following three kinds of joins:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col width="1.88795303030303" style="text-align: left" class="C1"/><col width="3.36031085858586" style="text-align: left" class="C2"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Union Type</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>INNER JOIN</p>
</td><td style="text-align: left" valign="top">
<p>Intersection between two tables.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>LEFT OUTER JOIN</p>
</td><td style="text-align: left" valign="top">
<p>Limits the result set by the left table. So all results from the left table will be returned with their matching result in the right table. If no matching result is found, it will return a NULL value.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>RIGHT OUTER JOIN</p>
</td><td style="text-align: left" valign="top">
<p>Same as the LEFT OUTER JOIN except that the tables are reversed.</p>
</td></tr></tbody></table></div><p>There is no RDBMS written in Python but most RDBMSes can be accessed via a corresponding Python library.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec02"/>Object-Oriented Database Management System (OODBMS)</h2></div></div></div><p>An OODBMS uses the object-oriented model to organize and store information. In other words, an OODBMS allows objects to be stored without having to be mapped into a different data structure like the relational database. This implies a great consistency between the database persisting the data and the application layers encapsulating it. In fact, the persistence mechanism is unobtrusive to the developer.<a id="id142" class="indexterm"/>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec03"/>XML Database Management System (XMLDBMS)</h2></div></div></div><p>
<span class="strong"><strong>Native XML Databases</strong></span> (<span class="strong"><strong>NXDs</strong></span>) use XML documents as the unit of data they store and manipulate. XMLDBMSes on top of NXDs are optimized in this sense and provide native support for standard XML selection and querying languages such as XPath and XQuery. Some modern RDBMSes offer XML support through transparent conversion between the XML and relational data model leveraging the introduction of an XML database requirement.<a id="id143" class="indexterm"/>
</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec05"/>Object-Relational Mapping</h1></div></div></div><p>For the last fifteen years the software industry has moved towards a generalized use of the object-oriented modeling paradigm in the different layers of software application development. One of the last bastions that have resisted against this wave has been the database domain. Nonetheless, over the years quite an important amount of work has been conducted with success in order to develop OODBMSes for filling the gap of managing data. In spite of that OODBMSes have not taken off enough to steal RDBMS's thunder.<a id="id144" class="indexterm"/>
</p><p>There are several factors behind this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Cost of changing the market. For decades RDBMSes have been the DBMSes of predilection to store and organize data. Most businesses have built their infrastructure around RDBMSes and changing that state is an immense task and only few are ready to pay for such a risk.</p></li><li class="listitem"><p>Cost of migrating existing data. Even if a company is ready to step into that direction for new projects, it is unlikely it will for the existing infrastructure as the cost of migration and integration would be too high.</p></li><li class="listitem"><p>Lack of unified query language.</p></li><li class="listitem"><p>Lack of third-party software such as reporting tools based on OODBMS.</p></li><li class="listitem"><p>Lack of experts. Finding a database administrator for a RDBMS is much easier than for an ODBMS.</p></li></ul></div><p>
<span class="strong"><strong>Object-Relational Mappers</strong></span> (<span class="strong"><strong>ORMs</strong></span>) succeeded because they were an efficient and cost-effective answer to some of the enumerated issues. The principle behind object-relational mapping is to reduce the impedance mismatch between the two models with minimum intrusion. ORMs allow the database designer and administrator to keep their beloved RDBMSes while proposing an objected-oriented interface to a certain extent to the software developer. ORM is an extra layer between the database and the application which translates an object into a database row and vice versa.<a id="id145" class="indexterm"/>
</p><p>It is important to bear in mind though that ORM can alleviate the problem only to a certain degree and that in some cases the differences between the relational and object design cannot be met without some compromise on both sides. For example, most ORMs correlate a database table into a class, which works fine when the number of entities and their relationships stay at a basic level. Unfortunately, this one-to-one relationship between a table and a class does not always work well in more complex object-oriented design. In such cases the impedance mismatch between the relational and object-oriented models may force designers to make concessions that could have negative impacts in the long run in regards to extending and maintaining the software.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec04"/>Python Object-Relational Mappers</h2></div></div></div><p>This section will introduce three ORMs in a very basic example in order to provide a basic understanding of how they work and their differences. The purpose is not to declare one of these ORMs the winner but to give you an idea of their design and features.<a id="id146" class="indexterm"/>
</p><p>The three ORMs we will cover are:<a id="id147" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>SQLObject from Ian Bicking</p></li><li class="listitem"><p>SQLAlchemy from Michael Bayer</p></li><li class="listitem"><p>Dejavu from Robert Brewer</p></li></ul></div><p>Although great care has been taken in this section, it may happen that by the time you read this chapter these products might have changed a bit. You will have to refer to their official documentation.</p><p>In the following example we will map the following entities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Artist: An artist is made of a name. An artist can have zero or several albums.</p></li><li class="listitem"><p>Album: An album is made of a title and a release year. An album is associated to an artist and can have zero or more songs.</p></li><li class="listitem"><p>Song: A song is made of a name and a position within the album. A song is associated to an album.<a id="id148" class="indexterm"/>
</p></li></ul></div><p>This example should be seen as a stripped down version of our photoblog entity set that we defined at the start of this chapter in order to focus on the actual features of each ORM rather than on the entities themselves.<a id="id149" class="indexterm"/>
</p><p>Step 1:<span class="strong"><strong> Mapping the entities</strong></span>
</p><p>
<span class="strong"><strong>SQLObject</strong></span>
</p><div class="informalexample"><pre class="programlisting">from sqlobject import *
class Song(SQLObject):
title = StringCol()
position = IntCol()
album = ForeignKey('Album', cascade=True)
class Album(SQLObject):
title = StringCol()
release_year = IntCol()
artist = ForeignKey('Artist', cascade=True)
songs = MultipleJoin('Song', orderBy="position")
class Artist(SQLObject):
# Using alternateID will automatically
# create a byName() method
name = StringCol(alternateID=True, unique=True)
albums = MultipleJoin('Album')
</pre></div><p>The first point to note is that SQLObject does not require a separate declaration of the mapping that is done within the class itself. Each class must inherit from the unobtrusive<code class="literal"> SQLObject</code> class to be manageable by SQLObject and the attributes will be mapped transparently by SQLObject into the table's columns. SQLObject automatically adds an attribute<code class="literal"> id</code> to hold the unique identifier of each object. This means that every table mapped by SQLObject must have a primary key.</p><p>
<code class="literal">ForeignKey</code> or<code class="literal"> MultipleJoin</code> are examples of how to define the relationships between entities. Note that they need the name of the class as a string and not the class object itself. This allows the declaration of relationships without the prior existence of each class within the scope of the module. In other words<code class="literal"> Artist</code> and<code class="literal"> Album</code> could be declared in two different modules without the problem of cross imports.</p><p>SQLObject offers a useful feature when specifying<code class="literal"> alternateID</code> as a parameter in one of the class attributes. By using it, SQLObject adds a new method to the class of the form<code class="literal"> byAttributeName</code> as shown in the example above. Note also how you can specify at that level the way rows must be ordered when being retrieved.</p><p>Finally bear in mind that by default SQLObject auto-commits to the database each modification made to an attribute, which can increase the network overhead as well as break the database integrity if an error occurs. To work around this behavior SQLObject offers the<code class="literal"> set</code> method on an SQLObject object that performs one single<code class="literal"> UPDATE</code> query for all the modifications limiting the required bandwidth. Moreover, SQLObject supports the concept of transactions, allowing us to ensure that operations are atomic to the database and can then be rolled back if an error occurs. Note that the transactions have to be explicitly requested by the developer.<a id="id150" class="indexterm"/>
</p><p>
<span class="strong"><strong>SQLAlchemy</strong></span>
</p><div class="informalexample"><pre class="programlisting">from sqlalchemy import *
artist_table = Table('Artist', metadata,
Column('id', Integer, primary_key=True),
Column('name', String(), unique=True))
song_table = Table('Song', metadata,
Column('id', Integer, primary_key=True),
Column('title', String()),
Column('position', Integer),
Column('album_id', Integer,
ForeignKey('Album.id')))
album_table = Table('Album', metadata,
Column('id', Integer, primary_key=True),
Column('title', String()),
Column('release_year', Integer),
Column('artist_id', Integer,
ForeignKey('Artist.id')))
class Artist(object):
def __init__(self, name):
self.id = None
self.name = name
class Album(object):
def __init__(self, title, release_year=0):
self.id = None
self.title = title
self.release_year = release_year
class Song(object):
def __init__(self, title, position=0):
self.id = None
self.title = title
self.position = position
song_mapper = mapper(Song, song_table)
album_mapper = mapper(Album, album_table,
properties = {'songs': relation(song_mapper,
cascade="all, delete-orphan")
})
artist_mapper = mapper(Artist, artist_table,
properties = {'albums': relation(album_mapper,
cascade="all, delete-orphan")
})
</pre></div><p>SQLAlchemy uses a declarative mapping style as you can see. The first step is to express tables into their Python syntax counterpart. Then we need to declare the class our application will manipulate. Note how they don't need to inherit from an<code class="literal"> SQLAlchemy</code> class even though they must inherit from the built-in Python object class. Eventually, we map both aspects through the<code class="literal"> mapper</code> function, which also allows us to inform SQLAlchemy of the relationships between entities.<a id="id151" class="indexterm"/>
</p><p>You will notice how the identifier of each table is explicitly declared unlike SQLObject and Dejavu. Similarly you do not specify at that level how fetched rows must be ordered as this will be specified at the query level.</p><p>
<span class="strong"><strong>Dejavu</strong></span>
</p><div class="informalexample"><pre class="programlisting">from dejavu import Unit, UnitProperty
class Song(Unit):
title = UnitProperty(unicode)
position = UnitProperty(int)
album_id = UnitProperty(int, index=True)
class Album(Unit):
title = UnitProperty(unicode)
release_year = UnitProperty(int)
artist_id = UnitProperty(int, index=True)
def songs(self):
return self.Song()
songs = property(songs)
def artist(self):
return self.Artist()
artist = property(artist)
def on_forget(self):
for song in self.Song():
song.forget()
class Artist(Unit):
name = UnitProperty(unicode)
def albums(self):
return self.Album()
albums = property(albums)
def on_forget(self):
for album in self.Album():
album.forget()
Album.one_to_many('ID', Song, 'album_id')
Artist.one_to_many('ID', Album, 'artist_id')
</pre></div><p>Like SQLObject, Dejavu does lots of work under the hood. Each class participating in the mapping must inherit from<code class="literal"> Unit</code>. The attributes of the class represent the columns of the table. Only the relationship between the entities is done through a more declarative interface.</p><p>One difference between Dejavu and the other two is that it does not provide the cascade delete feature. This means that this has to be accomplished from the class itself by defining an<code class="literal"> on_forget()</code> method and specifying what tasks should be done when deleting a unit. This might look at first sight like a drawback but offers, in fact, a fine granularity on how you propagate a cascade delete.</p><p>Step 2:<span class="strong"><strong> Setting up the access to the database</strong></span>
</p><p>
<span class="strong"><strong>SQLObject</strong></span>
<a id="id152" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"># Create a connection to a SQLlite 'in memory' database
sqlhub.processConnection =
connectionForURI('sqlite:/:memory:?debug=True')
</pre></div><p>
<span class="strong"><strong>SQLAlchemy</strong></span>
</p><div class="informalexample"><pre class="programlisting"># Inform SQLAlchemy of the database we will use
# A SQLlite 'in memory' database
# Mapped into an engine object and bound to a high
# level meta data interface
engine = create_engine('sqlite:///:memory:', echo=True)
metadata = BoundMetaData(engine)
</pre></div><p>
<span class="strong"><strong>Dejavu</strong></span>
</p><div class="informalexample"><pre class="programlisting"># Create the global arena object
arena = dejavu.Arena()
arena.logflags = dejavu.logflags.SQL + dejavu.logflags.IO
# Add a storage to the main arena object
conf = {'Database': ":memory:"}
arena.add_store("main","sqlite", conf)
# Register units the arena will be allowed to handle
# This call must happen after the declaration of the units
# and those must be part of the current namespace
arena.register_all(globals())
</pre></div><p>Step 3:<span class="strong"><strong> Manipulating tables</strong></span>
<a id="id153" class="indexterm"/>
</p><p>
<span class="strong"><strong>SQLObject</strong></span>
</p><div class="informalexample"><pre class="programlisting">def create_tables():
Album.createTable()
Song.createTable()
Artist.createTable()
def drop_tables():
Song.dropTable()
Artist.dropTable()
Album.dropTable()
</pre></div><p>
<span class="strong"><strong>SQLAlchemy</strong></span>
</p><div class="informalexample"><pre class="programlisting">def create_tables():
artist_table.create(checkfirst=True)
album_table.create(checkfirst=True)
song_table.create(checkfirst=True)
def drop_tables():
artist_table.drop(checkfirst=False)
song_table.drop(checkfirst=False)
album_table.drop(checkfirst=False)
</pre></div><p>
<span class="strong"><strong>Dejavu</strong></span>
</p><div class="informalexample"><pre class="programlisting">def create_tables():
arena.create_storage(Song)
arena.create_storage(Album)
arena.create_storage(Artist)
def drop_tables():
arena.drop_storage(Song)
arena.drop_storage(Album)
arena.drop_storage(Artist)
</pre></div><p>Step 4:<span class="strong"><strong> Loading data</strong></span>
<a id="id154" class="indexterm"/>
</p><p>
<span class="strong"><strong>SQLObject</strong></span>
</p><div class="informalexample"><pre class="programlisting"># Create an artist
jeff_buckley = Artist(name="Jeff Buckley")
# Create an album for that artist
grace = Album(title="Grace", artist=jeff_buckley, release_year=1994)
# Add songs to that album
dream_brother = Song(title="Dream Brother", position=10, album=grace)
mojo_pin = Song(title="Mojo Pin", position=1, album=grace)
lilac_wine = Song(title="Lilac Wine", position=4, album=grace)
</pre></div><p>
<span class="strong"><strong>SQLAlchemy</strong></span>
</p><div class="informalexample"><pre class="programlisting">session = create_session(bind_to=engine)
jeff_buckley = Artist(name="Jeff Buckley")
grace = Album(title="Grace", release_year=1994)
dream_brother = Song(title="Dream Brother", position=10)
mojo_pin = Song(title="Mojo Pin", position=1)
lilac_wine = Song(title="Lilac Wine", position=4)
grace.songs.append(dream_brother)
grace.songs.append(mojo_pin)
grace.songs.append(lilac_wine)
jeff_buckley.albums.append(grace)
session.save(jeff_buckley)
session.flush()
</pre></div><p>Note the fact that each object is created independently from the other and their relationship is fulfilled in a second step, e.g. the<code class="literal"> append()</code> method on the<code class="literal"> grace.songs</code> object.</p><p>In the same declarative spirit as above SQLAlchemy does not commit automatically by default to the database. Instead it delays the operation until you<code class="literal"> flush</code> the current session of work.</p><p>
<span class="strong"><strong>Dejavu</strong></span>
</p><div class="informalexample"><pre class="programlisting">sandbox = arena.new_sandbox()
# Create an artist unit
jeff_buckley = Artist(name="Jeff Buckley")
sandbox.memorize(jeff_buckley)
grace = Album(title="Grace", release_year=1994)
sandbox.memorize(grace)
# Add the album unit to the artist unit
jeff_buckley.add(grace)
dream_brother = Song(title="Dream Brother", position=10)
sandbox.memorize(dream_brother)
mojo_pin = Song(title="Mojo Pin", position=1)
sandbox.memorize(mojo_pin)
lilac_wine = Song(title="Lilac Wine", position=4)
sandbox.memorize(lilac_wine)
# Add each song unit to the album unit
grace.add(dream_brother)
grace.add(mojo_pin)
grace.add(lilac_wine)
sandbox.flush_all()
</pre></div><p>Dejavu provides the concept of sandboxes in which you can isolate the entities you manipulate. Also note that newly created units do not exist for their relatives until you call the<code class="literal"> sandbox.memorize()</code> method, which puts the unit into the sandbox.</p><p>Like SQLAlchemy, Dejavu delays the commit operation until you explicitly call the<code class="literal"> sandbox.flush_all()</code> method.</p><p>Step 5:<span class="strong"><strong> Manipulating data</strong></span>
<a id="id155" class="indexterm"/>
</p><p>First we define a function that will take an artist and display the albums' songs.</p><div class="informalexample"><pre class="programlisting">def display_info(artist):
for album in artist.albums:
message = """
%s released %s in %d
It contains the following songs:\n""" % (artist.name,
album.title,
album.release_year)
for song in album.songs:
message = message + " %s\n" % (song.title, )
print message
</pre></div><p>
<span class="strong"><strong>SQLObject</strong></span>
</p><div class="informalexample"><pre class="programlisting"># Retrieve an artist by his name
buckley = Artist.byName('Jeff Buckley')
display_info(buckley)
# Retrieve songs containing the word 'la' from the given artist
# The AND() function is provided by the SQLObject namespace
songs = Song.select(AND(Artist.q.name=="Jeff Buckley",
Song.q.title.contains("la")))
for song in songs:
print " %s" % (song.title,)
# Retrieve all songs but only display some of them
songs = Song.select()
print "Found %d songs, let's show only a few of them:" %
(songs.count(), )
for song in songs[1:-1]:
print " %s" % (song.title,)
# Retrieve an album by its ID
album = Album.get(1)
print album.title
# Delete the album and all its dependencies
# since we have specified cascade delete
album.destroySelf()
</pre></div><p>
<span class="strong"><strong>SQLAlchemy</strong></span>
</p><div class="informalexample"><pre class="programlisting">session = create_session(bind_to=engine)
# Retrieve an artist by his name
buckley = session.query(Artist).get_by(name='Jeff Buckley')
display_info(buckley)
# Retrieve songs containing the word 'la' from the given artist
songs = session.query(Song).select(and_(artist_table.c.name=="Jeff
Buckley",
song_table.c.title.like
("%la%")))
for song in songs:
print " %s" % (song.title,)
# Retrieve all songs but only display some of them
# Note that we specify the order by clause at this level
songs = session.query(Song).select(order_by=[Song.c.position])
print "Found %d songs, let's show only a few of them:" % (len(songs),)
for song in songs[1:-1]:
print " %s" % (song.title,)
# Retrieve an album by its ID
album = session.query(Album).get_by(id=1)
print album.title
# Delete the album and all its dependencies
# since we have specified cascade delete
session.delete(album)
session.flush()
</pre></div><p>
<span class="strong"><strong>Dejavu</strong></span>
</p><div class="informalexample"><pre class="programlisting">sandbox = arena.new_sandbox()
# Retrieve an artist by his name
buckley = sandbox.Artist(name="Jeff Buckley")
display_info(buckley)
# Retrieve songs containing the word 'la' from the given artist
# We will explain in more details the concepts of Expressions
f = lambda ar, al, s: ar.name == "Jeff Buckley" and "la" in s.title
# Note how we express the composition between the units
results = sandbox.recall(Artist &amp; Album &amp; Song, f)
for artist, album, song in results:
print " %s" % (song.title,)
# Retrieve all songs but only display some of them
songs = sandbox.recall(Song)
print "Found %d songs, let's show only a few of them:" % (len(songs),)
for song in songs[1:-1]:
print " %s" % (song.title,)
# Retrieve an album by its ID
album = sandbox.Album(ID=1)
print album.title
</pre></div><p>Choosing an object-relational mapper is a difficult task as it is usually after using one for a while that you can really measure the impact it has on the development design and process. As previously stated, it is critical to acknowledge that ORMs do not remove the impedance mismatch between the relational and object-oriented model.</p><p>SQLObject has a low-learning curve and quite a big community, which makes it suitable for developers debuting in the use of ORM. The project is aiming at its next version, which will fix a fair number of bad design decisions made in its early life while slowly abandoning the current version.</p><p>SQLAlchemy has based its design on the Hibernate ORM from the Java world and has thus avoided lots of pitfalls that SQLObject has not. Its declarative syntax will not please every pythoner but its flexibility and good documentation have placed SQLAlchemy as a very serious candidate in the field.</p><p>Dejavu is a fairly unknown ORM and thus has a small community. It is well documented and comes with relevant example cases. Its strength resides in its capacity to move away from the underlying relational database layer by providing a very high-level interface using common Python idioms.<a id="id156" class="indexterm"/>
</p><p>For instance, SQLObject and SQLAlchemy do use terms such as<code class="literal"> table, column</code>, or<code class="literal"> select</code> while Dejavu refers to<code class="literal"> storage</code> and<code class="literal"> unit</code> providing a better abstraction to the underlying mechanisms.</p><p>This is also true when it comes to the process of building queries. Unlike SQLObject and SQLAlchemy, which stay very close to SQL by providing a Python interface to SQL statements, Dejavu provides an interface independent of SQL. Review the section on manipulating data for an example.</p><p>These are the reasons why our photoblog application will use Dejavu instead of SQLObject or SQLAlchemy. However, keep in mind that they are all good and powerful ORMs.</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec06"/>Photoblog Application Entity Modeling</h1></div></div></div><p>First we define what we will call a<code class="literal"> storage</code> module providing a simple interface to some common operations like the connection to the database.<a id="id157" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">import dejavu
arena = dejavu.Arena()
from model import Photoblog, Album, Film, Photo
def connect():
conf = {'Connect': "host=localhost dbname=photoblog user=test
password=test"}
arena.add_store("main", "postgres", conf)
arena.register_all(globals())
</pre></div><p>In this case, we import the<code class="literal"> dejavu</code> module and we create one global instance of the<code class="literal"> Arena</code> class. The<code class="literal"> arena</code> will be our interface between the underlying storage manager and the business logic layer.</p><p>The<code class="literal"> connect</code> function adds a storage manager to the<code class="literal"> arena</code> object for a PostgreSQL RDBMS and then registers all imported entities so that the<code class="literal"> arena</code> object knows what entities it will manage. (Please refer to the Dejavu documentation for a list of supported database managers and how to declare them within the<code class="literal"> add_store()</code> method.) Once we have this module we can start mapping entities.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec05"/>Mapping Entities</h2></div></div></div><p>Mapping the entities is done through the following process:<a id="id158" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Creating a class that inherits from<code class="literal"> Unit</code>
</p></li><li class="listitem"><p>Adding attributes using the<code class="literal"> UnitProperty</code> class</p></li><li class="listitem"><p>Setting up the relationship between units</p></li></ul></div><p>
<span class="strong"><strong>Entity:</strong></span> Photoblog</p><div class="informalexample"><pre class="programlisting">from dejavu import Unit, UnitProperty
from engine.database import arena
from album import Album
class Photoblog(Unit):
name = UnitProperty(unicode)
title = UnitProperty(unicode)
def on_forget(self):
for album in self.Album():
album.forget()
Photoblog.one_to_many('ID', Album, 'blog_id')
</pre></div><p>
<span class="strong"><strong>Entity:</strong></span> Album</p><div class="informalexample"><pre class="programlisting">import datetime
from dejavu import Unit, UnitProperty
from engine.database import arena
from film import Film
class Album(Unit):
name = UnitProperty(unicode)
title = UnitProperty(unicode)
author = UnitProperty(unicode)
description = UnitProperty(unicode)
content = UnitProperty(unicode, hints={u'bytes': 0})
created = UnitProperty(datetime.datetime)
modified = UnitProperty(datetime.datetime)
blog_id = UnitProperty(int, index=True)
def on_forget(self):
for film in self.Film():
film.forget()
Album.one_to_many('ID', Film, 'album_id')
</pre></div><p>
<span class="strong"><strong>Entity:</strong></span> Film</p><div class="informalexample"><pre class="programlisting">import datetime
from dejavu import Unit, UnitProperty
from engine.database import arena
from photo import Photo
class Film(Unit):
name = UnitProperty(unicode)
title = UnitProperty(unicode)
created = UnitProperty(datetime.datetime)
modified = UnitProperty(datetime.datetime)
album_id = UnitProperty(int, index=True)
def on_forget(self):
for photo in self.Photo():
photo.forget()
Film.one_to_many('ID', Photo, 'film_id')
</pre></div><p>
<span class="strong"><strong>Entity:</strong></span> Photo</p><div class="informalexample"><pre class="programlisting">import datetime
from dejavu import Unit, UnitProperty
from engine.database import arena
class Photo(Unit):
name = UnitProperty(unicode)
legend = UnitProperty(unicode)
filename = UnitProperty(unicode)
filesize = UnitProperty(int)
width = UnitProperty(int)
height = UnitProperty(int)
created = UnitProperty(datetime.datetime)
modified = UnitProperty(datetime.datetime)
film_id = UnitProperty(int, index=True)
</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec06"/>Units and UnitProperties</h2></div></div></div><p>In the previous section, we mapped our entities into units that Dejavu will manage. All our classes inherit from the<code class="literal"> Unit</code> base class. This class does not provide much apart from automatically adding an<code class="literal"> ID</code> property to the class, which is the reason why we do not explicitly provide one in any of our units. Nonetheless by inheriting from the<code class="literal"> Unit</code> class you allow Dejavu to register and handle your class.<a id="id159" class="indexterm"/>
</p><p>The next step is obviously to add properties to your classes via the<code class="literal"> UnitProperty</code> class, which has the following signature:</p><div class="informalexample"><pre class="programlisting">UnitProperty(type=unicode, index=False,
hints=None, key=None, default=None)
</pre></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The<code class="literal"> type</code> parameter is a Python type. Dejavu takes care of translating it into the appropriate SQL equivalent type transparently.</p></li><li class="listitem"><p>The<code class="literal"> index</code> parameter indicates whether the column should be indexed by the RDBMS if it supports it.</p></li><li class="listitem"><p>The<code class="literal"> hints</code> parameter is a dictionary to help Dejavu storage managers to optimize the creation of the column. Dejavu has three built-in hints but you can provide yours if you create your own storage manager:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
<code class="literal">bytes:</code> Indicates the number of bytes to be used for a unicode property, 0 meaning unlimited.</p></li><li class="listitem"><p>
<code class="literal">scale:</code> Number of digits to the right of the decimal point in a numeric column.</p></li><li class="listitem"><p>
<code class="literal">precision:</code> Total number of digits in a numeric column.</p></li></ul></div></li><li class="listitem"><p>The<code class="literal"> key</code> parameter is the property canonical name.</p></li><li class="listitem"><p>The<code class="literal"> default</code> parameter indicates the default value to be used.<a id="id160" class="indexterm"/>
</p></li></ul></div><p>Properties will map into the columns of a table in the relational database.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec07"/>Associating Units</h2></div></div></div><p>Associating units is the means of giving a shape to your design. Entities are bricks, relations are the mortar.<a id="id161" class="indexterm"/>
</p><p>Dejavu supports the following common relationships:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>One to one (1, 1)</p></li><li class="listitem"><p>One to many (1, n)</p></li><li class="listitem"><p>Many to one (n, 1)</p></li></ul></div><p>In each case you provide the signature as follows:</p><div class="informalexample"><pre class="programlisting">nearClass(nearKey, farClass, farKey)
</pre></div><p>Therefore the relation between<code class="literal"> Film</code> and<code class="literal"> Photo</code> is:</p><div class="informalexample"><pre class="programlisting">Film.one_to_many('ID', Photo, 'film_id')
</pre></div><p>The<code class="literal"> nearClass</code> is<code class="literal"> Film</code>, the<code class="literal"> nearKey</code> is<code class="literal"> ID</code> (property of the<code class="literal"> nearClass</code>), the<code class="literal"> farClass</code> is<code class="literal"> Photo</code>, and the<code class="literal"> farKey</code> is<code class="literal"> film_id</code> (property of the<code class="literal"> farClass</code>).</p><p>Dejavu does not provide a native many-to-many relationship but this is achievable through a third unit class and a one-to-one relationship.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec08"/>The Sandbox Interface</h2></div></div></div><p>The<code class="literal"> sandbox</code> object manages memory dedicated to units in a protected way. A<code class="literal"> sandbox</code> is where units spend their life. There are two ways to create<code class="literal"> sandboxes:</code>
<a id="id162" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">box = arena.create_sandbox()
box = dejavu.Sandbox(arena)
</pre></div><p>The former version is the most common and is the one we will use throughout this book.</p><p>Let's review a few key methods of the<code class="literal"> sandbox</code> interface:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
<code class="literal">memorize:</code> When you create a new instance of a unit, it exists only in memory and is separated from the storage manager. You need to call the<code class="literal"> memorize</code> method to make it part of the<code class="literal"> sandbox</code>. This will also set the<code class="literal"> ID</code> of the unit. Additionally this will reserve a place in the underlying database by issuing an<code class="literal"> INSERT INTO SQL</code> statement.</p></li><li class="listitem"><p>
<code class="literal">forget:</code> In order to tell the store manager to stop managing a unit you must call the<code class="literal"> forget</code> method. This will delete it from the<code class="literal"> sandbox</code> and from the storage manager.</p></li><li class="listitem"><p>
<code class="literal">repress:</code> In some cases you may wish to clear the unit from the<code class="literal"> sandbox</code> but not from the store manager. In such cases you should use the<code class="literal"> repress</code> method.</p></li><li class="listitem"><p>
<code class="literal">recall, xrecall:</code> These two methods allow you to retrieve units based on filters (as we will explain in the section<span class="emphasis"><em> Querying Units)</em></span>. The difference between<code class="literal"> recall</code> and<code class="literal"> xrecall</code> is that the latter yields results in an iterating fashion whereas the former loads everything into a list at once.</p></li><li class="listitem"><p>
<code class="literal">unit:</code> Both the previous methods are powerful ones to retrieve a set of data but they can be heavy when you simply look for one unit based on a value of its properties. This is what the<code class="literal"> unit</code> method provides.</p></li><li class="listitem"><p>
<code class="literal">flush_all:</code> Once you have manipulated your units you have to call<code class="literal"> flush_all</code> in order to make those changes to the physical back end.<a id="id163" class="indexterm"/>
</p></li></ul></div><p>As you can see, the interface provided by the<code class="literal"> Sandbox</code> class is quite simple, straightforward, and yet powerful as the next section will demonstrate.</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec07"/>Querying Units</h1></div></div></div><p>We have seen so far how to map our entities into units as well as how to manipulate those units. This section will explain in detail how to query the storage manager for units based on criteria.<a id="id164" class="indexterm"/>
</p><p>Within Dejavu querying is done through an<code class="literal"> Expression</code> instance. The<code class="literal"> Expression</code> class is a filter for units. Let's take an example to explain how this works.</p><div class="informalexample"><pre class="programlisting"># Search for all photographs with a width superior to 300 pixels
f = lambda x: x.width &gt; 300
box.recall(Photo, f)
</pre></div><p>The first step is to create a function that returns a<code class="literal"> bool</code>. That function is usually a<code class="literal"> lambda</code> as there is no need to pollute the Python namespace with meaningless names. Then we pass it to one of the<code class="literal"> sandbox</code> methods such as<code class="literal"> recall</code> or<code class="literal"> xrecall</code>, which will create a<code class="literal"> logic.Expression</code> instance and apply it.</p><p>Expressions show their value when filtering against complex queries such as the one involving JOIN. For example, if you want to join between units you would use Python operators between the units themselves.</p><div class="informalexample"><pre class="programlisting"># Search for all photographs of width superior to 300 pixels
# within albums created by Sylvain
box.recall(Album &amp; Photo, lambda a,
p: a.author == "Sylvain" and p.width &gt; 300)
</pre></div><p>As you can see, the first parameter of the method takes an aggregation of the unit classes that will take part in the join. Dejavu gives you the opportunity of using Python operators to declare aggregation between units.<a id="id165" class="indexterm"/>
</p><p>When composing between units, the order is important while constructing the<code class="literal"> filter</code> function. In the previous example the<code class="literal"> lambda</code> function parameters will match the order of the composed units. This behavior is mirrored by the result returned by the<code class="literal"> recall()</code> method, which will provide a list of<code class="literal"> Album</code> and<code class="literal"> Photo</code> items.</p><p>Below are the Dejavu representations of SQL JOINs.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col width="0.823611111111111" style="text-align: left" class="C1"/><col width="0.739583333333333" style="text-align: left" class="C2"/><col width="3.7125" style="text-align: left" class="C3"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Join Type</p>
</th><th style="text-align: left" valign="bottom">
<p>Operator</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Inner</p>
</td><td style="text-align: left" valign="top">
<p>&amp; or +</p>
</td><td style="text-align: left" valign="top">
<p>All related pairs of both classes will be returned.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Left Outer</p>
</td><td style="text-align: left" valign="top">
<p>&lt;&lt;</p>
</td><td style="text-align: left" valign="top">
<p>All related pairs of both classes will be returned. In addition, if any Unit in class1 has no match in class2, we return a single row with Unit1 and a<span class="strong"><strong> null Unit</strong></span> (a Unit, all of whose properties are None).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Right Outer</p>
</td><td style="text-align: left" valign="top">
<p>&gt;&gt;</p>
</td><td style="text-align: left" valign="top">
<p>All related pairs of both classes will be returned. In addition, if any Unit in class2 has no match in class1, we return a single row with a null Unit (a Unit, all of whose properties are None) and Unit2.</p>
</td></tr></tbody></table></div><p>There is no limitation from Dejavu regarding the aggregation you build. For instance you can write:</p><div class="informalexample"><pre class="programlisting">(Film &lt;&lt; Album) &amp; Photo
</pre></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec08"/>Extending the Data Access Layer</h1></div></div></div><p>In the previous sections, we have defined the mapping between our entities and the classes our application will manipulate. As they stand these classes are not very useful; in this section we will see how to extend them to provide more functionalities. To keep this section concise, we will only discuss the<code class="literal"> Album</code> class.<a id="id166" class="indexterm"/>
</p><p>Methods to be added to the Album class:</p><div class="informalexample"><pre class="programlisting">def films(self):
"""Returns all the attached films
album = Album()
...
for film in album.films:
...
"""
return self.Film()
films = property(films)
def get_all(cls):
"""Returns all the existing albums
for album in Album.albums:
...
"""
sandbox = arena.new_sandbox()
return sandbox.recall(Album)
albums = classmethod(get_all)
def fetch(cls, id):
"""Fetch one album by id"""
sandbox = arena.new_sandbox()
return sandbox.unit(Album, ID=int(id))
fetch = classmethod(fetch)
def fetch_range(cls, start, end):
"""Fetch a range of albums which ID falls into the
specified range.
# This could return up to 5 albums
albums = Album.fetch_range(4, 9)
for album in albums:
...
"""
sandbox = arena.new_sandbox()
# dejavu's views change the capacity of dejavu to
# perform operations on a Unit
# here we create a view of the Album unit so that only
# the created and ID properties appear in the
# result of the view. A view yields values
# not units unlike recall or xrecall.
v = list(sandbox.view(Album, ['created', 'ID']))
v.sort()
photoblogdata access layer, extendingsize = len(v)
if end &gt; size and start &gt;= size:
return None
elif end &gt; size and start &lt; size:
end = size
# row[0] is the 'created' property value
# row[1] is the 'ID' property value
targets = [row[1] for row in v[start:end]]
return sandbox.recall(Album, lambda x: x.ID in targets)
fetch_range = classmethod(fetch_range)
def create(self, photoblog, name, title, slug, author, description,
content):
"""Instanciates the Album,
adds it to the passed photoblog and
persists the changes into the database"""
sandbox = photoblog.sandbox
self.name = name
self.title = title
self.author = author
self.description = description
self.content = content
self.created = datetime.datetime.now().replace(microsecond=0)
self.modified = album.created
self.blog_id = photoblog.ID
sandbox.memorize(self)
photoblog.add(self)
sandbox.flush_all()
def update(self, name, title, slug, author, description, content):
"""Updates the attributes of an album and
persists the changes into the storage"""
self.title = title
self.slug = slug
self.author = author
self.description = description
self.content = content
self.modified = datetime.datetime.now().replace(microsecond=0)
self.sandbox.flush_all()
def delete(self):
"""Delete the album from the storage"""
self.sandbox.forget(album)
def to_dict(self):
"""Return an album as a Python dictionary"""
return {'id': self.ID,
'uuid': self.uuid,
'title': self.title,
'author': self.author,
'description': self.description,
'content': self.content,
'created': self.created.strftime("%d %b. %Y, %H:%M"),
'modified': self.modified.strftime("%d %b. %Y, %H:%M")}
def to_json(self):
"""JSONify an album properties"""
return simplejson.dumps(self.to_dict())
</pre></div><p>As you can see, the<code class="literal"> Album</code> class now contains enough methods to allow manipulation of<code class="literal"> Album</code> instances. The other photoblog entities share the same idea and will provide similar interfaces.</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec09"/>Summary</h1></div></div></div><p>This chapter has introduced the backbone of our photoblog application through the description of its entities and how they are mapped in their Python counterparts. Our next chapter will review how to manipulate those entities from our CherryPy handlers to build the external interface of our application.</p></div></div></div>
</body></html>