<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Best Practices</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will explore the different <em>best practices</em> that can help us to build our GUI efficiently and keep it both <em>maintainable</em> and <em>extendable</em>.</p>
<p>These best practices will also help you to debug your GUI to get it just the way you want it to be.</p>
<p>Here is the overview of Python modules for this chapter:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="Images/eb40adb7-139a-4b41-a0f4-1610ddbeee5c.png" style="width:20.08em;height:23.25em;" width="375" height="433"/></div>
<p>Knowing how to code using best practices will greatly enhance your Python programming skills.</p>
<p>The recipes that will be discussed in this chapter are the following:</p>
<p class="mce-root"/>
<ul>
<li style="list-style-type: none">
<ul>
<li>Avoiding spaghetti code</li>
<li>Using __init__ to connect modules</li>
<li>Mixing fall-down and OOP coding</li>
<li>Using a code naming convention</li>
<li>When not to use OOP</li>
<li>How to use design patterns successfully</li>
<li>Avoiding complexity</li>
<li>GUI design using multiple notebooks</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Avoiding spaghetti code</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will explore a typical way to create spaghetti code and then we will see a much better way of how to avoid such code.</p>
<div class="packt_infobox">Spaghetti code is code in which a lot of functionality is intertangled.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will create a new, simple GUI, written in Python using the built-in Python <kbd>tkinkter</kbd> library.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>Having searched online and read the documentation, we might start by writing the following code to create our GUI:</p>
<ol>
<li>Create a new module: <kbd>GUI_Spaghetti.py</kbd><span>.</span></li>
<li>Add the following code:</li>
</ol>
<pre style="padding-left: 60px"># Spaghetti Code ############################# <br/>def PRINTME(me):print(me) <br/>import tkinter  <br/>x=y=z=1 <br/>PRINTME(z)  <br/>from tkinter import * <br/>scrolW=30;scrolH=6 <br/>win=tkinter.Tk() <br/>if x:chVarUn=tkinter.IntVar() <br/>from tkinter import ttk <br/>WE='WE' <br/>import tkinter.scrolledtext <br/>outputFrame=tkinter.ttk.LabelFrame(win,text=' Type into the scrolled text control: ') <br/>scr=tkinter.scrolledtext.ScrolledText(outputFrame,width=scrolW,height=scrolH,wrap=tkinter.WORD) <br/>e='E' <br/>scr.grid(column=1,row=1,sticky=WE) <br/>outputFrame.grid(column=0,row=2,sticky=e,padx=8) <br/>lFrame=None <br/>if y:chck2=tkinter.Checkbutton(lFrame,text="Enabled",variable=chVarUn) <br/>wE='WE' <br/>if y==x:PRINTME(x)  <br/>lFrame=tkinter.ttk.LabelFrame(win,text="Spaghetti") <br/>chck2.grid(column=1,row=4,sticky=tkinter.W,columnspan=3)   <br/>PRINTME(z) <br/>lFrame.grid(column=0,row=0,sticky=wE,padx=10,pady=10)  <br/>chck2.select() <br/>try: win.mainloop() <br/>except:PRINTME(x) <br/>chck2.deselect() <br/>if y==x:PRINTME(x)  <br/># End Pasta #############################</pre>
<ol start="3">
<li>Run the code and observe the output, as follows:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/8210fa3a-659d-485f-b811-b38085f5f028.png" style="width:27.33em;height:15.08em;" width="350" height="193"/><br/></div>
<ol start="4">
<li>Compare the preceding GUI to the intended GUI design, as follows:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/c9648873-cc9e-48b8-94cc-1527bfde7313.png" style="width:21.00em;height:16.08em;" width="279" height="212"/></div>
<ol start="5">
<li>Create a new module, <kbd>GUI_NOT_Spaghetti.py</kbd>, and add the following code:</li>
</ol>
<pre style="padding-left: 60px">#====================== <br/># imports <br/>#====================== <br/>import tkinter as tk <br/>from tkinter import ttk <br/>from tkinter import scrolledtext <br/>#====================== <br/># Create instance <br/>#====================== <br/>win = tk.Tk()    <br/>#====================== <br/># Add a title        <br/>#======================  <br/>win.title("Python GUI") <br/>#========================= <br/># Disable resizing the GUI <br/>#========================= <br/>win.resizable(0,0) <br/><br/></pre>
<ol start="6">
<li>Next, add some controls:</li>
</ol>
<pre style="padding-left: 60px">#============================================================= <br/># Adding a LabelFrame, Textbox (Entry) and Combobox   <br/>#============================================================= <br/>lFrame = ttk.LabelFrame(win, text="Python GUI Programming Cookbook") <br/>lFrame.grid(column=0, row=0, sticky='WE', padx=10, pady=10) <br/>#============================================================= <br/># Using a scrolled Text control     <br/>#============================================================= <br/>outputFrame = ttk.LabelFrame(win, text=' Type into the scrolled text <br/>control: ') <br/>outputFrame.grid(column=0, row=2, sticky='E', padx=8) <br/>scrolW = 30 <br/>scrolH =  6 <br/>scr = scrolledtext.ScrolledText(outputFrame, width=scrolW, <br/>height=scrolH, wrap=tk.WORD) <br/>scr.grid(column=1, row=0, sticky='WE') </pre>
<ol start="7">
<li>Add some more widgets:</li>
</ol>
<pre style="padding-left: 60px">#============================================================= <br/># Creating a checkbutton <br/>#============================================================= <br/>chVarUn = tk.IntVar() <br/>check2 = tk.Checkbutton(lFrame, text="Enabled", variable=chVarUn) <br/>check2.deselect() <br/>check2.grid(column=1, row=4, sticky=tk.W, columnspan=3)  <br/>#====================== <br/># Start GUI <br/>#====================== <br/>win.mainloop()</pre>
<ol start="8">
<li>Run the code and observe the following output:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/791cb3bf-f7d2-47fd-84c3-a06097ba5b17.png" style="width:20.67em;height:15.75em;" width="276" height="210"/></p>
<p>Let's go behind the scenes to understand the code better.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p><span>While the spaghetti code created a GUI, it is very hard to read because there is so much confusion in the code.</span> Good code has many advantages over spaghetti code.</p>
<p>Let's see an example of spaghetti code first:</p>
<pre>def PRINTME(me):print(me) <br/>import tkinter  <br/>x=y=z=1 <br/>PRINTME(z)  <br/>from tkinter import *</pre>
<p>Now, consider this example good code (note that there is not much confusion in reading the code):</p>
<pre>#====================== <br/># imports <br/>#====================== <br/>import tkinter as tk <br/>from tkinter import ttk</pre>
<p><span>The good code has a clearly commented section. We can easily find the import statements:</span></p>
<pre>#-----------------------------------</pre>
<p><span>Consider the following spaghetti code:</span></p>
<pre>import tkinter.scrolledtext <br/>outputFrame=tkinter.ttk.LabelFrame(win,text=' Type into the scrolled text <br/>control: ') <br/>scr=tkinter.scrolledtext.ScrolledText(outputFrame,width=scrolW,height=scrolH,wrap=tkinter.WORD) <br/>e='E' <br/>scr.grid(column=1,row=1,sticky=WE) <br/>outputFrame.grid(column=0,row=2,sticky=e,padx=8) <br/>lFrame=None <br/>if y:chck2=tkinter.Checkbutton(lFrame,text="Enabled",variable=chVarUn) <br/>wE='WE' <br/>if y==x:PRINTME(x)  <br/>lFrame=tkinter.ttk.LabelFrame(win,text="Spaghetti")</pre>
<p><span>Now, consider the following good code. Here, as stated previously, we can easily find the import statements:</span></p>
<pre>#============================================================= <br/># Adding a LabelFrame, Textbox (Entry) and Combobox   <br/>#============================================================= <br/>lFrame = ttk.LabelFrame(win, text="Python GUI Programming Cookbook") <br/>lFrame.grid(column=0, row=0, sticky='WE', padx=10, pady=10) <br/><br/>#============================================================= <br/># Using a scrolled Text control     <br/>#============================================================= <br/>outputFrame = ttk.LabelFrame(win, text=' Type into the scrolled text <br/>control: ') <br/>outputFrame.grid(column=0, row=2, sticky='E', padx=8)</pre>
<p>Good code, as shown in the preceding block, has a natural flow that follows how the widgets get laid out in the main GUI form.</p>
<p>In the spaghetti code, the bottom <kbd>LabelFrame</kbd> gets created before the top <kbd>LabelFrame</kbd>, and it is intermixed with an <kbd>import</kbd> statement and some widget creation:</p>
<pre>#-----------------------------------</pre>
<p><span>The following is an example of spaghetti code that portrays this feature:</span></p>
<pre>def PRINTME(me):print(me) <br/>x=y=z=1 <br/>e='E' <br/>WE='WE' <br/>scr.grid(column=1,row=1,sticky=WE) <br/>wE='WE' <br/>if y==x:PRINTME(x)  <br/>lFrame.grid(column=0,row=0,sticky=wE,padx=10,pady=10)  <br/>PRINTME(z) <br/>try: win.mainloop() <br/>except:PRINTME(x) <br/>chck2.deselect() <br/>if y==x:PRINTME(x)</pre>
<p><span>Good code</span> <span>does not contain unnecessary variable assignments, nor does it have a</span> <kbd>PRINTME</kbd> <span>function that does not do the debugging we might expect it to when reading the code:</span></p>
<pre>#-----------------------------------</pre>
<p>The following code blocks enumerate this aspect.</p>
<p>Here is the spaghetti code:</p>
<pre>import tkinter <br/>x=y=z=1 <br/>PRINTME(z)  <br/>from tkinter import * <br/>scrolW=30;scrolH=6 <br/>win=tkinter.Tk() <br/>if x:chVarUn=tkinter.IntVar() <br/>from tkinter import ttk <br/>WE='WE' <br/>import tkinter.scrolledtext</pre>
<p><span>Here is the good code:</span></p>
<pre>import tkinter as tk <br/>from tkinter import ttk <br/>from tkinter import scrolledtext</pre>
<p>Good code has none of the instances mentioned for the spaghetti code.</p>
<p>The <kbd>import</kbd> statements only import the required modules, and they are not cluttered throughout the code. Also, there are no duplicate <kbd>import</kbd> statements. There is no <kbd>import *</kbd> statement:</p>
<pre>#-----------------------------------</pre>
<p><span>The following code blocks enumerate this aspect.</span></p>
<p>This is the spaghetti code:</p>
<pre>x=y=z=1 <br/>if x:chVarUn=tkinter.IntVar() <br/>wE='WE'</pre>
<p>Here is the good code:</p>
<pre>#============================================================= <br/># Using a scrolled Text control     <br/>#============================================================= <br/>outputFrame = ttk.LabelFrame(win, text=' Type into the scrolled text<br/>control: ') <br/>outputFrame.grid(column=0, row=2, sticky='E', padx=8) <br/>scrolW = 30 <br/>scrolH =  6 <br/>scr = scrolledtext.ScrolledText(outputFrame, width=scrolW, <br/>height=scrolH, wrap=tk.WORD) <br/>scr.grid(column=1, row=0, sticky='WE')</pre>
<p><span>Good code, as shown in the preceding example and compared to spaghetti code, has</span> <span>variable names that are quite meaningful</span><span>. There are no unnecessary</span> <kbd>if</kbd> <span>statements that use the number</span> <kbd>1</kbd> <span>instead of</span> <kbd>True</kbd><span>. It also has good indentation that makes the code much more readable.</span></p>
<p class="mce-root"/>
<p>In <span><kbd>GUI_NOT_Spaghetti.py</kbd>, w</span><span>e did not lose the intended window title and our check button ended up in the correct position. We also made</span> <span>the</span> <kbd>LabelFrame</kbd> that <span>surrounds the check button visible.</span></p>
<p>In <kbd>GUI_Spaghetti.py</kbd>, we both <span>lost</span> the window title and did not display the top <kbd>LabelFrame</kbd>. The check button ended up in the wrong place.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using __init__ to connect modules</h1>
                </header>
            
            <article>
                
<p>When we create a new Python package using the PyDev plugin for the Eclipse IDE, it automatically creates an <kbd>__init__.py</kbd> module. We can also create it ourselves manually, when not using Eclipse.</p>
<div class="packt_infobox">The <kbd>__init__.py</kbd> module is usually empty and, <span class="InformationBoxPACKTChar">then,</span> has a size of 0 KB.</div>
<p>We can use this usually empty module to connect different Python modules by entering code into it. This recipe will show how to do this.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will create a new GUI similar to the one we created in the previous recipe, <em>Avoiding spaghetti code</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p><span>As our project becomes larger and larger, we naturally break it out into several Python modules. Sometimes, it can be complicated to find modules that are located in different subfolders, either above or below the code that needs to import it.</span></p>
<p class="mce-root"/>
<p>Let's see this recipe sequentially:</p>
<ol>
<li>Create an empty file and save it as <kbd>__init__.py</kbd>.</li>
<li>Look at its size:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="Images/50771dad-df83-401a-b1ab-771e1e7c8239.png" style="width:17.92em;height:9.08em;" width="258" height="131"/></div>
<ol start="3">
<li>Create a new module, <kbd>GUI__init.py</kbd>, and add the following code:</li>
</ol>
<pre style="padding-left: 60px">#====================== <br/># imports <br/>#====================== <br/>import tkinter as tk <br/>from tkinter import ttk <br/>#====================== <br/># Create instance <br/>#====================== <br/>win = tk.Tk()    <br/>#====================== <br/># Add a title        <br/>#======================  <br/>win.title("Python GUI") </pre>
<ol start="4">
<li>Next, add some widgets and a callback function:</li>
</ol>
<pre style="padding-left: 60px">#============================================================= <br/># Adding a LabelFrame and a Button <br/>#============================================================= <br/>lFrame = ttk.LabelFrame(win, text="Python GUI Programming Cookbook") <br/>lFrame.grid(column=0, row=0, sticky='WE', padx=10, pady=10) <br/>def clickMe(): <br/>    from tkinter import messagebox <br/>    messagebox.showinfo('Message Box', 'Hi from same Level.') <br/>button = ttk.Button(lFrame, text="Click Me ", command=clickMe) <br/>button.grid(column=1, row=0, sticky=tk.S)   <br/>#====================== <br/># Start GUI <br/>#====================== <br/>win.mainloop()</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="5">
<li>Run the code and click the <kbd>Click Me</kbd> button:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="Images/48aeb0d5-3c0a-412a-909c-2cf39f415b58.png" style="width:29.00em;height:12.25em;" width="485" height="205"/></div>
<ol start="6">
<li>Create three subfolders below where you are running your Python modules from.</li>
<li><span>Name them</span> <kbd>Folder1</kbd><span>,</span> <kbd>Folder2</kbd><span>, and</span> <kbd>Folder3</kbd><span>:</span></li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="Images/fed12450-6897-479b-b244-88c0e1dc6d7d.png" style="width:48.67em;height:8.75em;" width="782" height="141"/></div>
<ol start="8">
<li>In <span><kbd>Folder3</kbd></span>, create a new module: <kbd>MessageBox.py</kbd>.</li>
<li>Add the following code:</li>
</ol>
<pre style="padding-left: 60px">from tkinter import messagebox<br/><br/>def clickMe():<br/>    messagebox.showinfo('Imported Message Box', 'Hi from Level 3')</pre>
<ol start="10">
<li>Open <span><kbd>GUI__init.py</kbd> and save it as <kbd>GUI__init_import_folder.py</kbd>.</span></li>
<li>Add the following import:</li>
</ol>
<pre style="padding-left: 60px">from Ch11_Code.Folder1.Folder2.Folder3.MessageBox import clickMe</pre>
<ol start="12">
<li>Comment out or delete the <kbd>clickMe</kbd> function:</li>
</ol>
<pre style="padding-left: 60px"># def clickMe():         # commented out<br/># from tkinter import messagebox<br/># messagebox.showinfo('Message Box', 'Hi from same Level.')</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="13">
<li>Run the code from your development environment and observe the output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="Images/1d6b3f2b-eb03-4dcb-ad56-1afe028d32f0.png" style="width:31.58em;height:12.00em;" width="466" height="177"/></div>
<ol start="14">
<li>Open Command Prompt and try to run it. If running the code is unsuccessful, you can see the following output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/0fa821f7-a6cc-4549-887f-b2da7a9e6161.png" style="width:62.08em;height:11.58em;" width="984" height="183"/></div>
<ol start="15">
<li class="mce-root">Open <kbd><span>__init__.py</span></kbd>.</li>
<li class="mce-root">Add the following code to the <kbd>__init__.py</kbd> <span>module:</span></li>
</ol>
<pre style="padding-left: 60px">print('hi from GUI init\n') <br/>from sys import path <br/>from pprint import pprint <br/>#===================================================================<br/># Required setup for the PYTONPATH in order to find all package <br/># folders <br/>#===================================================================<br/>from site import addsitedir <br/>from os import getcwd, chdir, pardir <br/>while True: <br/>    curFull = getcwd() <br/>    curDir = curFull.split('\\')[-1]  <br/>    if 'Ch11_Code' == curDir: <br/>        addsitedir(curFull) <br/>        addsitedir(curFull + 'Folder1\Folder2\Folder3') <br/>        break <br/>    chdir(pardir) <br/>pprint(path)</pre>
<ol start="17">
<li>Open <span><kbd>GUI__init_import_folder.py</kbd> and save it as <kbd>GUI__init_import_folder_directly.py</kbd></span><span>.</span></li>
<li>Add the following two import statements and comment out the previous import:</li>
</ol>
<pre style="padding-left: 60px"># from Ch11_Code.Folder1.Folder2.Folder3.MessageBox import clickMe # comment out<br/>import __init__ <br/>from MessageBox import clickMe</pre>
<ol start="19">
<li>Run the code from Command Prompt:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="Images/c8b13ae4-8aac-4e6f-bc9a-1828f1fcfc86.png" style="width:58.92em;height:21.67em;" width="906" height="262"/></div>
<p>Let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>When we create an <kbd>__init__.py</kbd> <span>module, it is typically empty with a file size of 0 KB.</span></p>
<div class="packt_infobox">The <kbd>__init__.py</kbd> module is not the same as the <kbd>__init__(self):</kbd> method of a Python class.</div>
<div>
<p>In <kbd><span>GUI__init.py</span></kbd>, we created the following function, which imports Python's message box and then uses it to display the message box dialog window:</p>
<pre>def clickMe(): <br/>    from tkinter import messagebox <br/>    messagebox.showinfo('Message Box', 'Hi from same Level.')</pre></div>
<p>When we move the <kbd>clickMe()</kbd> message box code into a nested directory folder and try to <kbd>import</kbd> it into our GUI module, we might run into some challenges.</p>
<p>We have created three subfolders below where our Python module lives. We have then placed the <kbd>clickMe()</kbd> message box code into a new Python module, which we named <kbd>MessageBox.py</kbd>. This module is located in <kbd>Folder3</kbd>, three levels below where our Python module is.</p>
<p>We want to import <kbd>MessageBox.py</kbd> in order to use the <kbd>clickMe()</kbd> function that this module contains.</p>
<p>We can use Python's relative import syntax:</p>
<pre>from Ch11_Code.Folder1.Folder2.Folder3.MessageBox import clickMe</pre>
<p>In the preceding code, the path is hardcoded. If we remove <kbd>Folder2</kbd>, it would no longer work.</p>
<p><span>In <kbd>GUI__init_import_folder.py</kbd>, we deleted the local</span> <kbd>clickMe()</kbd> <span>function and now our callback is expected to use the imported</span> <kbd>clickMe()</kbd> <span>function. This works from within Eclipse and other IDEs that set <kbd>PYTHONPATH</kbd> to a project where you develop your code.</span></p>
<p>It may or may not work from Command Prompt, depending on whether you have set <kbd>PYTHONPATH</kbd> to the root of where the <kbd>Ch11_Code\Folder1\Folder2\Folder3</kbd> <span>folders</span> are located.</p>
<p><span>To solve this error, we can initialize our Python search path from within the</span> <kbd>__init__.py</kbd> <span>module</span><span>. This often solves relative import errors.</span></p>
<p>In the <span><kbd>GUI__init_import_folder_directly.py</kbd></span> module, we no longer have to specify the full folder path. We can import the module and its function directly.</p>
<div class="packt_infobox"><span>We have to explicitly</span> import <kbd>__init__</kbd> <span>for this code to work.</span></div>
<p>This recipe showed a few troubleshooting approaches in case you run into this sort of challenge.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Mixing fall-down and OOP coding</h1>
                </header>
            
            <article>
                
<p>Python is an OOP language, yet it does not always make sense to use OOP. For simple scripting tasks, the legacy waterfall coding style is still appropriate.</p>
<p>In this recipe, we will create a new GUI that mixes both the fall-down coding style with the more modern OOP coding style.</p>
<p>We will create an OOP-style class that will display a tooltip when we hover the mouse over a widget in a Python GUI, which <span>we will create using the waterfall style.</span></p>
<div class="packt_infobox">Fall-down and waterfall coding styles are the same. It means that we have to physically place code above code before we can call it from the code below. In this paradigm, the code literally falls down from the top of our program to the bottom of our program when we execute the code.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will create a GUI using <kbd>tkinter</kbd>, which is similar to the GUI we created in the first chapter of this book.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>Let's see how to perform this recipe:</p>
<ol>
<li>We will first create a GUI using <kbd>tkinter</kbd> in a procedural fashion and then we will add a class to it to display tooltips over GUI widgets.</li>
<li>Next, we will create a new module: <kbd>GUI_FallDown.py</kbd><span>.</span></li>
<li>Add the following code:</li>
</ol>
<pre style="padding-left: 60px">#====================== <br/># imports <br/>#====================== <br/>import tkinter as tk <br/>from tkinter import ttk <br/>from tkinter import messagebox <br/>#====================== <br/># Create instance <br/>#====================== <br/>win = tk.Tk()    <br/>#====================== <br/># Add a title        <br/>#======================  <br/>win.title("Python GUI") <br/>#========================= <br/># Disable resizing the GUI <br/>#========================= <br/>win.resizable(0,0) </pre>
<ol start="4">
<li>Next, add some widgets:</li>
</ol>
<pre style="padding-left: 60px">#============================================================= <br/># Adding a LabelFrame, Textbox (Entry) and Combobox   <br/>#============================================================= <br/>lFrame = ttk.LabelFrame(win, text="Python GUI Programming Cookbook") <br/>lFrame.grid(column=0, row=0, sticky='WE', padx=10, pady=10) <br/>#============================================================= <br/># Labels <br/>#============================================================= <br/>ttk.Label(lFrame, text="Enter a name:").grid(column=0, row=0) <br/>ttk.Label(lFrame, text="Choose a number:").grid(column=1, row=0, sticky=tk.W) <br/>#============================================================= <br/># Buttons click command <br/>#============================================================= <br/>def clickMe(name, number): <br/>    messagebox.showinfo('Information Message Box', 'Hello '+name+  <br/>    ', your number is: ' + number) </pre>
<ol start="5">
<li>Add more widgets in a loop:</li>
</ol>
<pre style="padding-left: 60px">#============================================================= <br/># Creating several controls in a loop <br/>#============================================================= <br/>names         = ['name0', 'name1', 'name2'] <br/>nameEntries   = ['nameEntry0', 'nameEntry1', 'nameEntry2'] <br/>numbers       = ['number0', 'number1', 'number2'] <br/>numberEntries = ['numberEntry0', 'numberEntry1', 'numberEntry2'] <br/>buttons = [] <br/>for idx in range(3): <br/>    names[idx] = tk.StringVar() <br/>    nameEntries[idx] = ttk.Entry(lFrame, width=12, <br/>    textvariable=names[idx]) <br/>    nameEntries[idx].grid(column=0, row=idx+1) <br/>    nameEntries[idx].delete(0, tk.END) <br/>    nameEntries[idx].insert(0, '&lt;name&gt;') <br/>    numbers[idx] = tk.StringVar() <br/>    numberEntries[idx] = ttk.Combobox(lFrame, width=14,<br/>    textvariable=numbers[idx]) <br/>    numberEntries[idx]['values'] = (1+idx, 2+idx, 4+idx, 42+idx, <br/>    100+idx) <br/>    numberEntries[idx].grid(column=1, row=idx+1) <br/>    numberEntries[idx].current(0) <br/>    button = ttk.Button(lFrame, text="Click Me "+str(idx+1), <br/>    command=lambda idx=idx: clickMe(names[idx].get(), <br/>    numbers[idx].get())) <br/>    button.grid(column=2, row=idx+1, sticky=tk.W)   <br/>    buttons.append(button) <br/>#====================== <br/># Start GUI <br/>#====================== <br/>win.mainloop()</pre>
<ol start="6">
<li>Run the code and click one of the buttons:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="Images/c4fc7273-ebc5-4a85-be6f-2fc231001ab8.png" style="width:37.58em;height:13.25em;" width="570" height="201"/></div>
<ol start="7">
<li>Create a new module: <kbd>GUI_FallDown_Tooltip.py</kbd><span>.</span></li>
<li>Use the code from <kbd><span>GUI_FallDown.py</span></kbd> and then add the following code to it at the top:</li>
</ol>
<pre style="padding-left: 60px">import tkinter as tk<br/>from tkinter import ttk<br/>from tkinter import messagebox<br/>#===================================================================<br/># Add this code at the top<br/>class ToolTip(object):<br/>    def __init__(self, widget, tip_text=None):<br/>        self.widget = widget<br/>        self.tip_text = tip_text<br/>        widget.bind('&lt;Enter&gt;', self.mouse_enter)     <br/>        widget.bind('&lt;Leave&gt;', self.mouse_leave)<br/>    def mouse_enter(self, _event): <br/>        self.show_tooltip()        <br/>    def mouse_leave(self, _event):<br/>        self.hide_tooltip()<br/>    def show_tooltip(self):<br/>        if self.tip_text:<br/>            x_left = self.widget.winfo_rootx() <br/>            # get widget top-left coordinates<br/>            y_top = self.widget.winfo_rooty() - 18 <br/>            # place tooltip above widget<br/>            <br/>            self.tip_window = tk.Toplevel(self.widget) <br/>            self.tip_window.overrideredirect(True) <br/>            self.tip_window.geometry("+%d+%d" % (x_left, y_top))  <br/>            label = tk.Label(self.tip_window, text=self.tip_text, <br/>                          justify=tk.LEFT, background="#ffffe0", <br/>                          relief=tk.SOLID, borderwidth=1,<br/>                          font=("tahoma", "8", "normal"))<br/>            label.pack(ipadx=1)<br/>    def hide_tooltip(self):<br/>        if self.tip_window:<br/>            self.tip_window.destroy() <br/>#====================================<br/># ...<br/># Add this code at the bottom<br/>    # Add Tooltips to widgets<br/>    ToolTip(nameEntries[idx], 'This is an Entry widget.') <br/>    ToolTip(numberEntries[idx], 'This is a DropDown widget.') <br/>    ToolTip(buttons[idx], 'This is a Button widget.') <br/>#======================<br/># Start GUI<br/>#======================<br/>win.mainloop()</pre>
<ol start="9">
<li>Run the code and hover the mouse over several widgets:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/339bb25c-a797-443a-ae30-d1126593381e.png" width="287" height="164"/></div>
<p>Let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>First, we create a Python GUI in <kbd><span>GUI_FallDown.py</span></kbd> using <kbd>tkinter</kbd> and code it in the waterfall style.</p>
<p>We can improve our Python GUI by adding tooltips. The best way to do this is to isolate the code that creates the tooltip functionality from our GUI.</p>
<p>We do this by creating a separate class, which has the tooltip functionality, and then we create an instance of this class in the same Python module that creates our GUI.</p>
<p>Using Python, there is no need to place our <kbd>ToolTip</kbd> class into a separate module. We can place it just above the procedural code and then call it from below the class code.</p>
<p>In <span><kbd>GUI_FallDown_Tooltip.py</kbd>, the code is almost identical to <kbd>GUI_FallDown.py</kbd>, but now we have tooltips.</span></p>
<p>We can very easily mix and match both procedural and OOP programming in the same Python module.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using a code naming convention</h1>
                </header>
            
            <article>
                
<p>This recipe will show you the value of adhering to a code naming scheme: it helps us to find the code we want to extend, and reminds us of the design of our program.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will look at Python module names and look at good naming conventions.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>We will create example projects with different Python module names to compare the naming:</p>
<ol>
<li>Create a new <kbd>ModuleNames</kbd> folder under <kbd>Folder1</kbd><span>.</span></li>
<li>Add the following Python modules, 1, 11, 2, and 3:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="Images/3b68c8c4-0684-4a69-a664-d5711a57b52e.png" style="width:10.58em;height:11.83em;" width="167" height="186"/></div>
<p class="mce-root"/>
<ol start="3">
<li>Next, create a new <kbd>ModuleNames_</kbd> folder under <kbd>Folder1</kbd>.</li>
<li>Add the following Python modules, 1, 11, 2, and 3:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/f290f8fe-1d3e-4f2d-b62b-e7894af0e317.png" style="width:8.75em;height:7.67em;" width="127" height="111"/></p>
<ol start="5">
<li>Next, create a new <kbd>ModuleNames_Desc</kbd> folder under <kbd>Folder1</kbd>.</li>
<li>Add the following Python modules, <kbd>Logger</kbd>, <kbd>UnitTests</kbd>, <kbd>GUI</kbd>, and <kbd>debug</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/d2fa59ec-51d6-420f-a516-a791d5aee4d9.png" style="width:10.58em;height:7.17em;" width="159" height="108"/></p>
<ol start="7">
<li>Look at this naming convention as an example:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="Images/5bdd6b95-5c07-4729-a2a0-85db9d4f437b.png" style="width:16.67em;height:18.50em;" width="249" height="277"/></div>
<p>Let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>In <em>step 1</em>, we create a package subfolder named <span><kbd>ModuleNames</kbd>.</span></p>
<p>In <em>step 2</em>, we add Python modules to it.</p>
<p>In <em>step 3</em>, we create another <span>package folder and add a trailing underscore to the name: <kbd>ModuleNames_</kbd>.</span></p>
<p>In <em>step 4</em>, we add new Python modules that have the same names as the ones in <em>step 2</em>.</p>
<p>In <em>step 5</em>, we create another package folder with a much more descriptive name, <span><kbd>ModuleNames_Desc</kbd>.</span></p>
<p>In <em>step 6</em>, we add Python modules but this time with much more descriptive names that explain the purpose of each Python module.</p>
<p>Lastly, in <em>step 7</em>, we show a full example of how this can look.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Often, a typical way to start coding is by incrementing numbers, as can be seen in <kbd><span>ModuleNames</span></kbd>.</p>
<p class="mce-root"/>
<p>Later, coming back to this code, we don't have much of an idea which Python module provides which functionality and, sometimes, our last incremented modules are not as good as the earlier versions.</p>
<div class="packt_tip">A clear naming convention does help.</div>
<p>A slight improvement is adding underscores, which makes module names more readable, as in <kbd><span>ModuleNames_</span></kbd>.</p>
<p>A better way is to add some description of what the module does, as seen in <kbd><span>ModuleNames_Desc</span></kbd>.</p>
<p><span>While not perfect, the names chosen for the different Python modules indicate what each module's responsibility is. When we want to add more unit tests, it is clear in which module they reside.</span></p>
<p>In the last example, we are using the placeholder, <kbd><span>PRODUCT</span></kbd>, for a real name.</p>
<div class="packt_tip">Replace the word <kbd>PRODUCT</kbd> with the product you are currently working on.</div>
<p>The entire application is a GUI. All parts are connected. The <kbd>DEBUG.py</kbd> module is only used for debugging code. The main module to invoke the GUI has its name reversed when compared with all of the other modules. It starts with <kbd>Gui</kbd> and has a <kbd>.pyw</kbd> extension.</p>
<p>It is the only Python module that has this extension name.</p>
<p>From this naming convention, if you are familiar enough with Python, it will be obvious that, to run this GUI, you can double-click the <kbd>Gui_PRODUCT.pyw</kbd> module.</p>
<p>All other Python modules contain functionality for the GUI and also execute the underlying business logic to fulfill the purpose this GUI addresses.</p>
<p>Naming conventions for Python code modules are a great help in keeping us efficient and helping us to remember our original design. When we need to debug and fix a defect or add new functionality, they are the first resources to look at.</p>
<p class="mce-root"/>
<div class="packt_infobox">Incrementing module names by numbers is not very meaningful and eventually wastes development time.</div>
<p>On the other hand, naming Python variables is more of a free form. Python infers types, so we do not have to specify that a variable will be of the <kbd>list</kbd> <span>type</span> (it might not be, or later in the code, it might become a different type).</p>
<p>A good idea for naming variables is to make them descriptive, and it is a good idea not to abbreviate too much.</p>
<p>If we wish to point out that a certain variable is designed to be of the <kbd>list</kbd> type, then it is much more intuitive to use the full word <kbd>list_of_things</kbd> instead of <kbd>lst<span>_of_things</span></kbd>. Similarly, use for <kbd>number</kbd> instead of <kbd>num</kbd>.</p>
<p>While it is a good idea to have very descriptive names for variables, sometimes that can get too long. In Apple's Objective-C language, some variable and function names are extreme: <kbd>thisIsAMethodThatDoesThisAndThatAndAlsoThatIfYouPassInNIntegers:1:2:3</kbd>.</p>
<div class="packt_tip">Use common sense when naming variables, methods, and functions.</div>
<p>Now, let's move on to the next recipe.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">When not to use OOP</h1>
                </header>
            
            <article>
                
<p>Python comes built in with OOP capabilities, but at the same time, we can write scripts that do not need to use OOP. For some tasks, OOP does not make sense.</p>
<p>This recipe will show us when not to use OOP.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will create a Python GUI similar to the previous recipes. We will compare the OOP code to the non-OOP alternative way of programming the GUI. The resultant output will be the same but the code of the two versions is slightly different.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>Let's see how to perform this recipe:</p>
<ol>
<li>Let's first create a new GUI using the OOP methodology. The code shown in the following steps will create the GUI displayed.</li>
<li>Create a new module: <kbd>GUI_OOP.py</kbd>.</li>
<li>Add the following code:</li>
</ol>
<pre style="padding-left: 60px">import tkinter as tk <br/>from tkinter import ttk <br/>from tkinter import scrolledtext <br/>from tkinter import Menu </pre>
<ol start="4">
<li>Create a class:</li>
</ol>
<pre style="padding-left: 60px">class OOP(): <br/>    def __init__(self):  <br/>        self.win = tk.Tk()          <br/>        self.win.title("Python GUI")       <br/>        self.createWidgets() </pre>
<ol start="5">
<li>Add a method to create widgets:</li>
</ol>
<pre style="padding-left: 60px">def createWidgets(self): <br/>    tabControl = ttk.Notebook(self.win) <br/>    tab1 = ttk.Frame(tabControl) <br/>    tabControl.add(tab1, text='Tab 1') <br/>    tabControl.pack(expand=1, fill="both") <br/>    self.monty = ttk.LabelFrame(tab1, text=' Mighty Python ') <br/>    self.monty.grid(column=0, row=0, padx=8, pady=4) <br/><br/>    ttk.Label(self.monty, text="Enter a name:").grid(column=0, <br/>    row=0, sticky='W') <br/>    self.name = tk.StringVar() <br/>    nameEntered = ttk.Entry(self.monty, width=12, <br/>    textvariable=self.name) <br/>    nameEntered.grid(column=0, row=1, sticky='W') <br/><br/>    self.action = ttk.Button(self.monty, text="Click Me!") <br/>    self.action.grid(column=2, row=1) <br/><br/>    ttk.Label(self.monty, text="Choose a number:")<br/>    .grid(column=1, row=0) <br/>    number = tk.StringVar() <br/>    numberChosen = ttk.Combobox(self.monty, width=12, <br/>    textvariable=number) <br/>    numberChosen['values'] = (42) <br/>    numberChosen.grid(column=1, row=1) <br/>    numberChosen.current(0) <br/><br/>    scrolW = 30; scrolH = 3 <br/>    self.scr = scrolledtext.ScrolledText(self.monty, width=scrolW, <br/>    height=scrolH, wrap=tk.WORD) <br/>    self.scr.grid(column=0, row=3, sticky='WE', columnspan=3)</pre>
<ol start="6">
<li>Create a menu bar:</li>
</ol>
<pre style="padding-left: 60px">    menuBar = Menu(tab1) <br/>    self.win.config(menu=menuBar) <br/>    fileMenu = Menu(menuBar, tearoff=0) <br/>    menuBar.add_cascade(label="File", menu=fileMenu) <br/>    helpMenu = Menu(menuBar, tearoff=0) <br/>    menuBar.add_cascade(label="Help", menu=helpMenu) <br/><br/>    nameEntered.focus()      <br/>#========================== <br/>oop = OOP() <br/>oop.win.mainloop()</pre>
<ol start="7">
<li>Run the code and observe the following output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/65445ad7-62bc-4f4a-92f0-ad1977fe5656.png" width="284" height="195"/></div>
<p>Let's have a look at a new scenario:</p>
<ol>
<li>Create a new module, <kbd>GUI_NOT_OOP.py</kbd>, and add the following code:</li>
</ol>
<pre style="padding-left: 60px">import tkinter as tk <br/>from tkinter import ttk <br/>from tkinter import scrolledtext <br/>from tkinter import Menu    <br/><br/>def createWidgets():     <br/>    tabControl = ttk.Notebook(win)      <br/>    tab1 = ttk.Frame(tabControl)             <br/>    tabControl.add(tab1, text='Tab 1')     <br/>    tabControl.pack(expand=1, fill="both")   <br/>    monty = ttk.LabelFrame(tab1, text=' Mighty Python ') <br/>    monty.grid(column=0, row=0, padx=8, pady=4)         </pre>
<ol start="2">
<li>Create more widgets:</li>
</ol>
<pre style="padding-left: 60px">ttk.Label(monty, text="Enter a name:").grid(column=0, row=0, <br/>sticky='W') <br/>name = tk.StringVar() <br/>nameEntered = ttk.Entry(monty, width=12, textvariable=name) <br/>nameEntered.grid(column=0, row=1, sticky='W') <br/><br/>action = ttk.Button(monty, text="Click Me!")    <br/>action.grid(column=2, row=1) <br/><br/>ttk.Label(monty, text="Choose a number:").grid(column=1, row=0) <br/>number = tk.StringVar() <br/>numberChosen = ttk.Combobox(monty, width=12, textvariable=number) <br/>numberChosen['values'] = (42) <br/>numberChosen.grid(column=1, row=1) <br/>numberChosen.current(0) <br/><br/>scrolW = 30; scrolH = 3 <br/>scr = scrolledtext.ScrolledText(monty, width=scrolW, <br/>height=scrolH, wrap=tk.WORD) <br/>scr.grid(column=0, row=3, sticky='WE', columnspan=3) </pre>
<ol start="3">
<li>Create a menu bar:</li>
</ol>
<pre style="padding-left: 60px">menuBar = Menu(tab1) <br/>win.config(menu=menuBar) <br/>fileMenu = Menu(menuBar, tearoff=0) <br/>menuBar.add_cascade(label="File", menu=fileMenu) <br/>helpMenu = Menu(menuBar, tearoff=0) <br/>menuBar.add_cascade(label="Help", menu=helpMenu) <br/><br/>nameEntered.focus()</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="4">
<li>Now, create the entire GUI, calling the function that creates the widgets:</li>
</ol>
<pre style="padding-left: 60px">#====================== <br/>win = tk.Tk()          <br/>win.title("Python GUI")    <br/>createWidgets() <br/>win.mainloop()</pre>
<ol start="5">
<li>Run the code. The resultant GUI will be identical to the one from <kbd><span>GUI_OOP.py</span></kbd> shown previously.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>First, we create a Python <kbd>tkinter</kbd> GUI in OOP style, <span><kbd>GUI_OOP.py</kbd>.</span> Then, we create the same GUI in a procedural style, <span><kbd>GUI_NOT_OOP.py</kbd>.</span></p>
<p>We can achieve the same GUI without using an OOP approach by restructuring our code slightly. First, we remove the <kbd>OOP</kbd> class and its <kbd>__init__</kbd> method. Next, we move all of the methods to the left and remove the <kbd>self</kbd> class reference, which turns them into unbound functions. We also remove any other <kbd>self</kbd> references our previous code had. Then, we move the <kbd>createWidgets</kbd> function call below the point of the function's declaration. We place it just above the <kbd>mainloop</kbd> call.</p>
<p>In the end, we achieve the same GUI but without using OOP.</p>
<p>Python enables us to use OOP when it makes sense. Other languages such as Java and C# force us to always use the OOP approach to coding. In this recipe, we explored a situation when it did not make sense to use OOP.</p>
<div class="packt_infobox">The OOP approach will be more extendable if the code base grows, but if it's certain that it is the only code that's needed, then there's no need to go through OOP.</div>
<p><span>Now, let's move on to the next recipe.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to use design patterns successfully</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will create widgets for our Python GUI by using the <em>factory design pattern</em>. In the previous recipes, we created our widgets either manually one at a time or dynamically in a loop. Using the factory design pattern, we will use the <em>factory</em> to create our widgets.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will create a Python GUI that has three buttons, each having a different style.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>We will create a Python GUI with different button styles and we will use a factory design pattern to create these different styles:</p>
<ol>
<li>Create a new module: <kbd>GUI_DesignPattern.py</kbd>.</li>
<li>Add the following code:</li>
</ol>
<pre style="padding-left: 60px">import tkinter as tk<br/>from tkinter import ttk<br/>from tkinter import scrolledtext<br/>from tkinter import Menu</pre>
<ol start="3">
<li>Create the factory class:</li>
</ol>
<pre style="padding-left: 60px">class ButtonFactory():<br/>    def createButton(self, type_):<br/>        return buttonTypes[type_]()        </pre>
<ol start="4">
<li>Create a base class:</li>
</ol>
<pre style="padding-left: 60px">class ButtonBase(): <br/>    relief ='flat'<br/>    foreground ='white'<br/>    def getButtonConfig(self):<br/>        return self.relief, self.foreground  </pre>
<ol start="5">
<li>Create classes that inherit from the base class:</li>
</ol>
<pre style="padding-left: 60px">class ButtonRidge(ButtonBase):<br/>    relief ='ridge'<br/>    foreground ='red'     <br/><br/>class ButtonSunken(ButtonBase):<br/>    relief ='sunken'<br/>    foreground ='blue' <br/><br/>class ButtonGroove(ButtonBase):<br/>    relief ='groove'<br/>    foreground ='green' </pre>
<ol start="6">
<li>Create a list that contains the previous classes:</li>
</ol>
<pre style="padding-left: 60px">buttonTypes = [ButtonRidge, ButtonSunken, ButtonGroove] </pre>
<ol start="7">
<li>Create a new class that uses the previous code:</li>
</ol>
<pre style="padding-left: 60px">class OOP():<br/>    def __init__(self): <br/>        self.win = tk.Tk() <br/>        self.win.title("Python GUI") <br/>        self.createWidgets()<br/><br/>    def createWidgets(self): <br/>        tabControl = ttk.Notebook(self.win) <br/>        tab1 = ttk.Frame(tabControl) <br/>        tabControl.add(tab1, text='Tab 1') <br/>        tabControl.pack(expand=1, fill="both") <br/>        self.monty = ttk.LabelFrame(tab1, text=' Monty Python ')<br/>        self.monty.grid(column=0, row=0, padx=8, pady=4) <br/>        scr = scrolledtext.ScrolledText(self.monty, width=30, <br/>        height=3, wrap=tk.WORD)<br/>        scr.grid(column=0, row=3, sticky='WE', columnspan=3)<br/>        menuBar = Menu(tab1)<br/>        self.win.config(menu=menuBar)<br/>        fileMenu = Menu(menuBar, tearoff=0)<br/>        menuBar.add_cascade(label="File", menu=fileMenu)<br/>        helpMenu = Menu(menuBar, tearoff=0)<br/>        menuBar.add_cascade(label="Help", menu=helpMenu)       <br/>        self.createButtons()<br/><br/>    def createButtons(self):            <br/>        factory = ButtonFactory() # &lt;-- create the factory<br/>        <br/>        # Button 1<br/>        rel = factory.createButton(0).getButtonConfig()[0]<br/>        fg = factory.createButton(0).getButtonConfig()[1]<br/>        action = tk.Button(self.monty, text="Button "+str(0+1), <br/>        relief=rel, foreground=fg) <br/>        action.grid(column=0, row=1) <br/>        # Button 2<br/>        rel = factory.createButton(1).getButtonConfig()[0]<br/>        fg = factory.createButton(1).getButtonConfig()[1]<br/>        action = tk.Button(self.monty, text="Button "+str(1+1), <br/>        relief=rel, foreground=fg) <br/>        action.grid(column=1, row=1) <br/>        # Button 3<br/>        rel = factory.createButton(2).getButtonConfig()[0]<br/>        fg = factory.createButton(2).getButtonConfig()[1]<br/>        action = tk.Button(self.monty, text="Button "+str(2+1), <br/>        relief=rel, foreground=fg) <br/>        action.grid(column=2, row=1) <br/>#==========================<br/>oop = OOP()<br/>oop.win.mainloop()</pre>
<ol start="8">
<li>Run the code and observe the output:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/f933506b-a17d-415a-b9e4-ec254f1ecaa9.png" style="width:18.42em;height:11.58em;" width="283" height="178"/></p>
<p>Let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>We create a base class that our different button style classes inherit from and in which each of them overrides the <kbd>relief</kbd> and <kbd>foreground</kbd> configuration attributes. All subclasses inherit the <kbd>getButtonConfig</kbd> method from this base class. This method returns a tuple.</p>
<p>We also create a button factory class and a list that holds the names of our button subclasses. We name the list <kbd>buttonTypes</kbd>, as our factory will create different types of buttons.</p>
<p>Further down in the module, we create the button widgets, using the same <kbd>buttonTypes</kbd> list. We create an instance of the button factory and then we use our factory to create our buttons.</p>
<p class="mce-root"/>
<div class="packt_infobox">The items in the <kbd>buttonTypes</kbd> list are the names of our subclasses.</div>
<p>We invoke the <kbd>createButton</kbd> method and then immediately call the <kbd>getButtonConfig</kbd> method of the base class and retrieve the configuration <span>attributes using dot notation.</span></p>
<p><span>We can see that our Python GUI factory did indeed create different buttons, each having a different style. They differ in the color of their text and their</span> <kbd>relief</kbd> <span>property.</span></p>
<p>Design patterns are a very exciting tool in our software development toolbox.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Avoiding complexity</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will extend our Python GUI and learn ways to handle the increasing complexity of our software development efforts.</p>
<p>Our co-workers and clients love the GUIs we create in Python and ask for more and more features to add to our GUI.</p>
<p>This increases complexity and can easily ruin our original nice design.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will create a new Python GUI similar to those in the previous recipes and will add many features to it in the form of widgets.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>Let's see how to perform the recipe:</p>
<ol>
<li>We will start with a Python GUI that has two tabs and then we will add more widgets to it.</li>
<li>Create a new module: <kbd>GUI_Complexity_start.py</kbd><span>.</span></li>
<li>Add the following code:</li>
</ol>
<pre style="padding-left: 60px">#======================<br/># imports<br/>#======================<br/>import tkinter as tk<br/>from tkinter import ttk<br/>from tkinter import scrolledtext<br/>from tkinter import Menu<br/>from tkinter import Spinbox<br/>from Ch11_Code.ToolTip import ToolTip</pre>
<ol start="4">
<li>Create a global variable and a class:</li>
</ol>
<pre style="padding-left: 60px">GLOBAL_CONST = 42<br/>#=================================================================== <br/>class OOP():<br/>    def __init__(self): <br/>        # Create instance<br/>        self.win = tk.Tk()         <br/>        # Add a title <br/>        self.win.title("Python GUI") <br/>        self.createWidgets()   <br/>    # Button callback<br/>    def clickMe(self):<br/>        self.action.configure(text='Hello ' + self.name.get())    <br/>    # Button callback Clear Text <br/>    def clearScrol(self):<br/>        self.scr.delete('1.0', tk.END)     <br/>    # Spinbox callback <br/>    def _spin(self):<br/>        value = self.spin.get()<br/>        print(value)<br/>        self.scr.insert(tk.INSERT, value + '\n')        <br/>    # Checkbox callback <br/>    def checkCallback(self, *ignoredArgs):<br/>        # only enable one checkbutton<br/>        if self.chVarUn.get(): <br/>            self.check3.configure(state='disabled')<br/>        else: self.check3.configure(state='normal')<br/>        if self.chVarEn.get(): <br/>            self.check2.configure(state='disabled')<br/>        else: self.check2.configure(state='normal')         <br/>    # Radiobutton callback function<br/>    def radCall(self):<br/>        radSel=self.radVar.get()<br/>        if radSel == 0: self.monty2.configure(text='Blue')<br/>        elif radSel == 1: self.monty2.configure(text='Gold')<br/>        elif radSel == 2: self.monty2.configure(text='Red') <br/>    # Exit GUI cleanly<br/>    def _quit(self):<br/>        self.win.quit()<br/>        self.win.destroy()<br/>        exit()     <br/>    def usingGlobal(self):<br/>        GLOBAL_CONST = 777<br/>        print(GLOBAL_CONST)</pre>
<ol start="5">
<li>Add a method that creates the widgets:</li>
</ol>
<pre style="padding-left: 60px">#######################################################################<br/>def createWidgets(self): <br/>    tabControl = ttk.Notebook(self.win) # Create Tab Control <br/>    tab1 = ttk.Frame(tabControl) # Create a tab <br/>    tabControl.add(tab1, text='Tab 1') # Add the tab <br/>    tab2 = ttk.Frame(tabControl) # Add a second tab<br/>    tabControl.add(tab2, text='Tab 2') # Make second tab visible <br/>    tabControl.pack(expand=1, fill="both") # Pack to make visible <br/>    self.monty = ttk.LabelFrame(tab1, text=' Mighty Python ')<br/>    self.monty.grid(column=0, row=0, padx=8, pady=4) <br/><br/>    ttk.Label(self.monty, text="Enter a name:").grid(column=0, <br/>    row=0, sticky='W') <br/>    self.name = tk.StringVar()<br/>    nameEntered = ttk.Entry(self.monty, width=12, <br/>    textvariable=self.name)<br/>    nameEntered.grid(column=0, row=1, sticky='W') <br/><br/>    self.action = ttk.Button(self.monty, text="Click Me!", <br/>    command=self.clickMe) <br/>    self.action.grid(column=2, row=1) <br/>    ttk.Label(self.monty, text="Choose a number:").grid(column=1, <br/>    row=0)<br/>    number = tk.StringVar()<br/>    numberChosen = ttk.Combobox(self.monty, width=12, <br/>    textvariable=number)<br/>    numberChosen['values'] = (1, 2, 4, 42, 100)<br/>    numberChosen.grid(column=1, row=1)<br/>    numberChosen.current(0) <br/><br/>    self.spin = Spinbox(self.monty, values=(1, 2, 4, 42, 100), <br/>    width=5, bd=8, command=self._spin) <br/>    self.spin.grid(column=0, row=2) <br/><br/>    scrolW = 30; scrolH = 3<br/>    self.scr = scrolledtext.ScrolledText(self.monty, width=scrolW, <br/>    height=scrolH, wrap=tk.WORD)<br/>    self.scr.grid(column=0, row=3, sticky='WE', columnspan=3) <br/><br/>    self.monty2 = ttk.LabelFrame(tab2, text=' Holy Grail ')<br/>    self.monty2.grid(column=0, row=0, padx=8, pady=4)<br/><br/>    chVarDis = tk.IntVar()<br/>    check1 = tk.Checkbutton(self.monty2, text="Disabled", <br/>    variable=chVarDis, state='disabled')<br/>    check1.select()<br/>    check1.grid(column=0, row=0, sticky=tk.W) <br/>    self.chVarUn = tk.IntVar()<br/>    self.check2 = tk.Checkbutton(self.monty2, text="UnChecked", <br/>    variable=self.chVarUn)<br/>    self.check2.deselect()<br/>    self.check2.grid(column=1, row=0, sticky=tk.W ) <br/>    self.chVarEn = tk.IntVar()<br/>    self.check3 = tk.Checkbutton(self.monty2, text="Toggle", <br/>    variable=self.chVarEn)<br/>    self.check3.deselect()<br/>    self.check3.grid(column=2, row=0, sticky=tk.W) <br/><br/>    self.chVarUn.trace('w', lambda unused0, unused1, unused2 : <br/>    self.checkCallback()) <br/>    self.chVarEn.trace('w', lambda unused0, unused1, unused2 : <br/>    self.checkCallback()) <br/><br/>    colors = ["Blue", "Gold", "Red"] <br/>    self.radVar = tk.IntVar() <br/>    self.radVar.set(99) <br/><br/>    for col in range(3):<br/>        curRad = 'rad' + str(col) <br/>        curRad = tk.Radiobutton(self.monty2, text=colors[col], <br/>        variable=self.radVar, value=col, command=self.radCall)<br/>        curRad.grid(column=col, row=6, sticky=tk.W, columnspan=3)<br/>        ToolTip(curRad, 'This is a Radiobutton control.')<br/>       <br/>    labelsFrame = ttk.LabelFrame(self.monty2, <br/>    text=' Labels in a Frame ')<br/>    labelsFrame.grid(column=0, row=7) <br/><br/>    ttk.Label(labelsFrame, text="Label1").grid(column=0, row=0)<br/>    ttk.Label(labelsFrame, text="Label2").grid(column=0, row=1) <br/><br/>    for child in labelsFrame.winfo_children(): <br/>        child.grid_configure(padx=8) <br/>    <br/>    menuBar = Menu(tab1)<br/>    self.win.config(menu=menuBar) <br/><br/>    fileMenu = Menu(menuBar, tearoff=0)<br/>    fileMenu.add_command(label="New")<br/>    fileMenu.add_separator()<br/>    fileMenu.add_command(label="Exit", command=self._quit)<br/>    menuBar.add_cascade(label="File", menu=fileMenu) <br/><br/>    helpMenu = Menu(menuBar, tearoff=0)<br/>    helpMenu.add_command(label="About")<br/>    menuBar.add_cascade(label="Help", menu=helpMenu) <br/><br/>    self.win.iconbitmap('pyc.ico') <br/><br/>    strData = tk.StringVar()<br/>    strData.set('Hello StringVar') <br/>    intData = tk.IntVar()<br/>    strData = tk.StringVar()<br/>    strData = self.spin.get() <br/>    self.usingGlobal() <br/>    nameEntered.focus() <br/><br/>    ToolTip(self.spin, 'This is a Spin control.') <br/>    ToolTip(nameEntered, 'This is an Entry control.') <br/>    ToolTip(self.action, 'This is a Button control.') <br/>    ToolTip(self.scr, 'This is a ScrolledText control.') <br/>#======================<br/># Start GUI<br/>#======================<br/>oop = OOP()<br/>oop.win.mainloop()</pre>
<ol start="6">
<li>Run <span>the code and click both tabs:</span></li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="Images/35bf9481-3a0a-4b34-b4de-d85845b18b44.png" width="631" height="250"/></div>
<ol start="7">
<li>Open <span><kbd>GUI_Complexity_start.py</kbd> and save it as <kbd>GUI_Complexity_start_add_button.py</kbd></span>.</li>
<li>Add the following code to the <kbd>createWidgets</kbd> <span>method:</span></li>
</ol>
<pre style="padding-left: 60px"># Adding another Button <br/>self.action = ttk.Button(self.monty, text="Clear Text", command=self.clearScrol)    <br/>self.action.grid(column=2, row=2)</pre>
<ol start="9">
<li>Add the following code just below <kbd>__init__(self)</kbd>:</li>
</ol>
<pre style="padding-left: 60px"># Button callback <br/>def clickMe(self): <br/>    self.action.configure(text='Hello ' + self.name.get()) <br/><br/># Button callback Clear Text    <br/>def clearScrol(self): <br/>    self.scr.delete('1.0', tk.END)</pre>
<ol start="10">
<li>Run the code and observe the following output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/6d00c1a7-0e8d-4dc8-b2c3-e4677f664cd9.png" width="294" height="230"/></div>
<ol start="11">
<li>Open <kbd><span>GUI_Complexity_start_add_button.py</span></kbd> <span>and save it as</span> <kbd>GUI_Complexity_start_add_three_more_buttons.py</kbd>.</li>
</ol>
<p> </p>
<ol start="12">
<li>Add the following code to the <kbd>createWidgets</kbd> <span>method:</span></li>
</ol>
<pre style="padding-left: 60px"># Adding more Feature Buttons <br/>for idx in range(3): <br/>    b = ttk.Button(self.monty, text="Feature" + str(idx+1))    <br/>    b.grid(column=idx, row=4)</pre>
<ol start="13">
<li>Run the code and observe the output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/20b1d196-a134-4d41-8602-0bc25a950521.png" style="width:20.58em;height:18.08em;" width="293" height="256"/></div>
<ol start="14">
<li>Open <kbd><span>GUI_Complexity_start_add_three_more_buttons.py</span></kbd> <span>and save it as <kbd>GUI_Complexity_start_add_three_more_buttons_add_more.py</kbd></span>.</li>
<li>Add the following code to the <kbd>createWidgets</kbd> <span>method:</span></li>
</ol>
<pre style="padding-left: 60px"># Adding more Feature Buttons <br/>startRow = 4<br/>for idx in range(12):<br/>    if idx &lt; 2: col = idx<br/>    else: col += 1<br/>    if not idx % 3: <br/>        startRow += 1<br/>        col = 0<br/><br/>    b = ttk.Button(self.monty, text="Feature " + str(idx+1)) <br/>    b.grid(column=col, row=startRow)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="16">
<li>Run the code and observe the following output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/3848bfc4-d4ab-4450-9624-ac8b40e7db8c.png" style="width:18.83em;height:20.92em;" width="290" height="323"/></div>
<ol start="17">
<li>Open <kbd><span>GUI_Complexity_start_add_three_more_buttons_add_more.py</span></kbd> and save it as <kbd><span>GUI_Complexity_end_tab3.py</span></kbd>.</li>
<li>Add the following code <span>to the <kbd>createWidgets</kbd> method:</span></li>
</ol>
<pre style="padding-left: 60px"># Tab Control 3 ----------------------------------------- <br/>    tab3 = ttk.Frame(tabControl) # Add a tab <br/>    tabControl.add(tab3, text='Tab 3') # Make tab visible <br/><br/>    monty3 = ttk.LabelFrame(tab3, text=' New Features ') <br/>    monty3.grid(column=0, row=0, padx=8, pady=4) <br/><br/>    # Adding more Feature Buttons <br/>    startRow = 4 <br/>    for idx in range(24): <br/>        if idx &lt; 2: col = idx <br/>        else: col += 1<br/>        if not idx % 3: <br/>            startRow += 1 <br/>            col = 0 <br/><br/>        b = ttk.Button(monty3, text="Feature " + str(idx+1)) <br/>        b.grid(column=col, row=startRow) <br/><br/>    # Add some space around each label <br/>    for child in monty3.winfo_children(): <br/>        child.grid_configure(padx=8)</pre>
<ol start="19">
<li>Run the code and click on <span class="packt_screen">Tab 3</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/322f3e01-e7cc-43fe-8ba3-28b64fb2479e.png" width="292" height="298"/></div>
<p>Let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>We start with a GUI built with <kbd>tkinter</kbd>, <kbd><span>GUI_Complexity_start.py</span></kbd>, and it has some widgets on two tabs. We have created similar GUIs throughout this entire book.</p>
<p>The first new feature request we receive is to add functionality to <span class="packt_screen">Tab 1</span>, which clears the <kbd>scrolledtext</kbd> widget.</p>
<p>Easy enough. We just add another button to <span class="packt_screen">Tab 1.</span></p>
<p class="mce-root"/>
<p><span>We also have to create the callback method in <kbd>GUI_Complexity_start_add_button.py</kbd> to add the desired functionality, which we define toward the top of our class and outside the method that creates our widgets.</span> <span>Now, our GUI has a new button and, when we click it, we clear the text of the</span> <kbd>ScrolledText</kbd> <span>widget. To</span> add this functionality, we had to add code in two places in the same Python module.</p>
<p>We inserted the new button in the <kbd>createWidgets</kbd> method and then we created a new callback method, which our new button calls when it is clicked. We placed this code just below the callback of our first button.</p>
<p><span>Our next feature request is to add more functionality. The business logic is encapsulated in another Python module. We invoke this new functionality by adding three more buttons to</span> <span class="packt_screen">Tab 1</span> in <span class="packt_screen"><kbd><span>GUI_Complexity_start_add_three_more_buttons.py</span></kbd></span><span>. We use a loop to do this.</span></p>
<p><span>Next, our customers ask for more features and we use the same approach in <kbd>GUI_Complexity_start_add_three_more_buttons_add_more.py.</kbd></span></p>
<div class="packt_infobox">This is not too bad. When we get new feature requests for another 50 new features, we start to wonder whether our approach is still the best one to use.</div>
<p>One way to manage the increasing complexity our GUI handles is by adding tabs. By adding more tabs and placing related features into their own tab, we get control of the complexity and make our GUI more intuitive. We do this in <kbd>GUI_Complexity_end_tab3.py</kbd><span>, which creates our new</span> <span class="packt_screen">Tab 3.</span></p>
<p>We saw how to handle complexity by modularizing our GUI by breaking large features into smaller pieces and arranging them in functionally related areas using tabs.</p>
<p>While complexity has many aspects, modularizing and refactoring the code is usually a very good approach to handling software code complexity.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">GUI design using multiple notebooks</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will create our GUI using multiple notebooks. Surprisingly, <kbd>tkinter</kbd> does not ship out of the box with this functionality, but we can design such a widget ourselves.</p>
<p>Using multiple notebooks will further reduce the complexity discussed in the previous recipe.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will create a new Python GUI similar to the one in the previous recipe. This time, however, we will design our GUI with two notebooks. To focus on this feature, we will use functions instead of class methods. Reading the previous recipe will be a good introduction to this recipe.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>Let's see how to perform this recipe:</p>
<ol>
<li>To use multiple notebooks within the same GUI, we start by creating two frames. The first frame will hold the notebooks and their tabs while the second frame will serve as the display area for the widgets each tab is designed to display.</li>
<li>Create a new module: <kbd>GUI_Complexity_end_tab3_multiple_notebooks.py</kbd>.</li>
<li>Add the following code:</li>
</ol>
<pre style="padding-left: 60px">import tkinter as tk<br/>from tkinter import ttk<br/>from tkinter import scrolledtext<br/>from tkinter import Menu<br/>from tkinter import Spinbox<br/>from tkinter.messagebox import showinfo</pre>
<ol start="4">
<li>Create callback functions:</li>
</ol>
<pre style="padding-left: 60px">def clickMe(button, name, number):<br/>    button.configure(text='Hello {} {}'.format(name.get(), <br/>    number.get()))<br/><br/>def clearScrol(scr):<br/>    scr.delete('1.0', tk.END) <br/><br/>def _spin(spin, scr):<br/>    value = spin.get()<br/>    print(value)<br/>    scr.insert(tk.INSERT, value + '\n')<br/><br/>def checkCallback(*ignoredArgs):<br/>    pass<br/>#------------------------------------------<br/>def create_display_area():<br/>    # add empty label for spacing <br/>    display_area_label = tk.Label(display_area, text="", height=2)<br/>    display_area_label.grid(column=0, row=0)    <br/>#------------------------------------------<br/>def clear_display_area():<br/>    # remove previous widget(s) from display_area:<br/>    for widget in display_area.grid_slaves():<br/>        if int(widget.grid_info()["row"]) == 0:<br/>            widget.grid_forget() <br/>#------------------------------------------<br/>def _quit():<br/>    win.quit()<br/>    win.destroy()<br/>    exit()     </pre>
<ol start="5">
<li>Create a menu bar:</li>
</ol>
<pre style="padding-left: 60px">def create_menu(): <br/>    menuBar = Menu(win_frame_multi_row_tabs)<br/>    win.config(menu=menuBar)    <br/><br/>    fileMenu = Menu(menuBar, tearoff=0)<br/>    fileMenu.add_command(label="New")<br/>    fileMenu.add_separator()<br/>    fileMenu.add_command(label="Exit", command=_quit)<br/>    menuBar.add_cascade(label="File", menu=fileMenu)    <br/><br/>    helpMenu = Menu(menuBar, tearoff=0)<br/>    helpMenu.add_command(label="About")<br/>    menuBar.add_cascade(label="Help", menu=helpMenu)  </pre>
<ol start="6">
<li>Create Tab Display Area 1:</li>
</ol>
<pre style="padding-left: 60px">def display_tab1():<br/>    monty = ttk.LabelFrame(display_area, text=' Mighty Python ')<br/>    monty.grid(column=0, row=0, padx=8, pady=4)    <br/><br/>    ttk.Label(monty, text="Enter a name:").grid(column=0, row=0, <br/>    sticky='W')    <br/><br/>    name = tk.StringVar()<br/>    nameEntered = ttk.Entry(monty, width=12, textvariable=name)<br/>    nameEntered.grid(column=0, row=1, sticky='W')    <br/>    ttk.Label(monty, text="Choose a number:").grid(column=1, row=0)<br/>    number = tk.StringVar()<br/>    numberChosen = ttk.Combobox(monty, width=12, <br/>    textvariable=number)<br/>    numberChosen['values'] = (1, 2, 4, 42, 100)<br/>    numberChosen.grid(column=1, row=1)<br/>    numberChosen.current(0)<br/><br/>    action = ttk.Button(monty, text="Click Me!", <br/>    command= lambda: clickMe(action, name, number)) <br/>    action.grid(column=2, row=1)    <br/><br/>    scrolW = 30; scrolH = 3<br/>    scr = scrolledtext.ScrolledText(monty, width=scrolW, <br/>    height=scrolH, wrap=tk.WORD)<br/>    scr.grid(column=0, row=3, sticky='WE', columnspan=3)            <br/><br/>    spin = Spinbox(monty, values=(1, 2, 4, 42, 100), width=5, bd=8, <br/>    command= lambda: _spin(spin, scr)) <br/>    spin.grid(column=0, row=2, sticky='W')   <br/><br/>    clear = ttk.Button(monty, text="Clear Text", command= lambda: <br/>    clearScrol(scr)) <br/>    clear.grid(column=2, row=2)<br/><br/>    startRow = 4<br/>    for idx in range(12):<br/>        if idx &lt; 2:col = idx<br/>        else: col += 1<br/>        if not idx % 3: <br/>            startRow += 1<br/>            col = 0<br/>        b = ttk.Button(monty, text="Feature " + str(idx+1)) <br/>        b.grid(column=col, row=startRow)    </pre>
<ol start="7">
<li>Create <span>Tab Display Area 2:</span></li>
</ol>
<pre style="padding-left: 60px">def display_tab2():<br/>    monty2 = ttk.LabelFrame(display_area, text=' Holy Grail ')<br/>    monty2.grid(column=0, row=0, padx=8, pady=4)    <br/><br/>    chVarDis = tk.IntVar()<br/>    check1 = tk.Checkbutton(monty2, text="Disabled", <br/>    variable=chVarDis, state='disabled')<br/>    check1.select()<br/>    check1.grid(column=0, row=0, sticky=tk.W)    <br/>    chVarUn = tk.IntVar()<br/>    check2 = tk.Checkbutton(monty2, text="UnChecked", <br/>    variable=chVarUn)<br/>    check2.deselect()<br/>    check2.grid(column=1, row=0, sticky=tk.W )      <br/>    chVarEn = tk.IntVar()<br/>    check3 = tk.Checkbutton(monty2, text="Toggle", <br/>    variable=chVarEn)<br/>    check3.deselect()<br/>    check3.grid(column=2, row=0, sticky=tk.W) <br/><br/>    labelsFrame = ttk.LabelFrame(monty2, <br/>    text=' Labels in a Frame ')<br/>    labelsFrame.grid(column=0, row=7)     <br/><br/>    ttk.Label(labelsFrame, text="Label1").grid(column=0, row=0)<br/>    ttk.Label(labelsFrame, text="Label2").grid(column=0, row=1)    <br/><br/>    for child in labelsFrame.winfo_children(): <br/>        child.grid_configure(padx=8)        </pre>
<ol start="8">
<li>Create Tab Display Area 3:</li>
</ol>
<pre style="padding-left: 60px">def display_tab3():<br/>    monty3 = ttk.LabelFrame(display_area, text=' New Features ')<br/>    monty3.grid(column=0, row=0, padx=8, pady=4)   <br/><br/>    startRow = 4<br/>    for idx in range(24):<br/>        if idx &lt; 2: col = idx<br/>        else: col += 1<br/>        if not idx % 3: <br/>            startRow += 1<br/>            col = 0    <br/>        b = ttk.Button(monty3, text="Feature " + str(idx + 1)) <br/>        b.grid(column=col, row=startRow)         <br/><br/>    for child in monty3.winfo_children(): <br/>        child.grid_configure(padx=8)          </pre>
<ol start="9">
<li>Write the code to display a button for all other tabs:</li>
</ol>
<pre style="padding-left: 60px">def display_button(active_notebook, tab_no):<br/>    btn = ttk.Button(display_area, text=active_notebook +' - Tab '+ <br/>    tab_no, \ command= lambda: showinfo("Tab Display", <br/>    "Tab: " + tab_no) )<br/>    btn.grid(column=0, row=0, padx=8, pady=8) </pre>
<ol start="10">
<li>Create the notebook callback:</li>
</ol>
<pre style="padding-left: 60px">def notebook_callback(event):<br/>    clear_display_area()    <br/>    current_notebook = str(event.widget)<br/>    tab_no = str(event.widget.index("current") + 1)     <br/>    if current_notebook.endswith('notebook'):<br/>        active_notebook = 'Notebook 1'<br/>    elif current_notebook.endswith('notebook2'):<br/>        active_notebook = 'Notebook 2'<br/>    else:<br/>        active_notebook = ''        <br/>    if active_notebook is 'Notebook 1': <br/>        if tab_no == '1': display_tab1()<br/>        elif tab_no == '2': display_tab2()<br/>        elif tab_no == '3': display_tab3()<br/>        else: display_button(active_notebook, tab_no)<br/>    else:<br/>        display_button(active_notebook, tab_no)</pre>
<ol start="11">
<li>Create the GUI with the multiple notebooks:</li>
</ol>
<pre style="padding-left: 60px">win = tk.Tk()                 # Create instance <br/>win.title("Python GUI")       # Add title <br/>#------------------------------------------<br/>win_frame_multi_row_tabs = ttk.Frame(win)<br/>win_frame_multi_row_tabs.grid(column=0, row=0, sticky='W')<br/>display_area = ttk.Labelframe(win, text=' Tab Display Area ') <br/>display_area.grid(column=0, row=1, sticky='WE')<br/>note1 = ttk.Notebook(win_frame_multi_row_tabs)<br/>note1.grid(column=0, row=0)<br/>note2 = ttk.Notebook(win_frame_multi_row_tabs)<br/>note2.grid(column=0, row=1)<br/># create and add tabs to Notebooks<br/>for tab_no in range(5):<br/>    tab1 = ttk.Frame(note1, width=0, height=0) <br/>    # Create a tab for notebook 1<br/>    tab2 = ttk.Frame(note2, width=0, height=0) <br/>    # Create a tab for notebook 2<br/>    note1.add(tab1, text=' Tab {} '.format(tab_no + 1)) <br/>    # Add tab notebook 1<br/>    note2.add(tab2, text=' Tab {} '.format(tab_no + 1)) <br/>    # Add tab notebook 2<br/><br/># bind click-events to Notebooks <br/>note1.bind("&lt;ButtonRelease-1&gt;", notebook_callback)<br/>note2.bind("&lt;ButtonRelease-1&gt;", notebook_callback)<br/><br/>create_display_area()<br/>create_menu()<br/>display_tab1()<br/>#-------------<br/>win.mainloop() <br/>#-------------</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="12">
<li>Run the code, click on <span class="packt_screen">Tab 1</span>, and observe the following output:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/7d71405b-d650-46dc-a728-bdf6b98936e0.png" style="width:17.75em;height:23.75em;" width="281" height="376"/></p>
<ol start="13">
<li>Click on <span class="packt_screen">Tab 2</span>. You will see the following output:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/7af19d25-73a5-451e-8727-1e7b8dbb504a.png" style="width:20.42em;height:15.92em;" width="291" height="226"/></p>
<ol start="14">
<li>Click on <span class="packt_screen">Tab 3</span>. You will see the following output:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/021a189c-81f9-4215-9540-3478441f4576.png" style="width:18.17em;height:21.33em;" width="297" height="348"/></p>
<ol start="15">
<li>Click on <span class="packt_screen">Tab 4</span> in the second row and observe the following output:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/9aac87a8-00a5-424b-ae01-c32df2320085.png" style="width:15.75em;height:11.33em;" width="220" height="158"/></p>
<p class="mce-root"/>
<ol start="16">
<li>Click on <span class="packt_screen">Tab 5</span> in the first row and then click the button in <span class="packt_screen">Tab Display Area</span> to see the following output:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="image-border" src="Images/e8617474-ee5a-4b9f-bf40-8745996f6ffe.png" style="width:14.08em;height:20.42em;" width="257" height="373"/></p>
<p>Let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>In <span><kbd>GUI_Complexity_end_tab3_multiple_notebooks.py</kbd>, w</span>e use the grid layout manager to arrange the two frames we are creating, placing one above the other. Then, we create two notebooks and arrange them within the first frame:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="Images/258b406b-e5ab-41e9-8fa0-b30c36aecafb.png" style="width:28.92em;height:16.75em;" width="488" height="282"/></div>
<p class="CDPAlignLeft CDPAlign">Next, we use a loop to create five tabs and add them to each notebook:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="Images/b457857b-d8a7-4b9a-99f0-da56d27a4a87.png" style="width:42.75em;height:7.33em;" width="645" height="110"/></div>
<p class="CDPAlignLeft CDPAlign">We create a callback function and bind the click event of the two notebooks to this callback function. Now, when the user clicks on any tab belonging to the two notebooks, this callback function will be called:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="Images/84f8dce3-79b9-4519-94b2-ec11126d6bbb.png" style="width:25.75em;height:4.17em;" width="378" height="61"/></div>
<p class="CDPAlignLeft CDPAlign">In the callback function, we add logic that decides which widgets get displayed after clicking a tab:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="Images/7f8b9d09-ad12-4845-81ab-aba6fea756e8.png" style="width:24.83em;height:20.17em;" width="418" height="340"/></div>
<p class="CDPAlignLeft CDPAlign">We add a function that creates a display area and another function that clears the area:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="Images/350ad1f9-8c9a-4f2f-a35f-d6aec81700f1.png" style="width:34.58em;height:13.42em;" width="500" height="194"/></div>
<div class="CDPAlignLeft CDPAlign packt_infobox">Note how the <kbd>notebook_callback()</kbd> function calls the <kbd>clear_display_area()</kbd> function.</div>
<p class="CDPAlignLeft CDPAlign">The <kbd>clear_display_area()</kbd> <span>function knows both the row and column in which the widgets of tabs are being created, and, by finding row 0, we can then use <kbd>grid_forget()</kbd> to clear the display.</span></p>
<p class="CDPAlignLeft CDPAlign">For tabs 1 to 3 of the first notebook, we create new frames to hold more widgets. Clicking any of those three tabs then results in a GUI very similar to the one we created in the previous recipe.</p>
<p class="CDPAlignLeft CDPAlign">These first three tabs are being invoked in the callback function as <kbd>display_tab1()</kbd>, <kbd>display_tab2()</kbd>, and <kbd>display_tab3()</kbd> when those tabs are being clicked.</p>
<p class="CDPAlignLeft CDPAlign">Here is the code that runs when clicking on <span class="packt_screen">Tab 3</span> of the first notebook:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="Images/1ec681ba-6982-4420-be4f-5e23ef044bc7.png" style="width:26.92em;height:20.50em;" width="480" height="366"/></div>
<p class="CDPAlignLeft CDPAlign">Clicking any tab other than the first three tabs of the first notebook one calls the same function, <kbd>display_button()</kbd><span>,</span> which results in a button being displayed whose text property is being set to show the notebook and tab number:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="Images/af83e6d9-2b75-4d2a-9f84-28cb2333a558.png" style="width:37.42em;height:6.17em;" width="609" height="100"/></div>
<p class="CDPAlignLeft CDPAlign">Clicking any of these buttons results in a message box.</p>
<p class="CDPAlignLeft CDPAlign">At the end of the code, we invoke the <kbd>display_tab1()</kbd> function. When the GUI first starts up, the widgets of this tab are what get displayed in the display area:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="Images/e267007f-100b-4028-a483-cf12c566ab37.png" style="width:24.75em;height:12.92em;" width="399" height="209"/></div>
<p>Running the <kbd>GUI_Complexity_end_tab3_multiple_notebooks.py</kbd> code of this recipe creates the following GUI:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/c8e45837-4b5e-4cac-a8b2-27bd60a281db.png" style="width:17.75em;height:23.50em;" width="282" height="374"/></div>
<p class="CDPAlignLeft CDPAlign">Clicking on <span class="packt_screen">Tab 2</span> of the first notebook clears the tab display area and then displays the widgets created in the <kbd>display_tab2()</kbd> function:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/6e63dc49-32b4-4bb7-bbcb-0fb1b8fc4aaa.png" style="width:19.83em;height:15.58em;" width="292" height="229"/></div>
<div class="CDPAlignLeft CDPAlign packt_infobox">Note how the tab display area automatically adjusts to the sizes of the widgets being created.</div>
<p class="CDPAlignLeft CDPAlign">Clicking <span class="packt_screen">Tab 3</span> results in the following GUI display:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/c3c252af-465a-4b5b-b6c8-1fe713e59b45.png" style="width:19.00em;height:22.17em;" width="299" height="348"/></div>
<p class="CDPAlignLeft CDPAlign">Clicking any other tab in either the first or the second notebook results in a button being displayed in the tab display area:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/aa4bd375-b3e6-4eab-8887-9d40708136e2.png" style="width:15.25em;height:11.25em;" width="220" height="162"/></div>
<p class="CDPAlignLeft CDPAlign">Clicking any of those buttons results in a message box:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="Images/2584263f-6438-46f4-a55c-f9b6f6e18708.png" style="width:16.42em;height:23.83em;" width="257" height="373"/></div>
<p class="CDPAlignLeft CDPAlign">There is no limit to creating notebooks. We can create as many notebooks as our design requires.</p>


            </article>

            
        </section>
    </div>



  </body></html>