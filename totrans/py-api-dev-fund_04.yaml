- en: 4\. Authentication Services and Security with JWT
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 使用JWT进行认证服务和安全
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Apply your knowledge of JWT
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用JWT知识
- en: Create an access token using Flask-JWT-Extended
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flask-JWT-Extended创建访问令牌
- en: Develop a membership login system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发会员登录系统
- en: Implement an access control system (authentication and permissions)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现访问控制系统（认证和权限）
- en: Work with a refresh token
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用刷新令牌进行操作
- en: Restrict access using a blacklist
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用黑名单限制访问
- en: This chapter covers how to develop a user login/logout function using JWT.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何使用JWT开发用户登录/注销功能。
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we completed the database setup and configuration and
    linked the database to the code using ORM. We then implemented the user registration
    API on top of that. This chapter is divided into four parts. The first part is
    about authenticating the user and allowing them to log in to their own private
    profile page. The second part completes the recipe sharing system, allowing users
    to publish or unpublish their recipes. The third part shows how to refresh the
    security token and implement the logout feature. And finally, we will talk about
    how we can use the `blacklist` function to force the user to log out.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们完成了数据库的设置和配置，并使用ORM将数据库链接到代码中。然后我们在其基础上实现了用户注册API。本章分为四个部分。第一部分是关于用户认证并允许他们登录到自己的私有个人资料页面。第二部分完成了食谱分享系统，允许用户发布或取消发布他们的食谱。第三部分展示了如何刷新安全令牌并实现注销功能。最后，我们将讨论如何使用`blacklist`函数强制用户注销。
- en: User authentication is important in modern systems, especially if they are deployed
    on the internet. Thousands of users visit the same website, using the same web
    application. Without user authentication and access control, everything would
    be shared. Look at your Facebook/Instagram account – there are also user authentication
    and access controls implemented in the system. Only you can log in to your account
    and manage your posts and photos. For our Smilecook application, we will need
    the same feature.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 用户认证在现代系统中非常重要，尤其是如果它们部署在互联网上。数千名用户访问同一个网站，使用相同的Web应用程序。如果没有用户认证和访问控制，所有内容都会共享。看看你的Facebook/Instagram账户——系统中也实现了用户认证和访问控制。只有你才能登录到你的账户并管理你的帖子和个人照片。对于我们的Smilecook应用程序，我们同样需要这样的功能。
- en: We will start by discussing JWT.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论JWT。
- en: JWT
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JWT
- en: '**JWT** is used for user authentication and is passed between the user and
    the server. The full definition of the acronym is **JSON Web Token**. The way
    they work is to encode the user identity and sign it digitally, making it an unforgeable
    token that identifies the user, and the application can later control access for
    the user based on their identity.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**JWT**用于用户认证，并在用户和服务器之间传递。该缩写的全称是**JSON Web Token**。它们的工作方式是编码用户身份并对其进行数字签名，使其成为一个不可伪造的令牌，用于识别用户，并且应用程序可以根据用户的身份控制对用户的访问。'
- en: 'A JWT is a string composed of the header, payload, and signature. Those three
    parts are separated by a `.`. Here is an example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: JWT是一个由头部、载荷和签名组成的字符串。这三部分由`.`分隔。以下是一个示例：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The header of the `"alg": "HS256"`, and the encryption algorithm, `"typ": "JWT"`.
    We can see this clearly if we `base64` decode the header string:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`"alg": "HS256"`的头部，表示加密算法，`"typ": "JWT"`。如果我们对头部字符串进行`base64`解码，可以清楚地看到这一点：'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The content of the `base64` decode it and obtain the information inside. One
    important thing to note is that this information is not encrypted, therefore it
    is not recommended to store credit card details or passwords here:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 解码`base64`内容并获取其中的信息。需要注意的是，这些信息未加密，因此不建议在此处存储信用卡详情或密码：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `HS256` algorithm. The algorithm is encrypting the encoded header and payload
    data with a secret key that is known by the application server only. While anyone
    can modify the JWT content, that would result in a different signature, thus the
    data integrity is protected.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`HS256`算法。该算法使用只有应用程序服务器才知道的密钥加密编码的头部和载荷数据。尽管任何人都可以修改JWT内容，但这会导致不同的签名，从而保护数据完整性。'
- en: 'We can make use of the free service at [https://jwt.io/](https://jwt.io/) to
    have a better view of the structure and content in the JWT token:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用[https://jwt.io/](https://jwt.io/)提供的免费服务，更好地查看JWT令牌的结构和内容：
- en: '![Figure 4.1: The JWT website'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1：JWT网站'
- en: '](img/C15309_04_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C15309_04_01.jpg)'
- en: 'Figure 4.1: The JWT website'
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.1：JWT网站
- en: With a simple structure, `header.payload.secret`, we have a JWT, which will
    be used in this project for user authentication. Based on the user's identity,
    we can then apply access controls or other kinds of logic.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单的结构`header.payload.secret`，我们有一个JWT，它将在这个项目中用于用户认证。基于用户的身份，我们可以应用访问控制或其他类型的逻辑。
- en: Flask-JWT-Extended
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flask-JWT-Extended
- en: Flask-JWT-Extended is a user authentication package that provides the `create_access_token`
    function for making new access JWTs. It also provides the `jwt_required` decorator
    for protecting the API endpoints (for checking whether users have logged in).
    Also, `the get_jwt_identity()` function is provided to get the identity of a JWT
    in a protected endpoint. This allows us to know who the authenticated users are.
    This is an extremely useful package for user authentication.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-JWT-Extended是一个用户认证包，它提供了`create_access_token`函数来创建新的访问JWT。它还提供了`jwt_required`装饰器来保护API端点（用于检查用户是否已登录）。此外，还提供了`get_jwt_identity()`函数来获取受保护端点中JWT的身份。这使得我们可以知道谁是认证用户。这是一个非常实用的用户认证包。
- en: 'Before we dive into the coming exercise, let''s first discuss two very important
    key configurations that we will be using. They are as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入到即将到来的练习之前，让我们首先讨论两个我们将要使用的重要关键配置。它们如下：
- en: '**SECRET_KEY**: This is the key for encrypting the message and generating the
    signature. We recommend that you use a complex string.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SECRET_KEY**：这是加密消息和生成签名的密钥。我们建议您使用一个复杂的字符串。'
- en: '`msg`, but we are setting that to the `message` here.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`msg`，但我们在这里将其设置为`message`。'
- en: We will work on the user login function together in the next exercise. You will
    learn how user login works and how we can tell who the authenticated user is.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个练习中一起工作用户登录功能。您将了解用户登录的工作原理以及我们如何确定认证用户是谁。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on Flask-JWT-Extended, you can refer to this link: [https://flask-jwt-extended.readthedocs.io/en/latest/options.html](https://flask-jwt-extended.readthedocs.io/en/latest/options.html).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Flask-JWT-Extended的更多信息，您可以参考此链接：[https://flask-jwt-extended.readthedocs.io/en/latest/options.html](https://flask-jwt-extended.readthedocs.io/en/latest/options.html)。
- en: 'Exercise 24: Implementing a User Login Function'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习24：实现用户登录功能
- en: 'In this exercise, we will build the user login function. We will use the Flask-JWT-Extended
    package. Through this exercise, you will learn how we can generate JWTs in Flask.
    Users will enter their credentials in `http://localhost:5000/token` and they will
    get a token. They can then use that token to access `http://localhost:5000/users/{username}`
    and check their personal information registered in the system. If they don''t
    have the token, they will only see their own ID and username. This is the access
    control function of our Smilecook application:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将构建用户登录功能。我们将使用Flask-JWT-Extended包。通过这个练习，您将学习我们如何在Flask中生成JWT。用户将在`http://localhost:5000/token`中输入他们的凭据，然后他们将获得一个令牌。他们可以使用该令牌来访问`http://localhost:5000/users/{username}`并检查系统中注册的个人资料。如果没有令牌，他们将只能看到自己的ID和用户名。这是我们Smilecook应用程序的访问控制功能：
- en: 'Install the `Flask-JWT-Extended` package by adding the following lines in `requirements.txt`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`requirements.txt`文件中添加以下行来安装`Flask-JWT-Extended`包：
- en: '[PRE3]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the following command to install all of the necessary packages:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以安装所有必要的包：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should see the following installation result on the screen:'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该在屏幕上看到以下安装结果：
- en: '[PRE5]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Configure `Flask-JWT-Extended` by adding the following settings to the `Config`
    class in the `config.py` file:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`config.py`文件中的`Config`类中添加以下设置来配置`Flask-JWT-Extended`：
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Put the following code in `extension.py`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码放入`extension.py`：
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we are trying to create an instance of `Flask-JWT-Extended`. We first
    import the `JWTManager` class from `flask_jwt_extended`, then we instantiate a
    `Flask-JWT-Extended` instance by calling `JWTManager()`, and assign it to the
    `jwt` variable.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们试图创建一个`Flask-JWT-Extended`的实例。我们首先从`flask_jwt_extended`中导入`JWTManager`类，然后通过调用`JWTManager()`创建一个`Flask-JWT-Extended`实例，并将其分配给`jwt`变量。
- en: 'Type the following code in `app.py`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app.py`中输入以下代码：
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We first imported `jwt` from `extensions`, and then we initialized `jwt` with
    `jwt.init_app(app)` in `register_extensions(app)`.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先从`extensions`中导入`jwt`，然后在`register_extensions(app)`中通过`jwt.init_app(app)`初始化`jwt`。
- en: 'Now we will create the resource for the login. We will first create the `token.py`
    file in the `resources` folder and type in the following code. We first import
    all the necessary modules, functions, and classes:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建登录资源。我们首先在 `resources` 文件夹中创建 `token.py` 文件，并输入以下代码。我们首先导入所有必要的模块、函数和类：
- en: '[PRE9]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, define a class called `TokenResource`. This class inherits from `flask_restful.Resource`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个名为 `TokenResource` 的类。这个类继承自 `flask_restful.Resource`：
- en: '[PRE10]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inside the class, we create a `post` method. When a user logs in, this method
    will be invoked and it will take the `email` and `password` from the client JSON
    request. It will use the `get_by_email` method to verify the correctness of the
    user''s credentials:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类内部，我们创建了一个 `post` 方法。当用户登录时，此方法将被调用，并且它将从客户端 JSON 请求中获取 `email` 和 `password`。它将使用
    `get_by_email` 方法来验证用户的凭据是否正确：
- en: '[PRE11]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If they are invalid, the method will stop there and return `email or password
    is incorrect`. Otherwise, it will create an access token with the user id as the
    identity to the user.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果它们无效，该方法将停止并返回 `email 或 password is incorrect`。否则，它将创建一个带有用户 ID 作为身份的访问令牌。
- en: Note
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The way the `check_password` function works is by hashing the password the client
    passes in and comparing that hash value with the one stored in the database, using
    the `pbkdf2_sha256.verify(password, hashed)` function. There is no plaintext password
    comparison here.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`check_password` 函数的工作方式是通过散列客户端传递的密码，并使用 `pbkdf2_sha256.verify(password, hashed)`
    函数将散列值与数据库中存储的散列值进行比较。这里没有明文密码比较。'
- en: We will then create a new resource, which is for getting user details. If the
    user is not authenticated, they can only see their ID and username. Otherwise,
    they will see their personal email as well. We can add the following code to `resources/user.py`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个新的资源，用于获取用户详细信息。如果用户未认证，他们只能看到他们的 ID 和用户名。否则，他们还将看到他们的个人电子邮件。我们可以在
    `resources/user.py` 中添加以下代码：
- en: 'We first import the necessary modules, functions, and classes:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先导入必要的模块、函数和类：
- en: '[PRE12]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we define a `UserResource` class that inherits from `flask_restful.Resource`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个继承自 `flask_restful.Resource` 的 `UserResource` 类：
- en: '[PRE13]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this class, we define a `get` method and wrap it with a `jwt_optional` decorator.
    This implies that the endpoint is accessible regardless of the procession of the
    token:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个类中，我们定义了一个 `get` 方法，并用 `jwt_optional` 装饰器包装它。这意味着端点是无论令牌的处理过程如何都可以访问的：
- en: '[PRE14]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We then perform a similar routine to the previous step and check whether the
    `username` can be found in the database:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们执行与上一步类似的常规操作，检查 `username` 是否可以在数据库中找到：
- en: '[PRE15]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If it is found in the database, we will further check whether it matches the
    identity of the user ID in the JWT:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在数据库中找到，我们将进一步检查它是否与 JWT 中的用户 ID 身份匹配：
- en: '[PRE16]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Depending on the result in the previous step, we apply access control and output
    different information:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据上一步的结果，我们应用访问控制并输出不同的信息：
- en: '[PRE17]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we will import the resources we created in the previous steps and
    add them to the `api` in `app.py`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将导入之前创建的资源，并将它们添加到 `app.py` 中的 `api`：
- en: '[PRE18]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Right-click on it to run the application. **Flask** will then be started up
    and run on localhost (**127.0.0.1**) at port **5000**:![Figure 4.2: Run the application
    to start and run Flask on localhost'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击它以运行应用程序。**Flask** 将随后在本地主机（**127.0.0.1**）的 **5000** 端口启动并运行：![图 4.2：运行应用程序以在本地主机上启动和运行
    Flask
- en: '](img/C15309_04_02.jpg)'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_04_02.jpg)'
- en: 'Figure 4.2: Run the application to start and run Flask on localhost'
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.2：运行应用程序以在本地主机上启动和运行 Flask
- en: So, we have completed the user login function. This will allow users to visit
    the access-controlled APIs after login. Let's test it in our next exercise!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经完成了用户登录功能。这将使用户在登录后能够访问受控的 API。让我们在我们的下一个练习中测试它！
- en: 'Exercise 25: Testing the User Login Function'
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 25：测试用户登录功能
- en: 'In this exercise, we will test the login function and verify the user information
    stored in the database. We will also test that the user information obtained from
    the `http://localhost:5000/users/{username}` API is different before and after
    user login:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将测试登录功能并验证存储在数据库中的用户信息。我们还将测试从 `http://localhost:5000/users/{username}`
    API 获取的用户信息在用户登录前后是否不同：
- en: The first thing to do is to create a user. Click on the **Collections** tab
    and choose **POST** **UserList**.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先要做的事情是创建一个用户。点击 **Collections** 选项卡，选择 **POST** **UserList**。
- en: 'Select the **Body** tab, select the **raw** radio button, and choose **JSON
    (application/json)** from the drop-down list. Put in the following user details
    (JSON format) in the **Body** field:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Body** 选项卡，选择 **raw** 单选按钮，并从下拉列表中选择 **JSON (application/json)**。在 **Body**
    字段中输入以下用户详情（JSON 格式）：
- en: '[PRE19]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Click `"id": 3` here means that the user is the third successfully registered
    user.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '点击 `"id": 3` 这里表示该用户是成功注册的第三个用户。'
- en: We will then try to check the user information without logging in. Let's see
    what information we can get. Click on the `User`, and save it under the `User`
    folder.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将尝试在不登录的情况下检查用户信息。让我们看看我们能得到什么信息。点击 `User`，并将其保存到 `User` 文件夹下。
- en: Edit the request and put `http://localhost:5000/users/james` in the URL field.
    **Save** the request so that it can be reused later.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑请求，在 URL 字段中输入 `http://localhost:5000/users/james`。**保存**请求以便以后重用。
- en: 'Click **Send** to get the user details. The result is shown in the following
    screenshot:![Figure 4.4: Checking the user information without logging in'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Send** 获取用户详情。结果如下截图所示：![图 4.4：未登录时检查用户信息
- en: '](img/C15309_04_04.jpg)'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[图片](img/C15309_04_04.jpg)'
- en: 'Figure 4.4: Checking the user information without logging in'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.4：未登录时检查用户信息
- en: You will then see the response. The HTTP Status is **200 OK**, meaning the request
    has been successful. We can see the ID and username in the response body. However,
    we can't see the email address here because it is private information and is only
    visible to the authenticated user.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到响应。HTTP 状态是 **200 OK**，表示请求已成功。我们可以在响应体中看到 ID 和用户名。然而，我们在这里看不到电子邮件地址，因为它属于私人信息，并且只有经过认证的用户才能看到。
- en: Now, log in through the API. Click on the **Collections** tab. Create a new
    folder called **Token** and create a new request called **Token** inside it.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过 API 登录。点击 **Collections** 选项卡。创建一个名为 **Token** 的新文件夹，并在其中创建一个名为 **Token**
    的新请求。
- en: Edit the request, change the method to `http://localhost:5000/token` in the
    URL field.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑请求，将方法更改为 URL 字段中的 `http://localhost:5000/token`。
- en: 'Click the **Body** tab, check the **raw** radio button, and select **JSON (application/json)**
    in the drop-down menu. Type in the following JSON content in the **Body** field
    and click **Save**:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Body** 选项卡，检查 **raw** 单选按钮，并在下拉菜单中选择 **JSON (application/json)**。在 **Body**
    字段中输入以下 JSON 内容，然后点击 **Save**：
- en: '[PRE20]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Click **Send** to log in. The result is shown in the following screenshot:![Figure
    4.5: Checking the user information after creating tokens'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Send** 登录。结果如下截图所示：![图 4.5：创建令牌后检查用户信息
- en: '](img/C15309_04_05.jpg)'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[图片](img/C15309_04_05.jpg)'
- en: 'Figure 4.5: Checking the user information after creating tokens'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.5：创建令牌后检查用户信息
- en: You will then see the response. The HTTP status code **200** means the login
    has been successful. We can see the access token in the response body. We will
    rely on this token to show that the user has logged in.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到响应。HTTP 状态码 **200** 表示登录成功。我们可以在响应体中看到访问令牌。我们将依靠这个令牌来显示用户已经登录。
- en: Now check the user information again after we have logged in. Click the **Collections**
    tab and select the **GET User** request.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们登录后再次检查用户信息。点击 **Collections** 选项卡，并选择 **GET User** 请求。
- en: Select the `Bearer {token}` in the **VALUE** field, where the token is what
    we obtained in step 10.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **VALUE** 字段中选择 `Bearer {token}`，其中令牌是我们在第 10 步中获得的。
- en: 'Click **Send** to get the user details. The result is shown in the following
    screenshot:![Figure 4.6: Checking the user information after logging in'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Send** 获取用户详情。结果如下截图所示：![图 4.6：登录后检查用户信息
- en: '](img/C15309_04_06.jpg)'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[图片](img/C15309_04_06.jpg)'
- en: 'Figure 4.6: Checking the user information after logging in'
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.6：登录后检查用户信息
- en: You will then see the response, the HTTP status code **200** means the request
    is successful. And in the response body, we can see information including **id**,
    **username**, and **email**.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到响应，HTTP 状态码 **200** 表示请求成功。在响应体中，我们可以看到包括 **id**、**username** 和 **email**
    在内的信息。
- en: In this exercise, we can see how access control really works. We can see the
    difference in the HTTP response before and after the user is authenticated. This
    is very important for our Smilecook application because we want to protect our
    users' privacy. There is information that only certain authenticated users can
    see.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们可以看到访问控制是如何真正工作的。我们可以看到用户认证前后 HTTP 响应的差异。这对我们的 Smilecook 应用程序非常重要，因为我们想保护用户的隐私。有一些信息只有经过认证的用户才能看到。
- en: 'Exercise 26: Creating the me Endpoint'
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 26：创建 me 端点
- en: 'In this exercise, we will create a special endpoint, `/users/me`. That will
    allow us to get the authenticated user information back by using `access_token`.
    We will first create a new `resource` class under the `user` model. There will
    be a `get` method in it, and we will finally associate this with the new API endpoint:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个特殊的端点`/users/me`。这将允许我们通过`access_token`获取认证用户信息。我们首先在`user`模型下创建一个新的`resource`类。它将有一个`get`方法，最后我们将将其与新的API端点关联起来：
- en: 'Add the `get_by_id` method in `models/user.py`. For convenience''s sake, we
    will use this method to get the user object by ID:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`models/user.py`中添加`get_by_id`方法。为了方便起见，我们将使用此方法通过ID获取用户对象：
- en: '[PRE21]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In `resources/user.py`, import `jwt_required` and create a `MeResource` class:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`resources/user.py`中导入`jwt_required`并创建一个`MeResource`类：
- en: '[PRE22]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `get` method here will get the user information by the ID in the JWT.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里使用的`get`方法将通过JWT中的ID获取用户信息。
- en: 'In `app.py`, import the `MeResource` class. Add the `/me` endpoint:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app.py`中导入`MeResource`类。添加`/me`端点：
- en: '[PRE23]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Right-click on it to run the application. **Flask** will then be started up
    and run on localhost (**127.0.0.1**) at port **5000**:![Figure 4.7: Run the application
    to start and run the Flask on localhost'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击以运行应用程序。**Flask**将在本地主机（**127.0.0.1**）的**5000**端口启动并运行：![图4.7：运行应用程序以在本地主机上启动和运行Flask
- en: '](img/C15309_03_07.jpg)'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.7：运行应用程序以在本地主机上启动和运行Flask'
- en: 'Figure 4.7: Run the application to start and run the Flask on localhost'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.7：运行应用程序以在本地主机上启动和运行Flask
- en: Now check the user information again after we have logged in using the users/me
    endpoint. Click on the **Collections** tab and create a new request called **Me**
    in the **User** folder.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用users/me端点登录后，再次检查用户信息。点击**收藏夹**选项卡，在**用户**文件夹中创建一个名为**Me**的新请求。
- en: Put `http://localhost:5000/me` in the URL field.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在URL字段中输入`http://localhost:5000/me`。
- en: Select the `Bearer {token}` in the **VALUE** field, where the token is what
    we obtained in the previous exercise.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**值**字段中选择`Bearer {token}`，其中token是我们之前练习中获得的。
- en: 'Click **Send** to get the user details. The result is shown in the following
    screenshot:![Figure 4.8: Checking the user information after we have logged in'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送**以获取用户详情。结果如下截图所示：![图4.8：登录后检查用户信息
- en: '](img/C15309_04_08.jpg)'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.7：运行应用程序以在本地主机上启动和运行Flask'
- en: 'Figure 4.8: Checking the user information after we have logged in'
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.8：登录后检查用户信息
- en: This new API endpoint allows us to get the authenticated user information just
    by using the access token. This means that whenever the user is in the authenticated
    state, we can get their information. Now that we have pretty much figured out
    the users, let's work on the recipes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的API端点允许我们仅通过访问令牌获取认证用户信息。这意味着当用户处于认证状态时，我们可以获取他们的信息。现在我们已经基本了解了用户，让我们来处理食谱。
- en: Designing the Methods in the Recipe Model
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在食谱模型中设计方法
- en: 'Now, we have finished the user registration and login feature, we will work
    on the recipe management features of our Smilecook application. That will need
    a few methods in the `Recipe` class to do the work. In our design, we will have
    the following five methods:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了用户注册和登录功能，我们将着手处理Smilecook应用程序的食谱管理功能。这需要在`Recipe`类中实现一些方法。在我们的设计中，我们将有以下五种方法：
- en: '`data`: This is used to return the data in a dictionary format.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：这是用来以字典格式返回数据的。'
- en: '`get_all_published`: This method gets all the published recipes.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_all_published`：此方法获取所有已发布的食谱。'
- en: '`get_by_id`: This method gets the recipes by ID.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_by_id`：此方法通过ID获取食谱。'
- en: '`save`: This method persists data to the database.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`save`：此方法将数据持久化到数据库。'
- en: '`delete`: This method deletes data from the database.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete`：此方法从数据库中删除数据。'
- en: These five methods cover pretty much all the necessary recipe management functions.
    In the next exercise, we will work on implementing these methods in our Smilecook
    application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这五种方法涵盖了几乎所有必要的食谱管理功能。在下一个练习中，我们将实现这些方法在我们的Smilecook应用程序中。
- en: 'Exercise 27: Implementing Access-Controlled Recipe Management Functions'
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习27：实现受访问控制的食谱管理功能
- en: 'The aim of this exercise is to implement different recipe management functions
    on our platform so that users can manage their own recipes in our Smilecook application.
    We will also have to modify `RecipeListResource` and `RecipeResource` to restrict
    access to certain methods there:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目的是在我们的平台上实现不同的食谱管理功能，以便用户可以在我们的Smilecook应用程序中管理自己的食谱。我们还将修改`RecipeListResource`和`RecipeResource`以限制对某些方法的访问：
- en: 'In `models/recipe.py`, add the `data`, `get_all_published`, `get_by_id`, `save`,
    and `delete` methods to the `Recipe` class:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`models/recipe.py`中，向`Recipe`类添加`data`、`get_all_published`、`get_by_id`、`save`和`delete`方法：
- en: '[PRE24]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Delete the following code in `models/recipe.py`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`models/recipe.py`中删除以下代码：
- en: '[PRE25]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In `resources/recipe.py`, import `get_jwt_identity`, `jwt_required`, and `jwt_optional`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`resources/recipe.py`中导入`get_jwt_identity`、`jwt_required`和`jwt_optional`：
- en: '[PRE26]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Remove import `recipe_list`
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除导入`recipe_list`
- en: '[PRE27]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will then modify the `get` method in the `RecipeListResource` class. We
    will get all the published recipes by triggering `Recipe.get_all_published()`.Then,
    in the `for` loop, it iterates through the recipe list, converts each recipe into
    a dictionary object, and returns the dictionary list:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将修改`RecipeListResource`类中的`get`方法。我们将通过触发`Recipe.get_all_published()`来获取所有已发布的食谱。然后，在`for`循环中，它遍历食谱列表，将每个食谱转换为字典对象，并返回字典列表：
- en: '[PRE28]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We then continue to modify the `post` method in the `RecipeListResource` class.
    The `@jwt_required` decorator here says that the method can only be invoked after
    the user has logged in. Inside the method, it gets all the recipe details from
    the client requests and saves them in the database. Finally, it will return the
    data with an HTTP status code of **201 CREATED**:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续修改`RecipeListResource`类中的`post`方法。这里的`@jwt_required`装饰器表示该方法只能在用户登录后调用。在方法内部，它从客户端请求中获取所有食谱详情并将其保存到数据库中。最后，它将返回带有HTTP状态码**201
    CREATED**的数据：
- en: '[PRE29]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We will modify the `get` method in `RecipeResource` to get a specific recipe.
    The `@jwt_optional` decorator specifies that the JWT is optional. Inside the method,
    we use `Recipe.get_by_id(recipe_id=recipe_id)` to get the recipe. If the specific
    recipe is not found, we will return **404 NOT_FOUND**. If it is found, we will
    then change the user who owns the recipe and the status. There is access control
    here, so it will return **403 FORBIDDEN** or **200 OK** depending on the situation:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将修改`RecipeResource`中的`get`方法以获取特定的食谱。`@jwt_optional`装饰器指定JWT是可选的。在方法内部，我们使用`Recipe.get_by_id(recipe_id=recipe_id)`来获取食谱。如果找不到特定食谱，我们将返回**404
    NOT_FOUND**。如果找到了，然后更改食谱的所有者和状态。这里存在访问控制，所以它将根据情况返回**403 FORBIDDEN**或**200 OK**：
- en: '[PRE30]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We will modify the `put` method in `RecipeResource` to get a specific recipe.
    This `put` method is to update the recipe details. It will first check whether
    the recipe exists and whether the user has update privileges. If everything is
    okay, it will go ahead to update the recipe details and save it to the database:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将修改`RecipeResource`中的`put`方法以获取特定的食谱。这个`put`方法用于更新食谱详情。它将首先检查食谱是否存在以及用户是否有更新权限。如果一切正常，它将继续更新食谱详情并将其保存到数据库中：
- en: '[PRE31]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We will modify the `delete` method in `RecipeResource` to get a specific recipe.
    This is for deleting a recipe. The `@jwt_required` decorator implies that the
    JWT is required. When the user has logged in, they can access this path and delete
    the specified recipe if it exists:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将修改`RecipeResource`中的`delete`方法以获取特定的食谱。这是用于删除食谱的。`@jwt_required`装饰器意味着JWT是必需的。当用户登录时，他们可以访问此路径并删除存在的指定食谱：
- en: '[PRE32]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: So, in this exercise, we have implemented the recipe management functions and
    added access control to the resources. Now, only authorized users are allowed
    to manage their recipes. Let's test whether this is really the case in our next
    exercise.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个练习中，我们已经实现了食谱管理功能并添加了对资源的访问控制。现在，只有授权用户才能管理他们的食谱。让我们在下一个练习中测试一下这是否真的如此。
- en: 'Exercise 28: Testing the Recipe Management Functions'
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习28：测试食谱管理功能
- en: 'The aim of this exercise is to test all the recipe management functions using
    Postman. We registered an account in our previous exercise and logged in. We will
    use the same authenticated user to test adding, updating, and deleting recipes:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的目的是使用Postman测试所有食谱管理功能。我们在之前的练习中注册了一个账户并登录。我们将使用相同的认证用户来测试添加、更新和删除食谱：
- en: Create a recipe through our API. Click on the **Collections** tab and select
    the **POST RecipeList** request that we created previously.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过我们的API创建一个食谱。点击**Collections**标签，并选择我们之前创建的**POST RecipeList**请求。
- en: 'Go to the `Bearer {token}` in the **VALUE** field, where the token is the JWT
    token we got in our previous exercise. The result is shown in the following screenshot:![Figure
    4.9: Creating a recipe through the API'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**VALUE**字段中的`Bearer {token}`，这里的token是我们之前练习中获得的JWT token。结果如下所示：![图4.9：通过API创建食谱](img/C15309_04_09.jpg)
- en: '](img/C15309_04_09.jpg)'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.9：通过API创建食谱](img/C15309_04_09.jpg)'
- en: 'Figure 4.9: Creating a recipe through the API'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.9：通过API创建食谱
- en: 'Go to the **Body** tab and type in the following recipe details:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **Body** 选项卡并输入以下菜谱详情：
- en: '[PRE33]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Click `user_id` is **3**, which is the user ID of the currently authenticated
    user.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `user_id` 是 **3**，这是当前登录用户的用户 ID。
- en: Get the recipe with `id = 3` in the state that the user has logged in. Click
    on the **Collections** tab and select the **GET** recipe request that we created
    previously.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户登录的状态下获取 `id = 3` 的菜谱。点击 **Collections** 选项卡并选择我们之前创建的 **GET** 菜谱请求。
- en: Go to the `Bearer {token}` in the **VALUE** field, where the token is the JWT
    token we got in the previous exercise.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **VALUE** 字段中的 `Bearer {token}`，其中令牌是我们之前练习中获得的 JWT 令牌。
- en: 'Click **Send** to check the recipe. The result is shown in the following screenshot:![Figure
    4.11: Recipe with ID 3 after the user is logged in'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Send** 检查菜谱。结果如下截图所示：![图 4.11：用户登录后的 ID 为 3 的菜谱
- en: '](img/C15309_04_11.jpg)'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_04_11.jpg)'
- en: 'Figure 4.11: Recipe with ID 3 after the user is logged in'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.11：用户登录后的 ID 为 3 的菜谱
- en: You will then see the response. We can see the recipe details in the body. That
    is because the user is authenticated.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到响应。我们可以在正文中看到菜谱详情。那是因为用户已经经过身份验证。
- en: Get the recipe with `id = 3` in the state that the user has *not* logged in.
    The expected result is that we won't be able to see the unpublished recipe. Click
    on the **Collections** tab and select the **GET Recipe** request that we created
    previously.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户未登录的状态下获取 `id = 3` 的菜谱。预期结果是我们将无法看到未发布的菜谱。点击 **Collections** 选项卡并选择我们之前创建的
    **GET 菜谱** 请求。
- en: 'Go to the **Headers** tab and uncheck **Authorization**, meaning that we are
    not going to put in the JWT token. Click **Send** to check the recipe. The result
    is shown in the following screenshot:![Figure 4.12: Recipe with ID 3 and the user
    not logged in'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **Headers** 选项卡并取消选中 **Authorization**，这意味着我们不会输入 JWT 令牌。点击 **Send** 检查菜谱。结果如下截图所示：![图
    4.12：用户未登录时的 ID 为 3 的菜谱
- en: '](img/C15309_04_12.jpg)'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_04_12.jpg)'
- en: 'Figure 4.12: Recipe with ID 3 and the user not logged in'
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.12：用户未登录时的 ID 为 3 的菜谱
- en: You will then see the response; the HTTP status code is **403 FORBIDDEN**. This
    is because the recipe is unpublished and we have implemented access control on
    our API so that only authenticated users can see their own recipes in the draft.
    We see the message **Access is not allowed** because we have not logged in yet.
    The unpublished recipe is not available to the public.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到响应；HTTP 状态码是 **403 禁止**。这是因为菜谱尚未发布，我们在我们的 API 上实现了访问控制，以便只有经过身份验证的用户才能看到他们自己的草稿菜谱。因为我们还没有登录，所以我们看到消息
    **不允许访问**。未发布的菜谱对公众不可用。
- en: So, we have tested the access control recipe management functions. We can see
    how these can be used in real-world scenarios. Next, we will discuss refresh tokens,
    which are for keeping our users in the logged-in state.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经测试了访问控制菜谱管理功能。我们可以看到这些功能如何在现实场景中使用。接下来，我们将讨论刷新令牌，这是为了保持用户登录状态。
- en: Refresh Tokens
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刷新令牌
- en: For the sake of security, we often set an expiration time for our tokens (`flask-jwt-extended`
    defaults that to 15 minutes). Because a token will expire, we need a function
    to refresh it without users putting in their credentials again.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，我们通常为我们的令牌设置一个过期时间（`flask-jwt-extended` 默认为 15 分钟）。因为令牌会过期，我们需要一个函数来刷新它，而无需用户再次输入凭据。
- en: Flask-JWT-Extended provides refresh-token-related functions. A refresh token
    is a long-lived token that can be used to generate new access tokens. Please don't
    mix up refresh tokens and access tokens. A refresh token can only be used to obtain
    a new access token; it cannot be used as an access token to access restricted
    endpoints. For example, endpoints that have the `jwt_required()` or `jwt_optional()`
    decorators need an access token.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-JWT-Extended 提供了与刷新令牌相关的函数。刷新令牌是一个长期有效的令牌，可以用来生成新的访问令牌。请不要混淆刷新令牌和访问令牌。刷新令牌只能用来获取新的访问令牌；它不能用作访问令牌来访问受限制的端点。例如，具有
    `jwt_required()` 或 `jwt_optional()` 装饰器的端点需要一个访问令牌。
- en: 'Here''s a brief explanation of the refresh-token-related functions in Flask-JWT-Extended:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Flask-JWT-Extended 中与刷新令牌相关的函数的简要说明：
- en: '`create_access_token`: This function creates a new access token.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_access_token`: 这个函数创建一个新的访问令牌。'
- en: '`create_refresh_token`: This function creates a refresh token.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_refresh_token`: 这个函数创建一个刷新令牌。'
- en: '`jwt_refresh_token_required`: This is a decorator specifying that the refresh
    token is required.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jwt_refresh_token_required`: 这是一个指定需要刷新令牌的装饰器。'
- en: '`get_jwt_identity`: This function gets the user that holds the current access
    token.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_jwt_identity`：此函数获取持有当前访问令牌的用户。'
- en: You will learn more about these functions in the next exercise. We will also
    add a `fresh` attribute to our token. This `fresh` attribute will only be set
    to `True` when users get the token by putting in their credentials. When they
    simply refresh the token, they will get a token with `fresh = false`. The reason
    for a refresh token is that we would like to avoid users having to put their credentials
    in again and again. However, for some critical functions, for example, changing
    passwords, we will still require them to have a fresh token.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，你将了解更多关于这些函数的信息。我们还将为我们的令牌添加一个`fresh`属性。当用户通过输入凭证获取令牌时，此`fresh`属性将仅设置为`True`。当用户仅刷新令牌时，他们将获得一个`fresh
    = false`的令牌。刷新令牌的原因是我们希望避免用户反复输入他们的凭证。然而，对于一些关键功能，例如更改密码，我们仍然需要他们拥有一个新鲜的令牌。
- en: 'Exercise 29: Adding a Refresh Token Function'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习29：添加刷新令牌功能
- en: 'In this exercise, we will be adding a refresh token feature to our Smilecook
    application so that when the user''s access token expires, they can use the refresh
    token to obtain a new access token:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将向我们的Smilecook应用程序添加刷新令牌功能，以便当用户的访问令牌过期时，他们可以使用刷新令牌获取新的访问令牌：
- en: 'In `resources/token.py`, import the necessary functions from `flask_jwt_extended`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`resources/token.py`中，从`flask_jwt_extended`导入必要的函数：
- en: '[PRE34]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Modify the `post` method under `TokenResource` to generate a `token` and a
    `refresh_token` for the user:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`TokenResource`下的`post`方法以生成用户的`token`和`refresh_token`：
- en: '[PRE35]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We pass in the `fresh=True` parameter to the `create_access_token` function.
    We then invoke the `create_refresh_token` function to generate a `refresh` token.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将`fresh=True`参数传递给`create_access_token`函数。然后调用`create_refresh_token`函数生成刷新令牌。
- en: 'Add the `RefreshResource` class to `token.py`. Please add the following code:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`RefreshResource`类添加到`token.py`中。请添加以下代码：
- en: '[PRE36]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `@jwt_refresh_token_required` decorator specifies that this endpoint will
    require a `refresh` token. In this method, we are generating a token for the user
    with `fresh=false`.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`@jwt_refresh_token_required`装饰器指定此端点将需要刷新令牌。在此方法中，我们为用户生成一个`fresh=false`的令牌。'
- en: 'Finally, add the route for `RefreshResource`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加`RefreshResource`的路由：
- en: '[PRE37]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Save `app.py` and right-click on it to run the application. `127.0.0.1`) at
    port `5000`:![Figure 4.13: Run the application to start and run Flask on localhost'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`app.py`，然后右键单击它以运行应用程序。在端口`5000`上运行（`127.0.0.1`）：![图4.13：运行应用程序以在本地主机上启动和运行Flask]
- en: '](img/C15309_04_13.jpg)'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.13：运行应用程序以在本地主机上启动和运行Flask](img/C15309_04_13.jpg)'
- en: 'Figure 4.13: Run the application to start and run Flask on localhost'
  id: totrans-199
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.13：运行应用程序以在本地主机上启动和运行Flask
- en: Congratulations! We have just added the refresh token function. Let's move on
    to the testing part.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们刚刚添加了刷新令牌功能。让我们继续进行测试部分。
- en: 'Exercise 30: Obtaining a New Access Token Using a Refresh Token'
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习30：使用刷新令牌获取新的访问令牌
- en: 'In this exercise, we will be using Postman to log in to the user account and
    get the access token and refresh token. Later on, we will obtain a new access
    token by using the refresh token. This is to simulate a real-life scenario in
    which we want to keep the user logged in:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用Postman登录用户账户并获取访问令牌和刷新令牌。稍后，我们将使用刷新令牌获取新的访问令牌。这是为了模拟现实生活中的场景，我们希望保持用户登录状态：
- en: We will test logging first. Click on the **Collections** tab. Select the **POST
    Token** request that we created previously.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先测试日志记录功能。点击**集合**标签页。选择我们之前创建的**POST Token**请求。
- en: Check the **raw** radio button and select **JSON (application/json)** from the
    drop-down menu.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选中**原始**单选按钮，并从下拉菜单中选择**JSON (application/json)**。
- en: 'Add the following JSON content in the **Body** field:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**正文**字段中添加以下JSON内容：
- en: '[PRE38]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Click **Send** to login to the account. The result is shown in the following
    screenshot:![Figure 4.14: Testing the login'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送**以登录账户。结果如下截图所示：![图4.14：测试登录]
- en: '](img/C15309_04_14.jpg)'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.14：测试登录](img/C15309_04_14.jpg)'
- en: 'Figure 4.14: Testing the login'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.14：测试登录
- en: We can see that the HTTP status code is **200 OK**, meaning the login has been
    successful. We can also see the access token and refresh token in the body.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到HTTP状态码是**200 OK**，这意味着登录成功。我们还可以在正文看到访问令牌和刷新令牌。
- en: Next, we will get the `access` token by using the `refresh` token. Click on
    the **Collections** tab. Create a new request, name it **Refresh**, and save it
    in the **Token** folder.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用刷新令牌获取`access`令牌。点击**集合**标签页。创建一个新的请求，命名为**刷新**，并将其保存在**令牌**文件夹中。
- en: Select this new request and choose `http://localhost:5000/refresh` in the **URL**
    field.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择这个新的请求，并在 **URL** 字段中选择 `http://localhost:5000/refresh`。
- en: Go to the `Bearer {token}` in the **VALUE** field, where the token is the **JWT**
    we got in step 4.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **VALUE** 字段中的 `Bearer {token}` 处，其中令牌是我们第 4 步中获得的 **JWT**。
- en: 'Click **Send** to refresh the token. The result is shown in the following screenshot:![Figure
    4.15: Accessing the token using the refresh token'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **发送** 以刷新令牌。结果如下截图所示：![图 4.15：使用刷新令牌访问令牌
- en: '](img/C15309_04_15.jpg)'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_04_15.jpg)'
- en: 'Figure 4.15: Accessing the token using the refresh token'
  id: totrans-216
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.15：使用刷新令牌访问令牌
- en: We can see HTTP status **200 OK**, which means the request has been successful.
    And we can see the new access token in the response body. If the access token
    expires in the future, we can use a refresh token to obtain a new access token.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 HTTP 状态 **200 OK**，这意味着请求已成功。我们还可以在响应体中看到新的访问令牌。如果访问令牌将来过期，我们可以使用刷新令牌来获取新的访问令牌。
- en: The User Logout Mechanism
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户登出机制
- en: 'The Flask-JWT-Extended package supports the logout function. The way it works
    is to put the token into a blacklist when the user is logged out. A `token_in_blacklist_loader`
    to verify whether the user has logged out or not:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-JWT-Extended 包支持登出功能。其工作原理是在用户登出时将令牌放入黑名单。一个 `token_in_blacklist_loader`
    来验证用户是否已登出：
- en: '![Figure 4.16: The user logout mechanism using a blacklist'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.16：使用黑名单的用户登出机制'
- en: '](img/C15309_04_16.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C15309_04_16.jpg)'
- en: 'Figure 4.16: The user logout mechanism using a blacklist'
  id: totrans-222
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.16：使用黑名单的用户登出机制
- en: In the next exercise, we want you to try implementing this logout function.
    It will test your understanding of the login and logout flow.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们希望您尝试实现这个登出功能。这将测试您对登录和登出流程的理解。
- en: 'Exercise 31: Implementing the Logout Function'
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 31：实现登出功能
- en: 'In this exercise, we will implement the logout function. We will first declare
    a `black_list` to store all the **logged-out** access tokens. Later, when the
    user wants to visit the access-controlled API endpoints, we will first check whether
    the access token is still valid using the blacklist:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现登出功能。我们首先声明一个 `black_list` 来存储所有 **已登出** 的访问令牌。稍后，当用户想要访问受控的 API
    端点时，我们将首先使用黑名单检查访问令牌是否仍然有效：
- en: 'Import `get_raw_jwt`. In `resources/token.py`, we will import `jwt_required`
    and `get_raw_jwt` from `flask_jwt_extended`:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `get_raw_jwt`。在 `resources/token.py` 中，我们将从 `flask_jwt_extended` 导入 `jwt_required`
    和 `get_raw_jwt`：
- en: '[PRE39]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In `resources/token.py`, assign `set()` to `black_list`:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `resources/token.py` 中，将 `set()` 分配给 `black_list`：
- en: '[PRE40]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create the `RevokeResource` class and define the `post` method. We will apply
    the `@jwt_required` decorator here to control the access to this endpoint. In
    this method, we get the token using `get_raw_jwt()[''jti'']` and put it in the
    blacklist:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `RevokeResource` 类并定义 `post` 方法。我们将在这里应用 `@jwt_required` 装饰器以控制对端点的访问。在这个方法中，我们使用
    `get_raw_jwt()['jti']` 获取令牌并将其放入黑名单：
- en: '[PRE41]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We will then add the following code in `config.py`. As you can tell, we are
    enabling the blacklist feature and also telling the application to check both
    the `access` and `refresh` token:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `config.py` 中添加以下代码。正如你所见，我们正在启用黑名单功能，并告知应用程序检查 `access` 和 `refresh` 令牌：
- en: '[PRE42]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We will then import `RevokeResource` and `black_list` in `app.py`:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `app.py` 中导入 `RevokeResource` 和 `black_list`：
- en: '[PRE43]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, inside `register_extensions(app)`, we will add the following lines of
    code. This is to check whether the token is on the blacklist:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `register_extensions(app)` 内部，我们将添加以下代码行。这是为了检查令牌是否在黑名单上：
- en: '[PRE44]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, add the route in `register_resources`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `register_resources` 中添加路由：
- en: '[PRE45]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Save `app.py` and right-click on it to run the application. **Flask** will
    then be started up and run on localhost (**127.0.0.1**) at port **5000**:![Figure
    4.17: Run the application to start Flask'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 `app.py` 并右键单击它以运行应用程序。此时，**Flask** 将在本地主机（**127.0.0.1**）的端口 **5000** 上启动并运行：![图
    4.17：运行应用程序以启动 Flask
- en: '](img/C15309_04_17.jpg)'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_04_17.jpg)'
- en: 'Figure 4.17: Run the application to start Flask'
  id: totrans-242
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.17：运行应用程序以启动 Flask
- en: Once the server is started, that means we are ready to test our refresh token
    API.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器启动，这意味着我们已经准备好测试我们的刷新令牌 API。
- en: 'Exercise 32: Testing the Logout Function'
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 32：测试登出功能
- en: 'In this exercise, we are going to test the logout function that we have just
    implemented in the previous exercise. Once we have logged out, we will try accessing
    an access-controlled endpoint and make sure we no longer have access to it:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将测试我们在之前练习中刚刚实现的登出功能。一旦我们登出，我们将尝试访问受访问控制的端点，并确保我们不再有访问权限：
- en: We will log out from our application. Click on the **Collections** tab and create
    a new request, name it **Revoke**, and save it in the **Token** folder.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将登出我们的应用程序。点击**收藏**标签页，创建一个新的请求，命名为**撤销**，并将其保存在**令牌**文件夹中。
- en: Select this new request and choose `http://localhost:5000/revoke` in the URL
    field.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择这个新请求，并在URL字段中选择`http://localhost:5000/revoke`。
- en: Go to the `Bearer {token}` in the **VALUE** field, where the token is the JWT
    we got in the previous exercise.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**值**字段中的`Bearer {token}`处，其中令牌是我们之前练习中获得的JWT。
- en: 'Click **Send** to log out. The result is shown in the following screenshot:![Figure
    4.18: Logging out from the application'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送**以登出。结果如下截图所示：![图4.18：从应用程序中登出
- en: '](img/C15309_04_18.jpg)'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_04_18.jpg)'
- en: 'Figure 4.18: Logging out from the application'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.18：从应用程序中登出
- en: You will then see the response, HTTP status **200 OK**, meaning that the user
    has logged out successfully. Besides this, we can also see the message saying
    that the user has **successfully logged out**.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到响应，HTTP状态**200 OK**，这意味着用户已成功登出。除此之外，我们还可以看到消息说用户已**成功登出**。
- en: 'Log out again and see what happens. Click **Send** again, and you will then
    see the following response:![Figure 4.19: Logging out again'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次登出并查看发生了什么。再次点击**发送**，然后你会看到以下响应：![图4.19：再次登出
- en: '](img/C15309_04_19.jpg)'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_04_19.jpg)'
- en: 'Figure 4.19: Logging out again'
  id: totrans-255
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.19：再次登出
- en: We can see HTTP status **401 UNAUTHORIZED**, meaning the user doesn't have access
    to this endpoint because the original access token has already been placed on
    the blacklist. In the response body, we can see the message **Token has been revoked**,
    meaning the user has successfully logged out.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到HTTP状态**401未授权**，这意味着用户没有访问此端点的权限，因为原始访问令牌已经被列入黑名单。在响应体中，我们可以看到消息**令牌已被撤销**，这意味着用户已成功登出。
- en: 'Activity 7: Implementing Access Control on the publish/unpublish Recipe Function'
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动7：在发布/取消发布食谱功能上实现访问控制
- en: 'In this activity, we will implement access control on the `publish`/`unpublish`
    recipe API endpoint so that only authenticated users can `publish`/`unpublish`
    their own recipe. Follow these steps to complete the activity:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将对`publish`/`unpublish`食谱API端点实现访问控制，以便只有认证用户可以`publish`/`unpublish`自己的食谱。按照以下步骤完成活动：
- en: Modify the `put` method in `RecipePublishResource` to restrict access to authenticated
    users.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`RecipePublishResource`中的`put`方法以限制对认证用户的访问。
- en: Modify the `delete` method in `RecipePublishResource`.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`RecipePublishResource`中的`delete`方法。
- en: Log in to the user account and get the access token.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录用户账户并获取访问令牌。
- en: Publish the recipe with `id = 3` in the state that the user has logged in.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户已登录的状态下发布`id = 3`的食谱。
- en: Unpublish a recipe `id = 3` in the state that the user has logged in
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户已登录的状态下取消发布`id = 3`的食谱
- en: Note
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 307.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第307页找到。
- en: If you got everything right, congratulations! That means you have added access
    control to the publish and unpublish recipe function. Now, recipes are protected
    in the Smilecook application. Only the authors of the recipes can manage their
    own recipes now.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一切都做对了，恭喜你！这意味着你已经为发布和取消发布的食谱功能添加了访问控制。现在，食谱在Smilecook应用程序中受到保护。只有食谱的作者现在可以管理自己的食谱。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use Flask-JWT-Extended for access control.
    This is an important and fundamental feature that almost all online platforms
    will require. At the end of the chapter, we touched on the topic of maintaining
    the liveliness of a token. This is advanced but applicable knowledge that you
    will use in developing real-life RESTful APIs. In the next chapter, we will start
    to talk about data verification.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Flask-JWT-Extended进行访问控制。这是一个重要且基本的功能，几乎所有在线平台都将需要。在本章末尾，我们简要提到了维护令牌活跃性的话题。这是高级但实用的知识，你将在开发实际的RESTful
    API时使用。在下一章中，我们将开始讨论数据验证。
