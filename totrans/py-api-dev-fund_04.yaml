- en: 4\. Authentication Services and Security with JWT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Apply your knowledge of JWT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an access token using Flask-JWT-Extended
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop a membership login system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement an access control system (authentication and permissions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with a refresh token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restrict access using a blacklist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter covers how to develop a user login/logout function using JWT.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we completed the database setup and configuration and
    linked the database to the code using ORM. We then implemented the user registration
    API on top of that. This chapter is divided into four parts. The first part is
    about authenticating the user and allowing them to log in to their own private
    profile page. The second part completes the recipe sharing system, allowing users
    to publish or unpublish their recipes. The third part shows how to refresh the
    security token and implement the logout feature. And finally, we will talk about
    how we can use the `blacklist` function to force the user to log out.
  prefs: []
  type: TYPE_NORMAL
- en: User authentication is important in modern systems, especially if they are deployed
    on the internet. Thousands of users visit the same website, using the same web
    application. Without user authentication and access control, everything would
    be shared. Look at your Facebook/Instagram account â€“ there are also user authentication
    and access controls implemented in the system. Only you can log in to your account
    and manage your posts and photos. For our Smilecook application, we will need
    the same feature.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by discussing JWT.
  prefs: []
  type: TYPE_NORMAL
- en: JWT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**JWT** is used for user authentication and is passed between the user and
    the server. The full definition of the acronym is **JSON Web Token**. The way
    they work is to encode the user identity and sign it digitally, making it an unforgeable
    token that identifies the user, and the application can later control access for
    the user based on their identity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A JWT is a string composed of the header, payload, and signature. Those three
    parts are separated by a `.`. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The header of the `"alg": "HS256"`, and the encryption algorithm, `"typ": "JWT"`.
    We can see this clearly if we `base64` decode the header string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The content of the `base64` decode it and obtain the information inside. One
    important thing to note is that this information is not encrypted, therefore it
    is not recommended to store credit card details or passwords here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `HS256` algorithm. The algorithm is encrypting the encoded header and payload
    data with a secret key that is known by the application server only. While anyone
    can modify the JWT content, that would result in a different signature, thus the
    data integrity is protected.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make use of the free service at [https://jwt.io/](https://jwt.io/) to
    have a better view of the structure and content in the JWT token:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: The JWT website'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C15309_04_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.1: The JWT website'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With a simple structure, `header.payload.secret`, we have a JWT, which will
    be used in this project for user authentication. Based on the user's identity,
    we can then apply access controls or other kinds of logic.
  prefs: []
  type: TYPE_NORMAL
- en: Flask-JWT-Extended
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flask-JWT-Extended is a user authentication package that provides the `create_access_token`
    function for making new access JWTs. It also provides the `jwt_required` decorator
    for protecting the API endpoints (for checking whether users have logged in).
    Also, `the get_jwt_identity()` function is provided to get the identity of a JWT
    in a protected endpoint. This allows us to know who the authenticated users are.
    This is an extremely useful package for user authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we dive into the coming exercise, let''s first discuss two very important
    key configurations that we will be using. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SECRET_KEY**: This is the key for encrypting the message and generating the
    signature. We recommend that you use a complex string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msg`, but we are setting that to the `message` here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will work on the user login function together in the next exercise. You will
    learn how user login works and how we can tell who the authenticated user is.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For more information on Flask-JWT-Extended, you can refer to this link: [https://flask-jwt-extended.readthedocs.io/en/latest/options.html](https://flask-jwt-extended.readthedocs.io/en/latest/options.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 24: Implementing a User Login Function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will build the user login function. We will use the Flask-JWT-Extended
    package. Through this exercise, you will learn how we can generate JWTs in Flask.
    Users will enter their credentials in `http://localhost:5000/token` and they will
    get a token. They can then use that token to access `http://localhost:5000/users/{username}`
    and check their personal information registered in the system. If they don''t
    have the token, they will only see their own ID and username. This is the access
    control function of our Smilecook application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `Flask-JWT-Extended` package by adding the following lines in `requirements.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command to install all of the necessary packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following installation result on the screen:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure `Flask-JWT-Extended` by adding the following settings to the `Config`
    class in the `config.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Put the following code in `extension.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are trying to create an instance of `Flask-JWT-Extended`. We first
    import the `JWTManager` class from `flask_jwt_extended`, then we instantiate a
    `Flask-JWT-Extended` instance by calling `JWTManager()`, and assign it to the
    `jwt` variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Type the following code in `app.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We first imported `jwt` from `extensions`, and then we initialized `jwt` with
    `jwt.init_app(app)` in `register_extensions(app)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we will create the resource for the login. We will first create the `token.py`
    file in the `resources` folder and type in the following code. We first import
    all the necessary modules, functions, and classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, define a class called `TokenResource`. This class inherits from `flask_restful.Resource`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the class, we create a `post` method. When a user logs in, this method
    will be invoked and it will take the `email` and `password` from the client JSON
    request. It will use the `get_by_email` method to verify the correctness of the
    user''s credentials:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If they are invalid, the method will stop there and return `email or password
    is incorrect`. Otherwise, it will create an access token with the user id as the
    identity to the user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The way the `check_password` function works is by hashing the password the client
    passes in and comparing that hash value with the one stored in the database, using
    the `pbkdf2_sha256.verify(password, hashed)` function. There is no plaintext password
    comparison here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will then create a new resource, which is for getting user details. If the
    user is not authenticated, they can only see their ID and username. Otherwise,
    they will see their personal email as well. We can add the following code to `resources/user.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We first import the necessary modules, functions, and classes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we define a `UserResource` class that inherits from `flask_restful.Resource`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this class, we define a `get` method and wrap it with a `jwt_optional` decorator.
    This implies that the endpoint is accessible regardless of the procession of the
    token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then perform a similar routine to the previous step and check whether the
    `username` can be found in the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If it is found in the database, we will further check whether it matches the
    identity of the user ID in the JWT:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Depending on the result in the previous step, we apply access control and output
    different information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will import the resources we created in the previous steps and
    add them to the `api` in `app.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Right-click on it to run the application. **Flask** will then be started up
    and run on localhost (**127.0.0.1**) at port **5000**:![Figure 4.2: Run the application
    to start and run Flask on localhost'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_04_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.2: Run the application to start and run Flask on localhost'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: So, we have completed the user login function. This will allow users to visit
    the access-controlled APIs after login. Let's test it in our next exercise!
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 25: Testing the User Login Function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will test the login function and verify the user information
    stored in the database. We will also test that the user information obtained from
    the `http://localhost:5000/users/{username}` API is different before and after
    user login:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do is to create a user. Click on the **Collections** tab
    and choose **POST** **UserList**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **Body** tab, select the **raw** radio button, and choose **JSON
    (application/json)** from the drop-down list. Put in the following user details
    (JSON format) in the **Body** field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Click `"id": 3` here means that the user is the third successfully registered
    user.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will then try to check the user information without logging in. Let's see
    what information we can get. Click on the `User`, and save it under the `User`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the request and put `http://localhost:5000/users/james` in the URL field.
    **Save** the request so that it can be reused later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **Send** to get the user details. The result is shown in the following
    screenshot:![Figure 4.4: Checking the user information without logging in'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_04_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.4: Checking the user information without logging in'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: You will then see the response. The HTTP Status is **200 OK**, meaning the request
    has been successful. We can see the ID and username in the response body. However,
    we can't see the email address here because it is private information and is only
    visible to the authenticated user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, log in through the API. Click on the **Collections** tab. Create a new
    folder called **Token** and create a new request called **Token** inside it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the request, change the method to `http://localhost:5000/token` in the
    URL field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **Body** tab, check the **raw** radio button, and select **JSON (application/json)**
    in the drop-down menu. Type in the following JSON content in the **Body** field
    and click **Save**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Click **Send** to log in. The result is shown in the following screenshot:![Figure
    4.5: Checking the user information after creating tokens'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_04_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.5: Checking the user information after creating tokens'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: You will then see the response. The HTTP status code **200** means the login
    has been successful. We can see the access token in the response body. We will
    rely on this token to show that the user has logged in.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now check the user information again after we have logged in. Click the **Collections**
    tab and select the **GET User** request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Bearer {token}` in the **VALUE** field, where the token is what
    we obtained in step 10.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **Send** to get the user details. The result is shown in the following
    screenshot:![Figure 4.6: Checking the user information after logging in'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_04_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.6: Checking the user information after logging in'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You will then see the response, the HTTP status code **200** means the request
    is successful. And in the response body, we can see information including **id**,
    **username**, and **email**.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we can see how access control really works. We can see the
    difference in the HTTP response before and after the user is authenticated. This
    is very important for our Smilecook application because we want to protect our
    users' privacy. There is information that only certain authenticated users can
    see.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 26: Creating the me Endpoint'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a special endpoint, `/users/me`. That will
    allow us to get the authenticated user information back by using `access_token`.
    We will first create a new `resource` class under the `user` model. There will
    be a `get` method in it, and we will finally associate this with the new API endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `get_by_id` method in `models/user.py`. For convenience''s sake, we
    will use this method to get the user object by ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `resources/user.py`, import `jwt_required` and create a `MeResource` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `get` method here will get the user information by the ID in the JWT.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `app.py`, import the `MeResource` class. Add the `/me` endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Right-click on it to run the application. **Flask** will then be started up
    and run on localhost (**127.0.0.1**) at port **5000**:![Figure 4.7: Run the application
    to start and run the Flask on localhost'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_03_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.7: Run the application to start and run the Flask on localhost'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Now check the user information again after we have logged in using the users/me
    endpoint. Click on the **Collections** tab and create a new request called **Me**
    in the **User** folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put `http://localhost:5000/me` in the URL field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Bearer {token}` in the **VALUE** field, where the token is what
    we obtained in the previous exercise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **Send** to get the user details. The result is shown in the following
    screenshot:![Figure 4.8: Checking the user information after we have logged in'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_04_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.8: Checking the user information after we have logged in'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This new API endpoint allows us to get the authenticated user information just
    by using the access token. This means that whenever the user is in the authenticated
    state, we can get their information. Now that we have pretty much figured out
    the users, let's work on the recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the Methods in the Recipe Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we have finished the user registration and login feature, we will work
    on the recipe management features of our Smilecook application. That will need
    a few methods in the `Recipe` class to do the work. In our design, we will have
    the following five methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data`: This is used to return the data in a dictionary format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_all_published`: This method gets all the published recipes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_by_id`: This method gets the recipes by ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`save`: This method persists data to the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete`: This method deletes data from the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These five methods cover pretty much all the necessary recipe management functions.
    In the next exercise, we will work on implementing these methods in our Smilecook
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 27: Implementing Access-Controlled Recipe Management Functions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The aim of this exercise is to implement different recipe management functions
    on our platform so that users can manage their own recipes in our Smilecook application.
    We will also have to modify `RecipeListResource` and `RecipeResource` to restrict
    access to certain methods there:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `models/recipe.py`, add the `data`, `get_all_published`, `get_by_id`, `save`,
    and `delete` methods to the `Recipe` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Delete the following code in `models/recipe.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `resources/recipe.py`, import `get_jwt_identity`, `jwt_required`, and `jwt_optional`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remove import `recipe_list`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will then modify the `get` method in the `RecipeListResource` class. We
    will get all the published recipes by triggering `Recipe.get_all_published()`.Then,
    in the `for` loop, it iterates through the recipe list, converts each recipe into
    a dictionary object, and returns the dictionary list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then continue to modify the `post` method in the `RecipeListResource` class.
    The `@jwt_required` decorator here says that the method can only be invoked after
    the user has logged in. Inside the method, it gets all the recipe details from
    the client requests and saves them in the database. Finally, it will return the
    data with an HTTP status code of **201 CREATED**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will modify the `get` method in `RecipeResource` to get a specific recipe.
    The `@jwt_optional` decorator specifies that the JWT is optional. Inside the method,
    we use `Recipe.get_by_id(recipe_id=recipe_id)` to get the recipe. If the specific
    recipe is not found, we will return **404 NOT_FOUND**. If it is found, we will
    then change the user who owns the recipe and the status. There is access control
    here, so it will return **403 FORBIDDEN** or **200 OK** depending on the situation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will modify the `put` method in `RecipeResource` to get a specific recipe.
    This `put` method is to update the recipe details. It will first check whether
    the recipe exists and whether the user has update privileges. If everything is
    okay, it will go ahead to update the recipe details and save it to the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will modify the `delete` method in `RecipeResource` to get a specific recipe.
    This is for deleting a recipe. The `@jwt_required` decorator implies that the
    JWT is required. When the user has logged in, they can access this path and delete
    the specified recipe if it exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, in this exercise, we have implemented the recipe management functions and
    added access control to the resources. Now, only authorized users are allowed
    to manage their recipes. Let's test whether this is really the case in our next
    exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 28: Testing the Recipe Management Functions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The aim of this exercise is to test all the recipe management functions using
    Postman. We registered an account in our previous exercise and logged in. We will
    use the same authenticated user to test adding, updating, and deleting recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a recipe through our API. Click on the **Collections** tab and select
    the **POST RecipeList** request that we created previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the `Bearer {token}` in the **VALUE** field, where the token is the JWT
    token we got in our previous exercise. The result is shown in the following screenshot:![Figure
    4.9: Creating a recipe through the API'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_04_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.9: Creating a recipe through the API'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Go to the **Body** tab and type in the following recipe details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click `user_id` is **3**, which is the user ID of the currently authenticated
    user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the recipe with `id = 3` in the state that the user has logged in. Click
    on the **Collections** tab and select the **GET** recipe request that we created
    previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `Bearer {token}` in the **VALUE** field, where the token is the JWT
    token we got in the previous exercise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **Send** to check the recipe. The result is shown in the following screenshot:![Figure
    4.11: Recipe with ID 3 after the user is logged in'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_04_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.11: Recipe with ID 3 after the user is logged in'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: You will then see the response. We can see the recipe details in the body. That
    is because the user is authenticated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Get the recipe with `id = 3` in the state that the user has *not* logged in.
    The expected result is that we won't be able to see the unpublished recipe. Click
    on the **Collections** tab and select the **GET Recipe** request that we created
    previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the **Headers** tab and uncheck **Authorization**, meaning that we are
    not going to put in the JWT token. Click **Send** to check the recipe. The result
    is shown in the following screenshot:![Figure 4.12: Recipe with ID 3 and the user
    not logged in'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_04_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.12: Recipe with ID 3 and the user not logged in'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You will then see the response; the HTTP status code is **403 FORBIDDEN**. This
    is because the recipe is unpublished and we have implemented access control on
    our API so that only authenticated users can see their own recipes in the draft.
    We see the message **Access is not allowed** because we have not logged in yet.
    The unpublished recipe is not available to the public.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have tested the access control recipe management functions. We can see
    how these can be used in real-world scenarios. Next, we will discuss refresh tokens,
    which are for keeping our users in the logged-in state.
  prefs: []
  type: TYPE_NORMAL
- en: Refresh Tokens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the sake of security, we often set an expiration time for our tokens (`flask-jwt-extended`
    defaults that to 15 minutes). Because a token will expire, we need a function
    to refresh it without users putting in their credentials again.
  prefs: []
  type: TYPE_NORMAL
- en: Flask-JWT-Extended provides refresh-token-related functions. A refresh token
    is a long-lived token that can be used to generate new access tokens. Please don't
    mix up refresh tokens and access tokens. A refresh token can only be used to obtain
    a new access token; it cannot be used as an access token to access restricted
    endpoints. For example, endpoints that have the `jwt_required()` or `jwt_optional()`
    decorators need an access token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a brief explanation of the refresh-token-related functions in Flask-JWT-Extended:'
  prefs: []
  type: TYPE_NORMAL
- en: '`create_access_token`: This function creates a new access token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create_refresh_token`: This function creates a refresh token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jwt_refresh_token_required`: This is a decorator specifying that the refresh
    token is required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_jwt_identity`: This function gets the user that holds the current access
    token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will learn more about these functions in the next exercise. We will also
    add a `fresh` attribute to our token. This `fresh` attribute will only be set
    to `True` when users get the token by putting in their credentials. When they
    simply refresh the token, they will get a token with `fresh = false`. The reason
    for a refresh token is that we would like to avoid users having to put their credentials
    in again and again. However, for some critical functions, for example, changing
    passwords, we will still require them to have a fresh token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 29: Adding a Refresh Token Function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will be adding a refresh token feature to our Smilecook
    application so that when the user''s access token expires, they can use the refresh
    token to obtain a new access token:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `resources/token.py`, import the necessary functions from `flask_jwt_extended`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `post` method under `TokenResource` to generate a `token` and a
    `refresh_token` for the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We pass in the `fresh=True` parameter to the `create_access_token` function.
    We then invoke the `create_refresh_token` function to generate a `refresh` token.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the `RefreshResource` class to `token.py`. Please add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `@jwt_refresh_token_required` decorator specifies that this endpoint will
    require a `refresh` token. In this method, we are generating a token for the user
    with `fresh=false`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, add the route for `RefreshResource`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save `app.py` and right-click on it to run the application. `127.0.0.1`) at
    port `5000`:![Figure 4.13: Run the application to start and run Flask on localhost'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_04_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.13: Run the application to start and run Flask on localhost'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Congratulations! We have just added the refresh token function. Let's move on
    to the testing part.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 30: Obtaining a New Access Token Using a Refresh Token'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will be using Postman to log in to the user account and
    get the access token and refresh token. Later on, we will obtain a new access
    token by using the refresh token. This is to simulate a real-life scenario in
    which we want to keep the user logged in:'
  prefs: []
  type: TYPE_NORMAL
- en: We will test logging first. Click on the **Collections** tab. Select the **POST
    Token** request that we created previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **raw** radio button and select **JSON (application/json)** from the
    drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following JSON content in the **Body** field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Click **Send** to login to the account. The result is shown in the following
    screenshot:![Figure 4.14: Testing the login'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_04_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.14: Testing the login'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: We can see that the HTTP status code is **200 OK**, meaning the login has been
    successful. We can also see the access token and refresh token in the body.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we will get the `access` token by using the `refresh` token. Click on
    the **Collections** tab. Create a new request, name it **Refresh**, and save it
    in the **Token** folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select this new request and choose `http://localhost:5000/refresh` in the **URL**
    field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `Bearer {token}` in the **VALUE** field, where the token is the **JWT**
    we got in step 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **Send** to refresh the token. The result is shown in the following screenshot:![Figure
    4.15: Accessing the token using the refresh token'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_04_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.15: Accessing the token using the refresh token'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can see HTTP status **200 OK**, which means the request has been successful.
    And we can see the new access token in the response body. If the access token
    expires in the future, we can use a refresh token to obtain a new access token.
  prefs: []
  type: TYPE_NORMAL
- en: The User Logout Mechanism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Flask-JWT-Extended package supports the logout function. The way it works
    is to put the token into a blacklist when the user is logged out. A `token_in_blacklist_loader`
    to verify whether the user has logged out or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16: The user logout mechanism using a blacklist'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C15309_04_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.16: The user logout mechanism using a blacklist'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the next exercise, we want you to try implementing this logout function.
    It will test your understanding of the login and logout flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 31: Implementing the Logout Function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will implement the logout function. We will first declare
    a `black_list` to store all the **logged-out** access tokens. Later, when the
    user wants to visit the access-controlled API endpoints, we will first check whether
    the access token is still valid using the blacklist:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `get_raw_jwt`. In `resources/token.py`, we will import `jwt_required`
    and `get_raw_jwt` from `flask_jwt_extended`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `resources/token.py`, assign `set()` to `black_list`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `RevokeResource` class and define the `post` method. We will apply
    the `@jwt_required` decorator here to control the access to this endpoint. In
    this method, we get the token using `get_raw_jwt()[''jti'']` and put it in the
    blacklist:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will then add the following code in `config.py`. As you can tell, we are
    enabling the blacklist feature and also telling the application to check both
    the `access` and `refresh` token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will then import `RevokeResource` and `black_list` in `app.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, inside `register_extensions(app)`, we will add the following lines of
    code. This is to check whether the token is on the blacklist:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the route in `register_resources`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save `app.py` and right-click on it to run the application. **Flask** will
    then be started up and run on localhost (**127.0.0.1**) at port **5000**:![Figure
    4.17: Run the application to start Flask'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_04_17.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.17: Run the application to start Flask'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Once the server is started, that means we are ready to test our refresh token
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 32: Testing the Logout Function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to test the logout function that we have just
    implemented in the previous exercise. Once we have logged out, we will try accessing
    an access-controlled endpoint and make sure we no longer have access to it:'
  prefs: []
  type: TYPE_NORMAL
- en: We will log out from our application. Click on the **Collections** tab and create
    a new request, name it **Revoke**, and save it in the **Token** folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select this new request and choose `http://localhost:5000/revoke` in the URL
    field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `Bearer {token}` in the **VALUE** field, where the token is the JWT
    we got in the previous exercise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **Send** to log out. The result is shown in the following screenshot:![Figure
    4.18: Logging out from the application'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_04_18.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.18: Logging out from the application'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: You will then see the response, HTTP status **200 OK**, meaning that the user
    has logged out successfully. Besides this, we can also see the message saying
    that the user has **successfully logged out**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Log out again and see what happens. Click **Send** again, and you will then
    see the following response:![Figure 4.19: Logging out again'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_04_19.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.19: Logging out again'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can see HTTP status **401 UNAUTHORIZED**, meaning the user doesn't have access
    to this endpoint because the original access token has already been placed on
    the blacklist. In the response body, we can see the message **Token has been revoked**,
    meaning the user has successfully logged out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 7: Implementing Access Control on the publish/unpublish Recipe Function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will implement access control on the `publish`/`unpublish`
    recipe API endpoint so that only authenticated users can `publish`/`unpublish`
    their own recipe. Follow these steps to complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify the `put` method in `RecipePublishResource` to restrict access to authenticated
    users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `delete` method in `RecipePublishResource`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in to the user account and get the access token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the recipe with `id = 3` in the state that the user has logged in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unpublish a recipe `id = 3` in the state that the user has logged in
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 307.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you got everything right, congratulations! That means you have added access
    control to the publish and unpublish recipe function. Now, recipes are protected
    in the Smilecook application. Only the authors of the recipes can manage their
    own recipes now.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use Flask-JWT-Extended for access control.
    This is an important and fundamental feature that almost all online platforms
    will require. At the end of the chapter, we touched on the topic of maintaining
    the liveliness of a token. This is advanced but applicable knowledge that you
    will use in developing real-life RESTful APIs. In the next chapter, we will start
    to talk about data verification.
  prefs: []
  type: TYPE_NORMAL
