<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer030">
<h1 class="chapter-number" id="_idParaDest-15"><a id="_idTextAnchor014"/>1</h1>
<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Understanding the Raspberry Pi</h1>
<p>Welcome to the wonderful <a id="_idIndexMarker000"/>world of <strong class="bold">Internet of Things</strong> (<strong class="bold">IoT</strong>) projects and the Raspberry Pi in this, the second edition of <em class="italic">Internet of Things </em><span class="No-Break"><em class="italic">Programming Projects</em></span><span class="No-Break">.</span></p>
<p>In this book, we will take a journey into IoT projects using the Raspberry Pi. In the first part of this book, we’ll explore IoT projects on the Raspberry Pi, initially transforming it into a weather station with the Sense HAT to capture real-time data. Later, we’ll use motors and <strong class="bold">general-purpose input/output</strong> (<strong class="bold">GPIO</strong>) pins to repurpose the Pi as an analog<a id="_idIndexMarker001"/> <span class="No-Break">metering device.</span></p>
<p> We will then create an IoT home security system, using the Raspberry Pi as the central hub for an alarm system. We’ll also develop a LoRa-enabled IoT monitoring station for remote sensing. The book culminates with our most ambitious project: building an IoT robot car powered by the <span class="No-Break">Raspberry Pi.</span></p>
<p>We will start this chapter by exploring the various Raspberry Pi models and their significance, observing the evolution and advancements in processing power, memory, and capabilities <span class="No-Break">over time.</span></p>
<p>We will also look at alternatives to the Raspberry Pi available in the IoT landscape, enabling us to make informed decisions based on our project requirements. We compare these alternatives with the Raspberry Pi, highlighting their unique specifications <span class="No-Break">and capabilities.</span></p>
<p>Furthermore, we dive into Raspberry Pi’s <strong class="bold">Hardware Attached on Top</strong> (<strong class="bold">HAT</strong>), which expands the Raspberry Pi’s <a id="_idIndexMarker002"/>capabilities through add-on boards. Specifically, we explore the Pibrella HAT and the Raspberry Pi Sense HAT, highlighting their ability to enhance the Raspberry Pi with additional features <span class="No-Break">and functionalities.</span></p>
<p>Our Sense HAT projects will make use of an optional custom Raspberry Pi case we see in <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.1</em>. This case allows us to display our Raspberry Pi in a vertical format and make use of the dot matrix display on the Sense HAT. The build files for the Raspberry Pi 4B and Raspberry Pi 5 versions’ case are available in the GitHub repository for <span class="No-Break">the book.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer008">
<img alt="Figure 1.1 – Raspberry Pi 4B and Sense HAT in a custom case" height="592" src="image/B21282_01_1.jpg" width="826"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Raspberry Pi 4B and Sense HAT in a custom case</p>
<p>We will also <a id="_idIndexMarker003"/>discuss a range of operating systems compatible with the<a id="_idIndexMarker004"/> Raspberry Pi beyond the official Raspberry Pi OS. These options cater to various applications, including networked audio systems, aviation-related projects, retro gaming, and <span class="No-Break">3D printing.</span></p>
<p>In the context of IoT applications, we will highlight the Raspberry Pi’s versatility and power as it serves as an optimal platform for processing real-time data and controlling physical devices, pivotal in the development and deployment of versatile <span class="No-Break">IoT projects.</span></p>
<p>Finally, we will explore the Raspberry Pi as a robust development platform, equipped with pre-installed tools for software development. We conclude the chapter with a series of programming projects using the Raspberry Pi with the Sense HAT to extract sensory information as we build a scrolling environmental <span class="No-Break">data display.</span></p>
<p>Our hands-on dive into programming in this chapter will fine-tune our programming abilities and ready us for exciting IoT project development throughout this book. Although there is a lot of information that is covered in this chapter, we should not worry if we feel overwhelmed or if we can’t digest all the information from the first chapter right away. As we progress through the book, we will gain more experience and understanding, making it easier to grasp the concepts introduced <span class="No-Break">early on.</span></p>
<p>We will cover <span class="No-Break">the following:</span></p>
<ul>
<li>Exploring Raspberry <span class="No-Break">Pi models</span></li>
<li>Exploring alternatives to the <span class="No-Break">Raspberry Pi</span></li>
<li>Looking at the power <span class="No-Break">of HATs</span></li>
<li>Investigating operating systems for the <span class="No-Break">Raspberry Pi</span></li>
<li>Using the Raspberry Pi <span class="No-Break">for IoT</span></li>
<li>Getting started with Raspberry <span class="No-Break">Pi development</span></li>
</ul>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Technical requirements</h1>
<p>The following are required to complete <span class="No-Break">this chapter:</span></p>
<ul>
<li>Late-model Raspberry Pi, such as the Raspberry Pi 5 4/8 GB model or Raspberry Pi 4B 4/8 <span class="No-Break">GB model</span></li>
<li>Keyboard, mouse, <span class="No-Break">and monitor</span></li>
<li>Raspberry Pi Sense HAT is optional but encouraged; we will be making use of the Sense HAT <span class="No-Break">software emulator</span></li>
</ul>
<p>The GitHub repository for the chapter is located <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter1"><span class="No-Break">https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter1</span></a><span class="No-Break">.</span></p>
<p>For those that have access to a 3D printer or 3D printing service, there are <strong class="source-inline">.stl</strong> files available in the <strong class="source-inline">Build Files</strong> directory of this chapter’s GitHub repository for the construction of the optional custom case. Files are available for the Raspberry Pi 5 and Raspberry Pi 4B versions of <span class="No-Break">the case.</span></p>
<p>A general knowledge of programming is also required. We will be using the Python programming language in this book. We will start with basic code and work our way toward more advanced coding as we go through the projects in <span class="No-Break">the book.</span></p>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Exploring Raspberry Pi models</h1>
<p>Every Raspberry Pi model, from the<a id="_idIndexMarker005"/> initial Raspberry Pi 1 to the current Raspberry Pi 5 and the<a id="_idIndexMarker006"/> compact Pi Zero, possesses distinct characteristics and functionalities that make it an exciting choice for IoT developers. Each model excels in different areas, such as processing power, size, and <span class="No-Break">energy efficiency.</span></p>
<p>The Raspberry Pi models have evolved significantly over time, with each iteration bringing notable advancements in processing power, memory, <span class="No-Break">and capabilities.</span></p>
<p>In the following list, we compare the various models of the Raspberry Pi, starting with the <span class="No-Break">first one:</span></p>
<ul>
<li><strong class="bold">Raspberry Pi 1</strong>: Launched in<a id="_idIndexMarker007"/> February 2012, the Raspberry Pi 1 changed the world of computing with its affordability and accessibility. Equipped with a 700 MHz processor, 512 MB RAM, and a $35 price point, the first model of the Raspberry Pi spurred digital innovation and highlighted the potential of <span class="No-Break">single-board computers.</span></li>
<li><strong class="bold">Raspberry Pi 2</strong>: Released in February 2015, the Raspberry Pi 2 improved on the first model with a 900 MHz quad-core processor and doubled RAM at 1 GB. The Raspberry Pi 2 also expanded the GPIO from 26 to 40 pins, allowing for a new wave of 40-pin HATs. These advancements allowed the Raspberry Pi 2 to become a hub for complex projects, from robotics to <span class="No-Break">IoT applications.</span></li>
<li><strong class="bold">Raspberry Pi 3</strong>: Released in February 2016, the Raspberry Pi 3 sported a 1.2 GHz quad-core processor. This improved performance by 50-60% and enabled more resource-intensive applications. Like the Raspberry Pi 2, it maintained 1 GB RAM. Wi-Fi and Bluetooth 4.1 were integrated, simplifying connectivity and freeing USB ports (a USB Wi-Fi dongle was required on the Raspberry Pi 2). A new dual-core VideoCore IV GPU enhanced multimedia projects with improved video capabilities. <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.2</em> provides a layout of a Raspberry Pi 3, highlighting several of its <span class="No-Break">key components:</span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer009">
<img alt="Figure 1.2 – Raspberry Pi 3B" height="395" src="image/B21282_01_2.jpg" width="620"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Raspberry Pi 3B</p>
<ul>
<li><strong class="bold">Raspberry Pi 4</strong>: Unveiled in June 2019, the Raspberry Pi 4 marked a significant evolution in the series, pushing the boundaries of single-board computers closer to conventional desktop PCs in terms of capabilities, all while preserving its compact size and<a id="_idIndexMarker008"/> affordability. What set the Pi 4 apart <a id="_idIndexMarker009"/>was the variety of memory options it offered, 2 GB, 4 GB, and 8 GB LPDDR4-3200 SDRAM, a substantial improvement over the previous 1 GB LPDDR2 RAM, enabling smoother multitasking and handling of data-intensive tasks. Improved connectivity featured Gigabit Ethernet, dual-band 802.11ac Wi-Fi, and Bluetooth 5.0. Its multimedia capabilities saw a boost with two micro-HDMI ports supporting 4K resolution, allowing the operation of two monitors at once. The Raspberry Pi 4 introduced two USB 3.0 ports for quicker data transfer and replaced the micro-USB power connector with a USB-C, supporting its enhanced features. In <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.3</em>, we see a layout of a Raspberry Pi 4 with several of its key <span class="No-Break">components highlighted:</span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer010">
<img alt="Figure 1.3 – Raspberry 4B" height="562" src="image/B21282_01_3.jpg" width="919"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Raspberry 4B</p>
<p class="list-inset">The Raspberry Pi 4 includes two micro-HDMI ports (for dual displays), four USB ports (two 3.0, two 2.0), a Gigabit Ethernet port, a USB-C power port, a micro-SD slot, a camera port, and a 3.5mm audio-composite <span class="No-Break">video jack.</span></p>
<ul>
<li><strong class="bold">Raspberry Pi 5</strong>: The Raspberry<a id="_idIndexMarker010"/> Pi 5, released in<a id="_idIndexMarker011"/> October 2023, marks a significant advancement in the series, enhancing computational and multimedia capabilities for educational and DIY applications with its upgraded CPU <span class="No-Break">and GPU.</span><p class="list-inset">Priced at $60 for 4 GB and $80 for 8 GB, the Raspberry Pi 5 features a 2.4GHz quad-core Arm Cortex-A76 CPU, VideoCore VII GPU, dual 4Kp60 HDMI outputs, and various connectivity options including Wi-Fi and Bluetooth. It also introduces a power button, enhanced memory, and I/O capabilities, including two four-lane Mobile Industry Processor Interface (MIPI) camera/display transceivers. These transceivers offer the flexibility to connect any combination of two cameras or displays, making them ideal for advanced <span class="No-Break">multimedia projects.</span></p><p class="list-inset">The Raspberry Pi 5 also features a PCIe 2.0 x1 interface, allowing the connection of fast peripherals to expand its capabilities for advanced applications, such as high-speed networking or <span class="No-Break">storage solutions.</span></p><p class="list-inset">The accompanying Raspberry Pi Active Cooler, with its efficient heatsink and fan design, reduces CPU temperatures by approximately 20 degrees Celsius, vital for intensive tasks. It offers easy installation and up to 8000 RPM fan speed, enhancing performance and longevity. In <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.4</em>, the Raspberry Pi 5 is displayed <a id="_idIndexMarker012"/>alongside its<a id="_idIndexMarker013"/> Active Cooler, with key components such as the PCIe 2.0 Interface, GPIO Header, USB Ports, Ethernet Port, dual micro-HDMI Ports, and the two MIPI <span class="No-Break">Transceivers labeled:</span></p></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer011">
<img alt="Figure 1.4 – Raspberry Pi 5 (right) and Raspberry Pi Active Cooler (left)" height="551" src="image/B21282_01_4.jpg" width="1254"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Raspberry Pi 5 (right) and Raspberry Pi Active Cooler (left)</p>
<p class="list-inset">We will feature the Raspberry Pi 5 for our projects that involve a single-board computer, although the late-model Raspberry Pi 4B should <span class="No-Break">suffice too.</span></p>
<ul>
<li><strong class="bold">Raspberry Pi Zero and Zero W</strong>: Launched in November 2015, the Raspberry Pi Zero shrank the Raspberry Pi to a size of just 65mm by 30mm. It packed a 1 GHz single-core CPU and 512 MB of RAM at an affordable price. It came with a mini-HDMI Port, a micro-USB OTG Port, a micro-USB Power Port, and a HAT-compatible 40-pin header, making it ideal for compact applications such as IoT projects, wearables, as well as embedded systems. The Raspberry Pi Zero 2W was built on the same form factor and was introduced in 2021. It brought an enhanced 1 GHz quad-core ARM Cortex-A53 CPU, boosting performance and handling more demanding tasks. Its wireless capabilities with onboard Wi-Fi and Bluetooth <a id="_idIndexMarker014"/>further<a id="_idIndexMarker015"/> expanded its versatility, making it an excellent choice for compact projects. <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.5</em> provides a layout of a Raspberry Pi <span class="No-Break">Zero 2W:</span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer012">
<img alt="Figure 1.5 – Raspberry Pi Zero 2W" height="555" src="image/B21282_01_5.jpg" width="1602"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – Raspberry Pi Zero 2W</p>
<ul>
<li><strong class="bold">Raspberry Pi Pico and Pico W</strong>: Introduced in January 2021, the Raspberry Pi Pico is a compact microcontroller board designed for embedded projects and low-level programming. It’s only 51mm x 21mm in size, but highly flexible. It supports <strong class="bold">Serial Peripheral Interface</strong> (<strong class="bold">SPI</strong>) for<a id="_idIndexMarker016"/> high-speed <a id="_idIndexMarker017"/>data exchange, <strong class="bold">Inter-Integrated Circuit</strong> (<strong class="bold">I2C</strong>) for communication between peripherals, and <strong class="bold">Universal Asynchronous Receiver/Transmitter</strong> (<strong class="bold">UART</strong>) for serial communication. The <a id="_idIndexMarker018"/>Raspberry Pi Pico W, launched in February 2022, extended this flexibility with onboard Wi-Fi and Bluetooth. Unlike the traditional Raspberry Pi boards, both Pico models offer a unique <a id="_idIndexMarker019"/>set of <strong class="bold">General Purpose</strong> (<strong class="bold">GP</strong>) pins. Importantly, the Pico series, as microcontrollers rather than single-board computers, do not have an operating system. This enables bare metal programming, an approach where code runs directly on the hardware, resulting in faster, more efficient code execution and precise control. This makes devices such as the Raspberry Pi Pico ideal for applications requiring immediate reactions and close interactions with hardware, making it perfect for time-sensitive tasks. In <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.6</em>, we see <a id="_idIndexMarker020"/>a Raspberry <a id="_idIndexMarker021"/>Pi Pico W and a mapping of its <span class="No-Break">GP pins:</span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer013">
<img alt="Figure 1.6 – Raspberry Pi Pico W" height="624" src="image/B21282_01_6.jpg" width="699"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – Raspberry Pi Pico W</p>
<p>We will be using the variations of the Raspberry Pi Pico for projects where microcontrollers are more suitable than <span class="No-Break">single-board computers.</span></p>
<p>The following is a table outlining some of the differences between Raspberry <span class="No-Break">Pi models:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer014">
<img alt="Figure 1.7 – Table of Raspberry Pi models" height="1499" src="image/B21282_01_7.jpg" width="1651"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – Table of Raspberry Pi models</p>
<p>Now that we<a id="_idIndexMarker022"/> have a<a id="_idIndexMarker023"/> better understanding of the ecosystem of Raspberry Pi devices, let’s look at <span class="No-Break">some alternatives.</span></p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Exploring alternatives to the Raspberry Pi</h1>
<p>The IoT landscape is<a id="_idIndexMarker024"/> filled with a variety of single-board computers and microcontrollers, each offering unique specifications that cater to specific project needs. By comparing these alternatives with the Raspberry Pi, we can make informed decisions about the ideal platform for our unique requirements. The following is a breakdown of some of the alternatives to the Raspberry Pi that we may consider for our IoT projects. We will only focus on the Raspberry Pi and not the Raspberry Pi Pico as we will be using the former for this chapter’s <span class="No-Break">programming projects:</span></p>
<ul>
<li><strong class="bold">BeagleBone Black</strong>: The BeagleBone Black features a 1GHz ARM Cortex-A8 processor, 512MB DDR3 RAM, 4 GB flash storage, and many connectivity options. Its distinct feature, the <strong class="bold">Programmable Real-Time Units</strong> (<strong class="bold">PRUs</strong>), allow for precise <a id="_idIndexMarker025"/>real-time processing, ideal for applications such as robotics or industrial automation. Despite this, the Raspberry Pi remains popular due to its faster 1.5GHz 64-bit quad-core processor, beneficial for resource-intensive applications. The Raspberry Pi’s main advantage, however, is its large community software ecosystem, which greatly helps in <span class="No-Break">easing development.</span></li>
<li><strong class="bold">Arduino Uno</strong>: Like the Raspberry Pi Pico, the Arduino Uno is a microcontroller rather than a single-board computer. It uses the ATmega328P microcontroller, operates at 16 MHz, and has 2 KB of RAM. The Arduino Uno shines with its easy-to-use shields for functionality expansion, including Wi-Fi, Bluetooth, and sensor capabilities, making it ideal for simpler IoT projects. It benefits from an extensive ecosystem and easy-to-use <strong class="bold">Integrated Development Environment</strong> (<strong class="bold">IDE</strong>). However, for<a id="_idIndexMarker026"/> projects requiring heavy computations, multitasking, or extensive data processing, the more powerful Raspberry Pi is a <span class="No-Break">preferable option.</span></li>
<li><strong class="bold">ESP32</strong>: The ESP32 by Espressif Systems is a microcontroller like the Arduino Uno but with distinctive features. Its dual-core Xtensa LX6 microprocessor and 520 KB of SRAM, combined with in-built Wi-Fi and Bluetooth, enable robust wireless connectivity for IoT applications. Certain ESP32 models further expand their potential with additional sensors and communication protocols, such as LoRa for long-range, low-power communications. Although it doesn’t match the Raspberry Pi’s processing and RAM capabilities, it shines in areas prioritizing wireless connectivity and low power use. Its compactness and cost-effectiveness make it suitable for diverse IoT projects, from remote monitoring to home automation and wearables. In <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.8</em>, we see an ESP32 with built-in LoRa communication <a id="_idIndexMarker027"/>and <strong class="bold">Organic Light-Emitting Diode</strong> (<strong class="bold">OLED</strong>) screen (the LoRa board is covered by <span class="No-Break">the </span><span class="No-Break"><a id="_idIndexMarker028"/></span><span class="No-Break">screen):</span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer015">
<img alt="Figure 1.8 – ESP32 with the OLED screen and LoRa" height="424" src="image/B21282_01_8.jpg" width="688"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8 – ESP32 with the OLED screen and LoRa</p>
<ul>
<li><strong class="bold">Arduino Nano RP2040 Connect</strong>: The Arduino Nano RP2040 Connect was developed to integrate Raspberry Pi’s RP2040 microcontroller into a compact, feature-rich Arduino board, offering a unique blend of performance and connectivity for IoT projects and embedded AI solutions. It combines the dual-core processing power of the RP2040 with onboard Wi-Fi and Bluetooth, a six-axis IMU, microphone, and RGB LED, targeting a seamless IoT development experience. Its compatibility with the Arduino Cloud platform simplifies project management with capabilities such as <span class="No-Break">over-the-air updates.</span></li>
</ul>
<p>Now that we have <a id="_idIndexMarker029"/>explored some of the alternatives to the Raspberry Pi, we will now turn our focus to expanding the functionality of the Raspberry Pi <span class="No-Break">using HATs.</span></p>
<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Looking at the power of HATs</h1>
<p>Raspberry Pi HATs are <a id="_idIndexMarker030"/>add-on boards that extend the capabilities of the Raspberry Pi, offering a wide range of functionality for various applications. These HATs provide an easy and convenient way to enhance the Raspberry Pi’s capabilities by adding features such as sensors, actuators, displays, communication interfaces, and more. In this section, we will explore two notable HATs: the Pibrella HAT and the Raspberry Pi <span class="No-Break">Sense HAT.</span></p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Pibrella HAT</h2>
<p>The Pibrella HAT is an <a id="_idIndexMarker031"/>excellent beginner-friendly board designed to introduce<a id="_idIndexMarker032"/> electronics and programming concepts to users of all ages. It features buttons, LEDs, and a buzzer, providing a hands-on experience for physical computing projects with the Raspberry Pi. With its intuitive interface and Python library, the Pibrella HAT offers a great starting point for learning <span class="No-Break">and prototyping.</span></p>
<p>Despite being designed for the first version of the Raspberry Pi and thus having only a 26-pin GPIO connection, the Pibrella HAT can still be used with the current 40-pin versions of the Raspberry Pi. We can see the Pibrella HAT being attached to a Raspberry Pi 3B in <span class="No-Break"><em class="italic">Figure 1</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<img alt="Figure 1.9 – Attaching the Pibrella to a Raspberry Pi 3B" height="671" src="image/B21282_01_9.jpg" width="1310"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.9 – Attaching the Pibrella to a Raspberry Pi 3B</p>
<p>With the Pibrella HAT, users can explore the fundamentals of physical computing, learn about input and <a id="_idIndexMarker033"/>output interactions, and gain hands-on experience<a id="_idIndexMarker034"/> in programming with the <span class="No-Break">Raspberry Pi.</span></p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>The Raspberry Pi Sense HAT</h2>
<p>The Raspberry <a id="_idIndexMarker035"/>Pi Sense HAT (as shown in <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.10</em>) is an<a id="_idIndexMarker036"/> impressive add-on board designed to enhance the capabilities of the Raspberry Pi for sensing and environmental monitoring applications. Equipped with a variety of sensors, including temperature, humidity, pressure, gyroscope, accelerometer, and magnetometer, the Sense HAT allows users to gather data from the surrounding environment with ease. Its LED matrix display offers a visual output, enabling users to display real-time information, <span class="No-Break">including animations:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer017">
<img alt="Figure 1.10 – Raspberry Pi Sense HAT" height="531" src="image/B21282_01_10.jpg" width="1539"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.10 – Raspberry Pi Sense HAT</p>
<p>In addition to its wide range of applications, the Sense HAT also plays a vital role in the AstroPi program, which enables students to run their own experiments on the International Space Station. With its sensors and compact form factor, the Sense HAT is an ideal choice for collecting valuable data in a <span class="No-Break">space station.</span></p>
<p>In this chapter, we begin writing code using a Raspberry Pi 5 and Sense HAT. We will write code to fetch the current temperature from Sense HAT’s built-in temperature sensor and display<a id="_idIndexMarker037"/> it as a scrolling message on the<a id="_idIndexMarker038"/> Sense HAT’s dot <span class="No-Break">matrix display.</span></p>
<p>Before we do this, however, we will continue our exploration of the Raspberry Pi by looking at the various operating systems available for the <span class="No-Break">Raspberry Pi.</span></p>
<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/>Investigating operating systems for the Raspberry Pi</h1>
<p>While the official <a id="_idIndexMarker039"/>Raspberry Pi OS (formerly Raspbian) is <a id="_idIndexMarker040"/>the most widely used operating system for the Raspberry Pi, there is also support for various other operating systems. These options range from specialized systems tailored for specific applications, such as audio players including Volumio, and more general-purpose systems, such<a id="_idIndexMarker041"/> as Ubuntu and<a id="_idIndexMarker042"/> Raspberry Pi OS itself. In this section, we explore a selection of these operating systems and their unique features. They are <span class="No-Break">as follows:</span></p>
<ul>
<li><strong class="bold">Volumio</strong>: For those of us <a id="_idIndexMarker043"/>aiming to build a networked audio system accessible via a computer or smartphone, Volumio is a fitting choice. It transforms the Raspberry Pi into a headless audio player, rendering a keyboard or mouse unnecessary. This system connects to our audio files via a USB or network, with the option to enhance the audio output quality through an add-on HAT. Notably, Volumio includes a Spotify plugin, letting us stream music over a <span class="No-Break">sound system.</span></li>
<li><strong class="bold">PiFM radio transmitter</strong>: This system image turns the Raspberry Pi into an FM transmitter, broadcasting audio files to any standard FM radio receiver. We simply need to attach a wire to one of the GPIO pins to function as an antenna, creating a surprisingly robust <span class="No-Break">FM signal.</span></li>
<li><strong class="bold">Stratux</strong>: Stratux is open-source aviation software that can transform a Raspberry Pi into a powerful <strong class="bold">Automatic Dependent Surveillance-Broadcast</strong> (<strong class="bold">ADS-B</strong>) receiver. ADS-B is<a id="_idIndexMarker044"/> a modern aviation standard that allows aircraft to share their position, velocity, and other flight data with air traffic control and other aircraft. By installing Stratux on a Raspberry Pi and pairing it with additional hardware, we can create our own ADS-B ground station. This enables us to receive real-time data from aircraft in our vicinity, including flight trajectories, altitude, <span class="No-Break">and speed.</span></li>
<li><strong class="bold">RetroPie</strong>: For gaming buffs, RetroPie converts our Raspberry Pi into a retro gaming console. It effectively emulates several vintage gaming consoles and computers such as Amiga, Apple II, Atari 2600, and the Nintendo Entertainment System from the <span class="No-Break">early 1980s.</span></li>
<li><strong class="bold">OctoPi</strong>: For those of us involved in 3D printing, OctoPi transforms a Raspberry Pi into a server for a 3D printer, offering control and monitoring remotely through a <span class="No-Break">network connection.</span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer018">
<img alt="Figure 1.11 – OctoDash main screen" height="460" src="image/B21282_01_11.jpg" width="777"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.11 – OctoDash main screen</p>
<p class="list-inset">A companion to OctoPi is <strong class="bold">OctoDash</strong> (as shown in <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.11</em>), a touchscreen interface that provides an easy-to-use, visually appealing control panel for managing and monitoring 3D printing tasks. Using OctoPi with OctoDash can make the interaction with a 3D printer more flexible <span class="No-Break">and efficient.</span></p>
<ul>
<li><strong class="bold">Ubuntu for Raspberry Pi</strong>: Ubuntu, a leading open-source Linux distribution company, offers a platform for Raspberry Pi. Among Ubuntu’s key strengths is its compatibility <a id="_idIndexMarker045"/>with the <strong class="bold">Robot Operating System</strong> (<strong class="bold">ROS</strong>), an <a id="_idIndexMarker046"/>adaptable framework for writing robot software. With ROS on Ubuntu installed on a Raspberry Pi, we <a id="_idIndexMarker047"/>can<a id="_idIndexMarker048"/> engage in robotics projects, from simple hobbyist endeavors to sophisticated industrial automation systems. We will begin our exploration of ROS in <a href="B21282_11.xhtml#_idTextAnchor173"><span class="No-Break"><em class="italic">Chapter 11</em></span></a><span class="No-Break">.</span></li>
<li><strong class="bold">Raspberry Pi OS</strong>: Formerly known as Raspbian, Raspberry Pi OS is the most widely used operating system for Raspberry Pi due to its direct compatibility, lightweight design, and ease of use. Tailored specifically for Raspberry Pi, this operating system is abundant in educational software and programming tools, thereby aligning with Raspberry Pi’s mission of promoting learning in computer science and related fields. Installing Raspberry Pi OS is straightforward with the Raspberry Pi Imager, a tool that simplifies the process of burning the system image to a microSD card. Once installed, Raspberry Pi OS provides a graphical user interface along with a comprehensive suite of programming, internet, and multimedia apps, thereby<a id="_idIndexMarker049"/> making it a versatile choice for a wide range of Raspberry <span class="No-Break">Pi projects.</span></li>
</ul>
<p>Now that we have a <a id="_idIndexMarker050"/>general <a id="_idIndexMarker051"/>understanding of the operating systems available for the Raspberry Pi, let’s explore using the Raspberry Pi in the field that this book is based on – <span class="No-Break">IoT.</span></p>
<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>Using the Raspberry Pi for IoT</h1>
<p>IoT has revolutionized the<a id="_idIndexMarker052"/> way we interact with technology, giving everyday objects the ability to communicate, automate tasks, and generate invaluable data for use over the internet. The Raspberry Pi is central to many of these systems. Its versatility and robust processing capabilities enable this powerful single-board computer to function both as a data processor and a controller for <span class="No-Break">physical devices.</span></p>
<p>Uniquely equipped with features such as GPIO pins, USB ports, and Wi-Fi capabilities, the Raspberry Pi is a cost-effective and instrumental tool in implementing IoT solutions. The Raspberry Pi is especially valuable for processing real-time data and managing hardware. The following is a look at examples of Raspberry Pi-based <span class="No-Break">IoT systems.</span></p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Utilizing web services for IoT applications</h2>
<p>One of the distinct advantages <a id="_idIndexMarker053"/>of using<a id="_idIndexMarker054"/> the Raspberry Pi in IoT applications is its capacity to process real-time data and control other hardware elements based on this data. This capability becomes particularly useful when the data is sourced from the internet. The applications for such a setup are vast, from environmental monitoring to health tracking, traffic management, <span class="No-Break">and more.</span></p>
<p>The following example introduces a specific instance of such an application – a Raspberry Pi-driven IoT system that suggests appropriate clothing based on the current weather conditions (<span class="No-Break"><em class="italic">Figure 1</em></span><span class="No-Break"><em class="italic">.12</em></span><span class="No-Break">):</span></p>
<div>
<div class="IMG---Figure" id="_idContainer019">
<img alt="Figure 1.12 – Analog dashboard for weather information" height="557" src="image/B21282_01_12.jpg" width="836"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.12 – Analog dashboard for weather information</p>
<p>Built in the first edition of <em class="italic">Internet of Things Programming Projects</em>, this application utilizes an intuitive analog dashboard to suggest appropriate clothing based on the weather conditions. It includes an LED, which indicates if an umbrella will <span class="No-Break">be necessary.</span></p>
<p>In addition to <a id="_idIndexMarker055"/>being a weather-based <a id="_idIndexMarker056"/>application, we can modify this Raspberry Pi-powered IoT solution for various applications that involve collecting real-time data from a web service and representing it as analog data and <span class="No-Break">an LED.</span></p>
<p>Here are a <span class="No-Break">few examples:</span></p>
<ul>
<li><strong class="bold">Traffic density monitor</strong>: Leveraging similar concepts as described in <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.12</em>, this application would gather real-time traffic data from a city’s traffic monitoring API. The analog meter would show the current traffic density, and the LED could flash to indicate heavy traffic or congestion on a specific route. This allows commuters to choose the best routes and times <span class="No-Break">to travel.</span></li>
<li><strong class="bold">Health monitoring system</strong>: With data sourced from a health API or smart health devices, the analog meter could display heart rate, blood pressure, or any other vital statistic. The LED would act as an immediate visual alert for abnormal values, prompting immediate medical attention <span class="No-Break">if necessary.</span></li>
<li><strong class="bold">Water quality monitor</strong>: The IoT device could connect to a web service that receives data from water quality sensors in a river, lake, or ocean. The analog meter could display metrics such as pH level and the LED could flash when the readings indicate potentially <span class="No-Break">hazardous conditions.</span></li>
<li><strong class="bold">Agricultural monitor</strong>: Connected to a web service that pulls data from sensors in a farm field (such as soil moisture, temperature, etc.), the analog meter could display current conditions, while the LED could indicate when conditions are ripe for irrigation or if there’s a risk <span class="No-Break">of frost.</span></li>
</ul>
<p>Moving beyond metered dashboards, the powerful features of Raspberry Pi are particularly effective in robotics. The Raspberry Pi acts as the <em class="italic">brain</em> for these systems, managing tasks such as sensor data analysis, decision-making, and motor control. The integration of IoT and robotics has resulted in major advancements in various fields including <a id="_idIndexMarker057"/>security, automation, and<a id="_idIndexMarker058"/> surveillance. An example of this is <strong class="bold">T.A.R.A.S.</strong> (short for <strong class="bold">This Amazing Raspberry-Pi Automated Security agent</strong>), an automated security agent powered by Raspberry Pi and IoT principles, as presented in the first edition of <em class="italic">Internet of Things </em><span class="No-Break"><em class="italic">Programming Projects</em></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Re-introducing T.A.R.A.S. – an IoT-based robotics project</h2>
<p>T.A.R.A.S., a <a id="_idIndexMarker059"/>backronym <a id="_idIndexMarker060"/>named <a id="_idIndexMarker061"/>in honor of one of the author’s business mentors, Taras, serves as an automated <span class="No-Break">security guard.</span></p>
<p>This application of IoT in robotics exhibits how a Raspberry Pi can manage sensory and motor functions. It <a id="_idIndexMarker062"/>uses <strong class="bold">Message Queuing Telemetry Transport</strong> (<strong class="bold">MQTT</strong>) messages, a lightweight, publish–subscribe network protocol, enabling seamless communication between devices. We can see a graphic of T.A.R.A.S. in <span class="No-Break"><em class="italic">Figure 1</em></span><span class="No-Break"><em class="italic">.13</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer020">
<img alt="Figure 1.13 – T.A.R.A.S. communicates over the internet by sending and receiving MQTT messages" height="653" src="image/B21282_01_13.jpg" width="1298"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.13 – T.A.R.A.S. communicates over the internet by sending and receiving MQTT messages</p>
<p>Alongside sensory inputs, LED, and buzzer outputs, T.A.R.A.S. encapsulates the dynamic range of possibilities within IoT. In the previous edition, we built a web-based controller for T.A.R.A.S., integrating a host of skills acquired throughout <span class="No-Break">the book.</span></p>
<p>In this edition of <em class="italic">Internet of Things Programming Projects</em>, we say goodbye to T.A.R.A.S. as he has taken a package and retired from the security field. We will say hello to <strong class="bold">A.R.E.S.</strong>, or <strong class="bold">Advanced Robotic Eyes for Security</strong>. Named <a id="_idIndexMarker063"/>after the author’s beloved<a id="_idIndexMarker064"/> late <a id="_idIndexMarker065"/>dog, A.R.E.S. will take security and mobility to a new level by<a id="_idIndexMarker066"/> incorporating vision recognition <span class="No-Break">and ROS.</span></p>
<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Getting started with Raspberry Pi development</h1>
<p>Our Raspberry Pi can <a id="_idIndexMarker067"/>serve as a robust development platform ideal for various programming environments. The default Linux-based Raspberry Pi OS is equipped with Python, Scratch, and many other tools that cater to both beginners and seasoned programmers. It’s particularly effective for IoT projects and edge computing, thanks to its small form factor. As developers, we can use it for software development, web hosting, home automation projects, and prototyping, making it a versatile and accessible tool <span class="No-Break">for innovation.</span></p>
<p>In this book, we will develop IoT projects using the Raspberry Pi, specifically utilizing the Raspberry Pi 5 with 8 GB of RAM for optimal performance. While other versions of the Raspberry Pi may be sufficient, the Raspberry Pi 5 with 8 GB of RAM is currently the most powerful model available. Our projects will encompass an array of exciting applications, including an analog metered weather dashboard, an internet-connected home security system, an IoT remote monitoring station, and A.R.E.S. our advanced IoT-enabled robot car. In the remainder of this chapter, we will familiarize ourselves with reading sensory data from a Raspberry Pi <span class="No-Break">Sense HAT.</span></p>
<p>Before diving into <a id="_idIndexMarker068"/>development though, it’s crucial to familiarize ourselves with the development tools that are available for the <span class="No-Break">Raspberry Pi.</span></p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>Raspberry Pi development tools</h2>
<p>The following is a<a id="_idIndexMarker069"/> range of development tools available for our Raspberry Pi projects. It’s important to note that not all these programs come pre-installed with Raspberry Pi OS and may require <span class="No-Break">manual installation:</span></p>
<ul>
<li><strong class="bold">Python</strong>: Python is a high-level interpreted programming language for general-purpose programming. Its simple syntax and readability make it excellent for beginners, and its powerful libraries and versatility also suit advanced users for complex projects. Python comes pre-installed on Raspberry <span class="No-Break">Pi OS.</span></li>
<li><strong class="bold">Thonny</strong>: Thonny is an IDE for Python that comes pre-installed with Raspberry Pi OS. It’s easy to use for beginners and includes features such as <strong class="bold">step-by-step debugging</strong> and <strong class="bold">error highlighting</strong>. It’s also robust enough for advanced users, offering comprehensive tools for more complex coding. We will utilize Thonny for our projects in <span class="No-Break">this book.</span></li>
<li><strong class="bold">Scratch</strong>: Scratch is a block-based visual programming language aimed at children. With Scratch, children can create animation and games all while learning the basics <span class="No-Break">of programming.</span></li>
<li><strong class="bold">Greenfoot and BlueJ</strong>: These are two IDEs for Java. They are primarily used in education and are designed to help beginners get a grip on <span class="No-Break">object-oriented programming.</span></li>
<li><strong class="bold">Mu</strong> – This is a Python editor for beginner programmers. It’s designed to be simple and easy <span class="No-Break">to understand.</span></li>
<li><strong class="bold">Geany</strong>: It is a lightweight and highly customizable IDE that supports a wide range of programming languages including C, Java, PHP, HTML, Python, <span class="No-Break">Perl, Pascal.</span></li>
<li><strong class="bold">Wolfram Mathematica and Wolfram Language</strong>: Wolfram provides a high-level language and interactive environment for programming, mathematical visualization, and <span class="No-Break">general computation.</span></li>
<li><strong class="bold">Node-RED</strong>: This is a flow-based open source tool used for visual programming. Node-RED allows access to APIs and <span class="No-Break">online services.</span></li>
<li><strong class="bold">GCC and GDB</strong>: The <strong class="bold">GNU Compiler Collection</strong> (<strong class="bold">GCC</strong>) (including gcc and g++) and<a id="_idIndexMarker070"/> the <strong class="bold">GNU Debugger</strong> (<strong class="bold">GDB</strong>) allow us to<a id="_idIndexMarker071"/> compile and debug code written in languages such as C <span class="No-Break">and C++.</span></li>
</ul>
<p>Apart from these, we can install other software development tools from the Raspberry Pi OS repositories using the apt package manager or download and install them manually. For example, we might want to install Git for version control, Docker for containerization, or Visual Studio Code for a more advanced <span class="No-Break">development environment.</span></p>
<p>The Raspberry Pi <a id="_idIndexMarker072"/>supports a wide array of development tools, catering to various programming needs. By looking at these tools, we’ve underscored the Raspberry Pi’s adaptability and capacity for <span class="No-Break">innovative projects.</span></p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Raspberry Pi and Sense HAT development</h2>
<p>It is a great idea <a id="_idIndexMarker073"/>to start our journey into IoT development by <a id="_idIndexMarker074"/>learning how to write simple code for the Raspberry Pi Sense HAT. The Sense HAT serves as an excellent IoT device, equipped with a range of sensors and an LED matrix display that can be harnessed to create <span class="No-Break">innovative applications.</span></p>
<p>For our coding examples, we will securely mount our Raspberry Pi 5 into a case specifically designed for this book. In <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.14</em>, we can see a CAD render of the case that we will be using. The case features a front cover that exposes the dot matrix LED screen of the Sense HAT. It also includes a circular vent to ensure proper heat dissipation inside the case. On the back part of the case, we have incorporated a GoPro-style hook, providing us with the flexibility to mount the Raspberry Pi and Sense HAT using any GoPro stand. Files to build the case are available from the book’s GitHub repository. Using a standard FDM 3D printer to make the case should be sufficient; however, better quality and durability are obtained using a liquid resin printer and engineering resins such as Siraya Tech Blu. <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.14</em> shows what the assembled case will look like with <a id="_idIndexMarker075"/>the <a id="_idIndexMarker076"/>printed stem and base plate in place of a <span class="No-Break">GoPro stand:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<img alt="Figure 1.14 – Custom-designed Sense HAT case for Raspberry Pi 5" height="569" src="image/B21282_01_14.jpg" width="1271"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.14 – Custom-designed Sense HAT case for Raspberry Pi 5</p>
<p>We can find all the necessary files for 3D printing (<strong class="source-inline">.stl</strong> files) in the <strong class="source-inline">Build Files</strong> folder within the book’s GitHub repository. It is worth noting that most Raspberry Pi cases do not account for the accommodation of HATs, making our Raspberry Pi/Sense HAT case an excellent accessory for this book. However, it is important to mention that the case is not mandatory to complete the exercises in this book. Furthermore, if we decide not to purchase a Sense HAT, we can still run the examples by utilizing the Sense HAT simulator available for the Raspberry <span class="No-Break">Pi OS.</span></p>
<p>Before we start writing code, we’ll set up the development environment on our Raspberry Pi. Once<a id="_idIndexMarker077"/> our<a id="_idIndexMarker078"/> environment is ready, we’ll dive right <span class="No-Break">into coding.</span></p>
<p>Let’s <span class="No-Break">get started!</span></p>
<h3>Setting up our development environment</h3>
<p>In this section, we<a id="_idIndexMarker079"/> will go through the process of setting up Thonny for development with the Raspberry Pi and Sense HAT. Thonny is a beginner-friendly IDE that offers a user-friendly interface. With Thonny, we can easily write, test, and debug our code, allowing us to focus on the development process without <span class="No-Break">unnecessary complexity.</span></p>
<p>We will use a Python virtual environment for our development. As there are libraries that only work with the root installation of Python, we will use system packages in our Python virtual environment. To do so, we do <span class="No-Break">the following:</span></p>
<ol>
<li>On our Raspberry Pi 5, we open a Terminal application by clicking on the fourth icon on the top-left menu (<span class="No-Break"><em class="italic">Figure 1</em></span><span class="No-Break"><em class="italic">.15</em></span><span class="No-Break">):</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer022">
<img alt="Figure 1.15 – Opening the Terminal application (indicated by the red arrow)" height="214" src="image/B21282_01_15.jpg" width="792"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.15 – Opening the Terminal application (indicated by the red arrow)</p>
<ol>
<li value="2">To store our project files, we create a new directory with <span class="No-Break">the following:</span><pre class="source-code">
<strong class="bold">mkdir Chapter1</strong></pre></li> <li>We then navigate to the new directory with <span class="No-Break">the following:</span><pre class="source-code">
<strong class="bold">cd Chapter1</strong></pre></li> <li>We create a new<a id="_idIndexMarker080"/> Python virtual environment for our project with <span class="No-Break">the following:</span><pre class="source-code">
<strong class="bold">python -m venv ch1-env --system-site-packages</strong></pre></li> <li>With this command, we create a new Python virtual environment called <strong class="source-inline">ch1-env</strong> and enable access to the system site packages. This allows the virtual environment to inherit packages from the global Python environment, which can be useful when certain libraries are installed system wide. Once the environment is set up, we can activate it and begin installing project-specific packages without affecting the global <span class="No-Break">Python environment.</span></li>
<li>With our new Python virtual environment created, we source into it with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">source ch1-env/bin/activate</strong></pre></li> <li>Sourcing into the new Python virtual environment activates the environment, allowing us to work with its specific settings and installed packages isolated from the global Python installation. Our Terminal application should now show that we are using the <strong class="source-inline">ch1-env</strong> Python <span class="No-Break">virtual environment:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer023">
<img alt="Figure 1.16 – Terminal using ch1-env environment" height="391" src="image/B21282_01_16.jpg" width="1587"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.16 – Terminal using ch1-env environment</p>
<ol>
<li value="8">For our project, we need the Sense HAT and the Sense HAT emulator libraries. The Sense HAT<a id="_idIndexMarker081"/> library is pre-installed in our Python virtual environment; however, the Sense HAT emulator requires manual installation via a <span class="No-Break">Terminal command:</span><pre class="source-code">
<strong class="bold">pip install sense-emu</strong></pre></li> <li>Installing the Sense HAT emulator library lets us run code with either the actual Sense HAT or the Sense HAT emulator. We can close the Terminal with a <span class="No-Break">specific command:</span><pre class="source-code">
<strong class="bold">exit</strong></pre></li> <li>We are now ready to load up Thonny. We do so by clicking on the <strong class="bold">Menu</strong> icon in the Raspberry Pi taskbar, navigating to the <strong class="bold">Programming</strong> category, and selec<a id="_idTextAnchor029"/>ting <strong class="bold">Thonny</strong> (<span class="No-Break"><em class="italic">Figure 1</em></span><span class="No-Break"><em class="italic">.17</em></span><span class="No-Break">):</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer024">
<img alt="Figure 1.17 – Thonny IDE interface" height="483" src="image/B21282_01_17.jpg" width="994"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.17 – Thonny IDE interface</p>
<ol>
<li value="11">By default, Thonny<a id="_idIndexMarker082"/> uses the Raspberry Pi’s built-in version of Python (red arrow in <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.17</em>). For our project, we will use the Python virtual environment we just created. To start, we need to view the project files by clicking on <strong class="bold">View</strong> and selecting <strong class="bold">Files</strong> if it is not already selected (we may have to switch to regular mode first by clicking on the <strong class="bold">Switch to regular mode</strong> tab at the top-right side of <span class="No-Break">the screen).</span></li>
<li>In the <strong class="bold">Files</strong> section, we locate the <span class="No-Break"><strong class="source-inline">ch1-env</strong></span><span class="No-Break"> directory.</span></li>
<li>We then right-click on the folder and select the <strong class="bold">Activate virtual </strong><span class="No-Break"><strong class="bold">environment</strong></span><span class="No-Break"> option:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer025">
<img alt="Figure 1.18 – Activating ch1-env virtual environment in Thonny" height="539" src="image/B21282_01_18.jpg" width="354"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.18 – Activating ch1-env virtual environment in Thonny</p>
<p>With our project<a id="_idIndexMarker083"/> folder created, our Python virtual environment set up and activated, and the Sense HAT emulator package installed, we may now start <span class="No-Break">writing code.</span></p>
<h3>Sense HAT development – reading sensor data</h3>
<p>The goal for our<a id="_idIndexMarker084"/> first project is to create a program that reads sensor information from the Sense HAT and displays it in the Thonny Shell. Before we can read sensory information, however, we must ensure that we have the Sense HAT properly connected to our <span class="No-Break">Raspberry Pi.</span></p>
<p>To start, follow <span class="No-Break">these steps:</span></p>
<ol>
<li>If not already running, we launch Thonny by clicking on the <strong class="bold">Menu</strong> icon in the Raspberry Pi taskbar, navigating to the <strong class="bold">Programming</strong> category, and selecting <strong class="bold">Thonny</strong>. We activate the <strong class="source-inline">ch1-env</strong> virtual environment if not <span class="No-Break">already activated.</span></li>
<li>We then create a new tab by selecting <strong class="bold">File</strong> and then <strong class="bold">New</strong> or by hitting <em class="italic">Ctrl</em>+<em class="italic">N</em> on <span class="No-Break">the keyboard:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer026">
<img alt="Figure 1.19 – Creating a new file in Thonny" height="604" src="image/B21282_01_19.jpg" width="903"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.19 – Creating a new file in Thonny</p>
<ol>
<li value="3">Inside the new <a id="_idIndexMarker085"/>tab, we enter the <span class="No-Break">following code:</span><pre class="source-code">
from sense_hat import SenseHat
sense_hat = SenseHat()
temp = sense_hat.get_temperature()
humidity = sense_hat.get_humidity()
press = sense_hat.get_pressure()
accel = sense_hat.get_accelerometer_raw()
gyroscope = sense_hat.get_gyroscope_raw()
print("Temperature: {:.2f}°C".format(temp))
print("Humidity: {:.2f}%".format(humidity))
print("Pressure: {:.2f} millibars".format(press))
print("Accelerometer Data: x={:.2f}, y={:.2f},  z={:.2f}".format(accel['x'], accel['y'], accel['z']))
print("Gyroscope Data: x={:.2f}, y={:.2f}, z={:.2f}".format(gyroscope['x'], gyroscope['y'], gyroscope['z']))</pre></li> <li>For those of us using the Sense HAT simulator, we simply need to change the first line of code to <span class="No-Break">the following:</span><pre class="source-code">
from sense_emu import SenseHat</pre><p class="list-inset">We save the code with a descriptive name such as <strong class="source-inline">sensor-test.py</strong>. Before we run the code, let’s break it down to <span class="No-Break">understand it:</span></p><ol><li class="upper-roman">Our code starts<a id="_idIndexMarker086"/> by importing the <strong class="source-inline">SenseHat</strong> class from the <span class="No-Break"><strong class="source-inline">sense_hat</strong></span><span class="No-Break"> library.</span></li><li class="upper-roman">An instance of the <strong class="source-inline">SenseHat</strong> class is created and assigned to the <span class="No-Break">variable </span><span class="No-Break"><strong class="source-inline">sense_hat</strong></span><span class="No-Break">.</span></li><li class="upper-roman">The <strong class="source-inline">get_temperature()</strong> method is called on the <strong class="source-inline">sense_hat</strong> object to retrieve the temperature data and assigned to the <span class="No-Break"><strong class="source-inline">temp</strong></span><span class="No-Break"> variable.</span></li><li class="upper-roman">The <strong class="source-inline">get_humidity()</strong> method is called on the <strong class="source-inline">sense_hat</strong> object to retrieve the humidity data and assigned to the <span class="No-Break"><strong class="source-inline">humidity</strong></span><span class="No-Break"> variable.</span></li><li class="upper-roman">The <strong class="source-inline">get_pressure()</strong> method is called on the <strong class="source-inline">sense_hat</strong> object to retrieve the air pressure data and assigned to the <span class="No-Break"><strong class="source-inline">press</strong></span><span class="No-Break"> variable.</span></li><li class="upper-roman">The <strong class="source-inline">get_accelerometer_raw()</strong> method is called on the <strong class="source-inline">sense_hat</strong> object to retrieve the raw accelerometer data, which includes values for the <em class="italic">x</em>, <em class="italic">y</em>, and <em class="italic">z</em> axes. The data is assigned to the <span class="No-Break"><strong class="source-inline">accel</strong></span><span class="No-Break"> variable.</span></li><li class="upper-roman">The <strong class="source-inline">get_gyroscope_raw()</strong> method is called on the <strong class="source-inline">sense_hat</strong> object to retrieve the raw gyroscope data, which also includes values for the <em class="italic">x</em>, <em class="italic">y</em>, and <em class="italic">z</em> axes. The data is assigned to the <span class="No-Break"><strong class="source-inline">gyroscope</strong></span><span class="No-Break"> variable.</span></li><li class="upper-roman">The obtained data is then printed out with appropriate formatting using the <strong class="source-inline">print()</strong> function and formatted string placeholders <strong class="source-inline">(`{:.2f}`)</strong> to display the values with two <span class="No-Break">decimal places.</span></li></ol></li> <li>We run the code by either clicking on the green <strong class="bold">Run</strong> button, hitting <em class="italic">F5</em> on the keyboard, or clicking<a id="_idIndexMarker087"/> on the <strong class="bold">Run</strong> menu option at the top and then <strong class="bold">Run </strong><span class="No-Break"><strong class="bold">current script</strong></span><span class="No-Break">:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer027">
<img alt="Figure 1.20 – Running a program in Thonny" height="497" src="image/B21282_01_20.jpg" width="695"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.20 – Running a program in Thonny</p>
<p class="list-inset">After running the code, we should observe a message like the following in <span class="No-Break">the Shell:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<img alt="Figure 1.21 – Results after running sensor-test.py" height="531" src="image/B21282_01_21.jpg" width="928"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.21 – Results after running sensor-test.py</p>
<p>For those of us using <a id="_idIndexMarker088"/>the Sense HAT emulator, the values displayed will be determined by the slider values set in <span class="No-Break">the emulator.</span></p>
<p class="callout-heading">Important notes</p>
<p class="callout">We can disregard the warning since the Sense HAT does not include a TCS34725 color sensor. It is likely that the warning is caused by an internal issue in the Sense HAT Python library. Our code is not affected by this warning and can continue to run <span class="No-Break">as intended.</span></p>
<p class="callout">It’s important to note that the temperature readings are influenced by the heat generated by the Raspberry Pi, resulting in higher values compared to the actual room temperature. The humidity readings are also affected. However, the accelerometer and gyroscope values accurately reflect the position and orientation of the Sense HAT and can be observed to change when the case is swiveled in different directions. To see updated values from the accelerometer and gyroscope, the code must be run again after swiveling <span class="No-Break">the case.</span></p>
<p>Now that we have learned how to read sensory data from Sense HAT, let’s shift our focus to the dot matrix screen. In the next section, we will explore creating a simple animation using <a id="_idIndexMarker089"/>the dot <span class="No-Break">matrix display.</span></p>
<h3>Sense HAT development – creating animations</h3>
<p>In this section, we<a id="_idIndexMarker090"/> will create an explosion animation using Sense HAT and the Raspberry Pi. We will use Thonny as our development environment to write and execute <span class="No-Break">the code.</span></p>
<p>To start, follow <span class="No-Break">these steps:</span></p>
<ol>
<li>If not already running, we launch Thonny by clicking on the <strong class="bold">Menu</strong> icon in the Raspberry Pi taskbar, navigating to the <strong class="bold">Programming</strong> category, and selecting <strong class="bold">Thonny</strong>. We activate the <strong class="source-inline">ch1-env</strong> virtual environment if not <span class="No-Break">already activated.</span></li>
<li>We then create a new tab by selecting <strong class="bold">File</strong> and then <strong class="bold">New</strong> or by hitting <em class="italic">Ctrl</em> + <em class="italic">N</em> on <span class="No-Break">the keyboard.</span></li>
<li>We start our code by entering <span class="No-Break">our imports:</span><pre class="source-code">
from sense_hat import SenseHat
import time</pre><ol><li class="upper-roman">We import the <strong class="source-inline">SenseHat</strong> module from the <strong class="source-inline">sense_hat</strong> library, allowing us to interact with the Sense <span class="No-Break">HAT board.</span></li><li class="upper-roman">We also import the <strong class="source-inline">time</strong> module, which will be used for adding delays in <span class="No-Break">our program.</span></li></ol></li> <li>We then set our <span class="No-Break">variable declarations:</span><pre class="source-code">
sense_hat = SenseHat()
R = [255, 0, 0]  # Red
O = [255, 165, 0]  # Orange
Y = [255, 255, 0]  # Yellow
B = [0, 0, 0]  # Black
frame1 = [
B, B, B, B, B, B, B, B,
B, B, B, B, B, B, B, B,
B, B, B, R, R, B, B, B,
B, B, R, R, R, R, B, B,
B, B, R, R, R, R, B, B,
B, B, B, R, R, B, B, B,
B, B, B, B, B, B, B, B,
B, B, B, B, B, B, B, B
]
frame2 = [
B, B, Y, O, O, Y, B, B,
B, Y, O, R, R, O, Y, B,
Y, O, R, Y, Y, R, O, Y,
O, R, Y, B, B, Y, R, O,
O, R, Y, B, B, Y, R, O,
Y, O, R, Y, Y, R, O, Y,
B, Y, O, R, R, O, Y, B,
B, B, Y, O, O, Y, B, B
]
frame3 = [
O, R, R, Y, Y, R, R, O,
R, Y, O, O, O, O, Y, R,
Y, O, B, B, B, B, O, Y,
O, B, B, B, B, B, B, O,
O, B, B, B, B, B, B, O,
Y, O, B, B, B, B, O, Y,
R, Y, O, O, O, O, Y, R,
O, R, R, Y, Y, R, R, O
]
frames = [frame1, frame2, frame3]</pre><ol><li class="upper-roman">We create an instance of the SenseHAT class called <strong class="source-inline">sense_hat</strong>, enabling us to access the Sense <span class="No-Break">HAT’s functionality.</span></li><li class="upper-roman">We define color values for red, orange, yellow, and black, which will be used to create <span class="No-Break">our animation.</span></li><li class="upper-roman">We create <strong class="source-inline">frame1</strong> as a list of color values, representing the desired image on the <span class="No-Break">LED matrix.</span></li><li class="upper-roman">We define <strong class="source-inline">frame2</strong> and <strong class="source-inline">frame3</strong> as <span class="No-Break">additional frames.</span></li><li class="upper-roman">We create<a id="_idIndexMarker091"/> a list called <strong class="source-inline">frames</strong>, which holds the defined frames in a <span class="No-Break">specific order.</span></li></ol></li> <li>To have our animation run continuously, we set up an <span class="No-Break">infinite loop:</span><pre class="source-code">
while True:
    for frame in frames:
        sense_hat.set_pixels(frame)
        time.sleep(0.5)
    sense_hat.clear()
    time.sleep(0.2)</pre><ol><li class="upper-roman">Within the loop, we iterate through each frame in the <span class="No-Break"><strong class="source-inline">frames</strong></span><span class="No-Break"> list.</span></li><li class="upper-roman">We set the pixels of the LED matrix to the current frame using <strong class="source-inline">sense_hat.set_pixels(frame)</strong>, displaying the <span class="No-Break">corresponding image.</span></li><li class="upper-roman">We introduce a brief pause of 0.5 seconds using <strong class="source-inline">time.sleep(0.5)</strong> to control the <span class="No-Break">animation speed.</span></li><li class="upper-roman">After displaying all frames, we clear the LED matrix using <strong class="source-inline">sense_hat.clear()</strong>, preparing for the <span class="No-Break">next iteration.</span></li><li class="upper-roman">We add a slight delay of 0.2 seconds using <strong class="source-inline">time.sleep(0.2)</strong> before starting the animation loop again, creating the <span class="No-Break">explosion pattern.</span></li></ol></li> <li>For those of<a id="_idIndexMarker092"/> us using the Sense HAT simulator we simply need to change the first line of code to the following and open the Sense HAT simulator on our <span class="No-Break">Raspberry Pi:</span><pre class="source-code">
from sense_emu import SenseHat</pre></li> <li>We save the code with a descriptive name such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">animation-test.py</strong></span><span class="No-Break">.</span><p class="list-inset">We run the code by clicking on the green <strong class="bold">Run</strong> button, hitting <em class="italic">F5</em> on the keyboard, or clicking on the <strong class="bold">Run</strong> menu option at the top and then <strong class="bold">Run current script</strong>. We should observe an explosion animation on our Sense HAT or in the Sense <span class="No-Break">HAT emulator:</span></p></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer029">
<img alt="Figure 1.22 – Frame from explosion animation on the Sense HAT emulator" height="464" src="image/B21282_01_22.jpg" width="766"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.22 – Frame from explosion animation on the Sense HAT emulator</p>
<p>In this section, we explored creating animations with Sense HAT and Raspberry Pi. We learned how to write code that displays a sequence of frames on the LED matrix, resulting in an explosion animation. For our final programming project in this chapter, we will create a<a id="_idIndexMarker093"/> scrolling message on the Sense HAT’s dot matrix screen. This message will dynamically show temperature, humidity, and air pressure data, providing us with valuable environmental insights in a visually <span class="No-Break">appealing way.</span></p>
<h3>Sense HAT development – creating a scrolling environmental data display</h3>
<p>Building upon our <a id="_idIndexMarker094"/>previous projects, where we gained experience in reading sensory data from Sense HAT and creating animations on its LED matrix, we will now dive into the creation of a scrolling text application using the Sense HAT’s dot <span class="No-Break">matrix display.</span></p>
<p>To start, follow <span class="No-Break">these steps:</span></p>
<ol>
<li>If not already running, we launch Thonny by clicking on the <strong class="bold">Menu</strong> icon in the Raspberry Pi taskbar, navigating to the <strong class="bold">Programming</strong> category, and selecting <strong class="bold">Thonny</strong>. We activate the <strong class="source-inline">ch1-env</strong> virtual environment if not <span class="No-Break">already activated.</span></li>
<li>We create a new tab by selecting <strong class="bold">File</strong> and then <strong class="bold">New</strong> or by hitting <em class="italic">Ctrl</em> + <em class="italic">N</em> on <span class="No-Break">the keyboard.</span></li>
<li>We start our code by importing the libraries <span class="No-Break">we need:</span><pre class="source-code">
from sense_hat import SenseHat
import time</pre><ol><li class="upper-roman">We import the <strong class="source-inline">SenseHat</strong> module from the <strong class="source-inline">sense_hat</strong> library, allowing us to interact with the Sense HAT board. For those of us using the Sense HAT emulator, we would use the <strong class="source-inline">sense_emu</strong> <span class="No-Break">library instead.</span></li><li class="upper-roman">We also import the <strong class="source-inline">time</strong> module, which will be used for adding delays in <span class="No-Break">our program.</span></li></ol></li> <li>We then set<a id="_idIndexMarker095"/> our variable declarations in <span class="No-Break">our code:</span><pre class="source-code">
sense_hat = SenseHat()
speed = 0.05
sense_hat.set_rotation(270)
red = [255, 0, 0]
green = [0, 255, 0]</pre><ol><li class="upper-roman">We create an instance of the <strong class="source-inline">SenseHAT</strong> class we <span class="No-Break">call </span><span class="No-Break"><strong class="source-inline">sense_hat</strong></span><span class="No-Break">.</span></li><li class="upper-roman">We set the scrolling speed of the messages on the LED matrix using the <span class="No-Break">variable </span><span class="No-Break"><strong class="source-inline">speed</strong></span><span class="No-Break">.</span></li><li class="upper-roman">The line <strong class="source-inline">sense_hat.set_rotation(270)</strong> adjusts the orientation of the Sense HAT’s LED matrix so that it matches the orientation of the Raspberry Pi in the <span class="No-Break">custom case.</span></li><li class="upper-roman">We define two color variables, <strong class="source-inline">red</strong> and <strong class="source-inline">green</strong>, for the <span class="No-Break">text color.</span></li></ol></li> <li>To have our scrolling message continuously play, we create an <span class="No-Break">infinite loop:</span><pre class="source-code">
while True:
    sense_hat.show_message("Temperature: %.1fC, " %
                   sense_hat.get_temperature(),
                   scroll_speed=speed,
                   text_colour=green)
    sense_hat.show_message("Humidity: %.1f%%, " %
                   sense.get_humidity(),
                   scroll_speed=speed,
                   text_colour=green)
    sense_hat.show_message("Pressure: %.1fhPa" %
                   sense.get_pressure(),
                   scroll_speed=speed,
                   text_colour=red)
    time.sleep(1)</pre><p class="list-inset">In the infinite<a id="_idIndexMarker096"/> loop, we do <span class="No-Break">the following:</span></p><ol><li class="upper-roman">We display the temperature reading on the LED matrix, formatted with one <span class="No-Break">decimal place.</span></li><li class="upper-roman">We display the humidity reading on the LED matrix, formatted with one <span class="No-Break">decimal place.</span></li><li class="upper-roman">We display the pressure reading on the LED matrix, formatted with one <span class="No-Break">decimal place.</span></li><li class="upper-roman">We pause for one second before the next iteration of <span class="No-Break">the loop.</span></li></ol></li> <li>We save the code with a descriptive name such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">sensor-scroll.py</strong></span><span class="No-Break">.</span></li>
<li>We run the code by clicking on the green <strong class="bold">Run</strong> button, hitting <em class="italic">F5</em> on the keyboard, or clicking on the <strong class="bold">Run</strong> menu option at the top and then <strong class="bold">Run </strong><span class="No-Break"><strong class="bold">current script</strong></span><span class="No-Break">.</span><p class="list-inset">We should observe a scrolling message of sensory data displayed on the dot matrix screen of our Sense HAT (or Sense <span class="No-Break">HAT emulator).</span></p></li>
</ol>
<p>In this exercise, we created a scrolling text application on the Sense HAT, displaying real-time environmental data. This project enhanced our skills in data acquisition from sensors and visual presentation, using the Sense HAT’s LED matrix for effective data visualization. Completing<a id="_idIndexMarker097"/> this final chapter project, we’re now equipped to tackle more advanced IoT applications with the Sense HAT and <span class="No-Break">Raspberry Pi.</span></p>
<h1 id="_idParaDest-30"><a id="_idTextAnchor030"/>Summary</h1>
<p>In this chapter, we began our journey into the world of IoT projects with the Raspberry Pi. We explored the various Raspberry Pi models, their distinct characteristics, and their significance in IoT development. We took a brief look at the alternatives to the Raspberry Pi for IoT applications and explored Raspberry Pi HATs, such as the Pibrella HAT and the Raspberry Pi <span class="No-Break">Sense HAT.</span></p>
<p>Additionally, we looked at operating systems compatible with the Raspberry Pi, outside of the official Raspberry Pi OS. We highlighted the versatility and power of the Raspberry Pi in IoT applications, emphasizing its ability to process real-time data and control physical devices. The chapter also introduced the Raspberry Pi as a robust development platform, equipped with pre-installed tools for <span class="No-Break">software development.</span></p>
<p>At the end of the chapter, we engaged in practical programming projects that utilized Sense HAT and explored its potential in IoT applications. These projects included a scrolling environmental data display, providing hands-on experience in extracting sensory information, and creating dynamic <span class="No-Break">visual displays.</span></p>
<p>This chapter equipped us with the knowledge we may use to make informed choices when developing IoT projects. Understanding the strengths of different Raspberry Pi models and alternatives prepares us to choose the right device for specific applications. Familiarity with Raspberry Pi HATs and various operating systems expands our toolkit. In this chapter, we unlocked the potential of the Raspberry Pi by understanding its data and control capabilities. Our Sense HAT practice prepared us for more complex projects in <span class="No-Break">the future.</span></p>
<p>Looking ahead, in the next chapter, we will harness the power of web services as we continue to build more sophisticated <span class="No-Break">IoT applications.</span></p>
</div>
</div></body></html>