<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Storing Data in Google Cloud SQL</h1></div></div></div><p>Google Cloud SQL<a id="id320" class="indexterm"/> is a MySQL database server instance that lives in the Google cloud infrastructure; it can be used from outside Google Cloud Platform within applications that don't run on the App Engine platform. We will learn how to use it both ways: by adding code to our Notes application and creating a standalone script that runs on our workstation.</p><p>Google offers two billing plans for Cloud SQL, <strong>Packages</strong> and <strong>Per Use</strong>, without providing<a id="id321" class="indexterm"/> any free tier. This means we have to pay to execute the code in<a id="id322" class="indexterm"/> this chapter, though choosing the Per Use plan and running the instance for the sole purpose of going through the chapter should be extremely cheap.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to create, configure, and run a Cloud SQL instance</li><li class="listitem" style="list-style-type: disc">How to manage a running instance</li><li class="listitem" style="list-style-type: disc">How to use Cloud SQL from App Engine</li><li class="listitem" style="list-style-type: disc">How to use Cloud SQL from outside App Engine</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Creating a Cloud SQL instance</h1></div></div></div><p>We will<a id="id323" class="indexterm"/> make heavy use of Developer Console throughout this chapter, and we start by creating an instance of a Cloud SQL database. As we already know from <a class="link" href="ch01.html" title="Chapter 1. Getting Started">Chapter 1</a>, <em>Getting Started</em>, even if we created our Notes application from App Engine Admin Console, we should have a corresponding project on Developer Console.</p><div><div><h3 class="title"><a id="note13"/>Note</h3><p>At this point, we must have enabled the billing feature for our project to access all the Cloud-SQL-related functionalities from within Developer Console.</p></div></div><p>From Developer Console, once our project is selected, we have to perform the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Click the <strong>Cloud SQL</strong> item under the <strong>Storage</strong> section on the left-hand side menu.</li><li class="listitem">Push the <strong>Create an instance</strong> button.</li><li class="listitem">Provide<a id="id324" class="indexterm"/> a name for the database instance, for example, <strong>myfirst</strong>; the name of the instance must be unique within a project and will be always combined with the project name.</li><li class="listitem">Select <strong>REGION</strong>, the same as the location of the App Engine application (most likely <strong>United States</strong>).</li><li class="listitem">Select a tier for the instance; we can safely use the cheapest tier for the purpose of this chapter, the one labeled <strong>D0</strong>.</li><li class="listitem">Click on the <strong>Save</strong> button.</li></ol></div><p>The following screenshot shows Developer Console:</p><div><img src="img/8194OS_05_01.jpg" alt="Creating a Cloud SQL instance"/></div><p>The creation process for our Cloud SQL instance will immediately start. In a few minutes, the <a id="id325" class="indexterm"/>status of the instance will become runnable, which means that we can start the instance whenever we need it. We're not charged of any fee while the instance is in the runnable state.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec29"/>Configuring access</h2></div></div></div><p>Before<a id="id326" class="indexterm"/> using our database instance, we should <a id="id327" class="indexterm"/>configure access permissions and credentials to control who can perform connections to the database and how. There are two levels of access control, one at the Cloud Platform level and another at the database level. The first level authorizes access to the Cloud SQL instance from client applications, either from the App Engine infrastructure by checking the application ID, or from a remote node on the Internet by checking the source IP address. The second level is the MySQL privilege system that is responsible for authentication of users and associate them with privileges on databases, such as the ability to perform the <code class="literal">SELECT</code>, <code class="literal">INSERT</code>, <code class="literal">UPDATE</code> or <code class="literal">DELETE</code> operation.</p><p>If we created the Cloud SQL instance from within our project settings in Developer Console, our App Engine application is already authorized to connect to the database. To double-check, on Developer Console we have to:</p><div><ol class="orderedlist arabic"><li class="listitem">Click on <strong>Cloud SQL</strong> menu item.</li><li class="listitem">Click on the instance ID.</li><li class="listitem">Open the <strong>Access Control</strong> tab.</li></ol></div><p>Under <a id="id328" class="indexterm"/>the <strong>Authorized App Engine Applications</strong> label, we can see whether our application ID is listed.</p><p>While we <a id="id329" class="indexterm"/>are on that page, we can set up the access for our local machine; this is needed to perform administrative tasks such as adding users and databases using any MySQL client. We first need to assign an IP address for our instance so that we can reach it from outside the Cloud Platform infrastructure; click the <strong>Add new</strong> link, next to the <strong>IP Addresses</strong> label and wait for the address to be assigned to our instance.</p><div><div><h3 class="title"><a id="note14"/>Note</h3><p>When we request an IP address for Cloud SQL instances, we should be aware that we will be charged for the time we use this address while instances are not running. To lower costs, we can release the IP address as soon as we don't need it.</p></div></div><p>When we connect from our local machine to the Cloud SQL instance, we are obviously outside the App Engine infrastructure, so we have to add our public IP address to the list of the hosts allowed to access from the Internet. For this, we need to perform the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Get our public IP address; we can use Google for this by hitting this <a class="ulink" href="https://www.google.com/#q=my-ip">https://www.google.com/#q=my-ip</a> URL.</li><li class="listitem">Click on the <strong>Add new</strong> link next to the <strong>Authorized Networks</strong> label.</li><li class="listitem">Fill out the form with our public IP address.</li><li class="listitem">Click on the <strong>Add</strong> button.</li></ol></div><p>The following screenshot shows Developer Console:</p><div><img src="img/8194OS_05_02.jpg" alt="Configuring access"/></div><p>From now on, we can connect to our Cloud SQL instance using the MySQL command line<a id="id330" class="indexterm"/> client, for instance, from our laptop. For the<a id="id331" class="indexterm"/> first level of the access control system, that's enough for now; we can proceed to configuring the second level.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec30"/>Setting the root password</h2></div></div></div><p>The<a id="id332" class="indexterm"/> first step to take full control of our Cloud <a id="id333" class="indexterm"/>SQL instance is setting a password for the MySQL <code class="literal">root</code> user; to do this, perform the following:</p><div><ol class="orderedlist arabic"><li class="listitem">On Developer Console, we go to the <strong>ACCESS CONTROL</strong> tab page.</li><li class="listitem">Fill the field under the <strong>Set Root Password</strong> section with the desired password.</li><li class="listitem">Click on the <strong>Set</strong> button.</li></ol></div><p>In the next paragraph, we will see how to connect to the instance as a <code class="literal">root</code> user and perform the administrative tasks we need to complete before using the instance from within<a id="id334" class="indexterm"/> our<a id="id335" class="indexterm"/> Notes application.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Connecting to the instance with the MySQL console</h1></div></div></div><p>To<a id="id336" class="indexterm"/> interact with our Cloud SQL instance, we will use the MySQL command line client, which is available for all the platforms supported by App Engine, even if we can use any client we feel more comfortable with. The client is usually shipped together with most MySQL server installation packages; besides having the MySQL client tool installed, it is advisable to install MySQL and have a local server running so that we can work with it instead of the production instance while developing applications. We will get back to this soon in this chapter.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec31"/>Creating the notes database</h2></div></div></div><p>The <a id="id337" class="indexterm"/>first task we need to perform is creating <a id="id338" class="indexterm"/>a new database on the Cloud SQL instance; we will use this to store data from our Notes application. To connect to the instance, we issue the following from the command line:</p><div><pre class="programlisting">
<strong>mysql –host=&lt;your instance IP&gt; --user=root –password</strong>
</pre></div><p>After inserting the password for the <code class="literal">root</code> user, we should get into the MySQL monitor and see an output similar to the following:</p><div><pre class="programlisting">
<strong>Welcome to the MySQL monitor.  Commands end with ; or \g.</strong>
<strong>Your MySQL connection id is 1</strong>
<strong>Server version: 5.5.38 (Google)</strong>

<strong>Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.</strong>

<strong>Oracle is a registered trademark of Oracle Corporation and/or its</strong>
<strong>affiliates. Other names may be trademarks of their respective</strong>
<strong>owners.</strong>

<strong>Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</strong>

<strong>mysql&gt;</strong>
</pre></div><p>If we successfully managed to get to the prompt, we can create a database named <code class="literal">notes</code> by issuing the following instructions:</p><div><pre class="programlisting">
<strong>mysql&gt; CREATE DATABASE notes;</strong>
<strong>Query OK, 1 row affected (1.62 sec)</strong>
</pre></div><p>The <a id="id339" class="indexterm"/>output of the command should be very <a id="id340" class="indexterm"/>similar to the previous command in the case of success; we can now proceed to creating a dedicated database user we will use to perform connections from our Notes application.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec32"/>Creating a dedicated user</h2></div></div></div><p>The <code class="literal">root</code> user in a MySQL installation has unlimited privileges and it is a good security practice to<a id="id341" class="indexterm"/> avoid connecting to the server <a id="id342" class="indexterm"/>with the <code class="literal">superuser</code> credentials. For this reason, we create a dedicated user that we will use to make connections from our Notes application and that is able to operate exclusively on the <code class="literal">notes</code> database. Before proceeding, we remove the anonymous localhost access provided by default in Cloud SQL instances; this is a good security practice and avoids the anonymous user to shadow regular users when MySQL checks for user permissions. From the client, we issue the statement:</p><div><pre class="programlisting">
<strong>mysql&gt; DROP USER ''@localhost;</strong>
<strong>Query OK, 0 rows affected (0.17 sec)</strong>
</pre></div><p>We then proceed creating a regular user:</p><div><pre class="programlisting">
<strong>mysql&gt; CREATE USER 'notes'@'%' IDENTIFIED BY 'notes_password';</strong>
<strong>Query OK, 0 rows affected (1.47 sec)</strong>
</pre></div><p>Of course, we should pick up a stronger password; anyway, we have just created a new user named <code class="literal">notes</code> who will be able to perform connections from any host (notice the <code class="literal">%</code> character that is a wildcard matching any host). For convenience, we grant to the <code class="literal">notes</code> user any privilege on the <code class="literal">notes</code> database:</p><div><pre class="programlisting">
<strong>mysql&gt; GRANT ALL PRIVILEGES ON notes.* TO 'notes'@'%';</strong>
<strong>Query OK, 0 rows affected (0.49 sec)</strong>
</pre></div><p>We finally make MySQL server reload all the updated privileges with the following statement:</p><div><pre class="programlisting">
<strong>mysql&gt; FLUSH PRIVILEGES;</strong>
<strong>Query OK, 0 rows affected (0.17 sec)</strong>
</pre></div><p>We can now disconnect from the server, ending the current session with the <code class="literal">\q</code> command and try to reconnect using the <code class="literal">notes</code> user:</p><div><pre class="programlisting">
<strong>mysql&gt; \q</strong>
<strong>Bye</strong>

<strong>mysql –host=&lt;your instance IP&gt; --user=notes –password</strong>
</pre></div><p>We should establish a connection with the MySQL monitor without errors, and then we can check whether we can actually access the <code class="literal">notes</code> database:</p><div><pre class="programlisting">
<strong>mysql&gt; use notes;</strong>
<strong>Database changed</strong>
</pre></div><p>We <a id="id343" class="indexterm"/>can now proceed with creating tables<a id="id344" class="indexterm"/> for storing data in our Notes application.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec33"/>Creating tables</h2></div></div></div><p>Suppose <a id="id345" class="indexterm"/>we want to log users activities and store <a id="id346" class="indexterm"/>this information on a database so that we can use them later for, let's say, business intelligence analysis. Using Datastore for this purpose is not a good idea for at least two reasons:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We will likely end with writing a lot of data, thus we cannot use too many indexes and we might have to refrain from using grouped entities.</li><li class="listitem" style="list-style-type: disc">We will require another App Engine application to retrieve and analyze data because we cannot access Datastore from outside the platform.</li></ul></div><p>Cloud SQL can solve both the issues above, respectively:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Writing limits for Cloud SQL are far more loose than Datastore.</li><li class="listitem" style="list-style-type: disc">We can connect to the Cloud SQL instance from an external application and access data.</li></ul></div><p>We can now start defining the data we want to log; for a simple usage analysis, we can save the user identifier, the type of operation performed, and the date and time of such an operation. Once connected to the server with the MySQL client, we can issue the <code class="literal">CREATE</code> statement:</p><div><pre class="programlisting">CREATE TABLE 'notes'.'ops'
(
    'id'        INT NOT NULL auto_increment,
    'user_id'   VARCHAR(128) NOT NULL,
    'operation' VARCHAR(16) NOT NULL,
    'date'      DATETIME NOT NULL,
    PRIMARY KEY ('id')
);</pre></div><p>If the query succeeded, we should see something like this output:</p><div><pre class="programlisting">
<strong>Query OK, 0 rows affected (0.55 sec)</strong>
</pre></div><p>The SQL statement creates a relation or table named <code class="literal">ops</code> inside the <code class="literal">notes</code> database. The table has 4 columns:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>The</strong> <code class="literal">id</code> <strong>column</strong> This contains integer values that increment automatically every<a id="id347" class="indexterm"/> time a new row is inserted; this is the primary key.</li><li class="listitem" style="list-style-type: disc"><strong>The</strong> <code class="literal">user_id</code> <strong>column</strong>: This holds the user identifier provided by App Engine, which is <a id="id348" class="indexterm"/>usually 56 characters long; we <a id="id349" class="indexterm"/>set 128 as the length so that we have room<a id="id350" class="indexterm"/> if the length grows.</li><li class="listitem" style="list-style-type: disc"><strong>The</strong> <code class="literal">operation</code> <strong>column</strong>: This is to store the type of operation logged; 16 characters <a id="id351" class="indexterm"/>should be more than enough.</li><li class="listitem" style="list-style-type: disc"><strong>The</strong> <code class="literal">date</code> <strong>column</strong>: This<a id="id352" class="indexterm"/> holds the date and time when operation was logged.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Connecting to the instance from our application</h1></div></div></div><p>To <a id="id353" class="indexterm"/>connect with Cloud SQL instances<a id="id354" class="indexterm"/> from our Python code, we use the <code class="literal">MySQLdb</code> package, which is a MySQL driver that implements the Python Database API as described in the <strong>PEP 249</strong> document. To install the package, we can use <code class="literal">pip</code>; from the command line, we issue the following command:</p><div><pre class="programlisting">
<strong>pip install MySQL-python</strong>
</pre></div><p>We don't specify the <code class="literal">-t</code> option as we did when installing GCS Client Library in <a class="link" href="ch03.html" title="Chapter 3. Storing and Processing Users' Data">Chapter 3</a>, <em>Storing and Processing Users' Data</em> because the <code class="literal">MySQLdb</code> package is included in App Engine Python Runtime Environment on the production servers and we don't need to upload it during deployment. Instead, we list the package in the <code class="literal">libraries</code> section of the <code class="literal">app.yaml</code> file:</p><div><pre class="programlisting">libraries:
- name: webapp2
  version: "2.5.2"

- name: jinja2
  version: latest

- name: MySQLdb
  version: latest</pre></div><p>A simple test to check if the database connection is working correctly consists of retrieving and logging the Cloud SQL version number. We add a function to the <code class="literal">utils.py</code> module to retrieve a connection to the database. We first need to import the <code class="literal">MySQLdb</code> package at the top of our <code class="literal">utils.py</code> module along with the <code class="literal">os</code> module:</p><div><pre class="programlisting">import os
import MySQLdb</pre></div><p>Then, we add the following function:</p><div><pre class="programlisting">def get_cloudsql_db():
    db_ip = os.getenv('CLOUD_SQL_IP')
    db_user = os.getenv('CLOUD_SQL_USER')
    db_pass = os.getenv('CLOUD_SQL_PASS')
    return MySQLdb.connect(host=db_ip, db='notes',
                           user=db_user, passwd=db_pass)</pre></div><p>The function returns a connection to the database. We retrieve all the information to perform the connection accessing some environment variables so that they are easily available<a id="id355" class="indexterm"/> from any point in our <a id="id356" class="indexterm"/>codebase. To define environment variables, we just have to add this at the bottom of our <code class="literal">app.yaml</code> file:</p><div><pre class="programlisting">env_variables:
  CLOUD_SQL_IP: '&lt;your_instance_ip&gt;'
  CLOUD_SQL_USER: 'notes'
  CLOUD_SQL_PASS: 'notes_password'</pre></div><p>We can use the database connection to get the MySQL version in the <code class="literal">get()</code> method of the <code class="literal">MainHandler</code> class in the <code class="literal">main.py</code> module. We first import the <code class="literal">get_cloudsql_db()</code> method and the <code class="literal">logging</code> module:</p><div><pre class="programlisting">from utils import get_cloudsql_db
import logging</pre></div><p>We modify the <code class="literal">get()</code> method as follows:</p><div><pre class="programlisting">def get(self):
    user = users.get_current_user()
    if user is not None:
        db = get_cloudsql_db()
        ver = db.get_server_info()
        logging.info("Cloud SQL version: {}".format(ver))
        logout_url = users.create_logout_url(self.request.uri)
        template_context = {
            'user': user.nickname(),
            'logout_url': logout_url,
        }
        self.response.out.write(
            self._render_template('main.html', template_context))
    else:
        login_url = users.create_login_url(self.request.uri)
        self.redirect(login_url)</pre></div><p>We can run the Notes application with the local development server and access the main page with our browser; if everything is okay, we should see a message in the log console (or in your shell if you launched the <code class="literal">dev_appserver.py</code> server from there) similar to this:</p><div><pre class="programlisting">INFO 2014-09-28 12:40:41,796 main.py:109] Cloud SQL version: 5.5.38</pre></div><p>So far so good, but if we try to deploy the application on App Engine, the result will be an error page with this error:</p><p><strong>OperationalError: (2004, "Can't create TCP/IP socket (-1)")</strong></p><p>This is <a id="id357" class="indexterm"/>because we are trying to <a id="id358" class="indexterm"/>access the Cloud SQL instance using a TCP/IP socket, which is perfectly fine if we connect from outside App Engine; due to the runtime environment networking restriction though, if we connect from an App Engine application, we have to use a Unix socket instead.</p><p>We can change the connection string in the <code class="literal">utils.py</code> module as follows:</p><div><pre class="programlisting">def get_cloudsql_db():
    db_user = os.getenv('CLOUD_SQL_USER')
    db_pass = os.getenv('CLOUD_SQL_PASS')
    instance_id = os.getenv('CLOUD_SQL_INSTANCE_ID')
    unix_socket = '/cloudsql/{}'.format(instance_id)
    return MySQLdb.connect(unix_socket=unix_socket, db='notes',
                           user=db_user, passwd=db_pass)</pre></div><p>We need to define an additional environment variable named <code class="literal">CLOUD_SQL_INSTANCE_ID</code> in our <code class="literal">app.yaml</code> file:</p><div><pre class="programlisting">env_variables:
  CLOUD_SQL_IP: '&lt;your_instance_ip&gt;'
  CLOUD_SQL_USER: 'notes'
  CLOUD_SQL_PASS: 'notes_password'
  CLOUD_SQL_INSTANCE_ID: '&lt;your_instance_id&gt;'</pre></div><p>If we try to deploy this version of the application, we'll notice this actually works on App Engine but it won't work on the local environment server anymore. To avoid changing the code in the <code class="literal">get_cloudsql_db()</code> function every time we switch from development to production, we can provide a method that detects automatically whether an application is running locally or on the App Engine servers. In the <code class="literal">utils.py</code> module, we add the following:</p><div><pre class="programlisting">def on_appengine():
    return os.getenv('SERVER_SOFTWARE', '').startswith('Google App Engine')</pre></div><p>This function simply returns the <code class="literal">True</code> parameter if the application is running on App Engine and the <code class="literal">False</code> parameter otherwise. We can use the function in the <code class="literal">get_cloudsql_db()</code> function in this manner:</p><div><pre class="programlisting">def get_cloudsql_db():
    db_user = os.getenv('CLOUD_SQL_USER')
    db_pass = os.getenv('CLOUD_SQL_PASS')

    if on_appengine():
        instance_id = os.getenv('CLOUD_SQL_INSTANCE_ID')
        sock = '/cloudsql/{}'.format(instance_id)
        return MySQLdb.connect(unix_socket=sock, db='notes',
                               user=db_user, passwd=db_pass)
    else:
        db_ip = os.getenv('CLOUD_SQL_IP')
        return MySQLdb.connect(host=db_ip, db='notes',
                               user=db_user, passwd=db_pass)</pre></div><p>The <a id="id359" class="indexterm"/>function will always return<a id="id360" class="indexterm"/> the right database connection for the environment our application is running on.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Loading and saving data</h1></div></div></div><p>Now<a id="id361" class="indexterm"/> that we know how to connect to a Cloud SQL instance from our App <a id="id362" class="indexterm"/>Engine application, it's time to learn how to write and read data from the database. We already created a table called <code class="literal">ops</code>, and we will use it to store information about user operations. We will log the following events:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A user has created a note</li><li class="listitem" style="list-style-type: disc">A user has added a file</li><li class="listitem" style="list-style-type: disc">A user has performed a shrink operation</li></ul></div><p>We have to assign a text code to each of the operation types we want to log. To do so, we can use a simple Python class that works as an enumeration. In the <code class="literal">utils.py</code> module, we add the following code:</p><div><pre class="programlisting">class OpTypes(object):
    NOTE_CREATED = 'NCREATED'
    FILE_ADDED = 'FADDED'
    SHRINK_PERFORMED = 'SHRINKED'</pre></div><p>We will see how to use it in a moment. We now provide a <code class="literal">log_operation()</code> method in the <code class="literal">utils.py</code> module that we will use to log operations in the Cloud SQL database. We will call this function within the Notes code passing along the user who actually performed the operation, the appropriate operation type, and the date and time of the operation. The code is the following:</p><div><pre class="programlisting">def log_operation(user, operation_type, opdate):
    db = get_cloudsql_db()
    cursor = db.cursor()
    cursor.execute('INSERT INTO ops (user_id, operation, date)'
                   ' VALUES (%s, %s, %s)',
                   (user.user_id(), operation_type, opdate))
    db.commit()
    db.close()</pre></div><p>We first<a id="id363" class="indexterm"/> retrieve a valid database connection, and then we get a cursor object <a id="id364" class="indexterm"/>by calling the <code class="literal">cursor()</code> method on the connection object. By calling the <code class="literal">execute()</code> method on the cursor object, we can issue SQL statements contained in the string we pass as a parameter. In this case, we insert a new row in the <code class="literal">ops</code> table, persisting the user identifier, the string corresponding to the operation type, and the date and time when the operation was performed. We finally commit the transaction and close the connection.</p><p>We can call the <code class="literal">log_operation()</code> method from the <code class="literal">main.py</code> module at various points in the code:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the <code class="literal">post()</code> method of the <code class="literal">MainHandler</code> class:<div><pre class="programlisting">if file_name and file_content:
    content_t = mimetypes.guess_type(file_name)[0]
    real_path = os.path.join('/', bucket_name, user.user_id(), file_name)

    with cloudstorage.open(real_path, 'w', content_type=content_t,
                           options={'x-goog-acl': 'public-read'}) as f:
        f.write(file_content.read())
    log_operation(user, OpTypes.FILE_ADDED,
                  datetime.datetime.now())
self._create_note(user, file_name, real_path)
log_operation(user, OpTypes.NOTE_CREATED,
              datetime.datetime.now())</pre></div></li><li class="listitem" style="list-style-type: disc">In the <code class="literal">get()</code> method of the <code class="literal">ShrinkHandler</code> class:<div><pre class="programlisting">taskqueue.add(url='/shrink',
              params={'user_email': user.email()})
log_operation(user, OpTypes.SHRINK_PERFORMED,
              datetime.datetime.now())
self.response.write('Task added to the queue.')</pre></div></li><li class="listitem" style="list-style-type: disc">In the <code class="literal">receive()</code> method of the <code class="literal">CreateNoteHandler</code> class:<div><pre class="programlisting">attachments = getattr(mail_message, 'attachments', None)

self._create_note(user, title, content, attachments)
log_operation(user, OpTypes.NOTE_CREATED,
              datetime.datetime.now())</pre></div></li></ul></div><p>Notice that by passing the date and time to the <code class="literal">log_operation()</code> method, we can record the actual time at which the user performs the operation instead of the time at which the function code was executed; this can be useful if we need to be punctual but the function is added to a task queue and executed at a later time.</p><p>From<a id="id365" class="indexterm"/> now on, when someone uses our Notes application, we will collect usage<a id="id366" class="indexterm"/> information about that user. We can access this information from the Notes application itself or another application on App Engine that is authorized to access the same Cloud SQL instance; otherwise, we can use a pure Python application that runs on our workstation or another remote server to access and process data whenever needed. For example, we create an application in an <code class="literal">analyze.py</code> module outside the App Engine project <code class="literal">root</code> (so that we can avoid uploading the file during deployment). The code is as follows:</p><div><pre class="programlisting"># -*- coding: utf-8 -*-
import sys
import MySQLdb

CLOUD_SQL_IP = '&lt;your_instance_ip&gt;'
CLOUD_SQL_USER = 'notes'
CLOUD_SQL_PASS = 'notes_password'

def main():
    db = MySQLdb.connect(host=CLOUD_SQL_IP, db='notes',
                         user=CLOUD_SQL_USER,
                         passwd=CLOUD_SQL_PASS)
    cursor = db.cursor()

    cursor.execute('SELECT COUNT(DISTINCT user_id) FROM ops '
                   'WHERE date &gt; (DATE_SUB(CURDATE(), '
                   'INTERVAL 1 MONTH));')
    users = cursor.fetchone()[0]
    sys.stdout.write("Active users: {}\n".format(users))

    cursor.execute('SELECT COUNT(*) FROM ops WHERE date &gt; '
                   '(DATE_SUB(CURDATE(), INTERVAL 1 HOUR))')
    ops = cursor.fetchone()[0]
    sys.stdout.write("Ops in the last hour: {}\n".format(ops))

    cursor.execute('SELECT COUNT(*) FROM ops WHERE '
                   'operation = "SHRINKED"')
    ops = cursor.fetchone()[0]
    sys.stdout.write("Total shrinking ops: {}\n".format(ops))

    return 0

if __name__ == '__main__':
    sys.exit(main())</pre></div><p>We can run the script from the command line at any time using the following line of command:</p><div><pre class="programlisting">
<strong>python analyze.py</strong>
</pre></div><p>Back to <a id="id367" class="indexterm"/>the code; in the <code class="literal">main()</code> method, we first get a connection to the<a id="id368" class="indexterm"/> database through a TCP/IP socket using the public IP of the instance. Then, we get a cursor object and perform the first query that counts the number of users we consider active, namely users who performed at least one kind of operation in the past month. As this is a count query, we expect only one row as result. In this case, we can call the <code class="literal">fetchone()</code> method of the cursor object; this method returns a tuple that contains one value that we get by index and store it in the <code class="literal">users</code> variable that we print on the standard output. With the same strategy, we retrieve and print to the standard output the number of operations globally performed in the last hour and the total number of shrinking operations.</p><p>This is just a simple example but it shows how easy it can be to get usage metrics for our web applications extracting data from a Cloud SQL instance with any Python program running outside App Engine.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Using the local MySQL installation for development</h1></div></div></div><p>There <a id="id369" class="indexterm"/>are several reasons why we wouldn't want to work with a Cloud SQL instance while running our application locally in the development server. We might notice major slowdowns because every time we connect to a Cloud SQL instance, we perform a socket connection to a remote host that can be very far from us. Moreover, regardless of the Cloud SQL tier we choose, we always pay something for using the service and we might not want to use it while experimenting on the local development server.</p><p>Fortunately, we can leverage the fact that, in the end, a Cloud SQL instance is nothing more than a MySQL database when our code talks to it. We can then install a local instance of a MySQL server and work with this.</p><p>We install and start the local server and perform the same operations we did on the Cloud SQL instance:</p><div><ol class="orderedlist arabic"><li class="listitem">Connect with the MySQL client.</li><li class="listitem">Create the <code class="literal">notes</code> database.</li><li class="listitem">Create the <code class="literal">notes</code> users and give them privileges on the <code class="literal">notes</code> database.</li><li class="listitem">Reload database privileges.</li><li class="listitem">Create the <code class="literal">ops</code> table.</li></ol></div><p>At this point, all we have to do is change the <code class="literal">CLOUD_SQL_IP</code> environment variable in our <code class="literal">app.yaml</code> file so that it points to <code class="literal">localhost</code> variable:</p><div><pre class="programlisting">env_variables:
  CLOUD_SQL_IP: 'localhost'
  CLOUD_SQL_USER: 'notes'
  CLOUD_SQL_PASS: 'notes_password'</pre></div><p>We<a id="id370" class="indexterm"/> can now start using the local instance, avoiding network lags and costs.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Summary</h1></div></div></div><p>In this chapter, we put into action Cloud SQL, the scalable database service offered by Google Cloud Platform. Cloud SQL is more than a MySQL instance; it is a flexible and scalable relational database server that we can use to store and retrieve data from our App Engine applications as well as from external services and applications.</p><p>Even if Cloud Datastore is the go-to solution when we have to deal with lot of data in our highly trafficked web applications, in this chapter, you learned how convenient it can be to have a relational database to store some data without hitting on the limits Datastore imposes to write operations. Being able to access that data from outside App Engine is a big plus and we have seen a simple yet effective use case, which we couldn't have implemented using Datastore.</p><p>In the next chapter, we will add new features to our Notes application; we will make the application real time using Channel API to push data from the server to the clients connected.</p></div></body></html>