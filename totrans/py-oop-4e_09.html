<html><head></head><body>
  <div><h1 class="chapterNumber">9</h1>
    <h1 id="_idParaDest-179" class="chapterTitle">Strings, Serialization, and File Paths</h1>
    <p class="normal">Before we get involved with higher-level design patterns, let's take a deep dive into one of Python's most common objects: the string. We'll see that there is a lot more to the string than meets the eye, and we'll also cover searching strings for patterns, and serializing data for storage or transmission.</p>
    <p class="normal">All of these topics are elements of making objects persistent. Our application can create objects in files for use at a later time. We often take persistence – the ability to write data to a file and retrieve it at an arbitrary later date – for granted. Because persistence happens via files, at the byte level, via OS writes and reads, it leads to two transformations: data we have stored must be decoded into a nice, useful object collection of objects in memory; objects from memory need to be encoded to some kind of clunky text or bytes format for storage, transfer over the network, or remote invocation on a distant server.</p>
    <p class="normal">In this chapter, we'll look at the following topics:</p>
    <ul>
      <li class="bullet">The complexities of strings, bytes, and byte arrays</li>
      <li class="bullet">The ins and outs of string formatting</li>
      <li class="bullet">The mysterious regular expression</li>
      <li class="bullet">How to use the <code class="Code-In-Text--PACKT-">pathlib</code> module to manage the filesystem</li>
      <li class="bullet">A few ways to serialize data, including Pickle and JSON</li>
    </ul>
    <p class="normal">This chapter will extend the case study to examine how best to work with collections of data files. We'll look at another serialization format, CSV, in the case study. This will help us explore alternative representations for the training and testing data.</p>
    <p class="normal">We'll start by looking Python strings. They do so much and it's easy to overlook the wealth of available features.</p>
    <h1 id="_idParaDest-180" class="title">Strings</h1>
    <p class="normal">Strings <a id="_idIndexMarker606"/>are a basic primitive in Python; we've used them in nearly every example we've discussed so far. All they do is represent an immutable sequence of characters. However, though you may not have considered it before, <em class="italic">character</em> is a bit of an ambiguous word; can Python strings represent sequences of accented characters? Chinese characters? What about Greek, Cyrillic, or Farsi?</p>
    <p class="normal">In Python 3, the answer is yes. Python strings are all represented in Unicode, a character definition standard that can represent virtually any character in any language on the planet (and some made-up languages and random characters as well). This is done seamlessly. So, let's think of Python 3 strings as an immutable sequence of Unicode characters. We've touched on many of the ways strings can be manipulated in previous examples, but let's quickly cover it all in one place: a crash course in string theory!</p>
    <p class="normal">It's very important to step away from the older encodings we used to know and love. The ASCII encoding, for example, was limited to one byte per character. Unicode has several ways to encode a character into bytes. The most popular, called <a id="_idIndexMarker607"/>UTF-8, tends to parallel the old ASCII encoding for some punctuation and letters. It's approximately one byte per character. But, if you need one of the thousands of other Unicode characters, there may be multiple bytes involved.</p>
    <p class="normal">The important rule is this: we <em class="italic">encode</em> our characters to create bytes; we <em class="italic">decode</em> bytes to recover the characters. The two are separated by a high fence with a gate labeled encode on one side and decode on the other. We can visualize it like this:</p>
    <figure class="mediaobject"><img src="img/B17070_09_01.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 9.1: Strings and bytes</p>
    <p class="normal">There's a potential source of confusion that arises from the canonical display of a bytes value. Python will show a bytes value as <code class="Code-In-Text--PACKT-">b'Flamb\xc3\xa9'</code>. In a bytes value, the letters are shorthand for numbers and use the older ASCII encoding scheme. </p>
    <p class="normal">For most letters, the UTF-8 and ASCII encoding are the same. The <code class="Code-In-Text--PACKT-">b'</code> prefix tells us these are bytes, and the letters are really only ASCII codes, not proper Unicode characters. We can see this because the Unicode <code class="Code-In-Text--PACKT-">é</code> – encoded in UTF-8 – takes two bytes, and there's no ASCII shorthand for either of those bytes.</p>
    <h2 id="_idParaDest-181" class="title">String manipulation</h2>
    <p class="normal">As you know, strings can <a id="_idIndexMarker608"/>be created in Python by wrapping a sequence of characters in single or double quotes. Multiline strings can easily be created using three quote characters, and multiple hardcoded strings can be concatenated together by placing them side by side. Here are some examples:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; a = "hello"
&gt;&gt;&gt; b = 'world' 
&gt;&gt;&gt; c = '''a multiple 
... line string''' 
&gt;&gt;&gt; d = """More 
... multiple""" 
&gt;&gt;&gt; e = ("Three " "Strings " 
...        "Together") 
</code></pre>
    <p class="normal">That last string is automatically composed into a single string by the interpreter. It is also possible to concatenate strings using the <code class="Code-In-Text--PACKT-">+</code> operator (as in <code class="Code-In-Text--PACKT-">"hello " + "world"</code>). Of course, strings don't have to be hardcoded. They can also come from various outside sources, such as text files and user input, or can be transmitted on the network.</p>
    <div><p class="Tip--PACKT-"><strong class="keyword">Watch for missing operators</strong></p>
      <p class="Tip--PACKT-">The automatic concatenation of adjacent strings can make for some hilarious bugs when a comma is missed. It is, however, extremely useful when a long string needs to be placed inside a function call without exceeding the 79-character line-length limit suggested by PEP-8, the Python style guide.</p>
    </div>
    <p class="normal">Like other sequences, strings can be iterated over (character by character), indexed, sliced, or concatenated. The syntax is the same as for lists and tuples.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">str</code> class has numerous methods on it to make manipulating strings easier. The <code class="Code-In-Text--PACKT-">dir()</code> and <code class="Code-In-Text--PACKT-">help()</code> functions can tell us how to use all of them; we'll consider some of the more common ones directly.</p>
    <p class="normal">Several Boolean convenience methods help us identify whether or not the characters in a string match a certain pattern. Most of these, such as <code class="Code-In-Text--PACKT-">isalpha()</code>, <code class="Code-In-Text--PACKT-">isupper()</code>, <code class="Code-In-Text--PACKT-">islower()</code>, <code class="Code-In-Text--PACKT-">startswith()</code>, and <code class="Code-In-Text--PACKT-">endswith()</code>, have reasonably easy-to-understand interpretations. The <code class="Code-In-Text--PACKT-">isspace()</code> method is also fairly obvious, but remember that all whitespace characters (including tab and newline) are considered, not just the space character. When in doubt, the <code class="Code-In-Text--PACKT-">help()</code> function is useful:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; help(str.isalpha)
Help on method_descriptor:
isalpha(...)
    S.isalpha() -&gt; bool
    Return True if all characters in S are alphabetic and there is at     least one character in S, False otherwise.
    A string is alphabetic if all characters in the string are     alphabetic and there is at least one character in the string.
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">istitle()</code> method <a id="_idIndexMarker609"/>returns <code class="Code-In-Text--PACKT-">True</code> if the first character of each word is capitalized and all other characters are lowercase. Note that it does not strictly enforce the English grammatical definition of title formatting. For example, Leigh Hunt's poem <em class="italic">The Glove and the Lions</em> follows common style guides for a title, but doesn't fit the narrow rule of Python's method. Similarly, Robert Service's <em class="italic">The Cremation of Sam McGee</em> follows the usual English rules for a valid title, even though there is an uppercase letter in the middle of the last word; Python's <code class="Code-In-Text--PACKT-">istitle()</code> method will return <code class="Code-In-Text--PACKT-">False</code>, unaware of the rules for capitalizing a name like McGee or words like <em class="italic">and</em> <em class="italic">the</em> in a title.</p>
    <p class="normal">Be careful with the <code class="Code-In-Text--PACKT-">isdigit()</code>, <code class="Code-In-Text--PACKT-">isdecimal()</code>, and <code class="Code-In-Text--PACKT-">isnumeric()</code> methods, as they are more nuanced than we would expect. Many Unicode characters are considered numbers besides the 10 digits we are used to. Worse, the period character that we use to construct floats from strings is not considered a decimal character, so <code class="Code-In-Text--PACKT-">'45.2'.isdecimal()</code> returns <code class="Code-In-Text--PACKT-">False</code>. The real decimal character is represented by the Unicode value 0660, as in 45.2 (or <code class="Code-In-Text--PACKT-">45\u06602</code>). Further, these methods do not verify whether the strings are valid numbers; <code class="Code-In-Text--PACKT-">127.0.0.1</code> returns <code class="Code-In-Text--PACKT-">True</code> for all three methods. We might think we should use that decimal character instead of a period for all numeric quantities, but passing that character into the <code class="Code-In-Text--PACKT-">float()</code> or <code class="Code-In-Text--PACKT-">int()</code> constructor converts that decimal character to a zero:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; float('45\u06602')
4502.0
</code></pre>
    <p class="normal">The result of all these inconsistencies is that the Boolean numeric checks must be used carefully, knowing the details of the rules. We'll often need to write a regular expression (discussed later in this chapter) to confirm whether the string matches a specific numeric pattern. We call this LBYL-style programming: "Look Before You Leap." One very common approach is to use a <code class="Code-In-Text--PACKT-">try/except</code> block wrapped around an <code class="Code-In-Text--PACKT-">int()</code> or <code class="Code-In-Text--PACKT-">float()</code> conversion attempt. We call this EAFP-style programming: "It's Easier to Ask Forgiveness than to Ask Permission." The EAFP style fits naturally with Python.</p>
    <p class="normal">Other methods useful for <a id="_idIndexMarker610"/>pattern-matching do not return Booleans. The <code class="Code-In-Text--PACKT-">count()</code> method tells us how many times a given substring shows up in the string, while <code class="Code-In-Text--PACKT-">find()</code>, <code class="Code-In-Text--PACKT-">index()</code>, <code class="Code-In-Text--PACKT-">rfind()</code>, and <code class="Code-In-Text--PACKT-">rindex()</code> tell us the position of a given substring within the original string. Most operations start at the zero index and work from left to right. The two <code class="Code-In-Text--PACKT-">r</code> (for <em class="italic">right</em> or <em class="italic">reverse</em>) methods start searching from the highest index end of the string and work from right to left. The <code class="Code-In-Text--PACKT-">find()</code> methods return <code class="Code-In-Text--PACKT-">-1</code> if the substring can't be found, while <code class="Code-In-Text--PACKT-">index()</code> raises a <code class="Code-In-Text--PACKT-">ValueError</code> exception in this situation. Have a look at some of these methods in action:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; s = "hello world"
&gt;&gt;&gt; s.count('l')
3
&gt;&gt;&gt; s.find('l')
2
&gt;&gt;&gt; s.rindex('m')
Traceback (most recent call last):
...
File "&lt;doctest examples.md[11]&gt;", line 1, in &lt;module&gt;
s.rindex('m')
ValueError: substring not found
</code></pre>
    <p class="normal">Most of the remaining string methods return transformations of the string. The <code class="Code-In-Text--PACKT-">upper()</code>, <code class="Code-In-Text--PACKT-">lower()</code>, <code class="Code-In-Text--PACKT-">capitalize()</code>, and <code class="Code-In-Text--PACKT-">title()</code> methods create new strings with all alphabetical characters following the given format rules. The <code class="Code-In-Text--PACKT-">translate()</code> method can use a dictionary to map arbitrary input characters to specified output characters.</p>
    <p class="normal">For all of these methods, note that the input string remains unmodified; a brand new <code class="Code-In-Text--PACKT-">str</code> instance is created. If we need to manipulate the resultant string, we should assign it to a new variable, as in <code class="Code-In-Text--PACKT-">new_value = value.capitalize()</code>. Often, once we've performed the transformation, we don't need the old value anymore, so a common idiom is to assign it to the same variable, as in <code class="Code-In-Text--PACKT-">value = value.title()</code>.</p>
    <p class="normal">Finally, a couple of string methods return or operate on lists. The <code class="Code-In-Text--PACKT-">split()</code> method accepts a substring and splits the string into a list of strings breaking wherever that substring occurs. You can pass a number as a second parameter to limit the number of resultant strings. The <code class="Code-In-Text--PACKT-">rsplit()</code> method behaves identically to <code class="Code-In-Text--PACKT-">split()</code> if you don't limit the number of strings, but if you do supply a limit, it starts splitting from the end of the string. The <code class="Code-In-Text--PACKT-">partition()</code> and <code class="Code-In-Text--PACKT-">rpartition()</code> methods split the string at only the first or last occurrence of the substring, and return a tuple of three values: characters before the substring, the substring itself, and the characters after the substring.</p>
    <p class="normal">As the<a id="_idIndexMarker611"/> inverse of <code class="Code-In-Text--PACKT-">split()</code>, the <code class="Code-In-Text--PACKT-">join()</code> method accepts a list of strings, and returns all of those strings combined together by placing the original string between them. The <code class="Code-In-Text--PACKT-">replace()</code> method accepts two arguments, and returns a string where each instance of the first argument has been replaced with the second. Here are some of these methods in action:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; s = "hello world, how are you"
&gt;&gt;&gt; s2 = s.split(' ')
&gt;&gt;&gt; s2
['hello', 'world,', 'how', 'are', 'you']
&gt;&gt;&gt; '#'.join(s2)
'hello#world,#how#are#you'
&gt;&gt;&gt; s.replace(' ', '**')
'hello**world,**how**are**you'
&gt;&gt;&gt; s.partition(' ')
('hello', ' ', 'world, how are you')
</code></pre>
    <p class="normal">There you have it, a whirlwind tour of the most common methods on the <code class="Code-In-Text--PACKT-">str</code> class! Now, let's look at Python 3's approach to composing strings and values from variables and other expressions to create new strings.</p>
    <h2 id="_idParaDest-182" class="title">String formatting</h2>
    <p class="normal">Python 3 has powerful string formatting<a id="_idIndexMarker612"/> and templating mechanisms that allow us to construct strings comprised of template text and interspersed representations of objects usually from variables, but also from expressions. We've used it in many previous examples, but it is much more versatile than the simple formatting specifiers we've used.</p>
    <p class="normal">A format string (also <a id="_idIndexMarker613"/>called an <strong class="keyword">f-string</strong>) has a prefix on the opening quotation mark of <code class="Code-In-Text--PACKT-">f</code>, as in <code class="Code-In-Text--PACKT-">f"hello world"</code>. If such a string contains the special characters <code class="Code-In-Text--PACKT-">{</code> and <code class="Code-In-Text--PACKT-">}</code>, expressions, including variables from the surrounding scope, are evaluated and then interpolated into the string. Here's an example:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; name = "Dusty"
&gt;&gt;&gt; activity = "reviewing"
&gt;&gt;&gt; message = f"Hello {name}, you are currently {activity}."
&gt;&gt;&gt; print(message)
</code></pre>
    <p class="normal">If we run these statements, it replaces the braces with variables, in order:</p>
    <pre class="programlisting con"><code class="hljs-con">Hello Dusty, you are currently reviewing.
</code></pre>
    <h3 id="_idParaDest-183" class="title">Escaping braces</h3>
    <p class="normal">Brace characters <a id="_idIndexMarker614"/>are often useful in strings, aside from formatting. We need a way to escape them in situations where we want them to be displayed as themselves, rather than being replaced. This can be done by doubling the braces. For example, we can use Python to format a basic Java program:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; classname = "MyClass"
&gt;&gt;&gt; python_code = "print('hello world')"
&gt;&gt;&gt; template = f"""
... public class {classname} {{
...     public static void main(String[] args) {{
...         System.out.println("{python_code}");
...     }}
... }}
... """
</code></pre>
    <p class="normal">Where we see the <code class="Code-In-Text--PACKT-">{{</code> and <code class="Code-In-Text--PACKT-">}}</code> sequence in the template – that is, the braces enclosing the Java class and method definition – we know the f-string will replace them with single braces, rather than some argument in the surrounding methods. Here's the output:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; print(template)
public class MyClass {
    public static void main(String[] args) {
        System.out.println("print('hello world')");
    }
}
</code></pre>
    <p class="normal">The class name and contents of the output have been replaced with two parameters, while the double braces have been replaced with single braces, giving us a valid Java file. Turns out, this is about the simplest possible Python program to print the simplest possible Java program that can print the simplest possible Python program.</p>
    <h3 id="_idParaDest-184" class="title">f-strings can contain Python code</h3>
    <p class="normal">We aren't restricted to<a id="_idIndexMarker615"/> interpolating the values of simple string variables into an f-string template. Any primitives, such as integers or floats, can be formatted. More interestingly, complex objects, including lists, tuples, dictionaries, and arbitrary objects, can be used, and we can access indexes and variables or call functions on those objects from within the <code class="Code-In-Text--PACKT-">format</code> string.</p>
    <p class="normal">For example, if our<a id="_idIndexMarker616"/> email message had grouped the <code class="Code-In-Text--PACKT-">From</code> and <code class="Code-In-Text--PACKT-">To</code> email addresses into a tuple and placed the subject and message in a dictionary, for some reason (perhaps because that's the input required for an existing <code class="Code-In-Text--PACKT-">send_mail</code> function we want to use), we can format it like this:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; emails = ("steve@example.com", "dusty@example.com")
&gt;&gt;&gt; message = {
...     "subject": "Next Chapter",
...     "message": "Here's the next chapter to review!",
... }
&gt;&gt;&gt; formatted = f"""
... From: &lt;{emails[0]}&gt;
... To: &lt;{emails[1]}&gt;
... Subject: {message['subject']}
... 
... {message['message']}
... """
</code></pre>
    <p class="normal">The variables inside the braces in the template string look a little weird, so let's look at what they're doing. The two email addresses are looked up by the expression <code class="Code-In-Text--PACKT-">emails[x]</code>, where <code class="Code-In-Text--PACKT-">x</code> is either <code class="Code-In-Text--PACKT-">0</code> or <code class="Code-In-Text--PACKT-">1</code>. This is an ordinary tuple indexing operation, so <code class="Code-In-Text--PACKT-">emails[0]</code> refers to the first item in the <code class="Code-In-Text--PACKT-">emails</code> tuple. Similarly, the expression <code class="Code-In-Text--PACKT-">message['subject']</code> gets an item from a dictionary.</p>
    <p class="normal">This works out particularly well when we have a more complex object to display. We can extract object attributes and properties and even call methods inside the f-string. Let's change our email message data once again, this time to a class:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; class Notification:
...     def __init__(
...             self, 
...             from_addr: str, 
...             to_addr: str, 
...             subject: str, 
...             message: str
...     ) -&gt; None:
...         self.from_addr = from_addr
...         self.to_addr = to_addr
...         self.subject = subject
...         self._message = message
...     def message(self):
...         return self._message
</code></pre>
    <p class="normal">Here's an instance of the <code class="Code-In-Text--PACKT-">Notification</code> class:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; email = Notification(
...     "dusty@example.com",
...     "steve@example.com",
...     "Comments on the Chapter",
...     "Can we emphasize Python 3.9 type hints?",
... )
</code></pre>
    <p class="normal">We can use this email instance to fill in an f-string as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; formatted = f"""
... From: &lt;{email.from_addr}&gt;
... To: &lt;{email.to_addr}&gt;
... Subject: {email.subject}
... 
... {email.message()}
... """
</code></pre>
    <p class="normal">Pretty much any <a id="_idIndexMarker617"/>Python code that you would expect to return a string (or a value that can convert to a string with the <code class="Code-In-Text--PACKT-">str()</code> function) can be executed inside an f-string. As an example of how powerful it can get, you can even use a list comprehension or ternary operator in a format string parameter:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; f"{[2*a+1 for a in range(5)]}"
'[1, 3, 5, 7, 9]'
&gt;&gt;&gt; for n in range(1, 5):
...     print(f"{'fizz' if n % 3 == 0 else n}")
1
2
fizz
4
</code></pre>
    <p class="normal">In some cases, we'll want to include a label on the value. This is great for debugging; we can add an <code class="Code-In-Text--PACKT-">=</code> suffix to the expression. It looks like this:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; a = 5
&gt;&gt;&gt; b = 7
&gt;&gt;&gt; f"{a=}, {b=}, {31*a//42*b + b=}"
'a=5, b=7, 31*a//42*b + b=28'
</code></pre>
    <p class="normal">This technique creates a label and a value for us. It can be very helpful. Of course, there are a number of more sophisticated formatting options available to us.</p>
    <h3 id="_idParaDest-185" class="title">Making it look right</h3>
    <p class="normal">It's nice to be able to include variables in template strings, but sometimes the variables need a bit of coercion to make them look the way we want them to in the output. We're planning a sailing trip around the Chesapeake Bay. Starting from Annapolis, we want to visit Saint Michaels, Oxford, and Cambridge. To do this, we'll need to know the distances among these sailing ports. Here's a useful distance computation<a id="_idIndexMarker618"/> for relatively short distances. First, the formal math, because that can help explain the code:</p>
    <figure class="mediaobject"><img src="img/B17070_09_001.png" alt="" style="height: 2em;"/></figure>
    <p class="normal">This follows the same pattern as the hypotenuse of a triangle computation. </p>
    <figure class="mediaobject"><img src="img/B17070_09_002.png" alt="" style="height: 2em;"/></figure>
    <p class="normal">There are some differences, which are important:</p>
    <ul>
      <li class="bullet">We wrote <img src="img/B17070_09_003.png" alt="" style="height: 1em;"/> for the differences in the north-south latitudes, converted to radians from degrees. This seemed simpler than <img src="img/B17070_09_004.png" alt="" style="height: 1em;"/>.</li>
      <li class="bullet">We wrote <img src="img/B17070_09_005.png" alt="" style="height: 1em;"/> for the differences in the east-west longitudes, converted to radians from degrees. This is simpler than <img src="img/B17070_09_006.png" alt="" style="height: 1em;"/>. In some parts of the world, the longitudes will be a mix of positive and negative numbers, and we'll need to sort out the minimum positive-valued distance rather than compute a trip all the way around the world. </li>
      <li class="bullet">The value of R converts radians to nautical miles (about 1.85 km, 1.15 statute miles, exactly 1/60th of a degree of latitude).</li>
      <li class="bullet">The cosine computation<a id="_idIndexMarker619"/> reflects the way longitude distances compress toward zero at the pole. At the north pole, we can walk in a tiny circle and cover all 360°. At the equator, we have to walk (or walk and sail) 40,000 km to cover the same 360°.</li>
    </ul>
    <p class="normal">Otherwise, this is similar to the <code class="Code-In-Text--PACKT-">math.hypot()</code> function we used in the <em class="chapterRef">Chapter 3</em> case study, which means it involves square roots and awkwardly too-precise floating-point numbers.</p>
    <p class="normal">Here's the code:</p>
    <pre class="programlisting code"><code class="hljs-code">def distance(
        lat1: float, lon1: float, lat2: float, lon2: float
) -&gt; float:
    d_lat = radians(lat2) - radians(lat1)
    d_lon = min(
        (radians(lon2) - radians(lon1)) % (2 * pi),
        (radians(lon1) - radians(lon2)) % (2 * pi),
    )
    R = 60 * 180 / pi
    d = hypot(R * d_lat, R * cos(radians(lat1)) * d_lon)
    return d
</code></pre>
    <p class="normal">Here's our test case:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; annapolis = (38.9784, 76.4922)
&gt;&gt;&gt; saint_michaels = (38.7854, 76.2233)
&gt;&gt;&gt; round(distance(*annapolis, *saint_michaels), 9)
17.070608794
</code></pre>
    <p class="normal">That sounds like fun. A <code class="Code-In-Text--PACKT-">17.070608794</code> nautical mile trip in a sailboat going about 6 knots will take 2.845101465666667 hours to cross the bay. If the wind is lighter, maybe we'll only go 5 knots, and the trip will take 3.4141217588000004 hours. </p>
    <p class="normal">This is too many decimal places to be really useful. The boat is 42 feet (12.8m) long; that's 0.007 nautical miles; so, anything after the third decimal place is noise, not a useful result. We'll need to adjust these distances to provide useful information. Also, we have multiple legs, and we don't want to treat each leg as a special case. We need to provide better organization and better display of the data. </p>
    <p class="normal">Here's how we'd like to plan this trip. First, we'll define our four waypoints for the places we want to go. Then we'll combine the waypoints into legs.</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; annapolis = (38.9784, 76.4922)
&gt;&gt;&gt; saint_michaels = (38.7854, 76.2233)
&gt;&gt;&gt; oxford = (38.6865, 76.1716)
&gt;&gt;&gt; cambridge = (38.5632, 76.0788)
&gt;&gt;&gt; legs = [
...     ("to st.michaels", annapolis, saint_michaels),
...     ("to oxford", saint_michaels, oxford),
...     ("to cambridge", oxford, cambridge),
...     ("return", cambridge, annapolis),
... ]
</code></pre>
    <p class="normal">We can then use the distance computation<a id="_idIndexMarker620"/> to figure out how far it is to each destination. We can figure the speed to cover the distance, and we can even compute the fuel required if we can't sail and have to motor:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; speed = 5
&gt;&gt;&gt; fuel_per_hr = 2.2
&gt;&gt;&gt; for name, start, end in legs:
...     d = distance(*start, *end)
...     print(name, d, d/speed, d/speed*fuel_per_hr)
    to st.michaels 17.070608794397305 3.4141217588794612     7.511067869534815
    to oxford 6.407736547720565 1.281547309544113 2.8194040809970486
    to cambridge 8.580230239760064 1.716046047952013 3.7753013054944287
    return 31.571582240989173 6.314316448197834 13.891496186035237
</code></pre>
    <p class="normal">While we've structured the whole journey, we still have too many digits. Distances only need two decimal places at most. A tenth of an hour is six minutes; we don't need too many digits there. And fuel, similarly, can be computed to the nearest tenth of a gallon. (A tenth of a gallon is 0.4 liters.)</p>
    <p class="normal">The f-string substitution rules include formatting that can help us. After the expression (a variable is a very simple expression), we can use <code class="Code-In-Text--PACKT-">:</code> followed by a detailed description of the layout of the numbers. We'll return to the details after an example. Here's an improved plan with more <a id="_idIndexMarker621"/>useful print formatting:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; speed = 5
&gt;&gt;&gt; fuel_per_hr = 2.2
&gt;&gt;&gt; print(f"{'leg':16s} {'dist':5s} {'time':4s} {'fuel':4s}")
leg              dist  time fuel
&gt;&gt;&gt; for name, start, end in legs:
...     d = distance(*start, *end)
...     print(
...         f"{name:16s} {d:5.2f} {d/speed:4.1f} "
...         f"{d/speed*fuel_per_hr:4.0f}"
...     )
to st.michaels   17.07  3.4    8
to oxford             6.41  1.3    3
to cambridge      8.58  1.7    4
return                 31.57  6.3   14
</code></pre>
    <p class="normal">As an example, the <code class="Code-In-Text--PACKT-">:5.2f</code> format specifier says the following, from left to right:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">5</code>: take up at most five spaces – this guarantees column alignment when using a fixed-width font</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">.</code>: show the decimal point</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">2</code>: show two places after the decimal</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">f</code>: format the input value as a floating-point numeric value</li>
    </ul>
    <p class="normal">Nifty! The location is formatted as <code class="Code-In-Text--PACKT-">16s</code>. This follows the same pattern as the float format:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">16</code> means it should take up 16 characters. By default, with strings, if the string is shorter than the specified number of characters, it appends spaces to the right-hand side of the string to make it long enough (beware, however: if the original string is too long, it won't be truncated!).</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">s</code> means it is a string value.</li>
    </ul>
    <p class="normal">When we wrote the headings, we used an odd-looking f-string:</p>
    <pre class="programlisting code"><code class="hljs-code">f"{'leg':16s} {'dist':5s} {'time':4s} {'fuel':4s}")
</code></pre>
    <p class="normal">This has string literals like <code class="Code-In-Text--PACKT-">'leg'</code> with a format of <code class="Code-In-Text--PACKT-">16s</code>, and <code class="Code-In-Text--PACKT-">'dist'</code> with a format of <code class="Code-In-Text--PACKT-">5s</code>. The sizes are copied from the detail lines to make sure the headers fit over their respective columns. Making sure the sizes match makes it easy to be sure the heading and the details align.</p>
    <p class="normal">All these format specifiers have the same pattern; the details are optional:</p>
    <ul>
      <li class="bullet">A filler character (space if nothing is provided) that's used to pad out the number to fill in the specified size.</li>
      <li class="bullet">The alignment rule. By default, numbers are right-aligned and strings are left-aligned. Characters like <code class="Code-In-Text--PACKT-">&lt;</code>, <code class="Code-In-Text--PACKT-">^</code>, and <code class="Code-In-Text--PACKT-">&gt;</code> can force left, centered, or right alignment.</li>
      <li class="bullet">How to handle the sign (default is <code class="Code-In-Text--PACKT-">–</code> for negative, nothing for positive.) You can use <code class="Code-In-Text--PACKT-">+</code> to show all signs. Also, " " (a space) leaves a space for positive numbers and <code class="Code-In-Text--PACKT-">-</code> for negative numbers to assure proper alignment.</li>
      <li class="bullet">A <code class="Code-In-Text--PACKT-">0</code> if you want leading zeroes to fill in the front of the number.</li>
      <li class="bullet">The overall size of the field. This should include signs, decimal places, commas, and the period itself for floating-point numbers.</li>
      <li class="bullet">A <code class="Code-In-Text--PACKT-">,</code> if you want 1,000 groups separated by ",". Use <code class="Code-In-Text--PACKT-">_</code> to separate groups with an "_". If you have a locale where grouping is done with ".", and the decimal separator is ",", you'll want to use the <code class="Code-In-Text--PACKT-">n</code> format to use all of the locale settings. The <code class="Code-In-Text--PACKT-">f</code> format is biased toward locales that use "," for grouping.</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">.</code> if it's a float (<code class="Code-In-Text--PACKT-">f</code>) or general (<code class="Code-In-Text--PACKT-">g</code>) number, followed by the number of digits to the right of the decimal point.</li>
      <li class="bullet">The type. Common types are <code class="Code-In-Text--PACKT-">s</code> for strings, <code class="Code-In-Text--PACKT-">d</code> for decimal integers, and <code class="Code-In-Text--PACKT-">f</code> for floating-point. The default is <code class="Code-In-Text--PACKT-">s</code> for string. Most of the other format specifiers are alternative versions of these; for example, <code class="Code-In-Text--PACKT-">o</code> represents octal format and <code class="Code-In-Text--PACKT-">X</code> represents hexadecimal format for integers. The <code class="Code-In-Text--PACKT-">n</code> type specifier can be useful for formatting any kind of number in the current locale's format. For floating-point numbers, the <code class="Code-In-Text--PACKT-">%</code> type will multiply by 100 and format a float as a percentage.</li>
    </ul>
    <p class="normal">This is a very sophisticated way to display numbers. It can simplify otherwise confusing output, by reducing clutter and aligning data into columns when the information is related.</p>
    <div><p class="Tip--PACKT-"><strong class="keyword">Faulty Navigation Advice</strong></p>
      <p class="Tip--PACKT-">These waypoints are a little misleading. The route from St. Michaels to Oxford is only 6.41 miles if you're a bird. There's a big peninsula in the way, and it's actually a delightfully longer trip outside Poplar and Tilghman Islands and up the Choptank River. A superficial analysis of distances needs to be backed up with actually looking at the nautical chart and inserting a number of additional waypoints. Our algorithm permits this, and updating the list of legs is easy.</p>
    </div>
    <h3 id="_idParaDest-186" class="title">Custom formatters</h3>
    <p class="normal">While these standard<a id="_idIndexMarker622"/> formatters apply to most built-in objects, it is also possible for other objects to define nonstandard specifiers. For example, if we pass a <code class="Code-In-Text--PACKT-">datetime</code> object into <code class="Code-In-Text--PACKT-">format</code>, we can use the specifiers used in the <code class="Code-In-Text--PACKT-">datetime.strftime()</code> function, as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; import datetime 
&gt;&gt;&gt; important = datetime.datetime(2019, 10, 26, 13, 14)
&gt;&gt;&gt; f"{important:%Y-%m-%d %I:%M%p}"
'2019-10-26 01:14PM'
</code></pre>
    <p class="normal">It is even possible to write custom formatters for objects we create ourselves, but that is beyond the scope of this book. Look into overriding the <code class="Code-In-Text--PACKT-">__format__()</code> special method if you need to do this in your code.</p>
    <p class="normal">The Python formatting syntax is quite flexible, but it is a difficult mini-language to remember. It's helpful to bookmark the page in the Python standard library to help look up details. While good for many things, this formatting capability isn't powerful enough for larger-scale templating needs, such as generating web pages. There are several third-party templating libraries you can look into if you need to do more than basic formatting of a few strings.</p>
    <h3 id="_idParaDest-187" class="title">The format() method</h3>
    <p class="normal">F-strings were introduced <a id="_idIndexMarker623"/>in Python 3.6. Since Python 3.5's support ended in 2020 (see PEP-478 for details), we no longer need to worry about old Python runtimes without f-strings. There's a slightly more general tool for plugging values into a string template: the <code class="Code-In-Text--PACKT-">format()</code> method of a string. It uses the same formatting specifiers as f-strings. The values come from parameter values to the <code class="Code-In-Text--PACKT-">format()</code> method. Here's an example:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from decimal import Decimal
&gt;&gt;&gt; subtotal = Decimal('2.95') * Decimal('1.0625')
&gt;&gt;&gt; template = "{label}: {number:*^{size}.2f}" 
&gt;&gt;&gt; template.format(label="Amount", size=10, number=subtotal)
'Amount: ***3.13***'
&gt;&gt;&gt; grand_total = subtotal + Decimal('12.34')
&gt;&gt;&gt; template.format(label="Total", size=12, number=grand_total)
'Total: ***15.47****'
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">format()</code> method behaves similarly to an f-string with one important distinction: you can access values provided as the arguments to the <code class="Code-In-Text--PACKT-">format()</code> method only. This permits us to provide message templates as configuration items in a complex application.</p>
    <p class="normal">We have three ways to refer to the arguments that will be inserted into the template string:</p>
    <ul>
      <li class="bullet"><strong class="keyword">By name</strong>: The example has <code class="Code-In-Text--PACKT-">{label}</code> and <code class="Code-In-Text--PACKT-">{number}</code> in the template and provides the <code class="Code-In-Text--PACKT-">label=</code> and <code class="Code-In-Text--PACKT-">number= </code>named arguments to the <code class="Code-In-Text--PACKT-">format()</code> method.</li>
      <li class="bullet"><strong class="keyword">By position</strong>: We can use <code class="Code-In-Text--PACKT-">{0}</code> in the template, and this will use the first positional argument to <code class="Code-In-Text--PACKT-">format()</code>, like this: <code class="Code-In-Text--PACKT-">"Hello {0}!".format("world")</code>.</li>
      <li class="bullet"><strong class="keyword">By implied position</strong>: We can use <code class="Code-In-Text--PACKT-">{}</code> in the template, and this will use the positional arguments in order from the template, like this: <code class="Code-In-Text--PACKT-">"{} {}!".format("Hello", "world")</code>.</li>
    </ul>
    <p class="normal">Between<a id="_idIndexMarker624"/> f-strings and the <code class="Code-In-Text--PACKT-">format()</code> method of a template, we can create complex string values by interpolating expressions or values into a template. In most cases, the f-string is what we need. In rare cases where a format string might be a configuration parameter for a complex application, the <code class="Code-In-Text--PACKT-">format()</code> method is helpful.</p>
    <h2 id="_idParaDest-188" class="title">Strings are Unicode</h2>
    <p class="normal">At the beginning of this section, we <a id="_idIndexMarker625"/>defined strings as immutable collections of Unicode characters. This actually makes things very complicated at times, because Unicode isn't a storage format. If you get a string of bytes from a file or a socket, for example, they won't be in Unicode. They will, in fact, be the built-in type <code class="Code-In-Text--PACKT-">bytes</code>. Bytes are immutable sequences of...well, bytes. Bytes are the basic storage format in computing. They represent 8 bits, usually described as an integer between 0 and 255, or a hexadecimal equivalent between <code class="Code-In-Text--PACKT-">0x00</code> and <code class="Code-In-Text--PACKT-">0xFF</code>. Bytes don't represent anything specific; a sequence of bytes may store characters of an encoded string, or pixels in an image, or represent an integer, or part of a floating-point value.</p>
    <p class="normal">If we print a <code class="Code-In-Text--PACKT-">bytes</code> object, Python uses a canonical display that's reasonably compact. Any of the individual byte values that map to ASCII characters are displayed as characters, while non-character ASCII bytes are printed as escapes, either a one-character escape like <code class="Code-In-Text--PACKT-">\n</code> or a hex code like <code class="Code-In-Text--PACKT-">\x1b</code>. You may find it odd that a byte, represented as an integer, can map to an ASCII character. But the old ASCII code defined Latin letters for many different byte values. In ASCII the character <code class="Code-In-Text--PACKT-">a</code> is represented by the same byte as the integer 97, which is the hexadecimal number <code class="Code-In-Text--PACKT-">0x61</code>. All of these are an interpretation of the binary pattern <code class="Code-In-Text--PACKT-">0b1100001</code>. </p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; list(map(hex, b'abc'))
['0x61', '0x62', '0x63']
&gt;&gt;&gt; list(map(bin, b'abc'))
['0b1100001', '0b1100010', '0b1100011']
</code></pre>
    <p class="normal">Here's how the canonical display bytes might look when they have a mixture of values that have ASCII character representations and values that don't have a simple character:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; bytes([137, 80, 78, 71, 13, 10, 26, 10])
b'\x89PNG\r\n\x1a\n'
</code></pre>
    <p class="normal">The first byte used <a id="_idIndexMarker626"/>a hexadecimal escape, <code class="Code-In-Text--PACKT-">\x89</code>. The next three bytes had ASCII characters, <code class="Code-In-Text--PACKT-">P</code>, <code class="Code-In-Text--PACKT-">N</code>, and <code class="Code-In-Text--PACKT-">G</code>. The next two characters had one-character escapes, <code class="Code-In-Text--PACKT-">\r</code> and <code class="Code-In-Text--PACKT-">\n</code>. The seventh byte also had a hexadecimal escape, <code class="Code-In-Text--PACKT-">\x1a</code>, because there was no other encoding. The final byte is another one-character escape, <code class="Code-In-Text--PACKT-">\n</code>. The eight bytes were expanded into 17 printable characters, not counting the prefix <code class="Code-In-Text--PACKT-">b'</code> and the final <code class="Code-In-Text--PACKT-">'</code>.</p>
    <p class="normal">Many I/O operations only know how to deal with <code class="Code-In-Text--PACKT-">bytes</code>, even if the <code class="Code-In-Text--PACKT-">bytes</code> object is the encoding of textual data. It is therefore vital to know how to convert between <code class="Code-In-Text--PACKT-">bytes</code> values and Unicode <code class="Code-In-Text--PACKT-">str</code> values.</p>
    <p class="normal">The problem is that there are many encodings that map <code class="Code-In-Text--PACKT-">bytes</code> to Unicode text. Several are true international standards, but many others are parts of commercial offerings, making them really popular, but not – exactly – standardized. The Python <code class="Code-In-Text--PACKT-">codecs</code> module provides many of these code-decode rules for decoding bytes into a string and encoding a string into bytes.</p>
    <p class="normal">The important consequence of multiple encodings is that the same sequence of bytes represents completely different text characters when mapped using different encodings! So, <code class="Code-In-Text--PACKT-">bytes</code> must be decoded using the same character set with which they were encoded. It's not possible to get text from bytes without knowing how the bytes should be decoded. If we receive unknown bytes without a specified encoding, the best we can do is guess what format they are encoded in, and we are likely to be wrong.</p>
    <h3 id="_idParaDest-189" class="title">Decoding bytes to text</h3>
    <p class="normal">If we have an <a id="_idIndexMarker627"/>array of <code class="Code-In-Text--PACKT-">bytes</code> from somewhere, we can convert it to Unicode<a id="_idIndexMarker628"/> using the <code class="Code-In-Text--PACKT-">.decode()</code> method on the <code class="Code-In-Text--PACKT-">bytes</code> class. This method accepts a string for the name of the character encoding. There are many such encodings; common ones include ASCII, UTF-8, latin-1, and cp-1252. Of these, UTF-8 is one of the most commonly used.</p>
    <p class="normal">The sequence of bytes (in hex), <code class="Code-In-Text--PACKT-">63 6c 69 63 68 c3 a9</code>, actually represents the characters of the word cliche in UTF-8 encoding:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; characters = b'\x63\x6c\x69\x63\x68\xc3\xa9' 
&gt;&gt;&gt; characters 
b'clich\xc3\xa9'
</code></pre>
    <p class="normal">The first line creates a <code class="Code-In-Text--PACKT-">bytes</code> literal as a <code class="Code-In-Text--PACKT-">b''</code> string. The <code class="Code-In-Text--PACKT-">b</code> character immediately before the string tells us that we are defining a <code class="Code-In-Text--PACKT-">bytes</code> object instead of a normal Unicode text string. Within the string, each byte is specified using – in this case – a hexadecimal number. The <code class="Code-In-Text--PACKT-">\x</code> character escapes within the byte string, and each says <em class="italic">the next two characters represent a byte using hexadecimal digits</em>.</p>
    <p class="normal">The final line is the <a id="_idIndexMarker629"/>output, showing us Python's canonical representation of a <code class="Code-In-Text--PACKT-">bytes</code> object. The first five of the seven bytes had an ASCII character that could be used. The<a id="_idIndexMarker630"/> final two bytes, however, don't have ASCII characters, and <code class="Code-In-Text--PACKT-">\xc3\xa9</code> had to be used.</p>
    <p class="normal">Provided we are using a shell that understands UTF-8 encoding, we can decode the bytes to Unicode and see the following: </p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; characters.decode("utf-8") 
'cliché'
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">decode</code> method returns a text (Unicode) <code class="Code-In-Text--PACKT-">str</code> object, with the correct characters. Note that the <code class="Code-In-Text--PACKT-">\xc3\xa9 </code>sequence of bytes maps to a single Unicode character.</p>
    <p class="normal">In some cases, the Python terminal may not have the correct encodings defined so the operating system can pick the right characters from the OS font. Yes, there's a very complex mapping from bytes to text to displayed characters, part of which is a Python problem, and part of which is an OS problem. Ideally, your computer is using UTF-8 encodings and has fonts with the full Unicode character set. If not, you may need to research the <code class="Code-In-Text--PACKT-">PYTHONIOENCODING</code> environment variable. See <a href="https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONIOENCODING">https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONIOENCODING</a>. </p>
    <p class="normal">However, if we had decoded this same string using the Cyrillic <code class="Code-In-Text--PACKT-">iso8859-5</code> encoding, we'd have ended up with this:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; characters.decode("iso8859-5")
'clichУЉ'
</code></pre>
    <p class="normal">This is because the <code class="Code-In-Text--PACKT-">\xc3\xa9</code>  bytes map to different characters in the other encoding. Over the years a lot of different encodings have been invented, and not all of them are in wide use.</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; characters.decode("cp037")
'Ä%ÑÄÇZ'
</code></pre>
    <p class="normal">This is why we<a id="_idIndexMarker631"/> need to know the encoding used. Generally, UTF-8 <a id="_idIndexMarker632"/>should be the encoding of choice. This is a common default, but it isn't universal.</p>
    <h3 id="_idParaDest-190" class="title">Encoding text to bytes</h3>
    <p class="normal">The flip side of <a id="_idIndexMarker633"/>converting bytes to Unicode is situations where we convert <a id="_idIndexMarker634"/>outgoing Unicode into byte sequences. This is done with the <code class="Code-In-Text--PACKT-">encode()</code> method on the <code class="Code-In-Text--PACKT-">str</code> class, which, like the <code class="Code-In-Text--PACKT-">decode()</code> method, requires an encoding name. The following code creates a Unicode string and encodes it in different character sets:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; characters = "cliché" 
&gt;&gt;&gt; characters.encode("UTF-8")
b'clich\xc3\xa9'
&gt;&gt;&gt; characters.encode("latin-1")
b'clich\xe9'
&gt;&gt;&gt; characters.encode("cp1252")
b'clich\xe9'
&gt;&gt;&gt; characters.encode("CP437")
b'clich\x82'
&gt;&gt;&gt; characters.encode("ascii") 
Traceback (most recent call last):
...
File "&lt;doctest examples.md[73]&gt;", line 1, in &lt;module&gt;
characters.encode("ascii")
UnicodeEncodeError: 'ascii' codec can't encode character '\xe9' in position 5: ordinal not in range(128)
</code></pre>
    <p class="normal">Now you should understand the importance of encodings! The accented character is represented as a different byte by most of these encodings; if we use the wrong one when we are decoding bytes to text, we get the wrong character.</p>
    <p class="normal">The exception in the last case is not always the desired behavior; there may be cases where we want the unknown characters to be handled in a different way. The <code class="Code-In-Text--PACKT-">encode</code> method takes an optional string argument named <code class="Code-In-Text--PACKT-">errors</code> that can define how such characters should be handled. This string can be one of the following:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">"strict"</code></li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">"replace"</code></li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">"ignore"</code></li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">"xmlcharrefreplace"</code></li>
    </ul>
    <p class="normal">The <code class="Code-In-Text--PACKT-">strict</code> replacement strategy is the default we just saw. When a byte sequence is encountered <a id="_idIndexMarker635"/>that does not have a valid representation in the requested <a id="_idIndexMarker636"/>encoding, an exception is raised. When the <code class="Code-In-Text--PACKT-">replace</code> strategy is used, the character is replaced with a different character. In ASCII, it is a question mark; other encodings may use different symbols, such as an empty box. </p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">ignore</code> strategy simply discards any bytes it doesn't understand, while the <code class="Code-In-Text--PACKT-">xmlcharrefreplace</code> strategy creates an <code class="Code-In-Text--PACKT-">xml</code> entity representing the Unicode character. This can be useful when converting unknown strings for use in an XML document. </p>
    <p class="normal">Here's how each of the strategies affects our sample word:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; characters = "cliché" 
&gt;&gt;&gt; characters.encode("ascii", "replace")
b'clich?'
&gt;&gt;&gt; characters.encode("ascii", "ignore")
b'clich'
&gt;&gt;&gt; characters.encode("ascii", "xmlcharrefreplace")
b'clich&amp;#233;'
</code></pre>
    <p class="normal">It is possible to call the <code class="Code-In-Text--PACKT-">str.encode()</code> and <code class="Code-In-Text--PACKT-">bytes.decode()</code> methods without passing an encoding name. The encoding will be set to the default encoding for the current platform. This will depend on the current operating system and locale or regional settings; you can look it up using the <code class="Code-In-Text--PACKT-">sys.getdefaultencoding()</code> function. It is usually a good idea to specify the encoding explicitly, though, since the default encoding for a platform may change, or the program may one day be extended to work on text from a wider variety of sources.</p>
    <p class="normal">If you are encoding text and don't know which encoding to use, it is best to use UTF-8 encoding. UTF-8 is able to represent any Unicode character. In modern software, it is a widely used, standard encoding to ensure documents in any language—or even multiple languages—can be exchanged. The various other possible encodings are useful for legacy documents or in software that uses different character encodings by default.</p>
    <p class="normal">The UTF-8 encoding <a id="_idIndexMarker637"/>uses one byte to represent ASCII and other common characters, and<a id="_idIndexMarker638"/> up to four bytes for other characters. UTF-8 is special because it is (mostly) backward-compatible with ASCII; an ASCII document encoded using UTF-8 will be almost identical to the original ASCII document. </p>
    <div><p class="Tip--PACKT-"><strong class="keyword">Encode vs. Decode</strong></p>
      <p class="Tip--PACKT-">It's hard to remember whether to use <code class="Code-In-Text--PACKT-">encode</code> or <code class="Code-In-Text--PACKT-">decode</code> to convert from binary bytes to Unicode text. The problem is that the letters "code" in Uni<em class="italic">code</em> can be confusing. I suggest ignoring them. If we think of bytes as code, we encode plain text to bytes and decode bytes back to plain text.</p>
    </div>
    <h3 id="_idParaDest-191" class="title">Mutable byte strings</h3>
    <p class="normal">The <code class="Code-In-Text--PACKT-">bytes</code> type, like <code class="Code-In-Text--PACKT-">str</code>, is immutable. We can use index and slice notation on a <code class="Code-In-Text--PACKT-">bytes</code> object and <a id="_idIndexMarker639"/>search for a particular sequence of bytes, but we can't extend or modify them. This can be inconvenient when dealing with I/O, as it is often necessary to buffer incoming or outgoing bytes until they are ready to be sent. For example, if we are receiving data from a socket, we may have to accumulate the results of several <code class="Code-In-Text--PACKT-">recv</code> calls before we have received an entire message.</p>
    <p class="normal">This is where the <code class="Code-In-Text--PACKT-">bytearray</code> built-in comes in. This type behaves something like a list, except it only holds bytes. The constructor for the class can accept a <code class="Code-In-Text--PACKT-">bytes</code> object to initialize it. The <code class="Code-In-Text--PACKT-">extend</code> method can be used to append another <code class="Code-In-Text--PACKT-">bytes</code> object to the existing array (for example, when more data comes from a socket or other I/O channel).</p>
    <p class="normal">Slice notation can be used on <code class="Code-In-Text--PACKT-">bytearray</code> to modify the item in place, without the overhead of creating a new object. For example, this code constructs a <code class="Code-In-Text--PACKT-">bytearray</code> from a <code class="Code-In-Text--PACKT-">bytes</code> object and then replaces two bytes:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; ba = bytearray(b"abcdefgh") 
&gt;&gt;&gt; ba[4:6] = b"\x15\xa3"
&gt;&gt;&gt; ba
bytearray(b'abcd\x15\xa3gh')
</code></pre>
    <p class="normal">We used slice notation to replace bytes in the <code class="Code-In-Text--PACKT-">[4:6]</code> slice with two replacement bytes, <code class="Code-In-Text--PACKT-">b"\x15\xa3"</code>.</p>
    <p class="normal">If we want to manipulate a single element in <code class="Code-In-Text--PACKT-">bytearray</code>, the value must be an integer between 0 and 255 (inclusive), which is a specific <code class="Code-In-Text--PACKT-">bytes</code> pattern. If we try to pass a character or <code class="Code-In-Text--PACKT-">bytes</code> object, it will raise an exception.</p>
    <p class="normal">A single byte character can be converted to an integer using the <code class="Code-In-Text--PACKT-">ord()</code> (short for <em class="italic">ordinal</em>) function. This function returns the integer representation of a single character:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; ba = bytearray(b"abcdefgh") 
&gt;&gt;&gt; ba[3] = ord(b'g')
&gt;&gt;&gt; ba[4] = 68
&gt;&gt;&gt; ba
bytearray(b'abcgDfgh')
</code></pre>
    <p class="normal">After constructing the <a id="_idIndexMarker640"/>array, we replace the character at index <code class="Code-In-Text--PACKT-">3</code> (the fourth character, as indexing starts at <code class="Code-In-Text--PACKT-">0</code>, as with lists) with byte <code class="Code-In-Text--PACKT-">103</code>. This integer was returned by the <code class="Code-In-Text--PACKT-">ord()</code> function and is the ASCII character for the lowercase <code class="Code-In-Text--PACKT-">g</code>. </p>
    <p class="normal">For illustration, we also replaced the next character up with byte number <code class="Code-In-Text--PACKT-">68</code>, which maps to the ASCII character for the uppercase <code class="Code-In-Text--PACKT-">D</code>.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">bytearray</code> type has methods that allow it to behave like a list (we can append integer bytes to it, for example). It can also behave like a <code class="Code-In-Text--PACKT-">bytes</code> object (we can use methods such as <code class="Code-In-Text--PACKT-">count()</code> and <code class="Code-In-Text--PACKT-">find()</code>). The difference is that <code class="Code-In-Text--PACKT-">bytearray</code> is a mutable type, which can be useful for building up complex sequences of bytes from a specific input source. We may, for example, have to read a four byte header with length information before reading the payload bytes. It's handy to be able to perform the reads directly into a mutable <code class="Code-In-Text--PACKT-">bytearray</code> to save creating lots of small objects in memory.</p>
    <h1 id="_idParaDest-192" class="title">Regular expressions</h1>
    <p class="normal">You know <a id="_idIndexMarker641"/>what's really hard to do using object-oriented principles? Parsing strings to match arbitrary patterns, that's what. There have been a fair number of academic papers written in which object-oriented design is used to set up string-parsing, but the results seem too verbose and hard to read, and they are not widely used in practice.</p>
    <p class="normal">In the real world, string-parsing in most programming languages is handled by regular expressions. These are not verbose, but, wow, are they ever hard to read, at least until you learn the syntax. Even though regular expressions are not object-oriented, the Python regular expression library provides a few classes and objects that you can use to construct and run regular expressions.</p>
    <p class="normal">While we use regular expressions to "match" a string, this is only a partial description of what a regular expression really is. It can help to think of a regular expression as a mathematical rule that could generate a (potentially infinite) collection of strings. When we "match" a regular expression, it's similar to asking if a given string is in the set generated by the expression. What's tricky is rewriting some fancy math using the paltry collection of punctuation marks available in the original ASCII character set. To help explain the syntax of regular expressions, we'll take a little side-tour through some of these typographic problems that make regular expressions a challenge to read.</p>
    <p class="normal">Here's an idealized mathematical regular expression for a small set of strings: <em class="italic">world</em>. We want to match these five characters. The set has one string, <code class="Code-In-Text--PACKT-">"world"</code>, that matches. This doesn't seem too complex; the expression amounts to w AND o AND r AND l AND d with "AND" being implied. This parallels the way <img src="img/B17070_09_007.png" alt="" style="height: 0.9em;"/> means d = r <em class="italic">times</em> t; the multiplication is implied.</p>
    <p class="normal">Here's a regular<a id="_idIndexMarker642"/> expression for a pattern with repeats: <img src="img/B17070_09_008.png" alt="" style="height: 1em;"/>. We want to match five characters, but one of them must occur twice. This set has one string, <code class="Code-In-Text--PACKT-">"hello"</code>, that matches. This emphasizes the parallel between regular expressions, multiplication, and exponents. It also points out the use of exponents to distinguish between matching the <code class="Code-In-Text--PACKT-">2</code> character and matching the previous regular expression two times.</p>
    <p class="normal">Sometimes, we want some flexibility, and we want to match any digit. Mathematical typesetting lets us use a new font for this: we can say <img src="img/B17070_09_009.png" alt="" style="height: 1em;"/>. This fancy-looking D means any digit, or <img src="img/B17070_09_010.png" alt="" style="height: 1.2em;"/>, and the raised 4 means four copies. This describes a set that has 10,000 possible matching strings from "0000" to "9999". Why use the fancy math typesetting? We can use different fonts and letter arrangements to distinguish the concept of "any digit" and "four copies" from the letter <code class="Code-In-Text--PACKT-">D</code> and the digit <code class="Code-In-Text--PACKT-">4</code>. Code – as we'll see – lacks the fancy fonts, forcing designers to work around the distinction between letters meaning themselves, like <code class="Code-In-Text--PACKT-">D</code>, and letters having other useful meanings, like <img src="img/B17070_09_011.png" alt="" style="height: 1em;"/>.</p>
    <p class="normal">And yes, a regular expression looks a lot like a long multiplication. There's a very strong parallel with "must have these" and multiplication. Is there a parallel with addition? Yes, it's the idea of optional or alternative constructs; in effect an "or" instead of the default "and."</p>
    <p class="normal">What if we <a id="_idIndexMarker643"/>want to describe years in a date where there could be two digits or four digits? Mathematically, we might say <img src="img/B17070_09_012.png" alt="" style="height: 1em;"/>. What if we're not sure how many digits? We have a special "to any power," the Kleene star. We can say <img src="img/B17070_09_013.png" alt="" style="height: 1em;"/> to mean any number of repeats of a character in the <img src="img/B17070_09_014.png" alt="" style="height: 1em;"/> set.</p>
    <p class="normal">All of this math typesetting has to be implemented in the regular expression language. This can make it difficult to sort out precisely what a regular expression means.</p>
    <p class="normal">Regular expressions are used to solve a common problem: given a string, determine whether that string matches a given pattern and, optionally, collect substrings that contain relevant information. They can be used to answer questions such as the following:</p>
    <ul>
      <li class="bullet">Is this string a valid URL?</li>
      <li class="bullet">What is the date and time of all warning messages in a log file?</li>
      <li class="bullet">Which users in <code class="Code-In-Text--PACKT-">/etc/passwd</code> are in a given group?</li>
      <li class="bullet">What username and document were requested by the URL a visitor typed?</li>
    </ul>
    <p class="normal">There are many similar scenarios where regular expressions are the correct answer. In this section, we'll gain enough knowledge of regular expressions to compare strings against relatively common patterns.</p>
    <p class="normal">There are important limitations here. Regular expressions don't describe languages with recursive structures. When we look at XML or HTML, for example, a <code class="Code-In-Text--PACKT-">&lt;p&gt;</code> tag can contain inline <code class="Code-In-Text--PACKT-">&lt;span&gt;</code> tags, like this: <code class="Code-In-Text--PACKT-">&lt;p&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;/p&gt;</code>. This recursive nesting of tag-within-tag is generally not a great thing to try and process with a regular expression. We can recognize the individual elements of the XML language, but higher-level constructs like a paragraph tag with other tags inside it require more powerful tools than regular expressions. The XML parsers in the Python standard library can handle these more complex constructs.</p>
    <h2 id="_idParaDest-193" class="title">Matching patterns</h2>
    <p class="normal">Regular expressions<a id="_idIndexMarker644"/> are a complicated mini-language. We need to be able to describe individual characters as well as classes of characters, as well as operators that group and combine characters, all using a few ASCII-compatible characters. Let's start with literal characters, such as letters, numbers, and the space character, which always match themselves. Let's see a basic example:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; import re 
&gt;&gt;&gt; search_string = "hello world"
&gt;&gt;&gt; pattern = r"hello world"
&gt;&gt;&gt; if match := re.match(pattern, search_string): 
...     print("regex matches") 
...     print(match)
regex matches
&lt;re.Match object; span=(0, 11), match='hello world'&gt;
</code></pre>
    <p class="normal">The Python Standard Library module for regular expressions is called <code class="Code-In-Text--PACKT-">re</code>. We import it and set up a search string and pattern to search for; in this case, they are the same string. Since the search string matches the given pattern, the conditional passes and the <code class="Code-In-Text--PACKT-">print</code> statement executes.</p>
    <p class="normal">A successful match returns a <code class="Code-In-Text--PACKT-">re.Match</code> object describing what – exactly – matched. A failing match returns <code class="Code-In-Text--PACKT-">None</code>, which is equivalent to <code class="Code-In-Text--PACKT-">False</code> in the Boolean context of an <code class="Code-In-Text--PACKT-">if</code>-statement.</p>
    <p class="normal">We've used the "walrus" operator (<code class="Code-In-Text--PACKT-">:=</code>) to compute the results of <code class="Code-In-Text--PACKT-">re.match()</code> and save those results in a variable all as part of an <code class="Code-In-Text--PACKT-">if</code>-statement. This is one of the most common ways to use the walrus operator to compute a result and then test the result to see if it's truthy. This is a little optimization that can help clarify how the results of the matching operation will be used if they are not <code class="Code-In-Text--PACKT-">None</code>.</p>
    <p class="normal">We'll almost<a id="_idIndexMarker645"/> always use "raw" strings with the <code class="Code-In-Text--PACKT-">r</code> prefix for regular expressions. Raw strings do not have the backslash escapes processed by Python into other letters. In an ordinary string, for example, <code class="Code-In-Text--PACKT-">\b</code> is transformed to a single backspace character. In a raw string, it's two characters, <code class="Code-In-Text--PACKT-">\</code> and <code class="Code-In-Text--PACKT-">b</code>. In this example, the r-string wasn't really needed because the pattern didn't involve any special <code class="Code-In-Text--PACKT-">\d</code> or <code class="Code-In-Text--PACKT-">\w</code> kinds of regular expression symbols. Using r-strings is a good habit, and we'll try to do it consistently.</p>
    <p class="normal">Bear in mind that the <code class="Code-In-Text--PACKT-">match</code> function matches the pattern anchored at the beginning of the string. Thus, if the pattern were <code class="Code-In-Text--PACKT-">r"ello world"</code>, no match would be found because the <code class="Code-In-Text--PACKT-">search_string</code> value starts with "h" not "e". With confusing asymmetry, the parser stops searching as soon as it finds a match, so the pattern <code class="Code-In-Text--PACKT-">r"hello wo"</code> matches the <code class="Code-In-Text--PACKT-">search_string</code> value successfully, with a few characters left over. Let's build a small example program to <a id="_idIndexMarker646"/>demonstrate these differences and help us learn other regular expression syntax:</p>
    <pre class="programlisting code"><code class="hljs-code">import re
from typing import Pattern, Match
def matchy(pattern: Pattern[str], text: str) -&gt; None:
    if match := re.match(pattern, text):
        print(f"{pattern=!r} matches at {match=!r}")
    else:
        print(f"{pattern=!r} not found in {text=!r}")
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">matchy()</code> function expands on the earlier example; it accepts the pattern and search string as parameters. We can see how the start of the pattern must match, but a value is returned as soon as a match is found.</p>
    <p class="normal">Here are some examples of using this function:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; matchy(pattern=r"hello wo", text="hello world")
pattern='hello wo' matches at match=&lt;re.Match object; span=(0, 8), match='hello wo'&gt;
&gt;&gt;&gt; matchy(pattern=r"ello world", text="hello world")
pattern='ello world' not found in text='hello world'
</code></pre>
    <p class="normal">We'll be using this function throughout the next few sections. A sequence of test cases is a common way to develop a regular expression – from a bunch of examples of text we want to match and text we don't want to match, we test to make sure our expression works as expected.</p>
    <p class="normal">If you need control over whether items happen at the beginning or end of a line (or if there are no newlines in the string, or at the beginning and end of the string), you can use the <code class="Code-In-Text--PACKT-">^</code> and <code class="Code-In-Text--PACKT-">$</code> characters to represent the start and end of the string respectively. </p>
    <p class="normal">If you want a pattern to match an entire string, it's a good idea to include both of these:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; matchy(pattern=r"^hello world$", text="hello world")
pattern='^hello world$' matches at match=&lt;re.Match object; span=(0, 11), match='hello world'&gt;
&gt;&gt;&gt; matchy(pattern=r"^hello world$", text="hello worl")
pattern='^hello world$' not found in text='hello worl'
</code></pre>
    <p class="normal">We call the <code class="Code-In-Text--PACKT-">^</code> and <code class="Code-In-Text--PACKT-">$</code> characters "anchors." They anchor the match to the beginning or end of the string. What's important is that they don't literally match themselves; they're also called meta-characters. If we were doing fancy math typesetting, we'd use a different font to <a id="_idIndexMarker647"/>distinguish between <code class="Code-In-Text--PACKT-">^</code> meaning anchored at the beginning and <code class="Code-In-Text--PACKT-">^</code> meaning the actual <code class="Code-In-Text--PACKT-">"^"</code> character. Since we don't have fancy math typesetting in Python code, we use <code class="Code-In-Text--PACKT-">\</code> to distinguish between meta-character and ordinary character. In this case, <code class="Code-In-Text--PACKT-">^</code> is a meta-character, and <code class="Code-In-Text--PACKT-">\^</code> is the ordinary character.</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; matchy(pattern=r"\^hello world\$", text="hello worl")
pattern='\\^hello world\\$' not found in text='hello worl'
&gt;&gt;&gt; matchy(pattern=r"\^hello world\$", text="^hello world$")
pattern='\\^hello world\\$' matches at match=&lt;re.Match object; span=(0, 13), match='^hello world$'&gt;
</code></pre>
    <p class="normal">Because we used <code class="Code-In-Text--PACKT-">\^</code>, we need to match the <code class="Code-In-Text--PACKT-">^</code> character in the string; this is not the meta-character acting as an anchor. Note that we used <code class="Code-In-Text--PACKT-">r"\^hello…"</code> to create a raw string. Python's canonical display came back as <code class="Code-In-Text--PACKT-">'\\^hello…'</code>. The canonical version – with double <code class="Code-In-Text--PACKT-">\\</code> – can be awkward to type. While raw strings are easier to work with, they don't display the way we entered them.</p>
    <h3 id="_idParaDest-194" class="title">Matching a selection of characters</h3>
    <p class="normal">Let's start with matching <a id="_idIndexMarker648"/>an arbitrary character. The period character, when used in a regular expression pattern, is a meta-character that stands for a set containing all characters. This will match any single character. Using a period in the string means you don't care what the character is, just that there is a character there. Here is some example output from the <code class="Code-In-Text--PACKT-">matchy()</code> function:</p>
    <pre class="programlisting con"><code class="hljs-con">pattern='hel.o world' matches at match=&lt;re.Match object; span=(0, 11), match='hello world'&gt;
pattern='hel.o world' matches at match=&lt;re.Match object; span=(0, 11), match='helpo world'&gt;
pattern='hel.o world' matches at match=&lt;re.Match object; span=(0, 11), match='hel o world'&gt;
pattern='hel.o world' not found in text='helo world'
</code></pre>
    <p class="normal">Notice how the last example does not match because there is no character at the period's position in the pattern. We can't match "nothing" without some extra features. We'll get to the idea of optional characters later in this section.</p>
    <p class="normal">That's all well and <a id="_idIndexMarker649"/>good, but what if we only want a smaller set of characters to match? We can put a set of characters inside square brackets to match any one of those characters. So, if we encounter the string <code class="Code-In-Text--PACKT-">[abc]</code> in a regular expression pattern, this defines a set of alternatives to match one character in the string being searched; this one character will be in the set of characters. Note that the <code class="Code-In-Text--PACKT-">[]</code> around the set are meta-characters; they enclose the set and don't match themselves. Let's see a few examples:</p>
    <pre class="programlisting con"><code class="hljs-con">pattern='hel[lp]o world' matches at match=&lt;re.Match object; span=(0, 11), match='hello world'&gt;
pattern='hel[lp]o world' matches at match=&lt;re.Match object; span=(0, 11), match='helpo world'&gt;
pattern='hel[lp]o world' not found in text='helPo world'
</code></pre>
    <p class="normal">As with <code class="Code-In-Text--PACKT-">^</code> and <code class="Code-In-Text--PACKT-">$</code>, the characters <code class="Code-In-Text--PACKT-">.</code>, <code class="Code-In-Text--PACKT-">[</code> and <code class="Code-In-Text--PACKT-">]</code> are meta-characters. Meta-characters define a more complex feature of a regular expression. If we want to actually match a <code class="Code-In-Text--PACKT-">[</code> character, we'd use <code class="Code-In-Text--PACKT-">\[</code> to escape the meta-meaning and understand this to match <code class="Code-In-Text--PACKT-">[</code> instead of starting the definition of a class of characters.</p>
    <p class="normal">These square bracket sets could be named <em class="italic">character sets</em>, but they are more often referred to as <strong class="keyword">character classes</strong>. Often, we want to include a large range of characters inside these sets, and<a id="_idIndexMarker650"/> typing them all out can be monotonous and error-prone. Fortunately, the regular expression designers thought of this and gave us a shortcut. The dash character, in a character set, will create a range. This is especially useful if you want to match <em class="italic">all lowercase letters</em>, <em class="italic">all letters</em>, or <em class="italic">all numbers,</em> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">'hello   world' does not match pattern='hello [a-z] world'
'hello b world' matches pattern='hello [a-z] world'
'hello B world' matches pattern='hello [a-zA-Z] world'
'hello 2 world' matches pattern='hello [a-zA-Z0-9] world'
</code></pre>
    <p class="normal">There are some character classes that are so common they have their own abbreviations. <code class="Code-In-Text--PACKT-">\d</code> is digits, <code class="Code-In-Text--PACKT-">\s</code> is whitespace, and <code class="Code-In-Text--PACKT-">\w</code> is "word" characters. Instead of <code class="Code-In-Text--PACKT-">[0-9]</code>, use <code class="Code-In-Text--PACKT-">\d</code>. Instead of trying to enumerate all the Unicode whitespace characters, use <code class="Code-In-Text--PACKT-">\s</code>. Instead of <code class="Code-In-Text--PACKT-">[a-z0-9_]</code>, use <code class="Code-In-Text--PACKT-">\w</code>. Here's an example: </p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; matchy(r'\d\d\s\w\w\w\s\d\d\d\d', '26 Oct 2019')
pattern='\\d\\d\\s\\w\\w\\w\\s\\d\\d\\d\\d' matches at match=&lt;re.Match object; span=(0, 11), match='26 Oct 2019'&gt;
</code></pre>
    <p class="normal">Without the defined sets, this pattern would start out as <code class="Code-In-Text--PACKT-">[0-9][0-9][ \t\n\r\f\v][A-Za-z0-9_][A-Za-z0-9_][A-Za-z0-9_]</code>. It gets quite long as we repeat the <code class="Code-In-Text--PACKT-">[ \t\n\r\f\v]</code> class and the <code class="Code-In-Text--PACKT-">[0-9]</code> class four more times.</p>
    <p class="normal">When defining a <a id="_idIndexMarker651"/>class with <code class="Code-In-Text--PACKT-">[]</code>'s, the <code class="Code-In-Text--PACKT-">–</code> becomes a meta-character. What if we want to match <code class="Code-In-Text--PACKT-">[A-Z]</code> and <code class="Code-In-Text--PACKT-">-</code>, too? We can do this by including the <code class="Code-In-Text--PACKT-">–</code> at the very beginning or the very end; <code class="Code-In-Text--PACKT-">[A-Z-]</code> means any character between <code class="Code-In-Text--PACKT-">A</code> and <code class="Code-In-Text--PACKT-">Z</code>, and the <code class="Code-In-Text--PACKT-">-</code>, also.</p>
    <h3 id="_idParaDest-195" class="title">Escaping characters</h3>
    <p class="normal">As we've noted above, a lot of <a id="_idIndexMarker652"/>characters have special meanings. For example, putting a period character in a pattern matches any arbitrary character. How do we match just a period in a string? We'll use backslashes to escape the special meaning and change the character from a meta-character (like a class definition, or an anchor or the start of a class) and understand it as an ordinary character. This means we'll often have a bunch of <code class="Code-In-Text--PACKT-">\</code> characters in a regular expression, making r-strings really helpful.</p>
    <p class="normal">Here's a regular expression to match two-digit decimal numbers between 0.00 and 0.99:</p>
    <pre class="programlisting code"><code class="hljs-code">pattern='0\\.[0-9][0-9]' matches at match=&lt;re.Match object; span=(0, 4), match='0.05'&gt;
pattern='0\\.[0-9][0-9]' not found in text='005'
pattern='0\\.[0-9][0-9]' not found in text='0,05'
</code></pre>
    <p class="normal">For this pattern, the two characters <code class="Code-In-Text--PACKT-">\.</code> match the single <code class="Code-In-Text--PACKT-">.</code> character. If the period character is missing or is a different character, it will not match.</p>
    <p class="normal">This backslash escape sequence is used for a variety of special characters in regular expressions. You can use <code class="Code-In-Text--PACKT-">\[</code> to insert a square bracket without starting a character class, and <code class="Code-In-Text--PACKT-">\(</code> to insert a parenthesis, which we'll later see is also a meta-character.</p>
    <p class="normal">More interestingly, we can also use the escape symbol followed by a character to represent special characters such as newlines (<code class="Code-In-Text--PACKT-">\n</code>) and tabs (<code class="Code-In-Text--PACKT-">\t</code>). As we saw earlier, some character classes can be represented more succinctly using escape strings. </p>
    <p class="normal">To make the raw strings and backslashes more clear, we'll include the function calls again to show the code we wrote separate from Python's canonical display of the raw strings.</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; matchy(r'\(abc\]', "(abc]")
pattern='\\(abc\\]' matches at match=&lt;re.Match object; span=(0, 5), match='(abc]'&gt;
&gt;&gt;&gt; matchy(r'\s\d\w', " 1a")
pattern='\\s\\d\\w' matches at match=&lt;re.Match object; span=(0, 3), match=' 1a'&gt;
&gt;&gt;&gt; matchy(r'\s\d\w', "\t5n")
pattern='\\s\\d\\w' matches at match=&lt;re.Match object; span=(0, 3), match='\t5n'&gt;
&gt;&gt;&gt; matchy(r'\s\d\w', " 5n")
pattern='\\s\\d\\w' matches at match=&lt;re.Match object; span=(0, 3), match=' 5n'&gt;
</code></pre>
    <p class="normal">To summarize, this use of a<a id="_idIndexMarker653"/> backslash has two distinct meanings:</p>
    <ul>
      <li class="bullet">For meta-characters, a backslash escapes the meta-meaning. For example, <code class="Code-In-Text--PACKT-">.</code> is a class of characters, whereas <code class="Code-In-Text--PACKT-">\.</code> is a single character; similarly, <code class="Code-In-Text--PACKT-">^</code> is an anchor at the start of a string, but <code class="Code-In-Text--PACKT-">\^</code> is the hat character.</li>
      <li class="bullet">For a few ordinary characters, a backslash is used to name a character class. There aren't many examples of this; the most commonly used are <code class="Code-In-Text--PACKT-">\s</code>, <code class="Code-In-Text--PACKT-">\d</code>, <code class="Code-In-Text--PACKT-">\w</code>, <code class="Code-In-Text--PACKT-">\S</code>, <code class="Code-In-Text--PACKT-">\D</code>, and <code class="Code-In-Text--PACKT-">\W</code>. The uppercase variants, <code class="Code-In-Text--PACKT-">\S</code>, <code class="Code-In-Text--PACKT-">\D</code>, and <code class="Code-In-Text--PACKT-">\W</code>, are the inverses of the lower case. For example, <code class="Code-In-Text--PACKT-">\d</code> is any digit, and <code class="Code-In-Text--PACKT-">\D</code> is any non-digit. </li>
    </ul>
    <p class="normal">This odd distinction can be confusing at first. What's often helpful is to remember <code class="Code-In-Text--PACKT-">\</code> in front of a letter creates a special case, whereas <code class="Code-In-Text--PACKT-">\</code> in front of punctuation removes a meta-character meaning.</p>
    <h3 id="_idParaDest-196" class="title">Repeating patterns of characters</h3>
    <p class="normal">With this information, we <a id="_idIndexMarker654"/>can match most strings of a known length, but most of the time, we don't know how many characters to match inside a pattern. Regular expressions can take care of this, too. We can modify a pattern with a suffix character. When we think of a regular expression as a product, a repeating sequence is like raising to a power. This follows the pattern of <code class="Code-In-Text--PACKT-">a*a*a*a == a**4</code>. </p>
    <p class="normal">The asterisk (<code class="Code-In-Text--PACKT-">*</code>) character says that the previous pattern can be matched zero or more times. This probably sounds silly, but it's one of the most useful repetition characters. Before we explore why, consider some silly examples to make sure we understand what it does:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; matchy(r'hel*o', 'hello')
pattern='hel*o' matches at match=&lt;re.Match object; span=(0, 5), match='hello'&gt;
&gt;&gt;&gt; matchy(r'hel*o', 'heo')
pattern='hel*o' matches at match=&lt;re.Match object; span=(0, 3), match='heo'&gt;
&gt;&gt;&gt; matchy(r'hel*o', 'helllllo')
pattern='hel*o' matches at match=&lt;re.Match object; span=(0, 8), match='helllllo'&gt;
</code></pre>
    <p class="normal">So, the <code class="Code-In-Text--PACKT-">*</code> character in the pattern says that the previous pattern (the <code class="Code-In-Text--PACKT-">l</code> character) is optional, and if present, can be repeated as many times as possible to match the pattern. The rest of the characters (<code class="Code-In-Text--PACKT-">h</code>, <code class="Code-In-Text--PACKT-">e</code>, and <code class="Code-In-Text--PACKT-">o</code>) have to appear exactly once.</p>
    <p class="normal">This gets more<a id="_idIndexMarker655"/> interesting if we combine the asterisk with patterns that match multiple characters. So, <code class="Code-In-Text--PACKT-">.*</code>, for example, will match any string, whereas <code class="Code-In-Text--PACKT-">[a-z]*</code> matches any collection of lowercase letters, including the empty string. Here are a few examples:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; matchy(r'[A-Z][a-z]* [a-z]*\.', "A string.")
pattern='[A-Z][a-z]* [a-z]*\\.' matches at match=&lt;re.Match object; span=(0, 9), match='A string.'&gt;
&gt;&gt;&gt; matchy(r'[A-Z][a-z]* [a-z]*\.', "No .")
pattern='[A-Z][a-z]* [a-z]*\\.' matches at match=&lt;re.Match object; span=(0, 4), match='No .'&gt;
&gt;&gt;&gt; matchy(r'[a-z]*.*', "")
pattern='[a-z]*.*' matches at match=&lt;re.Match object; span=(0, 0), match=''&gt;
</code></pre>
    <p class="normal">The plus (<code class="Code-In-Text--PACKT-">+</code>) sign in a pattern behaves similarly to an asterisk; it states that the previous pattern can be repeated one or more times; this means the expression is not optional. The question mark (<code class="Code-In-Text--PACKT-">?</code>) ensures a pattern shows up exactly zero or one times, but not more. Let's explore some of these by playing with numbers (remember that <code class="Code-In-Text--PACKT-">\d</code> matches the same character class as <code class="Code-In-Text--PACKT-">[0-9]</code>):</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; matchy(r'\d+\.\d+', "0.4")
pattern='\\d+\\.\\d+' matches at match=&lt;re.Match object; span=(0, 3), match='0.4'&gt;
&gt;&gt;&gt; matchy(r'\d+\.\d+', "1.002")
pattern='\\d+\\.\\d+' matches at match=&lt;re.Match object; span=(0, 5), match='1.002'&gt;
&gt;&gt;&gt; matchy(r'\d+\.\d+', "1.")
pattern='\\d+\\.\\d+' not found in text='1.'
&gt;&gt;&gt; matchy(r'\d?\d%', "1%")
pattern='\\d?\\d%' matches at match=&lt;re.Match object; span=(0, 2), match='1%'&gt;
&gt;&gt;&gt; matchy(r'\d?\d%', "99%")
pattern='\\d?\\d%' matches at match=&lt;re.Match object; span=(0, 3), match='99%'&gt;
&gt;&gt;&gt; matchy(r'\d?\d%', "100%")
pattern='\\d?\\d%' not found in text='100%'
</code></pre>
    <p class="normal">These <a id="_idIndexMarker656"/>examples illustrate the two different uses of <code class="Code-In-Text--PACKT-">\</code>, also. For the <code class="Code-In-Text--PACKT-">.</code> character, <code class="Code-In-Text--PACKT-">\.</code> changes it from a meta-character that matches anything to a literal period. For the <code class="Code-In-Text--PACKT-">d</code> character, <code class="Code-In-Text--PACKT-">\d</code> changes it from a literal <code class="Code-In-Text--PACKT-">d</code> to a class of characters, <code class="Code-In-Text--PACKT-">[0-9]</code>. Don't forget that <code class="Code-In-Text--PACKT-">*</code>, <code class="Code-In-Text--PACKT-">+</code>, and <code class="Code-In-Text--PACKT-">?</code> are meta-characters, and matching them literally means using <code class="Code-In-Text--PACKT-">\*</code>, <code class="Code-In-Text--PACKT-">\+</code>, or <code class="Code-In-Text--PACKT-">\?</code>.</p>
    <h3 id="_idParaDest-197" class="title">Grouping patterns together</h3>
    <p class="normal">So far, we've seen how we <a id="_idIndexMarker657"/>can repeat a pattern multiple times, but we are restricted in what patterns we can repeat. If we want to repeat individual characters, we're covered, but what if we want a repeating sequence of characters? Enclosing any set of patterns in parentheses allows them to be treated as a single pattern when applying repetition operations. Compare these patterns:</p>
    <pre class="programlisting code"><code class="hljs-code">pattern='abc{3}' matches at match=&lt;re.Match object; span=(0, 5), match='abccc'&gt;
pattern='(abc){3}' not found in text='abccc'
pattern='(abc){3}' matches at match=&lt;re.Match object; span=(0, 9), match='abcabcabc'&gt;
</code></pre>
    <p class="normal">This follows from the core mathematics behind regular expressions. The formulas <img src="img/B17070_09_015.png" alt="" style="height: 1em;"/> and <img src="img/B17070_09_016.png" alt="" style="height: 1em;"/> have dramatically different meanings.</p>
    <p class="normal">Combined with complex patterns, this grouping feature greatly expands our pattern-matching repertoire. Here's a regular expression that matches simple English sentences:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; matchy(r'[A-Z][a-z]*( [a-z]+)*\.$', "Eat.")
pattern='[A-Z][a-z]*( [a-z]+)*\\.$' matches at match=&lt;re.Match object; span=(0, 4), match='Eat.'&gt;
&gt;&gt;&gt; matchy(r'[A-Z][a-z]*( [a-z]+)*\.$', "Eat more good food.")
pattern='[A-Z][a-z]*( [a-z]+)*\\.$' matches at match=&lt;re.Match object; span=(0, 19), match='Eat more good food.'&gt;
&gt;&gt;&gt; matchy(r'[A-Z][a-z]*( [a-z]+)*\.$', "A good meal.")
pattern='[A-Z][a-z]*( [a-z]+)*\\.$' matches at match=&lt;re.Match object; span=(0, 12), match='A good meal.'&gt;
</code></pre>
    <p class="normal">The first word<a id="_idIndexMarker658"/> starts with a capital, followed by zero or more lowercase letters, <code class="Code-In-Text--PACKT-">[A-Z][a-z]*</code>. Then, we enter a parenthetical that matches a single space followed by a word of one or more lowercase letters, <code class="Code-In-Text--PACKT-">[a-z]+</code>. This entire parenthetical is repeated zero or more times, <code class="Code-In-Text--PACKT-">( [a-z]+)*</code>. The pattern is terminated with a period. There cannot be any other characters after the period, as indicated by the <code class="Code-In-Text--PACKT-">$</code> anchor at the end of the pattern.</p>
    <p class="normal">We've seen many of the most basic patterns, but the regular expression language supports many more. It is worth bookmarking Python's documentation for the <code class="Code-In-Text--PACKT-">re</code> module and reviewing it frequently. There are very few things that regular expressions cannot match, and they should be the first tool you reach for when parsing strings that don't involve complex recursive definitions.</p>
    <h2 id="_idParaDest-198" class="title">Parsing information with regular expressions</h2>
    <p class="normal">Let's now <a id="_idIndexMarker659"/>focus on the Python side of things. The regular expression syntax is the furthest thing from object-oriented programming. However, Python's <code class="Code-In-Text--PACKT-">re</code> module provides an object-oriented interface to enter the regular expression engine.</p>
    <p class="normal">We've been checking whether the <code class="Code-In-Text--PACKT-">re.match()</code> function returns a valid object or not. If a pattern does not match, that function returns <code class="Code-In-Text--PACKT-">None</code>. If it does match, however, it returns a useful object that we can inspect for information about the pattern.</p>
    <p class="normal">So far, our regular expressions have answered questions such as <em class="italic">does this string match this pattern?</em> Matching patterns is useful, but in many cases, a more interesting question is <em class="italic">if this string matches this pattern, what is the value of a relevant substring?</em> If you use groups to identify parts of the pattern that you want to reference later, you can get them out of the match return value, as illustrated in the next example:</p>
    <pre class="programlisting code"><code class="hljs-code">def email_domain(text: str) -&gt; Optional[str]:
    email_pattern = r"[a-z0-9._%+-]+@([a-z0-9.-]+\.[a-z]{2,})"
    if match := re.match(email_pattern, text, re.IGNORECASE):
        return match.group(1)
    else:
        return None
</code></pre>
    <p class="normal">The full specification describing all valid email addresses is extremely complicated, and the regular expression that accurately matches all possibilities is obscenely long. So, we cheated and made a smaller regular expression that matches many common email addresses; the point is that we want to access the domain name (after the <code class="Code-In-Text--PACKT-">@</code> sign) so we can connect to that address. This is done easily by wrapping that part of the pattern in parentheses and calling the <code class="Code-In-Text--PACKT-">group()</code> method on the object returned by <code class="Code-In-Text--PACKT-">match()</code>.</p>
    <p class="normal">We've used<a id="_idIndexMarker660"/> an additional argument value, <code class="Code-In-Text--PACKT-">re.IGNORECASE</code>, to mark this pattern as case-independent. This saves us from having to use <code class="Code-In-Text--PACKT-">[a-zA-Z…]</code> in three places in the pattern. It is a handy simplification when case doesn't matter.</p>
    <p class="normal">There are three ways to collect the groups that match. We've used the <code class="Code-In-Text--PACKT-">group()</code> method, which provides one matching group. Since there's only one pair of <code class="Code-In-Text--PACKT-">()</code>'s, this seems prudent. The more general <code class="Code-In-Text--PACKT-">groups()</code> method returns a tuple of all the <code class="Code-In-Text--PACKT-">()</code> groups matched inside the pattern, which we can index to access a specific value. The groups are ordered from left to right. However, bear in mind that groups can be nested, meaning you can have one or more groups inside another group. In this case, the groups are returned in the order of their leftmost <code class="Code-In-Text--PACKT-">(</code>'s, so the outermost group will be returned before its inner matching groups.</p>
    <p class="normal">We can also provide names for groups. The syntax is very complex-looking. We have to use <code class="Code-In-Text--PACKT-">(?P&lt;name&gt;…)</code> instead of <code class="Code-In-Text--PACKT-">(…)</code> to collect the matched text as a group. The <code class="Code-In-Text--PACKT-">?P&lt;name&gt;</code> is how we provide a group name of <code class="Code-In-Text--PACKT-">name</code> inside the <code class="Code-In-Text--PACKT-">()</code>'s. This lets us use the <code class="Code-In-Text--PACKT-">groupdict() </code>method to extract names and their contents.</p>
    <p class="normal">Here's an alternative to the email domain parser; this one uses named groups:</p>
    <pre class="programlisting code"><code class="hljs-code">def email_domain_2(text: str) -&gt; Optional[str]:
    email_pattern = r"(?P&lt;name&gt;[a-z0-9._%+-]+)@(?P&lt;domain&gt;[a-z0-9.-]+\.[a-z]{2,})"
    if match := re.match(email_pattern, text, re.IGNORECASE):
        return match.groupdict()["domain"]
    else:
        return None
</code></pre>
    <p class="normal">We've changed<a id="_idIndexMarker661"/> the pattern to add <code class="Code-In-Text--PACKT-">?P&lt;name&gt;</code> and <code class="Code-In-Text--PACKT-">?&lt;domain&gt;</code> inside the <code class="Code-In-Text--PACKT-">()</code>'s to provide names to these capture groups. This part of the regular expression doesn't change what is matched, it provides names to the capture groups.</p>
    <h3 id="_idParaDest-199" class="title">Other features of the re module</h3>
    <p class="normal">In addition to the <code class="Code-In-Text--PACKT-">match()</code> function, the <code class="Code-In-Text--PACKT-">re</code> module provides a couple of other useful functions, <code class="Code-In-Text--PACKT-">search()</code> and <code class="Code-In-Text--PACKT-">findall()</code>. The <code class="Code-In-Text--PACKT-">search()</code> function finds the first instance of a matching pattern, relaxing the restriction that the pattern should be implicitly anchored to the first letter of the string. Note <a id="_idIndexMarker662"/>that you can get a similar effect by using <code class="Code-In-Text--PACKT-">match()</code> and putting a  <code class="Code-In-Text--PACKT-">.*</code> character at the front of the pattern to match any characters between the start of the string and the pattern you are looking for.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">findall()</code> function behaves similarly to <code class="Code-In-Text--PACKT-">search()</code>, except that it finds all non-overlapping instances of the matching pattern, not just the first one. Think of it searching for the first match, then continuing the search after the end of the first matching to find the next one.</p>
    <p class="normal">Instead of returning a list of <code class="Code-In-Text--PACKT-">re.Match</code> objects, as you would expect, it returns a list of matching strings, or tuples. Sometimes it's strings, sometimes it's tuples. It's not a very good API at all! As with all bad APIs, you'll have to memorize the differences and not rely on intuition. The type of the return value depends on the number of bracketed groups inside the regular expression:</p>
    <ul>
      <li class="bullet">If there are no groups in the pattern, <code class="Code-In-Text--PACKT-">re.findall()</code> will return a list of strings, where each value is a complete substring from the source string that matches the pattern</li>
      <li class="bullet">If there is exactly one group in the pattern, <code class="Code-In-Text--PACKT-">re.findall()</code> will return a list of strings where each value is the contents of that group</li>
      <li class="bullet">If there are multiple groups in the pattern, <code class="Code-In-Text--PACKT-">re.findall()</code> will return a list of tuples where each tuple contains a value from a matching group, in order</li>
    </ul>
    <div><p class="Tip--PACKT-"><strong class="keyword">Consistency Helps</strong></p>
      <p class="Tip--PACKT-">When you are designing function calls in your own Python libraries, try to make the function always return a consistent data structure. It is often good to design functions that can take arbitrary inputs and process them, but the return value should not switch from a single value to a list, or a list of values to a list of tuples depending on the input. Let <code class="Code-In-Text--PACKT-">re.findall()</code> be a lesson!</p>
    </div>
    <p class="normal">The examples in the following interactive session will hopefully clarify the differences:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; import re
&gt;&gt;&gt; re.findall(r"\d+[hms]", "3h 2m   45s")
['3h', '2m', '45s']
&gt;&gt;&gt; re.findall(r"(\d+)[hms]", "3h:2m:45s")
['3', '2', '45']
&gt;&gt;&gt; re.findall(r"(\d+)([hms])", "3h, 2m, 45s")
[('3', 'h'), ('2', 'm'), ('45', 's')]
&gt;&gt;&gt; re.findall(r"((\d+)([hms]))", "3h - 2m - 45s")
[('3h', '3', 'h'), ('2m', '2', 'm'), ('45s', '45', 's')]
</code></pre>
    <p class="normal">It seems like it's<a id="_idIndexMarker663"/> always a good practice to decompose the data elements to the extent possible. In this case, we separated the numeric value from the units, hours, minutes, or seconds, making it easier to convert a complex string into a time interval.</p>
    <h3 id="_idParaDest-200" class="title">Making regular expressions efficient</h3>
    <p class="normal">Whenever you<a id="_idIndexMarker664"/> call one of the regular expression methods, the <code class="Code-In-Text--PACKT-">re module</code> has to convert the pattern string into an internal structure that makes searching strings fast. This conversion takes a non-trivial amount of time. If a regular expression pattern is going to be reused multiple times (for example, inside a <code class="Code-In-Text--PACKT-">for</code> or <code class="Code-In-Text--PACKT-">while</code> statement), it would be better if this conversion step could be done only once.</p>
    <p class="normal">This is possible with the <code class="Code-In-Text--PACKT-">re.compile()</code> method. It returns an object-oriented version of the regular expression that has been compiled down and has the methods we've explored (<code class="Code-In-Text--PACKT-">match()</code>, <code class="Code-In-Text--PACKT-">search()</code>, and <code class="Code-In-Text--PACKT-">findall()</code>), among others. The changes to what we've seen are minor. Here's what we've been using:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; re.findall(r"\d+[hms]", "3h 2m   45s")
</code></pre>
    <p class="normal">We can create a two-step operation, where a single pattern is reused for a number of strings.</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; duration_pattern = re.compile(r"\d+[hms]")
&gt;&gt;&gt; duration_pattern.findall("3h 2m   45s")
['3h', '2m', '45s']
&gt;&gt;&gt; duration_pattern.findall("3h:2m:45s")
['3h', '2m', '45s']
</code></pre>
    <p class="normal">Compiling the patterns in advance of using them is a handy optimization. It makes the application slightly simpler and a bit more efficient. </p>
    <p class="normal">This has definitely<a id="_idIndexMarker665"/> been a condensed introduction to regular expressions. At this point, we have a good feel for the basics and will recognize when we need to do further research. If we have a string pattern-matching problem, regular expressions will almost certainly be able to solve them for us. However, we may need to look up new syntax in a more comprehensive coverage of the topic. But now we know what to look for! Some tools, like Pythex at <a href="https://pythex.org">https://pythex.org</a>, can help develop and debug regular expressions. Let's move on to a completely different topic: filesystem paths.</p>
    <h1 id="_idParaDest-201" class="title">Filesystem paths</h1>
    <p class="normal">Most operating<a id="_idIndexMarker666"/> systems provide a <em class="italic">filesystem</em>, a way of mapping a logical abstraction of <em class="italic">directories</em> (often depicted as <em class="italic">folders</em>) and <em class="italic">files</em> to the bits and bytes stored on a hard drive or another storage device. As humans, we typically interact with the filesystem using a drag-and-drop interface with images of folders and files of different types. Or we can use command-line programs such as <code class="Code-In-Text--PACKT-">cp</code>, <code class="Code-In-Text--PACKT-">mv</code>, and <code class="Code-In-Text--PACKT-">mkdir</code>.</p>
    <p class="normal">As programmers, we have to interact with the filesystem with a series of system calls. You can think of these as library functions supplied by the operating system so that programs can call them. They have a clunky interface with integer file handles and buffered reads and writes, and that interface is different depending on which operating system you are using. The Python <code class="Code-In-Text--PACKT-">os</code> module exposes some of these underlying calls.</p>
    <p class="normal">Inside the <code class="Code-In-Text--PACKT-">os</code> module is the <code class="Code-In-Text--PACKT-">os.path</code> module. While it works, it's not very intuitive. It requires a lot of string concatenation and you have to be conscious of OS differences. For example, there is an <code class="Code-In-Text--PACKT-">os.sep</code> attribute representing the path separator; that's a "<code class="Code-In-Text--PACKT-">/</code>" on POSIX-compliant OSes and "<code class="Code-In-Text--PACKT-">\</code>" for Windows. Using it can lead to code that looks like this:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; import os.path
&gt;&gt;&gt; path = os.path.abspath(
...     os.sep.join(
...         ["", "Users", "dusty", "subdir", "subsubdir", "file.ext"]))
&gt;&gt;&gt; print(path)
/Users/dusty/subdir/subsubdir/file.ext
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">os.path</code> module conceals some of the platform-specific details. But this still forces us to work with paths as strings.</p>
    <p class="normal">Working with filesystem paths in the form of strings is often irritating. Paths that are easy to type on the command line become illegible in Python code. When working with multiple paths (for example, when processing images in a data pipeline for a machine learning computer vision problem), just managing those directories becomes a bit of an ordeal.</p>
    <p class="normal">So, the Python <a id="_idIndexMarker667"/>language designers included a module called <code class="Code-In-Text--PACKT-">pathlib</code> in the standard library. It's an object-oriented representation of paths and files that is much more pleasant to work with. The preceding path, using <code class="Code-In-Text--PACKT-">pathlib</code>, would look like this:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; path = Path("/Users") / "dusty" / "subdir" / "subsubdir" / "file.ext"
&gt;&gt;&gt; print(path)
/Users/dusty/subdir/subsubdir/file.ext
</code></pre>
    <p class="normal">As you can see, it's quite a bit easier to see what's going on. Notice the unique use of the division operator as a path separator so you don't have to do anything with <code class="Code-In-Text--PACKT-">os.sep</code>. This is an elegant use of overloading Python's <code class="Code-In-Text--PACKT-">__truediv__()</code> method to provide this feature for <code class="Code-In-Text--PACKT-">Path</code> object.</p>
    <p class="normal">In a more real-world example, consider some code that counts the number of lines of code – excluding whitespace and comments – in all Python files in a given directory and subdirectories:</p>
    <pre class="programlisting code"><code class="hljs-code">from pathlib import Path
from typing import Callable
def scan_python_1(path: Path) -&gt; int:
    sloc = 0
    with path.open() as source:
        for line in source:
            line = line.strip()
            if line and not line.startswith("#"):
                sloc += 1
    return sloc
def count_sloc(path: Path, scanner: Callable[[Path], int]) -&gt; int:
    if path.name.startswith("."):
        return 0
    elif path.is_file():
        if path.suffix != ".py":
            return 0
        with path.open() as source:
            return scanner(path)
    elif path.is_dir():
        count = sum(
            count_sloc(name, scanner) for name in path.iterdir())
        return count
    else:
        return 0
</code></pre>
    <p class="normal">In typical <code class="Code-In-Text--PACKT-">pathlib</code> usage, we rarely have to construct many <code class="Code-In-Text--PACKT-">Path</code> objects. In this example, the base <code class="Code-In-Text--PACKT-">Path</code> is provided as a parameter. The bulk of the <code class="Code-In-Text--PACKT-">Path</code> manipulation is locating other files or directories relative to a given <code class="Code-In-Text--PACKT-">Path</code>. The rest of the <code class="Code-In-Text--PACKT-">Path</code>-related processing is asking for attributes of a specific <code class="Code-In-Text--PACKT-">Path</code>. </p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">count_sloc()</code> function looks at the name of the path, skipping names beginning with "<code class="Code-In-Text--PACKT-">.</code>". This avoids the "<code class="Code-In-Text--PACKT-">.</code>" and "<code class="Code-In-Text--PACKT-">..</code>" directories, but it also skips directories like <code class="Code-In-Text--PACKT-">.tox</code>, <code class="Code-In-Text--PACKT-">.coverage</code>, or<code class="Code-In-Text--PACKT-"> .git</code> that are created by our tools.</p>
    <p class="normal">There are three <a id="_idIndexMarker668"/>general cases:</p>
    <ul>
      <li class="bullet">Actual files that might have Python source. We make sure the suffix of the file name is <code class="Code-In-Text--PACKT-">.py</code> to be sure we want to open the file. We'll call the given <code class="Code-In-Text--PACKT-">scanner()</code> function to open and read each Python file. There are several approaches to counting source code; we've shown one here, in the <code class="Code-In-Text--PACKT-">scan_python_1()</code> function that should be provided as an argument value.</li>
      <li class="bullet">Directories. In this case, we iterate through the directory's content, calling <code class="Code-In-Text--PACKT-">count_sloc()</code> on the items we find inside this directory.</li>
      <li class="bullet">Other filesystem objects like device mount names, symbolic links, devices, FIFO queues, and sockets. We ignore these.</li>
    </ul>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Path.open</code> method takes similar arguments to the <code class="Code-In-Text--PACKT-">open</code> built-in function, but it uses a more object-oriented syntax. We can use <code class="Code-In-Text--PACKT-">Path('./README.md').open()</code> to open the file for reading, if the path already exists.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">scan_python_1()</code> function iterates over each line in the file and adds it to the count. We skip whitespace and comment lines, since these don't represent actual source code. The total count is returned to the calling function.</p>
    <p class="normal">Here's how we invoke this function to count lines of code in one directory.</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; base = Path.cwd().parent
&gt;&gt;&gt; chapter =  base / "ch_02"
&gt;&gt;&gt; count = count_sloc(chapter, scan_python_1)
&gt;&gt;&gt; print(
...     f"{chapter.relative_to(base)}: {count} lines of code"
... )
ch_02: 542 lines of code
</code></pre>
    <p class="normal">This shows the one-and-only <code class="Code-In-Text--PACKT-">Path()</code> constructor in this fairly complex example. We leap up to the parent directory from the <strong class="keyword">current working directory</strong> (<strong class="keyword">CWD</strong>). From there we can descend into the <code class="Code-In-Text--PACKT-">ch_02</code> subdirectory and rummage around, looking at directories and Python files.</p>
    <p class="normal">This also shows how we provide the <code class="Code-In-Text--PACKT-">scan_python_1()</code> function as the argument value for the scanner parameter. For more insight into using functions as parameters to other functions, see <em class="chapterRef">Chapter 8</em>, <em class="italic">The Intersection of Object-Oriented and Functional Programming</em>.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Path</code> class in <a id="_idIndexMarker669"/>the <code class="Code-In-Text--PACKT-">pathlib</code> module has a method or property to cover pretty much everything you might want to do with a path. In addition to those we covered in the example, here are a few more methods and attributes of a <code class="Code-In-Text--PACKT-">Path</code> object:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">.absolute()</code> returns the full path from the root of the filesystem. This helps show where relative paths came from.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">.parent</code> returns a path to the parent directory.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">.exists()</code> checks whether the file or directory exists.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">.mkdir()</code> creates a directory at the current path. It takes Boolean <code class="Code-In-Text--PACKT-">parents</code> and <code class="Code-In-Text--PACKT-">exist_ok</code> arguments to indicate that it should recursively create the directories if necessary and that it shouldn't raise an exception if the directory already exists.</li>
    </ul>
    <p class="normal">Refer to the standard library documentation at <a href="https://docs.python.org/3/library/pathlib.html">https://docs.python.org/3/library/pathlib.html</a> for even more uses. The authors are proud to have contributed to this library.</p>
    <p class="normal">Almost all of the standard library modules that accept a string path can also accept a <code class="Code-In-Text--PACKT-">pathlib.Path</code> object. An <code class="Code-In-Text--PACKT-">os.PathLike</code> type hint is used to describe parameters that accept a <code class="Code-In-Text--PACKT-">Path</code>. For example, you can open a ZIP file by passing a path into it:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; zipfile.ZipFile(Path('nothing.zip'), 'w').writestr('filename', 'contents')
</code></pre>
    <p class="normal">Some external packages may not work with <code class="Code-In-Text--PACKT-">Path</code> objects. In those cases, you'll have to cast the path to a string using <code class="Code-In-Text--PACKT-">str(pathname)</code>.</p>
    <div><p class="Tip--PACKT-"><strong class="keyword">Statements vs. Lines of Code</strong></p>
      <p class="Tip--PACKT-">The <code class="Code-In-Text--PACKT-">scan_python_1()</code> function counts each line of a triple-quoted, multi-line strings as if they're lines of<a id="_idIndexMarker670"/> code. If we're sure each <em class="italic">physical</em> line<a id="_idIndexMarker671"/> matters, then a long docstring might be relevant, even when it's not really code. On the other hand, we might decide that we want to count meaningful <em class="italic">statements</em> instead of physical lines; in this case, we'll need a smarter function that uses the <code class="Code-In-Text--PACKT-">ast</code> module. It's far, far better to work with <a id="_idIndexMarker672"/>the <strong class="keyword">Abstract Syntax Trees</strong> (<strong class="keyword">ASTs</strong>) than it is to try and work with the source text. Using the <code class="Code-In-Text--PACKT-">ast</code> module doesn't change the <code class="Code-In-Text--PACKT-">Path</code> processing. It's a little more complex than reading the text, and outside the scope of this book. If we count statements (not lines that could be statements or could be triple-quoted comments) there are 257 statements, in 542 lines of code.</p>
    </div>
    <p class="normal">We've looked <a id="_idIndexMarker673"/>at working strings, bytes, and filesystem paths. The next concept we need to cover is how to save our application's objects to files and recovering objects from the bytes of a file. We call this process serialization.</p>
    <h1 id="_idParaDest-202" class="title">Serializing objects</h1>
    <p class="normal">We've been working <a id="_idIndexMarker674"/>with bytes and file paths as foundations that support working with persistent objects. To make an object persistent, we need to create a series of bytes that represent the state of the object, and write those bytes to a file. The missing piece of persistence, then, is this process of encoding objects as a series of bytes. We also want to decode objects and their relationships from a series of bytes. This encoding and<a id="_idIndexMarker675"/> decoding is also <a id="_idIndexMarker676"/>described as <strong class="keyword">serializing</strong> and <strong class="keyword">deserializing</strong>.</p>
    <p class="normal">When we look at web services, we'll often see a service described as RESTful. The "REST" concept is REpresentational State Transfer; the server and client will exchange representations of object states. The distinction here can be helpful: the two pieces of software don't exchange objects. The applications have their own internal objects; they exchange a representation of object state.</p>
    <p class="normal">There are several ways to serialize objects. We'll start with a simple and general approach using the <code class="Code-In-Text--PACKT-">pickle</code> module. Later, we'll look at the <code class="Code-In-Text--PACKT-">json</code> package as an alternative.</p>
    <p class="normal">The Python <code class="Code-In-Text--PACKT-">pickle</code> module is an object-oriented way to store object state directly in a special storage format. It essentially converts an object's state (and all the state of all the objects it holds as attributes) into a series of bytes that can be stored or transported however we see fit.</p>
    <p class="normal">For basic tasks, the <code class="Code-In-Text--PACKT-">pickle</code> module has an extremely simple interface. It comprises four basic functions for storing and loading data: two for manipulating file-like objects, and two for manipulating <code class="Code-In-Text--PACKT-">bytes</code> objects so we can work with pickled objects without necessarily having an open file.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">dump()</code> method<a id="_idIndexMarker677"/> accepts an object to be written and a file-like object to write the serialized bytes to. A file-like object must have a <code class="Code-In-Text--PACKT-">write()</code> method, and that method must know how to handle a <code class="Code-In-Text--PACKT-">bytes</code> argument. This means a file opened for text output wouldn't work; we need to open the file with a mode value of <code class="Code-In-Text--PACKT-">wb</code>.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">load()</code> method does exactly the opposite; it reads a serialized object's state from a file-like object. This object must have the proper file-like <code class="Code-In-Text--PACKT-">read()</code> and <code class="Code-In-Text--PACKT-">readline()</code> methods, each of which must, of course, return <code class="Code-In-Text--PACKT-">bytes</code>. The <code class="Code-In-Text--PACKT-">pickle</code> module will read the bytes and the <code class="Code-In-Text--PACKT-">load()</code> method will return the fully reconstructed object. Here's an example that stores and then loads some data in a list object:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; import pickle
&gt;&gt;&gt; some_data = [
... "a list", "containing", 5, "items",
... {"including": ["str", "int", "dict"]}
... ]
&gt;&gt;&gt; with open("pickled_list", 'wb') as file: 
...     pickle.dump(some_data, file) 
&gt;&gt;&gt; with open("pickled_list", 'rb') as file: 
...     loaded_data = pickle.load(file) 
&gt;&gt;&gt; print(loaded_data)
['a list', 'containing', 5, 'items', {'including': ['str', 'int', 'dict']}]
&gt;&gt;&gt; assert loaded_data == some_data
</code></pre>
    <p class="normal">This code serializes the object referred to by <code class="Code-In-Text--PACKT-">some_list</code>. This includes the associated strings, and dictionaries, and even an integer. This is stored in the file and then loaded from the same file. In each case, we open the file using a <code class="Code-In-Text--PACKT-">with</code> statement so that it is automatically closed. We've been careful to use modes of <code class="Code-In-Text--PACKT-">wb</code> and <code class="Code-In-Text--PACKT-">rb</code> to be sure the file is in bytes mode instead of text mode.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">assert</code> statement at the end would raise an error if the newly loaded object was not equal to the original object. Equality does not imply that they are the same object. Indeed, if we were to print the <code class="Code-In-Text--PACKT-">id()</code> of both objects, we would discover they are distinct objects with distinct internal identifiers. However, because they are both lists whose contents are equal, the two lists are also considered equal.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">dumps()</code> and <code class="Code-In-Text--PACKT-">loads()</code> functions <a id="_idIndexMarker678"/>behave much like their file-like counterparts, except they return or accept <code class="Code-In-Text--PACKT-">bytes</code> instead of file-like objects. The <code class="Code-In-Text--PACKT-">dumps</code> function requires only one argument, the object to be stored, and it returns a serialized <code class="Code-In-Text--PACKT-">bytes</code> object. The <code class="Code-In-Text--PACKT-">loads()</code> function requires a <code class="Code-In-Text--PACKT-">bytes</code> object and returns the restored object. The <code class="Code-In-Text--PACKT-">'s'</code> character in the method names is short for string; it's a legacy name from ancient versions of Python, where <code class="Code-In-Text--PACKT-">str</code> objects were used instead of <code class="Code-In-Text--PACKT-">bytes</code>.</p>
    <p class="normal">It is possible to call <code class="Code-In-Text--PACKT-">dump()</code> or <code class="Code-In-Text--PACKT-">load()</code> on a single open file more than once. Each call to <code class="Code-In-Text--PACKT-">dump</code> will store a single object (plus any objects it is composed of or contains), while a call to <code class="Code-In-Text--PACKT-">load()</code> will load and return just one object. So, for a single file, each separate call to <code class="Code-In-Text--PACKT-">dump()</code> when storing the object should have an associated call to <code class="Code-In-Text--PACKT-">load()</code> when restoring at a later date.</p>
    <p class="normal">It's important to be aware that the representation of the state of an object is highly focused on a specific major release of Python. A pickle file created in Python 3.7, for example, may not be usable by Python 3.8. This suggests that pickle files are good for temporary persistence, but not suitable for long-term storage or sharing among Python applications that might not all have a common version.</p>
    <p class="normal">The process of recovering the state of an object from a pickled representation can – under some circumstances – result in evaluating arbitrary code buried in the pickle file. This means a pickle file can be a vector for malicious code. This leads to a prominent warning in the documentation for the pickle module:</p>
    <div><p class="Tip--PACKT-"><strong class="keyword">Warning</strong></p>
      <p class="Tip--PACKT-">The pickle module is not secure. Only unpickle data you trust.</p>
    </div>
    <p class="normal">This advice generally leads us to avoid accepting pickle-format files without trusting the sender and having assurance no person in the middle has tampered with the file. An application that uses a pickle for a temporary cache has nothing to worry about.</p>
    <h2 id="_idParaDest-203" class="title">Customizing pickles</h2>
    <p class="normal">With most <a id="_idIndexMarker679"/>common Python objects, pickling <em class="italic">just works</em>. Basic primitive types such as integers, floats, and strings can be pickled, as can any container objects, such as lists or dictionaries, provided the contents of those containers are also picklable. Further, and importantly, any object can be pickled, so long as all of its attributes are also picklable.</p>
    <p class="normal">So, what makes an attribute unpicklable? Usually, it has something to do with dynamic attribute values subject to change. For example, if we have an open network socket, open file, running thread, subprocess, processing pool, or database connection stored as an attribute on an object, it will not make sense to pickle these objects. Device and operating system state will be meaningless when we attempt to reload the object later. We can't just pretend the original thread or socket connection exists when we reload! No, we need to somehow customize how such transient and dynamic data is dumped and loaded.</p>
    <p class="normal">Here's a class that loads the contents of a web page every hour to ensure that they stay up to date. It uses the <code class="Code-In-Text--PACKT-">threading.Timer</code> class to schedule the next update:</p>
    <pre class="programlisting code"><code class="hljs-code">from threading import Timer
import datetime
from urllib.request import urlopen
class URLPolling:
    def __init__(self, url: str) -&gt; None:
        self.url = url
        self.contents = ""
        self.last_updated: datetime.datetime
        self.timer: Timer
        self.update()
    def update(self) -&gt; None:
        self.contents = urlopen(self.url).read()
        self.last_updated = datetime.datetime.now()
        self.schedule()
    def schedule(self) -&gt; None:
        self.timer = Timer(3600, self.update)
        self.timer.setDaemon(True)
        self.timer.start()
</code></pre>
    <p class="normal">Objects like <code class="Code-In-Text--PACKT-">url</code>, <code class="Code-In-Text--PACKT-">contents</code>, and <code class="Code-In-Text--PACKT-">last_updated</code> are all picklable, but if we try to pickle an instance of this class, things go a little nutty on the <code class="Code-In-Text--PACKT-">self.timer</code> instance:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; import pickle
&gt;&gt;&gt; poll = URLPolling("http://dusty.phillips.codes")
&gt;&gt;&gt; pickle.dumps(poll)
Traceback (most recent call last):
  ...
  File "&lt;doctest url_poll.__test__.test_broken[2]&gt;", line 1, in &lt;module&gt;
pickle.dumps(poll)
TypeError: cannot pickle '_thread.lock' object
</code></pre>
    <p class="normal">That's not a very useful error, but it looks like we're trying to pickle something we shouldn't be pickling. That would be the <code class="Code-In-Text--PACKT-">Timer</code> instance; we're storing a reference to <code class="Code-In-Text--PACKT-">self.timer</code> in the <code class="Code-In-Text--PACKT-">schedule()</code> method, and that attribute cannot be serialized.</p>
    <p class="normal">When <code class="Code-In-Text--PACKT-">pickle</code> tries<a id="_idIndexMarker680"/> to serialize an object, it simply tries to store the state, the value of the object's <code class="Code-In-Text--PACKT-">__dict__</code> attribute; <code class="Code-In-Text--PACKT-">__dict__</code> is a dictionary mapping all the attribute names on the object to their values. Luckily, before checking <code class="Code-In-Text--PACKT-">__dict__</code>, <code class="Code-In-Text--PACKT-">pickle</code> checks to see whether a <code class="Code-In-Text--PACKT-">__getstate__()</code> method exists. If it does, it will store the return value of that method instead of the <code class="Code-In-Text--PACKT-">__dict__</code> object.</p>
    <p class="normal">Let's add a <code class="Code-In-Text--PACKT-">__getstate__()</code> method to our <code class="Code-In-Text--PACKT-">URLPolling</code> class that simply returns a copy of the <code class="Code-In-Text--PACKT-">__dict__</code> without the unpicklable timer object:</p>
    <pre class="programlisting code"><code class="hljs-code">def __getstate__(self) -&gt; dict[str, Any]:
pickleable_state = self.__dict__.copy()
    if "timer" in pickleable_state:
        del pickleable_state["timer"]
    return pickleable_state
</code></pre>
    <p class="normal">If we pickle an instance of this expanded version of <code class="Code-In-Text--PACKT-">URLPolling</code>, it will no longer fail. And we can even successfully restore that object using <code class="Code-In-Text--PACKT-">loads()</code>. However, the restored object doesn't have a <code class="Code-In-Text--PACKT-">self.timer</code> attribute, so it will not be refreshing the content like it is designed to do. We need to somehow create a new timer (to replace the missing one) when the object is unpickled.</p>
    <p class="normal">As we might expect, there is a complementary <code class="Code-In-Text--PACKT-">__setstate__()</code> method that can be implemented to customize unpickling. This method accepts a single argument, which is the object returned by <code class="Code-In-Text--PACKT-">__getstate__</code>. If we implement both methods, <code class="Code-In-Text--PACKT-">__getstate__()</code> is not required to return a dictionary, since <code class="Code-In-Text--PACKT-">__setstate__()</code> will know what to do with whatever object <code class="Code-In-Text--PACKT-">__getstate__()</code> chooses to return. In our case, we simply want to restore the <code class="Code-In-Text--PACKT-">__dict__</code>, and then create a new timer:</p>
    <pre class="programlisting code"><code class="hljs-code">def __setstate__(self, pickleable_state: dict[str, Any]) -&gt; None:
    self.__dict__ = pickleable_state
    self.schedule()
</code></pre>
    <p class="normal">The parallels between <code class="Code-In-Text--PACKT-">__init__()</code> and <code class="Code-In-Text--PACKT-">__setstate__()</code> are important. Both involve a call to <code class="Code-In-Text--PACKT-">self.schedule()</code> to create (or recreate) the internal timer object. This is a common pattern for working with pickled objects that have dynamic state that must be recovered.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">pickle</code> module<a id="_idIndexMarker681"/> is very flexible and provides other tools to further customize the pickling process if you need them. However, these are beyond the scope of this book. The tools we've covered are sufficient for many basic pickling tasks. Objects to be pickled are normally relatively simple data objects. Some of the popular machine learning frameworks, like scikit-learn, use <code class="Code-In-Text--PACKT-">pickle</code> to preserve the model that was created. This lets a data scientist use the model for predictions or for further testing.</p>
    <p class="normal">Because of the security limitation, we need an alternative format for exchanging data. A text-based format can be helpful because it's often easier to inspect a text file to be sure it isn't malicious. We'll look at JSON as a popular text-based serialization format.</p>
    <h2 id="_idParaDest-204" class="title">Serializing objects using JSON</h2>
    <p class="normal">There are many<a id="_idIndexMarker682"/> formats that have been used for text-based data<a id="_idIndexMarker683"/> exchange over the years. <strong class="keyword">Extensible Markup Language</strong> (<strong class="keyword">XML</strong>)<a id="_idIndexMarker684"/> is popular, but the files tend to be large. <strong class="keyword">Yet Another Markup Language</strong> (<strong class="keyword">YAML</strong>) is another format that you may see referenced <a id="_idIndexMarker685"/>occasionally. Tabular data is <a id="_idIndexMarker686"/>frequently exchanged in the <strong class="keyword">Comma-Separated Value</strong> (<strong class="keyword">CSV</strong>) format. Many of these are fading into obscurity and there are many more that you will encounter over time. Python has solid standard or third-party libraries for all of them.</p>
    <p class="normal">Before using such libraries on untrusted data, make sure to investigate security concerns with each of them. XML and YAML, for example, both have obscure features that, used maliciously, can allow arbitrary commands to be executed on the host machine. These features may not be turned off by default. Do your research. Even something as simple-seeming as a ZIP file or a JPEG image can be hacked to create a data structure that can crash a web server.</p>
    <p class="normal"><strong class="keyword">JavaScript Object Notation</strong> (<strong class="keyword">JSON</strong>) is a <a id="_idIndexMarker687"/>human-readable format for exchanging data. JSON is a standard format that can be interpreted by a wide array of heterogeneous client systems. This means JSON is extremely useful for transmitting data between completely decoupled systems. The JSON format does not have any support for executable code; because only data can be serialized, it is more difficult to inject malicious content.</p>
    <p class="normal">Because <a id="_idIndexMarker688"/>JSON can be easily interpreted by JavaScript<a id="_idIndexMarker689"/> engines, it is often used for transmitting data from a web server to a JavaScript-capable web browser. If the web application serving the data is written in Python, the server needs a way to convert internal data into the JSON format.</p>
    <p class="normal">There is a module to do this, predictably named <code class="Code-In-Text--PACKT-">json</code>. This module provides a similar interface to the <code class="Code-In-Text--PACKT-">pickle</code> module, with <code class="Code-In-Text--PACKT-">dump()</code>, <code class="Code-In-Text--PACKT-">load()</code>, <code class="Code-In-Text--PACKT-">dumps()</code>, and <code class="Code-In-Text--PACKT-">loads()</code> functions. The default calls to these functions are nearly identical to those in <code class="Code-In-Text--PACKT-">pickle</code>, so let's not repeat the details. There are a couple of differences: obviously, the output of these calls is valid JSON notation, rather than a pickled object. In addition, the <code class="Code-In-Text--PACKT-">json</code> functions operate on <code class="Code-In-Text--PACKT-">str</code> objects, rather than <code class="Code-In-Text--PACKT-">bytes</code>. Therefore, when dumping to or loading from a file, we need to create text files rather than binary ones.</p>
    <p class="normal">The JSON serializer is not as robust as the <code class="Code-In-Text--PACKT-">pickle</code> module; it can only serialize basic types such as integers, floats, and strings, and simple containers such as dictionaries and lists. Each of these has a direct mapping to a JSON representation, but JSON is unable to represent objects unique to Python like class or function definitions. </p>
    <p class="normal">Generally, the <code class="Code-In-Text--PACKT-">json</code> module's functions try to serialize the object's state using the value of the object's <code class="Code-In-Text--PACKT-">__dict__</code> attribute. A better approach is to supply custom code to serialize an object's state into a JSON-friendly dictionary. We also want to go the other way: deserializing a JSON dictionary to recover a Python object's state.</p>
    <p class="normal">In the <code class="Code-In-Text--PACKT-">json</code> module, both the object encoding and decoding functions accept optional arguments to customize the behavior. The <code class="Code-In-Text--PACKT-">dump()</code> and <code class="Code-In-Text--PACKT-">dumps()</code> functions accept a poorly named <code class="Code-In-Text--PACKT-">cls</code> keyword argument. (It's short for "class", which we have to spell funny because <code class="Code-In-Text--PACKT-">class</code> is a reserved keyword.) If this argument value is provided to the function, it should be a subclass of the <code class="Code-In-Text--PACKT-">JSONEncoder</code> class, with the <code class="Code-In-Text--PACKT-">default()</code> method overridden. This overridden <code class="Code-In-Text--PACKT-">default()</code> method accepts an arbitrary Python object and converts it to a dictionary that <code class="Code-In-Text--PACKT-">json</code> can serialize. If it doesn't know how to process the object, we should call the <code class="Code-In-Text--PACKT-">super()</code> method, so that it can take care of serializing basic types in the normal way.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">load()</code> and <code class="Code-In-Text--PACKT-">loads()</code> methods also accept such a <code class="Code-In-Text--PACKT-">cls</code> argument that can be a subclass of the inverse class, <code class="Code-In-Text--PACKT-">JSONDecoder</code>. However, it is normally sufficient to pass a function into these methods using the <code class="Code-In-Text--PACKT-">object_hook</code> keyword argument. This function accepts a dictionary and returns an object; if it doesn't know what to do with the input dictionary, it can return it unmodified.</p>
    <p class="normal">Let's look at <a id="_idIndexMarker690"/>an example. Imagine we have the following simple <a id="_idIndexMarker691"/>contact class that we want to serialize:</p>
    <pre class="programlisting code"><code class="hljs-code">class Contact: 
    def __init__(self, first, last): 
        self.first = first 
        self.last = last 
    @property 
    def full_name(self): 
        return("{} {}".format(self.first, self.last)) 
</code></pre>
    <p class="normal">We can try to serialize the <code class="Code-In-Text--PACKT-">__dict__</code> attribute:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; import json
&gt;&gt;&gt; c = Contact("Noriko", "Hannah")
&gt;&gt;&gt; json.dumps(c.__dict__)
'{"first": "Noriko", "last": "Hannah"}'
</code></pre>
    <p class="normal">But accessing the special <code class="Code-In-Text--PACKT-">__dict__</code> attribute in this fashion is kind of crude. This can lead to problems when an attribute has a value that's not already serialized by the <code class="Code-In-Text--PACKT-">json</code> module; <code class="Code-In-Text--PACKT-">datetime</code> objects are a common problem. Also, what if the receiving code (perhaps some JavaScript on a web page) wanted that <code class="Code-In-Text--PACKT-">full_name</code> property to be supplied? Of course, we could construct the dictionary by hand, but let's create a custom encoder instead:</p>
    <pre class="programlisting code"><code class="hljs-code">import json
class ContactEncoder(json.JSONEncoder):
    def default(self, obj: Any) -&gt; Any:
        if isinstance(obj, Contact):
            return {
                "__class__": "Contact",
                "first": obj.first,
                "last": obj.last,
                "full_name": obj.full_name,
            }
        return super().default(obj)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">default</code> method needs to check to see what kind of object we're trying to serialize. If it's a <code class="Code-In-Text--PACKT-">Contact</code>, we convert it to a dictionary manually. Otherwise, we let the parent class handle serialization (by assuming that it is a basic type, which <code class="Code-In-Text--PACKT-">json</code> knows how to handle). Notice that we pass an extra attribute to identify this object as a contact, since there would be no way to tell upon loading it. </p>
    <p class="normal">In some cases, we may want to provide a more complete, fully qualified name, including the package and module. Remember that the format of the dictionary depends on the code at the receiving end; there has to be an agreement as to how the data is going to be specified.</p>
    <p class="normal">We can use this class to encode a contact by passing the class (not an instantiated object) to the <code class="Code-In-Text--PACKT-">dump</code> or <code class="Code-In-Text--PACKT-">dumps</code> function:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; c = Contact("Noriko", "Hannah")
&gt;&gt;&gt; text = json.dumps(c, cls=ContactEncoder)
&gt;&gt;&gt; text
'{"__class__": "Contact", "first": "Noriko", "last": "Hannah", "full_name": "Noriko Hannah"}'
</code></pre>
    <p class="normal">For decoding, we<a id="_idIndexMarker692"/> can write a function that accepts a dictionary and checks<a id="_idIndexMarker693"/> the existence of the <code class="Code-In-Text--PACKT-">__class__</code> attribute to decide whether to convert it to a <code class="Code-In-Text--PACKT-">Contact</code> instance or leave it as a default dictionary:</p>
    <pre class="programlisting code"><code class="hljs-code">def decode_contact(json_object: Any) -&gt; Any:
    if json_object.get("__class__") == "Contact":
        return Contact(json_object["first"], json_object["last"])
    else:
        return json_object
</code></pre>
    <p class="normal">We can pass this function to the <code class="Code-In-Text--PACKT-">load()</code> or <code class="Code-In-Text--PACKT-">loads()</code> function using the <code class="Code-In-Text--PACKT-">object_hook</code> keyword argument:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; some_text = (
...     '{"__class__": "Contact", "first": "Milli", "last": "Dale", '
...     '"full_name": "Milli Dale"}'
... )
&gt;&gt;&gt; c2 = json.loads(some_text, object_hook=decode_contact)
&gt;&gt;&gt; c2.full_name
'Milli Dale'
</code></pre>
    <p class="normal">These examples show how we can use JSON to exchange objects that encode a number of common Python objects. For uncommon Python objects, there are straightforward ways to add an encoder or a decoder to handle more complex cases. In larger applications, we might include a special <code class="Code-In-Text--PACKT-">to_json()</code> method to produce a useful serialization of an object.</p>
    <h1 id="_idParaDest-205" class="title">Case study</h1>
    <p class="normal">In the previous chapters of the case study, we've been skirting an issue that arises frequently when working with complex data. Files have both a logical layout and a physical format. We've been laboring under a tacit assumption that our files are in CSV format, with a layout defined by the first line of the file. In <em class="chapterRef">Chapter 2,</em> we touched on file loading. In <em class="chapterRef">Chapter 6</em>, we revisited loading data and partitioning it into training and testing sets.</p>
    <p class="normal">In both previous chapters, we trusted that the data would be in a CSV format. This isn't a great assumption to make. We need to look at the alternatives and elevate our assumptions into a design choice. We also need to build in the flexibility to make changes as the context for using our application evolves.</p>
    <p class="normal">It's common to map complex objects to dictionaries, which have a tidy JSON representation. For this reason, the <code class="Code-In-Text--PACKT-">Classifier</code> web application makes use of dictionaries. We can also parse CSV data into dictionaries. The idea of working with dictionaries provides a kind of grand unification of CSV, Python, and JSON. We'll start by looking at the CSV format before moving on to some alternatives for serialization, like JSON.</p>
    <h2 id="_idParaDest-206" class="title">CSV format designs</h2>
    <p class="normal">We can<a id="_idIndexMarker694"/> make use of the <code class="Code-In-Text--PACKT-">csv</code> module to read and write files. <strong class="keyword">CSV</strong> stands for <strong class="keyword">Comma-Separated Values</strong>, designed (originally) to export and import data from a spreadsheet.</p>
    <p class="normal">The CSV format describes a sequence of rows. Each row is a sequence of strings. That's all there is, and it can be a bit of a limitation.</p>
    <p class="normal">The "comma" in CSV is a role, not a specific character. The purpose of this character is to separate the columns of data. For the most part, the role of the comma is played by the literal "<code class="Code-In-Text--PACKT-">,</code>". But other actors can fill this role. It's common to see the tab character, written as "<code class="Code-In-Text--PACKT-">\t</code>" or "<code class="Code-In-Text--PACKT-">\x09</code>", fill the role of the comma. </p>
    <p class="normal">The end-of-line is often the CRLF sequence, written as "<code class="Code-In-Text--PACKT-">\r\n</code>" or <code class="Code-In-Text--PACKT-">\x0d\x0a</code>. On macOS X and Linux, it's also possible to use a single newline character, <code class="Code-In-Text--PACKT-">\n</code>, at the end of each row. Again, this is a role, and other characters could be used.</p>
    <p class="normal">In order to contain the comma character within a column's data, the data can be quoted. This is often done by surrounding a column's value with the <code class="Code-In-Text--PACKT-">"</code> character. It's possible to specify a different quote character when describing a CSV dialect.</p>
    <p class="normal">Because CSV data is simply a sequence of strings, any other interpretation of the data requires processing by our application. For example, within the <code class="Code-In-Text--PACKT-">TrainingSample</code> class, the <code class="Code-In-Text--PACKT-">load()</code> method includes processing like the following:</p>
    <pre class="programlisting code"><code class="hljs-code">test = TestingKnownSample(
    species=row["species"],
    sepal_length=float(row["sepal_length"]),
    sepal_width=float(row["sepal_width"]),
    petal_length=float(row["petal_length"]),
    petal_width=float(row["petal_width"]),
)
</code></pre>
    <p class="normal">This <code class="Code-In-Text--PACKT-">load()</code> method<a id="_idIndexMarker695"/> extracts specific column values from each row, applies a conversion function to build a Python object from the text, and uses all of the attribute values to build a resulting object. </p>
    <p class="normal">There are two ways to consume (and produce) CSV-formatted data. We can work with each row as a dictionary, or we can process each row as a simple list of strings. We'll look at both alternatives to see how well they apply to the data in our case study.</p>
    <h2 id="_idParaDest-207" class="title">CSV dictionary reader</h2>
    <p class="normal">We can read <a id="_idIndexMarker696"/>CSV files as a sequence of strings, or as a dictionary. When we read the file as a sequence of strings, there are no special provisions for column headers. We're forced to manage the details of which column has a particular attribute. This is unpleasantly complex, but sometimes necessary.</p>
    <p class="normal">We can also read a CSV file so each row becomes a dictionary. We can provide a sequence of keys, or the first line of the file can provide the keys. This is relatively common, and it saves a little bit of confusion when the column headers are part of the data.</p>
    <p class="normal">We've been looking at the Bezdek Iris data for our case study. There's a copy of the data in the Kaggle repository, <a href="https://www.kaggle.com/uciml/iris">https://www.kaggle.com/uciml/iris</a>. The data is also available at <a href="https://archive.ics.uci.edu/ml/datasets/iris">https://archive.ics.uci.edu/ml/datasets/iris</a>. The UCI Machine Learning Repository file, <code class="Code-In-Text--PACKT-">bezdekIris.data</code>, does not have column titles; these are provided separately in a file named <code class="Code-In-Text--PACKT-">iris.names</code>. </p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">iris.names</code> file has a great deal of information in it, including this in section 7 of the document:</p>
    <pre class="programlisting code"><code class="hljs-code">7. Attribute Information:
   1. sepal length in cm
   2. sepal width in cm
   3. petal length in cm
   4. petal width in cm
   5. class: 
      -- Iris Setosa
      -- Iris Versicolour
      -- Iris Virginica
</code></pre>
    <p class="normal">This defines the five columns of data. This separation between the metadata and the sample data isn't ideal, but we can copy and paste this information into code to make something useful from it.</p>
    <p class="normal">We'll use it to <a id="_idIndexMarker697"/>define an Iris reader class as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">class CSVIrisReader:
    """
    Attribute Information:
       1. sepal length in cm
       2. sepal width in cm
       3. petal length in cm
       4. petal width in cm
       5. class:
          -- Iris Setosa
          -- Iris Versicolour
          -- Iris Virginica
    """
  header = [
        "sepal_length",  # in cm
        "sepal_width",  # in cm
        "petal_length",  # in cm
        "petal_width",  # in cm
        "species",  # Iris-setosa, Iris-versicolour, Iris-virginica
    ]
    def __init__(self, source: Path) -&gt; None:
        self.source = source
    def data_iter(self) -&gt; Iterator[dict[str, str]]:
        with self.source.open() as source_file:
            reader = csv.DictReader(source_file, self.header)
            yield from reader
</code></pre>
    <p class="normal">We transformed the documentation into a sequence of column names. The transformation isn't arbitrary. We matched the resulting <code class="Code-In-Text--PACKT-">KnownSample</code> class attribute names. </p>
    <p class="normal">In relatively simple applications, there's a single source of data, so the attribute names for classes and column names for CSV files are easy to keep aligned. This isn't always the case. In some problem domains, the data may have several variant names and formats. We may choose attribute names that seem good, but may not simply match any of the input files.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">data_iter()</code> method <a id="_idIndexMarker698"/>has a name suggesting it is an iterator over multiple data items. The type hint (<code class="Code-In-Text--PACKT-">Iterator[Dict[str, str]]</code>) confirms this. The function uses <code class="Code-In-Text--PACKT-">yield from</code> to provide rows from the CSV <code class="Code-In-Text--PACKT-">DictReader</code> object as they're demanded by a client process.</p>
    <p class="normal">This is a "lazy" way to read lines from the CSV as they're required by another object. The iterator is like a factory using kanban techniques – it prepares data in response to demand. This doesn't slurp in the entire file, creating a gigantic list of dictionaries. Instead, the iterator produces one dictionary at a time, as they're requested.</p>
    <p class="normal">One way to request data from an iterator is to use the built-in <code class="Code-In-Text--PACKT-">list()</code> function. We can use this class as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from model import CSVIrisReader
&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; test_data = Path.cwd().parent/"bezdekIris.data"
&gt;&gt;&gt; rdr = CSVIrisReader(test_data)
&gt;&gt;&gt; samples = list(rdr.data_iter())
&gt;&gt;&gt; len(samples)
150
&gt;&gt;&gt; samples[0]
{'sepal_length': '5.1', 'sepal_width': '3.5', 'petal_length': '1.4', 'petal_width': '0.2', 'species': 'Iris-setosa'}
</code></pre>
    <p class="normal">The CSV <code class="Code-In-Text--PACKT-">DictReader</code> produces a dictionary. We provided the keys for this dictionary with the <code class="Code-In-Text--PACKT-">self.header</code> value; an alternative is to use the first row of the file as the keys. In this case, the file doesn't have column headers in the first row, so we provided column headers.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">data_iter()</code> method produces rows for a consuming class or function. In this example, the <code class="Code-In-Text--PACKT-">list()</code> function consumes the available rows. As expected, the dataset has 150 rows. We've shown the first row.</p>
    <p class="normal">Note that the attribute values are strings. This is always true when reading CSV files: all of the input values are strings. Our application must convert the strings to <code class="Code-In-Text--PACKT-">float</code> values to be able to create <code class="Code-In-Text--PACKT-">KnownSample</code> objects.</p>
    <p class="normal">Another way to<a id="_idIndexMarker699"/> consume values is with a <code class="Code-In-Text--PACKT-">for</code> statement. This how the <code class="Code-In-Text--PACKT-">load()</code> method of the <code class="Code-In-Text--PACKT-">TrainingData</code> class works. It uses code that looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code">def load(self, raw_data_iter: Iterator[Dict[str, str]]) -&gt; None:
    for n, row in enumerate(raw_data_iter):
        ... more processing here
</code></pre>
    <p class="normal">We combine an <code class="Code-In-Text--PACKT-">IrisReader</code> object with this object to load the samples. It looks like this:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; training_data = TrainingData("besdekIris")
&gt;&gt;&gt; rdr = CSVIrisReader(test_data)
&gt;&gt;&gt; training_data.load(rdr.data_iter())
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">load()</code> method will consume values produced by the <code class="Code-In-Text--PACKT-">data_iter()</code> method. The loading of the data is a cooperative process from the two objects.</p>
    <p class="normal">Working with CSV data as dictionaries seems to be very handy. To show an alternative, we'll turn to reading data using a non-dictionary CSV reader.</p>
    <h2 id="_idParaDest-208" class="title">CSV list reader</h2>
    <p class="normal">The non-dictionary <a id="_idIndexMarker700"/>CSV reader produces a list of strings from each row. This is not what our <code class="Code-In-Text--PACKT-">TrainingData</code> collection's <code class="Code-In-Text--PACKT-">load()</code> method expects, however.</p>
    <p class="normal">We have two choices to meet the interface requirement for the <code class="Code-In-Text--PACKT-">load()</code> method:</p>
    <ol>
      <li class="numbered">Convert the list of column values to a dictionary.</li>
      <li class="numbered">Change <code class="Code-In-Text--PACKT-">load()</code> to use a list of values in a fixed order. This would have the unfortunate consequence of forcing the <code class="Code-In-Text--PACKT-">load()</code> method of the <code class="Code-In-Text--PACKT-">TrainingData</code> class to match a specific file layout. Alternatively, we'd have to re-order input values to match the requirements of <code class="Code-In-Text--PACKT-">load()</code>; doing this is about as complex as building a dictionary. </li>
    </ol>
    <p class="normal">Building a dictionary seems relatively easy; this allows the <code class="Code-In-Text--PACKT-">load()</code> method to work with data where the column layout varies from our initial expectation.</p>
    <p class="normal">Here's a <code class="Code-In-Text--PACKT-">CSVIrisReader_2</code> class that uses <code class="Code-In-Text--PACKT-">csv.reader()</code> to read a file, and builds dictionaries based<a id="_idIndexMarker701"/> on the attribute information published in the <code class="Code-In-Text--PACKT-">iris.names</code> file.</p>
    <pre class="programlisting code"><code class="hljs-code">class CSVIrisReader_2:
    """
    Attribute Information:
       1. sepal length in cm
       2. sepal width in cm
       3. petal length in cm
       4. petal width in cm
       5. class:
          -- Iris Setosa
          -- Iris Versicolour
          -- Iris Virginica
    """
    def __init__(self, source: Path) -&gt; None:
        self.source = source
    def data_iter(self) -&gt; Iterator[dict[str, str]]:
        with self.source.open() as source_file:
            reader = csv.reader(source_file)
            for row in reader:
                yield dict(
                    sepal_length=row[0],  # in cm
                    sepal_width=row[1],  # in cm
                    petal_length=row[2],  # in cm
                    petal_width=row[3],  # in cm
                    species=row[4]  # class string
                )
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">data_iter()</code> method yields individual dictionary objects. This <code class="Code-In-Text--PACKT-">for-with-yield</code> summarizes what a <code class="Code-In-Text--PACKT-">yield from</code> does. When we write <code class="Code-In-Text--PACKT-">yield from X</code>, that is effectively the same as the longer</p>
    <pre class="programlisting code"><code class="hljs-code">for item in X:
    yield item
</code></pre>
    <p class="normal">For this application, the non-dictionary processing works by creating a dictionary from the input row. This doesn't seem to have any advantage over the <code class="Code-In-Text--PACKT-">csv.DictReader</code> class. </p>
    <p class="normal">The other big<a id="_idIndexMarker702"/> alternative is JSON serialization. We'll look at ways to apply the techniques shown in this chapter to our case study data.</p>
    <h2 id="_idParaDest-209" class="title">JSON serialization</h2>
    <p class="normal">The JSON format can<a id="_idIndexMarker703"/> serialize a number of commonly used Python object classes, including:</p>
    <ul>
      <li class="bullet">None</li>
      <li class="bullet">Boolean</li>
      <li class="bullet">Float and integer</li>
      <li class="bullet">String</li>
      <li class="bullet">Lists of compatible objects</li>
      <li class="bullet">Dictionaries with string keys and compatible objects as values</li>
    </ul>
    <p class="normal">The "compatible objects" can include nested structures. This dictionary-within-list and dictionary-within-dictionary recursion can allow JSON to represent very complex things.</p>
    <p class="normal">We might consider a theoretical (but invalid) type hint like the following:</p>
    <pre class="programlisting code"><code class="hljs-code">JSON = Union[
    None, bool, int, float, str, List['JSON'], Dict[str, 'JSON']
]
</code></pre>
    <p class="normal">This hint isn't directly supported by <strong class="" style="font-style: italic;">mypy</strong>, because it involves explicit recursion: the JSON type is defined based on the JSON type. This hint can be a helpful conceptual framework for understanding what we can represent in JSON notation. As a practical matter, we often use <code class="Code-In-Text--PACKT-">Dict[str, Any]</code> to describe JSON objects, ignoring the details of other structures that might be present. We can be a little more specific, though, when we know the expected keys for the dictionary; we'll expand on this below.</p>
    <p class="normal">In JSON notation, our data will look like this:</p>
    <pre class="programlisting code"><code class="hljs-code">[
  {
    "sepal_length": 5.1,
    "sepal_width": 3.5,
    "petal_length": 1.4,
    "petal_width": 0.2,
    "species": "Iris-setosa"
  },
  {
    "sepal_length": 4.9,
    "sepal_width": 3.0,
    "petal_length": 1.4,
    "petal_width": 0.2,
    "species": "Iris-setosa"
  },
</code></pre>
    <p class="normal">Note that the numeric values don't have quotation marks, and they will be converted to <code class="Code-In-Text--PACKT-">float</code> values if they have a <code class="Code-In-Text--PACKT-">.</code> character or converted to an integer if they lack the <code class="Code-In-Text--PACKT-">.</code> character.</p>
    <p class="normal">The <a href="http://json.org">json.org</a> standards require a single JSON object in a file. This encourages us to create a "list-of-dict" structure. Pragmatically, the structure of the file can be summarized by this type hint:</p>
    <pre class="programlisting code"><code class="hljs-code">JSON_Samples = List[Dict[str, Union[float, str]]]
</code></pre>
    <p class="normal">The document – as a whole – is a list. It contains a number of dictionaries that map string keys to either float or string values. </p>
    <p class="normal">Above, we <a id="_idIndexMarker704"/>noted that we can be more specific about the keys expected. In this case, we want to limit our application to working with specific dictionary keys. We can be a bit more precise, by using the <code class="Code-In-Text--PACKT-">typing.TypedDict</code> hint:</p>
    <pre class="programlisting code"><code class="hljs-code">class SampleDict(TypedDict):
    sepal_length: float
    sepal_width: float
    petal_length: float
    petal_width: float
    species: str
</code></pre>
    <p class="normal">This can be helpful to <strong class="" style="font-style: italic;">mypy</strong> (and other people reading our code) by showing what the expected structure <em class="italic">should</em> be. We can even add <code class="Code-In-Text--PACKT-">total=True</code> to assert that the definition shows the entire domain of valid keys.</p>
    <p class="normal">This <code class="Code-In-Text--PACKT-">TypedDict</code> hint doesn't really confirm the contents of the JSON document are valid or sensible, however. Remember, <strong class="" style="font-style: italic;">mypy</strong> is only a static check on the code, and has no runtime impact. To check the JSON document's structure, we'll need something more sophisticated than a Python type hint.</p>
    <p class="normal">Here's our JSON reader class definition:</p>
    <pre class="programlisting code"><code class="hljs-code">class JSONIrisReader:
    def __init__(self, source: Path) -&gt; None:
        self.source = source
    def data_iter(self) -&gt; Iterator[SampleDict]:
        with self.source.open() as source_file:
            sample_list = json.load(source_file)
        yield from iter(sample_list)
</code></pre>
    <p class="normal">We've <a id="_idIndexMarker705"/>opened the source file and loaded the list-of-dict objects. We can then yield the individual sample dictionaries by iterating over the list.</p>
    <p class="normal">This has a hidden cost. We'll look at how newline-delimited JSON – a modification to the standard – can help reduce the memory used.</p>
    <h2 id="_idParaDest-210" class="title">Newline-delimited JSON</h2>
    <p class="normal">For large collections of <a id="_idIndexMarker706"/>objects, reading a single, massive list into memory first isn't ideal. The "newline-delimited" JSON format, described by <a href="http://ndjson.org">ndjson.org</a>, provides a way to put a large number of separate JSON documents into a single file.</p>
    <p class="normal">The file would look like this:</p>
    <pre class="programlisting code"><code class="hljs-code">{"sepal_length": 5.0, "sepal_width": 3.3, "petal_length": 1.4, "petal_width": 0.2, "species": "Iris-setosa"}
{"sepal_length": 7.0, "sepal_width": 3.2, "petal_length": 4.7, "petal_width": 1.4, "species": "Iris-versicolor"}
</code></pre>
    <p class="normal">There's no overall <code class="Code-In-Text--PACKT-">[]</code> to create a list. Each individual sample <em class="italic">must</em> be complete on one physical line of the file. </p>
    <p class="normal">This leads to a slight difference in the way we process the sequence of documents:</p>
    <pre class="programlisting code"><code class="hljs-code">class NDJSONIrisReader:
    def __init__(self, source: Path) -&gt; None:
        self.source = source
    def data_iter(self) -&gt; Iterator[SampleDict]:
        with self.source.open() as source_file:
            for line in source_file:
                sample = json.loads(line)
                yield sample
</code></pre>
    <p class="normal">We've read each<a id="_idIndexMarker707"/> line of the file and used <code class="Code-In-Text--PACKT-">json.loads()</code> to parse the single string into a sample dictionary. The interface is the same: an <code class="Code-In-Text--PACKT-">Iterator[SampleDict]</code>. The technique for producing that iterator is unique to newline-delimited JSON.</p>
    <h2 id="_idParaDest-211" class="title">JSON validation</h2>
    <p class="normal">We noted<a id="_idIndexMarker708"/> that our <strong class="" style="font-style: italic;">mypy</strong> type hint doesn't really guarantee the JSON document is – in any way – what we expected. There is a package in the Python Package Index that can be used for this. The <code class="Code-In-Text--PACKT-">jsonschema</code> package lets us provide a specification for a JSON document, and then confirm whether or not the document meets the specification. </p>
    <p class="normal">We'll need to install an additional library to do the validation:</p>
    <pre class="programlisting con"><code class="hljs-con">python -m pip install jsonschema
</code></pre>
    <p class="normal">The JSON Schema validation is a runtime check, unlike the <strong class="" style="font-style: italic;">mypy</strong> type hint. This means using validation will make our program slower. It can also help to diagnose subtly incorrect JSON documents. For details, see <a href="https://json-schema.org">https://json-schema.org</a>. This is evolving toward standardization, and there are several versions of compliance checking available.</p>
    <p class="normal">We'll focus on newline-delimited JSON. This means we need a schema for each sample document within the larger collection of documents. This kind of additional validation might be relevant when receiving a batch of unknown samples to classify. Before doing anything, we'd like to be sure the sample document has the right attributes.</p>
    <p class="normal">A JSON Schema document is also written in JSON. It includes some metadata to help clarify the purpose and meaning of the document. It's often a little easier to create a Python dictionary with the JSON Schema definition.</p>
    <p class="normal">Here's a candidate definition for the Iris schema for an individual sample:</p>
    <pre class="programlisting code"><code class="hljs-code">IRIS_SCHEMA = {
    "$schema": "https://json-schema.org/draft/2019-09/hyper-schema",
    "title": "Iris Data Schema",
    "description": "Schema of Bezdek Iris data",
    "type": "object",
    "properties": {
        "sepal_length": {
            "type": "number", "description": "Sepal Length in cm"},
        "sepal_width": {
            "type": "number", "description": "Sepal Width in cm"},
        "petal_length": {
            "type": "number", "description": "Petal Length in cm"},
        "petal_width": {
            "type": "number", "description": "Petal Width in cm"},
        "species": {
            "type": "string",
            "description": "class",
            "enum": [
                "Iris-setosa", "Iris-versicolor", "Iris-virginica"],
        },
    },
    "required": [
"sepal_length", "sepal_width", "petal_length", "petal_width"],
}
</code></pre>
    <p class="normal">Each sample is an <code class="Code-In-Text--PACKT-">object</code>, the JSON Schema term for a dictionary with keys and values. The <code class="Code-In-Text--PACKT-">properties</code> of an object are the dictionary keys. Each one of these is described with a type of data, <code class="Code-In-Text--PACKT-">number</code> in this case. We can provide additional details, like ranges of values. We provided a description, taken from the <code class="Code-In-Text--PACKT-">iris.names</code> file.</p>
    <p class="normal">In the case of the <code class="Code-In-Text--PACKT-">species</code> property, we've provided an enumeration of the valid string values. This can be handy for confirming that the data meets our overall expectations. </p>
    <p class="normal">We use this schema<a id="_idIndexMarker709"/> information by creating a <code class="Code-In-Text--PACKT-">jsonschema</code> validator and applying the validator to check each sample we read. An extended class might look like this:</p>
    <pre class="programlisting code"><code class="hljs-code">class ValidatingNDJSONIrisReader:
    def __init__(self, source: Path, schema: dict[str, Any]) -&gt; None:
        self.source = source
        self.validator = jsonschema.Draft7Validator(schema)
    def data_iter(self) -&gt; Iterator[SampleDict]:
        with self.source.open() as source_file:
            for line in source_file:
                sample = json.loads(line)
                if self.validator.is_valid(sample):
                    yield sample
                else:
                    print(f"Invalid: {sample}")
</code></pre>
    <p class="normal">We've accepted an additional parameter in the <code class="Code-In-Text--PACKT-">__init__()</code> method with the schema definition. We use this to create the <code class="Code-In-Text--PACKT-">Validator</code> instance that will be applied to each document.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">data_iter()</code> method uses the <code class="Code-In-Text--PACKT-">is_valid()</code> method of <code class="Code-In-Text--PACKT-">validator</code> to process only samples that pass the JSON Schema validation. The others will be reported and ignored. We've printed the output using the <code class="Code-In-Text--PACKT-">print()</code> function. It would be smarter to use the <code class="Code-In-Text--PACKT-">file=sys.stderr</code> keyword parameter to direct the output to the error output. It would be even better to use the <code class="Code-In-Text--PACKT-">logging</code> package to write error messages to a log.</p>
    <p class="normal">Note that we now <a id="_idIndexMarker710"/>have two separate, but similar definitions for the raw data that builds a <code class="Code-In-Text--PACKT-">Sample</code> instance:</p>
    <ol>
      <li class="numbered" value="1">A type hint, <code class="Code-In-Text--PACKT-">SampleDict</code>, describing the expected Python intermediate data structure. This can be applied to CSV as well as JSON data, and helps summarize the relationship between the <code class="Code-In-Text--PACKT-">load()</code> method of the <code class="Code-In-Text--PACKT-">TrainingData</code> class, and the various readers.</li>
      <li class="numbered">A JSON Schema that <em class="italic">also</em> describes an expected external data structure. This doesn't describe a Python object, it describes the JSON serialization of a Python object.</li>
    </ol>
    <p class="normal">For very simple cases, these two descriptions of the data seem redundant. In more complex situations, however, these two will diverge, and fairly complex conversions between external schema, intermediate results, and the final class definition is a common feature of Python applications. This occurs because there are a variety of ways to serialize Python objects. We need to be flexible enough to work with a useful variety of representations.</p>
    <h1 id="_idParaDest-212" class="title">Recall</h1>
    <p class="normal">In this chapter, we've looked at the following topics:</p>
    <ul>
      <li class="bullet">The ways to encode strings into bytes and decode bytes into strings. While some older character encodings (like ASCII) treat bytes and characters alike, this leads to confusion. Python text can be any Unicode character and Python bytes are numbers in the range 0 to 255.</li>
      <li class="bullet">String formatting lets us prepare string objects that have template pieces and dynamic pieces. This works for a lot of situations in Python. One is to create readable output for people, but we can use f-strings and the string <code class="Code-In-Text--PACKT-">format()</code> method everywhere we're creating a complex string from pieces.</li>
      <li class="bullet">We use regular expressions to decompose complex strings. In effect, a regular expression is the opposite of a fancy string formatter. Regular expressions struggle to separate the characters we're matching from "meta-characters" that provide additional matching rules, like repetition or alternative choices.</li>
      <li class="bullet">We've looked at a few ways to serialize data, including Pickle, CSV, and JSON. There are other formats, including YAML, that are similar enough to JSON and Pickle that we didn't need to cover them in detail. Other serializations like XML and HTML are quite a bit more complex, and we've avoided them.</li>
    </ul>
    <h1 id="_idParaDest-213" class="title">Exercises</h1>
    <p class="normal">We've covered a wide variety of topics in this chapter, from strings to regular expressions, to object serialization, and back again. Now it's time to consider how these ideas can be applied to your own code.</p>
    <p class="normal">Python strings are very flexible, and Python is an extremely powerful tool for string-based manipulations. If you don't do a lot of string processing in your daily work, try designing a tool that is exclusively intended for manipulating strings. Try to come up with something innovative, but if you're stuck, consider writing a web log analyzer (how many requests per hour? How many people visit more than five pages?) or a template tool that replaces certain variable names with the contents of other files.</p>
    <p class="normal">Spend a lot of time toying with the string formatting operators until you've got the syntax memorized. Write a bunch of template strings and objects to pass into the format function, and see what kind of output you get. Try the exotic formatting operators, such as percentage or hexadecimal notation. Try out the fill and alignment operators, and see how they behave differently for integers, strings, and floats. Consider writing a class of your own that has a <code class="Code-In-Text--PACKT-">__format__</code> method; we didn't discuss this in detail, but explore just how much you can customize formatting.</p>
    <p class="normal">Make sure you understand the difference between <code class="Code-In-Text--PACKT-">bytes</code> and <code class="Code-In-Text--PACKT-">str</code> objects. The way that Python's canonical display of bytes looks like a string can be confusing. The only tricky part is knowing how and when to convert between the two. For practice, try writing text data to a file opened for writing <code class="Code-In-Text--PACKT-">bytes</code> (you'll have to encode the text yourself), and then reading from the same file.</p>
    <p class="normal">Do some experimenting with <code class="Code-In-Text--PACKT-">bytearray</code>. See how it can act both like a <code class="Code-In-Text--PACKT-">bytes</code> object and a list or container object at the same time. Try writing to a buffer that holds data in the bytes array until it is a certain length before returning it. You can simulate the code that puts data into the buffer by using <code class="Code-In-Text--PACKT-">time.sleep</code> calls to ensure data doesn't arrive too quickly.</p>
    <p class="normal">Study regular expressions online. Study them some more. Especially learn about named groups, greedy versus lazy matching, and regex flags, three features that we didn't cover in this chapter. Make conscious decisions about when not to use them. Many people have very strong opinions about regular expressions and either overuse them or refuse to use them at all. Try to convince yourself to use them only when appropriate, and figure out when that is.</p>
    <p class="normal">If you've ever written an adapter to load small amounts of data from a file or database and convert it to an object, consider using a pickle instead. Pickles are not efficient for storing massive amounts of data, but they can be useful for loading configuration or other simple objects. Try coding it multiple ways: using a pickle, a text file, or a small database. Which do you find easiest to work with?</p>
    <p class="normal">Try experimenting with pickling data, then modifying the class that holds the data, and loading the pickle into the new class. What works? What doesn't? Is there a way to make drastic changes to a class, such as renaming an attribute or splitting it into two new attributes and still get the data out of an older pickle? (Hint: try placing a private pickle version number on each object and update it each time you change the class; you can then put a migration path in <code class="Code-In-Text--PACKT-">__setstate__</code>.)</p>
    <p class="normal">If you do any web development at all, the JSON serializer will be central. It can simplify things to stick with standard JSON serializable objects, rather than writing custom encoders or <code class="Code-In-Text--PACKT-">object_hooks</code>, but the design depends on the complexity of the objects and the state representations being transferred.</p>
    <p class="normal">In the case study, we applied the JSON Schema validation to a JSON file. It can also be applied to the rows read from a file in CSV format. This is a powerful combination of tools to work with data in two common formats; it helps to apply rigorous validation rules to assure that the rows meet the application's expectations. To see how this works, modify the <code class="Code-In-Text--PACKT-">CSVIrisReader</code> class to include JSON Schema validation of the rows of data.</p>
    <h1 id="_idParaDest-214" class="title">Summary</h1>
    <p class="normal">We've covered string manipulation, regular expressions, and object serialization in this chapter. Hardcoded strings and program variables can be combined into outputtable strings using the powerful string formatting system. It is important to distinguish between binary and textual data, and <code class="Code-In-Text--PACKT-">bytes</code> and <code class="Code-In-Text--PACKT-">str</code> have specific purposes that must be understood. Both are immutable, but the <code class="Code-In-Text--PACKT-">bytearray</code> type can be used when manipulating bytes.</p>
    <p class="normal">Regular expressions are a complex topic, and we only scratched the surface. There are many ways to serialize Python data; pickles and JSON are two of the most popular.</p>
    <p class="normal">In the next chapter, we'll look at a design pattern that is so fundamental to Python programming that it has been given special syntax support: the iterator pattern.</p>
  </div>
</body></html>