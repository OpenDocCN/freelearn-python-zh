<html><head></head><body>
<div><h1 class="chapterNumber">16</h1>
<h1 class="chapterTitle" id="_idParaDest-421">Building a Chat Server</h1>
<p class="normal">In the previous chapter, you created a RESTful API for your project that provides a programmable interface for your application.</p>
<p class="normal">In this chapter, you will develop a chat server for students using Django Channels, enabling students to engage in real-time messaging within course chat rooms. You will learn how to build real-time applications through asynchronous programming with Django Channels. By serving your Django project through <strong class="keyWord">Asynchronous Server Gateway Interface</strong> (<strong class="keyWord">ASGI</strong>), and <a id="_idIndexMarker1426"/>implementing asynchronous communication, you will enhance the responsiveness and scalability of your server. Additionally, you will persist chat messages into the database, building a comprehensive chat history and enriching the user experience and functionality of the chat application.</p>
<p class="normal">In this chapter, you will:</p>
<ul>
<li class="bulletList">Add Channels to your project</li>
<li class="bulletList">Build a WebSocket consumer and appropriate routing</li>
<li class="bulletList">Implement a WebSocket client</li>
<li class="bulletList">Enable a channel layer with Redis</li>
<li class="bulletList">Make your consumer fully asynchronous</li>
<li class="bulletList">Persist chat messages into the database</li>
</ul>
<h1 class="heading-1" id="_idParaDest-422">Functional overview</h1>
<p class="normal"><em class="italic">Figure 16.1</em> shows a representation of the views, templates, and functionalities that will be built in this chapter:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_16_01.png"/></figure>
<p class="packt_figref">Figure 16.1: Diagram of functionalities built in this chapter</p>
<p class="normal">In this chapter, you will implement the <code class="inlineCode">course_chat_room</code> view in the <code class="inlineCode">chat</code> application. This view will serve the template that displays the chat room for a given course. The latest chat messages will be displayed when a user joins a chat room. You will use JavaScript to establish a WebSocket connection in the browser, and you will build the <code class="inlineCode">ChatConsumer</code> WebSocket consumer to handle WebSocket connections and to exchange messages. You will use Redis to implement the channel layer that allows broadcasting messages to all users in the chat room.</p>
<p class="normal">The source code for this chapter can be found at <a href="https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter16">https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter16</a>.</p>
<p class="normal">All Python modules used in this chapter are included in the <code class="inlineCode">requirements.txt</code> file in the source code that comes along with this chapter. You can follow the instructions to install each Python module below or you can install all requirements at once with the command <code class="inlineCode">python -m pip install -r requirements.txt</code>.</p>
<h1 class="heading-1" id="_idParaDest-423">Creating a chat application</h1>
<p class="normal">You are going to implement a<a id="_idIndexMarker1427"/> chat server to provide students with a chat room for each course. Students enrolled in a course will be able to access the course chat room and exchange messages in real time. You will use Channels to build this functionality. Channels is <a id="_idIndexMarker1428"/>a Django application that extends Django to handle protocols that require long-running connections, such as WebSockets, chatbots, or MQTT (a lightweight publish/subscribe message <a id="_idIndexMarker1429"/>transport commonly used in <strong class="keyWord">Internet of Things</strong> (<strong class="keyWord">IoT</strong>) projects).</p>
<p class="normal">Using Channels, you can easily implement real-time or asynchronous functionalities into your project in addition to your standard HTTP synchronous views. You will start by adding a new application to your project. The new application will contain the logic for the chat server.</p>
<p class="normal">You can the documentation for<a id="_idIndexMarker1430"/> Django Channels at <a href="https://channels.readthedocs.io/">https://channels.readthedocs.io/</a>.</p>
<p class="normal">Let’s start implementing the chat server. Run the following command from the project’s <code class="inlineCode">educa</code> directory to create the new application file structure:</p>
<pre class="programlisting con"><code class="hljs-con">django-admin startapp chat
</code></pre>
<p class="normal">Edit the <code class="inlineCode">settings.py</code> file of the <code class="inlineCode">educa</code> project and activate the <code class="inlineCode">chat</code> application in your project by editing the <code class="inlineCode">INSTALLED_APPS</code> setting, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">INSTALLED_APPS = [
    # ...
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'chat.apps.ChatConfig'</strong><strong class="hljs-slc">,</strong>
]
</code></pre>
<p class="normal">The new <code class="inlineCode">chat</code> application is now <a id="_idIndexMarker1431"/>active in your project. Next, you are going to build a view for course chat rooms.</p>
<h2 class="heading-2" id="_idParaDest-424">Implementing the chat room view</h2>
<p class="normal">You will provide students with a <a id="_idIndexMarker1432"/>different chat room for each course. You need to create a view for students to join the chat room of a given course. Only students who are enrolled in a course will be able to access the course chat room.</p>
<p class="normal">Edit the <code class="inlineCode">views.py</code> file of the new <code class="inlineCode">chat</code> application and add the following code to it:</p>
<pre class="programlisting code"><code class="hljs-code"><strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> django.contrib.auth.decorators </strong><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> login_required</strong>
<strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> django.http </strong><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> HttpResponseForbidden</strong>
from django.shortcuts import render
<strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> courses.models </strong><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> Course</strong>
<strong class="hljs-meta-slc">@login_required</strong>
<strong class="hljs-keyword-slc">def</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">course_chat_room</strong><strong class="hljs-slc">(</strong><strong class="hljs-params-slc">request, course_id</strong><strong class="hljs-slc">):</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">try</strong><strong class="hljs-slc">:</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-comment-slc"># retrieve course with given id joined by the current user</strong>
<strong class="hljs-slc">        course = request.user.courses_joined.get(</strong><strong class="hljs-built_in-slc">id</strong><strong class="hljs-slc">=course_id)</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">except</strong><strong class="hljs-slc"> Course.DoesNotExist:</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-comment-slc"># user is not a student of the course or course does not exist</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> HttpResponseForbidden()</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> render(request, </strong><strong class="hljs-string-slc">'chat/room.html'</strong><strong class="hljs-slc">, {</strong><strong class="hljs-string-slc">'course'</strong><strong class="hljs-slc">: course})</strong>
</code></pre>
<p class="normal">This is the <code class="inlineCode">course_chat_room</code> view. In <a id="_idIndexMarker1433"/>this view, you use the <code class="inlineCode">@login_required</code> decorator to prevent any non-authenticated user from accessing the view. The view works as follows:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">The view receives a required <code class="inlineCode">course_id</code> parameter that is used to retrieve the course with the given <code class="inlineCode">id</code>.</li>
<li class="numberedList">The courses that the user is enrolled in are retrieved through the <code class="inlineCode">courses_joined</code> relationship and the course with the given <code class="inlineCode">id</code> is obtained from that subset of courses. If the course with the given <code class="inlineCode">id</code> does not exist or the user is not enrolled in it, an <code class="inlineCode">HttpResponseForbidden</code> response is returned, which translates to an HTTP response with status <code class="inlineCode">403</code>.</li>
<li class="numberedList">If the course with the given <code class="inlineCode">id</code> exists and the user is enrolled in it, the <code class="inlineCode">chat/room.html</code> template is rendered, passing the <code class="inlineCode">course</code> object to the template context.</li>
</ol>
<p class="normal">You need to add a URL pattern for this view. Create a new file inside the <code class="inlineCode">chat</code> application directory and name it <code class="inlineCode">urls.py</code>. Add the following code to it:</p>
<pre class="programlisting code"><code class="hljs-code">from django.urls import path
from . import views
app_name = 'chat'
urlpatterns = [
    path(
        'room/&lt;int:course_id&gt;/',
        views.course_chat_room,
        name='course_chat_room'),
]
</code></pre>
<p class="normal">This is the initial URL <a id="_idIndexMarker1434"/>patterns file for the <code class="inlineCode">chat</code> application. You define the <code class="inlineCode">course_chat_room</code> URL pattern, including the <code class="inlineCode">course_id</code> parameter with the <code class="inlineCode">int</code> prefix, as you only expect an integer value here.</p>
<p class="normal">Include the new URL patterns of the <code class="inlineCode">chat</code> application in the main URL patterns of the project. Edit the main <code class="inlineCode">urls.py</code> file of the <code class="inlineCode">educa</code> project and add the following line to it:</p>
<pre class="programlisting code"><code class="hljs-code">urlpatterns = [
    # ...
<strong class="hljs-slc">    path(</strong><strong class="hljs-string-slc">'chat/'</strong><strong class="hljs-slc">, include(</strong><strong class="hljs-string-slc">'chat.urls'</strong><strong class="hljs-slc">, namespace=</strong><strong class="hljs-string-slc">'chat'</strong><strong class="hljs-slc">)),</strong>
]
</code></pre>
<p class="normal">URL patterns for the <code class="inlineCode">chat</code> application are added to the project under the <code class="inlineCode">chat/</code> path.</p>
<p class="normal">You need to create a template for the <code class="inlineCode">course_chat_room</code> view. This template will contain an area to visualize the messages that are exchanged in the chat, and a text input with a submit button to send text messages to the chat.</p>
<p class="normal">Create the following file structure within the <code class="inlineCode">chat</code> application directory:</p>
<pre class="programlisting con"><code class="hljs-con">templates/
    chat/
        room.html
</code></pre>
<p class="normal">Edit the <code class="inlineCode">chat/room.html</code> template and add the following code to it:</p>
<pre class="programlisting code"><code class="hljs-code">{% extends "base.html" %}
{% block title %}Chat room for "{{ course.title }}"{% endblock %}
{% block content %}
  &lt;div id="chat"&gt;
&lt;/div&gt;
&lt;div id="chat-input"&gt;
&lt;input id="chat-message-input" type="text"&gt;
&lt;input id="chat-message-submit" type="submit" value="Send"&gt;
&lt;/div&gt;
{% endblock %}
{% block include_js %}
{% endblock %}
{% block domready %}
{% endblock %}
</code></pre>
<p class="normal">This is the template for the course chat room. In this template, you perform the following actions:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">You extend the <code class="inlineCode">base.html</code> template of your project and fill its <code class="inlineCode">content</code> block.</li>
<li class="numberedList">You define a <code class="inlineCode">&lt;div&gt;</code> HTML element with the <code class="inlineCode">chat</code> ID that you will use to display the chat messages sent by the user and by other students.</li>
<li class="numberedList">You also define a second <code class="inlineCode">&lt;div&gt;</code> element with a <code class="inlineCode">text</code> input and a submit button that will allow the user to send messages.</li>
<li class="numberedList">You add the <code class="inlineCode">include_js</code> and <code class="inlineCode">domready</code> blocks defined in the <code class="inlineCode">base.html</code> template, which you are going to implement later, to establish a connection with a WebSocket and send or receive messages.</li>
</ol>
<p class="normal">Run the development <a id="_idIndexMarker1435"/>server and open <code class="inlineCode">http://127.0.0.1:8000/chat/room/1/</code> in your browser, replacing <code class="inlineCode">1</code> with the <code class="inlineCode">id</code> of an existing course in the database. </p>
<p class="normal">Access the chat room with a logged-in user who is enrolled in the course. You will see the following screen:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_16_02.png"/></figure>
<p class="packt_figref">Figure 16.2: The course chat room page</p>
<p class="normal">This is the course <a id="_idIndexMarker1436"/>chat room screen that students will use to discuss topics within a course.</p>
<p class="normal">You have created the base view for the course chat room. Now you need to handle messages between students. The next section will introduce asynchronous support with Channels for real-time communication.</p>
<h1 class="heading-1" id="_idParaDest-425">Real-time Django with Channels</h1>
<p class="normal">You are building a chat<a id="_idIndexMarker1437"/> server to provide students with a chat room for each<a id="_idIndexMarker1438"/> course. Students enrolled in a course will be able to access the course chat room and exchange messages. This functionality requires real-time communication between the server and the client.</p>
<p class="normal">A standard HTTP request/response model doesn’t work here because you need the browser to receive notifications as soon as new messages arrive. There are several ways you could implement this feature, using AJAX polling or long polling in combination with storing the messages in your database or Redis. However, there is no efficient way to implement real-time communication using a standard synchronous web application.</p>
<p class="normal">You need asynchronous communication, which allows real-time interactions, where the server can push updates to the client as soon as new messages arrive without the client needing to request updates periodically. Asynchronous communication also comes with other advantages, such as reduced latency, improved performance under load, and a better overall user experience. You are going to build a chat server using asynchronous communication through ASGI.</p>
<h2 class="heading-2" id="_idParaDest-426">Asynchronous applications using ASGI</h2>
<p class="normal">Django is usually deployed<a id="_idIndexMarker1439"/> using <strong class="keyWord">Web Server Gateway Interface</strong> (<strong class="keyWord">WSGI</strong>), which is the standard interface for Python applications to<a id="_idIndexMarker1440"/> handle HTTP requests. However, to work with asynchronous applications, you need to use another interface called ASGI, which can handle WebSocket requests as well. ASGI is the emerging Python standard for asynchronous web servers and applications. By using ASGI, we will enable Django to handle each message independently and in real time, creating a smooth and live chat experience for students.</p>
<p class="normal">You can find an introduction to <a id="_idIndexMarker1441"/>ASGI at <a href="https://asgi.readthedocs.io/en/latest/introduction.html">https://asgi.readthedocs.io/en/latest/introduction.html</a>.</p>
<p class="normal">Django comes with support for running asynchronous Python through ASGI. Writing asynchronous views has been supported since Django 3.1, and Django 4.1 introduced asynchronous handlers for class-based views. Django 5.0 adds handling for disconnect events in asynchronous views before the response is generated. It also adds asynchronous functions to the authentication framework, provides support for asynchronous signal dispatching, and adds async support to multiple built-in decorators.</p>
<p class="normal">Channels builds upon the<a id="_idIndexMarker1442"/> native ASGI support available in Django and provides additional functionalities to handle protocols that require long-running connections, such as WebSockets, IoT protocols, and chat protocols.</p>
<p class="normal">WebSockets<a id="_idIndexMarker1443"/> provide full-duplex communication by establishing a persistent, open, bidirectional <strong class="keyWord">Transmission Control Protocol</strong> (<strong class="keyWord">TCP</strong>) connection between servers and clients. Instead of sending <a id="_idIndexMarker1444"/>HTTP requests to the server, you establish a connection with the server; once the channel is open, messages can be exchanged in both directions without needing to establish a new connection each time. You are going to use WebSockets to implement your chat server.</p>
<p class="normal">You can read more about <a id="_idIndexMarker1445"/>WebSockets at <a href="https://en.wikipedia.org/wiki/WebSocket">https://en.wikipedia.org/wiki/WebSocket</a>.</p>
<p class="normal">You can find <a id="_idIndexMarker1446"/>more information about deploying Django with ASGI at <a href="https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/">https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/</a>.</p>
<p class="normal">You can find more information about Django’s support<a id="_idIndexMarker1447"/> for writing asynchronous views at <a href="https://docs.djangoproject.com/en/5.0/topics/async/">https://docs.djangoproject.com/en/5.0/topics/async/</a> and Django’s support for asynchronous class-based views<a id="_idIndexMarker1448"/> at <a href="https://docs.djangoproject.com/en/5.0/topics/class-based-views/#async-class-based-views">https://docs.djangoproject.com/en/5.0/topics/class-based-views/#async-class-based-views</a>.</p>
<p class="normal">Next, we are going to learn how the Django request/response cycle is altered by using Channels.</p>
<h2 class="heading-2" id="_idParaDest-427">The request/response cycle using Channels</h2>
<p class="normal">It’s important to<a id="_idIndexMarker1449"/> understand the differences in a request cycle<a id="_idIndexMarker1450"/> between a standard synchronous request cycle and a Channels implementation. The following schema shows the request cycle of a synchronous Django setup:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_16_03.png"/></figure>
<p class="packt_figref">Figure 16.3: The Django request/response cycle</p>
<p class="normal">When an HTTP request is sent by the browser to the web server, Django handles the request and passes the <code class="inlineCode">HttpRequest</code> object to the corresponding view. The view processes the request and returns an <code class="inlineCode">HttpResponse</code> object that is sent back to the browser as an HTTP response. There is no mechanism to maintain an open connection or send data to the browser without an associated HTTP request.</p>
<p class="normal">The following schema shows the request cycle of a Django project using Channels with WebSockets:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_16_04.png"/></figure>
<p class="packt_figref">Figure 16.4: The Django Channels request/response cycle</p>
<p class="normal">Channels<a id="_idIndexMarker1451"/> replaces Django’s request/response cycle with<a id="_idIndexMarker1452"/> messages that are sent across channels. HTTP requests are still routed to view functions using Django, but they get routed over channels. This allows WebSocket message handling as well, where you have producers and consumers that exchange messages across a channel layer. Channels preserves Django’s synchronous architecture, allowing you to choose between writing synchronous code and asynchronous code, or a combination of both.</p>
<p class="normal">Your <a id="_idIndexMarker1453"/>existing synchronous views will co-exist with the<a id="_idIndexMarker1454"/> WebSocket functionality that we will implement with Daphne, and you will serve both HTTP and WebSocket requests.</p>
<p class="normal">Next, you are going to install Channels and add it to your project.</p>
<h1 class="heading-1" id="_idParaDest-428">Installing Channels and Daphne</h1>
<p class="normal">You are going to add Channels to your project and set up the required basic ASGI application routing for it to manage HTTP requests.</p>
<p class="normal">Install Channels in your <a id="_idIndexMarker1455"/>virtual environment with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">python -m pip install -U 'channels[daphne]==4.1.0'
</code></pre>
<p class="normal">This will simultaneously install Channels along with the Daphne ASGI application server. An ASGI server is necessary for handling asynchronous requests, and we choose Daphne for its simplicity and compatibility, as it comes bundled with Channels.</p>
<p class="normal">Edit the <code class="inlineCode">settings.py</code> file of the <code class="inlineCode">educa</code> project and add <code class="inlineCode">daphne</code> to the beginning of the <code class="inlineCode">INSTALLED_APPS</code> setting as follows:</p>
<pre class="programlisting code"><code class="hljs-code">INSTALLED_APPS = [
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'daphne'</strong><strong class="hljs-slc">,</strong>
# ...
]
</code></pre>
<p class="normal">When <code class="inlineCode">daphne</code> is added <a id="_idIndexMarker1456"/>to the <code class="inlineCode">INSTALLED_APPS</code> setting, it takes control over the <code class="inlineCode">runserver</code> command, replacing the standard Django development server. This will allow you to serve asynchronous requests during development. Besides handling URL routing to Django views for synchronous requests, Daphne also manages routes to WebSocket consumers. You can find more <a id="_idIndexMarker1457"/>information about Daphne at <a href="https://github.com/django/daphne">https://github.com/django/daphne</a>.</p>
<p class="normal">Channels expects you to define a single root application that will be executed for all requests. You can define the root application by adding the <code class="inlineCode">ASGI_APPLICATION</code> setting to your project. This is similar to the <code class="inlineCode">ROOT_URLCONF</code> setting that points to the base URL patterns of your project. You can place the root application anywhere in your project, but it is recommended to put it in a project-level file. You can add your root routing configuration to the <code class="inlineCode">asgi.py</code> file directly, where the ASGI application will be defined.</p>
<p class="normal">Edit the <code class="inlineCode">asgi.py</code> file in the <code class="inlineCode">educa</code> project directory and add the following code highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">import os
<strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> channels.routing </strong><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> ProtocolTypeRouter</strong>
from django.core.asgi import get_asgi_application
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'educa.settings')
<strong class="hljs-slc">django_asgi_app</strong> = get_asgi_application()
<strong class="hljs-slc">application = ProtocolTypeRouter({</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'http'</strong><strong class="hljs-slc">: django_asgi_app,</strong>
<strong class="hljs-slc">})</strong>
</code></pre>
<p class="normal">In the previous code, you define the main ASGI application that will be executed when serving the <a id="_idIndexMarker1458"/>Django project through ASGI. You use the <code class="inlineCode">ProtocolTypeRouter</code> class provided by Channels as the main entry point of your routing system. <code class="inlineCode">ProtocolTypeRouter</code> takes a dictionary that maps communication types like <code class="inlineCode">http</code> or <code class="inlineCode">websocket</code> to ASGI applications. You instantiate this class with the default application for the HTTP protocol. Later, you will add a protocol for the WebSocket.</p>
<p class="normal">Add the following line to the <code class="inlineCode">settings.py</code> file of your project:</p>
<pre class="programlisting code"><code class="hljs-code">ASGI_APPLICATION = 'educa.asgi.application'
</code></pre>
<p class="normal">The <code class="inlineCode">ASGI_APPLICATION</code> setting is used by Channels to locate the root routing configuration.</p>
<p class="normal">Start the development server using the following command:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py runserver
</code></pre>
<p class="normal">You will see output similar to the following:</p>
<pre class="programlisting con"><code class="hljs-con">Watching for file changes with StatReloader
Performing system checks...
System check identified no issues (0 silenced).
April 14, 2024 - 08:02:57
Django version 5.0.4, using settings 'educa.settings'
Starting ASGI/Daphne version 4.1.0 development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.
</code></pre>
<p class="normal">Check that the output contains the line <code class="inlineCode">Starting ASGI/Daphne version 4.1.0 development server</code>. This line confirms that you are using the Daphne development server, which is capable of managing synchronous and asynchronous requests, instead of the standard Django development server. HTTP requests continue to behave the same as before, but they get routed over Channels.</p>
<p class="normal">Now that Channels is installed in your project, you can build the chat server for courses. To implement the chat server for your project, you will need to take the following steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><strong class="keyWord">Set up a consumer</strong>: Consumers are individual pieces of code that can handle WebSockets in a very similar way to traditional HTTP views. You will build a consumer to read and write messages to a communication channel.</li>
<li class="numberedList"><strong class="keyWord">Configure routing</strong>: Channels provides routing classes that allow you to combine and stack your consumers. You will configure URL routing for your chat consumer.</li>
<li class="numberedList"><strong class="keyWord">Implement a WebSocket client</strong>: When the student accesses the chat room, you will connect to the WebSocket from the browser and send or receive messages using JavaScript.</li>
<li class="numberedList"><strong class="keyWord">Enable a channel layer</strong>: Channel layers allow you to talk between different instances of an application. They’re a useful part of making a distributed real-time application. You will set up a channel layer using Redis.</li>
</ol>
<p class="normal">Let’s start by writing your own consumer to handle connecting to a WebSocket, receiving and sending messages, and disconnecting.</p>
<h1 class="heading-1" id="_idParaDest-429">Writing a consumer</h1>
<p class="normal">Consumers<a id="_idIndexMarker1459"/> are the equivalent of Django views for asynchronous applications. As mentioned, they handle WebSockets in a very similar way to how traditional views handle HTTP <a id="_idIndexMarker1460"/>requests. Consumers are ASGI applications that can handle messages, notifications, and other things. Unlike Django <a id="_idIndexMarker1461"/>views, consumers are built for long-running communication. URLs are mapped to consumers through routing classes that allow you to combine and stack consumers.</p>
<p class="normal">Let’s implement a basic consumer that can accept WebSocket connections and echoes every message it receives from the WebSocket back to it. This initial functionality will allow the student to send messages to the consumer and receive back the messages it sends.</p>
<p class="normal">Create a new file inside <a id="_idIndexMarker1462"/>the <code class="inlineCode">chat</code> application directory and<a id="_idIndexMarker1463"/> name it <code class="inlineCode">consumers.py</code>. Add the following code to it:</p>
<pre class="programlisting code"><code class="hljs-code">import json
from channels.generic.websocket import WebsocketConsumer
class ChatConsumer(WebsocketConsumer):
    def connect(self):
        # accept connection
        self.accept()
    def disconnect(self, close_code):
        pass
# receive message from WebSocket
def receive(self, text_data):
        text_data_json = json.loads(text_data)
        message = text_data_json['message']
        # send message to WebSocket
        self.send(text_data=json.dumps({'message': message}))
</code></pre>
<p class="normal">This is the <code class="inlineCode">ChatConsumer</code> consumer. This class inherits from the Channels <code class="inlineCode">WebsocketConsumer</code> class to implement a basic WebSocket consumer. In this consumer, you implement the following methods:</p>
<ul>
<li class="bulletList"><code class="inlineCode">connnect()</code>: Called when a new connection is received. You accept any connection with <code class="inlineCode">self.accept()</code>. You can also reject a connection by calling <code class="inlineCode">self.close()</code>.</li>
<li class="bulletList"><code class="inlineCode">disconnect()</code>: Called when the socket closes. You use <code class="inlineCode">pass</code> because you don’t need to implement any action when a client closes the connection.</li>
<li class="bulletList"><code class="inlineCode">receive()</code>: Called whenever data is received from the WebSocket. You expect text to be received as <code class="inlineCode">text_data</code> (this could also be <code class="inlineCode">binary_data</code> for binary data). You treat the text data received as JSON. Therefore, you use <code class="inlineCode">json.loads()</code> to load the received JSON data into a Python dictionary. You access the <code class="inlineCode">message</code> key, which you expect to be present in the JSON structure received. To echo the message, you send the message back to the WebSocket with <code class="inlineCode">self.send()</code>, transforming it into JSON format again through <code class="inlineCode">json.dumps()</code>.</li>
</ul>
<p class="normal">The <a id="_idIndexMarker1464"/>initial version of your <code class="inlineCode">ChatConsumer</code> consumer accepts any WebSocket <a id="_idIndexMarker1465"/>connection and echoes to the WebSocket client every message it receives. Note that the consumer does not broadcast messages to other clients yet. You will build this functionality by implementing a channel layer later.</p>
<p class="normal">First, let’s expose our consumer by adding it to the URLs of the project.</p>
<h1 class="heading-1" id="_idParaDest-430">Routing</h1>
<p class="normal">You need to define <a id="_idIndexMarker1466"/>a URL to <a id="_idIndexMarker1467"/>route connections to the <code class="inlineCode">ChatConsumer</code> consumer you have implemented. Channels provides routing classes that allow you to combine and stack consumers to dispatch based on what the connection is. You can think of them as the URL routing system of Django for asynchronous applications.</p>
<p class="normal">Create a new file inside the <code class="inlineCode">chat</code> application directory and name it <code class="inlineCode">routing.py</code>. Add the following code to it:</p>
<pre class="programlisting code"><code class="hljs-code">from django.urls import re_path
from . import consumers
websocket_urlpatterns = [
    re_path(
        r'ws/chat/room/(?P&lt;course_id&gt;\d+)/$',
        consumers.ChatConsumer.as_asgi()
    ),
]
</code></pre>
<p class="normal">In this code, you map a URL pattern with the <code class="inlineCode">ChatConsumer</code> class that you defined in the <code class="inlineCode">chat/consumers.py</code> file. There are some details that are worth reviewing:</p>
<ul>
<li class="bulletList">You use Django’s <code class="inlineCode">re_path()</code> to define the path with a regular expression instead of <code class="inlineCode">path()</code>. Channels’ URL routing may not function correctly with <code class="inlineCode">path()</code> routes if inner routers are wrapped by additional middleware, so this approach helps avoid any issues.</li>
<li class="bulletList">The URL includes an integer parameter called <code class="inlineCode">course_id</code>. This parameter will be available in the scope of the consumer and will allow you to identify the course chat room that the user is connecting to.</li>
<li class="bulletList">You call the <code class="inlineCode">as_asgi()</code> method of the <code class="inlineCode">consumer</code> class in order to get an ASGI application that will instantiate an instance of the consumer for each user connection. This behavior is similar to Django’s <code class="inlineCode">as_view()</code> method for class-based views.</li>
</ul>
<div><p class="normal">It is a good practice to prepend WebSocket URLs with <code class="inlineCode">/ws/</code> to differentiate them from URLs used for standard synchronous HTTP requests. This also simplifies the production setup when an HTTP server routes requests based on the path.</p>
</div>
<p class="normal">Edit the global <code class="inlineCode">asgi.py</code> file <a id="_idIndexMarker1468"/>located next to the <code class="inlineCode">settings.py</code> file<a id="_idIndexMarker1469"/> so that it looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">import os
<strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> channels.auth </strong><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> AuthMiddlewareStack</strong>
from channels.routing import ProtocolTypeRouter<strong class="hljs-slc">, URLRouter</strong>
from django.core.asgi import get_asgi_application
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'educa.settings')
django_asgi_app = get_asgi_application()
<strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> chat.routing </strong><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> websocket_urlpatterns</strong>
application = ProtocolTypeRouter({
    'http': django_asgi_app,
    <strong class="hljs-string-slc">'websocket'</strong><strong class="hljs-slc">: AuthMiddlewareStack(</strong>
<strong class="hljs-slc">        URLRouter(websocket_urlpatterns)</strong>
<strong class="hljs-slc">    ),</strong>
})
</code></pre>
<p class="normal">In this code, you have added:</p>
<ul>
<li class="bulletList">A new route for the <code class="inlineCode">websocket</code> protocol. You use <code class="inlineCode">URLRouter</code> to map <code class="inlineCode">websocket</code> connections to the URL patterns defined in the <code class="inlineCode">websocket_urlpatterns</code> list of the <code class="inlineCode">chat.routing</code> module.</li>
<li class="bulletList"><code class="inlineCode">AuthMiddlewareStack</code> as a wrapper function for the URL router. The <code class="inlineCode">AuthMiddlewareStack</code> class provided by Channels supports standard Django authentication, where the user details are stored in the session. Later, you will access the user instance in the scope of the consumer to identify the user who sends a message.</li>
</ul>
<p class="normal">Note that <a id="_idIndexMarker1470"/>the <code class="inlineCode">websocket_urlpatterns</code> import <a id="_idIndexMarker1471"/>is below the <code class="inlineCode">get_asgi_application()</code> function call. This is needed to ensure the application registry is populated before importing code that may import ORM models.</p>
<p class="normal">Now that we have a functioning WebSocket consumer that is available through a URL, we can implement the WebSocket client.</p>
<h1 class="heading-1" id="_idParaDest-431">Implementing the WebSocket client</h1>
<p class="normal">So far, you have <a id="_idIndexMarker1472"/>created the <code class="inlineCode">course_chat_room</code> view and its corresponding template for students to access the<a id="_idIndexMarker1473"/> course chat room. You have implemented a WebSocket consumer for the chat server and tied it with URL routing. Now, you need to build a WebSocket client to establish a connection with the WebSocket in the course chat room template and be able to send/receive messages.</p>
<p class="normal">You are going to implement the WebSocket client with JavaScript to open and maintain a connection in the browser, and you will<a id="_idIndexMarker1474"/> interact with the <strong class="keyWord">Document Object Model</strong> (<strong class="keyWord">DOM</strong>) using JavaScript.</p>
<p class="normal">You will perform the following tasks related to the WebSocket client:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Open a WebSocket connection with the server when the page is loaded.</li>
<li class="numberedList">Add messages to an HTML container when data is received through the WebSocket.</li>
<li class="numberedList">Attach a listener to the submit button to send messages through the WebSocket when the user clicks the <strong class="screenText">SEND</strong> button or presses the <em class="italic">Enter</em> key.</li>
</ol>
<p class="normal">Let’s start by opening the WebSocket connection.</p>
<p class="normal">Edit the <code class="inlineCode">chat/room.html</code> template of the <code class="inlineCode">chat</code> application and modify the <code class="inlineCode">include_js</code> and <code class="inlineCode">domready</code> blocks, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">{% block include_js %}
<strong class="hljs-slc">  {{ course.id|json_script:"course-id" }}</strong>
{% endblock %}
{% block domready %}
<strong class="hljs-slc">  const courseId = JSON.parse(</strong>
<strong class="hljs-slc">    document.getElementById('course-id').textContent</strong>
<strong class="hljs-slc">  );</strong>
<strong class="hljs-slc">  const url = 'ws://' + window.location.host +</strong>
<strong class="hljs-slc">              '/ws/chat/room/' + courseId + '/';</strong>
<strong class="hljs-slc">  const chatSocket = new WebSocket(url);</strong>
{% endblock %}
</code></pre>
<p class="normal">In the <code class="inlineCode">include_js</code> block, you<a id="_idIndexMarker1475"/> use the <code class="inlineCode">json_script</code> template<a id="_idIndexMarker1476"/> filter to securely use the value of <code class="inlineCode">course.id</code> with JavaScript. The <code class="inlineCode">json_script</code> template filter provided by Django outputs a Python object as JSON, wrapped in a <code class="inlineCode">&lt;script&gt;</code> tag, so that you can safely use it with JavaScript. The code <code class="inlineCode">{{ course.id|json_script:"course-id" }}</code> is rendered as <code class="inlineCode">&lt;script id="course-id" type="application/json"&gt;6&lt;/script&gt;</code>. This value is then retrieved in the <code class="inlineCode">domready</code> block by parsing the content of the element with <code class="inlineCode">id="course-id"</code> using <code class="inlineCode">JSON.parse()</code>. This is the safe way to use Python objects in JavaScript.</p>
<div><p class="normal">The <code class="inlineCode">json_script</code> template filter securely encodes Python objects as JSON and safely embeds them in a <code class="inlineCode">&lt;script&gt;</code> HTML tag, protecting against <strong class="keyWord">cross-site scripting</strong> (<strong class="keyWord">XSS</strong>) attacks by escaping potentially harmful characters.</p>
</div>
<p class="normal">You can find more information <a id="_idIndexMarker1477"/>about the <code class="inlineCode">json_script</code> template filter at <a href="https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#json-script">https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#json-script</a>.</p>
<p class="normal">In the <code class="inlineCode">domready</code> block, you define an URL with the WebSocket protocol, which looks like <code class="inlineCode">ws://</code> (or <code class="inlineCode">wss://</code> for secure WebSockets, just like <code class="inlineCode">https://</code>). You build the URL using the current location of the browser, which you obtain from <code class="inlineCode">window.location.host</code>. The rest of the URL is built with the path for the chat room URL pattern that you defined in the <code class="inlineCode">routing.py</code> file of the <code class="inlineCode">chat</code> application.</p>
<p class="normal">You write the URL instead of building it with a resolver because Channels does not provide a way to reverse URLs. You use the current course <code class="inlineCode">ID</code> to generate the URL for the current course and store the URL in a new constant named <code class="inlineCode">url</code>.</p>
<p class="normal">You then open a WebSocket connection to the stored URL using <code class="inlineCode">new</code> <code class="inlineCode">WebSocket(url)</code>. You assign the instantiated WebSocket client object to the new constant <code class="inlineCode">chatSocket</code>.</p>
<p class="normal">You have created a<a id="_idIndexMarker1478"/> WebSocket consumer, you<a id="_idIndexMarker1479"/> have included routing for it, and you have implemented a basic WebSocket client. Let’s try the initial version of your chat.</p>
<p class="normal">Start the development server using the following command:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py runserver
</code></pre>
<p class="normal">Open the URL <code class="inlineCode">http://127.0.0.1:8000/chat/room/1/</code> in your browser, replacing <code class="inlineCode">1</code> with the <code class="inlineCode">id</code> of an existing course in the database. Take a look at the console output. Besides the HTTP <code class="inlineCode">GET</code> requests for the page and its static files, you should see two lines, including <code class="inlineCode">WebSocket HANDSHAKING</code> and <code class="inlineCode">WebSocket CONNECT</code>, like the following output:</p>
<pre class="programlisting con"><code class="hljs-con">HTTP GET /chat/room/1/ 200 [0.02, 127.0.0.1:57141]
WebSocket HANDSHAKING /ws/chat/room/1/ [127.0.0.1:57144]
WebSocket CONNECT /ws/chat/room/1/ [127.0.0.1:57144]
</code></pre>
<p class="normal">The Daphne server listens for incoming socket connections using a standard TCP socket. The handshake is the bridge from HTTP to WebSockets. In the handshake, details of the connection are negotiated and either party can close the connection before completion. Remember that you are using <code class="inlineCode">self.accept()</code> to accept any connection in the <code class="inlineCode">connect()</code> method of the <code class="inlineCode">ChatConsumer</code> class, implemented in the <code class="inlineCode">consumers.py</code> file of the <code class="inlineCode">chat</code> application. The connection is accepted, and therefore, you see the <code class="inlineCode">WebSocket CONNECT</code> message in the console.</p>
<p class="normal">If you use the browser developer tools to track network connections, you can also see information for the WebSocket connection that has been established.</p>
<p class="normal">It should look like <em class="italic">Figure 16.5</em>:</p>
<figure class="mediaobject"><img alt="Graphical user interface, application, table  Description automatically generated" src="img/B21088_16_05.png"/></figure>
<p class="packt_figref">Figure 16.5: The browser developer tools showing that the WebSocket connection has been established</p>
<p class="normal">Now that you <a id="_idIndexMarker1480"/>can connect to the WebSocket, it’s time to interact with it. You will implement the methods to handle common events, such <a id="_idIndexMarker1481"/>as receiving a message and closing the connection. Edit the <code class="inlineCode">chat/room.html</code> template of the <code class="inlineCode">chat</code> application and modify the <code class="inlineCode">domready</code> block, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">{% block domready %}
  const courseId = JSON.parse(
    document.getElementById('course-id').textContent
  );
  const url = 'ws://' + window.location.host +
              '/ws/chat/room/' + courseId + '/';
  const chatSocket = new WebSocket(url);
<strong class="hljs-slc">  chatSocket.</strong><strong class="hljs-params-slc">onmessage = </strong><strong class="hljs-keyword-slc">function</strong><strong class="hljs-params-slc">(event) {</strong>
<strong class="hljs-params-slc">    const data = </strong><strong class="hljs-title-slc">JSON</strong><strong class="hljs-params-slc">.</strong><strong class="hljs-title-slc">parse</strong><strong class="hljs-params-slc">(event.data);</strong>
<strong class="hljs-params-slc"> </strong><strong class="hljs-keyword-slc">const</strong><strong class="hljs-params-slc"> chat = </strong><strong class="hljs-variable-slc">document</strong><strong class="hljs-params-slc">.</strong><strong class="hljs-title-slc">getElementById</strong><strong class="hljs-params-slc">(</strong><strong class="hljs-string-slc">'chat'</strong><strong class="hljs-params-slc">);</strong>
<strong class="hljs-params-slc">    chat.innerHTML += </strong><strong class="hljs-string-slc">'&lt;div class="message"&gt;'</strong><strong class="hljs-params-slc"> +</strong>
<strong class="hljs-params-slc">                      data.message + </strong><strong class="hljs-string-slc">'</strong><strong class="hljs-string-slc">&lt;/div&gt;'</strong><strong class="hljs-params-slc">;</strong>
<strong class="hljs-params-slc">    chat.scrollTop = chat.scrollHeight;</strong>
<strong class="hljs-params-slc">  };</strong>
<strong class="hljs-params-slc">  chatSocket.onclose = </strong><strong class="hljs-keyword-slc">function</strong><strong class="hljs-params-slc">(event) {</strong>
<strong class="hljs-params-slc"> </strong><strong class="hljs-variable-slc">console</strong><strong class="hljs-params-slc">.</strong><strong class="hljs-title-slc">error</strong><strong class="hljs-params-slc">(</strong><strong class="hljs-string-slc">'Chat socket closed unexpectedly'</strong><strong class="hljs-params-slc">);</strong>
<strong class="hljs-params-slc">  };</strong>
{% endblock %}
</code></pre>
<p class="normal">In this code, you define the following events for the WebSocket client:</p>
<ul>
<li class="bulletList"><code class="inlineCode">onmessage</code>: Fired when data is received through the WebSocket. You parse the message, which you expect in JSON format, and access its <code class="inlineCode">message</code> attribute. You then append a new <code class="inlineCode">&lt;div&gt;</code> element with the message received to the HTML element with the <code class="inlineCode">chat</code> ID. This will add new messages to the chat log, while keeping all previous messages that have been added to the log. You scroll the chat log <code class="inlineCode">&lt;div&gt;</code> to the bottom to ensure that the new message gets visibility. You achieve this by scrolling to the total scrollable height of the chat log, which can be obtained by accessing its <code class="inlineCode">scrollHeight</code> attribute.</li>
<li class="bulletList"><code class="inlineCode">onclose</code>: Fired when the connection with the WebSocket is closed. You don’t expect to close the connection, and therefore, you write the error <code class="inlineCode">Chat socket closed unexpectedly</code> to the console log if this happens.</li>
</ul>
<p class="normal">You have implemented the action to display the message when a new message is received. You need to implement the functionality to send messages to the socket as well.</p>
<p class="normal">Edit the <code class="inlineCode">chat/room.html</code> template of the <code class="inlineCode">chat</code> application and add the following JavaScript code <a id="_idIndexMarker1482"/>to the bottom of<a id="_idIndexMarker1483"/> the <code class="inlineCode">domready</code> block:</p>
<pre class="programlisting code"><code class="hljs-code">const input = document.getElementById('chat-message-input');
const submitButton = document.getElementById('chat-message-submit');
submitButton.addEventListener('click', function(event) {
  const message = input.value;
  if(message) {
    // send message in JSON format
    chatSocket.send(JSON.stringify({'message': message}));
    // clear input
    input.value = '';
    input.focus();
  }
});
</code></pre>
<p class="normal">In this code, you define an event listener for the <code class="inlineCode">click</code> event of the submit button, which you select by its ID <code class="inlineCode">chat-message-submit</code>. When the button is clicked, you perform the following actions:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">You read the message entered by the user from the value of the text input element with the ID <code class="inlineCode">chat-message-input</code>.</li>
<li class="numberedList">You check whether the message has any content with <code class="inlineCode">if(message)</code>.</li>
<li class="numberedList">If the user has entered a message, you form JSON content such as <code class="inlineCode">{'message': 'string entered by the user'}</code> by using <code class="inlineCode">JSON.stringify()</code>.</li>
<li class="numberedList">You send the JSON content through the WebSocket, calling the <code class="inlineCode">send()</code> method of <code class="inlineCode">chatSocket</code> client.</li>
<li class="numberedList">You clear the contents of the text input by setting its value to an empty string with <code class="inlineCode">input.value = ''</code>.</li>
<li class="numberedList">You return the focus to the text input with <code class="inlineCode">input.focus()</code> so that the user can write a new message straight away.</li>
</ol>
<p class="normal">The user is now able to send messages using the text input and by clicking the submit button.</p>
<p class="normal">To improve the<a id="_idIndexMarker1484"/> user experience, you will give focus to the text input when the page loads, allowing users to begin typing immediately without needing to click on it first. You will also capture keyboard <a id="_idIndexMarker1485"/>keypress events to identify the <em class="italic">Enter</em> key and fire the <code class="inlineCode">click</code> event on the submit button. Users will be able to either click the button or press the <em class="italic">Enter</em> key to send a message.</p>
<p class="normal">Edit the <code class="inlineCode">chat/room.html</code> template of the <code class="inlineCode">chat</code> application and add the following JavaScript code to the bottom of the <code class="inlineCode">domready</code> block:</p>
<pre class="programlisting code"><code class="hljs-code">input.addEventListener('keypress', function(event) {
    if (event.key === 'Enter') {
      // cancel the default action, if needed
      event.preventDefault();
      // trigger click event on button
      submitButton.click();
    }
  });
 
input.focus();
</code></pre>
<p class="normal">In this code, you also define a function for the <code class="inlineCode">keypress</code> event of the <code class="inlineCode">input</code> element. For any key that the user presses, you perform the following actions:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">You check whether its key is <em class="italic">Enter</em>.</li>
<li class="numberedList">If the <em class="italic">Enter</em> key is pressed:<ol class="alphabeticList" style="list-style-type: lower-alpha;">
<li class="alphabeticList" value="1">You prevent the default behavior for this key with <code class="inlineCode">event.preventDefault()</code>.</li>
<li class="alphabeticList">Then you fire the <code class="inlineCode">click</code> event on the submit button to send the message to the WebSocket.</li>
</ol>
</li>
</ol>
<p class="normal">Outside of the<a id="_idIndexMarker1486"/> event handler, in the <a id="_idIndexMarker1487"/>main JavaScript code for the <code class="inlineCode">domready</code> block, you give the focus to the text input with <code class="inlineCode">input.focus()</code>. By doing so, when the DOM is loaded, the focus will be set on the <code class="inlineCode">input</code> element for the user to type a message.</p>
<p class="normal">The <code class="inlineCode">domready</code> block of the <code class="inlineCode">chat/room.html</code> template should now look as follows:</p>
<pre class="programlisting code"><code class="hljs-code">{% block domready %}
  const courseId = JSON.parse(
    document.getElementById('course-id').textContent
  );
  const url = 'ws://' + window.location.host +
              '/ws/chat/room/' + courseId + '/';
  const chatSocket = new WebSocket(url);
  chatSocket.onmessage = function(event) {
    const data = JSON.parse(event.data);
    const chat = document.getElementById('chat');
    chat.innerHTML += '&lt;div class="message"&gt;' +
                      data.message + '&lt;/div&gt;';
    chat.scrollTop = chat.scrollHeight;
  };
  chatSocket.onclose = function(event) {
    console.error('Chat socket closed unexpectedly');
  };
  const input = document.getElementById('chat-message-input');
  const submitButton = document.getElementById('chat-message-submit');
  submitButton.addEventListener('click', function(event) {
    const message = input.value;
    if(message) {
      // send message in JSON format
      chatSocket.send(JSON.stringify({'message': message}));
      // clear input
      input.value = '';
      input.focus();
    }
  });
  input.addEventListener('keypress', function(event) {
    if (event.key === 'Enter') {
      // cancel the default action, if needed
      event.preventDefault();
      // trigger click event on button
      submitButton.click();
    }
  });
 
  input.focus();
{% endblock %}
</code></pre>
<p class="normal">Open the URL <code class="inlineCode">http://127.0.0.1:8000/chat/room/1/</code> in your browser, replacing <code class="inlineCode">1</code> with the <code class="inlineCode">id</code> of an existing course in the database. With a logged-in user who is enrolled in the course, write some text in the input field and click the <strong class="screenText">SEND</strong> button or press the <em class="italic">Enter</em> key.</p>
<p class="normal">You will see that <a id="_idIndexMarker1488"/>your message appears<a id="_idIndexMarker1489"/> in the chat log:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_16_06.png"/></figure>
<p class="packt_figref">Figure 16.6: The chat room page, including messages sent through the WebSocket</p>
<p class="normal">Great! The message has been sent through the WebSocket and the <code class="inlineCode">ChatConsumer</code> consumer has received the message and has sent it back through the WebSocket. The <code class="inlineCode">chatSocket</code> client has received a message event and the <code class="inlineCode">onmessage</code> function has been fired, adding the message to the chat log.</p>
<p class="normal">You have <a id="_idIndexMarker1490"/>implemented the<a id="_idIndexMarker1491"/> functionality with a WebSocket consumer and a WebSocket client to establish client/server communication and can send or receive events. However, the chat server is not able to broadcast messages to other clients. If you open a second browser tab and enter a message, the message will not appear on the first tab. In order to build communication between consumers, you have to enable a channel layer.</p>
<h1 class="heading-1" id="_idParaDest-432">Enabling a channel layer</h1>
<p class="normal">Channel layers<a id="_idIndexMarker1492"/> allow you to communicate between different instances of an <a id="_idIndexMarker1493"/>application. A channel layer is the transport mechanism that allows multiple consumer instances to communicate with each other and with other parts of Django.</p>
<p class="normal">In your chat server, you plan to have multiple instances of the <code class="inlineCode">ChatConsumer</code> consumer for the same course chat room. Each student who joins the chat room will instantiate the WebSocket client in their browser, and that will open a connection with an instance of the WebSocket consumer. You need a common channel layer to distribute messages between consumers.</p>
<h2 class="heading-2" id="_idParaDest-433">Channels and groups</h2>
<p class="normal">Channel layers provide two abstractions to manage communications: channels and groups:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Channel</strong>: You <a id="_idIndexMarker1494"/>can think of a channel as an inbox where messages can be sent or as a task queue. Each channel has a name. Messages are sent to a channel by anyone who knows the channel name and then given to consumers listening on that channel.</li>
<li class="bulletList"><strong class="keyWord">Group</strong>: Multiple <a id="_idIndexMarker1495"/>channels can be grouped into a group. Each group has a name. A channel can be added or removed from a group by anyone who knows the group name. Using the group name, you can also send a message to all channels in the group.</li>
</ul>
<p class="normal">You will work with channel groups to implement the chat server. By creating a channel group for each course chat room, the <code class="inlineCode">ChatConsumer</code> instances will be able to communicate with each other.</p>
<p class="normal">Let’s add a channel layer to our project.</p>
<h2 class="heading-2" id="_idParaDest-434">Setting up a channel layer with Redis</h2>
<p class="normal">Redis<a id="_idIndexMarker1496"/> is the preferred option for a channel layer, though Channels has support for other types of channel layers. Redis works as the communication store for the channel layer. Remember that you already used Redis in <em class="italic">Chapter 7</em>, <em class="italic">Tracking User Actions</em>, <em class="italic">Chapter 10</em>, <em class="italic">Extending Your Shop</em>, and <em class="italic">Chapter 14</em>, <em class="italic">Rendering and Caching Content</em>.</p>
<p class="normal">If you haven’t <a id="_idIndexMarker1497"/>installed<a id="_idIndexMarker1498"/> Redis yet, you can find installation instructions in <em class="italic">Chapter 7</em>, <em class="italic">Tracking User Actions</em>.</p>
<p class="normal">To use Redis as a channel layer, you have to install the <code class="inlineCode">channels-redis</code> package. Install <code class="inlineCode">channels-redis</code> in your virtual environment with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">python -m pip install channels-redis==4.2.0
</code></pre>
<p class="normal">Edit the <code class="inlineCode">settings.py</code> file of the <code class="inlineCode">educa</code> project and add the following code to it:</p>
<pre class="programlisting code"><code class="hljs-code">CHANNEL_LAYERS = {
    'default': {
        'BACKEND': 'channels_redis.core.RedisChannelLayer',
        'CONFIG': {
            'hosts': [('127.0.0.1', 6379)],
        },
    },
}
</code></pre>
<p class="normal">The <code class="inlineCode">CHANNEL_LAYERS</code> setting defines the configuration for the channel layers available to the project. You define a default channel layer using the <code class="inlineCode">RedisChannelLayer</code> backend provided by <code class="inlineCode">channels-redis</code> and specify the host <code class="inlineCode">127.0.0.1</code> and the port <code class="inlineCode">6379</code>, on which Redis is running.</p>
<p class="normal">Let’s try the channel layer. Initialize the Redis Docker container using the following command:</p>
<pre class="programlisting con"><code class="hljs-con">docker run -it --rm --name redis -p 6379:6379 redis:7.2.4
</code></pre>
<p class="normal">If you want to run the command in the background (in detached mode) you can use the <code class="inlineCode">-d</code> option.</p>
<p class="normal">Open the Django shell using the following command from the project directory:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py shell
</code></pre>
<p class="normal">To verify that the <a id="_idIndexMarker1499"/>channel layer can communicate with Redis, write the following<a id="_idIndexMarker1500"/> code to send a message to a test channel named <code class="inlineCode">test_channel</code> and receive it back:</p>
<pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; import channels.layers
&gt;&gt;&gt; from asgiref.sync import async_to_sync
&gt;&gt;&gt; channel_layer = channels.layers.get_channel_layer()
&gt;&gt;&gt; async_to_sync(channel_layer.send)('test_channel', {'message': 'hello'})
&gt;&gt;&gt; async_to_sync(channel_layer.receive)('test_channel')
</code></pre>
<p class="normal">You should get the following output:</p>
<pre class="programlisting con"><code class="hljs-con">{'message': 'hello'}
</code></pre>
<p class="normal">In the previous code, you send a message to a test channel through the channel layer, and then you retrieve it from the channel layer. The channel layer is communicating successfully with Redis.</p>
<p class="normal">Next, we will add the channel layer to our project.</p>
<h2 class="heading-2" id="_idParaDest-435">Updating the consumer to broadcast messages</h2>
<p class="normal">Let’s edit<a id="_idIndexMarker1501"/> the <code class="inlineCode">ChatConsumer</code> consumer to use the channel layer we have implemented with Redis. You will use a channel group for each course chat room. Therefore, you will use the course <code class="inlineCode">id</code> to build the group name. <code class="inlineCode">ChatConsumer</code> instances will know the group name and will be able to communicate with each other.</p>
<p class="normal">Edit the <code class="inlineCode">consumers.py</code> file of the <code class="inlineCode">chat</code> application, import the <code class="inlineCode">async_to_sync()</code> function, and modify the <code class="inlineCode">connect()</code> method of the <code class="inlineCode">ChatConsumer</code> class, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">import json
<strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> asgiref.sync </strong><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> async_to_sync</strong>
from channels.generic.websocket import WebsocketConsumer
class ChatConsumer(WebsocketConsumer):
    def connect(self):
<strong class="hljs-slc">        self.</strong><strong class="hljs-built_in-slc">id</strong><strong class="hljs-slc"> = self.scope[</strong><strong class="hljs-string-slc">'url_route'</strong><strong class="hljs-slc">][</strong><strong class="hljs-string-slc">'kwargs'</strong><strong class="hljs-slc">][</strong><strong class="hljs-string-slc">'course_id'</strong><strong class="hljs-slc">]</strong>
<strong class="hljs-slc">        self.room_group_name = </strong><strong class="hljs-string-slc">f'chat_</strong><strong class="hljs-subst-slc">{self.</strong><strong class="hljs-built_in-slc">id</strong><strong class="hljs-subst-slc">}</strong><strong class="hljs-string-slc">'</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-comment-slc"># join room group</strong>
<strong class="hljs-slc">        async_to_sync(self.channel_layer.group_add)(</strong>
<strong class="hljs-slc">            self.room_group_name, self.channel_name</strong>
<strong class="hljs-slc">        )</strong>
# accept connection
        self.accept()
    # ...
</code></pre>
<p class="normal">In this code, you import the <code class="inlineCode">async_to_sync()</code> helper function to wrap calls to asynchronous channel<a id="_idIndexMarker1502"/> layer methods. <code class="inlineCode">ChatConsumer</code> is a synchronous <code class="inlineCode">WebsocketConsumer</code> consumer, but it needs to call asynchronous methods of the channel layer.</p>
<p class="normal">In the new <code class="inlineCode">connect()</code> method, you perform the following tasks:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">You retrieve the course <code class="inlineCode">id</code> from the scope to know the course that the chat room is associated with. You access <code class="inlineCode">self.scope['url_route']['kwargs']['course_id']</code> to retrieve the <code class="inlineCode">course_id</code> parameter from the URL. Every consumer has a scope with information about its connection, arguments passed by the URL, and the authenticated user, if any.</li>
<li class="numberedList">You build the group name with the <code class="inlineCode">id</code> of the course that the group corresponds to. Remember that you will have a channel group for each course chat room. You store the group name in the <code class="inlineCode">room_group_name</code> attribute of the consumer.</li>
<li class="numberedList">You join the group by adding the current channel to the group. You obtain the channel name from the <code class="inlineCode">channel_name</code> attribute of the consumer. You use the <code class="inlineCode">group_add</code> method of the channel layer to add the channel to the group. You use the <code class="inlineCode">async_to_sync()</code> wrapper to use the channel layer asynchronous method.</li>
<li class="numberedList">You keep the <code class="inlineCode">self.accept()</code> call to accept the WebSocket connection.</li>
</ol>
<p class="normal">When the <code class="inlineCode">ChatConsumer</code> consumer receives a new WebSocket connection, it adds the channel to the group associated with the course in its scope. The consumer is now able to receive any messages sent to the group.</p>
<p class="normal">In the same <code class="inlineCode">consumers.py</code> file, modify the <code class="inlineCode">disconnect()</code> method of the <code class="inlineCode">ChatConsumer</code> class, as follows:</p>
<pre class="programlisting code"><code class="hljs-code"> class ChatConsumer(WebsocketConsumer):
    # ...
def disconnect(self, close_code):
<strong class="hljs-slc"> </strong><strong class="hljs-comment-slc"># leave room group</strong>
<strong class="hljs-slc">        async_to_sync(self.channel_layer.group_discard)(</strong>
<strong class="hljs-slc">            self.room_group_name, self.channel_name</strong>
<strong class="hljs-slc">        )</strong>
# ...
</code></pre>
<p class="normal">When the connection is<a id="_idIndexMarker1503"/> closed, you call the <code class="inlineCode">group_discard()</code> method of the channel layer to leave the group. You use the <code class="inlineCode">async_to_sync()</code> wrapper to use the channel layer asynchronous method.</p>
<p class="normal">In the same <code class="inlineCode">consumers.py</code> file, modify the <code class="inlineCode">receive()</code> method of the <code class="inlineCode">ChatConsumer</code> class, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">class ChatConsumer(WebsocketConsumer):
    # ...
# receive message from WebSocket
def receive(self, text_data):
        text_data_json = json.loads(text_data)
        message = text_data_json['message']
<strong class="hljs-slc"> </strong><strong class="hljs-comment-slc"># send message to room group</strong>
<strong class="hljs-slc">        async_to_sync(self.channel_layer.group_send)(</strong>
<strong class="hljs-slc">            self.room_group_name,</strong>
<strong class="hljs-slc">            {</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'type'</strong><strong class="hljs-slc">: </strong><strong class="hljs-string-slc">'chat_message'</strong><strong class="hljs-slc">,</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'message'</strong><strong class="hljs-slc">: message,</strong>
<strong class="hljs-slc">            }</strong>
<strong class="hljs-slc">        )</strong>
</code></pre>
<p class="normal">When you receive a message from the WebSocket connection, instead of sending the message to the associated channel, you send the message to the group. You do this by calling the <code class="inlineCode">group_send()</code> method of the channel layer. You use the <code class="inlineCode">async_to_sync()</code> wrapper to use the channel layer asynchronous method. You pass the following information in the event sent to the group:</p>
<ul>
<li class="bulletList"><code class="inlineCode">type</code>: The event type. This is a special key that corresponds to the name of the method that should be invoked on consumers that receive the event. You can implement a method in the consumer named the same as the message type so that it gets executed every time a message with that specific type is received.</li>
<li class="bulletList"><code class="inlineCode">message</code>: The actual message you are sending.</li>
</ul>
<p class="normal">In the same <code class="inlineCode">consumers.py</code> file, add <a id="_idIndexMarker1504"/>a new <code class="inlineCode">chat_message()</code> method in the <code class="inlineCode">ChatConsumer</code> class, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">class ChatConsumer(WebsocketConsumer):
    # ...
<strong class="hljs-slc"> </strong><strong class="hljs-comment-slc"># receive message from room group</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">def</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">chat_message</strong><strong class="hljs-slc">(</strong><strong class="hljs-params-slc">self, event</strong><strong class="hljs-slc">):</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-comment-slc"># send message to WebSocket</strong>
<strong class="hljs-slc">        self.send(text_data=json.dumps(event))</strong>
</code></pre>
<p class="normal">You name this method <code class="inlineCode">chat_message()</code> to match the <code class="inlineCode">type</code> key that is sent to the channel group when a message is received from the WebSocket. When a message with type <code class="inlineCode">chat_message</code> is sent to the group, all consumers subscribed to the group will receive the message and will execute the <code class="inlineCode">chat_message()</code> method. In the <code class="inlineCode">chat_message()</code> method, you send the event message received to the WebSocket.</p>
<p class="normal">The complete <code class="inlineCode">consumers.py</code> file should now look like this:</p>
<pre class="programlisting code"><code class="hljs-code">import json
from asgiref.sync import async_to_sync
from channels.generic.websocket import WebsocketConsumer
class ChatConsumer(WebsocketConsumer):
    def connect(self):
        self.id = self.scope['url_route']['kwargs']['course_id']
        self.room_group_name = f'chat_{self.id}'
# join room group
        async_to_sync(self.channel_layer.group_add)(
            self.room_group_name, self.channel_name
        )
        # accept connection
        self.accept()
    def disconnect(self, close_code):
        # leave room group
        async_to_sync(self.channel_layer.group_discard)(
            self.room_group_name, self.channel_name
        )
    # receive message from WebSocket
def receive(self, text_data):
        text_data_json = json.loads(text_data)
        message = text_data_json['message']
        # send message to room group
        async_to_sync(self.channel_layer.group_send)(
            self.room_group_name,
            {
                'type': 'chat_message',
                'message': message,
            }
        )
    # receive message from room group
def chat_message(self, event):
        # send message to WebSocket
        self.send(text_data=json.dumps(event))
</code></pre>
<p class="normal">You have implemented a <a id="_idIndexMarker1505"/>channel layer in <code class="inlineCode">ChatConsumer</code>, allowing consumers to broadcast messages and communicate with each other.</p>
<p class="normal">Run the development server with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py runserver
</code></pre>
<p class="normal">Open the URL <code class="inlineCode">http://127.0.0.1:8000/chat/room/1/</code> in your browser, replacing <code class="inlineCode">1</code> with the <code class="inlineCode">id</code> of an existing course in the database. Write a message and send it. Then, open a second browser window and access the same URL. Send a message from each browser window.</p>
<p class="normal">The result should look like this:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_16_07.png"/></figure>
<p class="packt_figref">Figure 16.7: The chat room page with messages sent from different browser windows</p>
<p class="normal">You will see that the <a id="_idIndexMarker1506"/>first message is only displayed in the first browser window. When you open a second browser window, messages sent in any of the browser windows are displayed in both of them. When you open a new browser window and access the chat room URL, a new WebSocket connection is established between the JavaScript WebSocket client in the browser and the WebSocket consumer in the server. Each channel gets added to the group associated with the course ID and passed through the URL to the consumer. Messages are sent to the group and received by all consumers.</p>
<p class="normal">Next, we are going to enrich messages with additional context.</p>
<h2 class="heading-2" id="_idParaDest-436">Adding context to the messages</h2>
<p class="normal">Now that messages can<a id="_idIndexMarker1507"/> be exchanged between all users in a chat room, you probably want to display who sent which message and when it was sent. Let’s add some context to the messages.</p>
<p class="normal">Edit the <code class="inlineCode">consumers.py</code> file of the <code class="inlineCode">chat</code> application and implement the following changes:</p>
<pre class="programlisting code"><code class="hljs-code">import json
from asgiref.sync import async_to_sync
from channels.generic.websocket import WebsocketConsumer
<strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> django.utils </strong><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> timezone</strong>
class ChatConsumer(WebsocketConsumer):
    def connect(self):
<strong class="hljs-slc">        self.user = self.scope[</strong><strong class="hljs-string-slc">'user'</strong><strong class="hljs-slc">]</strong>
        self.id = self.scope['url_route']['kwargs']['course_id']
        self.room_group_name = f'chat_{self.id}'
# join room group
        async_to_sync(self.channel_layer.group_add)(
            self.room_group_name, self.channel_name
        )
        # accept connection
        self.accept()
    def disconnect(self, close_code):
        # leave room group
        async_to_sync(self.channel_layer.group_discard)(
            self.room_group_name, self.channel_name
        )
    # receive message from WebSocket
def receive(self, text_data):
        text_data_json = json.loads(text_data)
        message = text_data_json['message']
<strong class="hljs-slc">        now = timezone.now()</strong>
# send message to room group
        async_to_sync(self.channel_layer.group_send)(
            self.room_group_name,
            {
                'type': 'chat_message',
                'message': message,
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'user'</strong><strong class="hljs-slc">: self.user.username,</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'datetime'</strong><strong class="hljs-slc">: now.isoformat(),</strong>
            }
        )
    # receive message from room group
def chat_message(self, event):
        # send message to WebSocket
        self.send(text_data=json.dumps(event))
</code></pre>
<p class="normal">You now import <a id="_idIndexMarker1508"/>the <code class="inlineCode">timezone</code> module provided by Django. In the <code class="inlineCode">connect()</code> method of the consumer, you retrieve the current user from the scope with <code class="inlineCode">self.scope['user']</code> and store them in a new <code class="inlineCode">user</code> attribute of the consumer. </p>
<p class="normal">When the consumer receives a message through the WebSocket, it gets the current time using <code class="inlineCode">timezone.now()</code> and passes the current <code class="inlineCode">user</code> and <code class="inlineCode">datetime</code> in ISO 8601 format along with the message in the event sent to the channel group.</p>
<p class="normal">Edit the <code class="inlineCode">chat/room.html</code> template of the <code class="inlineCode">chat</code> application and add the following line highlighted in bold to the <code class="inlineCode">include_js</code> block:</p>
<pre class="programlisting code"><code class="hljs-code">{% block include_js %}
  {{ course.id|json_script:"course-id" }}
<strong class="hljs-slc">  {{ request.user.username|json_script:</strong><strong class="hljs-string-slc">"request-user"</strong><strong class="hljs-slc"> }}</strong>
{% endblock %}
</code></pre>
<p class="normal">Using the <code class="inlineCode">json_script</code> template, you safely print the username of the request user to use it with JavaScript.</p>
<p class="normal">In the <code class="inlineCode">domready</code> block of the <code class="inlineCode">chat/room.html</code> template, add the following lines highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">{% block domready %}
  const courseId = JSON.parse(
    document.getElementById('course-id').textContent
  );
<strong class="hljs-params-slc"> </strong><strong class="hljs-keyword-slc">const</strong><strong class="hljs-params-slc"> requestUser = </strong><strong class="hljs-title-slc">JSON</strong><strong class="hljs-params-slc">.</strong><strong class="hljs-title-slc">parse</strong><strong class="hljs-params-slc">(</strong>
<strong class="hljs-params-slc"> </strong><strong class="hljs-variable-slc">document</strong><strong class="hljs-params-slc">.</strong><strong class="hljs-title-slc">getElementById</strong><strong class="hljs-params-slc">(</strong><strong class="hljs-string-slc">'request-user'</strong><strong class="hljs-params-slc">).textContent</strong>
<strong class="hljs-params-slc">  );</strong>
  # ...
{% endblock %}
</code></pre>
<p class="normal">In the new code, you safely parse the data of the element with the ID <code class="inlineCode">request-user</code> and store it in the <code class="inlineCode">requestUser</code> constant.</p>
<p class="normal">Then, in the <code class="inlineCode">domready</code> block, find the following lines:</p>
<pre class="programlisting code"><code class="hljs-code">const data = JSON.parse(event.data);
const chat = document.getElementById('chat');
chat.innerHTML += '&lt;div class="message"&gt;' +
                  data.message + '&lt;/div&gt;';
chat.scrollTop = chat.scrollHeight;
</code></pre>
<p class="normal">Replace those lines with the following code:</p>
<pre class="programlisting code"><code class="hljs-code">const data = JSON.parse(event.data);
const chat = document.getElementById('chat');
<strong class="hljs-slc">const dateOptions = {hour: 'numeric', minute: 'numeric', hour12: true};</strong>
<strong class="hljs-slc">const datetime = new Date(data.datetime).toLocaleString('en', dateOptions);</strong>
<strong class="hljs-slc">const isMe = data.user === requestUser;</strong>
<strong class="hljs-slc">const source = isMe ? 'me' : 'other';</strong>
<strong class="hljs-slc">const name = isMe ? 'Me' : data.user;</strong>
chat.innerHTML += '&lt;div class="message <strong class="hljs-string-slc">' + source + '</strong>"&gt;' +
<strong class="hljs-slc">                  '</strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">strong</strong><strong class="hljs-tag-slc">&gt;</strong><strong class="hljs-slc">' + name + '</strong><strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">strong</strong><strong class="hljs-tag-slc">&gt;</strong><strong class="hljs-slc"> ' +</strong>
<strong class="hljs-slc">                  '</strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">span</strong><strong class="hljs-tag-slc"> </strong><strong class="hljs-attr-slc">class</strong><strong class="hljs-tag-slc">=</strong><strong class="hljs-string-slc">"date"</strong><strong class="hljs-tag-slc">&gt;</strong><strong class="hljs-slc">' + datetime + '</strong><strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">span</strong><strong class="hljs-tag-slc">&gt;&lt;</strong><strong class="hljs-name-slc">br</strong><strong class="hljs-tag-slc">&gt;</strong><strong class="hljs-slc">' +</strong>
                  data.message + '&lt;/div&gt;';
chat.scrollTop = chat.scrollHeight;
</code></pre>
<p class="normal">In this code, you<a id="_idIndexMarker1509"/> implement the following changes:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">You convert the <code class="inlineCode">datetime</code> received in the message to a JavaScript <code class="inlineCode">Date</code> object and format it with a specific locale.</li>
<li class="numberedList">You compare the username received in the message with two different constants as helpers to identify the user.</li>
<li class="numberedList">The constant <code class="inlineCode">source</code> gets the value <code class="inlineCode">me</code> if the user sending the message is the current user, or <code class="inlineCode">other</code> otherwise.</li>
<li class="numberedList">The constant <code class="inlineCode">name</code> gets the value <code class="inlineCode">Me</code> if the user sending the message is the current user or the name of the user sending the message otherwise. You use it to display the name of the user sending the message.</li>
<li class="numberedList">You use the <code class="inlineCode">source</code> value as a <code class="inlineCode">class</code> of the main <code class="inlineCode">&lt;div&gt;</code> message element to differentiate messages sent by the current user from messages sent by others. Different CSS styles are applied based on the <code class="inlineCode">class</code> attribute. These CSS styles are declared in the <code class="inlineCode">css/base.css</code> static file.</li>
<li class="numberedList">You use the username and the <code class="inlineCode">datetime</code> in the message that you append to the chat log.</li>
</ol>
<p class="normal">Open the URL <code class="inlineCode">http://127.0.0.1:8000/chat/room/1/</code> in your browser, replacing <code class="inlineCode">1</code> with the <code class="inlineCode">id</code> of an existing course in the database. With a logged-in user who is enrolled in the course, write a message and send it.</p>
<p class="normal">Then, open a second browser window in incognito mode to prevent the use of the same session. Log in with a different user, also enrolled in the same course, and send a message.</p>
<p class="normal">You will be able to<a id="_idIndexMarker1510"/> exchange messages using the two different users and see the user and time, with a clear distinction between messages sent by the user and messages sent by others. The conversation between two users should look similar to the following one:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_16_08.png"/></figure>
<p class="packt_figref">Figure 16.8: The chat room page with messages from two different user sessions</p>
<p class="normal">Great! You have built a functional real-time chat application using Channels. Next, you will learn how to improve the chat consumer by making it fully asynchronous.</p>
<h1 class="heading-1" id="_idParaDest-437">Modifying the consumer to be fully asynchronous</h1>
<p class="normal">The <code class="inlineCode">ChatConsumer</code> you have<a id="_idIndexMarker1511"/> implemented inherits from the synchronous base class <code class="inlineCode">WebsocketConsumer</code>. Synchronous consumers operate in a way that each request must be processed in sequence, one after the other. Synchronous consumers are convenient for accessing Django models and calling regular synchronous I/O functions. However, asynchronous consumers perform better because of their ability to perform non-blocking operations, moving to another task without waiting for the first operation to complete. They don’t require additional threads when handling requests, thus reducing wait times and increasing the ability to scale to more users and requests simultaneously.</p>
<p class="normal">Given that you are already using the asynchronous channel layer functions, you can seamlessly rewrite the <code class="inlineCode">ChatConsumer</code> class to make it asynchronous.</p>
<p class="normal">Edit the <code class="inlineCode">consumers.py</code> file of the <code class="inlineCode">chat</code> application and implement the following changes:</p>
<pre class="programlisting code"><code class="hljs-code">import json
<strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> channels.generic.websocket </strong><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> AsyncWebsocketConsumer</strong>
from django.utils import timezone
class ChatConsumer(<strong class="hljs-title-slc">AsyncWebsocketConsumer</strong>):
    <strong class="hljs-keyword-slc">async</strong> def connect(self):
        self.user = self.scope['user']
        self.id = self.scope['url_route']['kwargs']['course_id']
        self.room_group_name = 'chat_%s' % self.id
# join room group
<strong class="hljs-keyword-slc">await</strong><strong class="hljs-slc"> self.channel_layer.group_add(</strong>
            self.room_group_name, self.channel_name
        <strong class="hljs-slc">)</strong>
# accept connection
<strong class="hljs-keyword-slc">await</strong> self.accept()
    <strong class="hljs-keyword-slc">async</strong> def disconnect(self, close_code):
        # leave room group
<strong class="hljs-keyword-slc">await</strong><strong class="hljs-slc"> self.channel_layer.group_discard(</strong>
            self.room_group_name, self.channel_name
        <strong class="hljs-slc">)</strong>
# receive message from WebSocket
<strong class="hljs-keyword-slc">async</strong> def receive(self, text_data):
        text_data_json = json.loads(text_data)
        message = text_data_json['message']
        now = timezone.now()
        # send message to room group
<strong class="hljs-keyword-slc">await</strong><strong class="hljs-slc"> self.channel_layer.group_send(</strong>
            self.room_group_name,
            {
                'type': 'chat_message',
                'message': message,
                'user': self.user.username,
                'datetime': now.isoformat(),
            }
        <strong class="hljs-slc">)</strong>
# receive message from room group
<strong class="hljs-keyword-slc">async</strong> def chat_message(self, event):
        # send message to WebSocket
<strong class="hljs-keyword-slc">await</strong> self.send(text_data=json.dumps(event))
</code></pre>
<p class="normal">You have implemented the following changes:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">The <code class="inlineCode">ChatConsumer</code> consumer now inherits from the <code class="inlineCode">AsyncWebsocketConsumer</code> class to implement asynchronous calls.</li>
<li class="numberedList">You have changed the definition of all methods from <code class="inlineCode">def</code> to <code class="inlineCode">async def</code>.</li>
<li class="numberedList">You use <code class="inlineCode">await</code> to call asynchronous functions that perform I/O operations.</li>
<li class="numberedList">You no longer use the <code class="inlineCode">async_to_sync()</code> helper function when calling methods on the channel layer.</li>
</ol>
<p class="normal">Open the URL <code class="inlineCode">http://127.0.0.1:8000/chat/room/1/</code> with two different browser windows again and <a id="_idIndexMarker1512"/>verify that the chat server still works. The chat server is now fully asynchronous!</p>
<p class="normal">Next, we are going to implement a chat history by storing messages in the database.</p>
<h1 class="heading-1" id="_idParaDest-438">Persisting messages into the database</h1>
<p class="normal">Let’s enhance the <a id="_idIndexMarker1513"/>chat application by adding message persistence. We will develop functionality to store messages in the database, allowing us to present a chat history to users when they join a chat room. This feature is essential for real-time applications, where it’s necessary to display both current and previously generated data. For example, consider a stock trading application: upon logging in, users should see not only the current stock values but also the historical values from the time the stock market opened.</p>
<p class="normal">To implement the chat history functionality, we will follow these steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">We will create Django model to store chat messages and add it to the administration site.</li>
<li class="numberedList">We will modify the WebSocket consumer to persist messages.</li>
<li class="numberedList">We will retrieve the chat history to display the latest messages when users enter a chat room.</li>
</ol>
<p class="normal">Let’s start by creating the message model.</p>
<h2 class="heading-2" id="_idParaDest-439">Creating a model for chat messages</h2>
<p class="normal">Edit the <code class="inlineCode">models.py</code> file of the <code class="inlineCode">chat</code> application<a id="_idIndexMarker1514"/> and add the following lines highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code"><strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> django.conf </strong><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> settings</strong>
from django.db import models
<strong class="hljs-keyword-slc">class</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">Message</strong><strong class="hljs-slc">(models.Model):</strong>
<strong class="hljs-slc">    user = models.ForeignKey(</strong>
<strong class="hljs-slc">        settings.AUTH_USER_MODEL,</strong>
<strong class="hljs-slc">        on_delete=models.PROTECT,</strong>
<strong class="hljs-slc">        related_name=</strong><strong class="hljs-string-slc">'chat_messages'</strong>
<strong class="hljs-slc">    )</strong>
<strong class="hljs-slc">    course = models.ForeignKey(</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'courses.Course'</strong><strong class="hljs-slc">,</strong>
<strong class="hljs-slc">        on_delete=models.PROTECT,</strong>
<strong class="hljs-slc">        related_name=</strong><strong class="hljs-string-slc">'chat_messages'</strong>
<strong class="hljs-slc">    )</strong>
<strong class="hljs-slc">    content = models.TextField()</strong>
<strong class="hljs-slc">    sent_on = models.DateTimeField(auto_now_add=</strong><strong class="hljs-literal-slc">True</strong><strong class="hljs-slc">)</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">def</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">__str__</strong><strong class="hljs-slc">(</strong><strong class="hljs-params-slc">self</strong><strong class="hljs-slc">):</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">f'</strong><strong class="hljs-subst-slc">{self.user}</strong><strong class="hljs-string-slc"> on </strong><strong class="hljs-subst-slc">{self.course}</strong><strong class="hljs-string-slc"> at </strong><strong class="hljs-subst-slc">{self.sent_on}</strong><strong class="hljs-string-slc">'</strong>
</code></pre>
<p class="normal">This is the data model to<a id="_idIndexMarker1515"/> persist chat messages. Let’s take a look at the fields of the <code class="inlineCode">Message</code> model:</p>
<ul>
<li class="bulletList"><code class="inlineCode">user</code>: The <code class="inlineCode">User</code> object that wrote the message. This is a foreign key field because it specifies a many-to-one relationship: a user can send multiple messages, but each message is sent by a single user. By using <code class="inlineCode">PROTECT</code> for the <code class="inlineCode">on_delete</code> parameter, a <code class="inlineCode">User</code> object cannot be deleted if related messages exist.</li>
<li class="bulletList"><code class="inlineCode">course</code>: A relationship with the <code class="inlineCode">Course</code> object. Each message belongs to the chat room of a course. By using <code class="inlineCode">PROTECT</code> for the <code class="inlineCode">on_delete</code> parameter, a <code class="inlineCode">Course</code> object cannot be deleted if related messages exist.</li>
<li class="bulletList"><code class="inlineCode">content</code>: A <code class="inlineCode">TextField</code> to store the content of the message.</li>
<li class="bulletList"><code class="inlineCode">sent_on</code>: A <code class="inlineCode">DateTimeField</code> to store the date and time when the message object is saved the first time.</li>
</ul>
<p class="normal">Run the following command in the shell prompt to generate the database migrations for the <code class="inlineCode">chat</code> application:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py makemigrations chat
</code></pre>
<p class="normal">You should get the following output:</p>
<pre class="programlisting con"><code class="hljs-con">Migrations for 'chat':
    chat/migrations/0001_initial.py
        - Create model Message
</code></pre>
<p class="normal">Apply the newly created migration to your database with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py migrate
</code></pre>
<p class="normal">You will get an output that ends with the following line:</p>
<pre class="programlisting con"><code class="hljs-con">Applying chat.0001_initial... OK
</code></pre>
<p class="normal">The database is now in sync with the new model. Let’s add the <code class="inlineCode">Message</code> model to the administration site.</p>
<h2 class="heading-2" id="_idParaDest-440">Adding the message model to the administration site</h2>
<p class="normal">Edit the <code class="inlineCode">admin.py</code> file of the <code class="inlineCode">chat</code> application and <a id="_idIndexMarker1516"/>register the <code class="inlineCode">Message</code> model into the administration site, as follows. The new code is highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">from django.contrib import admin
<strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> chat.models </strong><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> Message</strong>
<strong class="hljs-meta-slc">@admin.register(</strong><strong class="hljs-params-slc">Message</strong><strong class="hljs-meta-slc">)</strong>
<strong class="hljs-keyword-slc">class</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">MessageAdmin</strong><strong class="hljs-slc">(admin.ModelAdmin):</strong>
<strong class="hljs-slc">list_display = [</strong><strong class="hljs-string-slc">'sent_on'</strong><strong class="hljs-slc">, </strong><strong class="hljs-string-slc">'user'</strong><strong class="hljs-slc">, </strong><strong class="hljs-string-slc">'course'</strong><strong class="hljs-slc">, </strong><strong class="hljs-string-slc">'content'</strong><strong class="hljs-slc">]</strong>
<strong class="hljs-slc">list_filter = [</strong><strong class="hljs-string-slc">'sent_on'</strong><strong class="hljs-slc">, </strong><strong class="hljs-string-slc">'course'</strong><strong class="hljs-slc">]</strong>
<strong class="hljs-slc">search_fields = [</strong><strong class="hljs-string-slc">'content'</strong><strong class="hljs-slc">]</strong>
<strong class="hljs-slc">raw_id_fields = [</strong><strong class="hljs-string-slc">'user'</strong><strong class="hljs-slc">, </strong><strong class="hljs-string-slc">'content'</strong><strong class="hljs-slc">]</strong>
</code></pre>
<p class="normal">Run the development server and open <code class="inlineCode">http://127.0.0.1:8000/admin/</code> in your browser. You should see the <strong class="screenText">CHAT</strong> block and the <strong class="screenText">Messages</strong> section on the administration site:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_16_09.png"/></figure>
<p class="packt_figref">Figure 16.9: The Chat application and Messages section on the administration site</p>
<p class="normal">We will continue by saving messages to the database when they are sent by users.</p>
<h2 class="heading-2" id="_idParaDest-441">Storing messages in the database</h2>
<p class="normal">We will modify the <a id="_idIndexMarker1517"/>WebSocket consumer to persist each message that is received through the WebSocket. Edit the <code class="inlineCode">consumers.py</code> file of the <code class="inlineCode">chat</code> application, and add the following code highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">import json
from channels.generic.websocket import AsyncWebsocketConsumer
from django.utils import timezone
<strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> chat.models </strong><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> Message</strong>
class ChatConsumer(AsyncWebsocketConsumer):
    # ...
<strong class="hljs-keyword-slc">    async</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">def</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">persist_message</strong><strong class="hljs-slc">(</strong><strong class="hljs-params-slc">self, message</strong><strong class="hljs-slc">):</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-slc"> </strong><strong class="hljs-comment-slc"># send message to WebSocket</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">await</strong><strong class="hljs-slc"> Message.objects.acreate(</strong>
<strong class="hljs-slc">            user=self.user, course_id=self.id, content=message</strong>
<strong class="hljs-slc">        )</strong>
# receive message from WebSocket
async def receive(self, text_data):
        text_data_json = json.loads(text_data)
        message = text_data_json['message']
        now = timezone.now()
        # send message to room group
await self.channel_layer.group_send(
            self.room_group_name,
            {
                'type': 'chat_message',
                'message': message,
                'user': self.user.username,
                'datetime': now.isoformat(),
 },
 )
<strong class="hljs-string-slc"> </strong><strong class="hljs-comment-slc"># persist message</strong>
<strong class="hljs-string-slc"> </strong><strong class="hljs-keyword-slc">await</strong><strong class="hljs-slc"> self.persist_message(message)</strong>
    # ...
</code></pre>
<p class="normal">In this code, we add <a id="_idIndexMarker1518"/>the asynchronous <code class="inlineCode">persist_message()</code> method to the <code class="inlineCode">ChatConsumer</code> class. This method takes a <code class="inlineCode">message</code> parameter and creates a <code class="inlineCode">Message</code> object in the database with the given message, the related authenticated <code class="inlineCode">user</code>, and the <code class="inlineCode">id</code> of the <code class="inlineCode">Course</code> object that the group chat room belongs to. Since the is <code class="inlineCode">ChatConsumer</code> is fully asynchronous, we use the <code class="inlineCode">acreate()</code> QuerySet method, which is the asynchronous version of <code class="inlineCode">create()</code>. You can read more about how to write asynchronous queries with the Django ORM at <a href="https://docs.djangoproject.com/en/5.0/topics/db/queries/#asynchronous-queries">https://docs.djangoproject.com/en/5.0/topics/db/queries/#asynchronous-queries</a>.</p>
<p class="normal">We call the <code class="inlineCode">persist_message()</code> method asynchronously in the <code class="inlineCode">receive()</code> method that is executed when a message is received by the consumer through the WebSocket.</p>
<p class="normal">Run the development server and open <code class="inlineCode">http://127.0.0.1:8000/chat/room/1/</code> in your browser, replacing <code class="inlineCode">1</code> with the <code class="inlineCode">id</code> of an existing course in the database. With a logged-in user who is enrolled in the course, write a message and send it.</p>
<p class="normal">Then, open a second browser window in incognito mode to prevent the use of the same session. Log in with a different user, also enrolled in the same course, and send a few messages as well.</p>
<p class="normal"><em class="italic">Figure 16.10</em> shows an<a id="_idIndexMarker1519"/> example of messages sent by two different users:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_16_10.png"/></figure>
<p class="packt_figref">Figure 16.10: Chat room example with messages sent by two different users</p>
<p class="normal">Open <code class="inlineCode">http://127.0.0.1:8000/admin/chat/message/</code> in your browser. The messages sent should appear on the administration site, as in <em class="italic">Figure 16.11</em>:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_16_11.png"/></figure>
<p class="packt_figref">Figure 16.11: Admin list display view of messages stored in the database</p>
<p class="normal">All messages are now persisted in the database.</p>
<p class="normal">Note that messages<a id="_idIndexMarker1520"/> could contain malicious code, for example, JavaScript fragments. We do not mark the messages as safe in our template, providing an initial layer of protection against malicious content. However, to further enhance security, consider sanitizing the messages before storing them in the database. A reliable option for sanitizing content is the <code class="inlineCode">nh3</code> package. You can read more<a id="_idIndexMarker1521"/> about <code class="inlineCode">nh3</code> at <a href="https://nh3.readthedocs.io/en/latest/">https://nh3.readthedocs.io/en/latest/</a>. Additionally, <code class="inlineCode">django-nh3</code> is a Django integration available that offers custom <code class="inlineCode">nh3</code> model fields and form <a id="_idIndexMarker1522"/>fields. More information is available at <a href="https://github.com/marksweb/django-nh3">https://github.com/marksweb/django-nh3</a>.</p>
<p class="normal">Now that you are storing the complete chat history in your database, let’s learn how to present the latest messages in the chat history to users when they join a chat room.</p>
<h2 class="heading-2" id="_idParaDest-442">Displaying the chat history</h2>
<p class="normal">When users join a course <a id="_idIndexMarker1523"/>chat room, we will display the latest five messages of the chat history. This will ensure that users gain immediate context for ongoing conversations.</p>
<p class="normal">Edit the <code class="inlineCode">views.py</code> file of the <code class="inlineCode">chat</code> application and add the following code highlighted in bold to the <code class="inlineCode">course_chat_room</code> view:</p>
<pre class="programlisting code"><code class="hljs-code">@login_required
def course_chat_room(request, course_id):
    try:
        # retrieve course with given id joined by the current user
        course = request.user.courses_joined.get(id=course_id)
    except Course.DoesNotExist:
        # user is not a student of the course or course does not exist
return HttpResponseForbidden()
<strong class="hljs-slc"> </strong><strong class="hljs-comment-slc"># retrieve chat history</strong>
<strong class="hljs-slc">    latest_messages = course.chat_messages.select_related(</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'user'</strong>
<strong class="hljs-string-slc"> </strong><strong class="hljs-slc">).order_by(</strong><strong class="hljs-string-slc">'-id'</strong><strong class="hljs-slc">)[:</strong><strong class="hljs-number-slc">5</strong><strong class="hljs-slc">]</strong>
<strong class="hljs-slc">    latest_messages = </strong><strong class="hljs-built_in-slc">reversed</strong><strong class="hljs-slc">(latest_messages)</strong>
return render(
        request,
        'chat/room.html',
        {'course': course<strong class="hljs-slc">, </strong><strong class="hljs-string-slc">'latest_messages'</strong><strong class="hljs-slc">: latest_messages</strong>}
    )
</code></pre>
<p class="normal">We retrieve the chat <a id="_idIndexMarker1524"/>messages related to the course and use <code class="inlineCode">select_related()</code> to fetch the related user in the same query. This will prevent the generation of additional SQL queries when accessing the username to display it alongside each message. Django’s ORM doesn’t support negative indexing, so we retrieve the first five messages in reverse chronological order, and we utilize the <code class="inlineCode">reversed()</code> function to reorder them back into chronological sequence.</p>
<p class="normal">Now, we will add the chat history to the chat room template. Edit the <code class="inlineCode">chat/room.html</code> template and add the following lines highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code"># ...
{% block content %}
  &lt;div id="chat"&gt;
<strong class="hljs-slc">    {% for message in latest_messages %}</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">div</strong><strong class="hljs-tag-slc"> </strong><strong class="hljs-attr-slc">class</strong><strong class="hljs-tag-slc">=</strong><strong class="hljs-string-slc">"</strong><strong class="hljs-string-slc">message {% if message.user == request.user %}me{% else %}other{% endif %}"</strong><strong class="hljs-tag-slc">&gt;</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">strong</strong><strong class="hljs-tag-slc">&gt;</strong><strong class="hljs-slc">{{ message.user.username }}</strong><strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">strong</strong><strong class="hljs-tag-slc">&gt;</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">span</strong><strong class="hljs-tag-slc"> </strong><strong class="hljs-attr-slc">class</strong><strong class="hljs-tag-slc">=</strong><strong class="hljs-string-slc">"date"</strong><strong class="hljs-tag-slc">&gt;</strong>
<strong class="hljs-slc">          {{ message.sent_on|date:"Y.m.d H:i A" }}</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">span</strong><strong class="hljs-tag-slc">&gt;</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">br</strong><strong class="hljs-tag-slc">&gt;</strong>
<strong class="hljs-slc">        {{ message.content }}</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">div</strong><strong class="hljs-tag-slc">&gt;</strong>
<strong class="hljs-slc">    {% endfor %}</strong>
&lt;/div&gt;
&lt;div id="chat-input"&gt;
&lt;input id="chat-message-input" type="text"&gt;
&lt;input id="chat-message-submit" type="submit" value="Send"&gt;
&lt;/div&gt;
{% endblock %}
# ...
</code></pre>
<p class="normal">Open <code class="inlineCode">http://127.0.0.1:8000/chat/room/1/</code> in your browser, replacing <code class="inlineCode">1</code> with the <code class="inlineCode">id</code> of an existing course in the database. You<a id="_idIndexMarker1525"/> should now see the latest messages, as shown in <em class="italic">Figure 16.12</em>:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_16_12.png"/></figure>
<p class="packt_figref">Figure 16.12: Chat room initially displaying the latest messages</p>
<p class="normal">Users can now see the <a id="_idIndexMarker1526"/>latest messages in the chat history upon joining a chat room. Next, we are going to add a link to the menu so that users can enter the course chat room.</p>
<h1 class="heading-1" id="_idParaDest-443">Integrating the chat application with existing views</h1>
<p class="normal">The chat server<a id="_idIndexMarker1527"/> is now fully implemented, and students enrolled in a course can communicate with each other. Let’s add a link for students to join the chat room for each course.</p>
<p class="normal">Edit the <code class="inlineCode">students/course/detail.html</code> template of the <code class="inlineCode">students</code> application and add the following <code class="inlineCode">&lt;h3&gt;</code> HTML element code at the bottom of the <code class="inlineCode">&lt;div class="contents"&gt;</code> element:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;div class="contents"&gt;
  ...
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">h3</strong><strong class="hljs-tag-slc">&gt;</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">a</strong><strong class="hljs-tag-slc"> </strong><strong class="hljs-attr-slc">href</strong><strong class="hljs-tag-slc">=</strong><strong class="hljs-string-slc">"{% url "</strong><strong class="hljs-attr-slc">chat:course_chat_room</strong><strong class="hljs-tag-slc">" </strong><strong class="hljs-attr-slc">object.id</strong><strong class="hljs-tag-slc"> %}"&gt;</strong>
<strong class="hljs-slc">      Course chat room</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">a</strong><strong class="hljs-tag-slc">&gt;</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">h3</strong><strong class="hljs-tag-slc">&gt;</strong>
&lt;/div&gt;
</code></pre>
<p class="normal">Open the browser and access any course that the student is enrolled in to view the course contents. The sidebar will now contain a <strong class="screenText">Course chat room</strong> link that points to the course chat room view. If you click on it, you will enter the chat room:</p>
<figure class="mediaobject"><img alt="Graphical user interface, application  Description automatically generated" src="img/B21088_16_13.png"/></figure>
<p class="packt_figref">Figure 16.13: The course detail page, including a link to the course chat room</p>
<p class="normal">Congratulations! You <a id="_idIndexMarker1528"/>successfully built your first asynchronous application using Django Channels.</p>
<h1 class="heading-1" id="_idParaDest-444">Summary</h1>
<p class="normal">In this chapter, you learned how to create a chat server using Channels. You implemented both a WebSocket consumer and a client. By enabling communication through a channel layer with Redis and modifying the consumer to be fully asynchronous, you improved the responsiveness and scalability of your application. Additionally, you implemented chat message persistence, providing a robust and user-friendly experience and maintaining chat history for users over time. The skills you learned in this chapter will help you in any future implementations of asynchronous real-time functionalities.</p>
<p class="normal">The next chapter will teach you how to build a production environment for your Django project using NGINX, uWSGI, and Daphne with Docker Compose. You will also learn how to implement custom middleware for request/response processing across your entire application, and how to develop custom management commands, which enable you to automate tasks and execute them via the command line.</p>
<h1 class="heading-1" id="_idParaDest-445">Additional resources</h1>
<p class="normal">The following resources provide additional information related to the topics covered in this chapter:</p>
<ul>
<li class="bulletList">Source code for this chapter: <a href="https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter16">https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter16</a></li>
<li class="bulletList">Introduction to ASGI: <a href="https://asgi.readthedocs.io/en/latest/introduction.html">https://asgi.readthedocs.io/en/latest/introduction.html</a></li>
<li class="bulletList">Django support for asynchronous views: <a href="https://docs.djangoproject.com/en/5.0/topics/async/">https://docs.djangoproject.com/en/5.0/topics/async/</a></li>
<li class="bulletList">Django support for asynchronous class-based views: <a href="https://docs.djangoproject.com/en/5.0/topics/class-based-views/#async-class-based-views">https://docs.djangoproject.com/en/5.0/topics/class-based-views/#async-class-based-views</a></li>
<li class="bulletList">Daphne ASGI server: <a href="https://github.com/django/daphne">https://github.com/django/daphne</a></li>
<li class="bulletList">Django Channels documentation: <a href="https://channels.readthedocs.io/">https://channels.readthedocs.io/</a></li>
<li class="bulletList">Deploying Django with ASGI: <a href="https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/">https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/</a></li>
<li class="bulletList">Introduction to WebSockets: <a href="https://en.wikipedia.org/wiki/WebSocket">https://en.wikipedia.org/wiki/WebSocket</a>.</li>
<li class="bulletList"><code class="inlineCode">json_script</code> template filter usage: <a href="https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#json-script">https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#json-script</a></li>
<li class="bulletList">Django ORM asynchronous queries: <a href="https://docs.djangoproject.com/en/5.0/topics/db/queries/#asynchronous-queries">https://docs.djangoproject.com/en/5.0/topics/db/queries/#asynchronous-queries</a></li>
<li class="bulletList"><code class="inlineCode">nh3</code> documentation: <a href="https://nh3.readthedocs.io/en/latest/">https://nh3.readthedocs.io/en/latest/</a></li>
<li class="bulletList"><code class="inlineCode">django-nh3</code> project: <a href="https://github.com/marksweb/django-nh3">https://github.com/marksweb/django-nh3</a></li>
</ul>
</div>
</body></html>