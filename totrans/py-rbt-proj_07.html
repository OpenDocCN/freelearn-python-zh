<html><head></head><body><div><h1 class="header-title">Sensor Interface for Obstacle Avoidance</h1>
                
            
            
                
<p>To make a robotic vehicle that drives itself, we need to first understand how humans drive a vehicle. When we drive a car, we constantly analyze the space and the distance to other objects. Thereafter, we make a decision if we can go through it or not. This happens constantly with our brain – eye coordination. Similarly, a robot would have to do the same sort of thing. </p>
<p>In our previous chapters, you learned that we can find the proximity of objects around us, using sensors. These sensors can tell us how far an object is, and based on it, we can make decisions. We have done using an ultrasonic sensor primarily because it is extremely cheap. However, as you remember, it was slightly cumbersome to attach ultrasonic sensors and to run its code. It's time that we take a much simpler sensor and attach it to the car. </p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>Infrared proximity sensor</li>
<li>Autonomous emergency braking</li>
<li>Giving it self-steering capabilities</li>
<li>Making it fully autonomous</li>
</ul>


            

            
        
    </div>
<div><h1 class="header-title">Infrared proximity sensor</h1>
                
            
            
                
<p>The following photo depicts an infrared proximity sensor:</p>
<div><img src="img/90715732-5355-4e01-a251-4f1ec0d14a91.jpg" style="width:51.33em;height:31.25em;"/></div>
<p>It consists of two major parts—the sensor and the transmitter. The transmitter emits IR waves; these <strong>Infrared</strong> (<strong>IR</strong>) waves then hit the object and come back to the sensor, as depicted in the following diagram.. </p>
<div><img src="img/6f685d5a-3977-4660-8fbb-27bfc4af7025.png" style="width:25.92em;height:52.58em;"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">Now, as you can see in the preceding diagram, the emitted IR waves bounces back from a surface at a different distance from the sensor, then they makes an angular approach to the sensor. Now, because the distance between the transmitter and the sensor is fixed at all points of time, the angle corresponding to reflected IR waves would be proportional to the distance it has traveled before bouncing off. There are ultraprecise sensors in the IR proximity sensors that are capable of sensing the angle at which the IR waves approach it. By this angle, it gives the user a value of distance corresponding to it. This method of finding distance is named <strong>triangulation</strong>, and it has been used widely in the industry. One more thing we need to keep in mind is that we are all surrounded by IR radiation as we mentioned earlier in the chapters; any object above absolute zero temperature would have corresponding waves emitted to it. Also, the sunlight around us is having ample amount of IR radiations. Hence, these sensors have a built-in circuitry to compensate for it; however, there is only so much it can do. That's why, this solution might have some trouble when dealing with direct sunlight.</p>
<p class="mce-root CDPAlignLeft CDPAlign">Now, enough of the theory, let's see how the car actually works. The IR proximity sensor we are using in this example is an analog sensor by Sharp with part code GP2D12. It has an effective sensing range of 1000-800 mm. The range is also dependent on the reflectivity of the surface of the object in question. The darker the object, the shorter the range. This sensor has three pins. As you might have guessed, there is one for VCC, another for ground, and the last for the signal. This is an analog sensor; hence, the distance reading would be given based on the voltage. Generally with most analog sensors you would get a graph which will depict the various voltages at various sensing ranges. The output is basically depending on the internal hardware of the sensor and its construction so it can be vastly different. Below is a graph for our sensor and its output :</p>
<div><img src="img/835cb4ca-1319-448a-bb5e-3b468215c639.png" style="width:40.67em;height:53.00em;"/></div>
<p>Okay then, so far so good. As we know that Raspberry Pi does not accept analog input; hence, we will go ahead and use what we have used earlier as well, an ADC. We will be using the same ADC we have used before.</p>


            

            
        
    </div>
<div><h1 class="header-title">Autonomous emergency braking</h1>
                
            
            
                
<p>There is a new technology that newer cars are equipped with. It's called <strong>autonomous emergency braking</strong>; no matter how serious we are while driving, we do get distractions, such as Facebook or WhatsApp notifications, which tempt us to look away from the road onto the screen of our phones. This can be a leading cause of road accidents; hence, car manufacturers are using autonomous braking technology. This generally relies on long range and short range radars and it detects the proximity of other objects around the car, and in the case of an eminent collision, it applies the brakes to the car autonomously preventing them from colliding from other cars or pedestrians. This is a really cool technology, but what's interesting is that we would be making it today with our own bare hands.</p>
<p>To make this, we will be using the IR proximity sensor to sense the proximity of objects around it. Now go ahead, grab a double-sided tape, and attach the IR distance sensor at the front of the car. Once this is done, connect the circuit as shown here:</p>
<div><img src="img/00dcfdd2-4c3c-405d-b24c-2d7484490ade.png"/></div>
<p>All right then, we are all set up to code it up. The following is the code, and just copy it into your Pi:</p>
<div><pre>import RPi.GPIO as GPIO<br/>import time<br/>GPIO.setmode(GPIO.BCM)<br/><br/>import Adafruit_ADS1x15<br/>adc0 = Adafruit_ADS1x15.ADS1115()<br/><br/>GAIN = 1<br/><br/>adc0.start_adc(0, gain=GAIN)<br/><br/>Motor1a = 20<br/>Motor1b = 21<br/>Motor2b = 23<br/>Motor2a = 24<br/><br/>GPIO.setup(Motor1a,GPIO.OUT)<br/>GPIO.setup(Motor1b,GPIO.OUT)<br/>GPIO.setup(Motor2a,GPIO.OUT)<br/>GPIO.setup(Motor2b,GPIO.OUT)<br/><br/>def forward():<br/>        GPIO.output(Motor1a,0)<br/>        GPIO.output(Motor1b,1)<br/>        GPIO.output(Motor2a,0)<br/>        GPIO.output(Motor2b,1)<br/><br/>def stop():<br/>        GPIO.output(Motor1a,0)<br/>        GPIO.output(Motor1b,0)<br/>        GPIO.output(Motor2a,0)<br/>        GPIO.output(Motor2b,0)<br/><br/>while True:<br/>   F_value = adc0.get_last_result()<br/>   F =    (1.0 / (F_value / 13.15)) - 0.35<br/>   forward()<br/> <br/>    min_dist = 20    <br/>    if F &lt; min_dist:<br/>        stop()<br/></pre></div>
<p>Now, let's see what's actually happening in this code. Everything is very much elementary; the IR proximity sensor is sensing the proximity of objects in front of it and gives the corresponding distance value in the form of analog signals. These signals are then taken by the ADC, and they are converted into digital values. These digital values are finally transferred to Raspberry Pi via the I2C protocol.</p>
<p>So far, so good. But you must be wondering what this line is doing?</p>
<pre>   F =    (1.0 / (F_value / 13.15)) - 0.35</pre>
<p>There is not much we are doing here, we are simply taking the digital values given by ADC, and using this formula, we are covering that digital value to understandable distance values in the unit of centimeters. This calculation is provided by the manufacturer, and we really don't have to get our head into this. Most of the sensors have these calculations provided. However, if you want to go and understand how and why we are using this formula, then I would recommend you go through the data sheet of the sensor. The data sheet is available easily online on the following link: <a href="https://engineering.purdue.edu/ME588/SpecSheets/sharp_gp2d12.pdf">https://engineering.purdue.edu/ME588/SpecSheets/sharp_gp2d12.pdf</a>.</p>
<p>Moving on, the main part of the code is as follows:</p>
<pre>min_dist = 20<br/>If F &lt; min_dist:<br/>    stop()</pre>
<p>It is again very simple. We have entered a distance value, which in this program, we have set to <kbd>20</kbd>. So, whenever the value of <kbd>F</kbd>  (the distance accrued by IR proximity sensor) is smaller than <kbd>20</kbd>, then a <kbd>stop()</kbd> function is called. The <kbd>stop</kbd> function simply stalls the car and stops it from colliding with anything. </p>
<p>Let's upload the code and see if it actually works! Make sure that you run this car indoors; otherwise, you would have a tough time trying to stop this car if it does not get any obstacles. Have fun! </p>


            

            
        
    </div>
<div><h1 class="header-title">Giving the car self-steering capabilities</h1>
                
            
            
                
<p>I hope that you are having fun with this little zippy thing. It is interesting how simple the application of sensors can be and how much difference it can make. As you have learned the basics, it's now time to move ahead and give the car some more powers.</p>
<p>In the previous code, we just made the robot stop in front of the obstacles, why don't we make it steer around the car? It's going to be super simple yet super fun. All we need to do is to tweak the function <kbd>stop()</kbd> and make it able to turn. Obviously, we will also change the name of the function from <kbd>stop()</kbd> to <kbd>turn()</kbd> just for the sake of clarity. One thing to remember that you won't have to rewrite the code; all we need to do is some minor tweaking. So, let's see the code and then I will tell you what exactly has changed and why: </p>
<div><pre>import RPi.GPIO as GPIO<br/>import time<br/>GPIO.setmode(GPIO.BCM)<br/><br/>import Adafruit_ADS1x15<br/>adc0 = Adafruit_ADS1x15.ADS1115()<br/><br/>GAIN = 1<br/><br/>adc0.start_adc(0, gain=GAIN)<br/><br/>Motor1a = 20<br/>Motor1b = 21<br/>Motor2a = 23<br/>Motor2b = 24<br/><br/>GPIO.setup(Motor1a,GPIO.OUT)<br/>GPIO.setup(Motor1b,GPIO.OUT)<br/>GPIO.setup(Motor2a,GPIO.OUT)<br/>GPIO.setup(Motor2b,GPIO.OUT)<br/><br/>def forward():<br/>        GPIO.output(Motor1a,0)<br/>        GPIO.output(Motor1b,1)<br/>        GPIO.output(Motor2a,0)<br/>        GPIO.output(Motor2b,1)<br/><br/>def turn():<br/>        GPIO.output(Motor1a,0)<br/>        GPIO.output(Motor1b,1)<br/>        GPIO.output(Motor2a,1)<br/>        GPIO.output(Motor2b,0)<br/>)<br/><br/>while True:<br/>   forward()<br/><br/>   F_value = adc0.get_last_result()<br/>   F =    (1.0 / (F_value / 13.15)) - 0.35<br/> <br/>    min_dist = 20<br/><br/>    while F &lt; min_dist:<br/>        turn()   <br/></pre></div>
<p>As you would have noted, everything remains pretty much the same except for the following:</p>
<pre>def turn():<br/>        GPIO.output(Motor1a,0)<br/>        GPIO.output(Motor1b,1)<br/>        GPIO.output(Motor2a,1)<br/>        GPIO.output(Motor2b,0)</pre>
<p>This part of the code is defining the <kbd>turn()</kbd> function in which the opposite side wheels of the vehicles would be spinning in the opposite direction; hence, making the car turn on its own axis:</p>
<pre>    min_dist = 20<br/><br/>    while F &lt; min_dist:<br/>        turn()</pre>
<p>Now this is the main part of the program; in this part, we are defining what the car would do if it encounters any sort of obstacle in front of it. In our previous programs, we were primarily just telling the robot to stop as soon as it encounters any obstacle; however, now we are chaining the <kbd>stop</kbd> function with a <kbd>turn</kbd> function, which we have defined previously in the program. </p>
<p>We simply put in a condition as follows:</p>
<pre>min_dist = 20<br/>If F &lt; min_dist:<br/>    turn()</pre>
<p>Then, it would turn just for a fraction of seconds, as the microcontroller would parse through the code and execute it and get out of the condition. To do this, our Raspberry Pi would hardly take a couple of microseconds. So, we might not even able to see what has happened. Hence, in our program, we have used a <kbd>while</kbd> loop. This essentially keeps the loops running till the time condition is fulfilled. Our condition is <kbd>while F &lt; min_dist:</kbd>, so till the time the robot is detecting an object in front of it, it will keep executing the function inside it, which in our case is, the <kbd>turn()</kbd> function. So in simple words, till the time it has not turned enough to avoid the obstacle, the vehicle would keep turning and then once the loop is executed, it will again jump back to the main program and keep going straight. </p>
<p>Simple isn't it? That's the beauty about programming!</p>


            

            
        
    </div>
<div><h1 class="header-title">Making it fully autonomous</h1>
                
            
            
                
<p>Now, you must have understood the basics of autonomous driving using a simple proximity sensor. Now is the time when we make it fully autonomous. To make it fully autonomous, we must understand and map our surroundings rather than to just turn the vehicle till the time it encounters an obstacle. We basically need to divide this whole activity in the following two basic parts:</p>
<ul>
<li>Scanning the environment</li>
<li>Deciding what to do with the perceived data</li>
</ul>
<p>Now, let's first write the code and then see what we need to do: </p>
<pre>import RPi.GPIO as GPIO<br/>import time<br/><br/>GPIO.setmode(GPIO.BCM)<br/><br/>import Adafruit_ADS1x15<br/>adc0 = Adafruit_ADS1x15.ADS1115()<br/><br/>GAIN = 1<br/>adc0.start_adc(0, gain=GAIN)<br/><br/>Motor1a = 20<br/>Motor1b = 21<br/>Motor2a = 23<br/>Motor2b = 24<br/><br/>GPIO.setup(Motor1a,GPIO.OUT)<br/>GPIO.setup(Motor1b,GPIO.OUT)<br/>GPIO.setup(Motor2a,GPIO.OUT)<br/>GPIO.setup(Motor2b,GPIO.OUT)<br/><br/>def forward():<br/>        GPIO.output(Motor1a,0)<br/>        GPIO.output(Motor1b,1)<br/>        GPIO.output(Motor2a,0)<br/>        GPIO.output(Motor2b,1)<br/><br/>def right():<br/>        GPIO.output(Motor1a,0)<br/>        GPIO.output(Motor1b,1)<br/>        GPIO.output(Motor2a,1)<br/>        GPIO.output(Motor2b,0)<br/><br/>def left():<br/>        GPIO.output(Motor1a,1)<br/>        GPIO.output(Motor1b,0)<br/>        GPIO.output(Motor2a,0)<br/>        GPIO.output(Motor2b,1)<br/><br/>def stop():<br/>        GPIO.output(Motor1a,0)<br/>        GPIO.output(Motor1b,0)<br/>        GPIO.output(Motor2a,0)<br/>        GPIO.output(Motor2b,0)<br/><br/>while True:<br/><br/>   forward()<br/><br/>   F_value = adc0.get_last_result()<br/>   F =   (1.0 / (F_value / 13.15)) - 0.35<br/><br/>   min_dist = 20<br/>   if F&lt; min_dist:<br/><br/>        stop()<br/><br/>    right()<br/>    time.sleep(1)<br/><br/>    F_value = adc0.get_last_result()<br/>    F =    (1.0 / (F_value / 13.15)) - 0.35<br/>    R = F<br/><br/>    left()<br/>    time.sleep(2)<br/><br/>    F_value = adc0.get_last_result()<br/>    F =    (1.0 / (F_value / 13.15)) - 0.3<br/><br/>    L = F<br/><br/>    if L &lt; R:<br/>        right()<br/>        time.sleep(2)<br/><br/>    else:<br/>        forward()<br/></pre>
<p>Now most of the program is just like all of our previous programs; in this program, we have defined the following functions: </p>
<ul>
<li><kbd>forward()</kbd></li>
<li><kbd>right()</kbd></li>
<li><kbd>left()</kbd></li>
<li><kbd>stop()</kbd></li>
</ul>
<p>There is not much I need to tell you about defining the functions, so let's move ahead and see what else do we have in stock for us.</p>
<p>The main action is going on in our infinite loop <kbd>while True:</kbd>. Let's see what exactly is happening:</p>
<pre>while True:<br/><br/>   forward()<br/><br/>   F_value = adc0.get_last_result()<br/>   F =   (1.0 / (F_value / 13.15)) - 0.35<br/><br/>   min_dist = 20<br/>   if F&lt; min_dist:<br/><br/>        stop()</pre>
<p class="mce-root">Let's see what this part of code is doing:</p>
<ul>
<li class="mce-root">The first thing that is executed as soon as our program enters the infinite loop is the <kbd>forward()</kbd> function; that is, as soon as the infinite loop is executed, the vehicle will start to go forward</li>
<li class="mce-root">Thereafter, <kbd>F_value = adc.get_last_result()</kbd> is taking the reading from ADC and storing it in a variable named <kbd>F_value</kbd> </li>
<li><kbd>F = (1.0/(F-value/13.15))-0.35</kbd> is calculating the distance into understandable metric distance value</li>
<li><kbd>min_dist = 20</kbd> , we have simply defined the minimum distance that we will be using later</li>
</ul>
<p>Once this part of code is done, then the <kbd>if</kbd> statement will check whether <kbd>F &lt; min_dist:</kbd>. If it is so, then the code that is under the <kbd>if</kbd> statement will start to execute. The first line of this will be the <kbd>stop()</kbd> function. So whenever the vehicle encounters any obstacle in front of it, the first thing it will do is stop. </p>
<p>Now, as I mentioned, the first part of our code is to understand the environment, so let's go ahead and see how we do it :</p>
<pre>right()<br/>    time.sleep(1)<br/><br/>    F_value = adc0.get_last_result()<br/>    F =    (1.0 / (F_value / 13.15)) - 0.35<br/>    R = F<br/><br/>    left()<br/>    time.sleep(2)<br/><br/>    F_value = adc0.get_last_result()<br/>    F =    (1.0 / (F_value / 13.15)) - 0.35<br/><br/>    L = F<br/></pre>
<p class="mce-root">After the vehicle has stopped, it will immediately turn right. As you can see, the next line of code is <kbd>time.sleep(1)</kbd>, so for another <kbd>1</kbd> second, the vehicle will keep turning right. We have randomly picked a time of <kbd>1</kbd> second, you can tweak it later. </p>
<p class="mce-root">Once it has turned right, it will again take the reading from the proximity sensor, and in using this code <kbd>R=F</kbd>, we are storing that value in a variable named <kbd>R</kbd>.</p>
<p class="mce-root">After it has done that, the car will turn to the other side, that is, toward left side using the <kbd>left()</kbd> function, and it will keep turning left for <kbd>2</kbd> seconds as we have <kbd>time.sleep(2)</kbd>. This will turn the car toward left of the obstacle. Once it has turned left, it will again take in the value of proximity sensor and store the value in a variable <kbd>L</kbd> using the code <kbd>L = F</kbd>.</p>
<p>So essentially what we have done is that we have scanned the areas around us. In the center, we have an obstacle. It will first turn right and take the distance value of the right side; thereafter, we will turn left and take the distance value of the left side. So we essentially know the environment around the obstacle. </p>
<p>Now we come to the part where we have to make a decision, in which direction we have to go forward. Let's see how we will do it:</p>
<pre>  if L &lt; R:<br/>        right()<br/>        time.sleep(2)<br/><br/>    else:<br/>        forward()</pre>
<p>Using an <kbd>if</kbd> statement, we are comparing the values of the proximity sensor for the right and left of the obstacle by this code <kbd>if L &lt; R:</kbd>. If <kbd>L</kbd> is smaller than <kbd>R</kbd>, then the vehicle will turn right for <kbd>2</kbd> seconds. If the condition is not true, then the <kbd>else:</kbd> statement would come into action, which will in turn make the vehicle go forward. </p>
<p>Now if we see the code in a larger picture, the following things are happening:</p>
<ul>
<li>The vehicle would go forward until it encounters an obstacle </li>
<li>Upon encountering an obstacle, the robot will stop</li>
<li>It will first turn right and measure the distance to objects in front of it</li>
<li>Then, it will turn left and measure the distance to objects in front of it</li>
<li>After this, it will compare the distance of both left and right and choose which direction it has to go in</li>
<li>If it has to go right, it will turn right and then go forward</li>
<li>If it has to go left, then it would already be in the left turned orientation, so it simply has to go straight </li>
</ul>
<p>Let's upload the code and see whether things happen according to plan or not. Remember this, though every environment is different and every vehicle is different, so you may have to tweak the code to make it work smoothly. </p>
<p>Now I will leave you with a problem. What if in both case the reading of the sensor is infinity or the maximum possible value that it can give? What will the robot do?</p>
<p>Go ahead, do some brainstorming and see what we can do to solve this problem! </p>


            

            
        
    </div>
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, using all basics that you learned so far and also by introducing IR proximity sensor, we were able to take an advanced step of developing our robotic car to detect obstacles and accordingly change the directions. In the next chapter, we will study how to make our own area scanner—see you there!</p>


            

            
        
    </div></body></html>