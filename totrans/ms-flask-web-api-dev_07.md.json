["```py\n \"payments\": {\n  \"<st c=\"4940\">details:id</st>\": 1001, \"<st c=\"4962\">details:stud_id</st>\": \"STD-001\",\n  \"<st c=\"4994\">details:tutor_id</st>\": \"TUT-001\", \"<st c=\"5027\">details:ccode</st>\": \"PY-100\",\n  \"<st c=\"5056\">details:fee</st>\": 5000.00\", \"<st c=\"5083\">items:id</st>\": 1001,\n  \"<st c=\"5103\">items:receipt_id</st>\": \"OR-901\", \"<st c=\"5135\">items:amount</st>\": 3000.00\"\n}\n\"bookings\" : {\n   \"<st c=\"5179\">details:id</st>\": 101, \"<st c=\"5200\">details:tutor_id</st>\": TUT-002\",\n   \"<st c=\"5232\">details:stud_id</st>\": \"STD-201\",\n   \"<st c=\"5264\">details:date_booked</st>\": \"2023-10-10\"\n}\n```", "```py\n     <configuration>\n        <property> <st c=\"8942\"><name>fs.defaultFS</name></st><st c=\"8967\"><value>hdfs://localhost:9000</value></st> </property>\n    </configuration>\n    ```", "```py\n     <configuration>\n     <property> <st c=\"9769\"><name>dfs.replication</name></st><st c=\"9797\"><value>1</value></st> </property>\n       <property> <st c=\"9838\"><name>dfs.namenode.name.dir</name></st><st c=\"9872\"><value></st><st c=\"9880\">file:///C:/Alibata/Development/Database/hadoop-3.3.6/data/namenode</value></st> </property>\n       <property> <st c=\"9979\"><name>dfs.datanode.data.dir</name></st><st c=\"10013\"><value></st><st c=\"10021\">file:///C:/Alibata/Development/Database/hadoop-3.3.6/data/datanode</value></st> </property>\n    </configuration>\n    ```", "```py\n     hdfs namenode -format\n    ```", "```py\n     <configuration>\n      <property> <st c=\"12227\"><name>hbase.cluster.distributed</name></st><st c=\"12265\"><value>false</value></st> </property>\n      <property> <st c=\"12310\"><name>hbase.tmp.dir</name></st><st c=\"12336\"><value>./tmp</value></st> </property>\n      <property> <st c=\"12380\"><name>hbase.rootdir</name></st><st c=\"12406\"><value></st><st c=\"12414\">file:///C:/Alibata/Development/Database/hbase-2.5.5/hbase</value></st> </property>\n     <property> <st c=\"12504\"><name>hbase.zookeeper.property.dataDir</name></st><st c=\"12549\"><value></st><st c=\"12557\">/C:/Alibata/Development/Database/hbase-2.5.5/zookeeper</value></st> </property>\n     <property> <st c=\"12644\"><name>hbase.zookeeper.quorum</name></st><st c=\"12679\"><value>localhost</value></st> </property>\n       … … … … … …\n    </configuration>\n    ```", "```py\n     set java_arguments=%HBASE_OPTS% -classpath \"%CLASSPATH%\" %CLASS% %hbase-command-arguments%\n    ```", "```py\n     set JAVA_HOME=%JAVA_HOME%\n    set HBASE_CLASSPATH=%HBASE_HOME%\\lib\\client-facing-thirdparty\\*\n    set HBASE_HEAPSIZE=8000\n    set HBASE_OPTS=\"-Djava.net.preferIPv4Stack=true\"\n    set SERVER_GC_OPTS=\"-verbose:gc\" <st c=\"13282\">\"-Xlog:gc*=info:stdout\" \"-XX:+UseG1GC\"</st><st c=\"13320\">\"-XX:MaxGCPauseMillis=100\" \"-XX:-ResizePLAB\"</st> %HBASE_GC_OPTS%\n    set HBASE_USE_GC_LOGFILE=true\n    set HBASE_JMX_BASE=\"-Dcom.sun.management.jmxremote.ssl=false\" \"-Dcom.sun.management.jmxremote.authenticate=false\"\n    set HBASE_MASTER_OPTS=%HBASE_JMX_BASE% \"-Dcom.sun.management.jmxremote.port=10101\"\n    set HBASE_REGIONSERVER_OPTS=%HBASE_JMX_BASE% \"-Dcom.sun.management.jmxremote.port=10102\"\n    set HBASE_THRIFT_OPTS=%HBASE_JMX_BASE% \"-Dcom.sun.management.jmxremote.port=10103\"\n    set HBASE_ZOOKEEPER_OPTS=%HBASE_JMX_BASE% -Dcom.sun.management.jmxremote.port=10104\"\n    set HBASE_REGIONSERVERS=%HBASE_HOME%\\conf\\regionservers\n    set HBASE_LOG_DIR=%HBASE_HOME%\\logs\n    set HBASE_IDENT_STRING=%USERNAME%\n    set HBASE_MANAGES_ZK=true\n    ```", "```py\n This file has been superceded by packaging our ruby files into a jar and using jruby's bootstrapping to invoke them. If you need to source this file for some reason it is now named 'jar-bootstrap.rb' and is located in the root of the file hbase-shell.jar and in the source tree at 'hbase-shell/src/main/ruby'.\n```", "```py\n java -cp hbase-shell-2.5.5.jar;client-facing-thirdparty/*;* org.jruby.JarBootstrapMain\n```", "```py\n pip install happybase\n```", "```py\n from flask import Flask\nimport toml <st c=\"24731\">import happybase</st> def create_app(config_file):\n    app = Flask(__name__)\n    app.config.from_file(config_file, toml.load) <st c=\"24844\">global pool</st><st c=\"24855\">pool = happybase.ConnectionPool(size=5,</st> <st c=\"24895\">host='localhost', port=9090)</st> with app.app_context():\n        import modules.api.hbase.payments\n        import modules.api.hbase.bookings\n```", "```py\n from typing import Dict, List, Any <st c=\"26156\">from happybase import Table</st> class PaymentRepository:\n    def __init__(self, <st c=\"26228\">pool</st>): <st c=\"26236\">self.pool = pool</st> def upsert_details(self, rowkey, tutor_id, stud_id, ccode, fee) -> bool:\n        record = <st c=\"26335\">{'details:id' : str(rowkey),</st> <st c=\"26363\">'details:tutor_id': tutor_id, 'details:stud_id':</st> <st c=\"26412\">stud_id, 'details:course_code': ccode,</st> <st c=\"26451\">'details:total_package': str(fee)}</st> try: <st c=\"26492\">with self.pool.connection() as conn:</st><st c=\"26528\">tbl:Table = conn.table(\"payments\")</st><st c=\"26563\">tbl.put(row=str(rowkey).encode('utf-8'),</st> <st c=\"26604\">data=record)</st> return True\n        except Exception as e:\n            print(e)\n        return False\n```", "```py\n def delete_payment_items(self, rowkey) -> bool:\n        try: <st c=\"27900\">with self.pool.connection() as conn:</st><st c=\"27936\">tbl:Table = conn.table(\"payments\")</st><st c=\"27971\">tbl.delete(rowkey.encode('utf-8'),</st> <st c=\"28006\">columns=[\"items\"])</st> return True\n        except Exception as e:\n            print(e)\n        return False\n```", "```py\n def select_records_ids(self, rowkeys:List[str], cols:List[str] = None):\n        try: <st c=\"28872\">with self.pool.connection() as conn:</st> tbl:Table = conn.table(\"payments\")\n                if cols == None or len(cols) == 0: <st c=\"28979\">rowkeys = tbl.rows(rowkeys)</st><st c=\"29006\">rows = [rec[1] for rec in rowkeys]</st> else: <st c=\"29048\">rowkeys = tbl.rows(rowkeys, cols)</st><st c=\"29081\">rows = [rec[1] for rec in rowkeys]</st> records = list() <st c=\"29134\">for r in rows:</st><st c=\"29148\">records.append({key.decode():value.decode()</st> <st c=\"29192\">for key, value in r.items()})</st> return records\n        except Exception as e:\n            print(e)\n        return None\n```", "```py\n { <st c=\"29783\">\"rowkeys\": [\"1\", \"2\", \"101\"],</st> \"cols\": []\n}\n```", "```py\n {\n    \"rowkeys\": [\"1\", \"2\", \"101\"], <st c=\"29970\">\"cols\": [\"details\"]</st> }\n```", "```py\n {\n    \"rowkeys\": [\"1\", \"2\", \"101\"], <st c=\"30143\">\"cols\": [\"details:stud_id\", \"details:tutor_id\",</st> <st c=\"30190\">\"details:course_code\"]</st> }\n```", "```py\n def select_all_records(self):\n        records = []\n        try: <st c=\"30509\">with self.pool.connection() as conn:</st> tbl:Table = conn.table(\"payments\") <st c=\"30581\">datalist = tbl.scan(columns=['details',</st> <st c=\"30620\">'items'])</st><st c=\"30630\">for key, data in datalist:</st><st c=\"30657\">data_str = {k.decode(): v.decode() for</st> <st c=\"30696\">k, v in data.items()}</st> records.append(data_str)\n                return records\n        except Exception as e:\n            print(e)\n        return records\n```", "```py\n def select_records_tutor(self, tutor_id):\n   records = []\n   try: <st c=\"31481\">with self.pool.connection() as conn:</st> tbl:Table = conn.table(\"payments\") <st c=\"31553\">datalist = tbl.scan(columns=[\"details\", \"items\"],</st> <st c=\"31602\">filter=\"SingleColumnValueFilter('details',</st> <st c=\"31645\">'tutor_id', =,'binary:{}')\".format(tutor_id))</st><st c=\"31691\">for key, data in datalist:</st><st c=\"31718\">data_str = {k.decode(): v.decode() for k, v in</st> <st c=\"31765\">data.items()}</st><st c=\"31779\">records.append(data_str)</st> return records\n   except Exception as e:\n       print(e)\n   return records\n```", "```py\n<st c=\"33710\">from modules import pool</st>\n<st c=\"33735\">@current_app.post('/ch07/payment/details/add')</st> def add_payment_details():\n    data = request.get_json() <st c=\"33836\">repo = PaymentRepository(pool)</st><st c=\"33866\">result = repo.upsert_details(data['id'],</st> <st c=\"33907\">data['tutor_id'], data['stud_id'], data['ccode'],</st> <st c=\"33957\">data['fee'])</st> if result == False:\n        return jsonify(message=\"error encountered in payment details record insert\"), 500\n    return jsonify(message=\"inserted payment details record\"), 201\n```", "```py\n<st c=\"34276\">from modules import pool</st>\n<st c=\"34301\">@current_app.get('/ch07/payment/list/all')</st> def list_all_payments(): <st c=\"34370\">repo = PaymentRepository(pool)</st><st c=\"34400\">results = repo.select_all_records()</st> return jsonify(records=results), 201\n```", "```py\n sudo ufw enable\n```", "```py\n sudo ufw allow 7000\nsudo ufw allow 9042\nsudo ufw allow 7199\n```", "```py\n sudo apt install openjdk-11-jdk\n```", "```py\n cassandra -f\n```", "```py\n CREATE KEYSPACE packtspace WITH replication = {'class': 'NetworkTopologyStrategy', 'datacenter1': '1'}  AND durable_writes = false;\n```", "```py\n pip install cassandra-driver\n```", "```py\n<st c=\"45502\">from cassandra.cqlengine.connection import setup</st> def create_app(config_file):\n    app = Flask(__name__)\n    app.config.from_file(config_file, toml.load) <st c=\"45707\">hosts</st> parameter provides the initial set of IP addresses that will serve as the contact points for the clusters. The second parameter is <st c=\"45844\">keyspace</st>, which was created beforehand with the CQL shell. The <st c=\"45907\">protocol version</st> parameter refers to the native protocol that <st c=\"45969\">cassandra-driver</st> uses to communicate with the server. It depicts the maximum number of requests a connection can handle during communication.\n\t\t\t<st c=\"46110\">Next, we’ll create the</st> <st c=\"46134\">model layer.</st>\n\t\t\t<st c=\"46146\">Building the model layer</st>\n\t\t\t<st c=\"46171\">Instead of using the CQL</st> <st c=\"46196\">shell to create the tables, we’ll use the</st> `<st c=\"46239\">cassandra-driver</st>` <st c=\"46255\">module since it can create the tables programmatically using entity model classes that can translate into actual tables upon application server startup.</st> <st c=\"46409\">These model classes are often referred to as</st> *<st c=\"46454\">object mappers</st>* <st c=\"46468\">since they also map</st> <st c=\"46488\">to the metadata of the</st> <st c=\"46512\">physical tables.</st>\n\t\t\t<st c=\"46528\">Unlike HBase, Cassandra recognizes data structures and data types for its tables.</st> <st c=\"46611\">Thus, the driver has a</st> `<st c=\"46634\">Model</st>` <st c=\"46639\">class that subclasses entities for Cassandra table generation.</st> <st c=\"46703\">It also provides helper classes, such as</st> `<st c=\"46744\">UUID</st>`<st c=\"46748\">,</st> `<st c=\"46750\">Integer</st>`<st c=\"46757\">,</st> `<st c=\"46759\">Float</st>`<st c=\"46764\">, and</st> `<st c=\"46770\">DateTime</st>`<st c=\"46778\">, that can define column metadata in an entity class.</st> <st c=\"46832\">The following code shows the entity models that are created through the</st> `<st c=\"46904\">cassandra-driver</st>` <st c=\"46920\">module:</st>\n\n```", "```py\n\n\t\t\t<st c=\"47783\">In the given</st> `<st c=\"47797\">Course</st>` <st c=\"47803\">entity,</st> `<st c=\"47812\">id</st>` <st c=\"47814\">and</st> `<st c=\"47819\">code</st>` <st c=\"47823\">are columns</st> <st c=\"47835\">that are declared as</st> *<st c=\"47857\">primary keys</st>*<st c=\"47869\">;</st> `<st c=\"47872\">id</st>` <st c=\"47874\">is the</st> *<st c=\"47882\">partition key</st>*<st c=\"47895\">, while</st> `<st c=\"47903\">code</st>` <st c=\"47907\">is the</st> *<st c=\"47915\">clustering key</st>* <st c=\"47929\">that will manage and sort the records per node in ascending order.</st> <st c=\"47997\">The</st> `<st c=\"48001\">title</st>`<st c=\"48006\">,</st> `<st c=\"48008\">req_hrs</st>`<st c=\"48015\">,</st> `<st c=\"48017\">total_cost</st>`<st c=\"48027\">,</st> `<st c=\"48029\">course_offered</st>`<st c=\"48043\">,</st> `<st c=\"48045\">level</st>`<st c=\"48050\">, and</st> `<st c=\"48056\">descriptions</st>` <st c=\"48068\">columns are typical columns that contain their respective metadata.</st> <st c=\"48137\">On the other hand, the</st> `<st c=\"48160\">get_json()</st>` <st c=\"48170\">custom method is an optional mechanism that will serialize the model when</st> `<st c=\"48245\">jsonify()</st>` <st c=\"48254\">needs to render them as a</st> <st c=\"48281\">JSON response.</st>\n\t\t\t<st c=\"48295\">The following model classes define the</st> `<st c=\"48335\">degree_level</st>`<st c=\"48347\">,</st> `<st c=\"48349\">student</st>`<st c=\"48356\">, and</st> `<st c=\"48362\">student_perf</st>` <st c=\"48374\">tables:</st>\n\n```", "```py\n\n\t\t\t<st c=\"49156\">Here,</st> `<st c=\"49163\">sync_table()</st>` <st c=\"49175\">from</st> `<st c=\"49181\">cassandra-driver</st>` <st c=\"49197\">converts each model into a table and synchronizes any changes made in the model classes to the mapped table in</st> `<st c=\"49309\">keyspace</st>`<st c=\"49317\">. However, applying this method to the model class with too many changes may mess up the existing table’s metadata.</st> <st c=\"49433\">So, it is more acceptable to drop all old tables using the CQL shell before running</st> `<st c=\"49517\">sync_table()</st>` <st c=\"49529\">with the updated</st> <st c=\"49547\">model classes.</st>\n\t\t\t<st c=\"49561\">After building the model layer, the subsequent</st> <st c=\"49608\">procedure is to implement the repository transactions to access the data in Cassandra.</st> <st c=\"49696\">So, let’s access the keyspace and tables in our Cassandra platform so that we can perform</st> <st c=\"49786\">CRUD operations.</st>\n\t\t\t<st c=\"49802\">Implementing the repository layer</st>\n\t\t\t<st c=\"49836\">Entity models inherit</st> <st c=\"49858\">some attributes from the</st> `<st c=\"49884\">Model</st>` <st c=\"49889\">class, such as</st> `<st c=\"49905\">__table_name__</st>`<st c=\"49919\">, which accepts and replaces the default table name of the mapping, and</st> `<st c=\"49991\">__keyspace__</st>`<st c=\"50003\">, which replaces the default</st> *<st c=\"50032\">keyspace</st>* <st c=\"50040\">of the</st> <st c=\"50048\">mapped table.</st>\n\t\t\t<st c=\"50061\">Moreover, entity models also inherit some other</st> <st c=\"50110\">instance methods:</st>\n\n\t\t\t\t*   `<st c=\"50127\">save()</st>`<st c=\"50134\">: Persists the entity object in</st> <st c=\"50167\">the database.</st>\n\t\t\t\t*   `<st c=\"50180\">update(**kwargs)</st>`<st c=\"50197\">: Updates the existing column fields based on the new column (</st>`<st c=\"50260\">kwargs</st>`<st c=\"50267\">) details.</st>\n\t\t\t\t*   `<st c=\"50278\">delete()</st>`<st c=\"50287\">: Removes the record from</st> <st c=\"50314\">the database.</st>\n\t\t\t\t*   `<st c=\"50327\">batch()</st>`<st c=\"50335\">: Runs synchronized updates or inserts</st> <st c=\"50375\">on replicas.</st>\n\t\t\t\t*   `<st c=\"50387\">iff(**kwargs)</st>`<st c=\"50401\">: Checks if the indicated</st> `<st c=\"50428\">kwargs</st>` <st c=\"50434\">matches the column values of the object before the update or</st> <st c=\"50496\">delete happens.</st>\n\t\t\t\t*   `<st c=\"50511\">if_exists()</st>`<st c=\"50523\">/</st>`<st c=\"50525\">if_not_exists()</st>`<st c=\"50540\">: Verifies if the mapped record exists in</st> <st c=\"50583\">the database.</st>\n\n\t\t\t<st c=\"50596\">Also, the entity classes derive the</st> `<st c=\"50633\">objects</st>` <st c=\"50640\">class variable from their</st> `<st c=\"50667\">Model</st>` <st c=\"50672\">superclass, which can provide query methods such as</st> `<st c=\"50725\">filter()</st>`<st c=\"50733\">,</st> `<st c=\"50735\">allow_filtering()</st>`<st c=\"50752\">, and</st> `<st c=\"50758\">get()</st>` <st c=\"50763\">for record retrieval.</st> <st c=\"50786\">They also inherit the</st> `<st c=\"50808\">create()</st>` <st c=\"50816\">class method, which can insert records into the database, an option other</st> <st c=\"50891\">than</st> `<st c=\"50896\">save()</st>`<st c=\"50902\">.</st>\n\t\t\t<st c=\"50903\">All these derived methods are the building blocks of our repository class.</st> <st c=\"50979\">The following repository class shows how the</st> `<st c=\"51024\">Course</st>` <st c=\"51030\">model implements its</st> <st c=\"51052\">CRUD transactions:</st>\n\n```", "```py\n\n\t\t\t<st c=\"51368\">Gere,</st> `<st c=\"51375\">insert_course()</st>` <st c=\"51390\">uses the</st> `<st c=\"51400\">create()</st>` <st c=\"51408\">method</st> <st c=\"51415\">to persist a</st> `<st c=\"51429\">course</st>` <st c=\"51435\">record instead of applying</st> `<st c=\"51463\">save()</st>`<st c=\"51469\">. For the update transaction,</st> `<st c=\"51499\">update_course()</st>` <st c=\"51514\">filters a</st> `<st c=\"51525\">course</st>` <st c=\"51531\">record by course code</st> <st c=\"51554\">for updating:</st>\n\n```", "```py\n\n\t\t\t<st c=\"51818\">In Cassandra, when querying records with constraints, the</st> *<st c=\"51877\">partition key</st>* <st c=\"51890\">must always be included in the constraint.</st> <st c=\"51934\">However,</st> `<st c=\"51943\">update_course()</st>` <st c=\"51958\">uses the</st> `<st c=\"51968\">allow_filtering()</st>` <st c=\"51985\">method to allow data retrieval without the</st> *<st c=\"52029\">partition key</st>* <st c=\"52042\">and bypass the</st> *<st c=\"52058\">Invalid Query Error</st>* <st c=\"52077\">or</st> *<st c=\"52081\">error</st>* *<st c=\"52087\">code 2200</st>*<st c=\"52096\">.</st>\n\t\t\t<st c=\"52097\">The following</st> `<st c=\"52112\">delete_course_code()</st>` <st c=\"52132\">transaction</st> <st c=\"52144\">uses the</st> `<st c=\"52154\">delete()</st>` <st c=\"52162\">entity class method to remove the filtered record object.</st> <st c=\"52221\">Again, the</st> `<st c=\"52232\">allow_filtering()</st>` <st c=\"52249\">method helps filter the record by code without messing up the</st> *<st c=\"52312\">partition key</st>*<st c=\"52325\">:</st>\n\n```", "```py\n\n\t\t\t<st c=\"52501\">Here,</st> `<st c=\"52508\">search_by_code()</st>` <st c=\"52524\">and</st> `<st c=\"52529\">search_all_courses()</st>` <st c=\"52549\">are the two query transactions of this</st> `<st c=\"52589\">CourseRepository</st>`<st c=\"52605\">. The former retrieves a single record based on a</st> `<st c=\"52655\">course</st>` <st c=\"52661\">code, while the latter filters all</st> `<st c=\"52697\">course</st>` <st c=\"52703\">records without any condition.</st> <st c=\"52735\">The</st> `<st c=\"52739\">get()</st>` <st c=\"52744\">method of</st> `<st c=\"52755\">objects</st>` <st c=\"52762\">returns a non-JSONable</st> `<st c=\"52786\">Course</st>` <st c=\"52792\">object that</st> `<st c=\"52805\">jsonify()</st>` <st c=\"52814\">cannot process.</st> <st c=\"52831\">But wrapping the object with</st> `<st c=\"52860\">dict()</st>` <st c=\"52866\">after converts it into a JSON serializable record.</st> <st c=\"52918\">In</st> `<st c=\"52921\">search_all_courses()</st>`<st c=\"52941\">, the custom</st> `<st c=\"52954\">get_json()</st>` <st c=\"52964\">method helps generate a list of JSONable course records for easy</st> `<st c=\"53030\">Response</st>` <st c=\"53038\">generation:</st>\n\n```", "```py\n\n\t\t\t<st c=\"53316\">Cassandra is known for its faster write than read operations.</st> <st c=\"53379\">It writes data to the commit log and then caches it simultaneously, preserving data from unexpected occurrences, damage, or downtime.</st> <st c=\"53513\">But there is one form of NoSQL data storage that’s popular</st> <st c=\"53571\">for its faster reads operations:</st> **<st c=\"53605\">Remote Dictionary</st>** **<st c=\"53623\">Server</st>** <st c=\"53629\">(</st>**<st c=\"53631\">Redis</st>**<st c=\"53636\">).</st>\n\t\t\t<st c=\"53639\">Storing search data in Redis</st>\n\t\t\t<st c=\"53668\">Redis is a fast, open</st> <st c=\"53690\">source, in-memory,</st> *<st c=\"53710\">key-value</st>* <st c=\"53719\">form of NoSQL storage</st> <st c=\"53741\">that’s popular in messaging and caching.</st> <st c=\"53783\">In</st> [*<st c=\"53786\">Chapter 5</st>*](B19383_05.xhtml#_idTextAnchor111)<st c=\"53795\">, we used it as the message broker of Celery, while in</st> [*<st c=\"53850\">Chapter 6</st>*](B19383_06.xhtml#_idTextAnchor143)<st c=\"53859\">, we used it as a message queue for the SSE and WebSocket programming.</st> <st c=\"53930\">However, this chapter will utilize Redis as a data cache to create a fast</st> <st c=\"54004\">search mechanism.</st>\n\t\t\t<st c=\"54021\">First, let’s install Redis on</st> <st c=\"54052\">our system.</st>\n\t\t\t<st c=\"54063\">Installing the Redis server</st>\n\t\t\t<st c=\"54091\">For Windows, download</st> <st c=\"54113\">the latest Redis</st> <st c=\"54130\">TAR file from</st> [<st c=\"54145\">https://redis.io/download/</st>](https://redis.io/download/)<st c=\"54171\">, unzip it to an installation folder, and run</st> `<st c=\"54217\">redis-server.exe</st>` <st c=\"54233\">from</st> <st c=\"54239\">the directory.</st>\n\t\t\t<st c=\"54253\">For WSL, run the following series of</st> `<st c=\"54291\">sudo</st>` <st c=\"54295\">commands:</st>\n\n```", "```py\n\n\t\t\t<st c=\"54424\">Then, run</st> `<st c=\"54435\">redis-cli -v</st>` <st c=\"54447\">to check if the installation was successful.</st> <st c=\"54493\">If so, run the</st> `<st c=\"54508\">redis-server</st>` <st c=\"54520\">command to start the Redis server.</st> *<st c=\"54556\">Figure 7</st>**<st c=\"54564\">.13</st>* <st c=\"54567\">shows the server log after the Redis server starts up on the</st> <st c=\"54629\">WSL-Ubuntu platform:</st>\n\t\t\t![Figure 7.13 – Running the redis-server command](img/B19383_07_013.jpg)\n\n\t\t\t<st c=\"56140\">Figure 7.13 – Running the redis-server command</st>\n\t\t\t<st c=\"56186\">To stop the server, run the</st> `<st c=\"56215\">redis-cli</st>` <st c=\"56224\">shutdown command or press</st> *<st c=\"56251\">Ctrl</st>* <st c=\"56255\">+</st> *<st c=\"56258\">C</st>* <st c=\"56259\">on</st> <st c=\"56263\">your keyboard.</st>\n\t\t\t<st c=\"56277\">Now, let’s explore the Redis</st> <st c=\"56306\">server using its client shell and understand its CLI commands so that we can run its</st> <st c=\"56392\">CRUD operations.</st>\n\t\t\t<st c=\"56408\">Understanding the Redis database</st>\n\t\t\t<st c=\"56441\">Key-value storage uses a</st> *<st c=\"56467\">hashtable</st>* <st c=\"56476\">data</st> <st c=\"56481\">structure model wherein its unique key value serves as a pointer to a corresponding value of any type.</st> <st c=\"56585\">For Redis, the key is always a string that points to values of type strings, JSON, lists, sets, hashes, sorted set, streams, bitfields, geospatial, and time series.</st> <st c=\"56750\">Since Redis is an in-memory storage type, it stores all its simple to complex key-value pairs of data in the host’s RAM, which is volatile and cannot persist data permanently.</st> <st c=\"56926\">However, in return, Redis can provide faster reads and access to its data than HBase</st> <st c=\"57011\">and Cassandra.</st>\n\t\t\t<st c=\"57025\">To learn more about this storage, Redis has a built-in shell client that interacts with the database through some commands.</st> *<st c=\"57150\">Figure 7</st>**<st c=\"57158\">.14</st>* <st c=\"57161\">shows opening a client shell by running the</st> `<st c=\"57206\">redis-cli</st>` <st c=\"57215\">command and checking the number of databases the storage has using the</st> `<st c=\"57287\">CONFIG GET</st>` `<st c=\"57298\">databases</st>` <st c=\"57307\">command:</st>\n\t\t\t![Figure 7.14 – Opening a Redis shell](img/B19383_07_014.jpg)\n\n\t\t\t<st c=\"57476\">Figure 7.14 – Opening a Redis shell</st>\n\t\t\t<st c=\"57511\">The typical number of databases</st> <st c=\"57543\">in Redis storage is</st> *<st c=\"57564\">16</st>*<st c=\"57566\">. Redis databases are named from</st> *<st c=\"57599\">0</st>* <st c=\"57601\">to</st> *<st c=\"57604\">15</st>*<st c=\"57606\">, like indexes of an array.</st> <st c=\"57634\">The default database name is</st> *<st c=\"57663\">0</st>*<st c=\"57664\">, but it has a</st> `<st c=\"57679\">select</st>` <st c=\"57685\">command that chooses the preferred database other than 0 (for example,</st> `<st c=\"57757\">select 1</st>`<st c=\"57765\">).</st>\n\t\t\t<st c=\"57768\">Since Redis is a simple NoSQL database, it only has the following</st> <st c=\"57834\">few commands, including CRUD, we need</st> <st c=\"57873\">to consider:</st>\n\n\t\t\t\t*   `<st c=\"57885\">set</st>`<st c=\"57889\">: Adds a key-value pair to</st> <st c=\"57917\">the database.</st>\n\t\t\t\t*   `<st c=\"57930\">get</st>`<st c=\"57934\">: Retrieves the value of</st> <st c=\"57960\">a key.</st>\n\t\t\t\t*   `<st c=\"57966\">hset</st>`<st c=\"57971\">: Adds a hash with multiple</st> <st c=\"58000\">key-value pairs.</st>\n\t\t\t\t*   `<st c=\"58016\">hget</st>`<st c=\"58021\">: Retrieves the value of a key in</st> <st c=\"58056\">a hash.</st>\n\t\t\t\t*   `<st c=\"58063\">hgetall</st>`<st c=\"58071\">: Retrieves all the key-value pairs in</st> <st c=\"58111\">a hash.</st>\n\t\t\t\t*   `<st c=\"58118\">hkeys</st>`<st c=\"58124\">: Retrieves all the keys in</st> <st c=\"58153\">a hash.</st>\n\t\t\t\t*   `<st c=\"58160\">hvals</st>`<st c=\"58166\">: Retrieves all the values in</st> <st c=\"58197\">a hash.</st>\n\t\t\t\t*   `<st c=\"58204\">del</st>`<st c=\"58208\">: Removes an existing key-value pair using the key or the</st> <st c=\"58267\">whole hash.</st>\n\t\t\t\t*   `<st c=\"58278\">hdel</st>`<st c=\"58283\">: Removes single or multiple key-value pairs in</st> <st c=\"58332\">a hash.</st>\n\n\t\t\t<st c=\"58339\">Redis hashes are records or structured</st> <st c=\"58378\">types that can hold collections of field-value pairs with values of varying types.</st> <st c=\"58462\">In a way, it can represent a Python object persisted in the database.</st> *<st c=\"58532\">Figure 7</st>**<st c=\"58540\">.15</st>* <st c=\"58543\">shows a list of Redis commands being run on the</st> <st c=\"58592\">Redis shell:</st>\n\t\t\t![Figure 7.15 – Running Redis commands on the Redis shell](img/B19383_07_015.jpg)\n\n\t\t\t<st c=\"59167\">Figure 7.15 – Running Redis commands on the Redis shell</st>\n\t\t\t<st c=\"59222\">But how can our</st> *<st c=\"59239\">Tutor Finder</st>* <st c=\"59251\">application</st> <st c=\"59264\">connect to a Redis database as a client?</st> <st c=\"59305\">We’ll answer this question in the</st> <st c=\"59339\">next section.</st>\n\t\t\t<st c=\"59352\">Establishing a database connection</st>\n\t\t\t<st c=\"59387\">In</st> [*<st c=\"59391\">Chapter 5</st>*](B19383_05.xhtml#_idTextAnchor111) <st c=\"59400\">and</st> [*<st c=\"59405\">Chapter 6</st>*](B19383_06.xhtml#_idTextAnchor143)<st c=\"59414\">, the</st> *<st c=\"59420\">redis-py</st>* <st c=\"59428\">module established</st> <st c=\"59447\">a connection to Redis as a broker or message queue.</st> <st c=\"59500\">This time, our application will connect to the Redis database for data storage</st> <st c=\"59579\">and caching.</st>\n\t\t\t<st c=\"59591\">So far, the Redis OM module is the most efficient and convenient Redis database connector that can provide database connectivity and methods for CRUD operations, similar to an ORM.</st> <st c=\"59773\">However, before accessing its utilities, install it using the</st> `<st c=\"59835\">pip</st>` <st c=\"59838\">command:</st>\n\n```", "```py\n\n\t\t\t`<st c=\"59868\">redis-py</st>` <st c=\"59877\">is the other library that’s included in the installation of the</st> `<st c=\"59942\">redis-om</st>` <st c=\"59950\">module.</st> <st c=\"59959\">The</st> `<st c=\"59963\">redis</st>` <st c=\"59968\">module has a Redis callable object that builds the database connectivity.</st> <st c=\"60043\">The callable has a</st> `<st c=\"60062\">from_url()</st>` <st c=\"60072\">method that accepts the database URL and some parameter values for the</st> `<st c=\"60144\">encoding</st>` <st c=\"60152\">and</st> `<st c=\"60157\">decode_responses</st>` <st c=\"60173\">parameters.</st> <st c=\"60186\">The following code shows</st> `<st c=\"60211\">create_app()</st>`<st c=\"60223\">, which creates the Redis connection to</st> <st c=\"60263\">database</st> `<st c=\"60272\">0</st>`<st c=\"60273\">:</st>\n\n```", "```py\n<st c=\"61688\">from redis_om import  HashModel, Field,</st> <st c=\"61727\">get_redis_connection</st>\n<st c=\"61748\">redis_conn = get_redis_connection(decode_responses=True)</st> class SearchCourse(<st c=\"61825\">HashModel</st>):\n    code: str  = Field(index=True)\n    title: str\n    description: str\n    req_hrs: float\n    total_cost: float\n    level: int\nclass SearchStudent(<st c=\"61961\">HashModel</st>):\n    std_id: str\n    firstname: str\n    midname: str\n    lastname: str\n    … … … … … …\nclass SearchTutor(<st c=\"62059\">HashModel</st>):\n    firstname: str\n    lastname: str\n    midname: str\n    … … … … … … <st c=\"62167\">CourseSearch</st>, <st c=\"62181\">SearchStudent</st>, and <st c=\"62200\">SearchTutor</st> are model classes that have been created to cache incoming request data to the Redis database for fast search transactions. Each class has declared attributes that correspond to the keys of a record. After its instantiation, the model object will have a <st c=\"62466\">pk</st> instance variable that contains the unique hash key of the data record.\n\t\t\t<st c=\"62540\">Aside from relying on the Redis</st> <st c=\"62572\">connection created by</st> `<st c=\"62595\">Redis.from_url()</st>`<st c=\"62611\">, a</st> `<st c=\"62615\">HashModel</st>` <st c=\"62624\">object can independently or directly connect to the Redis database by assigning a connection instance to its</st> `<st c=\"62734\">Meta</st>` <st c=\"62738\">object’s</st> `<st c=\"62748\">database</st>` <st c=\"62756\">variable.</st> <st c=\"62767\">In either of these connectivity approaches, the model object can still emit the methods that will operate the</st> <st c=\"62877\">repository layer.</st>\n\t\t\t<st c=\"62894\">After establishing the Redis connection and creating the model classes, the next step is to build the</st> <st c=\"62997\">repository layer.</st>\n\t\t\t<st c=\"63014\">Building the repository layer</st>\n\t\t\t<st c=\"63044\">Like in Cassandra’s repository</st> <st c=\"63075\">layer, the model object of the</st> `<st c=\"63107\">redis-om</st>` <st c=\"63115\">module implements the repository class.</st> <st c=\"63156\">The</st> `<st c=\"63160\">HashModel</st>` <st c=\"63169\">entity emits methods that will implement the CRUD transactions.</st> <st c=\"63234\">The following</st> `<st c=\"63248\">SearchCourseRepository</st>` <st c=\"63270\">class manages course details in the</st> <st c=\"63307\">Redis database:</st>\n\n```", "```py\n\n\t\t\t<st c=\"63620\">The given</st> `<st c=\"63631\">insert_course()</st>` <st c=\"63646\">method uses the</st> `<st c=\"63663\">HashModel</st>` <st c=\"63672\">entity’s</st> `<st c=\"63682\">save()</st>` <st c=\"63688\">instance method, which adds</st> <st c=\"63716\">the course details as key-value pairs in database</st> `<st c=\"63767\">0</st>` <st c=\"63768\">of Redis.</st> <st c=\"63779\">To update a record, retrieve the data object using its</st> `<st c=\"63834\">pk</st>` <st c=\"63836\">from the database and then invoke the</st> `<st c=\"63875\">update()</st>` <st c=\"63883\">method of the resulting model object with the new field values.</st> <st c=\"63948\">The following</st> `<st c=\"63962\">update_course()</st>` <st c=\"63977\">method applies this</st> `<st c=\"63998\">redis-om</st>` <st c=\"64006\">approach:</st>\n\n```", "```py\n\n\t\t\t<st c=\"64193\">When deleting a record,</st> `<st c=\"64218\">HashModel</st>` <st c=\"64227\">has a class method called</st> `<st c=\"64254\">delete()</st>` <st c=\"64262\">that removes a hashed object using its</st> `<st c=\"64302\">pk</st>`<st c=\"64304\">, similar to the following</st> `<st c=\"64331\">delete_course()</st>` <st c=\"64346\">method:</st>\n\n```", "```py\n\n\t\t\t<st c=\"64469\">When retrieving data</st> <st c=\"64490\">from the database, the</st> `<st c=\"64514\">get()</st>` <st c=\"64519\">method is the only way to retrieve a single model object using an existing</st> `<st c=\"64595\">pk</st>`<st c=\"64597\">. Querying all the records requires a</st> `<st c=\"64635\">for</st>` <st c=\"64638\">loop to enumerate all</st> `<st c=\"64661\">pk</st>` <st c=\"64663\">values from the</st> `<st c=\"64680\">HashModel</st>` <st c=\"64689\">entity’s</st> `<st c=\"64699\">all_pks()</st>` <st c=\"64708\">generator, which retrieves all</st> `<st c=\"64740\">pk</st>` <st c=\"64742\">from the database.</st> <st c=\"64762\">The loop will fetch all the model objects using the enumerated</st> `<st c=\"64825\">pk</st>`<st c=\"64827\">. The following</st> `<st c=\"64843\">select_course()</st>` <st c=\"64858\">class retrieves all course details from the</st> `<st c=\"64903\">search_course</st>` <st c=\"64916\">table using the</st> `<st c=\"64933\">pk</st>` <st c=\"64935\">value of</st> <st c=\"64945\">each record:</st>\n\n```", "```py\n\n\t\t\t<st c=\"65225\">All resulting objects from the query transactions are JSONable and don’t need a JSON serializer.</st> <st c=\"65323\">Running the given</st> `<st c=\"65341\">select_all_course()</st>` <st c=\"65360\">class will return the following sample</st> <st c=\"65400\">Redis records:</st>\n\n```", "```py\n\n\t\t\t<st c=\"65794\">Although Redis OM</st> <st c=\"65812\">is perfectly compatible with FastAPI, it can also make any Flask application a client for Redis.</st> <st c=\"65910\">Now, Redis OM cannot implement filtered queries.</st> <st c=\"65959\">If Redis OM needs a filtered search with some constraints, it needs a</st> *<st c=\"66029\">RediSearch</st>* <st c=\"66039\">extension module that calibrates and provides more search constraints to query transactions.</st> <st c=\"66133\">But</st> *<st c=\"66137\">RediSearch</st>* <st c=\"66147\">can only run with Redis OM if the application uses Redis Stack instead of the</st> <st c=\"66226\">typical server.</st>\n\t\t\t<st c=\"66241\">The next section will highlight a</st> *<st c=\"66276\">document-oriented</st>* <st c=\"66293\">NoSQL database that’s popular for enterprise application</st> <st c=\"66351\">development:</st> *<st c=\"66364\">MongoDB</st>*<st c=\"66371\">.</st>\n\t\t\t<st c=\"66372\">Handling BSON-based documents with MongoDB</st>\n\t\t\t**<st c=\"66415\">MongoDB</st>** <st c=\"66423\">is a NoSQL database that stores JSON-like</st> <st c=\"66465\">documents of key-value pairs</st> <st c=\"66495\">with a flexible and scalable schema, thus classified as a document-oriented database.</st> <st c=\"66581\">It can store huge volumes of data with varying data structures, types,</st> <st c=\"66652\">and formations.</st>\n\t\t\t<st c=\"66667\">These JSON-like documents use</st> **<st c=\"66698\">Binary Javascript Object Notation</st>** <st c=\"66731\">(</st>**<st c=\"66733\">BSON</st>**<st c=\"66737\">), a binary-encoded representation</st> <st c=\"66772\">of JSON documents suitable for network-based data transport because of its compact nature.</st> <st c=\"66864\">It has non-JSON-native data type support for date and binary data and recognizes embedded documents or an array of documents because of its</st> <st c=\"67004\">traversable structure.</st>\n\t\t\t<st c=\"67026\">Next, we’ll install MongoDB and compare its process to HBase, Cassandra,</st> <st c=\"67100\">and Redis.</st>\n\t\t\t<st c=\"67110\">Installing and configuring the MongoDB server</st>\n\t\t\t<st c=\"67156\">First, download the</st> <st c=\"67176\">preferred MongoDB</st> <st c=\"67194\">community server from</st> [<st c=\"67217\">https://www.mongodb.com/try/download/community</st>](https://www.mongodb.com/try/download/community)<st c=\"67263\">. Install it to</st> <st c=\"67278\">your preferred drive and directory.</st> <st c=\"67315\">Next, create a data directory where MongoDB can store its documents.</st> <st c=\"67384\">If the data folder doesn’t exist, MongoDB will resort to</st> `<st c=\"67441\">C:\\data\\db</st>` <st c=\"67451\">as its default data folder.</st> <st c=\"67480\">Afterward, run the server by running the</st> <st c=\"67521\">following command:</st>\n\n```", "```py\n\n\t\t\t<st c=\"67572\">The default host of the server is localhost, and its port</st> <st c=\"67631\">is</st> `<st c=\"67634\">27017</st>`<st c=\"67639\">.</st>\n\t\t\t<st c=\"67640\">Download MongoDB Shell</st> <st c=\"67663\">from</st> [<st c=\"67669\">https://www.mongodb.com/try/download/shell</st>](https://www.mongodb.com/try/download/shell) <st c=\"67711\">to open the client console for the server.</st> <st c=\"67755\">Also, download</st> <st c=\"67769\">MongoDB Compass from</st> [<st c=\"67791\">https://www.mongodb.com/try/download/compass</st>](https://www.mongodb.com/try/download/compass)<st c=\"67835\">, the GUI administration tool for the</st> <st c=\"67873\">database server.</st>\n\t\t\t<st c=\"67889\">So far, installing the MongoDB server and its tools takes less time than installing the other NoSQL databases.</st> <st c=\"68001\">Next, we’ll integrate MongoDB into our</st> *<st c=\"68040\">Tutor</st>* *<st c=\"68046\">Finder</st>* <st c=\"68052\">application.</st>\n\t\t\t<st c=\"68065\">Establishing a database connection</st>\n\t\t\t<st c=\"68100\">To create database</st> <st c=\"68119\">connectivity, MongoDB uses the</st> `<st c=\"68151\">pymongo</st>` <st c=\"68158\">module as its native driver, which is made from BSON utilities.</st> <st c=\"68223\">However, the driver requires more codes to implement the CRUD transactions because it offers low-level utilities.</st> <st c=\"68337\">A high-level and object-oriented module, such as</st> `<st c=\"68386\">mongoengine</st>`<st c=\"68397\">, can provide a better database connection than</st> `<st c=\"68445\">pymongo</st>`<st c=\"68452\">. The</st> `<st c=\"68458\">mongoengine</st>` <st c=\"68469\">library is a popular</st> **<st c=\"68491\">object document mapper</st>** <st c=\"68513\">(</st>**<st c=\"68515\">ODM</st>**<st c=\"68518\">) that can build a client application</st> <st c=\"68556\">with a model and</st> <st c=\"68574\">repository layers.</st>\n\t\t\t<st c=\"68592\">The</st> `<st c=\"68597\">flask-mongoengine</st>` <st c=\"68614\">library is written solely for Flask.</st> <st c=\"68652\">However, since Flask 3.x, the</st> `<st c=\"68682\">flask.json</st>` <st c=\"68692\">module, on which the module is tightly dependent, was removed.</st> <st c=\"68756\">This change affected the</st> `<st c=\"68781\">MongoEngine</st>` <st c=\"68792\">class of the</st> `<st c=\"68806\">flask_mongoengine</st>` <st c=\"68823\">library, which creates a MongoDB client.</st> <st c=\"68865\">Until the library is updated so that it supports the latest version of Flask, the native</st> `<st c=\"68954\">connect()</st>` <st c=\"68963\">method from the native</st> `<st c=\"68987\">mongoengine.connection</st>` <st c=\"69009\">module will always be the solution to connect to the MongoDB database.</st> <st c=\"69081\">The following snippet from the</st> *<st c=\"69112\">Tutor Finder</st>* <st c=\"69124\">application’s</st> `<st c=\"69139\">create_app()</st>` <st c=\"69151\">factory method uses</st> `<st c=\"69172\">connect()</st>` <st c=\"69181\">to establish communication with the</st> <st c=\"69218\">MongoDB server:</st>\n\n```", "```py\n from mongoengine import <st c=\"70242\">Document</st>, <st c=\"70252\">SequenceField</st>, <st c=\"70267\">BooleanField</st>, <st c=\"70281\">EmbeddedDocumentField</st>, <st c=\"70304\">BinaryField</st>, <st c=\"70317\">IntField</st>, <st c=\"70327\">StringField</st>, <st c=\"70340\">DateField</st>, <st c=\"70351\">EmailField</st>, <st c=\"70363\">EmbeddedDocumentListField</st>, <st c=\"70390\">EmbeddedDocument</st> class Savings(<st c=\"70421\">EmbeddedDocument</st>):\n    acct_name = StringField(db_field='acct_name', max_length=100, required=True)\n    acct_number = StringField(db_field='acct_number', max_length=16, required=True)\n        … … … … … …\nclass Checking(EmbeddedDocument):\n    acct_name = StringField(db_field='acct_name', max_length=100, required=True)\n    acct_number = StringField(db_field='acct_number', max_length=16, required=True)\n    bank =  StringField(db_field='bank', max_length=100, required=True)\n    … … … … … …\nclass PayPal(EmbeddedDocument):\n    email = EmailField(db_field='email', max_length=20, required=True)\n    address = StringField(db_field='address', max_length=200, required=True)\nclass Tutor(EmbeddedDocument):\n    firstname = StringField(db_field='firstname', max_length=50, required=True)\n    lastname = StringField(db_field='lastname', max_length=50, required=True)\n    … … …. … … <st c=\"71245\">savings = EmbeddedDocumentListField(Savings, required=False)</st><st c=\"71305\">checkings = EmbeddedDocumentListField(Checking, required=False)</st><st c=\"71369\">gcash = EmbeddedDocumentField(GCash, required=False)</st><st c=\"71422\">paypal = EmbeddedDocumentField(PayPal, required=False)</st> class TutorLogin(Document):\n    id = SequenceField(required=True, primary_key=True)\n    username = StringField(db_field='email',max_length=25, required=True)\n    password = StringField(db_field='password',maxent=25, required=True)\n    encpass = BinaryField(db_field='encpass', required=True) <st c=\"71827\">flask-mongengine</st> offers helper classes, such as <st c=\"71875\">StringField</st>, <st c=\"71888\">BinaryField</st>, <st c=\"71901\">DateField</st>, <st c=\"71912\">IntField</st>, and <st c=\"71926\">EmailField</st>, that build the metadata of a document. These helper classes have parameters, such as <st c=\"72023\">db_field</st> and <st c=\"72036\">required</st>, that will add details to the key-value pairs. Moreover, some parameters appear only in one helper class, such as <st c=\"72159\">min_length</st> and <st c=\"72174\">max_length</st> in <st c=\"72188\">StringField</st>, because they control the number of characters in the string. Likewise, <st c=\"72272\">ByteField</st> has a <st c=\"72288\">max_bytes</st> parameter that will not appear in other helper classes. Note that, the <st c=\"72369\">Document</st> base class’ <st c=\"72390\">BinaryField</st> translates to BSON’s binary data and <st c=\"72439\">DateField</st> to BSON’s date type, not the common Python type.\n\t\t\t<st c=\"72497\">Unlike Cassandra, Redis, and HBase, MongoDB</st> <st c=\"72541\">allows relationships among structures.</st> <st c=\"72581\">Although not normalized like in an RDBMS, MongoDB can link one document to its subdocuments using the</st> `<st c=\"72683\">EmbeddedDocumentField</st>` <st c=\"72704\">and</st> `<st c=\"72709\">EmbeddedDocumentListField</st>` <st c=\"72734\">helper classes.</st> <st c=\"72751\">In the given model classes, the</st> `<st c=\"72783\">TutorLogin</st>` <st c=\"72793\">model will create a parent document collection called</st> `<st c=\"72848\">tutor_login</st>` <st c=\"72859\">that will reference a</st> `<st c=\"72882\">tutor</st>` <st c=\"72887\">sub-document because the sub-document’s</st> `<st c=\"72928\">Tutor</st>` <st c=\"72933\">model is an</st> `<st c=\"72946\">EmbeddedDocumentField</st>` <st c=\"72967\">helper class of the parent</st> `<st c=\"72995\">TutorLogin</st>` <st c=\"73005\">model.</st> <st c=\"73013\">The idea is similar to a one-to-one relationship concept in a relational ERD but not totally the same.</st> <st c=\"73116\">On the other hand, the relationship between</st> `<st c=\"73160\">Tutor</st>` <st c=\"73165\">and</st> `<st c=\"73170\">Savings</st>` <st c=\"73177\">is like a one-to-many relationship because</st> `<st c=\"73221\">Savings</st>` <st c=\"73228\">is the</st> `<st c=\"73236\">EmbeddedDocumentListField</st>` <st c=\"73261\">helper class of the</st> `<st c=\"73282\">Tutor</st>` <st c=\"73287\">model.</st> <st c=\"73295\">In other words, the</st> `<st c=\"73315\">tutor</st>` <st c=\"73320\">document collections will reference a list of savings sub-documents.</st> <st c=\"73390\">Here</st> `<st c=\"73395\">EmbeddedDocumentField</st>` <st c=\"73416\">does not have an</st> `<st c=\"73434\">_id</st>` <st c=\"73437\">field because it cannot construct an actual document</st> <st c=\"73490\">collection, unlike in an independent</st> `<st c=\"73528\">Document</st>` <st c=\"73536\">base class.</st>\n\t\t\t<st c=\"73548\">Next, we’ll create the repository layer from the</st> `<st c=\"73598\">Tutor</st>` <st c=\"73603\">document and</st> <st c=\"73617\">its sub-documents.</st>\n\t\t\t<st c=\"73635\">Implementing the repository</st>\n\t\t\t<st c=\"73663\">The</st> `<st c=\"73668\">Document</st>` <st c=\"73676\">object emits utility methods</st> <st c=\"73705\">that perform CRUD operations for the repository layer.</st> <st c=\"73761\">Here is a</st> `<st c=\"73771\">TutorLoginRepository</st>` <st c=\"73791\">class that inserts, updates, deletes, and retrieves</st> `<st c=\"73844\">tutor_login</st>` <st c=\"73855\">documents:</st>\n\n```", "```py\n\n\t\t\t<st c=\"74150\">The</st> `<st c=\"74155\">insert_login()</st>` <st c=\"74169\">method uses the</st> `<st c=\"74186\">save()</st>` <st c=\"74192\">method of the</st> `<st c=\"74207\">TutorLogin</st>` <st c=\"74217\">model object for persistence.</st> <st c=\"74248\">The</st> `<st c=\"74252\">save()</st>` <st c=\"74258\">method will persist all the</st> `<st c=\"74287\">kwargs</st>` <st c=\"74293\">data that’s passed to the constructor</st> <st c=\"74332\">of</st> `<st c=\"74335\">TutorLogin</st>`<st c=\"74345\">.</st>\n\t\t\t<st c=\"74346\">Like the Cassandra</st> <st c=\"74365\">driver, the</st> `<st c=\"74378\">Document</st>` <st c=\"74386\">class has an</st> `<st c=\"74400\">objects</st>` <st c=\"74407\">class attribute that provides all query methods.</st> <st c=\"74457\">Updating a document uses the</st> `<st c=\"74486\">objects</st>` <st c=\"74493\">attribute to filter the data using any document keys and then fetches the record using the attribute’s</st> `<st c=\"74597\">get()</st>` <st c=\"74602\">method.</st> <st c=\"74611\">If the document exists, the</st> `<st c=\"74639\">update()</st>` <st c=\"74647\">method of the filtered record object will update the given</st> `<st c=\"74707\">kwargs</st>` <st c=\"74713\">of fields that require updating.</st> <st c=\"74747\">The following code shows</st> `<st c=\"74772\">update_login()</st>`<st c=\"74786\">, which updates a</st> `<st c=\"74804\">TutorLogin</st>` <st c=\"74814\">document:</st>\n\n```", "```py\n\n\t\t\t<st c=\"74990\">Deleting a document in MongoDB also uses the</st> `<st c=\"75036\">objects</st>` <st c=\"75043\">attribute to filter and extract the document that needs to be removed.</st> <st c=\"75115\">The</st> `<st c=\"75119\">delete()</st>` <st c=\"75127\">method of the retrieved model object will delete the filtered record from the database once the repository invokes it.</st> <st c=\"75247\">Here,</st> `<st c=\"75253\">delete_login()</st>` <st c=\"75267\">removes a filtered document from</st> <st c=\"75301\">the database:</st>\n\n```", "```py\n\n\t\t\t<st c=\"75447\">The</st> `<st c=\"75452\">objects</st>` <st c=\"75459\">attribute is responsible</st> <st c=\"75484\">for implementing all the query transactions.</st> <st c=\"75530\">Here,</st> `<st c=\"75536\">get_login()</st>` <st c=\"75547\">fetches a single object identified by its unique</st> `<st c=\"75597\">_id</st>` <st c=\"75600\">value using the</st> `<st c=\"75617\">get()</st>` <st c=\"75622\">method, while the</st> `<st c=\"75641\">get_login_username()</st>` <st c=\"75661\">transaction retrieves a single record filtered by the tutor’s username and password.</st> <st c=\"75747\">On the other hand,</st> `<st c=\"75766\">get_all_login()</st>` <st c=\"75781\">retrieves all the</st> `<st c=\"75800\">tutor_login</st>` <st c=\"75811\">documents from</st> <st c=\"75827\">the database:</st>\n\n```", "```py\n\n\t\t\t<st c=\"76173\">All these query transactions invoke the built-in</st> `<st c=\"76223\">to_json()</st>` <st c=\"76232\">method, which serializes and converts the BSON-based documents into JSON for the API’s response</st> <st c=\"76329\">generation process.</st>\n\t\t\t<st c=\"76348\">Embedded documents do not have dedicated collection storage because they are part of a parent document collection.</st> <st c=\"76464\">Adding and removing embedded documents from the parent document requires using string queries and operators or typical object referencing in Python, such as setting to</st> `<st c=\"76632\">None</st>` <st c=\"76636\">when removing a sub-document.</st> <st c=\"76667\">The following repository adds</st> <st c=\"76696\">and removes a tutor’s profile details from the</st> <st c=\"76744\">login credentials:</st>\n\n```", "```py\n\n\t\t\t<st c=\"77129\">Here,</st> `<st c=\"77136\">add_tutor_profile()</st>` <st c=\"77155\">embeds the</st> `<st c=\"77167\">TutorProfile</st>` <st c=\"77179\">document via the tutor key of the</st> `<st c=\"77214\">TutorLogin</st>` <st c=\"77224\">main document.</st> <st c=\"77240\">Another solution is to pass the</st> `<st c=\"77272\">set_tutor=profile</st>` <st c=\"77289\">query parameter to the</st> `<st c=\"77313\">update()</st>` <st c=\"77321\">operation.</st> <st c=\"77333\">The following transaction removes the tutor</st> <st c=\"77376\">profile from the</st> <st c=\"77394\">main document:</st>\n\n```", "```py\n\n\t\t\t<st c=\"77583\">Then,</st> `<st c=\"77590\">delete_tutor_profile()</st>` <st c=\"77612\">unsets the profile document from the</st> `<st c=\"77650\">TutorLogin</st>` <st c=\"77660\">document by setting the tutor field to</st> `<st c=\"77700\">None</st>`<st c=\"77704\">. Another way to do this is to use the</st> `<st c=\"77743\">unset__tutor=True</st>` <st c=\"77760\">query parameter for the</st> `<st c=\"77785\">update()</st>` <st c=\"77793\">method.</st>\n\t\t\t<st c=\"77801\">The most effective way to manage a list of embedded documents is to use query strings or query parameters to avoid lengthy implementations.</st> <st c=\"77942\">The following</st> `<st c=\"77956\">SavingsRepository</st>` <st c=\"77973\">class adds and removes a bank account from a list of savings accounts of a tutor.</st> <st c=\"78056\">Its</st> `<st c=\"78060\">add_savings()</st>` <st c=\"78073\">method adds a new saving account to the tutor’s list of saving accounts.</st> <st c=\"78147\">It uses the</st> `<st c=\"78159\">update()</st>` <st c=\"78167\">method with the</st> `<st c=\"78184\">push__tutor__savings=savings</st>` <st c=\"78212\">query parameter, which pushes a new</st> `<st c=\"78249\">Savings</st>` <st c=\"78256\">instance to</st> <st c=\"78269\">the list:</st>\n\n```", "```py\n\n\t\t\t<st c=\"78645\">On the other hand, the</st> `<st c=\"78669\">delete_savings()</st>` <st c=\"78685\">method deletes an account using the</st> `<st c=\"78722\">pull__tutor__savings__acct_number= details['acct_number']</st>` <st c=\"78779\">query parameter, which removes a savings account from</st> <st c=\"78834\">the list:</st>\n\n```", "```py\n\n\t\t\t<st c=\"79078\">Although MongoDB is popular</st> <st c=\"79106\">and has the most support, it slows down when the number of users increases.</st> <st c=\"79183\">When the datasets become massive, adding more replications and configurations becomes difficult due to its master-slave architecture.</st> <st c=\"79317\">Adding caches is also part of the plan to improve</st> <st c=\"79367\">data retrieval.</st>\n\t\t\t<st c=\"79382\">However, there is another document-oriented NoSQL database that’s designed for distributed architecture and high availability with internal caching for</st> <st c=\"79535\">datasets:</st> **<st c=\"79545\">Couchbase</st>**<st c=\"79554\">.</st>\n\t\t\t<st c=\"79555\">Managing key-based JSON documents with Couchbase</st>\n\t\t\t**<st c=\"79604\">Couchbase</st>** <st c=\"79614\">is a NoSQL database that’s designed</st> <st c=\"79650\">for distributed architectures</st> <st c=\"79680\">and offers high performance on concurrent, web-based, and cloud-based applications.</st> <st c=\"79765\">It</st> <st c=\"79767\">supports distributed</st> **<st c=\"79789\">ACID</st>** <st c=\"79793\">transactions and has a</st> <st c=\"79816\">SQL-like language called</st> **<st c=\"79842\">N1QL</st>**<st c=\"79846\">. All documents stored in Couchbase databases</st> <st c=\"79892\">are JSON-formatted.</st>\n\t\t\t<st c=\"79911\">Now, let’s install and configure the Couchbase</st> <st c=\"79959\">database server.</st>\n\t\t\t<st c=\"79975\">Installing and configuring the database instance</st>\n\t\t\t<st c=\"80024\">To begin, download</st> <st c=\"80043\">Couchbase Community Edition from</st> [<st c=\"80077\">https://www.couchbase.com/downloads/</st>](https://www.couchbase.com/downloads/)<st c=\"80113\">. Once it’s been installed, Couchbase will need cluster</st> <st c=\"80168\">configuration details</st> <st c=\"80190\">to be added, including the user profile for accessing the server dashboard at</st> `<st c=\"80269\">http://localhost:8091/ui/index.html</st>`<st c=\"80304\">. Accepting the user agreement for the configuration is also part of the process.</st> <st c=\"80386\">After configuring the cluster, the URL will show us the login form to access the default server instance.</st> *<st c=\"80492\">Figure 7</st>**<st c=\"80500\">.16</st>* <st c=\"80503\">shows the login page of the Couchbase</st> <st c=\"80542\">web portal:</st>\n\t\t\t![Figure 7.16 – Accessing the login page of Couchbase](img/B19383_07_016.jpg)\n\n\t\t\t<st c=\"80601\">Figure 7.16 – Accessing the login page of Couchbase</st>\n\t\t\t<st c=\"80652\">After logging in to the portal, the next step is to create a</st> *<st c=\"80714\">bucket</st>*<st c=\"80720\">. A</st> *<st c=\"80724\">bucket</st>* <st c=\"80730\">is a named container that saves all the data in Couchbase.</st> <st c=\"80790\">It groups all the keys and values based on collections and scopes.</st> <st c=\"80857\">Somehow, it is similar to the concept of a database schema in a relational DBMS.</st> *<st c=\"80938\">Figure 7</st>**<st c=\"80946\">.17</st>* <st c=\"80949\">shows</st> **<st c=\"80956\">packtbucket</st>**<st c=\"80967\">, which has been created on the</st> **<st c=\"80999\">Buckets</st>** <st c=\"81006\">dashboard:</st>\n\t\t\t![Figure 7.17 – Creating a bucket in the cluster](img/B19383_07_017.jpg)\n\n\t\t\t<st c=\"81241\">Figure 7.17 – Creating a bucket in the cluster</st>\n\t\t\t<st c=\"81287\">Afterward, create a scope</st> <st c=\"81313\">that will hold the tables or document</st> <st c=\"81352\">collections of the database instance.</st> <st c=\"81390\">A bucket scope is a named mechanism that manages and organizes these collections.</st> <st c=\"81472\">In some aspects, it is similar to a tablespace in a relational DBMS.</st> <st c=\"81541\">To create these scopes, click the</st> **<st c=\"81575\">Scopes & Collections</st>** <st c=\"81595\">hyperlink to the right of the bucket name on the</st> **<st c=\"81645\">Add Bucket</st>** <st c=\"81655\">page.</st> <st c=\"81662\">The</st> **<st c=\"81666\">Add Scope</st>** <st c=\"81675\">page will appear, as shown in</st> *<st c=\"81706\">Figure 7</st>**<st c=\"81714\">.18</st>*<st c=\"81717\">:</st>\n\t\t\t![Figure 7.18 – Creating a scope in a bucket](img/B19383_07_018.jpg)\n\n\t\t\t<st c=\"81968\">Figure 7.18 – Creating a scope in a bucket</st>\n\t\t\t<st c=\"82010\">On the</st> `<st c=\"82134\">tfs</st>`<st c=\"82137\">.</st>\n\t\t\t<st c=\"82138\">Lastly, click the</st> `<st c=\"82342\">tfs</st>` <st c=\"82345\">collections:</st>\n\t\t\t![Figure 7.19 – List of collections in a tfs scope](img/B19383_07_019.jpg)\n\n\t\t\t<st c=\"82943\">Figure 7.19 – List of collections in a tfs scope</st>\n\t\t\t<st c=\"82991\">Now, let’s establish the bucket connection using the</st> `<st c=\"83045\">couchbase</st>` <st c=\"83054\">module.</st>\n\t\t\t<st c=\"83062\">Setting up the server connection</st>\n\t\t\t<st c=\"83095\">To create a client connection</st> <st c=\"83125\">to Couchbase, install the</st> `<st c=\"83152\">couchbase</st>` <st c=\"83161\">module using the</st> `<st c=\"83179\">pip</st>` <st c=\"83182\">command:</st>\n\n```", "```py\n\n\t\t\t<st c=\"83213\">In the</st> `<st c=\"83221\">create_app()</st>` <st c=\"83233\">factory function of the application, perform the following steps to access the Couchbase</st> <st c=\"83323\">server instance:</st>\n\n\t\t\t\t1.  <st c=\"83339\">Create a</st> `<st c=\"83349\">PasswordAuthenticator</st>` <st c=\"83370\">object with the correct user profile’s credential to access the</st> <st c=\"83435\">specified bucket.</st>\n\t\t\t\t2.  <st c=\"83452\">Instantiate the</st> `<st c=\"83469\">Cluster</st>` <st c=\"83476\">class with its required constructor arguments, namely the Couchbase URL and some options, such as the</st> `<st c=\"83579\">PasswordAuthenticator</st>` <st c=\"83600\">object, wrapped in the</st> `<st c=\"83624\">ClusterOptions</st>` <st c=\"83638\">instance.</st>\n\t\t\t\t3.  <st c=\"83648\">Access the preferred bucket by calling the</st> `<st c=\"83692\">Cluster</st>`<st c=\"83699\">’s</st> `<st c=\"83703\">bucket()</st>` <st c=\"83711\">instance method.</st>\n\n\t\t\t<st c=\"83728\">The following snippet shows</st> <st c=\"83756\">how to implement these steps in our</st> *<st c=\"83793\">Tutor Finder</st>* <st c=\"83805\">application’s</st> `<st c=\"83820\">create_app()</st>` <st c=\"83832\">method:</st>\n\n```", "```py\n class DirectMessageRepository:\n    def insert_dm(self, details:Dict[str, Any]):\n        try: <st c=\"85245\">cb_coll = cb.scope(\"tfs\")</st> <st c=\"85270\">.collection(\"direct_messages\")</st> key = \"chat_\" + str(details['id']) + '-' + str(details[\"date_sent\"]) <st c=\"85370\">cb_coll.insert(key, details)</st> return True\n        except Exception as e:\n            print(e)\n        return False\n```", "```py\n def update_dm(self, details:Dict[str, Any]):\n        try: <st c=\"85905\">cb_coll = cb.scope(\"tfs\")</st> <st c=\"85930\">.collection(\"direct_messages\")</st> key = \"chat_\" + str(details['id']) + '-' + str(details[\"date_sent\"]) <st c=\"86030\">cb_coll.upsert(key, details)</st> return True\n        except Exception as e:\n            print(e)\n        return False\n```", "```py\n def delete_dm_key(self, details:Dict[str, Any]):\n        try: <st c=\"86350\">cb_coll = cb.scope(\"tfs\")</st> <st c=\"86375\">.collection(\"direct_messages\")</st> key = \"chat_\" + str(details['id']) + '-' + str(details[\"date_sent\"]) <st c=\"86475\">cb_coll.remove(key)</st> return True\n        except Exception as e:\n            print(e)\n        return False\n```", "```py\n def delete_dm_sender(self, sender):\n        try: <st c=\"86791\">cb_scope = cb.scope(\"tfs\")</st><st c=\"86817\">stmt = f\"delete from `direct_messages` where</st> <st c=\"86862\">`sender_id` LIKE '{sender}'\"</st><st c=\"86891\">cb_scope.query(stmt)</st> return True\n        except Exception as e:\n            print(e)\n        return False\n```", "```py<st c=\"87190\">``</st>```", "```py\n def delete_dm_sender(self, sender):\n        try:\n            cb_scope = cb.scope(\"tfs\")\n            stmt = f\"delete from `direct_messages` where `sender_id` LIKE '{sender}'\"\n            cb_scope.query(stmt)\n            return True\n        except Exception as e:\n            print(e)\n        return False\n```", "```py\n def select_all_dm(self):\n        cb_scope = cb.scope(\"tfs\")\n        raw_data = cb_scope.query('select * from `direct_messages`', QueryOptions(read_only=True))\n        records = [rec for rec in raw_data.rows()]\n        return records\n```", "```py\n pip install py2neo\n```", "```py\n<st c=\"90650\">from py2neo import Graph</st> def db_auth(): <st c=\"90691\">graph = Graph(\"bolt://127.0.0.1:7687\", auth=(\"neo4j\",</st> <st c=\"90744\">\"packt2255\"))</st> return graph\n```", "```py\n<st c=\"91587\">from main import graph</st>\n<st c=\"91610\">from py2neo import Node, NodeMatcher, Subgraph, Transaction</st>\n<st c=\"91670\">from py2neo.cypher import Cursor</st> from typing import Any, Dict\nclass StudentNodeRepository:\n    def __init__(self):\n        pass\n    def insert_student_node(self, details:Dict[str, Any]):\n        try: <st c=\"91847\">tx:Transaction = graph.begin()</st><st c=\"91877\">node_trainer = Node(\"Tutor\", **details)</st><st c=\"91917\">graph.create(node_trainer)</st><st c=\"91944\">graph.commit(tx)</st> return True\n        except Exception as e:\n            print(e)\n        return False\n```", "```py\n def update_student_node(self, details:Dict[str, Any]):\n        try: <st c=\"92835\">tx = graph.begin()</st><st c=\"92853\">matcher = NodeMatcher(graph)</st><st c=\"92882\">student_node:Node  = matcher.match('Student',</st> <st c=\"92927\">student_id=details['student_id']).first()</st> if not student_node == None:\n                del details['student_id'] <st c=\"93025\">student_node.update(**details)</st><st c=\"93055\">graph.push(student_node)</st><st c=\"93080\">graph.commit(tx)</st> return True\n            else:\n                return False\n        except Exception as e:\n            print(e)\n        return False\n```", "```py\n def delete_student_node(self, student_id:str):\n        try: <st c=\"94074\">tx = graph.begin()</st><st c=\"94092\">student_cur:Cursor = graph.query(f\"MATCH</st> <st c=\"94133\">(st:Student) WHERE st.student_id =</st> <st c=\"94168\">'{student_id}' Return st\")</st><st c=\"94195\">student_sg:Subgraph = student_cur.to_subgraph()</st><st c=\"94243\">graph.delete(student_sg)</st><st c=\"94268\">graph.commit(tx)</st> return True\n        except Exception as e:\n            print(e)\n        return False\n```", "```py\n def get_student_node(self, student_id:str): <st c=\"95063\">matcher = NodeMatcher(graph)</st><st c=\"95091\">student_node:Node  = matcher.match('Student',</st> <st c=\"95136\">student_id=student_id).first()</st><st c=\"95167\">record = dict(student_node)</st> return record\n    def select_student_nodes(self): <st c=\"95242\">student_cur:Cursor = graph.query(f\"MATCH (st:Student)</st> <st c=\"95295\">Return st\")</st> records = student_cur.data()\n        return records\n```", "```py\n\n```", "```py\n\n```", "```py\n\n```"]