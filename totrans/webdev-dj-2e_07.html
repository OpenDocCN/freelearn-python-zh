<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-214"><a id="_idTextAnchor229"/>7. Advanced Form Validation and Model Forms</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">Continuing your journey with the Bookr application, you will begin this chapter by adding a new form to your app with custom multi-field validation and form cleaning. You will learn how to set the initial values on your form and customize the widgets (the HTML input elements that are being generated). Then you will be introduced to the <code>ModelForm</code> class, which allows a form to be automatically created from a model. You will use it in a view to automatically save the new or changed <code>Model</code> instance.</p>
			<p class="callout">By the end of this chapter, you will know how to add extra multi-field validation to Django forms, how to customize and set form widgets for fields, how to use <code>ModelForms</code> to automatically create a form from a Django model, and how to automatically create <code>Model</code> instances from <code>ModelForms</code>.</p>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor230"/>Introduction</h1>
			<p>This chapter builds upon the knowledge we gained in <em class="italic">Chapter 6</em>, <em class="italic">Forms</em>, where we learned how to submit data from an HTML form to a Django view, both with a manually built HTML form and with a Django form. We used Django's <code>form</code> library to build and automatically validate forms with basic validation. For example, now we can build forms that check whether a date is entered in its desired format, whether a number is input where a user must enter their age, and whether a dropdown is selected before the user clicks the <code>Submit</code> button. However, most large-scale websites require validation that is a bit more advanced.</p>
			<p>For instance, a certain field might only be required if another field is set. Let's say we want to add a checkbox to allow users to sign up for our monthly newsletter. It has a textbox below it that lets them enter their email address. With some basic validation, we can check whether:</p>
			<ul>
				<li>The user has checked the checkbox.</li>
				<li>The user has entered their email address. </li>
			</ul>
			<p>When the user clicks the <code>Submit</code> button, we will be able to validate whether both fields are actioned. But what if the user doesn't want to sign up for our newsletter? If they click the <code>Submit</code> button, ideally, both fields should be blank. That's where validating each individual field might not work. </p>
			<p>Another example could be a case where we have two fields and each has a maximum value of, say, 50. But the total of values added to each one must be less than 75. We will start the chapter by looking at how to write custom validation rules to solve such problems.</p>
			<p>Later, as we progress in the chapter, we will look at how to set initial values on a form. This can be useful when automatically filling out information that is already known to the user. For example, we can automatically put a user's contact information into a form if that user is logged in.</p>
			<p>We will finish the chapter by looking at model forms, which will let us automatically create a form from a Django <code>Model</code> class. This cuts down the amount of code that needs to be written to create a new <code>Model</code> instance.</p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor231"/>Custom Field Validation and Cleaning</h1>
			<p>We have seen how a Django form converts values from an HTTP request, which are strings, into Python objects. In a non-custom Django form, the target type is dependent on the field class. For example, the Python type derived from <code>IntegerField</code> is <code>int</code>, and string values are given to us verbatim, as the user entered them. But we can also implement methods on our <code>Form</code> class to alter the output values from our fields in any way we choose. The allows us to clean or filter the user's input data to fit what we expect better. We could round an integer to the nearest multiple of ten to fit into a batch size for ordering specific items. Or we could transform an email address to lowercase so that the data is consistent for searching.</p>
			<p>We can also implement some custom validators. We will look at a couple of different ways of validating fields: by writing a custom validator, and by writing a custom <code>clean</code> method for the field. Each method has its pros and cons: a custom validator can be applied to different fields and forms, so you do not have to write the validation logic for each field; a custom <code>clean</code> method must be implemented on each form you want to clean, but is more powerful and allows validation using other fields in the form or changing the cleaned value that the field returns.</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor232"/>Custom Validators</h2>
			<p>A validator is simply a function that accepts a value and raises <code>django.core.exceptions.ValidationError</code> if the value is invalid – the validity is determined by the code you write. The value is a Python object (that is, <code>cleaned_data</code> that has already been converted from the <code>POST</code> request string).</p>
			<p>Here is a simple example that validates whether a value is lowercase:</p>
			<pre>from django.core.exceptions import ValidationError
def validate_lowercase(value):
  if value.lower() != value:
    raise ValidationError("{} is not lowercase."\
                          .format(value))</pre>
			<p>Notice the function does not return anything, for either success or failure. It will just raise <code>ValidationError</code> if the value is not valid.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Note that the behavior and handling of <code>ValidationError</code> differ from how other exceptions behave in Django. Normally, if you raise an exception in your view, you will end up with a <code>500</code> response from Django (if you do not handle the exception in your code). </p>
			<p class="callout">When raising <code>ValidationError</code> in your validation/cleaning code, the Django <code>form</code> class will catch the error for you and then the <code>is_valid</code> method of <code>form</code> will return <code>False</code>. You do not have to write <code>try</code>/<code>except</code> handlers around the code that might raise <code>ValidationError</code>.</p>
			<p>The validator can be passed to the <code>validators</code> argument of a field constructor on a form, inside a list; for example, to our <code>text_input</code> field from our <code>ExampleForm</code>:</p>
			<pre>class ExampleForm(forms.Form):
  text_input = forms.CharField(validators=[validate_lowercase])</pre>
			<p>Now, if we submit the form and the fields contain uppercase values, we will get an error, as shown in the following figure:</p>
			<div><div><img src="img/B15509_07_01.jpg" alt="Figure 7.1: Lowercase text validator in action&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1: Lowercase text validator in action</p>
			<p>The validator function can be used on any number of fields. In our example, if we wanted lots of fields to have lowercase enforced, <code>validate_lowercase</code> could be passed to all of them. Let's now look at how we could implement this another way, with a custom <code>clean</code> method. </p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor233"/>Cleaning Methods</h2>
			<p>A <code>clean</code> method is created on the <code>Form</code> class and is named in the format <code>clean_field-name</code>. For example, the <code>clean</code> method for <code>text_input</code> would be called <code>clean_text_input</code>, the <code>clean</code> method for <code>books_you_own</code> would be <code>clean_books_you_own</code>, and so on.</p>
			<p>Cleaning methods take no arguments; instead, they should use the <code>cleaned_data</code> attribute on <code>self</code> to access the field data. This dictionary will contain the data after being cleaned in the standard Django way, as we saw in the previous example. The <code>clean</code> method must return the cleaned value, which will replace the original value in the <code>cleaned_data</code> dictionary. Even if the method does not change the value, a value must be returned. You can also use the <code>clean </code>method to raise <code>ValidationError</code>, and the error will be attached to the field (the same as with a validator).</p>
			<p>Let's re-implement the lowercase validator as a <code>clean</code> method, like this:</p>
			<pre>class ExampleForm(forms.Form):
   text_input = forms.CharField()
  …
  def clean_text_input(self):
    value = self.cleaned_data['text_input']
    if value.lower() != value:
      raise ValidationError("{} is not lowercase."\
                            .format(value))\
    return value</pre>
			<p>You can see the logic is essentially the same, except we must return the validated value at the end. If we submit the form, we get the same result as the previous time we tried (<em class="italic">Figure 7.1</em>).</p>
			<p>Let's look at one more cleaning example. Instead of raising an exception when the value is invalid, we could just convert the value to lowercase. We would implement that with this code:</p>
			<pre>class ExampleForm(forms.Form):
  text_input = forms.CharField()
  …
  def clean_text_input(self):
    value = self.cleaned_data['text_input']
    return value.lower()</pre>
			<p>Now, consider that we enter text into the input as uppercase:</p>
			<div><div><img src="img/B15509_07_02.jpg" alt="Figure 7.2: ALL UPPERCASE text entered&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2: ALL UPPERCASE text entered</p>
			<p>If we were to examine the cleaned data using our debug output from the view, we would see that it is lowercase:</p>
			<div><div><img src="img/B15509_07_03.jpg" alt="Figure 7.3: The cleaned data has been transformed to lowercase&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3: The cleaned data has been transformed to lowercase</p>
			<p>These were just a couple of simple examples of how to validate fields using both validators and <code>clean</code> methods. You can, of course, make each type of validation much more complex if you wish and transform the data in more complex ways using a <code>clean</code> method.</p>
			<p>So far, you have only learned simple methods for form validation, where you have treated each field independently. A field is valid (or not) based only on the information it contains and nothing else. What if the validity of one field depends on what the user entered into another field? An example of this might be that you have an <code>email</code> field to collect someone's email address if they want to be signed up to a mailing list. The field is only required if they check a checkbox that indicates they wanted to be signed up. Neither of these fields is required on their own – we do not want the checkbox to be required to be checked, but if it is checked, then the <code>email</code> field should be required too.</p>
			<p>In the next section, we will show how you can validate a form whose fields depend on each other by overriding the <code>clean</code> method in your form.</p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor234"/>Multi-Field Validation</h2>
			<p>We have just looked at the <code>clean_&lt;field-name&gt;</code> methods that can be added to a Django form, to clean a specific field. Django also allows us to override the <code>clean</code> method, in which we can access all the <code>cleaned_data</code> from all fields, and we know that all custom field methods have been called. This allows the validation of fields based on another field's data.</p>
			<p>Referring to our previous example with a form that has an email address that is only required if a checkbox is checked, we will see how we can implement this using the <code>clean</code> method.</p>
			<p>First, create a <code>Form</code> class and add two fields – make them both optional with the <code>required=False</code> argument:</p>
			<pre>class NewsletterSignupForm(forms.Form):
  signup = forms.BooleanField\
           (label="Sign up to newsletter?", required=False)
  email = forms.EmailField\
          (help_text="Enter your email address to subscribe", \
           required=False)</pre>
			<p>We have also introduced two new arguments that can be used for any field:</p>
			<ul>
				<li><code>label</code><p>This allows setting the label text for a field. As we have seen, Django will automatically generate label text from the field name. If you set the <code>label</code> argument, you can override this default. Use this argument if you want to have a more descriptive label.</p></li>
				<li><code>help_text</code><p>If you need to have more information displayed regarding what input a field requires, you can use this argument. By default, it is displayed after the field.</p></li>
			</ul>
			<p>When rendered, the form looks like this:</p>
			<p> </p>
			<div><div><img src="img/B15509_07_04.jpg" alt="Figure 7.4: Email signup form with custom label and help text&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4: Email signup form with custom label and help text</p>
			<p>If we were to submit the form now, without entering any data, nothing would happen. Neither field is required, so the form validates fine.</p>
			<p>Now we can add the multi-field validation to the <code>clean</code> method. We will check whether the <code>signup</code> checkbox is checked, and then check that the <code>email</code> field has a value. The built-in Django methods have already validated that the email address is valid at this point, so we then just need to check that a value exists for it. We will then use the <code>add_error</code> method to set an error for the <code>email</code> field. This is a method you haven't seen before but it's very simple; it takes two arguments – the name of the field to set the error on, and the text of the error.</p>
			<p>Here is the code for the <code>clean</code> method:</p>
			<pre>class NewsletterSignupForm(forms.Form):
  …
  def clean(self):
    cleaned_data = super().clean()
    if cleaned_data["signup"] and not cleaned_data.get("email"):
    self.add_error\
    ("email", \
     "Your email address is required if signing up for the newsletter.")</pre>
			<p>Your <code>clean</code> method must always call the <code>super().clean()</code> method to retrieve the cleaned data. When <code>add_error</code> is called to add errors to the form, the form will no longer validate (the <code>is_valid</code> method returns <code>False</code>).</p>
			<p>Now if we submit the form without the checkbox checked, there is still no error generated, but if you check the checkbox without an email address, you will receive the error we just wrote the code for:</p>
			<div><div><img src="img/B15509_07_05.jpg" alt="Figure 7.5: Error displayed when attempting to sign up with no email address&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5: Error displayed when attempting to sign up with no email address</p>
			<p>You might notice that we are retrieving the email from the <code>cleaned_data</code> dictionary using the <code>get</code> method. The reason for doing this is if the <code>email</code> value in the form is invalid, then the <code>email</code> key will not exist in the dictionary. The browser should prevent the user from submitting the form if an invalid email has been entered, but a user might be using an older browser that does not support this client-side validation, so for safety, we use the <code>get</code> method. Since the <code>signup</code> field is <code>BooleanField</code>, and not required, it will only be invalid if a custom validation function is used. We are not using one here, so it is safe to access its value using square bracket notation.</p>
			<p>There is one more validation scenario to consider before moving on to our first exercise, and that is adding errors that are not specific to any field. Django calls these <em class="italic">non-field errors</em>. There are many scenarios where you might want to use these when multiple fields are dependent on each other. </p>
			<p>Take, for example, a shopping website. Your order form could have two numeric fields whose totals could not exceed a certain value. If the total were exceeded, the value of either field could be decreased to bring the total below the maximum value, so the error is not specific to either one of the fields. To add a non-field error, call the <code>add_error</code> method with <code>None</code> as the first argument.</p>
			<p>Let us look at how to implement this. In this example, we will have a form where the user can specify a certain number of items to order, for item A or item B. The user cannot order more than 100 items in total. The fields will have a <code>max_value</code> of <code>100</code>, and <code>min_value</code> of <code>0</code>, but custom validation in the <code>clean</code> method will need to be written to handle the validation of the total amount:</p>
			<pre>class OrderForm(forms.Form):
  item_a = forms.IntegerField(min_value=0, max_value=100)
  item_b = forms.IntegerField(min_value=0, max_value=100)\
  def clean(self):
    cleaned_data = super().clean()
    if cleaned_data.get("item_a", 0) + cleaned_data.get\
                                       ("item_b", 0) &gt; 100:
      self.add_error\
      (None, \
       "The total number of items must be 100 or less.")</pre>
			<p>The fields (<code>item_a</code> and <code>item_b</code>) are added in the normal way, with standard validation rules. You can see that we have used the <code>clean</code> method the same way we used it before. Moreover, we have implemented the maximum item logic inside this method. The following line is what registers the non-field error if the maximum items are exceeded:</p>
			<pre>self.add_error(None, \
               "The total number of items must be 100 or less.")</pre>
			<p>Once again, we access the values of <code>item_a</code> and <code>item_b</code> using the <code>get</code> method, with a default value of <code>0</code>. This is in case the user has an older browser (from 2011 or earlier) and was able to submit the form with invalid values.</p>
			<p>In a browser, the field-level validation ensures values between 0 and 100 have been entered in each field, and prevents the form from being submitted otherwise:</p>
			<div><div><img src="img/B15509_07_06.jpg" alt="Figure 7.6: The form cannot be submitted if one field exceeds the maximum value&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6: The form cannot be submitted if one field exceeds the maximum value</p>
			<p>However, if we put in two values that sum to more than 100, we can see how Django displays the non-field error:</p>
			<div><div><img src="img/B15509_07_07.jpg" alt="Figure 7.7: Django non-field error displayed at the start of the form&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7: Django non-field error displayed at the start of the form</p>
			<p>Django non-field errors are always displayed at the start of a form, before other fields or errors. In the next exercise, we will build a form that implements a validation function, a field clean method, and a form clean method.</p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor235"/>Exercise 7.01: Custom Clean and Validation Methods</h2>
			<p>In this exercise, you will build a new form that allows the user to create an order for books or magazines. It must have the following validation criteria:</p>
			<ul>
				<li>The user may order up to 80 magazines and/or 50 books, but the total number of items must not be more than 100. </li>
				<li>The user can choose to receive an order confirmation, and if they do, they must enter an email address.</li>
				<li>The user should not enter an email address if they have not chosen to receive an order confirmation.</li>
				<li>To ensure they are part of our company, the email address must be part of our company domain (in our case, we will just use <code>example.com</code>). </li>
				<li>For consistency with other email addresses in our fictional company, the address should be converted to lowercase. </li>
			</ul>
			<p>This sounds like a lot of rules, but with Django, it is simple if we tackle them one by one. We will carry on with the <code>form_project</code> app we started in <em class="italic">Chapter 6</em>, <em class="italic">Forms</em>. If you haven't completed <em class="italic">Chapter 6</em>, <em class="italic">Forms</em>, you can download the code from <a href="http://packt.live/2LRCczP">http://packt.live/2LRCczP</a>:</p>
			<ol>
				<li>In PyCharm, open the <code>form_example</code> app's <code>forms.py</code> file. <p class="callout-heading">Note</p><p class="callout">Make sure the Django dev server is not running, otherwise, it may crash as you make changes to this file, causing PyCharm to jump into the debugger.</p></li>
				<li>Since our work with <code>ExampleForm</code> is done, you can remove it from this file.</li>
				<li>Create a new class called <code>OrderForm</code> that inherits from <code>forms.Form</code>:<pre>class OrderForm(forms.Form):</pre></li>
				<li>Add four fields to the class as follows:<ul><li><code>magazine_count,</code> <code>IntegerField</code> with <code>min_value</code> of <code>0</code> and <code>max_value</code> of <code>80</code></li><li><code>book_count</code>, <code>IntegerField</code> with <code>min_value</code> of <code>0</code> and <code>max_value</code> of <code>50</code></li><li><code>send_confirmation</code>, <code>BooleanField</code>, which is not required</li><li><code>email</code>, <code>EmailField</code>, which is also not required<p>The class should look like this:</p><pre>class OrderForm(forms.Form):
  magazine_count = forms.IntegerField\
                   (min_value=0, max_value=80)
  book_count = forms.IntegerField\
               (min_value=0, max_value=50)
  send_confirmation = forms.BooleanField\
                      (required=False)
  email = forms.EmailField(required=False)</pre></li></ul></li>
				<li>Add a validation function to check that the user's email address is on the right domain. First, <code>ValidationError</code> needs to be imported; add this line at the top of the file:<pre>from django.core.exceptions import ValidationError</pre><p>Then write this function after the <code>import</code> line (before the <code>OrderForm</code> class implementation):</p><pre>def validate_email_domain(value):
  if value.split("@")[-1].lower()!= "example.com":\
      raise ValidationError\
      ("The email address must be on the domain example.com.")</pre><p>The function splits the email address on the <code>@</code> symbol, then checks whether the part after it is equal to <code>example.com</code>. This function alone would validate non-email addresses. For example, the string <code>not-valid@someotherdomain@example.com</code> would not cause <code>ValidationError</code> to be raised in this function. This is acceptable in our case because as we are using <code>EmailField</code>, the other standard field validators will check the email address validity.</p></li>
				<li>Add the <code>validate_email_domain</code> function as a validator to the <code>email</code> field on <code>OrderForm</code>. Update the <code>EmailField</code> constructor call to add a <code>validators</code> argument, passing in a list containing the validation function:<pre>class OrderForm(forms.Form):
  …
  <strong class="bold">email = forms.EmailField\</strong>
<strong class="bold">          (required=False, \</strong>
<strong class="bold">           validators=[validate_email_domain])</strong></pre></li>
				<li>Add a <code>clean_email</code> method to the form to make sure the email address is lowercase:<pre>class OrderForm(forms.Form):
  # truncated for brevity
  <strong class="bold">def clean_email(self):</strong>
<strong class="bold">  return self.cleaned_data['email'].lower()</strong></pre></li>
				<li>Now, add the <code>clean</code> method to perform all the cross-field validation. First, we will just add the logic for making sure that an email address is only entered if an order confirmation is requested:<pre>class OrderForm(forms.Form):
  # truncated for brevity
<code>email</code> field if <code>Send confirmation</code> is checked but no email address is added: </p><div><img src="img/B15509_07_08.jpg" alt="Figure 7.8: Error if Send confirmation is checked but no email address is added&#13;&#10;"/></div><p class="figure-caption">Figure 7.8: Error if Send confirmation is checked but no email address is added</p><p>Similarly, an error will be added to <code>email</code> if an email address is entered but <code>Send confirmation</code> is not checked:</p><div><img src="img/B15509_07_09.jpg" alt="Figure 7.9: Error because an email has been entered but the user &#13;&#10;has not chosen to receive confirmation&#13;&#10;"/></div><p class="figure-caption">Figure 7.9: Error because an email has been entered but the user has not chosen to receive confirmation</p></li>
				<li>Add the final check, also inside the <code>clean</code> method. The total number of items should not be more than 100. We will add a non-field error if the sum of <code>magazine_count</code> and <code>book_count</code> is greater than 100:<pre>class OrderForm(forms.Form):
  …
  def clean(self):
    …
    <code>None</code> as the first argument to the <code>add_error</code> call.</p><p class="callout-heading">Note</p><p class="callout">Refer to <a href="http://packt.live/3nMP3R7">http://packt.live/3nMP3R7</a> for the complete code.</p><p>Save <code>forms.py</code>.</p></li>
				<li>Open the <code>reviews</code> app's <code>views.py</code> file. We will change the form <code>import</code> so that <code>OrderForm</code> is being imported instead of <code>ExampleForm</code>. Consider the following import line:<pre>from .forms import ExampleForm, SearchForm</pre><p>Change it as follows:</p><pre>from .forms import OrderForm, SearchForm</pre></li>
				<li>In the <code>form_example</code> view, change the two lines that use <code>ExampleForm</code> to use <code>OrderForm</code> instead. Consider the following line of code:<pre>form = ExampleForm(request.POST)</pre><p>Change this as follows:</p><pre>form = OrderForm(request.POST)</pre><p>Similarly, consider the following line of code:</p><pre>form = ExampleForm()</pre><p>Change this as follows:</p><pre>form = OrderForm()</pre><p>The rest of the function can stay as it is.</p><p>We don't have to make changes to the template. Start the Django dev server and navigate to <code>http://127.0.0.1:8000/form-example/</code> in your browser. You should see the form rendered as in <em class="italic">Figure 7.10</em>:</p><div><img src="img/B15509_07_10.jpg" alt="Figure 7.10: OrderForm in the browser&#13;&#10;"/></div><p class="figure-caption">Figure 7.10: OrderForm in the browser</p></li>
				<li>Try submitting the form with a <code>Magazine count</code> of <code>80</code> and <code>Book count</code> of <code>50</code>. The browser will allow this, but as they sum to more than 100, an error will be triggered by the <code>clean</code> method in the form and displayed on the page:<div><img src="img/B15509_07_11.jpg" alt="Figure 7.11: A non-field error displayed on the form when &#13;&#10;the maximum number of allowed items is exceeded&#13;&#10;"/></div><p class="figure-caption">Figure 7.11: A non-field error displayed on the form when the maximum number of allowed items is exceeded</p></li>
				<li>Try submitting the form with <code>Send confirmation</code> checked but the <code>Email</code> field blank. Then fill the <code>Email</code> textbox but uncheck <code>Send confirmation</code>. Either combination will give an error that both must be present. The error will differ based on which field is missing:<div><img src="img/B15509_07_12.jpg" alt="Figure 7.12: Error message if no email address is present&#13;&#10;"/></div><p class="figure-caption">Figure 7.12: Error message if no email address is present</p></li>
				<li>Now try submitting the form with <code>Send confirmation</code> checked and an email address that is on the <code>example.com</code> domain. You should receive a message that your email address must have the domain <code>example.com</code>. You should also receive a message that <code>email</code> must be set – since email does not end up in the <code>cleaned_data</code> dictionary, as it is not valid:<div><img src="img/B15509_07_13.jpg" alt="Figure 7.13: The error message is shown when the email domain is not example.com&#13;&#10;"/></div><p class="figure-caption">Figure 7.13: The error message is shown when the email domain is not example.com</p></li>
				<li>Finally, enter valid values for <code>Magazine count</code> and <code>Book count</code> (such as <code>20</code> and <code>20</code>). Check <code>Send confirmation</code>, and enter <code>UserName@Example.Com</code> as the email (make sure you match the letter case, including the mixed uppercase and lowercase characters):<div><img src="img/B15509_07_14.jpg" alt="Figure 7.14: The form after being submitted with valid values&#13;&#10;"/></div><p class="figure-caption">Figure 7.14: The form after being submitted with valid values</p></li>
				<li>Switch to PyCharm and look in the debug console. You'll see that the email has been converted to lowercase when it is printed by our debug code:<div><img src="img/B15509_07_15.jpg" alt="Figure 7.15: Email in lowercase, as well as other fields&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 7.15: Email in lowercase, as well as other fields</p>
			<p>This is our <code>clean_email</code> method in action – even though we entered data in both uppercase and lowercase, it has been converted to all lowercase.</p>
			<p>In this exercise, we created a new <code>OrderForm</code> that implemented form and field clean methods. We used a custom validator to ensure that the <code>Email</code> field met our specific validation rules – only a specific domain was allowed. We used a custom field cleaning method (<code>clean_email</code>) to convert the email address to lowercase. We then implemented a <code>clean</code> method to validate the forms that were dependent on each other. In this method, we added both field and non-field errors. In the next section, we will cover how to add placeholders and initial values to the form.</p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor236"/>Placeholders and Initial Values</h2>
			<p>There are two things our first manually built form had that our current Django form still does not have –placeholders and initial values. Adding placeholders is simple; they are just added as an attribute to the widget constructor for the form field. This is similar to what we have already seen for setting the type of <code>DateField</code> in our previous examples.</p>
			<p>Here is an example:</p>
			<pre>class ExampleForm(forms.Form):
  text_field = forms.CharField\
               (widget=forms.TextInput\
               (attrs={"placeholder": "Text Placeholder"}))
  password_field = forms.CharField(\
    widget=forms.PasswordInput\
           (attrs={"placeholder": "Password Placeholder"}))
  email_field = forms.EmailField\
                (widget=forms.EmailInput\
                 (attrs={"placeholder": "Email Placeholder"}))
  text_area = forms.CharField\
              (widget=forms.Textarea\
              (attrs={"placeholder": "Text Area Placeholder"}))</pre>
			<p>This is what the preceding form looks like when rendered in the browser:</p>
			<div><div><img src="img/B15509_07_16.jpg" alt="Figure 7.16: Django form with placeholders&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.16: Django form with placeholders</p>
			<p>Of course, if we are manually setting <code>Widget</code> for each field, we need to know which <code>Widget</code> class to use. The ones that support placeholders are <code>TextInput</code>, <code>NumberInput</code>, <code>EmailInput</code>, <code>URLInput</code>, <code>PasswordInput</code>, and <code>Textarea</code>.</p>
			<p>While we are examining the <code>Form</code> class itself, we will look at the first of two ways of setting an initial value for a field. We can do it by using the <code>initial</code> argument on a <code>Field</code> constructor, like this:</p>
			<pre>text_field = forms.CharField(initial="Initial Value", …)</pre>
			<p>The other method is to pass in a dictionary of data when instantiating the form in our view. The keys are the field names. The dictionary should have zero or more items (that is, an empty dictionary is valid). Any extra keys are ignored. This dictionary should be supplied as the <code>initial</code> argument in our view as follows:</p>
			<pre>initial = {"text_field": "Text Value", \
           "email_field": "user@example.com"}
form = ExampleForm(initial=initial)</pre>
			<p>Or for a <code>POST</code> request, pass in <code>request.POST</code> as the first argument, as usual:</p>
			<pre>initial = {"text_field": "Text Value", \
           "email_field": "user@example.com"}
form = ExampleForm(request.POST, initial=initial)</pre>
			<p>Values in <code>request.POST</code> will override values in <code>initial</code>. This means that even if we have an initial value for a required field, if it is left blank when submitted, then it will not validate. The field will not fall back to the value in <code>initial</code>.</p>
			<p>Whether you decide to set initial values in the <code>Form</code> class itself or the view is up to you and depends on your use case. If you had a form that was used in multiple views but usually had the same value, it would be better to set the <code>initial</code> value in the form. Otherwise, it can be more flexible to use <code>setting</code> in the view.</p>
			<p>In the next exercise, we will add placeholders and initial values to the <code>OrderForm</code> class from the previous exercise.</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor237"/>Exercise 7.02: Placeholders and Initial Values</h2>
			<p>In this exercise, you will enhance the <code>OrderForm</code> class by adding placeholder text. You will simulate passing an initial email address to the form. It will be a hardcoded address, but once the user can log in, it could be an email address associated with their account – you will learn about sessions and authentication in <em class="italic">Chapter 9</em>,<em class="italic"> Sessions and Authentication</em>:</p>
			<ol>
				<li value="1">In PyCharm, open the <code>reviews</code> app's <code>forms.py</code> file. You will add placeholders to the <code>magazine_count</code>, <code>book_count</code>, and <code>email</code> fields on the <code>OrderForm</code>, which means also setting the <code>widget</code>.<p>To the <code>magazine_count</code> field, add a <code>NumberInput</code> <code>widget</code> with <code>placeholder</code> in the <code>attrs</code> dictionary. The <code>placeholder</code> should be set to <em class="italic">Number of Magazines</em>. Write the following code:</p><pre>magazine_count = forms.IntegerField\
                 (min_value=0, max_value=80,\
                  widget=forms.NumberInput\
                  (attrs={"placeholder": "Number of Magazines"}))</pre></li>
				<li>Add a placeholder to the <code>book_count</code> field in the same manner. The placeholder text should be <code>Number of Books</code>:<pre>book_count = forms.IntegerField\
             (min_value=0, max_value=50,\
              widget=forms.NumberInput\
              (attrs={"placeholder": "Number of Books"}))</pre></li>
				<li>The final change to <code>OrderForm</code> is to add a placeholder to the email field. This time the widget is <code>EmailInput</code>. The placeholder text should be <code>Your company email address</code>:<pre>email = forms.EmailField\
        (required=False, validators=[validate_email_domain],\
         widget=forms.EmailInput\
         (attrs={"placeholder": "Your company email address"}))</pre><p>Note that the <code>clean_email</code> and <code>clean</code> methods should remain as they were in <em class="italic">Exercise 7.01, Custom Clean and Validation Methods</em>. Save the file.</p></li>
				<li>Open the <code>reviews</code> app's <code>views.py</code> file. In the <code>form_example</code> view function, create a new dictionary variable called <code>initial</code> with one key, <code>email</code>, like this:<pre>initial = {"email": "user@example.com"}</pre></li>
				<li>In the two places that you are instantiating <code>OrderForm</code>, also pass in the <code>initial</code> variable using the <code>initial</code> kwarg. The first instance is as follows:<pre>form = OrderForm(request.POST, initial=initial)</pre><p>The second instance is as follows:</p><pre>form = OrderForm(initial=initial)</pre><p>The complete code for <code>views.py</code> can be found at <a href="http://packt.live/3szaPM6">http://packt.live/3szaPM6</a>.</p><p>Save the <code>views.py</code> file.</p></li>
				<li>Start the Django dev server if it is not already running. Browse to <code>http://127.0.0.1:8000/form-example/</code> in your browser. You should see that your form now has placeholders and an initial value set:<div><img src="img/B15509_07_17.jpg" alt="Figure 7.17: Order form with initial values and placeholders&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 7.17: Order form with initial values and placeholders</p>
			<p>In this exercise, we added placeholders to form fields. This was done by setting a <code>form</code> widget when defining the <code>form</code> field on the form class and setting a <em class="italic">placeholder</em> value in the <code>attrs</code> dictionary. We also set an initial value for the form using a dictionary and passing it to the <code>form</code> instance using the <code>initial</code> kwarg. </p>
			<p>In the next section, we will talk about how to work with Django models using data from forms, and how <code>ModelForm</code> makes this easier.</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor238"/>Creating or Editing Django Models</h2>
			<p>You have seen how to define a form, and in <em class="italic">Chapter 2</em>, <em class="italic">Models and Migrations</em>, you learned how to create Django model instances. By using these things together, you could build a view that displayed a form and also saved a model instance to the database. This gives you an easy method to save data without having to write a lot of boilerplate code or create custom forms. In Bookr, we will use this method to allow users to add reviews without requiring access to the Django admin site. Without using <code>ModelForm</code>, we could do something like this:</p>
			<ul>
				<li>We can create a form based on an existing model, for example, <code>Publisher</code>. The form would be called <code>PublisherForm</code>.</li>
				<li>We can manually define the fields on <code>PublisherForm</code>, using the same rules defined on the <code>Publisher</code> model, as shown here:<pre>class PublisherForm(forms.Form):
  name = forms.CharField(max_length=50)
  website = forms.URLField()
  …</pre></li>
				<li>In the view, the <code>initial</code> values would be retrieved from the model queried from the database, then passed to the form using the <code>initial</code> argument. If we were creating a new instance, the <code>initial</code> value would be blank – something like this:<pre>if create:
  initial = {}
else:
  publisher = Publisher.objects.get(pk=pk)
  initial = {"name": publisher.name, \
             "website": publisher.website, …}
form = PublisherForm(initial=initial)</pre></li>
				<li>Then, in the <code>POST</code> flow of the view, we can either create or update the model based on <code>cleaned_data</code>:<pre>form = PublisherForm(request.POST, initial=initial)
if create:
  publisher = Publisher()
else:
  publisher = Publisher.objects.get(pk=pk)
publisher.name = form.cleaned_data['name']
publisher.website = forms.cleaned_data['website']
…
publisher.save()</pre></li>
			</ul>
			<p>This is a lot of work, and we have to consider how much duplicated logic we have. For example, we are defining the length of the name in the <code>name</code> form field. If we made a mistake here, we could allow a longer name in the field than the model allows. We also have to remember to set all the fields in the <code>initial</code> dictionary, as well as setting the values on the new or updated model with <code>cleaned_data</code> from the form. There are many opportunities to make mistakes here, as well as remembering to add or remove field setting data for each of these steps if the model changes. All this code would have to be duplicated for each Django model you work with as well, expounding the duplication problem.</p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor239"/>The ModelForm Class</h2>
			<p>Luckily, Django provides a method of building <code>Model</code> instances from forms much more simply, with the <code>ModelForm</code> class. <code>ModelForm</code> is a form that is built automatically from a particular model. It will inherit the validation rules from the model (such as whether fields are required or the maximum length of <code>CharField</code> instances, and so on). It provides an extra <code>__init__</code> argument (called <code>instance</code>) to automatically populate the initial values from an existing model. It also adds a <code>save</code> method to automatically persist the form data to the database. All that needs to be done to set up <code>ModelForm</code> is to specify its model and what fields should be used: this is done on the <code>class Meta</code> attribute of the <code>form</code> class. Let us see how to build a form from <code>Publisher</code>.</p>
			<p>Inside the file that contains the form (for example, the <code>forms.py</code> file we have been working with), the only change is that the model must be imported:</p>
			<pre>from .models import Publisher</pre>
			<p>Then the <code>Form</code> class can then be defined. The class requires a <code>class Meta</code> attribute, which in turn must define a <code>model</code> attribute and either <code>fields</code> or <code>excludes</code> attributes:</p>
			<pre>class PublisherForm(forms.ModelForm):
  class Meta:
    model = Publisher
    fields = ("name", "website", "email")</pre>
			<p><code>fields</code> is a list or tuple of the fields to include in the form. When manually setting the list of fields, if you add extra fields to the model, you must also add their name here to have them displayed on the form. </p>
			<p>You can also use the special value <code>__all__</code> instead of a list or tuple to automatically include all the fields, like this:</p>
			<pre>class PublisherForm(forms.ModelForm):
  class Meta:
    model = Publisher
    fields = "__all__"</pre>
			<p>If the <code>model</code> field has its <code>editable</code> attribute set to <code>False</code>, then it will not be automatically included.</p>
			<p>On the contrary, the <code>exclude</code> attribute sets the fields to not display in the form. Any fields added to the model will automatically be added to the form. We could define the preceding form using <code>exclude</code> with any empty tuple since we want all the fields. The code is like this:</p>
			<pre>class PublisherForm(forms.ModelForm):
  class Meta:
    model = Publisher
    exclude = ()</pre>
			<p>This saves some work because you don't need to add a field to both the model and in the <code>fields</code> list, however, it is not as safe, as you might automatically expose fields to the end user that you don't want to. For example, if you had a <code>User</code> model with <code>UserForm</code>, you might add an <code>is_admin</code> field to the <code>User</code> model to give admin users extra privileges. If this field did not have the <code>exclude</code> attribute, it would be displayed to the user. A user would then be able to make themselves an administrator, which is something you probably wouldn't want.</p>
			<p>Whichever of these three approaches to choosing the forms to display that we decide to use, in our case, they will display the same in the browser. This is because we are choosing to display <em class="italic">all</em> the fields. They all look like this when rendered in the browser:</p>
			<div><div><img src="img/B15509_07_18.jpg" alt="Figure 7.18: PublisherForm&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.18: PublisherForm</p>
			<p>Note that <code>help_text</code> from the <code>Publisher</code> model is automatically rendered as well.</p>
			<p>Usage in a view is similar to the other forms we have seen. Also, as mentioned, there is an extra argument that can be provided, called <code>instance</code>. This can be set to <code>None</code>, which will render an empty form.</p>
			<p>Assuming, in your view function, you have some method of determining whether you are creating or editing a model instance (we will discuss how to do this later), this will determine a variable called <code>is_create</code> (<code>True</code> if creating an instance, or <code>False</code> if editing an existing one). Your view function to create the form could then be written like this:</p>
			<pre>if is_create:
  instance = None
else:
  instance = get_object_or_404(Publisher, pk=pk)
if request.method == "POST":
  form = PublisherForm(request.POST, instance=instance)
  if form.is_valid():
    # we'll cover this branch soon
else:
  form = PublisherForm(instance=instance)</pre>
			<p>As you can see, in either branch, the instance is passed to the <code>PublisherForm</code> constructor, although it is <code>None</code> if we are in create mode.</p>
			<p>If the form is valid, we can then save the <code>model</code> instance. This is done simply by calling the <code>save</code> method on the form. This will automatically create the instance, or simply save changes to the old one:</p>
			<pre>if form.is_valid():
  form.save()
  return redirect(success_url)</pre>
			<p>The <code>save</code> method returns the <code>model</code> instance that was saved. It takes one optional argument, <code>commit</code>, which determines whether the changes should be written to the database. You can pass <code>False</code> instead, which allows you to make additional changes to the instance before manually saving the changes. This would be required to set attributes that have not been included in the form. As we mentioned, maybe you would set the <code>is_admin</code> flag to <code>False</code> on a <code>User</code> instance:</p>
			<pre>if form.is_valid():
  new_user = form.save(False)
  new_user.is_admin = False
  new_user.save()
  return redirect(success_url)</pre>
			<p>In <em class="italic">Activity 7.02</em>, <em class="italic">Review Creation UI</em>, at the end of this chapter, we will be using this feature as well.</p>
			<p>If your model uses <code>ManyToMany</code> fields, and you also call <code>form.save(False)</code>, you should also call <code>form.save_m2m()</code> to save any many-to-many relationships that have been set. It is not necessary to call this method if you call the form <code>save</code> method with <code>commit</code> set to <code>True</code> (that is, the default).</p>
			<p>Model forms can be customized by making changes to their <code>Meta</code> attributes. The <code>widgets</code> attribute can be set. It can contain a dictionary keyed on the field names, with widget classes or instances as the values. For example, this is how to set up <code>PublisherForm</code> to have placeholders:</p>
			<pre>class PublisherForm(forms.ModelForm):
  class Meta:
    model = Publisher
    fields = "__all__"
    widgets = {"name": forms.TextInput\
               (attrs={"placeholder": "The publisher's name."})}</pre>
			<p>The values behave the same as setting the <code>kwarg</code> widget in the field definition; they can be a class or an instance. For example, to display <code>CharField</code> as a password input, the <code>PasswordInput</code> class can be used; it does not need to be instantiated:</p>
			<pre>widgets = {"password": forms.PasswordInput}</pre>
			<p>Model forms can also be augmented with extra fields added in the same way as they are added to a normal form. For example, suppose we wanted to give the option of sending a notification email after saving a <code>Publisher</code> object. We can add an <code>email_on_save</code> field to <code>PublisherForm</code> like this:</p>
			<pre>class PublisherForm(forms.ModelForm):
  email_on_save = forms.BooleanField\
                  (required=False, \
                   help_text="Send notification email on save")
  class Meta:
    model = Publisher
    fields = "__all__"</pre>
			<p>When rendered, the form looks like this:</p>
			<div><div><img src="img/B15509_07_19.jpg" alt="Figure 7.19: PublisherForm with an additional field&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.19: PublisherForm with an additional field</p>
			<p>Additional fields are placed after the <code>Model</code> fields. The extra fields are not handled automatically – they do not exist on the model, so Django won't attempt to save them on the <code>model</code> instance. Instead, you should handle the saving of their values by examining the <code>cleaned_data</code> values of the form, as you would with a standard form, for example (inside your view function):</p>
			<pre>if form.is_valid():
  if form.cleaned_data.get("email_on_save"):
    send_email()
      # assume this function is defined elsewhere
  # save the instance regardless of sending the email or not
  form.save()  
  return redirect(success_url)</pre>
			<p>In the next exercise, you will write a new view function to create or edit a <code>Publisher</code>.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor240"/>Exercise 7.03: Creating and Editing a Publisher</h2>
			<p>In this exercise, we will return to Bookr. We want to add the ability to create and edit a <code>Publisher</code> without using the Django admin. To do this, we will add a <code>ModelForm</code> for the <code>Publisher</code> model. It will be used in a new view function. The view function will take an optional argument, <code>pk</code>, which will either be the ID of the <code>Publisher</code> being edited or <code>None</code> to create a new <code>Publisher</code>. We will add two new URL maps to facilitate this. When this is complete, we will be able to see and update any publisher using their ID. For example, information for <code>Publisher 1</code> will be viewable/editable at URL path <code>/publishers/1</code>:</p>
			<ol>
				<li value="1">In PyCharm, open the <code>reviews</code> app's <code>forms.py</code> file. After the <code>forms</code> import, also import the <code>Publisher</code> model:<pre>from .models import Publisher</pre></li>
				<li>Create a <code>PublisherForm</code> class, inheriting from <code>forms.ModelForm</code>:<pre>class PublisherForm(forms.ModelForm):</pre></li>
				<li>Define the <code>class Meta</code> attribute on <code>PublisherForm</code>. The attributes that <code>Meta</code> requires are the model (<code>Publisher</code>) and fields (<code>"__all__"</code>):<pre>class PublisherForm(forms.ModelForm):
  class Meta:
    model = Publisher
    fields = "__all__"</pre><p>Save <code>forms.py</code>.</p><p class="callout-heading">Note</p><p class="callout">The complete file can be found at <a href="http://packt.live/3qh9bww">http://packt.live/3qh9bww</a>.</p></li>
				<li>Open the <code>reviews</code> app's <code>views.py</code> file. At the top of the file, import <code>PublisherForm</code>:<pre>from .forms import PublisherForm, SearchForm</pre></li>
				<li>Make sure you import the <code>get_object_or_404</code> and <code>redirect</code> functions from <code>django.shortcuts</code>, if you aren't already:<pre>from django.shortcuts import render, get_object_or_404, redirect</pre></li>
				<li>Also make sure you're importing the <code>Publisher</code> model if you aren't already. You may already be importing this and other models:<pre>from .models import Book, Contributor, Publisher</pre></li>
				<li>The final import you will need is the <code>messages</code> module. This will allow us to register a message letting the user know that a <code>Publisher</code> object was edited or created:<pre>from django.contrib import messages</pre><p>Once again, add this import if you do not already have it.</p></li>
				<li>Create a new view function called <code>publisher_edit</code>. It takes two arguments, <code>request</code> and <code>pk</code> (the ID of the <code>Publisher</code> object to edit). This is optional, and if it is <code>None</code>, then a <code>Publisher</code> object will be created instead:<pre>def publisher_edit(request, pk=None):</pre></li>
				<li>Inside the view function, we need to try to load the existing <code>Publisher</code> instance if <code>pk</code> is not <code>None</code>. Otherwise, the value of <code>publisher</code> should be <code>None</code>:<pre>def publisher_edit(request, pk=None):
  if pk is not None:
    publisher = get_object_or_404(Publisher, pk=pk)
  else:
    publisher = None</pre></li>
				<li>After getting a <code>Publisher</code> instance or <code>None</code>, complete the branch for a <code>POST</code> request. Instantiate the form in the same way as seen earlier in the chapter, but now make sure that it takes <code>instance</code> as a kwarg. Then, if the form is valid, save it using the <code>form.save()</code> method. The method will return the updated <code>Publisher</code> instance, which is stored in the <code>updated_publisher</code> variable. Then, register a different success message depending on whether the <code>Publisher</code> instance was created or updated. Finally, redirect back to this <code>publisher_edit</code> view, since <code>updated_publisher</code> will always have an ID at this point:<pre>def publisher_edit(request, pk=None):
  …
  if request.method == "POST":
    form = PublisherForm(request.POST, instance=publisher)
    if form.is_valid():
    updated_publisher = form.save()
      if publisher is None:
        messages.success\
        (request, "Publisher \"{}\" was created."\
                  .format(updated_publisher))
      else:
        messages.success\
        (request, "Publisher \"{}\" was updated."\
                  .format(updated_publisher))\
      return redirect("publisher_edit", updated_publisher.pk)</pre><p>If the form is not valid, the execution falls through to just return the <code>render</code> function call with the invalid form (this will be implemented in <em class="italic">step 12</em>). The redirect uses a named URL map, which will be added later in the exercise.</p></li>
				<li>Next, fill in the non-<code>POST</code> branch of the code. In this case, just instantiate the form with the <code>instance</code>:<pre>def publisher_edit(request, pk=None):
  …
  if request.method == "POST":
    …
  else:
    form = PublisherForm(instance=publisher)</pre></li>
				<li>Finally, you can reuse the <code>form-example.html</code> file that you've used in previous exercises. Render it with the <code>render</code> function, passing in the HTTP method and <code>form</code> as the context:<pre>def publisher_edit(request, pk=None):
  …
  return render(request, "form-example.html", \
                {"method": request.method, "form": form}) </pre><p>Save this file. You can refer to it at <a href="http://packt.live/3nI62En">http://packt.live/3nI62En</a>.</p></li>
				<li>Open <code>urls.py</code> in the <code>reviews</code> directory. Add two new URL maps; they will both go to the <code>publisher_edit</code> view. One will capture the ID of <code>Publisher</code> we want to edit and pass it into the view as the <code>pk</code> argument. The other will use the word <code>new</code> instead, and will not pass the <code>pk</code>, which will indicate we want to create a new <code>Publisher</code>.<p>To your <code>urlpatterns</code> variable, add the path <code>'publishers/&lt;int:pk&gt;/'</code> mapping to the view <code>reviews.views.publisher_edit</code>, with the name of <code>'publisher_edit'</code>.</p><p>Also, add the path <code>'publishers/new/'</code> mapping to the <code>reviews.views.publisher_edit</code> view, with the name of <code>'publisher_create'</code>:</p><pre>urlpatterns = [
  …
  path('publishers/&lt;int:pk&gt;/',views.publisher_edit, \
        name='publisher_edit'),\
  path('publishers/new/',views.publisher_edit, \
        name='publisher_create')]</pre><p>Since the second mapping does not capture anything, the <code>pk</code> that is passed to the <code>publisher_detail</code> view function is <code>None</code>.</p><p>Save the <code>urls.py</code> file. The completed version for reference is at <a href="http://packt.live/39CpUnw">http://packt.live/39CpUnw</a>.</p></li>
				<li>Create a <code>form-example.html</code> file inside the <code>reviews</code> app's <code>templates</code> directory. Since this is a standalone template (it does not extend any other templates), we need to render the messages inside it. Add this code just after the opening <code>&lt;body&gt;</code> tag to iterate through all the messages and display them:<pre>{% for message in messages %}
&lt;p&gt;&lt;em&gt;{{ message.level_tag|title }}:&lt;/em&gt; {{ message }}&lt;/p&gt;
{% endfor %}</pre><p>This will loop over the messages we have added and display the tag (in our case, <code>Success</code>) and then the message.</p></li>
				<li>Then, add the normal form rendering and submission code:<pre>&lt;form method="post"&gt;
  {% csrf_token %}
  {{ form.as_p }}
  &lt;p&gt;
    &lt;input type="submit" value="Submit"&gt;
  &lt;/p&gt;
&lt;/form&gt;</pre><p>Save and close this file.</p><p>You can refer to the full version of this file at <a href="http://packt.live/38I8XZx">http://packt.live/38I8XZx</a>.</p></li>
				<li>Start the Django dev server, then navigate to <code>http://127.0.0.1:8000/publishers/new/</code>. You should see a blank <code>PublisherForm</code> being displayed:<p> </p><div><img src="img/B15509_07_20.jpg" alt="Figure 7.20: Blank publisher form&#13;&#10;"/></div><p class="figure-caption">Figure 7.20: Blank publisher form</p></li>
				<li>The form has inherited the model's validation rules, so you cannot submit the form with too many characters for <code>Name</code>, or with an invalid <code>Website</code> or <code>Email</code>. Put in some valid information, then submit the form. After submission, you should see the success message and the form will be populated with information that was saved to the database:<div><img src="img/B15509_07_21.jpg" alt="Figure 7.21: Form after submission&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 7.21: Form after submission</p>
			<p>Notice that the URL has also been updated and now includes the ID of the publisher that was created. In this case, it is <code>http://127.0.0.1:8000/publishers/19/</code> but the ID on your setup will depend on how many <code>Publisher</code> instances were already in your database. </p>
			<p>Notice that if you refresh the page, you will not receive a message confirming whether you want to re-send the form data. This is because we redirected after saving, so it is safe to refresh this page as many times as you want, and no new <code>Publisher</code> instances will be created. If you had not redirected it, then every time the page was refreshed, a new <code>Publisher</code> instance would be created.</p>
			<p>If you have other <code>Publisher</code> instances in your database, you can change the ID in the URL to edit other ones. Since the ID in this instance is <code>3</code>, we can assume that <code>Publisher</code> <code>1</code> and <code>Publisher</code> <code>2</code> already exist and can substitute in their IDs to see the existing data. Here is the view of the existing <code>Publisher 1</code> (at <code>http://127.0.0.1:8000/publishers/1/</code>) – your information may be different:</p>
			<div><div><img src="img/B15509_07_22.jpg" alt="Figure 7.22: Existing Publisher 1 information&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.22: Existing Publisher 1 information</p>
			<p>Try making changes to the existing <code>Publisher</code> instance. Notice that after you save, the message is different – it is telling the user that the <code>Publisher</code> instance was <em class="italic">updated</em> rather than <em class="italic">created</em>:</p>
			<p> </p>
			<div><div><img src="img/B15509_07_23.jpg" alt="Figure 7.23: Publisher after updating instead of creating&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.23: Publisher after updating instead of creating</p>
			<p>In this exercise, we implemented a <code>ModelForm</code> from a model (<code>PublisherForm</code> was created from <code>Publisher</code>) and saw how Django automatically generated the form fields with the correct validation rules. We then used the form's built-in <code>save</code> method to save changes to the <code>Publisher</code> instance (or automatically create it) inside the <code>publisher_edit</code> view. We mapped two URLs to the view. The first URL, which was for editing an existing <code>Publisher</code>, passed <code>pk</code> to the view. The other did not pass <code>pk</code> to the view, indicating that the <code>Publisher</code> instance should be created. Finally, we used the browser to experiment with creating a new <code>Publisher</code> instance and then editing an existing one.</p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor241"/>Activity 7.01: Styling and Integrating the Publisher Form</h2>
			<p>In <em class="italic">Exercise 7.03</em>, <em class="italic">Creating and Editing a Publisher</em>, you added <code>PublisherForm</code> to create and edit <code>Publisher</code> instances. You built this with a standalone template that did not extend any other templates, so it lacked the global styles. In this activity, you will build a generic form detail page that will display a Django form, similar to <code>form-example.html</code> but extending from a base template. The template will accept a variable to display the type of model being edited. You will also update the main <code>base.html</code> template to render the Django messages, using Bootstrap styling.</p>
			<p>These steps will help you complete this activity:</p>
			<ol>
				<li value="1">Start by editing the <code>base.html</code> project. Wrap the <code>content</code> block in a container <code>div</code> for a nicer layout with some spacing. Surround the existing <code>content</code> block with a <code>&lt;div&gt;</code> element with <code>class="container-fluid"</code>.</li>
				<li>Render each <code>message</code> in <code>messages</code> (similar to <em class="italic">step 14</em> of <em class="italic">Exercise 7.03</em>, <em class="italic">Creating and Editing a Publisher</em>). Add the <code>{% for %}</code> block after the <code>&lt;div&gt;</code> you just created but before the <code>content</code> block. You should use the Bootstrap framework classes – this snippet will help you:<pre>&lt;div class="alert alert-{% if message.level_tag   == 'error' %}danger{% else %}{    {message.level_tag }}{% endif %}"
    role="alert"&gt;
  {{ message }}
&lt;/div&gt;</pre><p>The Bootstrap class and Django <code>message</code> tags have corresponding names for the most part (for example, <code>success</code> and <code>alert-success</code>). The exception is Django's <code>error</code> tag. The corresponding Bootstrap class is <code>alert-danger</code>. See more information about Bootstrap alerts at <a href="https://getbootstrap.com/docs/4.0/components/alerts/">https://getbootstrap.com/docs/4.0/components/alerts/</a>. This is why you need to use the <code>if</code> template tag in this snippet.</p></li>
				<li>Create a new template called <code>instance-form.html</code>, inside the <code>reviews</code> app's namespaced <code>templates</code> directory.</li>
				<li><code>instance-form.html</code> should extend from the <code>reviews</code> app's <code>base.html</code>.</li>
				<li>The context being passed to this template will contain a variable called <code>instance</code>. This will be the <code>Publisher</code> instance being edited, or <code>None</code> if we are creating a new <code>Publisher</code> instance. The context will also contain a <code>model_type</code> variable, which is a string indicating the model type (in this case, <code>Publisher</code>). Use these two variables to populate the <code>title</code> block template tag:<p>If the instance is <code>None</code>, the title should be <code>New Publisher</code>.</p><p>Otherwise, the title should be <code>Editing Publisher &lt;Publisher Name&gt;</code>.</p></li>
				<li><code>instance-form.html</code> should contain a <code>content</code> <code>block</code> template tag to override the <code>base.html</code> <code>content</code> block.</li>
				<li>Add an <code>&lt;h2&gt;</code> element inside the <code>content</code> block and populate it using the same logic as the title. For better styling, wrap the publisher name in an <code>&lt;em&gt;</code> element.</li>
				<li>Add a <code>&lt;form&gt;</code> element to the template with a <code>method</code> of <code>post</code>. Since we are posting back to the same URL, an <code>action</code> does not need to be specified.</li>
				<li>Include the CSRF token template tag in the <code>&lt;form&gt;</code> body.</li>
				<li>Render the Django form (its context variable will be <code>form</code>) inside <code>&lt;form&gt;</code>, using the <code>as_p</code> method.</li>
				<li>Add a <code>submit</code> <code>&lt;button&gt;</code> to the form. Its text should depend on whether you are editing or creating. Use the text <code>Save</code> for editing or <code>Create</code> for creating. You can use the Bootstrap classes for the button styling here. It should have the attribute <code>class="btn btn-primary"</code>.</li>
				<li>In <code>reviews/views.py</code>, the <code>publisher_edit</code> view does not need many changes. Update the <code>render</code> call to render <code>instance-form.html</code> instead of <code>form-example.html</code>.</li>
				<li>Update the context dictionary being passed to the <code>render</code> call. It should include the <code>Publisher</code> instance (the <code>publisher</code> variable that was already defined) and <code>model_type</code> string. The context dictionary already includes <code>form</code> (a <code>PublisherForm</code> instance). You can remove the <code>method</code> key.</li>
				<li>Since we're finished with the <code>form-example.html</code> template, it can be deleted.<p>When you've finished, the <code>Publisher</code> creation page (at <code>http://127.0.0.1:8000/publishers/new/</code>) should look like <em class="italic">Figure 7.24</em>:</p><div><img src="img/B15509_07_24.jpg" alt="Figure 7.24: The Publisher creation page&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 7.24: The Publisher creation page</p>
			<p>When editing a <code>Publisher</code> (for example, at the URL <code>http://127.0.0.1:8000/publishers/1/</code>), your page should look like <em class="italic">Figure 7.25</em>:</p>
			<div><div><img src="img/B15509_07_25.jpg" alt="Figure 7.25: The Editing Publisher page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.25: The Editing Publisher page</p>
			<p>After saving a <code>Publisher</code> instance, whether creating or editing, you should see the success message at the top of the page (<em class="italic">Figure 7.26</em>):</p>
			<div><div><img src="img/B15509_07_26.jpg" alt="Figure 7.26: Success message rendered as a Bootstrap alert&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.26: Success message rendered as a Bootstrap alert</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="http://packt.live/2Nh1NTJ">http://packt.live/2Nh1NTJ</a>.</p>
			<h2 id="_idParaDest-227">Activity 7.02: Review Crea<a id="_idTextAnchor242"/>tion UI</h2>
			<p><em class="italic">Activity 7.01</em>, <em class="italic">Styling and Integrating the Publisher Form</em>, was quite extensive; however, by completing it, you have created a foundation that makes it easier to add other <em class="italic">edit</em> and <em class="italic">create</em> views. You will experience this first-hand in this activity when you will build forms for creating and editing reviews. Because the <code>instance-form.html</code> template was made generically, you can reuse it in other views.</p>
			<p>In this activity, you will create a review <code>ModelForm</code>, then add a <code>review_edit</code> view to create or edit a <code>Review</code> instance. You can reuse <code>instance-form.html</code> from <em class="italic">Activity 7.01</em>, <em class="italic">Styling and Integrating the Publisher Form</em>, and pass in different context variables to make it work with the <code>Review</code> model. When working with reviews, you will operate within the context of a book, that is, the <code>review_edit</code> view must accept a book's <code>pk</code> as an argument. You will fetch the <code>Book</code> instance separately and assign it to the <code>Review</code> instance that you create.</p>
			<p>These steps will help you complete this activity:</p>
			<ol>
				<li value="1">In <code>forms.py</code>, add a <code>ReviewForm</code> subclass of <code>ModelForm</code>; its model should be <code>Review</code> (make sure you <code>import</code> the <code>Review</code> model).<p><code>ReviewForm</code> should exclude the <code>date_edited</code> and <code>book</code> fields since the user should not be setting these in the form. The database allows any rating, but we can override the <code>rating</code> field with an <code>IntegerField</code> that requires a minimum value of <em class="italic">0</em> and a maximum value of <em class="italic">5</em>.</p></li>
				<li>Create a new view called <code>review_edit</code>. It should accept two arguments after <code>request</code>: <code>book_pk</code>, which is required, and <code>review_pk</code>, which is optional (defaults to <code>None</code>). Fetch the <code>Book</code> instance and <code>Review</code> instance using the <code>get_object_or_404</code> shortcut (call it once for each type). When fetching the review, make sure the review belongs to the book. If <code>review_pk</code> is <code>None</code>, then the <code>Review</code> instance should be <code>None</code> too.</li>
				<li>If the <code>request</code> method is <code>POST</code>, then instantiate a <code>ReviewForm</code> using <code>request.POST</code> and the review instance. Make sure you <code>import</code> the <code>ReviewForm</code>.<p>If the form is valid, save the form but set the <code>commit</code> argument to <code>save</code> to <code>False</code>. Then, set the <code>book</code> attribute on the returned <code>Review</code> instance to the book fetched in <em class="italic">step 2</em>. </p></li>
				<li>If the <code>Review</code> instance was being updated instead of created, then you should also set the <code>date_edited</code> attribute to the current date and time. Use the <code>from</code> <code>django.utils.timezone.now()</code> function. Then, save the <code>Review</code> instance.</li>
				<li>Finish the valid form branch by registering a success message and redirecting back to the<code> book_detail</code> view. Since the <code>Review</code> model doesn't really contain a meaningful text description, use the book title in the message. For example, <code>Review for "&lt;book title&gt;" created</code>.</li>
				<li>If the <code>request</code> method is not <code>POST</code>, instantiate a <code>ReviewForm</code> and just pass in the <code>Review</code> instance. </li>
				<li>Render the <code>instance-form.html</code> template. In the context dictionary, include the same items as were used in <code>publisher_view</code>: <code>form</code>, <code>instance</code>, and <code>model_type</code> (<code>Review</code>). Include two extra items, <code>related_model_type</code>, which should be <code>Book</code>, and <code>related_instance</code>, which will be the <code>Book</code> instance.</li>
				<li>Edit <code>instance-form.html</code> to add a place to display the related instance information added in <em class="italic">step 6</em>. Under the <code>&lt;h2&gt;</code> element, add a <code>&lt;p&gt;</code> element that is only displayed if both <code>related_model_type</code> and <code>related_instance</code> are set. It should show the text <code>For &lt;related_model_type&gt; &lt;related_instance&gt;</code>. For example: <code>For Book Advanced Deep Learning with Keras</code>. Put the <code>related_instance</code> output in an <code>&lt;em&gt;</code> element for better readability.</li>
				<li>In the <code>reviews</code> app's <code>urls.py</code> file, add URL maps to the <code>review_edit</code> view. The URLs <code>/books/</code> and <code>/books/&lt;pk&gt;/</code> are already configured. Add the URLs <code>/books/&lt;book_pk&gt;/reviews/new/</code> to create a review, and <code>/books/&lt;book_pk&gt;/reviews/&lt;review_pk&gt;/</code> to edit a review. Make sure you give these names such as <code>review_create</code> and <code>review_edit</code>.</li>
				<li>Inside the <code>book_detail.html</code> template, add links that a user can click to create or edit a review. Add a link inside the <code>content</code> block, just before the <code>endblock</code> closing template tag. It should use the <code>url</code> template tag to link to the <code>review_edit</code> view when in creation mode. Also, use the attribute <code>class="btn btn-primary"</code> to make the link display like a Bootstrap button. The link text should be <code>Add Review</code>.</li>
				<li>Finally, add a link to edit a review, inside the <code>for</code> loop that iterates over <code>Reviews</code> for <code>Book</code>. After all the instances of <code>text-info</code> <code>&lt;span&gt;</code>, add a link to the <code>review_edit</code> view using the <code>url</code> template tag. You will need to provide <code>book.pk</code> and <code>review.pk</code> as arguments. The text of the link should be <code>Edit Review</code>. When you are finished, the <code>Review Comments</code> page should look like <em class="italic">Figure 7.27</em>:<div><img src="img/B15509_07_27.jpg" alt="Figure 7.27: Book detail page with added Add Review button&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 7.27: Book detail page with added Add Review button</p>
			<p>You can see the <code>Add Review</code> button. Clicking it will take you to the <code>Create Book Review</code> page, which should look like <em class="italic">Figure 7.28</em>:</p>
			<div><div><img src="img/B15509_07_28.jpg" alt="Figure 7.28: Review creation page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.28: Review creation page</p>
			<p>Enter some details in the form and click <code>Create</code>. You will be redirected to the <code>Book Details</code> page, and you should see the success message and your review, as in <em class="italic">Figure 7.29</em>:</p>
			<div><div><img src="img/B15509_07_29.jpg" alt="Figure 7.29: Book Details page with review added&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.29: Book Details page with review added</p>
			<p>You can also see the <code>Edit Review</code> link, and if you click it, you will be taken to a form that is pre-populated with your review data (see <em class="italic">Figure 7.30</em>):</p>
			<div><div><img src="img/B15509_07_30.jpg" alt="Figure 7.30: Review form when editing a review&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.30: Review form when editing a review</p>
			<p>After saving an existing review, you should see the <code>Modified on</code> date is updated on the <code>Book Details</code> page (<em class="italic">Figure 7.31</em>):</p>
			<div><div><img src="img/B15509_07_31.jpg" alt="Figure 7.31: The Modified on date is now populated&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.31: The Modified on date is now populated</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="http://packt.live/2Nh1NTJ">http://packt.live/2Nh1NTJ</a>.</p>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor243"/>Summary</h1>
			<p>This chapter was a deep dive into forms. We saw how to enhance Django forms with custom validation advanced rules for cleaning data and validating fields. We saw how custom cleaning methods can transform the data that we get out of forms. A nice feature we saw that can be added to forms is the ability to set initial and placeholder values on fields, so the user does not have to fill them out.</p>
			<p>We then looked at how to use the <code>ModelForm</code> class to automatically create a form from a Django model. We saw how to only show some fields to the user and how to apply custom form validation rules to the <code>ModelForm</code>. We also saw how Django can automatically save the new or updated model instance to the database inside the view. In the activities for this chapter, we enhanced Bookr some more by adding forms for creating and editing publishers and submitting reviews. The next chapter will carry on the theme of submitting user input, and along with that, we'll discuss how Django handles uploading and downloading files.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>