- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extending Your Blog Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter went through the basics of forms and the creation of a
    comment system. You also learned how to send emails with Django. In this chapter,
    you will extend your blog application with other popular features used on blogging
    platforms, such as tagging, recommending similar posts, providing an RSS feed
    to readers, and allowing them to search posts. You will learn about new components
    and functionalities with Django by building these functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing tagging using `django-taggit`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving posts by similarity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom template tags and filters to display the latest posts and most
    commented posts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a sitemap to the site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating feeds for blog posts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing PostgreSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using fixtures to dump and load data into the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a full-text search engine with Django and PostgreSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Figure 3.1* shows a representation of the views, templates, and functionalities
    that will be built in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Diagram of functionalities built in Chapter 3'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build the functionality to add tags to posts. We will
    extend the `post_list` view to filter posts by tag. When loading a single post
    in the `post_detail` view, we will retrieve similar posts based on common tags.
    We will also create custom template tags to display a sidebar with the total number
    of posts, the latest posts published, and the most commented posts.
  prefs: []
  type: TYPE_NORMAL
- en: We will add support to write posts with Markdown syntax and convert the content
    to HTML. We will create a sitemap for the blog with the `PostSitemap` class and
    implement an RSS feed with the latest posts in the `LatestPostsFeed` class. Finally,
    we will implement a search engine with the `post_search` view and use PostgreSQL
    full-text search capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter can be found at [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter03](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: All Python packages used in this chapter are included in the `requirements.txt`
    file in the source code for the chapter. You can follow the instructions to install
    each Python package in the following sections, or you can install all the requirements
    at once with the command `python` `-m` `pip install -r requirements.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing tagging with django-taggit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very common functionality in blogs is categorizing posts using tags. Tags
    allow you to categorize content in a non-hierarchical manner, using simple keywords.
    A tag is simply a label or keyword that can be assigned to posts. We will create
    a tagging system by integrating a third-party Django tagging application into
    the project.
  prefs: []
  type: TYPE_NORMAL
- en: '`django-taggit` is a reusable application that primarily offers you a `Tag`
    model and a manager to easily add tags to any model. You can take a look at its
    source code at [https://github.com/jazzband/django-taggit](https://github.com/jazzband/django-taggit).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add tagging to our blog. First, you need to install `django-taggit` via
    `pip` by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open the `settings.py` file of the `mysite` project and add `taggit`
    to your `INSTALLED_APPS` setting, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It’s good practice to keep the Django packages at the top, third-party packages
    in the middle, and local applications at the end of `INSTALLED_APPS`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `models.py` file of your `blog` application and add the `TaggableManager`
    manager provided by `django-taggit` to the `Post` model using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `tags` manager will allow you to add, retrieve, and remove tags from `Post`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following schema shows the data models defined by `django-taggit` to create
    tags and store related tagged objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated with low confidence](img/B21088_03_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Tag models of django-taggit'
  prefs: []
  type: TYPE_NORMAL
- en: The `Tag` model is used to store tags. It contains a `name` and a `slug` field.
  prefs: []
  type: TYPE_NORMAL
- en: The `TaggedItem` model is used to store the related tagged objects. It has a
    `ForeignKey` field for the related `Tag` object. It contains a `ForeignKey` to
    a `ContentType` object and an `IntegerField` to store the related `id` of the
    tagged object. The `content_type` and `object_id` fields combined form a generic
    relationship with any model in your project. This allows you to create relationships
    between a `Tag` instance and any other model instance of your applications. You
    will learn about generic relations ship in *Chapter 7*, *Tracking User Actions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command in the shell prompt to create a migration for your
    model changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following command to create the required database tables for `django-taggit`
    models and to synchronize your model changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see an output indicating that migrations have been applied, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The database is now in sync with the `taggit` models and we can start using
    the functionalities of `django-taggit`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now explore how to use the `tags` manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Django shell by running the following command in the system shell
    prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following code to retrieve one of the posts (the one with the `1` ID):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add some tags to it and retrieve its tags to check whether they were
    successfully added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, remove a tag and check the list of tags again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It’s really easy to add, retrieve, or remove tags from a model using the manager
    we have defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the development server from the shell prompt with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Open [http://127.0.0.1:8000/admin/taggit/tag/](http://127.0.0.1:8000/admin/taggit/tag/)
    in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the administration page with the list of `Tag` objects of the
    `taggit` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: The tag change list view on the Django administration site'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **jazz** tag. You will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: The tag edit view on the Django administration site'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to `http://127.0.0.1:8000/admin/blog/post/1/change/` to edit the post
    with ID 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see that posts now include a new **Tags** field, as follows, where
    you can easily edit tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: The related Tags field of a Post object'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you need to edit your blog posts to display tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `blog/post/list.html` template and add the following HTML code highlighted
    in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `join` template filter works analogously to Python’s string `join()` method.
    You can concatenate a list of items into one string, using a specific character
    or string to separate each item. For example, a list of tags like `['music', 'jazz',
    'piano']` is converted into a single string, `'music, jazz, piano'`, by joining
    them with `','` as the `join()` separator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `http://127.0.0.1:8000/blog/` in your browser. You should be able to see
    the list of tags under each post title:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: The Post list item, including related tags'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will edit the `post_list` view to let users list all posts tagged with
    a specific tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `views.py` file of your `blog` application, import the `Tag` model
    from `django-taggit`, and change the `post_list` view to optionally filter posts
    by a tag, as follows. New code is highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `post_list` view now works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It takes an optional `tag_slug` parameter that has a `None` default value. This
    parameter will be passed in the URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the view, we build the initial QuerySet, retrieving all published posts,
    and if there is a given tag slug, we get the `Tag` object with the given slug
    using the `get_object_or_404()` shortcut.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we filter the list of posts by the ones that contain the given tag. Since
    this is a many-to-many relationship, we have to filter posts by tags contained
    in a given list, which, in this case, contains only one element. We use the `__in`
    field lookup. Many-to-many relationships occur when multiple objects of a model
    are associated with multiple objects of another model. In our application, a post
    can have multiple tags and a tag can be related to multiple posts. You will learn
    how to create many-to-many relationships in *Chapter 6*, *Sharing Content on Your
    Website*. You can discover more about many-to-many relationships at [https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/](https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the `render()` function now passes the new `tag` variable to the template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember that QuerySets are lazy. The QuerySets to retrieve posts will only
    be evaluated when you loop over `post_list` when rendering the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `urls.py` file of your `blog` application, comment out the class-based
    `PostListView` URL pattern, and uncomment the `post_list` view, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following additional URL pattern to list posts by tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, both patterns point to the same view, but they have different
    names. The first pattern will call the `post_list` view without any optional parameters,
    whereas the second pattern will call the view with the `tag_slug` parameter. You
    use a `slug` path converter to match the parameter as a lowercase string with
    ASCII letters or numbers, plus the hyphen and underscore characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `urls.py` file of the `blog` application should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Since you are using the `post_list` view, edit the `blog/post/list.html` template
    and modify the pagination to use the `posts` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines highlighted in bold to the `blog/post/list.html` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If a user is accessing the blog, they will see the list of all posts. If they
    filter by posts tagged with a specific tag, they will see the tag that they are
    filtering by.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, edit the `blog/post/list.html` template and change the way tags are displayed,
    as follows. New lines are highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we loop through all the tags of a post displaying a custom
    link to the URL to filter posts by that tag. We build the URL with `{% url "blog:post_list_by_tag"
    tag.slug %}`, using the name of the URL and the `slug` tag as its parameter. You
    separate the tags with commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `http://127.0.0.1:8000/blog/tag/jazz/` in your browser. You will see the
    list of posts filtered by that tag, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: A post filtered by the tag “jazz”'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving posts by similarity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have implemented tagging for blog posts, you can do many interesting
    things with tags. Tags allow you to categorize posts in a non-hierarchical manner.
    Posts about similar topics will have several tags in common. We will build a functionality
    to display similar posts by the number of tags they share. In this way, when a
    user reads a post, we can suggest to them that they read other related posts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to retrieve similar posts for a specific post, you need to perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve all tags for the current post.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get all posts that are tagged with any of those tags.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exclude the current post from that list to avoid recommending the same post.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Order the results by the number of tags shared with the current post.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the case of two or more posts with the same number of tags, recommend the
    most recent post.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Limit the query to the number of posts you want to recommend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These steps are translated into a complex QuerySet. Let’s edit the `post_detail`
    view to incorporate these similarity-based post suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `views.py` file of your `blog` application and add the following import
    at the top of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the `Count` aggregation function of the Django ORM. This function will
    allow you to perform aggregated counts of tags. `django.db.models` includes the
    following aggregation functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Avg`: The mean value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Max`: The maximum value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Min`: The minimum value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Count`: The total number of objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can learn about aggregation at [https://docs.djangoproject.com/en/5.0/topics/db/aggregation/](https://docs.djangoproject.com/en/5.0/topics/db/aggregation/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `views.py` file of your `blog` application and add the following lines
    to the `post_detail` view. New lines are highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You retrieve a Python list of IDs for the tags of the current post. The `values_list()`
    QuerySet returns tuples with the values for the given fields. You pass `flat=True`
    to it to get single values such as `[1, 2, 3, ...]` instead of one tuple such
    as `[(1,), (2,), (3,) ...]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You get all posts that contain any of these tags, excluding the current post
    itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You use the `Count` aggregation function to generate a calculated field—`same_tags`—that
    contains the number of tags shared with all the tags queried.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You order the result by the number of shared tags (descending order) and by
    `publish` to display recent posts first for the posts with the same number of
    shared tags. You slice the result to retrieve only the first four posts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You pass the `similar_posts` object to the context dictionary for the `render()`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, edit the `blog/post/detail.html` template and add the following code highlighted
    in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The post detail page should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: The post detail page, including a list of similar posts'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `http://127.0.0.1:8000/admin/blog/post/` in your browser, edit a post
    that has no tags, and add the `music` and `jazz` tags, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9: Adding the “jazz” and “music” tags to a post'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit another post and add the `jazz` tag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: Adding the “jazz” tag to a post'
  prefs: []
  type: TYPE_NORMAL
- en: 'The post detail page for the first post should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.11: The post detail page, including a list of similar posts'
  prefs: []
  type: TYPE_NORMAL
- en: The posts recommended in the **Similar posts** section of the page appear in
    descending order based on the number of shared tags with the original post.
  prefs: []
  type: TYPE_NORMAL
- en: We are now able to successfully recommend similar posts to readers. `django-taggit`
    also includes a `similar_objects()` manager that you can use to retrieve objects
    by shared tags. You can take a look at all `django-taggit` managers at [https://django-taggit.readthedocs.io/en/latest/api.html](https://django-taggit.readthedocs.io/en/latest/api.html).
  prefs: []
  type: TYPE_NORMAL
- en: You can also add the list of tags to your post detail template in the same way
    as you did in the `blog/post/list.html` template.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom template tags and filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django offers a variety of built-in template tags, such as `{% if %}` or `{%
    block %}`. You used different template tags in *Chapter 1*, *Building a Blog Application*,
    and *Chapter 2*, *Enhancing Your Blog with Advanced Features*. You can find a
    complete reference of built-in template tags and filters at [https://docs.djangoproject.com/en/5.0/ref/templates/builtins/](https://docs.djangoproject.com/en/5.0/ref/templates/builtins/).
  prefs: []
  type: TYPE_NORMAL
- en: Django also allows you to create your own template tags to perform custom actions.
    Custom template tags come in very handy when you need to add a functionality to
    your templates that is not covered by the core set of Django template tags. This
    can be a tag to execute a QuerySet or any server-side processing that you want
    to reuse across templates. For example, we could build a template tag to display
    a list of the latest posts published on the blog. We could include this list in
    the sidebar so that it is always visible, regardless of the view that processes
    the request.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing custom template tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Django provides the following helper functions, which allow you to easily create
    template tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`simple_tag`: Processes the given data and returns a string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inclusion_tag`: Processes the given data and returns a rendered template'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template tags must live inside Django applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside your `blog` application directory, create a new directory, name it `templatetags`,
    and add an empty `__init__.py` file to it. Create another file in the same folder
    and name it `blog_tags.py`. The file structure of the blog application should
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The way you name the file is important because you will use the name of this
    module to load tags in templates.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple template tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by creating a simple tag to retrieve the total posts that have been
    published on the blog.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `templatetags/blog_tags.py` file you just created and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We have created a simple template tag that returns the number of posts published
    on the blog.
  prefs: []
  type: TYPE_NORMAL
- en: Each module that contains template tags needs to define a variable called `register`
    to be a valid tag library. This variable is an instance of `template.Library`,
    and it’s used to register the template tags and filters of the application.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we have defined a tag called `total_posts` with a simple
    Python function. We have added the `@register.simple_tag` decorator to the function,
    to register it as a simple tag. Django will use the function’s name as the tag
    name.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to register it using a different name, you can do so by specifying
    a `name` attribute, such as `@register.simple_tag(name='my_tag')`.
  prefs: []
  type: TYPE_NORMAL
- en: After adding a new template tags module, you will need to restart the Django
    development server in order to use the new tags and filters in templates.
  prefs: []
  type: TYPE_NORMAL
- en: Before using custom template tags, we have to make them available for the template
    using the `{% load %}` tag. As mentioned before, we need to use the name of the
    Python module containing our template tags and filters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `blog/templates/base.html` template and add `{% load blog_tags %}`
    at the top of it to load your template tags module. Then, use the tag you created
    to display your total posts, as follows. The new lines are highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need to restart the server to keep track of the new files added to
    the project. Stop the development server with *Ctrl* + *C* and run it again using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `http://127.0.0.1:8000/blog/` in your browser. You should see the total
    number of posts in the sidebar of the site, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.12: The total posts published included in the sidebar'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you see the following error message, it’s very likely you didn’t restart
    the development server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.13: The error message when a template tag library is not registered'
  prefs: []
  type: TYPE_NORMAL
- en: Template tags allow you to process any data and add it to any template regardless
    of the view executed. You can perform QuerySets or process any data to display
    results in your templates.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an inclusion template tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create another tag to display the latest posts in the sidebar of the
    blog. This time, we will implement an inclusion tag. Using an inclusion tag, you
    can render a template with context variables returned by your template tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `templatetags/blog_tags.py` file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have registered the template tag using the `@register.inclusion_tag`
    decorator. We have specified the template that will be rendered with the returned
    values using `blog/post/latest_posts.html`. The template tag will accept an optional
    `count` parameter that defaults to `5`. This parameter will allow us to specify
    the number of posts to display. We use this variable to limit the results of the
    query `Post.published.order_by('-publish')[:count]`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the function returns a dictionary of variables instead of a simple
    value. Inclusion tags have to return a dictionary of values, which is used as
    the context to render the specified template. The template tag we just created
    allows us to specify the optional number of posts to display as `{% show_latest_posts
    3 %}`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, create a new template file under `blog/post/` and name it `latest_posts.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the new `blog/post/latest_posts.html` template and add the following code
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, you have added an unordered list of posts using the
    `latest_posts` variable returned by your template tag. Now, edit the `blog/base.html`
    template and add the new template tag to display the last three posts, as follows.
    The new lines are highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The template tag is called, passing the number of posts to display, and the
    template is rendered in place with the given context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, return to your browser and refresh the page. The sidebar should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.14: The blog sidebar, including the latest published posts'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a template tag that returns a QuerySet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, we will create a simple template tag that returns a value. We will
    store the result in a variable that can be reused, rather than outputting it directly.
    We will create a tag to display the most commented posts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `templatetags/blog_tags.py` file and add the following import and
    template tag to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding template tag, you build a QuerySet using the `annotate()` function
    to aggregate the total number of comments for each post. You use the `Count` aggregation
    function to store the number of comments in the computed `total_comments` field
    for each `Post` object. You order the QuerySet by the computed field in descending
    order. You also provide an optional `count` variable to limit the total number
    of objects returned.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to `Count`, Django offers the aggregation functions `Avg`, `Max`,
    `Min`, and `Sum`. You can read more about aggregation functions at [https://docs.djangoproject.com/en/5.0/topics/db/aggregation/](https://docs.djangoproject.com/en/5.0/topics/db/aggregation/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, edit the `blog/base.html` template and add the following code highlighted
    in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we store the result in a custom variable using the `as`
    argument followed by the variable name. For the template tag, we use `{% get_most_commented_posts
    as most_commented_posts %}` to store the result of the template tag in a new variable
    named `most_commented_posts`. Then, we display the returned posts using an HTML
    unordered list element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open your browser and refresh the page to see the final result. It should
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.15: The post list view, including the complete sidebar with the latest
    and most commented posts'
  prefs: []
  type: TYPE_NORMAL
- en: You now have a clear idea of how to build custom template tags. You can read
    more about them at [https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/](https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing custom template filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Django has a variety of built-in template filters that allow you to alter variables
    in templates. These are Python functions that take one or two parameters, the
    value of the variable that the filter is applied to, and an optional argument.
    They return a value that can be displayed or treated by another filter.
  prefs: []
  type: TYPE_NORMAL
- en: A filter is written like `{{ variable``|my_filter` `}}`. Filters with an argument
    are written like `{{ variable``|my_filter:"foo"` `}}`. For example, you can use
    the `capfirst` filter to capitalize the first character of the value, like `{{
    value``|capfirst` `}}`. If `value` is `django`, the output will be `Django`. You
    can apply as many filters as you like to a variable, for example, `{{ variable``|filter1|filter2`
    `}}`, and each filter will be applied to the output generated by the preceding
    filter.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the list of Django’s built-in template filters at [https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#built-in-filter-reference](https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#built-in-filter-reference).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a template filter to support Markdown syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a custom filter to enable you to use Markdown syntax in your
    blog posts and then convert the post body to HTML in the templates.
  prefs: []
  type: TYPE_NORMAL
- en: Markdown is a plain-text formatting syntax that is very simple to use, and it’s
    intended to be converted into HTML. You can write posts using simple Markdown
    syntax and get the content automatically converted into HTML code. Learning Markdown
    syntax is much easier than learning HTML. By using Markdown, you can get other
    non-tech-savvy contributors to easily write posts for your blog. You can learn
    the basics of the Markdown format at [https://daringfireball.net/projects/markdown/basics](https://daringfireball.net/projects/markdown/basics).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install the Python `markdown` module via `pip` using the following command
    in the shell prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, edit the `templatetags/blog_tags.py` file and include the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We register template filters in the same way as template tags. To prevent a
    name clash between the function name and the `markdown` module, we have named
    the function `markdown_format` and we have named the filter `markdown` for use
    in templates, such as `{{ variable|markdown }}`.
  prefs: []
  type: TYPE_NORMAL
- en: Django escapes the HTML code generated by filters; characters of HTML entities
    are replaced with their HTML-encoded characters. For example, `<p>` is converted
    to `&lt;p&gt;` (*less than* symbol, *p* character, *greater than* symbol).
  prefs: []
  type: TYPE_NORMAL
- en: We use the `mark_safe` function provided by Django to mark the result as safe
    HTML to be rendered in the template. By default, Django will not trust any HTML
    code and will escape it before placing it in the output. The only exceptions are
    variables that are marked as safe from escaping. This behavior prevents Django
    from outputting potentially dangerous HTML and allows you to create exceptions
    for returning safe HTML.
  prefs: []
  type: TYPE_NORMAL
- en: In Django, HTML content is escaped by default for security. Use `mark_safe`
    cautiously, only on content you control. Avoid using `mark_safe` on any content
    submitted by non-staff users to prevent security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `blog/post/detail.html` template and add the following new code highlighted
    in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We have replaced the `linebreaks` filter of the `{{ post.body }}` template variable
    with the `markdown` filter. This filter will not only transform line breaks into
    `<p>` tags; it will also transform Markdown formatting into HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Storing text in Markdown format in the database, rather than HTML, is a wise
    security strategy. Markdown limits the potential for injecting malicious content.
    This approach ensures that any text formatting is safely converted to HTML only
    at the point of rendering the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `blog/post/list.html` template and add the following new code highlighted
    in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We have added the new `markdown` filter to the `{{ post.body }}` template variable.
    This filter will transform the Markdown content into HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we have replaced the previous `truncatewords` filter with the `truncatewords_html`
    filter. This filter truncates a string after a certain number of words, avoiding
    unclosed HTML tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open `http://127.0.0.1:8000/admin/blog/post/add/` in your browser and create
    a new post with the following body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The form should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.16: The post with Markdown content rendered as HTML'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `http://127.0.0.1:8000/blog/` in your browser and take a look at how the
    new post is rendered. You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.17: The post with Markdown content rendered as HTML'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 3.17*, custom template filters are very useful for
    customizing formatting. You can find more information about custom filters at
    [https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/#writing-custom-template-filters](https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/#writing-custom-template-filters).
  prefs: []
  type: TYPE_NORMAL
- en: Adding a sitemap to the site
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django comes with a sitemap framework, which allows you to generate sitemaps
    for your site dynamically. A sitemap is an XML file that tells search engines
    the pages of your website, their relevance, and how frequently they are updated.
    Using a sitemap will make your site more visible in search engine rankings because
    it helps crawlers to index your website’s content.
  prefs: []
  type: TYPE_NORMAL
- en: The Django sitemap framework depends on `django.contrib.sites`, which allows
    you to associate objects to particular websites that are running with your project.
    This comes in handy when you want to run multiple sites using a single Django
    project. To install the sitemap framework, we will need to activate both the `sites`
    and `sitemap` applications in your project. We are going to build a sitemap for
    the blog that includes the links to all published posts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `settings.py` file of the project and add `django.contrib.sites` and
    `django.contrib.sitemaps` to the `INSTALLED_APPS` setting. Also, define a new
    setting for the site ID, as follows. New code is highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following command from the shell prompt to create the tables of
    the Django site application in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an output that contains the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `sites` application is now synced with the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a new file inside your `blog` application directory and name it
    `sitemaps.py`. Open the file and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We have defined a custom sitemap by inheriting the `Sitemap` class of the `sitemaps`
    module. The `changefreq` and `priority` attributes indicate the change frequency
    of your post pages and their relevance in your website (the maximum value is `1`).
  prefs: []
  type: TYPE_NORMAL
- en: The `items()` method returns the QuerySet of objects to include in this sitemap.
    By default, Django calls the `get_absolute_url()` method on each object to retrieve
    its URL. Remember that we implemented this method in *Chapter 2*, *Enhancing Your
    Blog with Advanced Features*, to define the canonical URL for posts. If you want
    to specify the URL for each object, you can add a `location` method to your sitemap
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The `lastmod` method receives each object returned by `items()` and returns
    the last time the object was modified.
  prefs: []
  type: TYPE_NORMAL
- en: Both the `changefreq` and `priority` attributes can be either methods or attributes.
    You can take a look at the complete sitemap reference in the official Django documentation
    located at [https://docs.djangoproject.com/en/5.0/ref/contrib/sitemaps/](https://docs.djangoproject.com/en/5.0/ref/contrib/sitemaps/).
  prefs: []
  type: TYPE_NORMAL
- en: We have created the sitemap. Now we just need to create a URL for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the main `urls.py` file of the `mysite` project and add the sitemap, as
    follows. New lines are highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have included the required imports and defined a `sitemaps`
    dictionary. Multiple sitemaps can be defined for the site. We have defined a URL
    pattern that matches the `sitemap.xml` pattern and uses the `sitemap` view provided
    by Django. The `sitemaps` dictionary is passed to the `sitemap` view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the development server from the shell prompt with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `http://127.0.0.1:8000/sitemap.xml` in your browser. You will see an XML
    output including all of the published posts, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The URL for each `Post` object is built by calling its `get_absolute_url()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The `lastmod` attribute corresponds to the post `updated` date field, as you
    specified in your sitemap, and the `changefreq` and `priority` attributes are
    also taken from the `PostSitemap` class.
  prefs: []
  type: TYPE_NORMAL
- en: The domain used to build the URLs is `example.com`. This domain comes from a
    `Site` object stored in the database. This default object was created when you
    synced the site’s framework with your database. You can read more about the `sites`
    framework at [https://docs.djangoproject.com/en/5.0/ref/contrib/sites/](https://docs.djangoproject.com/en/5.0/ref/contrib/sites/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `http://127.0.0.1:8000/admin/sites/site/` in your browser. You should
    see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.18: The Django administration list view for the Site model of the
    site’s framework'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3.18* contains the list display administration view for the site’s
    framework. Here, you can set the domain or host to be used by the site’s framework
    and the applications that depend on it. To generate URLs that exist in your local
    environment, change the domain name to `localhost:8000`, as shown in *Figure 3.19*,
    and save it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.19: The Django administration edit view for the Site model of the
    site’s framework'
  prefs: []
  type: TYPE_NORMAL
- en: Open `http://127.0.0.1:8000/sitemap.xml` in your browser again. The URLs displayed
    in your sitemap will now use the new hostname and look like `http://localhost:8000/blog/2024/1/22/markdown-post/`.
    Links are now accessible in your local environment. In a production environment,
    you will have to use your website’s domain to generate absolute URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Creating feeds for blog posts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django has a built-in syndication feed framework that you can use to dynamically
    generate RSS or Atom feeds in a similar manner to creating sitemaps using the
    site’s framework. A web feed is a data format (usually XML) that provides users
    with the most recently updated content. Users can subscribe to the feed using
    a feed aggregator, a software that is used to read feeds and get new content notifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file in your `blog` application directory and name it `feeds.py`.
    Add the following lines to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have defined a feed by subclassing the `Feed` class
    of the syndication framework. The `title`, `link`, and `description` attributes
    correspond to the `<title>`, `<link>`, and `<description>` RSS elements, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We use `reverse_lazy()` to generate the URL for the `link` attribute. The `reverse()`
    method allows you to build URLs by their name and pass optional parameters. We
    used `reverse()` in *Chapter 2*, *Enhancing Your Blog with Advanced Features*.
  prefs: []
  type: TYPE_NORMAL
- en: The `reverse_lazy()` utility function is a lazily evaluated version of `reverse()`.
    It allows you to use a URL reversal before the project’s URL configuration is
    loaded.
  prefs: []
  type: TYPE_NORMAL
- en: The `items()` method retrieves the objects to be included in the feed. We retrieve
    the last five published posts to include them in the feed.
  prefs: []
  type: TYPE_NORMAL
- en: The `item_title()`, `item_description()`, and `item_pubdate()` methods will
    receive each object returned by `items()` and return the title, description, and
    publication date for each item.
  prefs: []
  type: TYPE_NORMAL
- en: In the `item_description()` method, we use the `markdown()` function to convert
    Markdown content to HTML and the `truncatewords_html()` template filter function
    to cut the description of posts after 30 words, avoiding unclosed HTML tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, edit the `blog/urls.py` file, import the `LatestPostsFeed` class, and
    instantiate the feed in a new URL pattern, as follows. New lines are highlighted
    in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to `http://127.0.0.1:8000/blog/feed/` in your browser. You should
    now see the RSS feed, including the last five blog posts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If you use Chrome, you will see the XML code. If you use Safari, it will ask
    you to install an RSS feed reader.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s install an RSS desktop client to view the RSS feed with a user-friendly
    interface. We will use Fluent Reader, which is a multi-platform RSS reader.
  prefs: []
  type: TYPE_NORMAL
- en: Download Fluent Reader for Linux, macOS, or Windows from [https://github.com/yang991178/fluent-reader/releases](https://github.com/yang991178/fluent-reader/releases).
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Fluent Reader and open it. You will see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing chart  Description automatically generated](img/B21088_03_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.20: Fluent Reader with no RSS feed sources'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the settings icon in the top-right corner of the window. You will
    see a screen to add RSS feed sources like the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B21088_03_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.21: Adding an RSS feed in Fluent Reader'
  prefs: []
  type: TYPE_NORMAL
- en: Enter `http://127.0.0.1:8000/blog/feed/` in the **Add source** field and click
    on the **Add** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see a new entry with the RSS feed of the blog in the table below the
    form, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B21088_03_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.22: RSS feed sources in Fluent Reader'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go back to the main screen of Fluent Reader. You should be able to see
    the posts included in the blog RSS feed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B21088_03_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.23: RSS feed of the blog in Fluent Reader'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on a post to see a description:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.24: The post description in Fluent Reader'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the third icon in the top-right corner of the window to load the full
    content of the post page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.25: The full content of a post in Fluent Reader'
  prefs: []
  type: TYPE_NORMAL
- en: The final step is to add an RSS feed subscription link to the blog’s sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `blog/base.html` template and add the following code highlighted in
    bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open `http://127.0.0.1:8000/blog/` in your browser and take a look at the
    sidebar. The new link will take users to the blog’s feed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.26: The RSS feed subscription link added to the sidebar'
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about the Django syndication feed framework at [https://docs.djangoproject.com/en/5.0/ref/contrib/syndication/](https://docs.djangoproject.com/en/5.0/ref/contrib/syndication/).
  prefs: []
  type: TYPE_NORMAL
- en: Adding full-text search to the blog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we will add search capabilities to the blog. Searching for data in the
    database with user input is a common task for web applications. The Django ORM
    allows you to perform simple matching operations using, for example, the `contains`
    filter (or its case-insensitive version, `icontains`). You can use the following
    query to find posts that contain the word `framework` in their body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: However, if you want to perform complex search lookups, retrieving results by
    similarity, or by weighting terms based on how frequently they appear in the text
    or how important different fields are (for example, the relevancy of the term
    appearing in the title versus in the body), you will need to use a full-text search
    engine. When you consider large blocks of text, building queries with operations
    on a string of characters is not enough. A full-text search examines the actual
    words against stored content as it tries to match search criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Django provides a powerful search functionality built on top of PostgreSQL database
    full-text search features. The `django.contrib.postgres` module provides functionalities
    offered by PostgreSQL that are not shared by the other databases that Django supports.
    You can learn about PostgreSQL’s full-text search support at [https://www.postgresql.org/docs/16/textsearch.html](https://www.postgresql.org/docs/16/textsearch.html).
  prefs: []
  type: TYPE_NORMAL
- en: Although Django is a database-agnostic web framework, it provides a module that
    supports part of the rich feature set offered by PostgreSQL, which is not offered
    by other databases that Django supports.
  prefs: []
  type: TYPE_NORMAL
- en: We are currently using an SQLite database for the `mysite` project. SQLite support
    for full-text search is limited and Django doesn’t support it out of the box.
    However, PostgreSQL is much better suited for full-text search and we can use
    the `django.contrib.postgres` module to use PostgreSQL’s full-text search capabilities.
    We will migrate our data from SQLite to PostgreSQL to benefit from its full-text
    search features.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite is sufficient for development purposes. However, for a production environment,
    you will need a more powerful database, such as PostgreSQL, MariaDB, MySQL, or
    Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL provides a Docker image that makes it very easy to deploy a PostgreSQL
    server with a standard configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker is a popular open-source containerization platform. It enables developers
    to package applications into containers, simplifying the process of building,
    running, managing, and distributing applications.
  prefs: []
  type: TYPE_NORMAL
- en: First, download and install Docker for your OS. You will find instructions for
    downloading and installing Docker on Linux, macOS, and Windows at [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).
    The installation includes both Docker Desktop and Docker command-line interface
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Installing PostgreSQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After installing Docker on your Linux, macOS, or Windows machine, you can easily
    pull the PostgreSQL Docker image. Run the following command from the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This will download the PostgreSQL Docker image to your local machine. You can
    find information about the official PostgreSQL Docker image at [https://hub.docker.com/_/postgres](https://hub.docker.com/_/postgres).
    You can find other PostgreSQL packages and installers at [https://www.postgresql.org/download/](https://www.postgresql.org/download/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command in the shell to start the PostgreSQL Docker container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Replace `xxxxx` with the desired password for your database user.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command starts a PostgreSQL instance. The `--name` option is used to assign
    a name to the container, in this case, `blog_db`. The `-e` option is to define
    environment variables for the instance. We set the following environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`POSTGRES_DB`: Name of the PostgreSQL database. If not defined, the value of
    `POSTGRES_USER` is used for the database name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POSTGRES_USER`: Used in conjunction with `POSTGRES_PASSWORD` to define a username
    and password. The user is created with superuser power.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POSTGRES_PASSWORD`: Sets the superuser password for PostgreSQL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-p` option is used to publish the `5432` port, on which PostgreSQL runs,
    to the same host interface port. This allows external applications to access the
    database. The `-d` option is for *detached mode*, which runs the Docker container
    in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Docker Desktop application. You should see the new container running,
    as in *Figure 3.27*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.27: PostgreSQL instance running in Docker Desktop'
  prefs: []
  type: TYPE_NORMAL
- en: You will see the newly created `blog_db` container, with the status **Running**.
    Under **Actions**, you can stop or restart the service. You can also delete the
    container. Note that deleting the container will also eliminate the database and
    all the data it contains. You will learn how to persist PostgreSQL data in the
    local filesystem using Docker in *Chapter 17*, *Going Live*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also need to install the `psycopg` PostgreSQL adapter for Python. Run the
    following command in the shell prompt to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will migrate the existing data in the SQLite database to the new PostgreSQL
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Dumping the existing data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before switching the database in the Django project, we need to dump the existing
    data from the SQLite database. We will export the data, switch the project’s database
    to PostgreSQL, and import the data into the new database.
  prefs: []
  type: TYPE_NORMAL
- en: Django comes with a simple way to load and dump data from the database into
    files that are called **fixtures**. Django supports fixtures in JSON, XML, or
    YAML format. We are going to create a fixture with all data contained in the database.
  prefs: []
  type: TYPE_NORMAL
- en: The `dumpdata` command dumps data from the database into the standard output,
    serialized in JSON format by default. The resulting data structure includes information
    about the model and its fields for Django to be able to load it into the database.
  prefs: []
  type: TYPE_NORMAL
- en: You can limit the output to the models of an application by providing the application
    names to the command, or specifying single models for outputting data using the
    `app.Model` format. You can also specify the format using the `--format` flag.
    By default, `dumpdata` outputs the serialized data to the standard output. However,
    you can indicate an output file using the `--output` flag. The `--indent` flag
    allows you to specify indentation. For more information on `dumpdata` parameters,
    run `python manage.py dumpdata --help`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command from the shell prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'All existing data has been exported in JSON format to a new file named `mysite_data.json`.
    You can view the file contents to see the JSON structure that includes all the
    different data objects for the different models of your installed applications.
    If you get an encoding error when running the command, include the `-Xutf8` flag
    as follows to activate Python UTF-8 mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We will now switch the database in the Django project and then we will import
    the data into the new database.
  prefs: []
  type: TYPE_NORMAL
- en: Switching the database in the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now you will add the PostgreSQL database configuration to your project settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `settings.py` file of your project and modify the `DATABASES` setting
    to make it look as follows. New code is highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The database engine is now `postgresql`. The database credentials are now loaded
    from environment variables using `python-decouple`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add values to the environment variables. Edit the `.env` file of your
    project and add the following lines highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Replace `xxxxxx` with the password you used when starting the PostgreSQL container.
    The new database is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to apply all database migrations to the new PostgreSQL
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see an output, including all the migrations that have been applied,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The PostgreSQL database is now in sync with your data models and you can run
    your Django project pointing to the new database. Let’s get the database to the
    same state by loading the data we previously exported from SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the data into the new database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to load the data fixtures we generated previously into our new
    PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to load the previously exported data into the PostgreSQL
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The number of objects might differ, depending on the users, posts, comments,
    and other objects that have been created in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the development server from the shell prompt with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `http://127.0.0.1:8000/admin/blog/post/` in your browser to verify that
    all posts have been loaded into the new database. You should see all the posts,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.28: The list of posts on the administration site'
  prefs: []
  type: TYPE_NORMAL
- en: Simple search lookups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having enabled PostgreSQL in our project, we can now build a powerful search
    engine by leveraging PostgreSQL’s full-text search capabilities. We will begin
    with basic search lookups and progressively incorporate more sophisticated features,
    such as stemming, ranking, or weighting queries, to build a comprehensive full-text
    search engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `settings.py` file of your project and add `django.contrib.postgres`
    to the `INSTALLED_APPS` setting, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the Django shell by running the following command in the system shell
    prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Now you can search against a single field using the `search` QuerySet lookup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following code in the Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This query uses PostgreSQL to create a search vector for the `title` field and
    a search query from the term `django`. Results are obtained by matching the query
    with the vector.
  prefs: []
  type: TYPE_NORMAL
- en: Searching against multiple fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might want to search against multiple fields. In this case, you will need
    to define a `SearchVector` object. Let’s build a vector that allows you to search
    against the `title` and `body` fields of the `Post` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following code in the Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Using `annotate` and defining `SearchVector` with both fields, you provide a
    functionality to match the query against both the `title` and `body` of the posts.
  prefs: []
  type: TYPE_NORMAL
- en: Full-text search is an intensive process. If you are searching for more than
    a few hundred rows, you should define a functional index that matches the search
    vector you are using. Django provides a `SearchVectorField` field for your models.
    You can read more about this at [https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/#performance](https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/#performance).
  prefs: []
  type: TYPE_NORMAL
- en: Building a search view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, you will create a custom view to allow your users to search posts. First,
    you will need a search form. Edit the `forms.py` file of the `blog` application
    and add the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'You will use the `query` field to let users introduce search terms. Edit the
    `views.py` file of the `blog` application and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding view, first, we instantiate the `SearchForm` form. To check
    whether the form is submitted, we look for the `query` parameter in the `request.GET`
    dictionary. We send the form using the `GET` method instead of `POST` so that
    the resulting URL includes the `query` parameter and is easy to share. When the
    form is submitted, we instantiate it with the submitted `GET` data and verify
    that the form data is valid. If the form is valid, we search for published posts
    with a custom `SearchVector` instance built with the `title` and `body` fields.
  prefs: []
  type: TYPE_NORMAL
- en: The search view is now ready. We need to create a template to display the form
    and the results when the user performs a search.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file inside the `templates/blog/post/` directory, name it `search.html`,
    and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As in the search view, we distinguish whether the form has been submitted by
    the presence of the `query` parameter. Before the query is submitted, we display
    the form and a submit button. When the search form is submitted, we display the
    query performed, the total number of results, and the list of posts that match
    the search query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, edit the `urls.py` file of the `blog` application and add the following
    URL pattern highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open `http://127.0.0.1:8000/blog/search/` in your browser. You should
    see the following search form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.29: The form with the query field to search for posts'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a query and click on the **SEARCH** button. You will see the results
    of the search query, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_30.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.30: Search results for the term “jazz”'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have created a basic search engine for your blog.
  prefs: []
  type: TYPE_NORMAL
- en: Stemming and ranking results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stemming is the process of reducing words to their word stem, base, or root
    form. Stemming is used by search engines to reduce indexed words to their stem,
    and to be able to match inflected or derived words. For example, the words “music,”
    “musical,” and “musicality” can be considered similar words by a search engine.
    The stemming process normalizes each search token into a lexeme, a unit of lexical
    meaning that underlies a set of words that are related through inflection. The
    words “music,” “musical,” and “musicality” would convert to “music” when creating
    a search query.
  prefs: []
  type: TYPE_NORMAL
- en: Django provides a `SearchQuery` class to translate terms into a search query
    object. By default, the terms are passed through stemming algorithms, which helps
    you to obtain better matches.
  prefs: []
  type: TYPE_NORMAL
- en: The PostgreSQL search engine also removes stop words, such as “a,” “the,” “on,”
    and “of.” Stop words are a set of commonly used words in a language. They are
    removed when creating a search query because they appear too frequently to be
    relevant to searches. You can find the list of stop words used by PostgreSQL for
    the English language at [https://github.com/postgres/postgres/blob/master/src/backend/snowball/stopwords/english.stop](https://github.com/postgres/postgres/blob/master/src/backend/snowball/stopwords/english.stop).
  prefs: []
  type: TYPE_NORMAL
- en: We also want to order results by relevancy. PostgreSQL provides a ranking function
    that orders results based on how often the query terms appear and how close together
    they are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `blog` application and add the following imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, edit the `post_search` view, as follows. New code is highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we create a `SearchQuery` object, filter results by it,
    and use `SearchRank` to order the results by relevancy.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can open `http://127.0.0.1:8000/blog/search/` in your browser and test
    different searches to test stemming and ranking. The following is an example of
    ranking by the number of occurrences of the word `django` in the title and body
    of the posts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_31.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.31: Search results for the term “django”'
  prefs: []
  type: TYPE_NORMAL
- en: Stemming and removing stop words in different languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can set up `SearchVector` and `SearchQuery` to execute stemming and remove
    stop words in any language. We can pass a `config` attribute to `SearchVector`
    and `SearchQuery` to use a different search configuration. This allows us to use
    different language parsers and dictionaries. The following example executes stemming
    and removes stop words in Spanish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: You can find the Spanish stop words dictionary used by PostgreSQL at [https://github.com/postgres/postgres/blob/master/src/backend/snowball/stopwords/spanish.stop](https://github.com/postgres/postgres/blob/master/src/backend/snowball/stopwords/spanish.stop).
  prefs: []
  type: TYPE_NORMAL
- en: Weighting queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can boost specific vectors so that more weight is attributed to them when
    ordering results by relevancy. For example, we can use this to give more relevance
    to posts that are matched by title rather than by content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `blog` application and modify the `post_search`
    view as follows. New code is highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we apply different weights to the search vectors built
    using the `title` and `body` fields. The default weights are `D`, `C`, `B`, and
    `A`, and they refer to the numbers `0.1`, `0.2`, `0.4`, and `1.0`, respectively.
    We apply a weight of `1.0` to the `title` search vector (`A`) and a weight of
    `0.4` to the `body` vector (`B`). Title matches will prevail over body content
    matches. We filter the results to display only the ones with a rank higher than
    `0.3`.
  prefs: []
  type: TYPE_NORMAL
- en: Searching with trigram similarity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another search approach is trigram similarity. A trigram is a group of three
    consecutive characters. You can measure the similarity of two strings by counting
    the number of trigrams that they share. This approach turns out to be very effective
    for measuring the similarity of words in many languages.
  prefs: []
  type: TYPE_NORMAL
- en: To use trigrams in PostgreSQL, you will need to install the `pg_trgm` database
    extension first. Django provides database migration operations to create PostgreSQL
    extensions. Let’s add a migration that creates the extension in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, execute the following command in the shell prompt to create an empty
    migration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create an empty migration for the `blog` application. You will see
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the file `blog/migrations/0005_trigram_ext.py` and add the following lines
    highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: You have added the `TrigramExtension` operation to the database migration. This
    operation executes the SQL statement `CREATE EXTENSION pg_trgm` to create the
    extension in PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about database migration operations at [https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/operations/](https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/operations/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now execute the migration with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The `pg_trgm` extension has been created in the database. Let’s modify `post_search`
    to search for trigrams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of your `blog` application and add the following import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, modify the `post_search` view as follows. New code is highlighted in
    bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `http://127.0.0.1:8000/blog/search/` in your browser and test different
    searches for trigrams. The following example displays a hypothetical typo in the
    `django` term, showing search results for `yango`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_32.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.32: Search results for the term “yango”'
  prefs: []
  type: TYPE_NORMAL
- en: We have added a powerful search engine to the blog application.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about full-text search with Django and PostgreSQL
    at [https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/](https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you implemented a tagging system by integrating a third-party
    application into your project. You generated post recommendations using complex
    QuerySets. You also learned how to create custom Django template tags and filters
    to provide templates with custom functionalities. You also created a sitemap for
    search engines to crawl your site and an RSS feed for users to subscribe to your
    blog. You then built a search engine for your blog using the full-text search
    engine of PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to build a social website using the
    Django authentication framework and how to implement user account functionalities
    and custom user profiles.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding your project using AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having completed the blog application, you likely have numerous ideas for adding
    new functionalities to your blog. This section aims to provide some insights into
    exploring new functionalities to incorporate into your project with the assistance
    of ChatGPT. ChatGPT is a sophisticated AI **Large Language Model** (**LLM**) created
    by OpenAI that generates human-like responses based on the prompts it receives.
    In this section, you will be presented with a task to extend your project, accompanied
    by a sample prompt for ChatGPT to assist you.
  prefs: []
  type: TYPE_NORMAL
- en: Engage with ChatGPT at [https://chat.openai.com/](https://chat.openai.com/).
    You will find similar guidance after completing each Django project within this
    book, in *Chapter 7*, *Tracking User Actions*, *Chapter 11*, *Adding Internationalization
    to Your Shop*, and *Chapter 17*, *Going Live*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s further enhance your blog with the help of ChatGPT. Your blog currently
    allows filtering posts by tags. Adding these tags to our sitemap could significantly
    improve the SEO optimization of the blog. Use the prompt provided at [https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter03/prompts/task.md](https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter03/prompts/task.md)
    for adding tag pages to the sitemap. This challenge is an excellent opportunity
    to refine your project and deepen your understanding of Django, while learning
    to interact with ChatGPT.
  prefs: []
  type: TYPE_NORMAL
- en: ChatGPT is ready to assist with code issues. Simply share your code along with
    any errors you’re facing, and ChatGPT can help you identify and resolve the issues.
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resources provide additional information related to the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Source code for this chapter: [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter03](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter03)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django-taggit`: [https://github.com/jazzband/django-taggit](https://github.com/jazzband/django-taggit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django-taggit` ORM managers: [https://django-taggit.readthedocs.io/en/latest/api.html](https://django-taggit.readthedocs.io/en/latest/api.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Many-to-many relationships: [https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/](https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django aggregation functions: [https://docs.djangoproject.com/en/5.0/topics/db/aggregation/](https://docs.djangoproject.com/en/5.0/topics/db/aggregation/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Built-in template tags and filters: [https://docs.djangoproject.com/en/5.0/ref/templates/builtins/](https://docs.djangoproject.com/en/5.0/ref/templates/builtins/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Writing custom template tags: [https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/](https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Markdown format reference: [https://daringfireball.net/projects/markdown/basics](https://daringfireball.net/projects/markdown/basics
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django sitemap framework: [https://docs.djangoproject.com/en/5.0/ref/contrib/sitemaps/](https://docs.djangoproject.com/en/5.0/ref/contrib/sitemaps/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django sites framework: [https://docs.djangoproject.com/en/5.0/ref/contrib/sites/](https://docs.djangoproject.com/en/5.0/ref/contrib/sites/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django syndication feed framework: [https://docs.djangoproject.com/en/5.0/ref/contrib/syndication/](https://docs.djangoproject.com/en/5.0/ref/contrib/syndication/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker download and installation instructions: [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PostgreSQL Docker image: [https://hub.docker.com/_/postgres](https://hub.docker.com/_/postgres)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PostgreSQL downloads: [https://www.postgresql.org/download/](https://www.postgresql.org/download/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PostgreSQL full-text search capabilities: [https://www.postgresql.org/docs/16/textsearch.html](https://www.postgresql.org/docs/16/textsearch.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Database migration operations: [https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/operations/](https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/operations/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django support for PostgreSQL full-text search – [https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/](https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ChatGPT interface – [https://chat.openai.com/](https://chat.openai.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sample ChatGPT prompt to add tag pages to the sitemap – [https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter03/prompts/task.md](https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter03/prompts/task.md)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
