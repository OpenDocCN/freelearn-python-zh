- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Extending Your Blog Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展您的博客应用程序
- en: The previous chapter went through the basics of forms and the creation of a
    comment system. You also learned how to send emails with Django. In this chapter,
    you will extend your blog application with other popular features used on blogging
    platforms, such as tagging, recommending similar posts, providing an RSS feed
    to readers, and allowing them to search posts. You will learn about new components
    and functionalities with Django by building these functionalities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了表单的基础知识以及评论系统的创建。您还学习了如何使用Django发送电子邮件。在本章中，您将通过添加博客平台上常用的其他功能来扩展您的博客应用程序，例如标签、推荐相似帖子、为读者提供RSS订阅源以及允许他们搜索帖子。通过构建这些功能，您将学习到Django的新组件和功能。
- en: 'The chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Implementing tagging using `django-taggit`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`django-taggit`实现标签功能
- en: Retrieving posts by similarity
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过相似度检索帖子
- en: Creating custom template tags and filters to display the latest posts and most
    commented posts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用于显示最新帖子及评论最多帖子的自定义模板标签和过滤器
- en: Adding a sitemap to the site
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向网站添加网站地图
- en: Creating feeds for blog posts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为博客帖子创建订阅源
- en: Installing PostgreSQL
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装PostgreSQL
- en: Using fixtures to dump and load data into the database
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用固定值将数据导入和导出到数据库
- en: Implementing a full-text search engine with Django and PostgreSQL
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Django和PostgreSQL实现全文搜索引擎
- en: Functional overview
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能概述
- en: '*Figure 3.1* shows a representation of the views, templates, and functionalities
    that will be built in this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.1*展示了本章将要构建的视图、模板和功能表示：'
- en: '![](img/B21088_03_01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_03_01.png)'
- en: 'Figure 3.1: Diagram of functionalities built in Chapter 3'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：第3章内置功能图
- en: In this chapter, we will build the functionality to add tags to posts. We will
    extend the `post_list` view to filter posts by tag. When loading a single post
    in the `post_detail` view, we will retrieve similar posts based on common tags.
    We will also create custom template tags to display a sidebar with the total number
    of posts, the latest posts published, and the most commented posts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建添加标签到帖子的功能。我们将扩展`post_list`视图以按标签过滤帖子。在`post_detail`视图中加载单个帖子时，我们将根据共同标签检索相似帖子。我们还将创建自定义模板标签以显示包含帖子总数、最新发布的帖子以及评论最多的帖子的侧边栏。
- en: We will add support to write posts with Markdown syntax and convert the content
    to HTML. We will create a sitemap for the blog with the `PostSitemap` class and
    implement an RSS feed with the latest posts in the `LatestPostsFeed` class. Finally,
    we will implement a search engine with the `post_search` view and use PostgreSQL
    full-text search capabilities.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加支持使用Markdown语法编写帖子并将内容转换为HTML。我们将使用`PostSitemap`类为博客创建一个网站地图，并在`LatestPostsFeed`类中实现一个RSS订阅源。最后，我们将通过`post_search`视图实现一个搜索引擎，并使用PostgreSQL全文搜索功能。
- en: The source code for this chapter can be found at [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter03](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter03).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在[https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter03](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter03)找到。
- en: All Python packages used in this chapter are included in the `requirements.txt`
    file in the source code for the chapter. You can follow the instructions to install
    each Python package in the following sections, or you can install all the requirements
    at once with the command `python` `-m` `pip install -r requirements.txt`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有Python包都包含在章节源代码中的`requirements.txt`文件中。您可以在以下部分中按照说明安装每个Python包，或者您可以使用命令`python
    -m pip install -r requirements.txt`一次性安装所有依赖项。
- en: Implementing tagging with django-taggit
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`django-taggit`实现标签功能
- en: A very common functionality in blogs is categorizing posts using tags. Tags
    allow you to categorize content in a non-hierarchical manner, using simple keywords.
    A tag is simply a label or keyword that can be assigned to posts. We will create
    a tagging system by integrating a third-party Django tagging application into
    the project.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在博客中，一个非常常见的功能是使用标签对帖子进行分类。标签允许您以非层次结构的方式使用简单的关键词对内容进行分类。标签只是一个可以分配给帖子的标签或关键词。我们将通过将第三方Django标签应用程序集成到项目中来创建一个标签系统。
- en: '`django-taggit` is a reusable application that primarily offers you a `Tag`
    model and a manager to easily add tags to any model. You can take a look at its
    source code at [https://github.com/jazzband/django-taggit](https://github.com/jazzband/django-taggit).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`django-taggit`是一个可重用的应用程序，它主要提供您一个`Tag`模型和一个管理器，以便轻松地将标签添加到任何模型。您可以在[https://github.com/jazzband/django-taggit](https://github.com/jazzband/django-taggit)查看其源代码。'
- en: 'Let’s add tagging to our blog. First, you need to install `django-taggit` via
    `pip` by running the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的博客中添加标签功能。首先，您需要通过运行以下命令使用`pip`安装`django-taggit`：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, open the `settings.py` file of the `mysite` project and add `taggit`
    to your `INSTALLED_APPS` setting, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开`mysite`项目的`settings.py`文件，并将`taggit`添加到您的`INSTALLED_APPS`设置中，如下所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It’s good practice to keep the Django packages at the top, third-party packages
    in the middle, and local applications at the end of `INSTALLED_APPS`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将Django包放在顶部，第三方包放在中间，本地应用放在`INSTALLED_APPS`的末尾是一种良好的实践。
- en: 'Open the `models.py` file of your `blog` application and add the `TaggableManager`
    manager provided by `django-taggit` to the `Post` model using the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的`blog`应用的`models.py`文件，并使用以下代码将`django-taggit`提供的`TaggableManager`管理器添加到`Post`模型中：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `tags` manager will allow you to add, retrieve, and remove tags from `Post`
    objects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`tags`管理器将允许您向`Post`对象添加、检索和删除标签。'
- en: 'The following schema shows the data models defined by `django-taggit` to create
    tags and store related tagged objects:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下模式显示了`django-taggit`定义的数据模型，用于创建标签并存储相关的标签对象：
- en: '![Diagram  Description automatically generated with low confidence](img/B21088_03_02.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图描述：自动生成，置信度低](img/B21088_03_02.png)'
- en: 'Figure 3.2: Tag models of django-taggit'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：django-taggit的标签模型
- en: The `Tag` model is used to store tags. It contains a `name` and a `slug` field.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tag`模型用于存储标签。它包含一个`name`和一个`slug`字段。'
- en: The `TaggedItem` model is used to store the related tagged objects. It has a
    `ForeignKey` field for the related `Tag` object. It contains a `ForeignKey` to
    a `ContentType` object and an `IntegerField` to store the related `id` of the
    tagged object. The `content_type` and `object_id` fields combined form a generic
    relationship with any model in your project. This allows you to create relationships
    between a `Tag` instance and any other model instance of your applications. You
    will learn about generic relations ship in *Chapter 7*, *Tracking User Actions*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaggedItem`模型用于存储相关的标签对象。它有一个指向相关`Tag`对象的`ForeignKey`字段。它包含一个指向`ContentType`对象的`ForeignKey`和一个用于存储相关标签对象`id`的`IntegerField`。`content_type`和`object_id`字段结合形成与项目中任何模型之间的通用关系。这允许您在标签实例和应用程序中的任何其他模型实例之间创建关系。您将在*第7章*，*跟踪用户行为*中了解通用关系。'
- en: 'Run the following command in the shell prompt to create a migration for your
    model changes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell提示符中运行以下命令以为您模型的更改创建迁移：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should get the following output:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到以下输出：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, run the following command to create the required database tables for `django-taggit`
    models and to synchronize your model changes:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下命令以创建`django-taggit`模型所需的数据库表，并同步您的模型更改：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You will see an output indicating that migrations have been applied, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出，表明迁移已应用：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The database is now in sync with the `taggit` models and we can start using
    the functionalities of `django-taggit`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库现在与`taggit`模型同步，我们可以开始使用`django-taggit`的功能了。
- en: Let’s now explore how to use the `tags` manager.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来探索如何使用`tags`管理器。
- en: 'Open the Django shell by running the following command in the system shell
    prompt:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统shell提示符中运行以下命令以打开Django shell：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run the following code to retrieve one of the posts (the one with the `1` ID):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下代码以检索一篇帖子（ID为`1`的帖子）：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, add some tags to it and retrieve its tags to check whether they were
    successfully added:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，向其添加一些标签并检索其标签以检查它们是否已成功添加：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, remove a tag and check the list of tags again:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，删除一个标签并再次检查标签列表：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It’s really easy to add, retrieve, or remove tags from a model using the manager
    we have defined.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们定义的管理器添加、检索或删除模型中的标签非常简单。
- en: 'Start the development server from the shell prompt with the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令从shell提示符启动开发服务器：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Open [http://127.0.0.1:8000/admin/taggit/tag/](http://127.0.0.1:8000/admin/taggit/tag/)
    in your browser.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开[http://127.0.0.1:8000/admin/taggit/tag/](http://127.0.0.1:8000/admin/taggit/tag/)。
- en: 'You will see the administration page with the list of `Tag` objects of the
    `taggit` application:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到包含`taggit`应用程序的`Tag`对象列表的管理页面。
- en: '![](img/B21088_03_03.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_03_03.png)'
- en: 'Figure 3.3: The tag change list view on the Django administration site'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：Django管理站点上的标签更改列表视图
- en: 'Click on the **jazz** tag. You will see the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**jazz**标签。您将看到以下内容：
- en: '![](img/B21088_03_04.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_03_04.png)'
- en: 'Figure 3.4: The tag edit view on the Django administration site'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：Django管理站点上的标签编辑视图
- en: Navigate to `http://127.0.0.1:8000/admin/blog/post/1/change/` to edit the post
    with ID 1.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`http://127.0.0.1:8000/admin/blog/post/1/change/`以编辑ID为1的帖子。
- en: 'You will see that posts now include a new **Tags** field, as follows, where
    you can easily edit tags:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到帖子现在包括一个新的**标签**字段，如下所示，您可以在其中轻松编辑标签：
- en: '![](img/B21088_03_05.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_03_05.png)'
- en: 'Figure 3.5: The related Tags field of a Post object'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：帖子对象的关联标签字段
- en: Now, you need to edit your blog posts to display tags.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要编辑您的博客帖子以显示标签。
- en: 'Open the `blog/post/list.html` template and add the following HTML code highlighted
    in bold:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`blog/post/list.html`模板，并添加以下以粗体显示的HTML代码：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `join` template filter works analogously to Python’s string `join()` method.
    You can concatenate a list of items into one string, using a specific character
    or string to separate each item. For example, a list of tags like `['music', 'jazz',
    'piano']` is converted into a single string, `'music, jazz, piano'`, by joining
    them with `','` as the `join()` separator.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`join`模板过滤器与Python的字符串`join()`方法类似。您可以使用特定的字符或字符串将一系列项目连接成一个字符串。例如，一个如`[''music'',
    ''jazz'', ''piano'']`的标签列表通过`join()`分隔符`'',''`连接后，被转换成一个单独的字符串`''music, jazz,
    piano''`。'
- en: 'Open `http://127.0.0.1:8000/blog/` in your browser. You should be able to see
    the list of tags under each post title:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开`http://127.0.0.1:8000/blog/`。您应该能够看到每个帖子标题下的标签列表：
- en: '![](img/B21088_03_06.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_03_06.png)'
- en: 'Figure 3.6: The Post list item, including related tags'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：帖子列表项，包括相关标签
- en: Next, we will edit the `post_list` view to let users list all posts tagged with
    a specific tag.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编辑`post_list`视图，让用户列出带有特定标签的所有帖子。
- en: 'Open the `views.py` file of your `blog` application, import the `Tag` model
    from `django-taggit`, and change the `post_list` view to optionally filter posts
    by a tag, as follows. New code is highlighted in bold:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的`blog`应用的`views.py`文件，从`django-taggit`导入`Tag`模型，并将`post_list`视图修改为可选地通过标签过滤帖子，如下所示。新代码以粗体显示：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `post_list` view now works as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`post_list`视图现在的工作方式如下：'
- en: It takes an optional `tag_slug` parameter that has a `None` default value. This
    parameter will be passed in the URL.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它接受一个可选的`tag_slug`参数，默认值为`None`。此参数将被传递到URL中。
- en: Inside the view, we build the initial QuerySet, retrieving all published posts,
    and if there is a given tag slug, we get the `Tag` object with the given slug
    using the `get_object_or_404()` shortcut.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图中，我们构建初始的查询集，检索所有已发布的帖子，如果提供了一个标签缩写，我们使用`get_object_or_404()`快捷方式获取具有给定缩写的`Tag`对象。
- en: Then, we filter the list of posts by the ones that contain the given tag. Since
    this is a many-to-many relationship, we have to filter posts by tags contained
    in a given list, which, in this case, contains only one element. We use the `__in`
    field lookup. Many-to-many relationships occur when multiple objects of a model
    are associated with multiple objects of another model. In our application, a post
    can have multiple tags and a tag can be related to multiple posts. You will learn
    how to create many-to-many relationships in *Chapter 6*, *Sharing Content on Your
    Website*. You can discover more about many-to-many relationships at [https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/](https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/).
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过包含给定标签的帖子过滤帖子列表。由于这是一个多对多关系，我们必须通过给定列表中的标签过滤帖子，在这个例子中，列表中只有一个元素。我们使用`__in`字段查找。当多个模型对象与多个其他模型对象相关联时，会发生多对多关系。在我们的应用中，一个帖子可以有多个标签，一个标签可以与多个帖子相关联。您将在*第6章*，*在您的网站上共享内容*中学习如何创建多对多关系。您可以在[https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/](https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/)了解更多关于多对多关系的信息。
- en: Finally, the `render()` function now passes the new `tag` variable to the template.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`render()`函数现在将新的`tag`变量传递给模板。
- en: Remember that QuerySets are lazy. The QuerySets to retrieve posts will only
    be evaluated when you loop over `post_list` when rendering the template.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，查询集是懒加载的。检索帖子的查询集只有在您在渲染模板时遍历`post_list`时才会被评估。
- en: 'Open the `urls.py` file of your `blog` application, comment out the class-based
    `PostListView` URL pattern, and uncomment the `post_list` view, like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的 `blog` 应用程序的 `urls.py` 文件，注释掉基于类的 `PostListView` URL 模式，并取消注释 `post_list`
    视图，如下所示：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the following additional URL pattern to list posts by tag:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下额外的 URL 模式添加到按标签列出文章的功能中：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, both patterns point to the same view, but they have different
    names. The first pattern will call the `post_list` view without any optional parameters,
    whereas the second pattern will call the view with the `tag_slug` parameter. You
    use a `slug` path converter to match the parameter as a lowercase string with
    ASCII letters or numbers, plus the hyphen and underscore characters.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这两种模式都指向同一个视图，但它们有不同的名称。第一个模式将调用没有任何可选参数的 `post_list` 视图，而第二个模式将调用带有 `tag_slug`
    参数的视图。您使用 `slug` 路径转换器将参数匹配为小写字母、ASCII 字母或数字，以及连字符和下划线字符。
- en: 'The `urls.py` file of the `blog` application should now look like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`blog` 应用的 `urls.py` 文件现在应该看起来像这样：'
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Since you are using the `post_list` view, edit the `blog/post/list.html` template
    and modify the pagination to use the `posts` object:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你正在使用 `post_list` 视图，编辑 `blog/post/list.html` 模板并修改分页以使用 `posts` 对象：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add the following lines highlighted in bold to the `blog/post/list.html` template:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下加粗的行添加到 `blog/post/list.html` 模板中：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If a user is accessing the blog, they will see the list of all posts. If they
    filter by posts tagged with a specific tag, they will see the tag that they are
    filtering by.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户正在访问博客，他们将看到所有文章的列表。如果他们通过特定标签的文章进行过滤，他们将看到他们正在过滤的标签。
- en: 'Now, edit the `blog/post/list.html` template and change the way tags are displayed,
    as follows. New lines are highlighted in bold:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编辑 `blog/post/list.html` 模板并更改显示标签的方式，如下。新行被加粗：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, we loop through all the tags of a post displaying a custom
    link to the URL to filter posts by that tag. We build the URL with `{% url "blog:post_list_by_tag"
    tag.slug %}`, using the name of the URL and the `slug` tag as its parameter. You
    separate the tags with commas.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们遍历显示自定义链接到 URL 的文章的所有标签，以通过该标签过滤文章。我们使用 `{% url "blog:post_list_by_tag"
    tag.slug %}` 构建该 URL，使用 URL 名称和 `slug` 标签作为其参数。您使用逗号分隔标签。
- en: 'Open `http://127.0.0.1:8000/blog/tag/jazz/` in your browser. You will see the
    list of posts filtered by that tag, like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开 `http://127.0.0.1:8000/blog/tag/jazz/`。你会看到按该标签过滤的文章列表，如下所示：
- en: '![](img/B21088_03_07.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_03_07.png)'
- en: 'Figure 3.7: A post filtered by the tag “jazz”'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7：按标签“jazz”过滤的文章
- en: Retrieving posts by similarity
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过相似性检索文章
- en: Now that we have implemented tagging for blog posts, you can do many interesting
    things with tags. Tags allow you to categorize posts in a non-hierarchical manner.
    Posts about similar topics will have several tags in common. We will build a functionality
    to display similar posts by the number of tags they share. In this way, when a
    user reads a post, we can suggest to them that they read other related posts.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了博客文章的标签功能，你可以用标签做很多有趣的事情。标签允许你以非层次结构的方式对文章进行分类。关于类似主题的文章将具有几个共同的标签。我们将构建一个功能来显示具有共享标签数量的相似文章。这样，当用户阅读一篇文章时，我们可以建议他们阅读其他相关的文章。
- en: 'In order to retrieve similar posts for a specific post, you need to perform
    the following steps:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检索特定文章的相似文章，你需要执行以下步骤：
- en: Retrieve all tags for the current post.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取当前文章的所有标签。
- en: Get all posts that are tagged with any of those tags.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取所有带有任何这些标签的文章。
- en: Exclude the current post from that list to avoid recommending the same post.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从该列表中排除当前文章，以避免推荐相同的文章。
- en: Order the results by the number of tags shared with the current post.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按与当前文章共享的标签数量对结果进行排序。
- en: In the case of two or more posts with the same number of tags, recommend the
    most recent post.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有两个或更多文章具有相同数量的标签，建议最新的文章。
- en: Limit the query to the number of posts you want to recommend.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制查询到您想要推荐的帖子数量。
- en: These steps are translated into a complex QuerySet. Let’s edit the `post_detail`
    view to incorporate these similarity-based post suggestions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤被转换为一个复杂的 QuerySet。让我们编辑 `post_detail` 视图以包含基于相似性的文章建议。
- en: 'Open the `views.py` file of your `blog` application and add the following import
    at the top of it:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的 `blog` 应用程序的 `views.py` 文件，并在其顶部添加以下导入：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is the `Count` aggregation function of the Django ORM. This function will
    allow you to perform aggregated counts of tags. `django.db.models` includes the
    following aggregation functions:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '`Avg`: The mean value'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Max`: The maximum value'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Min`: The minimum value'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Count`: The total number of objects'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can learn about aggregation at [https://docs.djangoproject.com/en/5.0/topics/db/aggregation/](https://docs.djangoproject.com/en/5.0/topics/db/aggregation/).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `views.py` file of your `blog` application and add the following lines
    to the `post_detail` view. New lines are highlighted in bold:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding code is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: You retrieve a Python list of IDs for the tags of the current post. The `values_list()`
    QuerySet returns tuples with the values for the given fields. You pass `flat=True`
    to it to get single values such as `[1, 2, 3, ...]` instead of one tuple such
    as `[(1,), (2,), (3,) ...]`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You get all posts that contain any of these tags, excluding the current post
    itself.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You use the `Count` aggregation function to generate a calculated field—`same_tags`—that
    contains the number of tags shared with all the tags queried.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You order the result by the number of shared tags (descending order) and by
    `publish` to display recent posts first for the posts with the same number of
    shared tags. You slice the result to retrieve only the first four posts.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You pass the `similar_posts` object to the context dictionary for the `render()`
    function.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, edit the `blog/post/detail.html` template and add the following code highlighted
    in bold:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The post detail page should look like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_08.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: The post detail page, including a list of similar posts'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `http://127.0.0.1:8000/admin/blog/post/` in your browser, edit a post
    that has no tags, and add the `music` and `jazz` tags, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_09.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9: Adding the “jazz” and “music” tags to a post'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit another post and add the `jazz` tag, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_10.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: Adding the “jazz” tag to a post'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'The post detail page for the first post should now look like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_11.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.11: The post detail page, including a list of similar posts'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: The posts recommended in the **Similar posts** section of the page appear in
    descending order based on the number of shared tags with the original post.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: We are now able to successfully recommend similar posts to readers. `django-taggit`
    also includes a `similar_objects()` manager that you can use to retrieve objects
    by shared tags. You can take a look at all `django-taggit` managers at [https://django-taggit.readthedocs.io/en/latest/api.html](https://django-taggit.readthedocs.io/en/latest/api.html).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: You can also add the list of tags to your post detail template in the same way
    as you did in the `blog/post/list.html` template.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom template tags and filters
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django offers a variety of built-in template tags, such as `{% if %}` or `{%
    block %}`. You used different template tags in *Chapter 1*, *Building a Blog Application*,
    and *Chapter 2*, *Enhancing Your Blog with Advanced Features*. You can find a
    complete reference of built-in template tags and filters at [https://docs.djangoproject.com/en/5.0/ref/templates/builtins/](https://docs.djangoproject.com/en/5.0/ref/templates/builtins/).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了各种内置模板标签，例如`{% if %}`或`{% block %}`。你在*第一章*，*构建博客应用程序*和*第二章*，*使用高级功能增强你的博客*中使用了不同的模板标签。你可以在[https://docs.djangoproject.com/en/5.0/ref/templates/builtins/](https://docs.djangoproject.com/en/5.0/ref/templates/builtins/)找到内置模板标签和过滤器的完整参考。
- en: Django also allows you to create your own template tags to perform custom actions.
    Custom template tags come in very handy when you need to add a functionality to
    your templates that is not covered by the core set of Django template tags. This
    can be a tag to execute a QuerySet or any server-side processing that you want
    to reuse across templates. For example, we could build a template tag to display
    a list of the latest posts published on the blog. We could include this list in
    the sidebar so that it is always visible, regardless of the view that processes
    the request.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Django还允许你创建自己的模板标签来执行自定义操作。当你需要向模板添加核心Django模板标签集未涵盖的功能时，自定义模板标签非常有用。这可以是一个执行QuerySet或任何你想要在模板间重用的服务器端处理的标签。例如，我们可以构建一个模板标签来显示博客上最新发布的帖子列表。我们可以将这个列表包含在侧边栏中，使其始终可见，无论处理请求的是哪个视图。
- en: Implementing custom template tags
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现自定义模板标签
- en: 'Django provides the following helper functions, which allow you to easily create
    template tags:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了以下辅助函数，这些函数允许你轻松创建模板标签：
- en: '`simple_tag`: Processes the given data and returns a string'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`simple_tag`: 处理给定数据并返回一个字符串'
- en: '`inclusion_tag`: Processes the given data and returns a rendered template'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inclusion_tag`: 处理给定数据并返回一个渲染的模板'
- en: Template tags must live inside Django applications.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 模板标签必须位于Django应用程序内部。
- en: 'Inside your `blog` application directory, create a new directory, name it `templatetags`,
    and add an empty `__init__.py` file to it. Create another file in the same folder
    and name it `blog_tags.py`. The file structure of the blog application should
    look like the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`blog`应用程序目录中，创建一个新的目录，命名为`templatetags`，并向其中添加一个空的`__init__.py`文件。在同一个文件夹中创建另一个文件，命名为`blog_tags.py`。博客应用程序的文件结构应该如下所示：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The way you name the file is important because you will use the name of this
    module to load tags in templates.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你命名文件的方式很重要，因为你将使用这个模块的名称来在模板中加载标签。
- en: Creating a simple template tag
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的模板标签
- en: Let’s start by creating a simple tag to retrieve the total posts that have been
    published on the blog.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个简单的标签来检索博客上已发布的总帖子数开始。
- en: 'Edit the `templatetags/blog_tags.py` file you just created and add the following
    code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑你刚刚创建的`templatetags/blog_tags.py`文件，并添加以下代码：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We have created a simple template tag that returns the number of posts published
    on the blog.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个简单的模板标签，它返回博客上发布的帖子数量。
- en: Each module that contains template tags needs to define a variable called `register`
    to be a valid tag library. This variable is an instance of `template.Library`,
    and it’s used to register the template tags and filters of the application.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 每个包含模板标签的模块都需要定义一个名为`register`的变量，以使其成为一个有效的标签库。这个变量是`template.Library`的一个实例，它用于注册应用程序的模板标签和过滤器。
- en: In the preceding code, we have defined a tag called `total_posts` with a simple
    Python function. We have added the `@register.simple_tag` decorator to the function,
    to register it as a simple tag. Django will use the function’s name as the tag
    name.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了一个名为`total_posts`的标签，它使用了一个简单的Python函数。我们向函数添加了`@register.simple_tag`装饰器，以将其注册为一个简单标签。Django将使用函数的名称作为标签名称。
- en: If you want to register it using a different name, you can do so by specifying
    a `name` attribute, such as `@register.simple_tag(name='my_tag')`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想用不同的名称注册它，你可以通过指定一个`name`属性来实现，例如`@register.simple_tag(name='my_tag')`。
- en: After adding a new template tags module, you will need to restart the Django
    development server in order to use the new tags and filters in templates.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加新的模板标签模块后，你需要重新启动Django开发服务器，以便在模板中使用新的标签和过滤器。
- en: Before using custom template tags, we have to make them available for the template
    using the `{% load %}` tag. As mentioned before, we need to use the name of the
    Python module containing our template tags and filters.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用自定义模板标签之前，我们必须使用`{% load %}`标签使它们对模板可用。如前所述，我们需要使用包含我们的模板标签和过滤器的Python模块的名称。
- en: 'Edit the `blog/templates/base.html` template and add `{% load blog_tags %}`
    at the top of it to load your template tags module. Then, use the tag you created
    to display your total posts, as follows. The new lines are highlighted in bold:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`blog/templates/base.html`模板，并在其顶部添加`{% load blog_tags %}`以加载你的模板标签模块。然后，使用你创建的标签显示你的总帖子数，如下所示。新的行以粗体显示：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You will need to restart the server to keep track of the new files added to
    the project. Stop the development server with *Ctrl* + *C* and run it again using
    the following command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要重新启动服务器以跟踪项目中新添加的文件。使用*Ctrl* + *C*停止开发服务器，然后使用以下命令重新运行它：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Open `http://127.0.0.1:8000/blog/` in your browser. You should see the total
    number of posts in the sidebar of the site, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开`http://127.0.0.1:8000/blog/`。你应该在网站的侧边栏中看到帖子的总数，如下所示：
- en: '![](img/B21088_03_12.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_03_12.png)'
- en: 'Figure 3.12: The total posts published included in the sidebar'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12：包含在侧边栏中的总帖子数
- en: 'If you see the following error message, it’s very likely you didn’t restart
    the development server:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到以下错误信息，那么很可能你没有重新启动开发服务器：
- en: '![](img/B21088_03_13.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_03_13.png)'
- en: 'Figure 3.13: The error message when a template tag library is not registered'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13：当模板标签库未注册时的错误信息
- en: Template tags allow you to process any data and add it to any template regardless
    of the view executed. You can perform QuerySets or process any data to display
    results in your templates.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 模板标签允许你在任何视图中处理任何数据并将其添加到任何模板中。你可以执行查询集或处理任何数据以在模板中显示结果。
- en: Creating an inclusion template tag
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建包含模板标签
- en: We will create another tag to display the latest posts in the sidebar of the
    blog. This time, we will implement an inclusion tag. Using an inclusion tag, you
    can render a template with context variables returned by your template tag.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建另一个标签以在博客侧边栏中显示最新帖子。这次，我们将实现一个包含模板标签。使用包含模板标签，你可以渲染一个模板，该模板使用模板标签返回的上下文变量。
- en: 'Edit the `templatetags/blog_tags.py` file and add the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`templatetags/blog_tags.py`文件，并添加以下代码：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, we have registered the template tag using the `@register.inclusion_tag`
    decorator. We have specified the template that will be rendered with the returned
    values using `blog/post/latest_posts.html`. The template tag will accept an optional
    `count` parameter that defaults to `5`. This parameter will allow us to specify
    the number of posts to display. We use this variable to limit the results of the
    query `Post.published.order_by('-publish')[:count]`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`@register.inclusion_tag`装饰器注册了模板标签。我们使用`blog/post/latest_posts.html`指定了将使用返回值渲染的模板。模板标签将接受一个可选的`count`参数，默认值为`5`。此参数允许我们指定要显示的帖子数。我们使用此变量来限制查询`Post.published.order_by('-publish')[:count]`的结果。
- en: Note that the function returns a dictionary of variables instead of a simple
    value. Inclusion tags have to return a dictionary of values, which is used as
    the context to render the specified template. The template tag we just created
    allows us to specify the optional number of posts to display as `{% show_latest_posts
    3 %}`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该函数返回一个包含变量的字典而不是一个简单的值。包含标签必须返回一个包含值的字典，该字典用作渲染指定模板的上下文。我们刚刚创建的模板标签允许我们指定要显示的帖子可选数量，格式为`{%
    show_latest_posts 3 %}`。
- en: Now, create a new template file under `blog/post/` and name it `latest_posts.html`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`blog/post/`目录下创建一个新的模板文件，并将其命名为`latest_posts.html`。
- en: 'Edit the new `blog/post/latest_posts.html` template and add the following code
    to it:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑新的`blog/post/latest_posts.html`模板，并添加以下代码到其中：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding code, you have added an unordered list of posts using the
    `latest_posts` variable returned by your template tag. Now, edit the `blog/base.html`
    template and add the new template tag to display the last three posts, as follows.
    The new lines are highlighted in bold:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你使用由你的模板标签返回的`latest_posts`变量添加了一个无序列表。现在，编辑`blog/base.html`模板，并添加新的模板标签以显示最后三篇帖子，如下所示。新的行以粗体显示：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The template tag is called, passing the number of posts to display, and the
    template is rendered in place with the given context.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 调用模板标签时，传递要显示的帖子数，并使用给定上下文在适当位置渲染模板。
- en: 'Next, return to your browser and refresh the page. The sidebar should now look
    like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，返回你的浏览器并刷新页面。侧边栏现在应该看起来像这样：
- en: '![](img/B21088_03_14.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_03_14.png)'
- en: 'Figure 3.14: The blog sidebar, including the latest published posts'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14：博客侧边栏，包括最新发布的帖子
- en: Creating a template tag that returns a QuerySet
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个返回QuerySet的模板标签
- en: Finally, we will create a simple template tag that returns a value. We will
    store the result in a variable that can be reused, rather than outputting it directly.
    We will create a tag to display the most commented posts.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个简单的模板标签，它返回一个值。我们将结果存储在一个可重用的变量中，而不是直接输出。我们将创建一个标签来显示最多评论的帖子。
- en: 'Edit the `templatetags/blog_tags.py` file and add the following import and
    template tag to it:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`templatetags/blog_tags.py`文件，并添加以下导入和模板标签：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding template tag, you build a QuerySet using the `annotate()` function
    to aggregate the total number of comments for each post. You use the `Count` aggregation
    function to store the number of comments in the computed `total_comments` field
    for each `Post` object. You order the QuerySet by the computed field in descending
    order. You also provide an optional `count` variable to limit the total number
    of objects returned.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模板标签中，你使用`annotate()`函数构建一个QuerySet，以聚合每个帖子的总评论数。你使用`Count`聚合函数将评论数存储在每个`Post`对象的计算字段`total_comments`中。你按计算字段降序排列QuerySet。你还提供了一个可选的`count`变量来限制返回的对象总数。
- en: In addition to `Count`, Django offers the aggregation functions `Avg`, `Max`,
    `Min`, and `Sum`. You can read more about aggregation functions at [https://docs.djangoproject.com/en/5.0/topics/db/aggregation/](https://docs.djangoproject.com/en/5.0/topics/db/aggregation/).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Count`之外，Django还提供了聚合函数`Avg`、`Max`、`Min`和`Sum`。你可以在[https://docs.djangoproject.com/en/5.0/topics/db/aggregation/](https://docs.djangoproject.com/en/5.0/topics/db/aggregation/)了解更多关于聚合函数的信息。
- en: 'Next, edit the `blog/base.html` template and add the following code highlighted
    in bold:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编辑`blog/base.html`模板，并添加以下加粗显示的代码：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code, we store the result in a custom variable using the `as`
    argument followed by the variable name. For the template tag, we use `{% get_most_commented_posts
    as most_commented_posts %}` to store the result of the template tag in a new variable
    named `most_commented_posts`. Then, we display the returned posts using an HTML
    unordered list element.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`as`参数和变量名来存储结果，创建一个自定义变量。对于模板标签，我们使用`{% get_most_commented_posts
    as most_commented_posts %}`将模板标签的结果存储在一个名为`most_commented_posts`的新变量中。然后，我们使用HTML无序列表元素显示返回的帖子。
- en: 'Now open your browser and refresh the page to see the final result. It should
    look like the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开你的浏览器并刷新页面，查看最终结果。它应该看起来像以下这样：
- en: '![](img/B21088_03_15.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_03_15.png)'
- en: 'Figure 3.15: The post list view, including the complete sidebar with the latest
    and most commented posts'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15：帖子列表视图，包括包含最新和最多评论帖子的完整侧边栏
- en: You now have a clear idea of how to build custom template tags. You can read
    more about them at [https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/](https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在对如何构建自定义模板标签有了清晰的认识。你可以在[https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/](https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/)了解更多相关信息。
- en: Implementing custom template filters
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现自定义模板过滤器
- en: Django has a variety of built-in template filters that allow you to alter variables
    in templates. These are Python functions that take one or two parameters, the
    value of the variable that the filter is applied to, and an optional argument.
    They return a value that can be displayed or treated by another filter.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了一系列内置的模板过滤器，允许你在模板中更改变量。这些是Python函数，它们接受一个或两个参数，即应用过滤器的变量的值，以及一个可选的参数。它们返回一个可以显示或由另一个过滤器处理的值。
- en: A filter is written like `{{ variable``|my_filter` `}}`. Filters with an argument
    are written like `{{ variable``|my_filter:"foo"` `}}`. For example, you can use
    the `capfirst` filter to capitalize the first character of the value, like `{{
    value``|capfirst` `}}`. If `value` is `django`, the output will be `Django`. You
    can apply as many filters as you like to a variable, for example, `{{ variable``|filter1|filter2`
    `}}`, and each filter will be applied to the output generated by the preceding
    filter.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: You can find the list of Django’s built-in template filters at [https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#built-in-filter-reference](https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#built-in-filter-reference).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Creating a template filter to support Markdown syntax
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a custom filter to enable you to use Markdown syntax in your
    blog posts and then convert the post body to HTML in the templates.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Markdown is a plain-text formatting syntax that is very simple to use, and it’s
    intended to be converted into HTML. You can write posts using simple Markdown
    syntax and get the content automatically converted into HTML code. Learning Markdown
    syntax is much easier than learning HTML. By using Markdown, you can get other
    non-tech-savvy contributors to easily write posts for your blog. You can learn
    the basics of the Markdown format at [https://daringfireball.net/projects/markdown/basics](https://daringfireball.net/projects/markdown/basics).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install the Python `markdown` module via `pip` using the following command
    in the shell prompt:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, edit the `templatetags/blog_tags.py` file and include the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We register template filters in the same way as template tags. To prevent a
    name clash between the function name and the `markdown` module, we have named
    the function `markdown_format` and we have named the filter `markdown` for use
    in templates, such as `{{ variable|markdown }}`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Django escapes the HTML code generated by filters; characters of HTML entities
    are replaced with their HTML-encoded characters. For example, `<p>` is converted
    to `&lt;p&gt;` (*less than* symbol, *p* character, *greater than* symbol).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: We use the `mark_safe` function provided by Django to mark the result as safe
    HTML to be rendered in the template. By default, Django will not trust any HTML
    code and will escape it before placing it in the output. The only exceptions are
    variables that are marked as safe from escaping. This behavior prevents Django
    from outputting potentially dangerous HTML and allows you to create exceptions
    for returning safe HTML.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: In Django, HTML content is escaped by default for security. Use `mark_safe`
    cautiously, only on content you control. Avoid using `mark_safe` on any content
    submitted by non-staff users to prevent security vulnerabilities.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `blog/post/detail.html` template and add the following new code highlighted
    in bold:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We have replaced the `linebreaks` filter of the `{{ post.body }}` template variable
    with the `markdown` filter. This filter will not only transform line breaks into
    `<p>` tags; it will also transform Markdown formatting into HTML.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Storing text in Markdown format in the database, rather than HTML, is a wise
    security strategy. Markdown limits the potential for injecting malicious content.
    This approach ensures that any text formatting is safely converted to HTML only
    at the point of rendering the template.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `blog/post/list.html` template and add the following new code highlighted
    in bold:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We have added the new `markdown` filter to the `{{ post.body }}` template variable.
    This filter will transform the Markdown content into HTML.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we have replaced the previous `truncatewords` filter with the `truncatewords_html`
    filter. This filter truncates a string after a certain number of words, avoiding
    unclosed HTML tags.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open `http://127.0.0.1:8000/admin/blog/post/add/` in your browser and create
    a new post with the following body:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The form should look like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_16.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.16: The post with Markdown content rendered as HTML'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `http://127.0.0.1:8000/blog/` in your browser and take a look at how the
    new post is rendered. You should see the following output:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_17.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.17: The post with Markdown content rendered as HTML'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 3.17*, custom template filters are very useful for
    customizing formatting. You can find more information about custom filters at
    [https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/#writing-custom-template-filters](https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/#writing-custom-template-filters).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Adding a sitemap to the site
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django comes with a sitemap framework, which allows you to generate sitemaps
    for your site dynamically. A sitemap is an XML file that tells search engines
    the pages of your website, their relevance, and how frequently they are updated.
    Using a sitemap will make your site more visible in search engine rankings because
    it helps crawlers to index your website’s content.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The Django sitemap framework depends on `django.contrib.sites`, which allows
    you to associate objects to particular websites that are running with your project.
    This comes in handy when you want to run multiple sites using a single Django
    project. To install the sitemap framework, we will need to activate both the `sites`
    and `sitemap` applications in your project. We are going to build a sitemap for
    the blog that includes the links to all published posts.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `settings.py` file of the project and add `django.contrib.sites` and
    `django.contrib.sitemaps` to the `INSTALLED_APPS` setting. Also, define a new
    setting for the site ID, as follows. New code is highlighted in bold:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, run the following command from the shell prompt to create the tables of
    the Django site application in the database:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You should see an output that contains the following lines:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `sites` application is now synced with the database.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a new file inside your `blog` application directory and name it
    `sitemaps.py`. Open the file and add the following code to it:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We have defined a custom sitemap by inheriting the `Sitemap` class of the `sitemaps`
    module. The `changefreq` and `priority` attributes indicate the change frequency
    of your post pages and their relevance in your website (the maximum value is `1`).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: The `items()` method returns the QuerySet of objects to include in this sitemap.
    By default, Django calls the `get_absolute_url()` method on each object to retrieve
    its URL. Remember that we implemented this method in *Chapter 2*, *Enhancing Your
    Blog with Advanced Features*, to define the canonical URL for posts. If you want
    to specify the URL for each object, you can add a `location` method to your sitemap
    class.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: The `lastmod` method receives each object returned by `items()` and returns
    the last time the object was modified.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Both the `changefreq` and `priority` attributes can be either methods or attributes.
    You can take a look at the complete sitemap reference in the official Django documentation
    located at [https://docs.djangoproject.com/en/5.0/ref/contrib/sitemaps/](https://docs.djangoproject.com/en/5.0/ref/contrib/sitemaps/).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: We have created the sitemap. Now we just need to create a URL for it.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the main `urls.py` file of the `mysite` project and add the sitemap, as
    follows. New lines are highlighted in bold:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code, we have included the required imports and defined a `sitemaps`
    dictionary. Multiple sitemaps can be defined for the site. We have defined a URL
    pattern that matches the `sitemap.xml` pattern and uses the `sitemap` view provided
    by Django. The `sitemaps` dictionary is passed to the `sitemap` view.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the development server from the shell prompt with the following command:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Open `http://127.0.0.1:8000/sitemap.xml` in your browser. You will see an XML
    output including all of the published posts, like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The URL for each `Post` object is built by calling its `get_absolute_url()`
    method.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: The `lastmod` attribute corresponds to the post `updated` date field, as you
    specified in your sitemap, and the `changefreq` and `priority` attributes are
    also taken from the `PostSitemap` class.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: The domain used to build the URLs is `example.com`. This domain comes from a
    `Site` object stored in the database. This default object was created when you
    synced the site’s framework with your database. You can read more about the `sites`
    framework at [https://docs.djangoproject.com/en/5.0/ref/contrib/sites/](https://docs.djangoproject.com/en/5.0/ref/contrib/sites/).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `http://127.0.0.1:8000/admin/sites/site/` in your browser. You should
    see something like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_18.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.18: The Django administration list view for the Site model of the
    site’s framework'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3.18* contains the list display administration view for the site’s
    framework. Here, you can set the domain or host to be used by the site’s framework
    and the applications that depend on it. To generate URLs that exist in your local
    environment, change the domain name to `localhost:8000`, as shown in *Figure 3.19*,
    and save it:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_19.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.19: The Django administration edit view for the Site model of the
    site’s framework'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Open `http://127.0.0.1:8000/sitemap.xml` in your browser again. The URLs displayed
    in your sitemap will now use the new hostname and look like `http://localhost:8000/blog/2024/1/22/markdown-post/`.
    Links are now accessible in your local environment. In a production environment,
    you will have to use your website’s domain to generate absolute URLs.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Creating feeds for blog posts
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django has a built-in syndication feed framework that you can use to dynamically
    generate RSS or Atom feeds in a similar manner to creating sitemaps using the
    site’s framework. A web feed is a data format (usually XML) that provides users
    with the most recently updated content. Users can subscribe to the feed using
    a feed aggregator, a software that is used to read feeds and get new content notifications.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file in your `blog` application directory and name it `feeds.py`.
    Add the following lines to it:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding code, we have defined a feed by subclassing the `Feed` class
    of the syndication framework. The `title`, `link`, and `description` attributes
    correspond to the `<title>`, `<link>`, and `<description>` RSS elements, respectively.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: We use `reverse_lazy()` to generate the URL for the `link` attribute. The `reverse()`
    method allows you to build URLs by their name and pass optional parameters. We
    used `reverse()` in *Chapter 2*, *Enhancing Your Blog with Advanced Features*.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: The `reverse_lazy()` utility function is a lazily evaluated version of `reverse()`.
    It allows you to use a URL reversal before the project’s URL configuration is
    loaded.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: The `items()` method retrieves the objects to be included in the feed. We retrieve
    the last five published posts to include them in the feed.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: The `item_title()`, `item_description()`, and `item_pubdate()` methods will
    receive each object returned by `items()` and return the title, description, and
    publication date for each item.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: In the `item_description()` method, we use the `markdown()` function to convert
    Markdown content to HTML and the `truncatewords_html()` template filter function
    to cut the description of posts after 30 words, avoiding unclosed HTML tags.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, edit the `blog/urls.py` file, import the `LatestPostsFeed` class, and
    instantiate the feed in a new URL pattern, as follows. New lines are highlighted
    in bold:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Navigate to `http://127.0.0.1:8000/blog/feed/` in your browser. You should
    now see the RSS feed, including the last five blog posts:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If you use Chrome, you will see the XML code. If you use Safari, it will ask
    you to install an RSS feed reader.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Let’s install an RSS desktop client to view the RSS feed with a user-friendly
    interface. We will use Fluent Reader, which is a multi-platform RSS reader.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Download Fluent Reader for Linux, macOS, or Windows from [https://github.com/yang991178/fluent-reader/releases](https://github.com/yang991178/fluent-reader/releases).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Fluent Reader and open it. You will see the following screen:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing chart  Description automatically generated](img/B21088_03_20.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.20: Fluent Reader with no RSS feed sources'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the settings icon in the top-right corner of the window. You will
    see a screen to add RSS feed sources like the following one:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B21088_03_21.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.21: Adding an RSS feed in Fluent Reader'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Enter `http://127.0.0.1:8000/blog/feed/` in the **Add source** field and click
    on the **Add** button.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see a new entry with the RSS feed of the blog in the table below the
    form, like this:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B21088_03_22.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.22: RSS feed sources in Fluent Reader'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go back to the main screen of Fluent Reader. You should be able to see
    the posts included in the blog RSS feed, as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B21088_03_23.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.23: RSS feed of the blog in Fluent Reader'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on a post to see a description:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_24.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.24: The post description in Fluent Reader'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the third icon in the top-right corner of the window to load the full
    content of the post page:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_25.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.25: The full content of a post in Fluent Reader'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: The final step is to add an RSS feed subscription link to the blog’s sidebar.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `blog/base.html` template and add the following code highlighted in
    bold:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now open `http://127.0.0.1:8000/blog/` in your browser and take a look at the
    sidebar. The new link will take users to the blog’s feed:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_26.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.26: The RSS feed subscription link added to the sidebar'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about the Django syndication feed framework at [https://docs.djangoproject.com/en/5.0/ref/contrib/syndication/](https://docs.djangoproject.com/en/5.0/ref/contrib/syndication/).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Adding full-text search to the blog
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we will add search capabilities to the blog. Searching for data in the
    database with user input is a common task for web applications. The Django ORM
    allows you to perform simple matching operations using, for example, the `contains`
    filter (or its case-insensitive version, `icontains`). You can use the following
    query to find posts that contain the word `framework` in their body:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: However, if you want to perform complex search lookups, retrieving results by
    similarity, or by weighting terms based on how frequently they appear in the text
    or how important different fields are (for example, the relevancy of the term
    appearing in the title versus in the body), you will need to use a full-text search
    engine. When you consider large blocks of text, building queries with operations
    on a string of characters is not enough. A full-text search examines the actual
    words against stored content as it tries to match search criteria.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您想执行复杂的搜索查询，通过相似度检索结果，或者根据它们在文本中出现的频率或不同字段的重要性（例如，标题中出现的术语与正文中出现的术语的相关性）来加权术语，您将需要使用全文搜索引擎。当考虑大量文本块时，仅使用字符串上的操作构建查询是不够的。全文搜索在尝试匹配搜索条件时会检查实际单词与存储内容之间的对比。
- en: Django provides a powerful search functionality built on top of PostgreSQL database
    full-text search features. The `django.contrib.postgres` module provides functionalities
    offered by PostgreSQL that are not shared by the other databases that Django supports.
    You can learn about PostgreSQL’s full-text search support at [https://www.postgresql.org/docs/16/textsearch.html](https://www.postgresql.org/docs/16/textsearch.html).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了一个基于PostgreSQL数据库全文搜索功能的强大搜索功能。`django.contrib.postgres`模块提供了PostgreSQL提供的功能，这些功能是Django支持的其他数据库所不具备的。您可以在[https://www.postgresql.org/docs/16/textsearch.html](https://www.postgresql.org/docs/16/textsearch.html)了解PostgreSQL的全文搜索支持。
- en: Although Django is a database-agnostic web framework, it provides a module that
    supports part of the rich feature set offered by PostgreSQL, which is not offered
    by other databases that Django supports.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Django是一个数据库无关的Web框架，但它提供了一个模块，支持PostgreSQL提供的部分丰富功能集，而Django支持的其他数据库则没有提供。
- en: We are currently using an SQLite database for the `mysite` project. SQLite support
    for full-text search is limited and Django doesn’t support it out of the box.
    However, PostgreSQL is much better suited for full-text search and we can use
    the `django.contrib.postgres` module to use PostgreSQL’s full-text search capabilities.
    We will migrate our data from SQLite to PostgreSQL to benefit from its full-text
    search features.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前为`mysite`项目使用SQLite数据库。SQLite对全文搜索的支持有限，Django默认也不支持。然而，PostgreSQL非常适合全文搜索，我们可以使用`django.contrib.postgres`模块来利用PostgreSQL的全文搜索功能。我们将把数据从SQLite迁移到PostgreSQL，以利用其全文搜索特性。
- en: SQLite is sufficient for development purposes. However, for a production environment,
    you will need a more powerful database, such as PostgreSQL, MariaDB, MySQL, or
    Oracle.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite对于开发目的来说是足够的。然而，对于生产环境，您将需要一个更强大的数据库，例如PostgreSQL、MariaDB、MySQL或Oracle。
- en: PostgreSQL provides a Docker image that makes it very easy to deploy a PostgreSQL
    server with a standard configuration.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL提供了一个Docker镜像，使得部署具有标准配置的PostgreSQL服务器变得非常容易。
- en: Installing Docker
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Docker
- en: Docker is a popular open-source containerization platform. It enables developers
    to package applications into containers, simplifying the process of building,
    running, managing, and distributing applications.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一个流行的开源容器化平台。它使开发者能够将应用程序打包到容器中，简化了构建、运行、管理和分发应用程序的过程。
- en: First, download and install Docker for your OS. You will find instructions for
    downloading and installing Docker on Linux, macOS, and Windows at [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).
    The installation includes both Docker Desktop and Docker command-line interface
    tools.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，下载并安装适用于您操作系统的Docker。您可以在[https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)找到关于在Linux、macOS和Windows上下载和安装Docker的说明。安装包括Docker桌面和Docker命令行界面工具。
- en: Installing PostgreSQL
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装PostgreSQL
- en: 'After installing Docker on your Linux, macOS, or Windows machine, you can easily
    pull the PostgreSQL Docker image. Run the following command from the shell:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Linux、macOS或Windows机器上安装Docker后，您可以轻松地拉取PostgreSQL Docker镜像。从shell中运行以下命令：
- en: '[PRE49]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This will download the PostgreSQL Docker image to your local machine. You can
    find information about the official PostgreSQL Docker image at [https://hub.docker.com/_/postgres](https://hub.docker.com/_/postgres).
    You can find other PostgreSQL packages and installers at [https://www.postgresql.org/download/](https://www.postgresql.org/download/).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载PostgreSQL Docker镜像到您的本地机器。您可以在[https://hub.docker.com/_/postgres](https://hub.docker.com/_/postgres)找到有关官方PostgreSQL
    Docker镜像的信息。您可以在[https://www.postgresql.org/download/](https://www.postgresql.org/download/)找到其他PostgreSQL软件包和安装程序。
- en: 'Execute the following command in the shell to start the PostgreSQL Docker container:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Replace `xxxxx` with the desired password for your database user.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'This command starts a PostgreSQL instance. The `--name` option is used to assign
    a name to the container, in this case, `blog_db`. The `-e` option is to define
    environment variables for the instance. We set the following environment variables:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '`POSTGRES_DB`: Name of the PostgreSQL database. If not defined, the value of
    `POSTGRES_USER` is used for the database name.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POSTGRES_USER`: Used in conjunction with `POSTGRES_PASSWORD` to define a username
    and password. The user is created with superuser power.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POSTGRES_PASSWORD`: Sets the superuser password for PostgreSQL.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-p` option is used to publish the `5432` port, on which PostgreSQL runs,
    to the same host interface port. This allows external applications to access the
    database. The `-d` option is for *detached mode*, which runs the Docker container
    in the background.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Docker Desktop application. You should see the new container running,
    as in *Figure 3.27*:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_27.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.27: PostgreSQL instance running in Docker Desktop'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: You will see the newly created `blog_db` container, with the status **Running**.
    Under **Actions**, you can stop or restart the service. You can also delete the
    container. Note that deleting the container will also eliminate the database and
    all the data it contains. You will learn how to persist PostgreSQL data in the
    local filesystem using Docker in *Chapter 17*, *Going Live*.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'You also need to install the `psycopg` PostgreSQL adapter for Python. Run the
    following command in the shell prompt to install it:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Next, we will migrate the existing data in the SQLite database to the new PostgreSQL
    instance.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Dumping the existing data
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before switching the database in the Django project, we need to dump the existing
    data from the SQLite database. We will export the data, switch the project’s database
    to PostgreSQL, and import the data into the new database.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Django comes with a simple way to load and dump data from the database into
    files that are called **fixtures**. Django supports fixtures in JSON, XML, or
    YAML format. We are going to create a fixture with all data contained in the database.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: The `dumpdata` command dumps data from the database into the standard output,
    serialized in JSON format by default. The resulting data structure includes information
    about the model and its fields for Django to be able to load it into the database.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: You can limit the output to the models of an application by providing the application
    names to the command, or specifying single models for outputting data using the
    `app.Model` format. You can also specify the format using the `--format` flag.
    By default, `dumpdata` outputs the serialized data to the standard output. However,
    you can indicate an output file using the `--output` flag. The `--indent` flag
    allows you to specify indentation. For more information on `dumpdata` parameters,
    run `python manage.py dumpdata --help`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command from the shell prompt:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'All existing data has been exported in JSON format to a new file named `mysite_data.json`.
    You can view the file contents to see the JSON structure that includes all the
    different data objects for the different models of your installed applications.
    If you get an encoding error when running the command, include the `-Xutf8` flag
    as follows to activate Python UTF-8 mode:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We will now switch the database in the Django project and then we will import
    the data into the new database.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Switching the database in the project
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now you will add the PostgreSQL database configuration to your project settings.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `settings.py` file of your project and modify the `DATABASES` setting
    to make it look as follows. New code is highlighted in bold:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The database engine is now `postgresql`. The database credentials are now loaded
    from environment variables using `python-decouple`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add values to the environment variables. Edit the `.env` file of your
    project and add the following lines highlighted in bold:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Replace `xxxxxx` with the password you used when starting the PostgreSQL container.
    The new database is empty.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to apply all database migrations to the new PostgreSQL
    database:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'You will see an output, including all the migrations that have been applied,
    like this:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The PostgreSQL database is now in sync with your data models and you can run
    your Django project pointing to the new database. Let’s get the database to the
    same state by loading the data we previously exported from SQLite.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Loading the data into the new database
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to load the data fixtures we generated previously into our new
    PostgreSQL database.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to load the previously exported data into the PostgreSQL
    database:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You will see the following output:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The number of objects might differ, depending on the users, posts, comments,
    and other objects that have been created in the database.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the development server from the shell prompt with the following command:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Open `http://127.0.0.1:8000/admin/blog/post/` in your browser to verify that
    all posts have been loaded into the new database. You should see all the posts,
    as follows:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_28.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.28: The list of posts on the administration site'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Simple search lookups
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having enabled PostgreSQL in our project, we can now build a powerful search
    engine by leveraging PostgreSQL’s full-text search capabilities. We will begin
    with basic search lookups and progressively incorporate more sophisticated features,
    such as stemming, ranking, or weighting queries, to build a comprehensive full-text
    search engine.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `settings.py` file of your project and add `django.contrib.postgres`
    to the `INSTALLED_APPS` setting, as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Open the Django shell by running the following command in the system shell
    prompt:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now you can search against a single field using the `search` QuerySet lookup.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following code in the Python shell:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This query uses PostgreSQL to create a search vector for the `title` field and
    a search query from the term `django`. Results are obtained by matching the query
    with the vector.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Searching against multiple fields
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might want to search against multiple fields. In this case, you will need
    to define a `SearchVector` object. Let’s build a vector that allows you to search
    against the `title` and `body` fields of the `Post` model.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following code in the Python shell:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Using `annotate` and defining `SearchVector` with both fields, you provide a
    functionality to match the query against both the `title` and `body` of the posts.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Full-text search is an intensive process. If you are searching for more than
    a few hundred rows, you should define a functional index that matches the search
    vector you are using. Django provides a `SearchVectorField` field for your models.
    You can read more about this at [https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/#performance](https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/#performance).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Building a search view
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, you will create a custom view to allow your users to search posts. First,
    you will need a search form. Edit the `forms.py` file of the `blog` application
    and add the following form:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You will use the `query` field to let users introduce search terms. Edit the
    `views.py` file of the `blog` application and add the following code to it:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In the preceding view, first, we instantiate the `SearchForm` form. To check
    whether the form is submitted, we look for the `query` parameter in the `request.GET`
    dictionary. We send the form using the `GET` method instead of `POST` so that
    the resulting URL includes the `query` parameter and is easy to share. When the
    form is submitted, we instantiate it with the submitted `GET` data and verify
    that the form data is valid. If the form is valid, we search for published posts
    with a custom `SearchVector` instance built with the `title` and `body` fields.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: The search view is now ready. We need to create a template to display the form
    and the results when the user performs a search.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file inside the `templates/blog/post/` directory, name it `search.html`,
    and add the following code to it:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As in the search view, we distinguish whether the form has been submitted by
    the presence of the `query` parameter. Before the query is submitted, we display
    the form and a submit button. When the search form is submitted, we display the
    query performed, the total number of results, and the list of posts that match
    the search query.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, edit the `urls.py` file of the `blog` application and add the following
    URL pattern highlighted in bold:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, open `http://127.0.0.1:8000/blog/search/` in your browser. You should
    see the following search form:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_29.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.29: The form with the query field to search for posts'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a query and click on the **SEARCH** button. You will see the results
    of the search query, as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_30.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.30: Search results for the term “jazz”'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have created a basic search engine for your blog.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Stemming and ranking results
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stemming is the process of reducing words to their word stem, base, or root
    form. Stemming is used by search engines to reduce indexed words to their stem,
    and to be able to match inflected or derived words. For example, the words “music,”
    “musical,” and “musicality” can be considered similar words by a search engine.
    The stemming process normalizes each search token into a lexeme, a unit of lexical
    meaning that underlies a set of words that are related through inflection. The
    words “music,” “musical,” and “musicality” would convert to “music” when creating
    a search query.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Django provides a `SearchQuery` class to translate terms into a search query
    object. By default, the terms are passed through stemming algorithms, which helps
    you to obtain better matches.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: The PostgreSQL search engine also removes stop words, such as “a,” “the,” “on,”
    and “of.” Stop words are a set of commonly used words in a language. They are
    removed when creating a search query because they appear too frequently to be
    relevant to searches. You can find the list of stop words used by PostgreSQL for
    the English language at [https://github.com/postgres/postgres/blob/master/src/backend/snowball/stopwords/english.stop](https://github.com/postgres/postgres/blob/master/src/backend/snowball/stopwords/english.stop).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: We also want to order results by relevancy. PostgreSQL provides a ranking function
    that orders results based on how often the query terms appear and how close together
    they are.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `blog` application and add the following imports:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then, edit the `post_search` view, as follows. New code is highlighted in bold:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In the preceding code, we create a `SearchQuery` object, filter results by it,
    and use `SearchRank` to order the results by relevancy.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: 'You can open `http://127.0.0.1:8000/blog/search/` in your browser and test
    different searches to test stemming and ranking. The following is an example of
    ranking by the number of occurrences of the word `django` in the title and body
    of the posts:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_31.png)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.31: Search results for the term “django”'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Stemming and removing stop words in different languages
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can set up `SearchVector` and `SearchQuery` to execute stemming and remove
    stop words in any language. We can pass a `config` attribute to `SearchVector`
    and `SearchQuery` to use a different search configuration. This allows us to use
    different language parsers and dictionaries. The following example executes stemming
    and removes stop words in Spanish:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: You can find the Spanish stop words dictionary used by PostgreSQL at [https://github.com/postgres/postgres/blob/master/src/backend/snowball/stopwords/spanish.stop](https://github.com/postgres/postgres/blob/master/src/backend/snowball/stopwords/spanish.stop).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Weighting queries
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can boost specific vectors so that more weight is attributed to them when
    ordering results by relevancy. For example, we can use this to give more relevance
    to posts that are matched by title rather than by content.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `blog` application and modify the `post_search`
    view as follows. New code is highlighted in bold:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In the preceding code, we apply different weights to the search vectors built
    using the `title` and `body` fields. The default weights are `D`, `C`, `B`, and
    `A`, and they refer to the numbers `0.1`, `0.2`, `0.4`, and `1.0`, respectively.
    We apply a weight of `1.0` to the `title` search vector (`A`) and a weight of
    `0.4` to the `body` vector (`B`). Title matches will prevail over body content
    matches. We filter the results to display only the ones with a rank higher than
    `0.3`.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Searching with trigram similarity
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another search approach is trigram similarity. A trigram is a group of three
    consecutive characters. You can measure the similarity of two strings by counting
    the number of trigrams that they share. This approach turns out to be very effective
    for measuring the similarity of words in many languages.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: To use trigrams in PostgreSQL, you will need to install the `pg_trgm` database
    extension first. Django provides database migration operations to create PostgreSQL
    extensions. Let’s add a migration that creates the extension in the database.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: 'First, execute the following command in the shell prompt to create an empty
    migration:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This will create an empty migration for the `blog` application. You will see
    the following output:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Edit the file `blog/migrations/0005_trigram_ext.py` and add the following lines
    highlighted in bold:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You have added the `TrigramExtension` operation to the database migration. This
    operation executes the SQL statement `CREATE EXTENSION pg_trgm` to create the
    extension in PostgreSQL.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about database migration operations at [https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/operations/](https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/operations/).
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'Now execute the migration with the following command:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'You will see the following output:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `pg_trgm` extension has been created in the database. Let’s modify `post_search`
    to search for trigrams.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of your `blog` application and add the following import:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Then, modify the `post_search` view as follows. New code is highlighted in
    bold:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Open `http://127.0.0.1:8000/blog/search/` in your browser and test different
    searches for trigrams. The following example displays a hypothetical typo in the
    `django` term, showing search results for `yango`:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_03_32.png)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.32: Search results for the term “yango”'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: We have added a powerful search engine to the blog application.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about full-text search with Django and PostgreSQL
    at [https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/](https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you implemented a tagging system by integrating a third-party
    application into your project. You generated post recommendations using complex
    QuerySets. You also learned how to create custom Django template tags and filters
    to provide templates with custom functionalities. You also created a sitemap for
    search engines to crawl your site and an RSS feed for users to subscribe to your
    blog. You then built a search engine for your blog using the full-text search
    engine of PostgreSQL.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to build a social website using the
    Django authentication framework and how to implement user account functionalities
    and custom user profiles.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: Expanding your project using AI
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having completed the blog application, you likely have numerous ideas for adding
    new functionalities to your blog. This section aims to provide some insights into
    exploring new functionalities to incorporate into your project with the assistance
    of ChatGPT. ChatGPT is a sophisticated AI **Large Language Model** (**LLM**) created
    by OpenAI that generates human-like responses based on the prompts it receives.
    In this section, you will be presented with a task to extend your project, accompanied
    by a sample prompt for ChatGPT to assist you.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: Engage with ChatGPT at [https://chat.openai.com/](https://chat.openai.com/).
    You will find similar guidance after completing each Django project within this
    book, in *Chapter 7*, *Tracking User Actions*, *Chapter 11*, *Adding Internationalization
    to Your Shop*, and *Chapter 17*, *Going Live*.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: Let’s further enhance your blog with the help of ChatGPT. Your blog currently
    allows filtering posts by tags. Adding these tags to our sitemap could significantly
    improve the SEO optimization of the blog. Use the prompt provided at [https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter03/prompts/task.md](https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter03/prompts/task.md)
    for adding tag pages to the sitemap. This challenge is an excellent opportunity
    to refine your project and deepen your understanding of Django, while learning
    to interact with ChatGPT.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: ChatGPT is ready to assist with code issues. Simply share your code along with
    any errors you’re facing, and ChatGPT can help you identify and resolve the issues.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  id: totrans-470
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resources provide additional information related to the topics
    covered in this chapter:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: 'Source code for this chapter: [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter03](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter03)'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django-taggit`: [https://github.com/jazzband/django-taggit](https://github.com/jazzband/django-taggit)'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django-taggit` ORM managers: [https://django-taggit.readthedocs.io/en/latest/api.html](https://django-taggit.readthedocs.io/en/latest/api.html)'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Many-to-many relationships: [https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/](https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/)'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django aggregation functions: [https://docs.djangoproject.com/en/5.0/topics/db/aggregation/](https://docs.djangoproject.com/en/5.0/topics/db/aggregation/)'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Built-in template tags and filters: [https://docs.djangoproject.com/en/5.0/ref/templates/builtins/](https://docs.djangoproject.com/en/5.0/ref/templates/builtins/)'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Writing custom template tags: [https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/](https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/)'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Markdown format reference: [https://daringfireball.net/projects/markdown/basics](https://daringfireball.net/projects/markdown/basics
    )'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django sitemap framework: [https://docs.djangoproject.com/en/5.0/ref/contrib/sitemaps/](https://docs.djangoproject.com/en/5.0/ref/contrib/sitemaps/)'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django sites framework: [https://docs.djangoproject.com/en/5.0/ref/contrib/sites/](https://docs.djangoproject.com/en/5.0/ref/contrib/sites/)'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django syndication feed framework: [https://docs.djangoproject.com/en/5.0/ref/contrib/syndication/](https://docs.djangoproject.com/en/5.0/ref/contrib/syndication/)'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker download and installation instructions: [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PostgreSQL Docker image: [https://hub.docker.com/_/postgres](https://hub.docker.com/_/postgres)'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PostgreSQL downloads: [https://www.postgresql.org/download/](https://www.postgresql.org/download/)'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PostgreSQL full-text search capabilities: [https://www.postgresql.org/docs/16/textsearch.html](https://www.postgresql.org/docs/16/textsearch.html)'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Database migration operations: [https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/operations/](https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/operations/).'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django support for PostgreSQL full-text search – [https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/](https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/)
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ChatGPT interface – [https://chat.openai.com/](https://chat.openai.com/)
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sample ChatGPT prompt to add tag pages to the sitemap – [https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter03/prompts/task.md](https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter03/prompts/task.md)
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
