- en: Building Robots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a Rover-Pi robot with forward driving motors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using advanced motor control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a six-legged Pi-Bug robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling servos directly with ServoBlaster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding objects and obstacles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a sense of direction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A little computer with a "brain the size of a planet" (to quote Douglas Adams,
    the author of *Hitchhiker's Guide to the Galaxy*) would be perfect as the brain
    of your own robotic creation. In reality, the Raspberry Pi probably provides far
    more processing power than a little robot or rover needs; however, its small size,
    excellent connectivity, and fairly low-power requirements mean that it is ideally
    suited.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will focus on exploring the various ways we can combine motors
    or servos to produce robotic movement, use sensors to gather information, and
    allow our creation to act upon it.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to check out the *Appendix,* *Hardware and Software List*; it lists
    all of the items used in this chapter and the places you can obtain them from.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Rover-Pi robot with forward driving motors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating robots does not need to be an expensive hobby. A small, rover-type
    robot can be constructed using household items for the chassis (the base everything
    is attached to), and a couple of small driving motors can be used to move it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Rover-Pi robot is a small, buggy-type robot that has two wheels and a skid
    or caster at the front to allow it to turn. One such robot is shown in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bafe4de4-9f36-4a25-ad0e-a4a59bc345d0.png)'
  prefs: []
  type: TYPE_IMG
- en: A home-built Rover-Pi robot
  prefs: []
  type: TYPE_NORMAL
- en: While it may not be in the same league as a Mars exploration rover, as you will
    see, there is plenty for you to experiment with.
  prefs: []
  type: TYPE_NORMAL
- en: You can also purchase one of many inexpensive robot kits that contain most of
    what you need in a single package (see the *There's more...* section at the end
    of this example).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The rover that we will build will need to contain the elements shown in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95cd43ca-57d0-4cb8-9f58-cd4b7627a6d1.png)'
  prefs: []
  type: TYPE_IMG
- en: The separate parts of the Rover-Pi robot
  prefs: []
  type: TYPE_NORMAL
- en: 'The elements are discussed in detail as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chassis**: This example uses a modified, battery-operated push nightlight
    (although any suitable platform can be used). Remember that the larger and heavier
    your robot is, the more powerful the driving motors will need to be to move it.
    Alternatively, you can use one of the chassis kits listed in the *There''s more...*
    section. A suitable push nightlight is shown in the following photo:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/8c391727-19e1-4f95-a1cb-2c22e2b11a3f.png)'
  prefs: []
  type: TYPE_IMG
- en: This push nightlight forms the basic chassis of a Rover-Pi robot
  prefs: []
  type: TYPE_NORMAL
- en: '**Front skid or caster**: This can be as simple as a large paper clip (76 mm/3
    inches) bent into shape, or a small caster wheel. A skid works best when it is
    on a smooth surface, but it may get stuck on the carpet. A caster wheel works
    well on all surfaces, but sometimes, it can have problems turning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wheels, motors,** **and gears**: The wheel movement of the Rover-Pi robot
    is a combination of the motor, gears, and wheels. The gears are helpful, as they
    allow a fast-spinning motor to turn the wheels at a slower speed and more force
    (torque); this will allow for better control of our robot. A unit that combines
    the wheels, motors, and gears in a single unit is shown in the following photo:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/c889b0cd-b66c-4320-9c4f-30e407900480.png)'
  prefs: []
  type: TYPE_IMG
- en: These wheels, with built-in geared motors, are ideal for small rovers
  prefs: []
  type: TYPE_NORMAL
- en: '**Battery/power source**: The Rover-Pi robot will be powered using four AA
    batteries, fitted into the bay of the chassis. Alternatively, a standard battery
    holder can be used, or even a long wire connected to a suitable power supply.
    It is recommended that you power the motors from a supply independent from the
    Raspberry Pi. This will help to avoid a situation in which the Raspberry Pi suddenly
    loses power when driving the motors, which require a big jump in current to move.
    Alternatively, you can power the Raspberry Pi with the batteries using a 5V regulator.
    The following image shows a chassis with four AA batteries:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/e267b815-edb5-4a07-9fce-c463c4fb6e0f.png)'
  prefs: []
  type: TYPE_IMG
- en: Four AA batteries provide a power source to drive the wheels
  prefs: []
  type: TYPE_NORMAL
- en: '**Motor driver/controller**: Motors will require a voltage and current greater
    than the GPIO can handle. Therefore, we will use a **Darlington array module**
    (which uses a **ULN2003** chip). See the *There''s more...* section at the end
    of this example for more details on how this particular module works. The following
    photo shows a Darlington array module:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/89b8f536-48c5-4789-82e6-843f383a4908.png)'
  prefs: []
  type: TYPE_IMG
- en: This Darlington array module, available at http://www.dx.com, can be used to
    drive small motors
  prefs: []
  type: TYPE_NORMAL
- en: '**Small cable ties or wire ties**: This will allow us to attach items, such
    as a motor or a controller, to the chassis. The following photo shows the use
    of cable ties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/cbabca2d-a3d8-4ac5-a6a1-fdcf4b410098.png)'
  prefs: []
  type: TYPE_IMG
- en: We use cable ties to secure the motors and wheels to the chassis
  prefs: []
  type: TYPE_NORMAL
- en: '**The Raspberry Pi connection**: The easiest setup is to attach the control
    wires to the Raspberry Pi using long cables, so that you can easily control your
    robot directly using an attached screen and keyboard. Later, you can consider
    mounting the Raspberry Pi on the robot and controlling it remotely (or even autonomously,
    if you include sensors and intelligence to make sense of them).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will use the `wiringpi2` Python library to control the GPIO;
    see [Chapter 10](18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml), *Sensing and Displaying
    Real-World Data*, for details on how to install it using a Python package manager
    (`pip`).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to create a small Rover-Pi robot:'
  prefs: []
  type: TYPE_NORMAL
- en: At the front of the chassis, you will need to mount the skid by bending the
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'paperclip/wire into a V shape. Attach the paperclip/wire to the front of the
    chassis by drilling small holes on either side, threading cable ties through the
    holes around the wire, and pulling tightly to secure. The fitted wire skid should
    look similar to the one shown in the following photo:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/15f491a6-7324-409e-bd1f-8c1b5bd4ba56.png)'
  prefs: []
  type: TYPE_IMG
- en: Wire skid fitted to the front of the Rover-Pi robot
  prefs: []
  type: TYPE_NORMAL
- en: Before you mount the wheels, you need to work out the approximate center of
    gravity of the chassis (do this with the batteries fitted in the chassis, as they
    will affect the balance). Get a feel of where the center is by trying to balance
    the unit on two fingers on either side and finding out how far forward or backward
    the chassis tilts. For my unit, this was about 1 cm (approximately one-third of
    an inch) back from the center. You should aim to place the wheel axles slightly
    behind this so that the rover will rest slightly forward on the skid. Mark the
    location of the wheels on the chassis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drill three holes on each side to mount the wheels using the cable ties. If
    the cable ties aren''t long enough, you can join two together by pulling the end
    of one through the end of the other (only pull through far enough for the tie
    to grip so that it extends the tie). The following diagram shows how you can use
    the cable ties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/865c1168-1f2a-4f4c-824f-fd9670b66fab.png)'
  prefs: []
  type: TYPE_IMG
- en: Securely fix the motors to the chassis
  prefs: []
  type: TYPE_NORMAL
- en: Next, test the motors by inserting the batteries into the unit; then, disconnect
    the wires that originally connected to the bulb, and touch them to the motor contacts.
    Determine which connection on the motor should be positive and which should be
    negative for the motor to move the robot forward (the top of the wheel should
    move forward when the robot is facing forwards). Connect red and black wires to
    the motor (on mine, black equals negative at the top of the motor, and red equals
    positive at the bottom), ensuring that the wires are long enough to reach anywhere
    on the chassis (around 14 cm, that is, approximately 5.5 inches, is enough for
    the nightlight).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Rover-Pi robot components should be wired up as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/656be4cb-1881-424a-a309-1648d435aa04.png)'
  prefs: []
  type: TYPE_IMG
- en: The wiring layout of the Rover-Pi robot
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the connections, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the black wires of the motors to the **OUT 1** (left) and **OUT 2**
    (right) output of the Darlington module, and connect the red wires to the last
    pin (the COM connection).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, connect the battery wires to the **GND**/**V-** and **V+** connections
    at the bottom of the module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, connect the **GND** from the GPIO connector (**Pin 6**) to the same
    **GND** connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the motor control by connecting 3.3V (GPIO **Pin 1**) to **IN1** or **IN2,**
    to simulate a GPIO output. When you're happy, connect GPIO **Pin 16** to **IN1**
    (for left) and GPIO **Pin 18** to **IN2** (for right).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The wiring should now match the details given in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Raspberry Pi GPIO** | **Darlington module** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Pin 16: Left | IN1 |'
  prefs: []
  type: TYPE_TB
- en: '| Pin 18: Right | IN2 |'
  prefs: []
  type: TYPE_TB
- en: '| Pin 6: GND | GND/V- (marked with -) |'
  prefs: []
  type: TYPE_TB
- en: '| **Motor 4 x AA battery Darlington module** |  |'
  prefs: []
  type: TYPE_TB
- en: '| Positive side of battery | V+ (marked with +) |'
  prefs: []
  type: TYPE_TB
- en: '| Negative side of battery | GND/V- (marked with -) |'
  prefs: []
  type: TYPE_TB
- en: '| **Motors** |  |'
  prefs: []
  type: TYPE_TB
- en: '| Left motor: black wire | OUT 1 (top pin in white socket) |'
  prefs: []
  type: TYPE_TB
- en: '| Right motor: black wire | OUT 2 (second pin in white socket) |'
  prefs: []
  type: TYPE_TB
- en: '| Both motors: red wires | COM (last pin in white socket) |'
  prefs: []
  type: TYPE_TB
- en: 'Use the following `rover_drivefwd.py` script to test the control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Remember that `wiringpi2` should be installed before running the scripts in
    this chapter (see [Chapter 10](18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml)*, Sensing
    and Displaying Real-World Data*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the previous code using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The script will prompt you with the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can enter a series of commands to follow; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will instruct the Rover-Pi robot to perform a series
    of movements: forward (`f`), right (`r`), pause (`#`), and left (`l`).'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have built the robot and wired up the wheels to the motor controller,
    you can work out how to control it.
  prefs: []
  type: TYPE_NORMAL
- en: Start by importing `time` (which will allow you to put pauses in the motor control)
    and `wiringpi2` (to allow control of the GPIO pins). Use `wiringpi2` here, since
    it makes it much easier to make use of I/O expanders and other I²C devices, if
    you want to later on.
  prefs: []
  type: TYPE_NORMAL
- en: Define values to use for setting the pins `ON`/`OFF`, for the direction `IN`/`OUT`,
    as well as the duration of each motor `STEP`. Also, define which `PINS` are wired
    to the motor controls, and our movements, `FWD`, `RIGHT`, and `LEFT`. The movement
    is defined in such a way that by switching both motors `ON`, you will move forward,
    and by switching just one motor `ON`, you will turn. By setting these values at
    the start of the file using variables, our code is easier to maintain and understand.
  prefs: []
  type: TYPE_NORMAL
- en: We define a `motor` class that will allow us to reuse it in other code, or easily
    swap it with alternative `motor` classes so that we can use other hardware if
    we want to. We set the default pins we are using and our `steptime` value (the
    `steptime` object defines how long we drive the motor(s) for in each step). However,
    both can still be specified when initializing the object, if desired.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call `GPIOsetup()`; it selects the physical pin numbering mode (so
    we can refer to the pins as they are located on the board). We also set all of
    the pins we are using to output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, for the `motor` class, we define the following three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: The first function we define (called `off()`) will allow us to switch off the
    motors, so we cycle through the pins list and set each GPIO pin to low (and therefore
    switch the motors off).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `drive()` function allows us to provide a list of drive actions (a combination
    of `ON` and `OFF` for each of the GPIO pins). Again, we cycle through each of
    the pins and set them to the corresponding drive action, wait for the step time,
    and then switch the motors off using the `off()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last function we define (called `cmd()`) simply allows us to send `char`
    (a single character) and use it to select the set of drive actions we want to
    use (`FWD`, `RIGHT` or `LEFT`, or wait (`#`)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For testing, `main()` allows us to specify a list of actions that need to be
    performed from the command line using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Using `os.environ` (by importing the `os` module so we can use it), we can check
    for `CMD` in the command and use it as our list of drive actions. If no `CMD`
    command has been provided, we can use the `input()` function to directly prompt
    for a list of drive actions. To use the `motor` class, we set `roverPi=motor()`;
    this allows us to call the `cmd()` function (of the motor class) with each character
    from the list of drive actions.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your robot should be limited only by your own creativity. There are lots of
    suitable chassis options, other motors, wheels, and ways to control and drive
    the wheels. You should experiment and test things to determine which combinations
    work best together. That is all part of the fun!
  prefs: []
  type: TYPE_NORMAL
- en: Darlington array circuits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Darlington transistors are a low-cost way to drive high powered devices, such
    as motors, or even relays. They consist of two transistors arranged in a series,
    where one feeds the other (allowing the gain in the current to be multiplied).
    That is, if the first transistor has a gain of 20, and the second one also has
    a gain of 20, together, they will provide an overall gain of 400.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that 1 mA on the base pin (1) in the following diagram will allow
    you to drive up to 400 mA through the Darlington transistor. The Darlington transistor''s
    electrical symbol is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/191e59cf-7f88-477c-8a19-aea25cd5e912.png)'
  prefs: []
  type: TYPE_IMG
- en: The electrical symbol for a Darlington transistor shows how two transistors
    are packaged together
  prefs: []
  type: TYPE_NORMAL
- en: 'The ULN2003 chip is used in the previous module and provides seven NPN Darlington
    transistors (an eight-way version, ULN2803, is also available if more output is
    required or to use with two stepper motors). The following diagram shows how a
    Darlington array can be used to drive motors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d26fc7b8-0679-423e-950f-92f6079a2ada.png)'
  prefs: []
  type: TYPE_IMG
- en: A Darlington array being used to drive two small motors
  prefs: []
  type: TYPE_NORMAL
- en: Each output from the chip can supply a maximum of 500 mA at up to 50V (enough
    to power most small motors). However, with extended use, the chip may overheat,
    so a heat sink is recommended when driving larger motors. An internal diode, connected
    across each Darlington for protection, is built into the chip. This is needed
    because when the motor moves without being driven (this can occur due to the natural
    momentum of the motor), it will act like a generator. A reverse voltage called
    **back EMF** is created, which would destroy the transistor if it wasn't dissipated
    back through the diode.
  prefs: []
  type: TYPE_NORMAL
- en: One disadvantage of the chip is that the positive supply voltage must always
    be connected to the common pin (COM), so each output is only able to sink current.
    That is, it will only drive the motor in one direction, with the positive voltage
    on COM and the negative voltage on the OUT pins. Therefore, we will need a different
    solution if we wish to drive our Rover-Pi robot in different directions (see the
    next example in the *Using advanced motor control* recipe).
  prefs: []
  type: TYPE_NORMAL
- en: These chips can also be used to drive certain types of stepper motors. One of
    the modules from [http://www.dx.com](http://www.dx.com) includes a stepper motor
    as a part of the kit. Although the gearing is for very slow movement, at around
    12 seconds per rotation (too slow for a rover), it is still interesting to use
    (for a clock, perhaps).
  prefs: []
  type: TYPE_NORMAL
- en: Transistor and relay circuits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Relays are able to handle much more highly powered motors, since they are mechanical
    switches controlled by an electromagnetic coil that physically moves the contacts
    together. However, they require a reasonable amount of current to be turned on
    – usually more than 3.3V. To switch even small relays, we need around 60 mA at
    5V (more than is available from the GPIO), so we will still need to use some additional
    components to switch it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the Darlington array (as used previously) or a small transistor
    (any small transistor, such as the 2N2222, will be fine) to provide the current
    and voltage required to switch it. The following circuit will allow us to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0503f39-881f-4f37-9084-64bbdc8a4bde.png)'
  prefs: []
  type: TYPE_IMG
- en: The transistor and relay circuit used to drive external circuits
  prefs: []
  type: TYPE_NORMAL
- en: Much like a motor, a relay can also generate EMF spikes, so a protection diode
    is needed to avoid any reverse voltage on the transistor.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very useful circuit, not just for driving motors, but for any external
    circuit; the physical switch allows it to be independent and electrically isolated
    from the Raspberry Pi controlling it.
  prefs: []
  type: TYPE_NORMAL
- en: As long as the relay is rated correctly, you can drive DC or AC devices through
    it.
  prefs: []
  type: TYPE_NORMAL
- en: You can use some relays to control items powered by the mains. However, this
    should be done only with extreme caution and proper electrical training. Electricity
    from the mains can kill or cause serious harm.
  prefs: []
  type: TYPE_NORMAL
- en: PiBorg has a ready-made module named the **PicoBorg** that will allow the switching
    of up to four relays. It uses devices called **metal-oxide-semiconductor field-effect
    transistor** (**MOSFETs**), which are essentially high-power versions of transistors
    that function with the same principle as discussed previously.
  prefs: []
  type: TYPE_NORMAL
- en: Tethered or untethered robots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important choice when designing your own Rover-Pi robot is to decide if you
    want to make it fully self-contained, or if you are happy to have a tether (a
    long control/power cable connected to the Rover-Pi). Using a tether, you can keep
    the weight of the Rover-Pi robot down, which means the small motors will be able
    to move the unit with ease. This will allow you to keep the Raspberry Pi separate
    from the main unit so that it can remain connected to a screen and keyboard for
    easy programming and debugging. The main disadvantage is that you will need a
    long, umbilical-like connection to your Rover-Pi robot (with a wire for each control
    signal) that may impede its movement. However, as we will see later, you may only
    need three or four wires to provide all of the control you need (see the *Using
    I/O expanders* section in the next recipe).
  prefs: []
  type: TYPE_NORMAL
- en: If you intend to mount the Raspberry Pi directly on the Rover-Pi robot, you
    will need a suitable power supply, such as a phone charger battery pack. If the
    battery pack has two USB ports, then you may be able to use it as a power source
    to drive both the Raspberry Pi and the motors. The unit must be able to maintain
    the supplies independently, as any power spike caused by driving the motors could
    reset the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that if the Raspberry Pi is now attached to the robot, you will need
    a means to control it. This could be a USB Wi-Fi dongle that allows a remote connection
    via SSH (and so on), or a wireless keyboard (that uses RF/Bluetooth), or even
    the GPIO D-Pad from [Chapter 9](7cf87b89-8982-4d64-852c-ddfcbf742be5.xhtml)*,*
    *Using Python to Drive Hardware*, which can be used for direct control.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the more you mount on the chassis, the harder the motors will need
    to work to move. You may find that stronger motors are required, rather than the
    little ones used here. A Rover-Pi robot powered by a USB battery pack is shown
    in the following photo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd3e2b82-820b-4567-8188-4dfbf9c5f28b.png)'
  prefs: []
  type: TYPE_IMG
- en: A battery-powered Raspberry Rover-Pi robot being controlled via Wi-Fi (cable
    management is optional)
  prefs: []
  type: TYPE_NORMAL
- en: Rover kits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you don''t fancy making your own chassis, there are also a number of pre-made
    rover chassis available. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 2WD Magician Robot Chassis from [https://www.sparkfun.com/](https://www.sparkfun.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4-Motor Smart Car Chassis from [http://www.dx.com/](http://www.dx.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2-Wheel Smart Car Model from [http://www.dx.com/](http://www.dx.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/9b82efda-c4a1-4664-b20b-89df3bd606cc.png)'
  prefs: []
  type: TYPE_IMG
- en: The TiddlyBot shows how multiple components can be integrated together within
    a single platform, as shown in my modified version
  prefs: []
  type: TYPE_NORMAL
- en: A particularly nice robot setup is the TiddlyBot (from [http://www.PiBot.org](http://www.PiBot.org)),
    which combines multiple sensors, continuous servos, an onboard battery pack, and
    the Raspberry Pi camera. An SD card is set up so the TiddlyBot acts as a Wi-Fi
    hotspot, hosting a simple drag and drop programming platform with a remote control
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'This shows how simple components such as the ones described in this chapter
    can be combined into a complete system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30dba40d-cbf7-40e9-8848-52235a04ab63.png)'
  prefs: []
  type: TYPE_IMG
- en: The TiddlyBot GUI provides a cross-platform drag and drop interface, as well
    as Python support
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to check out the *Appendix,* *Hardware and Software List*; it lists
    all of the items used in this chapter and the places you can obtain them from.
  prefs: []
  type: TYPE_NORMAL
- en: Using advanced motor control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous driving circuits are not suitable for driving motors in more than
    one direction (as they only switch the motor on or off). However, using a circuit
    named an H-bridge, you can switch and control the motor's direction, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'The switch combinations are shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/881f7600-1cd8-424b-825b-c7ba093b61ae.png)'
  prefs: []
  type: TYPE_IMG
- en: The direction of the motor can be controlled by different switch combinations
  prefs: []
  type: TYPE_NORMAL
- en: Using a different combination of switching, we can change the direction of the
    motor by switching the positive and negative supply to the motor (**SW1** and
    **SW4** activate the motor, and **SW2** and **SW3** reverse the motor). However,
    not only do we need four switching devices for each motor, but since the ULN2X03
    devices and PiBorg's PicoBorg module can only sink current, equivalent devices
    would be required to source current (to make up the top section of switches).
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there are purpose-built H-bridge chips, such as L298N, that contain
    the previous circuit inside them to provide a powerful and convenient way to control
    motors.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We shall replace the previous Darlington array module with the H-bridge motor
    controller shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f87ecfb3-c480-432a-960c-98b82371d5b5.png)'
  prefs: []
  type: TYPE_IMG
- en: The H-bridge motor controller allows for directional control of motors
  prefs: []
  type: TYPE_NORMAL
- en: The datasheet of L298N is available at [http://www.st.com/resource/en/datasheet/l298.pdf](http://www.st.com/resource/en/datasheet/l298.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The unit will need to be wired as follows (this will be similar for other H-bridge
    type controllers, but check with the relevant datasheet if unsure).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows how the motors and motor power supply connect to
    the H-bridge controller module:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **The motor side of the module – connecting to the battery and motors** |'
  prefs: []
  type: TYPE_TB
- en: '| **Motor A** | **VMS** | **GND** | **5V OUT** | **Motor B** |'
  prefs: []
  type: TYPE_TB
- en: '| Left motor red wire | Left motor black wire | Battery positive | Battery
    GND | None | Right motor red wire | Right motor black wire |'
  prefs: []
  type: TYPE_TB
- en: 'The following table shows how the H-bridge controller module connects to the
    Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Control side of the module – connecting to the Raspberry Pi GPIO header**
    |'
  prefs: []
  type: TYPE_TB
- en: '| **ENA** | **IN1** | **IN2** | **IN3** | **IN4** | **ENB** | **GND** | **5V**
    |'
  prefs: []
  type: TYPE_TB
- en: '| None | Pin 15 | Pin 16 | Pin 18 | Pin 22 | None | Pin 6 | None |'
  prefs: []
  type: TYPE_TB
- en: It is recommended that you keep the pull-up resistor jumpers on (UR1-UR4) and
    allow the motor supply to power the onboard voltage regulator, which will in turn
    power the L298N controller (jumper 5V_EN). The onboard regulator (the 78M05 device)
    can supply up to 500 mA, enough for the L298N controller plus any additional circuits,
    such as an I/O expander (see the *There's more...* section for more information).
    Both the ENA and ENB pins should be disconnected (the motor output will stay enabled
    by default).
  prefs: []
  type: TYPE_NORMAL
- en: You will need to make the following changes to the previous `rover_drivefwd.py`
    script (you can save it as `rover_drive.py`).
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the file, redefine `PINS`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And update the control patterns, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add the backwards command to `cmd()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can update the prompt that we have within the `main()` function
    to include `b` (backwards) as an option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The H-bridge motor controller recreates the previous switching circuit with
    additional circuitry to ensure that the electronic switches cannot create a short
    circuit (by not allowing **SW1** and **SW3** or **SW2** and **SW4** to be enabled
    at the same time).
  prefs: []
  type: TYPE_NORMAL
- en: 'The H-bridge motor controller''s switching circuit is shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af7d428f-5369-4292-87cd-9f650af08322.png)'
  prefs: []
  type: TYPE_IMG
- en: An approximation of the H-bridge switching circuit (in motor off state)
  prefs: []
  type: TYPE_NORMAL
- en: 'The input (**IN1** and **IN2**) will produce the following action on the motors:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **IN1****IN2** | **0** | **1** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Motor off | Motor backwards |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Motor forwards | Motor off |'
  prefs: []
  type: TYPE_TB
- en: As we did in the previous recipe, we can move forward by driving both motors
    forward; however, now we can drive them both backwards (to move backwards), as
    well as in opposite directions (allowing us to turn the Rover-Pi robot on the
    spot).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can achieve finer control of the motors using a **pulse width modulated**
    (**PWM**) signal and expand the available input/output using an I/O expander.
  prefs: []
  type: TYPE_NORMAL
- en: Motor speed control using PWM control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, the Rover-Pi robot motors are controlled by being switched on and
    off; however, if the robot is moving too fast (for example, if you have fitted
    bigger motors or used higher gearing), we can make use of the **ENA** and **ENB**
    input on the controller. If these are set low, the motor output is disabled, and
    if set high, it is enabled again. Therefore, by driving them with a PWM signal,
    we can control the speed of the motors. We could even set slightly different PWM
    rates (if required) to compensate for any differences in the motors/wheels or
    surface to drive them at slightly different speeds, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e07deb5-6fa5-4f0e-9758-fd94920bc0d4.png)'
  prefs: []
  type: TYPE_IMG
- en: A PWM signal controls the ratio of the ON and OFF times
  prefs: []
  type: TYPE_NORMAL
- en: A PWM signal is a digital on/off signal that has different amounts of **ON**
    time compared to **OFF** time. A motor driven with a 50:50, `ON:OFF` signal would
    drive a motor with half the power of an ON signal at 100 percent, and would therefore
    run more slowly. Using different ratios, we can drive the motors at different
    speeds.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the hardware PWM of the Raspberry Pi (GPIO pin 12 can use the PWM
    driver).
  prefs: []
  type: TYPE_NORMAL
- en: The PWM driver normally provides one of the audio channels of the analog audio
    output. Sometimes, this generates interference; therefore, it is suggested that
    you disconnect any devices connected to the analog audio socket.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hardware PWM function is enabled in `wiringpi2` by setting the pin mode
    to `2` (which is the value of `PWM`) and specifying the on time (represented as
    `ON_TIME`) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: However, this is only suitable for joint PWM motor control (as it is connected
    to both ENA and ENB), since there is only the one available hardware PWM output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another alternative is to use the software PWM function of `wiringpi2`. This
    creates a crude PWM signal using software; depending on your requirements, this
    may be acceptable. The code for generating a software PWM signal on GPIO Pin 7
    and GPIO Pin 11 is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The previous code sets both pins to 100 Hz, with GPIO Pin 7 set to an on time
    of 2 ms (and an off time of 8 ms) and GPIO Pin 11 set to 7.5 ms/2.5 ms.
  prefs: []
  type: TYPE_NORMAL
- en: To adjust the PWM timings, use `wiringpi2.softPwmWrite(PWM_PIN_ENA,ON_TIME2)`.
  prefs: []
  type: TYPE_NORMAL
- en: The accuracy of the PWM signal may be interrupted by other system processes,
    but it can control a small micro servo, even if it's slightly jittery.
  prefs: []
  type: TYPE_NORMAL
- en: Using I/O expanders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw previously (in [Chapter 10](18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml)*,
    Sensing and Displaying Real-World Data*), `wiringpi2` allows us to easily adjust
    our code to make use of I/O expanders using I²C. In this case, it can be useful
    to add additional circuits, such as sensors and LED status indicators, and perhaps
    even displays and control buttons, to assist with debugging and controlling the
    Rover-Pi robot as you develop it.
  prefs: []
  type: TYPE_NORMAL
- en: It can be particularly helpful if you intend to use it as a tethered device,
    since you will only require three wires to connect back to the Raspberry Pi (I²C
    Data GPIO Pin 3, I²C Clock GPIO Pin 5, and Ground GPIO Pin 6), with I²C VCC being
    provided by the motor controller 5V output.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the earlier example, add defines for the I²C address and pin base,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `gpiosetup()`, set up the MCP23017 device using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that any pin references you make are numbered 100-115 (to refer to the
    I/O expander pins A0-7 and B0-7) with `AF_BASE` added (which is the pin offset
    for the I/O expander).
  prefs: []
  type: TYPE_NORMAL
- en: Building a six-legged Pi-Bug robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Controlling motors is very useful for creating vehicle-like robots, but creating
    more naturally behaving robot components (such as servos) can provide excellent
    results. There are many creative designs of insect-like robots, or even biped
    designs (with humanoid-like legs) that use servos to provide natural joint movements.
    The design in this example uses three servos, but these principles and concepts
    can be easily applied to far more complex designs, to control legs/arms that use
    multiple servos. The Pi-Bug robot is shown in the following photo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed9160f7-9a28-49f7-aa44-7570e062ab06.png)'
  prefs: []
  type: TYPE_IMG
- en: The six-legged Pi-Bug robot uses a servo driver to control three servos to scuttle
    around
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A PWM driver module**: A driver module, such as the Adafruit 16-Channel 12-bit
    PWM/Servo Driver, will be needed. This uses a PCA9685 device; see the datasheet
    at [http://www.adafruit.com/datasheets/PCA9685.pdf](http://www.adafruit.com/datasheets/PCA9685.pdf)
    for details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Three micro servos**: The MG90S 9g Metal Gear Servos provide a reasonable
    amount of torque at a low cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A heavy gauge wire**: This will form the legs; three giant paper clips (76
    mm/3 inches) are ideal for this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A light gauge wire/cable ties**: These will be used to connect the legs to
    the servos and to mount the servos to the main board.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A small section of plywood or fiberboard**: Holes can be drilled into this,
    and the servos can be mounted on it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will need to have `wiringpi2` installed to control the PWM module, and
    it will be useful to install the I²C tools for debugging. See [Chapter 10](18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml)*,*
    *Sensing and Displaying Real-World Data*, for details on how to install `wiringpi2`
    and the I²C tools. The I²C connections are shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbaa7e3f-bce7-4e6e-9416-ea11985823d6.png)'
  prefs: []
  type: TYPE_IMG
- en: I²C connections on the Raspberry Pi GPIO header
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Pi-Bug robot uses three servos, one on either side and one in the middle.
    Mount each servo by drilling a hole on either side of the servo body, looping
    a wire or cable ties through it, and pulling to hold the servo tightly.
  prefs: []
  type: TYPE_NORMAL
- en: Bend the paper clip wire into a suitable shape to form the Pi-Bug robot's legs,
    and add a small kink that will allow you to wire the legs securely to the servo
    arms. It is recommended that you run the program first, with the Pi-Bug robot
    set to the home position `h`, before you screw the servo arms in place. This will
    ensure that the legs are located in the middle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the components on the Pi-Bug robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/685df7fb-978b-4972-a039-6687ed5887af.png)'
  prefs: []
  type: TYPE_IMG
- en: The layout of components on the Pi-Bug robot
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following `servoAdafruit.py` script to control the servos:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the following `bug_drive.py` script to control the Pi-Bug robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We explain the previous script functions by exploring how the servos are controlled
    using a PWM. Next, we will see how the servo class provides the methods to control
    the PCA9685 device. Finally, we will look at how the movements of the three servos
    combine to produce forward and turning motions for the Pi-Bug robot itself.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the servos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To control the servos used for the Pi-Bug robot, we require a special control
    signal that will determine the angle that the servo is required to move to. We
    will send the servo a PWM signal, where the duration of the on time will allow
    us to control the angle of the servo arm (and thereby, allow us to control the
    Pi-Bug robot''s legs). The following diagram shows how a PWM signal can be used
    to control the angle of the servo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a9a4381-b5a5-4511-b506-a25d11c08280.png)'
  prefs: []
  type: TYPE_IMG
- en: The angle of the servo is controlled by the duration of the up time of the PWM
    signal
  prefs: []
  type: TYPE_NORMAL
- en: 'Most servos will have an angular range of approximately 180 degrees and a mid-position
    of 90 degrees. A PWM frequency of 50 Hz will have a period of 20 ms, and the mid-position
    of 90 degrees typically corresponds to an **Up Time** of 1.5 ms, with a range
    of +/- 0.5 ms to 0.4 ms for near 0 degrees and near 180 degrees. Each type of
    servo will be slightly different, but you should be able to adjust the code to
    suit if required. The following diagram shows how you can control the servo angle
    using different PWM Up Times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb6c51ea-bcd6-4172-bc8e-cbc08088dc50.png)'
  prefs: []
  type: TYPE_IMG
- en: The servo angle is controlled by sending a PWM Up Time between 1 ms and 2 ms
  prefs: []
  type: TYPE_NORMAL
- en: Another type of servo is called a **continuous servo** (not used here). It allows
    you to control the rotation speed instead of the angle, and will rotate at a constant
    speed depending on the PWM signal that has been applied. Both servo types have
    internal feedback loops that will continuously drive the servo until the required
    angle or speed is reached.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is theoretically possible to generate these signals using software,
    you will find that any tiny interruption by other processes on the system will
    interfere with the signal timing; this, in turn, will produce an erratic response
    from the servo. This is why we use a hardware PWM controller, which only needs
    to be set with a specific up and down time, to then automatically generate the
    required signal for us.
  prefs: []
  type: TYPE_NORMAL
- en: The servo class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The servo code is based on the PWM driver that Adafruit uses for their module;
    however, it is not Python 3 friendly, so we need to create our own version. We
    will use `wiringpi2` I²C driver to initialize and control the I²C PWM controller.
    We define the registers that we will need to use (see the datasheet for the PCA9685
    device), as well as its default bus address, `0x40` (PWMADR), and a PWM frequency
    of 50 Hz (PWMHZ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Within our servo class, we initialize the I²C driver in `wiringpi2` and set
    up our `devPWM` device on the bus. Next, we initialize the PWM device itself (using
    `pwmInit()`). We have to calculate the **prescaler** required for the device to
    convert the onboard 25 MHz clock to a 50 Hz signal to generate the PWM frequency
    we need; we will use the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/104d3ec4-d744-42af-a7a2-12c2173d007c.png)'
  prefs: []
  type: TYPE_IMG
- en: The prescale register value sets the PWM frequency using a 12-bit value to scale
    the 25 MHz clock
  prefs: []
  type: TYPE_NORMAL
- en: The prescale value is loaded into the device, and a device reset is triggered
    to enable it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a function to allow the PWM `ON` and `OFF` times to be controlled.
    The `ON` and `OFF` times are 12-bit values (0-4096), so each value is split into
    upper and lower bytes (8-bits each) that need to be loaded into two registers.
    For the `L` (low) registers, we mask off the upper 8 bits using `&0xFF`, and for
    the `H` (high) registers, we shift down by 8 bits to provide the higher 8 bits.
    Each PWM channel will have two registers for the on time and two for the off time,
    so we can multiply the addresses of the first PWM channel registers by 4 and the
    channel number to get the addresses of any of the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test our `servo` class, we define the minimum and maximum ranges of the
    servos, which we calculate as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The PWM frequency of 50 Hz has a 20 ms period (*T=1/f*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ON/OFF times range from 0-4,096 (so 0 ms to 20 ms)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we can calculate the control values for 0 degrees (1 ms) and 180 degrees
    (2 ms)
  prefs: []
  type: TYPE_NORMAL
- en: 'as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 ms (servo min) is equal to 4,096/20 ms, which is 204.8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 ms (servo max) is equal to 4,096/10 ms, which is 409.6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We round the values to the nearest whole number.
  prefs: []
  type: TYPE_NORMAL
- en: Learning to walk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Pi-Bug robot uses a common design that allows three servos to be used to
    create a small, six-legged robot. The servos at the two ends provide forward and
    backward movement, while the servo in the middle provides the control. The following
    photo shows the mounted servos:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85460822-6d89-418f-88f8-769d2b59e31b.png)'
  prefs: []
  type: TYPE_IMG
- en: The servos are mounted upside-down on the underside of the board
  prefs: []
  type: TYPE_NORMAL
- en: The following table assumes that the left and right servos are mounted upside-down
    on the underside of the board, with the middle servo fitted vertically. You will
    have to adjust the code if mounted differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the servo movements used to walk forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Direction** | **Middle (servoM)** | **Left (servoL)** | **Right (servoR)**
    |'
  prefs: []
  type: TYPE_TB
- en: '| **home** | `MID`/Middle | `MID`/Middle | `MID`/Middle |'
  prefs: []
  type: TYPE_TB
- en: '| **fwdStep1** | `TR`/Right side up | `ACW`/Legs forward | `ACW`/Legs backward
    |'
  prefs: []
  type: TYPE_TB
- en: '| **fwdStep2** | `TL`/Left side up | `CW`/Legs backward | `CW`/Legs forward
    |'
  prefs: []
  type: TYPE_TB
- en: 'The following diagram shows how the movement makes the Pi-Bug robot step forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9edd774-480d-49bf-86ca-5eda4224fddd.png)'
  prefs: []
  type: TYPE_IMG
- en: The Pi-Bug robot moving forward
  prefs: []
  type: TYPE_NORMAL
- en: While it may seem a little confusing at first, when you see the robot moving,
    it should make more sense.
  prefs: []
  type: TYPE_NORMAL
- en: For the first forward step, we move the middle servo (`servoM`) clockwise so
    that the left side of the Pi-Bug robot is lifted off the ground by the movement
    of the remaining middle leg. We can then move the left servo (`servoL`) to move
    the legs on the left side forward (ready for movement later; they are not touching
    the ground at this point). Now, by moving the right servo (`servoR`), we can move
    the legs on the right backwards (allowing the Pi-Bug robot to be pushed forward
    on that side).
  prefs: []
  type: TYPE_NORMAL
- en: The second forward step is the same, except that we use the middle servo (`servoM`)
    to lift the right side off the ground. Again, we move the legs that are off the
    ground forward (ready for next time) and then move the legs on the other side
    backward (allowing that side of the Pi-Bug robot to move forward). By repeating
    the forward steps, the Pi-Bug robot will move forward; or, by swapping the sides
    that are being lifted up by the middle servo (`servoM`), it will move backward.
    The result is a rather bug-like scuttle!
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the Pi-Bug robot turn, we perform a similar action, except that just
    like the advanced motor control for the Rover-Pi robot, we move one side of the
    robot forward and the other side backward. The following table shows the servo
    movements used to turn right:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Direction** | **Middle (servoM)** | **Left (servoL)** | **Right (servoR)**
    |'
  prefs: []
  type: TYPE_TB
- en: '| **home** | `MID`/Middle | `MID`/Middle | `MID`/Middle |'
  prefs: []
  type: TYPE_TB
- en: '| **rightStep1** | `TL`/Left side up | `CW`/Legs backward | `ACW`/Legs backward
    |'
  prefs: []
  type: TYPE_TB
- en: '| **rightStep2** | `TR`/Right side up | `ACW`/Legs forward | `CW`/Legs forward
    |'
  prefs: []
  type: TYPE_TB
- en: 'The steps to turn the Pi-Bug robot to the right are shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a64bb9a8-0b80-4333-a2d9-2badd060b548.png)'
  prefs: []
  type: TYPE_IMG
- en: The Pi-Bug robot making a right turn
  prefs: []
  type: TYPE_NORMAL
- en: To turn right, we lift the left side of the Pi-Bug robot off the ground, but
    this time, we move the legs on both sides backward. This allows the right side
    of the Pi-Bug robot to move forward. The second half of the step lifts the right
    side off the ground, and we move the legs forward (which will push the left side
    of the Pi-Bug robot backward). In this manner, the bug will turn as it steps;
    again, just by swapping the sides that are being lifted, we can change the direction
    that the Pi-Bug robot will turn in.
  prefs: []
  type: TYPE_NORMAL
- en: The Pi-Bug code for walking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for the Pi-Bug robot has been designed to provide the same interface
    as the Rover-Pi robot so that they can be interchanged easily. You should notice
    that each class consists of the same four functions (`__init__()`, `off()`, `drive()`,
    and `cmd()`). The `__init__()` function defines the set of pins we will control,
    the `steptime` value of the walking action (this time, the gap between movements),
    and the previously defined servo module.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we have an `off()` function that provides a function that can be
    called to set the servos in their middle positions (which is very useful for when
    you need to fit the legs in position, as described previously in the home position).
    The `off()` function uses the `drive()` function to set each servo to the `MID`
    position. The `MID` value is halfway between `servoMin` and `servoMax` (1.5 ms
    to give a position of 90 degrees).
  prefs: []
  type: TYPE_NORMAL
- en: The `drive()` function is just like the previous motor control version; it cycles
    through each of the actions required for each servo, as defined in the various
    movement patterns (`FWD`, `BWD`, `LEFT`, and `RIGHT`) we discussed previously.
    However, to reproduce the required pattern of movement, we cycle through each
    servo twice, while inserting a small delay whenever we move the middle servo (`servoM`).
    This allows time for the servo to move and provide the necessary tilt to lift
    the other legs off the ground before allowing them to move.
  prefs: []
  type: TYPE_NORMAL
- en: We define each of the servo commands as a **clockwise** (**CW**) or **anticlockwise/counterclockwise**
    (**ACW**) movement of the servo arm. Since the servos are mounted upside down,
    an ACW (CW, if viewed from above) movement of the left servo (`servoL`) will bring
    the legs forwards, while the same direction of movement on the right servo (`servoR`)
    will move the legs backward (which is fwdStep1 in the previous diagram). In this
    way, each of the patterns can be defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we provide a test function using the following command that allows
    a list of instructions to either be defined from the command line or directly
    entered at the prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This includes the addition of `h` to return to the `home` position, if desired.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling servos directly with ServoBlaster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe demonstrated using a dedicated servo controller to handle
    the control of the servos used by the Pi-Bug. This has the advantage that any
    disturbances in the processing taking place on the Raspberry Pi do not cause interference
    with the delicate servo control (since the controller will continue to send the
    correct signals).
  prefs: []
  type: TYPE_NORMAL
- en: However, the Raspberry Pi is also capable of direct servo control. To achieve
    this, we will make use of Richard Hurst's ServoBlaster, which is a multiple servo
    driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will control four servos attached to the MeArm, a simple
    laser-cut robot arm; however, you can choose to fit servos to whatever device
    you like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b56d39c-96aa-4889-b22d-c05a890fe6c0.png)'
  prefs: []
  type: TYPE_IMG
- en: The MeArm is a simple robot arm powered by four miniature servos
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most common servos will have three wires and a three pin connector, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Black/Brown** | **Red** | **Orange/White/Yellow/Blue** |'
  prefs: []
  type: TYPE_TB
- en: '| Ground | Positive supply (typically 5V for small servos) | Signal |'
  prefs: []
  type: TYPE_TB
- en: While it is usually possible to power the servos directly from the Raspberry
    Pi 5V pins on the GPIO header, they can draw a significant amount of current when
    moving. Unless you have a very good power supply, this can cause the Raspberry
    Pi to reset unexpectedly, risking corrupting the SD card. Therefore, it is recommended
    that you power them separately; for example, with an additional USB power supply
    and cable connected to the ground and positive supply.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the servos can be wired as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Servo** | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | All GND | All Power |'
  prefs: []
  type: TYPE_TB
- en: '| **Raspberry Pi****GPIO Pin** |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 11 | 12 | 13 | 15 | 16 | 19 | 22 | 6 | No Connect |'
  prefs: []
  type: TYPE_TB
- en: '| **5V Power Supply** |  | GND | +5V |'
  prefs: []
  type: TYPE_TB
- en: 'We will assume that we are controlling four servos (0, 1, 2, and 3) that will
    be fitted to the MeArm or a similar device later:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70d2d538-68f3-415d-a1a3-98da85d94d5e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To install ServoBlaster, start by downloading the source files from the Git
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Unzip and open the `matplotlib-master` folder, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the user space daemon (which is located in the user directory)
    that is called `servod`. Before we can use it, we should compile it with this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'There should be no errors, showing the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For usage information, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can test a servo; first, start the `servod` daemon (with a timeout of
    2,000 ms to switch the servo off after it has moved):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can move the servo''s position to 0% of the servo''s range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, update the servo to 50%, causing the servo to rotate to 90 degrees (servo
    mid-point):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As recommended by the MeArm build instructions, the servos should be connected
    and calibrated before building the arm, to ensure that each servo is able to move
    the arm in its correct range. This is done by ensuring that each servo is powered
    up and commanded to its mid-point position (50%/90 degrees), and the servo-arm
    is fitted at the expected orientation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a72d289d-55cb-4a78-b14c-5ebf7f2e81f0.png)'
  prefs: []
  type: TYPE_IMG
- en: Each of the servos should be calibrated in the correct position before you fit
    them on the MeArm
  prefs: []
  type: TYPE_NORMAL
- en: You can now set each of the MeArm servos (0, 1, 2, and 3) to their mid-points
    (by commanding each, in turn, to 50%) before building and fitting them to a completed
    arm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The servos could be used to control a wide range of alternative devices other
    than the MeArm, but your servos will probably need to be calibrated in a similar
    manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/234797d3-42ad-4871-b5b1-69bbaa211114.png)'
  prefs: []
  type: TYPE_IMG
- en: The precision control of servos means they can be used for a variety of applications,
    for example, controlling simulated hands
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the following `servo_control.py` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can control the servos fitted to the MeArm (or whatever you are using)
    as prompted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The script starts by importing the `curses` and `os` modules. A standard Python
    `input()` command would require the *Enter* key to be pressed after each key press
    before we could act upon it. However, as we will see shortly, the `curses` module
    simply allows us to scan for keyboard presses and respond to them immediately.
    We use the `os` module to call the ServoBlaster commands, as we would via the
    Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: First, we define our setup, such as the servo mappings, calibration positions,
    min/max ranges, our control keys, and the `STEP` size in degrees for each control
    command. We also define our parameters for our requested angle (in degrees) to
    target PWM signal up time (in milliseconds) calculation.
  prefs: []
  type: TYPE_NORMAL
- en: For these particular servos, an up time of 1 ms is equal to 0 degrees and 2.5
    ms is 180 degrees, so we have an offset (`OFFSET`) of 1 ms and a scale (`DEG2MS`)
    of 180 degrees/1.5 ms.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, our required up time (in milliseconds) can be calculated as *OFFSET
    + (degrees*DEG2MS)*. Finally, we define the `SERVOD` command line and servo `IDLE`
    timeout to initialize the ServoBlaster user daemon. Within `initialize ()`, we
    use `os.system()` to start the `servod` daemon, as we did before.
  prefs: []
  type: TYPE_NORMAL
- en: In order to detect key presses, we call the `main()` function of the script
    from `curses.wrapper()`, allowing `term` to control the terminal input and output.
    We use `term.nodelay(1)` so that when we do check for any key presses (using `term.getch()`),
    execution will continue normally. We use `term.addstr(text)` to show the user
    the control keys and then update the display via `term.refresh()`. The remaining
    script checks the terminal for key presses and the result assigned to `c`. If
    no key was pressed, then `term.getch()` returns `-1`; otherwise, the ASCII equivalent
    value is returned, and we can check for it in each of the dictionaries we defined
    for control keys. We will use `KEY_MORE` and `KEY_LESS` to change the servo positions,
    and `KEY_CMD` (`c` or `x`) to allow us to set all the servos to their calibrated
    position or to exit cleanly. Finally, we display any useful debugging information
    (if `DEBUG` is set to `True`) using `term.addstr()`, and ensure that it is displayed
    at (1,0) in the terminal (one line down from the top).
  prefs: []
  type: TYPE_NORMAL
- en: For normal control, the position of the servos will be controlled using the
    `updateServo()` function, which adjusts the current position (stored in the POS
    array) by the required change (either `+STEP` or `-STEP`). We ensure the new position
    is within the MAX/MIN limits defined, and report if we've hit them. The servo
    is then instructed to move to the required position using `setServo()`, specifying
    the needed PWM up time in micro seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The last function, `calibrate()`, called when *C* is pressed, simply sets each
    of the servos to the angle defined in the `CAL` array (using `setServo()`) and
    ensures that the current position is kept up to date.
  prefs: []
  type: TYPE_NORMAL
- en: Using an infrared remote control with your Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is often useful to control robots remotely. An easy way to add additional
    input is to make
  prefs: []
  type: TYPE_NORMAL
- en: use of an **infrared** (**IR**) receiver and a standard remote control. Fortunately,
    the receiver is
  prefs: []
  type: TYPE_NORMAL
- en: well supported.
  prefs: []
  type: TYPE_NORMAL
- en: We will use a module called `lirc` to capture and decode IR signals from a standard
  prefs: []
  type: TYPE_NORMAL
- en: remote control.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'LIRC supports many types of IR detectors, such as Energenie''s PiMote IR board;
    however, since we only need to receive IR signals, we can use a simple (TSOP38238)
    IR detector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0bc8bc96-656d-4a9d-914b-e1acf33f9e95.png)'
  prefs: []
  type: TYPE_IMG
- en: The three pins of the TSOP38238 IR receiver can fit directly onto the Raspberry
    Pi header
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the following packages using the `apt-get` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to `/boot/config.txt`. This will enable the driver and define
    the pin the receiver is fitted on (BCM GPIO24):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform a restart of the Raspberry Pi so that the configuration takes effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We should now find that the IR device is located at `/dev/lirc0`. We can observe
    the output of the receiver if we point a remote control at it and press some buttons
    after using the following command (use *Ctrl* + *Z* to exit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `lirc0` resource may report as busy:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mode2: could not open /dev/lirc0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`mode2: default_init(): Device or resource busy`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we will need to stop the `lirc` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo /etc/init.d/lirc stop`'
  prefs: []
  type: TYPE_NORMAL
- en: 'It will give the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[ ok ] Stopping lirc (via systemctl): lirc.service`'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are ready, you can start the service again:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo /etc/init.d/lirc start`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will give the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[ ok ] Starting lirc (via systemctl): lirc.service`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see output similar to the following (if not, ensure that you have
    connected the receiver connected to the correct pins on the Raspberry Pi GPIO):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know our device is working, we can configure it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The global LIRC configurations are stored in `/etc/lirc`. We are interested
    in the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hardware.conf`: Defines where our IR sensor is installed and the overall setting
    for our sensor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lircd.conf`: The remote control configuration file; this contains the recorded
    outputs for your remote control''s keys and maps them to specific key symbols.
    You can often obtain pre-recorded files from [lirc.sourceforge.net/remotes](http://lirc.sourceforge.net/remotes/),
    or you can record a custom one, as shown next.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lircrc`: This file provides mapping of each of the key symbols to specific
    commands or keyboard mappings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the LIRC configurations stored in `/etc/lirc` are available for all users;
    however, if required, different configurations can be defined for each user by
    placing them in specific home folders (for example, `/home/pi/.config/`), allowing
    the defaults to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three steps to setting up the sensor, one for each of the LIRC configuration
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, ensure that `hardware.conf` is set up. For our sensor, we must ensure
    that the following is set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Next, obtain a `lircd.conf` file; or, if you do not have one for your remote,
    we can generate it. The following process will now take you through detecting
    each of the individual keys on the remote. For the purpose of this recipe, we
    only need to map eight keys (to control the four servos from the previous recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you want map additional keys, use the following command to find out the
    full list of valid key symbols:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '| `KEY_UP` | `KEY_RIGHT` | `KEY_VOLUMEUP` | `KEY_CHANNELUP` |'
  prefs: []
  type: TYPE_TB
- en: '| `KEY_DOWN` | `KEY_LEFT` | `KEY_VOLUMEDOWN` | `KEY_CHANNELDOWN` |'
  prefs: []
  type: TYPE_TB
- en: '![](img/c9c935d6-a742-43f6-b81e-875aa5beef9e.png)'
  prefs: []
  type: TYPE_IMG
- en: We can use the volume, channel, and direction buttons on this Goodman's remote
    as our MeArm controller
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will need to stop the `lirc` service, which, if it was running, would
    be using the `/dev/lirc0` device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, start the capture process using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/783e39cf-b484-4d0a-949d-287aa984310b.png)'
  prefs: []
  type: TYPE_IMG
- en: Record each button on the remote using the irrecord tool
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have captured the required keys, we ensure that the name of the
    remote is set (by default, it will be set to the name of the `lirc.conf` file
    when the buttons are captured):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the name of the remote in the file; for example, `Goodmans`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can replace the configuration in the `/etc/lirc` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can confirm the key symbols that are mapped to the remote using the `irw`
    program, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`irw`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will report the details of the key pressed and the remote control as defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can map the keys to specific commands; in this case, we will map them
    to the keys we used for controlling the MeArm servos. Create a new `/etc/lirc/lircrc`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To apply the configuration, you may need to restart the service (or, if that
    doesn''t work, try restarting the Raspberry Pi):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: When we run the `servo_control.py` script in the previous recipe, the remote
    should control the arm directly.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'LIRC supports several helper programs, of which `irxevent` is just one:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `remote` | By default, LIRC supports some simple controls; for example:` 
    prog=remote``  button=KEY_UP``  config=UP`This will provide simple cursor control
    from a remote (UP, DOWN, LEFT, RIGHT, and also ENTER) that are perfect for simple
    menu control. |'
  prefs: []
  type: TYPE_TB
- en: '| [http://www.lirc.org/html/configure.html#lircrc_format](http://www.lirc.org/html/configure.html#lircrc_format)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `irxevent` | Emulates button clicks and key presses within X applications.
    You can specify that the key event occurs in the `CurrentWindow` or in a specific
    window by name, that is, `leafpad`. This only works if you are running from the
    graphical desktop environment (or using X forwarding). |'
  prefs: []
  type: TYPE_TB
- en: '| [http://www.lirc.org/html/irxevent.html](http://www.lirc.org/html/irxevent.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `irpty` | Converts infrared remote commands into keystrokes for controlling
    a particular program:`  rog=irpty``  button=KEY_EXIT``  config=x`Start it by specifying
    the `lircrc` configuration and program you want to control:`irpty /etc/lirc/lircrc
    -- leafpad` |'
  prefs: []
  type: TYPE_TB
- en: '| [http://www.lirc.org/html/irpty.html](http://www.lirc.org/html/irpty.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `irexec` | Allows commands to be run directly from the remote control:  `prog=irexec`` 
    button=KEY_POWER``  config=sudo halt #Power Down` |'
  prefs: []
  type: TYPE_TB
- en: '| [http://www.lirc.org/html/irexec.html](http://www.lirc.org/html/irexec.html)
    |'
  prefs: []
  type: TYPE_TB
- en: 'You can test any part of the `lircrc` file by using `ircat` with the required
    `prog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will report the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if you have a suitable IR Transmitter LED attached (including a protective
    resistor/switching transistor), you can also use LIRC to send infrared signals
    from the Raspberry Pi. For this, you can use the `irsend` command, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The IR output channel is enabled within the `/boot/config.txt` file (assuming
    connected to GPIO Pin 19):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Avoiding objects and obstacles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To avoid obstacles, you can place sensors around the robot's perimeter to activate
    whenever an object is encountered. Depending on how you want your robot to behave,
    one avoidance strategy is to just reverse any action last taken (with an additional
    turn for forward/backward actions) that caused one of the sensors to be activated.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need some micro switches to be triggered when there is an impact with
    objects. Depending on the type you have, you need to place enough switches to
    detect any object around the outside (if required, you can use an additional length
    of wire to extend the reach of the switch). Shown in the following photo are two
    possible sensors that will cause the switch to activate when the spring or the
    metal arm hits an object. You need to determine which contacts of the switch open
    or close the circuit (this will depend on the device):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c4ecd33-151e-4c9f-a299-4f13e54fd0b2.png)'
  prefs: []
  type: TYPE_IMG
- en: Small micro switches can be used as collision sensors
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Connect the switches to the GPIO using a method similar to the one we used
    in [Chapter 9](7cf87b89-8982-4d64-852c-ddfcbf742be5.xhtml)*, Using Python to Drive
    Hardware*, for the D-Pad controller. A circuit diagram of the switches is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d949ca7-470c-4300-8e42-02432a483bdc.png)'
  prefs: []
  type: TYPE_IMG
- en: The switches should include current limiting resistors (1K ohm is ideal)
  prefs: []
  type: TYPE_NORMAL
- en: 'How you connect to the Raspberry Pi''s GPIO will depend on how your motor/servo
    drive is wired up. For example, a Rover-Pi robot with an H-bridge motor controller
    can be wired up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Control side of the module – connecting to the Raspberry Pi GPIO header**
    |'
  prefs: []
  type: TYPE_TB
- en: '| **ENA** | **IN1** | **IN2** | **IN3** | **IN4** | **ENB** | **GND** | **5V**
    |'
  prefs: []
  type: TYPE_TB
- en: '| None | Pin 15 | Pin 16 | Pin 18 | Pin 22 | None | Pin 6 | None |'
  prefs: []
  type: TYPE_TB
- en: Four additional proximity/collision sensors can be connected to the Raspberry
    Pi GPIO
  prefs: []
  type: TYPE_NORMAL
- en: 'as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Proximity/collision sensors – connecting to the Raspberry Pi GPIO header**
    |'
  prefs: []
  type: TYPE_TB
- en: '| **R_FWD** | **L_FWD** | **R_BWD** | **L_BWD** | **GND** |'
  prefs: []
  type: TYPE_TB
- en: '| Pin 7 | Pin 11 | Pin 12 | Pin 13 | Pin 6 |'
  prefs: []
  type: TYPE_TB
- en: If you wired it differently, you can adjust the pin numbers within the code,
    as required. If you require additional pins, then any of the multipurpose pins,
    such as RS232 RX/TX (pins 8 and 10) or the SPI/I²C, can be used as normal GPIO
    pins, too; just set them as input or output, as normal. Normally, we just avoid
    using them, as they are often more useful for expansion and other things, so it
    is sometimes useful to keep them available.
  prefs: []
  type: TYPE_NORMAL
- en: You can even use a single GPIO pin for all your sensors if you are just using
    the following example code, since the action is the same, regardless of which
    sensor is triggered. However, by wiring each one separately, you can adjust your
    strategy based on where the obstacle is around the robot or provide additional
    debug information about which sensor has been triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following `avoidance.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We import `rover_drive` to control the robot (if we are using a Pi-Bug robot,
    `bug_drive` can be used) and `wiringpi2` so that we can use the GPIO to read the
    sensors (defined as `PINS`). We define `opCmds`, which uses a Python dictionary
    to allocate new commands in response to the original command (using `opCmds[char]`,
    where `char` is the original command).
  prefs: []
  type: TYPE_NORMAL
- en: We create a new class called `sensor` and set up each of the switches as GPIO
    input (each with an internal pull-ups set). Now, whenever we make a movement (as
    earlier, from the list of requested commands in the `main()` function), we check
    to see if any of the switches have been triggered (by calling `mySensor.checkSensor()`).
  prefs: []
  type: TYPE_NORMAL
- en: If a switch was tripped, we stop the current movement, and then move in the
    opposite direction. However, if we are moving forward when one of the sensors
    is triggered, we move backward, and then turn. This allows the robot to gradually
    turn away from the object that is blocking its path and continue its movement
    in another direction. Similarly, if we are moving backwards and a sensor is triggered,
    we move forward, and then turn. By combining simple object avoidance with directional
    information, the robot can be commanded to navigate around as desired.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are also ways to detect objects that are near the robot without actually
    making physical contact with them. One such way is to use ultrasonic sensors,
    commonly used for vehicle reversing/parking sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Ultrasonic reversing sensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ultrasonic sensors provide an excellent way to measure the distance of the
    robot from obstacles (providing a measurement of between 2 cm and 20 cm) and are
    available at most electrical hobby stores (see the *Appendix,* *Hardware and Software
    List*). The ultrasonic module functions by sending a short burst of ultrasonic
    pulses and then measures the time it takes for the receiver to detect the echo.
    The module then produces a pulse on the echo output that is equal to the time
    measured. This time is equal to the distance traveled divided by the speed of
    sound (340.29 m/sec or 34,029 cm/s), which is the distance from the sensor to
    the object and back again. An ultrasonic module is shown in the following photo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d02e95d-f125-4da5-ab66-252cec0fd22c.png)'
  prefs: []
  type: TYPE_IMG
- en: The HC-SR04 ultrasonic sensor module
  prefs: []
  type: TYPE_NORMAL
- en: The sensor requires 5V to power it; it has an input that will receive the trigger
    pulse and an output that the echo pulse will be sent on. While the module works
    with a 3.3V trigger pulse, it responds with a 5V signal on the echo line; so,
    it requires some extra resistors to protect the Raspberry Pi's GPIO.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following circuit diagram shows the connection of the sensor output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01c01599-3614-410a-994b-7fb5289a8149.png)'
  prefs: []
  type: TYPE_IMG
- en: The sensor echo output must be connected to the Raspberry Pi via a potential
    divider
  prefs: []
  type: TYPE_NORMAL
- en: 'The resistors **R[t]** and **R[b]** create a potential divider; the aim is
    to drop the echo voltage from 5V to around 3V (but not less than 2.5V). Use the
    following equation from [Chapter 10](18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml)*,*
    *Sensing and Displaying Real-World Data*, to obtain the output voltage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f410e1fe-d1d4-41e6-80a1-babfe64aa7ab.png)'
  prefs: []
  type: TYPE_IMG
- en: The output voltage (Vout) of the potential divider is calculated using this
    equation
  prefs: []
  type: TYPE_NORMAL
- en: This means that we should aim for an **R[t]** to **R[b]** ratio of 2:3 to give
    3V (and not lower than 1:1, which would give 2.5V); that is, **R[t]** equals 2K
    ohm and **R[b]** equals 3K ohm, or 330 ohm and 470 ohm will be fine.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a voltage meter, you can check it (with everything else disconnected).
    Connect the top of the potential divider to GPIO Pin 2 (5V) and the bottom to
    GPIO Pin 6 (GND), and measure the voltage from the middle (it should be around
    3V).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following `sonic.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: First, we define the `TRIGGER` and `ECHO` pins, the length of the trigger pulse,
    and also the speed of sound (340.29 m/s). The `TRIGGER` pin is set as an output,
    and the `ECHO` as an input (we will not need a pull-up or pull-down resistor,
    since the module already has one).
  prefs: []
  type: TYPE_NORMAL
- en: The `pulse()` function will send a short trigger pulse (10 microseconds); then
    it will time the duration of the echo pulse. We then calculate the total distance
    traveled by dividing the duration by the speed of sound (the distance to the object
    is just half of this value).
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the sensor can get confused with certain types of objects; it
    will either detect echoes that bounce off a nearby object before being reflected
    back, or not pick up narrow items, such as chair legs. However, combined with
    localized collision sensors, the ultrasonic sensor can aid with the general navigation
    and avoidance of the larger objects.
  prefs: []
  type: TYPE_NORMAL
- en: An improvement to this setup would be to mount the sonic sensor on top of a
    servo, thereby allowing you to make a sensor sweep of the robot's surroundings.
    By making multiple sweeps, taking distance measurements, and tracking the angle
    of the servo, you could build an internal map of the robot's surroundings.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a sense of direction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to navigate your robot around the environment, you will need to keep
    track of which way your robot is facing. You can estimate the angle that your
    robot turns at by measuring the angle that it turned at in a fixed time period.
    For wheeled robots, you can also measure the rotation of each wheel using a rotary
    encoder (a device that provides a count of the wheel's rotations). However, as
    you make the robot take multiple turns, the direction the robot is facing becomes
    more and more uncertain, as differences in the surfaces and the grip of the wheels
    or legs cause differences in the angles that the robot is turning at.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we can use an electronic version of a compass; it allows us to
    determine the direction that the robot is facing by providing an angle from magnetic
    north. If we know which direction the robot is facing, we can receive commands
    requesting a particular angle and ensure that the robot moves towards it. This
    allows the robot to perform controlled movements and navigate as required.
  prefs: []
  type: TYPE_NORMAL
- en: When given a target angle, we can determine which direction we need to turn
    towards, until we reach it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a magnetometer device, such as PiBorg's **XLoBorg** module (which
    is a
  prefs: []
  type: TYPE_NORMAL
- en: 'combined I²C magnetometer and accelerometer). In this example, we will only
    focus on the magnetometer (the smaller chip on the left) output. The XLoBorg module
    is shown in the following photo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fad81355-fd55-4cb3-986b-220373177798.png)'
  prefs: []
  type: TYPE_IMG
- en: The PiBorg XLoBorg module contains a three-axis magnetometer and accelerometer
  prefs: []
  type: TYPE_NORMAL
- en: This device can be used with both types of robot, and the angle information
    received from the module can be used to determine which direction the robot needs
    to move in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The module is designed to connect directly to the GPIO header, which will block
    all the remaining pins. So, in order to use other GPIO devices, a GPIO splitter
    (such as the PiBorg **TriBorg**) can be used. Alternatively, you can use Dupont
    female to male patch wires to connect just the I²C pins. The connections to be
    made are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98584627-1d19-42db-a142-07ed4d9f1039.png)'
  prefs: []
  type: TYPE_IMG
- en: Connections to manually wire the XLoBorg module to the Raspberry Pi (using standard
    I²C connections)
  prefs: []
  type: TYPE_NORMAL
- en: When viewed from the underside, the PiBorg XLoBorg pins are mirrored compared
    to the Raspberry Pi GPIO header.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a Python 3-friendly version of the XLoBorg library (`XLoBorg3.py`) using
    `wiringpi2`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The script is based on the XLoBorg library available for the XLoBorg module,
    except that we use WiringPi2, which is Python 3-friendly, to perform the I²C actions.
    Just like our motor/servo drivers, we also define it as a class, so that we can
    drop it into our code and easily replace it with alternative devices if required.
  prefs: []
  type: TYPE_NORMAL
- en: We import `wiringpi2`, `time`, and a library called `struct` (which allows us
    to quickly unpack a block of data read from the device into separate items).
  prefs: []
  type: TYPE_NORMAL
- en: We create the `compass` class, which will include the `__init__()`, `initCompass()`,
    and `readCompassRaw()` functions. The `readCompassRaw()` function is the equivalent
    of the standard XLoBorg `ReadCompassRaw()` function provided by their library.
  prefs: []
  type: TYPE_NORMAL
- en: The `__init__()` function sets up the I²C bus with `wiringpi2` and registers
    the `degMAG` device on the bus address `0x0E`. The `initCompass()` function sets
    the `CTRL_REG1` and `CTRL_REG2` registers of the device with the settings required
    to quickly get raw readings from the device.
  prefs: []
  type: TYPE_NORMAL
- en: More details on the MAG3110 registers are available at [http://www.freescale.com/files/sensors/doc/data_sheet/MAG3110.pdf](http://www.freescale.com/files/sensors/doc/data_sheet/MAG3110.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: The `readCompassRaw()` function reads the data registers of the device in a
    single block (using the custom function `readBlockData()`). It reads all of the
    18 registers of the device (`0x00` through to `0x11`). The sensor readings we
    need are contained within the registers `0x01` to `0x06`, which contain the *x*,
    *y*, and *z* readings, split into upper and lower bytes (8-bit values). The `struct.pack()`
    and `struct.unpack()` functions provide an easy way to package them together and
    re-split them as separate words (16-bit values).
  prefs: []
  type: TYPE_NORMAL
- en: We can test our script by creating a `myCompass` object from the `compass` class
    and reading the sensor values using `myCompass.readCompassRaw()`. You will see
    the raw *x*, *y*, and *z* values from the device, just as you would from the standard
    XLoBorg library.
  prefs: []
  type: TYPE_NORMAL
- en: As you will find, these values aren't of much use on their own, since they are
    uncalibrated
  prefs: []
  type: TYPE_NORMAL
- en: and only give you RAW readings from the magnetometer. What we need is a far
    more useful angle, relative to magnetic north (see the following *There's more...*
    section for details on how to do this).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, the basic library allows us to see the strength of the magnetic field
    on each of the three axes around the sensor (up/down, left/right, and forward/backward).
    While we can see that these values will change as we move the sensor around, this
    is not enough to steer our robot. First, we need to calibrate the sensor, and
    then determine the direction of the robot from the readings of the *x* and *y*
    axes.
  prefs: []
  type: TYPE_NORMAL
- en: Calibrating the compass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The compass needs to be calibrated in order to report values that are centered
    and equalized. This is needed because there are magnetic fields all around; by
    calibrating the sensor, we can cancel out the effect of any localized fields.
  prefs: []
  type: TYPE_NORMAL
- en: By measuring the readings of the compass on all axes, we can determine the minimum
  prefs: []
  type: TYPE_NORMAL
- en: and maximum values for each axis. This will allow us to calculate the mid-point
    of the readings, and also the scaling, so that each axis will read the same value
    whenever it is facing the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code at the top of the file (after the `import` statements):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to `__init__(self)` of the `compass` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new function named `calibrateCompass()` within the `compass` class, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Add another new function named `readCompass()` in the `compass` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: If you look closely at the readings (if you use `readCompass()`), you will now
    find that all of the readings have the same range and are centered around the
    same values.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the compass bearing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The XLoBorg library only provides access to the RAW values of the MAG3110 device,
    which provides a measure of how strong the magnetic field on each of the axes
    is. To determine the direction of the sensor, we can use the readings from the
    *x* and *y* axes (assuming that we have mounted and calibrated the sensor horizontally).
    The readings of the *x* and *y* axes are proportional to the magnetic field in
    each direction around the sensor, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75844b13-7dc2-475d-8bfb-219ae254be4b.png)'
  prefs: []
  type: TYPE_IMG
- en: The magnetometer measures the strength of the magnetic field on each axis
  prefs: []
  type: TYPE_NORMAL
- en: 'The angle at which we turned away from the north can be calculated with the
    formula shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b819cd7-6306-41ea-bb1b-a6e88bb69683.png)'
  prefs: []
  type: TYPE_IMG
- en: The angle we are pointing towards (that is relative to magnetic north) can be
    calculated using the measurements *Rx* and *Ry*
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now obtain the `compass` angle by adding the `readCompassAngle()` function
    to our `compass` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add the following `import` with the other `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We use the math function, `math.atan2()`, to calculate our angle (`atan2` will
    return with the angle relative to the *x* axis of the coordinates `read[1]` and
    `read[2]` – the angle we want). The angle is in radians, which means that one
    full turn is defined as 2Pi, rather than 360 degrees. We convert it back to degrees
    by multiplying it by 360 and dividing by 2Pi. Since we wish to have our angle
    between the range of 0 to 360 degrees (rather than -180 to 180 degrees), we must
    ensure that it is positive by adding the equivalent of a full circle (2Pi) to
    any negative values.
  prefs: []
  type: TYPE_NORMAL
- en: With the sensor calibrated and the angle calculated, we should now have the
    proper compass bearing to use on our robot. To compare, you can see the result
    of using the uncalibrated value in our calculation by calling the function with
    `readCompassAngle (cal=False)`.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the calibration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having calibrated the sensor once in its current position, it would be inconvenient
    to have to calibrate it each and every time that you ran the robot. Therefore,
    you can add the following code to your library to automatically save your calibration
    and read it from a file the next time you run your robot. To create a new calibration,
    either delete or rename `mag.cal` (which is created in the same folder as your
    script), or create your `compass` object `compass(newCal=True)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code near the top of the file (after the `imports` statements):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Change `__init__(self)` to `__init__(self,newCal=False)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, consider the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the previous line to the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `readCal()` to the `compass` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `writeCal()` to the `compass` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Driving the robot using the compass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, all that remains for us to do is use the compass bearing to steer our robot
    to the desired angle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following `compassDrive.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We import the modules that we previously created: `XLoBorg3`, `rover_drive`
    (for the Rover-Pi robot, or the alternative `bug_drive`, as required), and `time`.
    Next, we create a function that will return `LEFT`, `RIGHT`, or `DONE`, based
    on the given target angle (requested by the user) and the current angle (read
    from the `compass` class). If the compass angle is within 180 degrees less than
    the target angle, then we turn `LEFT`. Similarly, if it is within 180 degrees,
    we turn `RIGHT`. Finally, if the compass angle is within the margin (+10 degrees/-10
    degrees), then we are `DONE`. By using `angle%360` (which gives us the remainder
    from dividing the angle by 360), we ensure the angles are all 0-360 (that is,
    -90 becomes 270).'
  prefs: []
  type: TYPE_NORMAL
- en: For the `main()` function, we create `myCompass` (an `XLoBorg.compass` object)
    and `myBot` (a `drive.motor()` object); these allow us to determine the direction
    we are facing in, and provide us with a way to drive in the desired direction.
    Within the `main` loop, we prompt for a target angle, find the current angle that
    our robot is facing at, and then continue to turn towards the required angle until
    we reach it (or reach somewhere near enough to that angle).
  prefs: []
  type: TYPE_NORMAL
