<html><head></head><body>
  <div class="Basic-Text-Frame" id="_idContainer178">
   <h1 class="chapterNumber">
    <span class="koboSpan" id="kobo.1.1">
     11
    </span>
   </h1>
   <h1 class="chapterTitle" id="_idParaDest-283">
    <span class="koboSpan" id="kobo.2.1">
     Debugging and Profiling
    </span>
   </h1>
   <blockquote class="packt_quote">
    <p class="quote">
     <span class="koboSpan" id="kobo.3.1">
      ”If debugging is the process of removing software bugs, then programming must be the process of putting them in.”
     </span>
    </p>
    <p class="cite">
     <span class="koboSpan" id="kobo.4.1">
      – Edsger W.
     </span>
     <span class="koboSpan" id="kobo.4.2">
      Dijkstra
     </span>
    </p>
   </blockquote>
   <p class="normal">
    <span class="koboSpan" id="kobo.5.1">
     In the life of a professional coder, debugging and troubleshooting take up a significant amount of time.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     All but the most trivial software is guaranteed to have bugs.
    </span>
    <span class="koboSpan" id="kobo.5.3">
     Humans are not perfect; we make mistakes.
    </span>
    <span class="koboSpan" id="kobo.5.4">
     Therefore, the code we produce is also not perfect.
    </span>
    <span class="koboSpan" id="kobo.5.5">
     As developers, we spend a large portion of our time reading code that was written by other people.
    </span>
    <span class="koboSpan" id="kobo.5.6">
     In our opinion, a good software developer is someone who keeps an eye out for potential bugs, even when they are reading code that is not reported to be wrong or buggy.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.6.1">
     Being able to debug code efficiently and quickly is a skill that every coder needs to keep improving.
    </span>
    <span class="koboSpan" id="kobo.6.2">
     Like testing, debugging is a skill that is best learned through experience.
    </span>
    <span class="koboSpan" id="kobo.6.3">
     There are guidelines you can follow, but there is no book that will teach you everything you need to know to become good at this.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.7.1">
     We feel that on this subject, we have learned the most from our colleagues.
    </span>
    <span class="koboSpan" id="kobo.7.2">
     It amazes us to observe someone who is very skilled attacking a problem.
    </span>
    <span class="koboSpan" id="kobo.7.3">
     We enjoy seeing the steps they take, the things they verify to exclude potential causes, and how they select the path that eventually leads them to a solution.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.8.1">
     Every colleague we work with can teach us something or surprise us with a fantastic guess that turns out to be the right one.
    </span>
    <span class="koboSpan" id="kobo.8.2">
     When that happens, do not just remain in wonderment (or worse, in envy), but seize the moment and ask them how they got to that guess and why.
    </span>
    <span class="koboSpan" id="kobo.8.3">
     The answer will allow you to see whether there is something you can study in depth later so that, next time, you will be the one who finds the bug.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.9.1">
     Some bugs are easy to spot.
    </span>
    <span class="koboSpan" id="kobo.9.2">
     They come out of mistakes and, once you see the effects of those mistakes, it is easy to find a solution to the problem.
    </span>
    <span class="koboSpan" id="kobo.9.3">
     But there are other bugs that are much more subtle and require true expertise and a great deal of creativity and out-of-the-box thinking to be dealt with.
    </span>
    <span class="koboSpan" id="kobo.9.4">
     The worst bugs of all are the non-deterministic ones.
    </span>
    <span class="koboSpan" id="kobo.9.5">
     These sometimes happen, and sometimes do not.
    </span>
    <span class="koboSpan" id="kobo.9.6">
     Some happen only in a particular environment but not in another seemingly identical environment.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.10.1">
     In a professional setting, we often need to debug our code in highly stressful situations.
    </span>
    <span class="koboSpan" id="kobo.10.2">
     If a website is down, or customers are upset, the business is losing money.
    </span>
    <span class="koboSpan" id="kobo.10.3">
     As a result, there is often a lot of pressure on developers to find and fix the problem immediately.
    </span>
    <span class="koboSpan" id="kobo.10.4">
     In such situations, it is crucial to be able to keep calm.
    </span>
    <span class="koboSpan" id="kobo.10.5">
     That’s the most important skill to have if you want to be able to fight bugs effectively.
    </span>
    <span class="koboSpan" id="kobo.10.6">
     Stress negatively impacts the creative thinking and problem-solving abilities that we need to find and fix bugs.
    </span>
    <span class="koboSpan" id="kobo.10.7">
     So, take a deep breath, sit properly, and focus.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.11.1">
     In this chapter, we will try to demonstrate some useful techniques that you can employ according to the severity of the bug, and a few suggestions that will hopefully boost your weapons against bugs and issues.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.12.1">
     Specifically, we are going to look at the following:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.13.1">
      Debugging techniques
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.14.1">
      Troubleshooting guidelines
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.15.1">
      Profiling
     </span>
    </li>
   </ul>
   <h1 class="heading-1" id="_idParaDest-284">
    <span class="koboSpan" id="kobo.16.1">
     Debugging techniques
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.17.1">
     In this part, we
    </span>
    <a id="_idIndexMarker995">
    </a>
    <span class="koboSpan" id="kobo.18.1">
     will introduce you to some of the techniques we use most often.
    </span>
    <span class="koboSpan" id="kobo.18.2">
     This is not an exhaustive list, but it should give you some useful ideas for where to start when debugging your own Python code.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-285">
    <span class="koboSpan" id="kobo.19.1">
     Debugging with print
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.20.1">
     The key to
    </span>
    <a id="_idIndexMarker996">
    </a>
    <span class="koboSpan" id="kobo.21.1">
     understanding any bug is to understand what your code is doing at the point where the bug occurs.
    </span>
    <span class="koboSpan" id="kobo.21.2">
     For this reason, we will be looking at a few different techniques for inspecting the state of a program while it is running.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.22.1">
     The easiest technique of all is to add
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.23.1">
      print()
     </span>
    </code>
    <span class="koboSpan" id="kobo.24.1">
     calls at various points in your code.
    </span>
    <span class="koboSpan" id="kobo.24.2">
     This allows you to easily see which parts of your code are executed, and what the values of key variables are at different points during execution.
    </span>
    <span class="koboSpan" id="kobo.24.3">
     For example, if you are developing a Django website and what happens on a page is not what you would expect, you can fill the view with prints and keep an eye on the console while you reload the page.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.25.1">
     There are
    </span>
    <a id="_idIndexMarker997">
    </a>
    <span class="koboSpan" id="kobo.26.1">
     several drawbacks and limitations to using
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.27.1">
      print()
     </span>
    </code>
    <span class="koboSpan" id="kobo.28.1">
     for debugging.
    </span>
    <span class="koboSpan" id="kobo.28.2">
     To use this technique, you need to be able to modify the source code and run it in a terminal where you can see the output of your
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.29.1">
      print()
     </span>
    </code>
    <span class="koboSpan" id="kobo.30.1">
     function calls.
    </span>
    <span class="koboSpan" id="kobo.30.2">
     This is not a problem in your development environment on your own machine, but it does limit the usefulness of this technique in other environments.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.31.1">
     When you scatter calls to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.32.1">
      print()
     </span>
    </code>
    <span class="koboSpan" id="kobo.33.1">
     in your code, you can easily end up duplicating a lot of debugging code.
    </span>
    <span class="koboSpan" id="kobo.33.2">
     For example, you may want to print timestamps (like we did when we were measuring how fast list comprehensions and generators were), or somehow build up a string with the information that you want to display.
    </span>
    <span class="koboSpan" id="kobo.33.3">
     Another disadvantage of this technique is that it is easy to forget calls to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.34.1">
      print()
     </span>
    </code>
    <span class="koboSpan" id="kobo.35.1">
     in your code.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.36.1">
     For these reasons, we sometimes prefer to use a custom debugging function rather than just bare calls to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.37.1">
      print()
     </span>
    </code>
    <span class="koboSpan" id="kobo.38.1">
     .
    </span>
    <span class="koboSpan" id="kobo.38.2">
     Let us see how.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-286">
    <span class="koboSpan" id="kobo.39.1">
     Debugging with a custom function
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.40.1">
     Having
    </span>
    <a id="_idIndexMarker998">
    </a>
    <span class="koboSpan" id="kobo.41.1">
     a custom debugging function saved in a file somewhere that you can quickly grab and paste into the code can be particularly useful.
    </span>
    <span class="koboSpan" id="kobo.41.2">
     If you are fast, you can also code one on the fly.
    </span>
    <span class="koboSpan" id="kobo.41.3">
     The important thing is to write it in such a way that it will not leave anything behind when you eventually remove the calls and their definitions.
    </span>
    <span class="koboSpan" id="kobo.41.4">
     Therefore,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.42.1">
      it is important to code it in a way that is completely self-contained
     </span>
    </em>
    <span class="koboSpan" id="kobo.43.1">
     .
    </span>
    <span class="koboSpan" id="kobo.43.2">
     Another good reason for this requirement is that it will avoid potential name clashes with the rest of the code.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.44.1">
     Let us see an example of such a function:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.45.1"># custom.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.46.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.47.1">debug</span></span><span class="koboSpan" id="kobo.48.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.49.1">*msg, print_separator=</span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.50.1">True</span></span><span class="koboSpan" id="kobo.51.1">):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.52.1">print</span></span><span class="koboSpan" id="kobo.53.1">(*msg)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.54.1">if</span></span><span class="koboSpan" id="kobo.55.1"> print_separator:
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.56.1">print</span></span><span class="koboSpan" id="kobo.57.1">("-" * </span><span class="hljs-number"><span class="koboSpan" id="kobo.58.1">40</span></span><span class="koboSpan" id="kobo.59.1">)
debug("Data </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.60.1">is</span></span><span class="koboSpan" id="kobo.61.1"> ...")
debug("Different", "Strings", "Are </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.62.1">not</span></span><span class="koboSpan" id="kobo.63.1"> a problem")
debug("After </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.64.1">while</span></span><span class="koboSpan" id="kobo.65.1"> loop", print_separator=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.66.1">False</span></span><span class="koboSpan" id="kobo.67.1">)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.68.1">
     In this case, we are using a keyword-only argument to be able to print a separator, which is a line of 40 dashes.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.69.1">
     The
    </span>
    <a id="_idIndexMarker999">
    </a>
    <span class="koboSpan" id="kobo.70.1">
     function just passes whatever is in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.71.1">
      msg
     </span>
    </code>
    <span class="koboSpan" id="kobo.72.1">
     to a call to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.73.1">
      print()
     </span>
    </code>
    <span class="koboSpan" id="kobo.74.1">
     and, if
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.75.1">
      print_separator
     </span>
    </code>
    <span class="koboSpan" id="kobo.76.1">
     is
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.77.1">
      True
     </span>
    </code>
    <span class="koboSpan" id="kobo.78.1">
     , it prints a line separator.
    </span>
    <span class="koboSpan" id="kobo.78.2">
     Running the code will show the following:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.79.1">$ python custom.py
Data is ...
</span><span class="koboSpan" id="kobo.79.2">----------------------------------------
Different Strings Are not a problem
----------------------------------------
After while loop
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.80.1">
     As you can see, there is no separator after the last line.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.81.1">
     This is just one easy way to augment a simple call to the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.82.1">
      print()
     </span>
    </code>
    <span class="koboSpan" id="kobo.83.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.83.2">
     Let us see how we can calculate a time difference between calls, using one of Python’s tricky features to our advantage:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.84.1"># custom_timestamp.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.85.1">from</span></span><span class="koboSpan" id="kobo.86.1"> time </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.87.1">import</span></span><span class="koboSpan" id="kobo.88.1"> sleep
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.89.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.90.1">debug</span></span><span class="koboSpan" id="kobo.91.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.92.1">*msg, timestamp=[</span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.93.1">None</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.94.1">]</span></span><span class="koboSpan" id="kobo.95.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.96.1">from</span></span><span class="koboSpan" id="kobo.97.1"> time </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.98.1">import</span></span><span class="koboSpan" id="kobo.99.1"> time  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.100.1"># local import</span></span>
    <span class="hljs-built_in"><span class="koboSpan" id="kobo.101.1">print</span></span><span class="koboSpan" id="kobo.102.1">(*msg)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.103.1">if</span></span><span class="koboSpan" id="kobo.104.1"> timestamp[</span><span class="hljs-number"><span class="koboSpan" id="kobo.105.1">0</span></span><span class="koboSpan" id="kobo.106.1">] </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.107.1">is</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.108.1">None</span></span><span class="koboSpan" id="kobo.109.1">:
        timestamp[</span><span class="hljs-number"><span class="koboSpan" id="kobo.110.1">0</span></span><span class="koboSpan" id="kobo.111.1">] = time()  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.112.1"># 1</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.113.1">else</span></span><span class="koboSpan" id="kobo.114.1">:
        now = time()
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.115.1">print</span></span><span class="koboSpan" id="kobo.116.1">(f" Time elapsed: {now - timestamp[</span><span class="hljs-number"><span class="koboSpan" id="kobo.117.1">0</span></span><span class="koboSpan" id="kobo.118.1">]:</span><span class="hljs-number"><span class="koboSpan" id="kobo.119.1">.3</span></span><span class="koboSpan" id="kobo.120.1">f}s")
        timestamp[</span><span class="hljs-number"><span class="koboSpan" id="kobo.121.1">0</span></span><span class="koboSpan" id="kobo.122.1">] = now  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.123.1"># 2</span></span><span class="koboSpan" id="kobo.124.1">
debug("Entering buggy piece of code...")
sleep(</span><span class="hljs-number"><span class="koboSpan" id="kobo.125.1">0.3</span></span><span class="koboSpan" id="kobo.126.1">)
debug("First step done.")
sleep(</span><span class="hljs-number"><span class="koboSpan" id="kobo.127.1">0.5</span></span><span class="koboSpan" id="kobo.128.1">)
debug("Second step done.")
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.129.1">
     This is a bit more complicated.
    </span>
    <span class="koboSpan" id="kobo.129.2">
     First, notice that we used an
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.130.1">
      import
     </span>
    </code>
    <span class="koboSpan" id="kobo.131.1">
     statement
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.132.1">
      inside
     </span>
    </em>
    <span class="koboSpan" id="kobo.133.1">
     the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.134.1">
      debug()
     </span>
    </code>
    <span class="koboSpan" id="kobo.135.1">
     function to import the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.136.1">
      time()
     </span>
    </code>
    <span class="koboSpan" id="kobo.137.1">
     function from the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.138.1">
      time
     </span>
    </code>
    <span class="koboSpan" id="kobo.139.1">
     module.
    </span>
    <span class="koboSpan" id="kobo.139.2">
     This allows us to avoid having to add that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.140.1">
      import
     </span>
    </code>
    <span class="koboSpan" id="kobo.141.1">
     outside the function and risk forgetting to remove it.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.142.1">
     Look at how we defined
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.143.1">
      timestamp
     </span>
    </code>
    <span class="koboSpan" id="kobo.144.1">
     .
    </span>
    <span class="koboSpan" id="kobo.144.2">
     It is a function parameter with a list as its default value.
    </span>
    <span class="koboSpan" id="kobo.144.3">
     In
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.145.1">
      Chapter 4
     </span>
    </em>
    <span class="koboSpan" id="kobo.146.1">
     ,
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.147.1">
      Functions, the Building Blocks of Code
     </span>
    </em>
    <span class="koboSpan" id="kobo.148.1">
     , we warned against using mutable defaults for parameters because the default value is initialized when Python parses the function, and the same object persists across different calls to the function.
    </span>
    <span class="koboSpan" id="kobo.148.2">
     Most of the time, this is not the behavior you want.
    </span>
    <span class="koboSpan" id="kobo.148.3">
     In this case, however, we are taking advantage of this feature to store a timestamp from the previous call to the function, without having to use an external global variable.
    </span>
    <span class="koboSpan" id="kobo.148.4">
     We borrowed this trick from our studies on
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.149.1">
      closures
     </span>
    </strong>
    <span class="koboSpan" id="kobo.150.1">
     , a technique that we encourage you to read about.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.151.1">
     After printing
    </span>
    <a id="_idIndexMarker1000">
    </a>
    <span class="koboSpan" id="kobo.152.1">
     the message, we inspect the content of the only item in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.153.1">
      timestamp
     </span>
    </code>
    <span class="koboSpan" id="kobo.154.1">
     .
    </span>
    <span class="koboSpan" id="kobo.154.2">
     If it is
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.155.1">
      None
     </span>
    </code>
    <span class="koboSpan" id="kobo.156.1">
     , we have no previous timestamp, so we set the value to the current time (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.157.1">
      #1
     </span>
    </code>
    <span class="koboSpan" id="kobo.158.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.158.2">
     On the other hand, if we have a previous timestamp, we can calculate a difference (which we neatly format to three decimal digits), and finally, we put the current time in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.159.1">
      timestamp
     </span>
    </code>
    <span class="koboSpan" id="kobo.160.1">
     (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.161.1">
      #2
     </span>
    </code>
    <span class="koboSpan" id="kobo.162.1">
     ).
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.163.1">
     Running this code outputs the following:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.164.1">$ python custom_timestamp.py
Entering buggy piece of code...
</span><span class="koboSpan" id="kobo.164.2">First step done.
 </span><span class="koboSpan" id="kobo.164.3">Time elapsed: 0.300s
Second step done.
 </span><span class="koboSpan" id="kobo.164.4">Time elapsed: 0.500s
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.165.1">
     Using a custom debug function solves some of the problems associated with just using
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.166.1">
      print()
     </span>
    </code>
    <span class="koboSpan" id="kobo.167.1">
     .
    </span>
    <span class="koboSpan" id="kobo.167.2">
     It reduces duplication of debugging code and makes it easier to remove all your debugging code when you no longer need it.
    </span>
    <span class="koboSpan" id="kobo.167.3">
     However, it still requires modifying the code and running it in a console where you can inspect the output.
    </span>
    <span class="koboSpan" id="kobo.167.4">
     Later in this chapter, we will see how we can overcome those difficulties by adding logging to our code.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-287">
    <span class="koboSpan" id="kobo.168.1">
     Using the Python debugger
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.169.1">
     Another
    </span>
    <a id="_idIndexMarker1001">
    </a>
    <span class="koboSpan" id="kobo.170.1">
     effective way of debugging Python is to use an interactive debugger.
    </span>
    <span class="koboSpan" id="kobo.170.2">
     The Python standard library module
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.171.1">
      pdb
     </span>
    </code>
    <span class="koboSpan" id="kobo.172.1">
     provides such a debugger; however, we usually prefer to use the third-party
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.173.1">
      pdbpp
     </span>
    </code>
    <span class="koboSpan" id="kobo.174.1">
     package.
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.175.1">
      pdbpp
     </span>
    </code>
    <span class="koboSpan" id="kobo.176.1">
     is a drop-in replacement for
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.177.1">
      pdb
     </span>
    </code>
    <span class="koboSpan" id="kobo.178.1">
     , with a somewhat friendlier user interface and some handy additional tools, our favorite of which is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.179.1">
      sticky mode
     </span>
    </em>
    <span class="koboSpan" id="kobo.180.1">
     , which allows you to see a whole function while you step through its instructions.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.181.1">
     There are a few different ways to activate the debugger (if you have the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.182.1">
      pdbpp
     </span>
    </code>
    <span class="koboSpan" id="kobo.183.1">
     package installed, it will be loaded instead of the standard
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.184.1">
      pdb
     </span>
    </code>
    <span class="koboSpan" id="kobo.185.1">
     debugger).
    </span>
    <span class="koboSpan" id="kobo.185.2">
     The most common approach is to add a call invoking the debugger to your code.
    </span>
    <span class="koboSpan" id="kobo.185.3">
     This is known as adding a
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.186.1">
      breakpoint
     </span>
    </strong>
    <span class="koboSpan" id="kobo.187.1">
     to the code.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.188.1">
     When the code is run and the interpreter reaches the breakpoint, execution is suspended, and you get console access to an interactive debugger session.
    </span>
    <span class="koboSpan" id="kobo.188.2">
     You can then inspect all the names in the current scope, and step through the program one line at a time.
    </span>
    <span class="koboSpan" id="kobo.188.3">
     You can also alter data on the fly to change the flow of the program.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.189.1">
     As a toy example, suppose
    </span>
    <a id="_idIndexMarker1002">
    </a>
    <span class="koboSpan" id="kobo.190.1">
     we have a program that receives a dictionary and a tuple of keys as input.
    </span>
    <span class="koboSpan" id="kobo.190.2">
     It then processes the dictionary items with the given keys.
    </span>
    <span class="koboSpan" id="kobo.190.3">
     The program is raising a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.191.1">
      KeyError
     </span>
    </code>
    <span class="koboSpan" id="kobo.192.1">
     because one of the keys is missing from the dictionary.
    </span>
    <span class="koboSpan" id="kobo.192.2">
     Suppose we cannot control the input (perhaps it comes from a third-party API), but we want to get past the error so that we can verify that our program would behave correctly on valid input.
    </span>
    <span class="koboSpan" id="kobo.192.3">
     Let us see how we could use the debugger to interrupt the program, inspect and fix the data, and then allow execution to proceed:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.193.1"># pdebugger.py</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.194.1"># d comes from an input that we do not control</span></span><span class="koboSpan" id="kobo.195.1">
d = {"first": "v1", "second": "v2", "fourth": "v4"}
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.196.1"># keys also comes from an input we do not control</span></span><span class="koboSpan" id="kobo.197.1">
keys = ("first", "second", "third", "fourth")
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.198.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.199.1">do_something_with_value</span></span><span class="koboSpan" id="kobo.200.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.201.1">value</span></span><span class="koboSpan" id="kobo.202.1">):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.203.1">print</span></span><span class="koboSpan" id="kobo.204.1">(value)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.205.1">for</span></span><span class="koboSpan" id="kobo.206.1"> key </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.207.1">in</span></span><span class="koboSpan" id="kobo.208.1"> keys:
    do_something_with_value(d[key])
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.209.1">print</span></span><span class="koboSpan" id="kobo.210.1">("Validation done.")
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.211.1">
     As you can see, this code will break when
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.212.1">
      key
     </span>
    </code>
    <span class="koboSpan" id="kobo.213.1">
     gets the value
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.214.1">
      "third"
     </span>
    </code>
    <span class="koboSpan" id="kobo.215.1">
     , which is missing from the dictionary.
    </span>
    <span class="koboSpan" id="kobo.215.2">
     Remember, we’re pretending that both
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.216.1">
      d
     </span>
    </code>
    <span class="koboSpan" id="kobo.217.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.218.1">
      keys
     </span>
    </code>
    <span class="koboSpan" id="kobo.219.1">
     come from an input source that we cannot control.
    </span>
    <span class="koboSpan" id="kobo.219.2">
     If we run the code as it is, we get the following:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.220.1">$ python pdebugger.py
v1
v2
Traceback (most recent call last):
  File ".../ch11/pdebugger.py", line 13, in &lt;module&gt;
    do_something_with_value(d[key])
                            ~^^^^^
KeyError: 'third'
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.221.1">
     We see that that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.222.1">
      key
     </span>
    </code>
    <span class="koboSpan" id="kobo.223.1">
     is missing from the dictionary, but since every time we run this code, we may get a different dictionary or
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.224.1">
      keys
     </span>
    </code>
    <span class="koboSpan" id="kobo.225.1">
     tuple, this information does not really help us.
    </span>
    <span class="koboSpan" id="kobo.225.2">
     We
    </span>
    <a id="_idIndexMarker1003">
    </a>
    <span class="koboSpan" id="kobo.226.1">
     want to inspect and modify the data while the program is running, so let us insert a breakpoint just before the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.227.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.228.1">
     loop.
    </span>
    <span class="koboSpan" id="kobo.228.2">
     In modern versions of Python, the simplest way of doing this is to call the built-in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.229.1">
      breakpoint()
     </span>
    </code>
    <span class="koboSpan" id="kobo.230.1">
     function:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.231.1">breakpoint</span></span><span class="koboSpan" id="kobo.232.1">()
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.233.1">
     Before Python 3.7, you would have needed to import the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.234.1">
      pdb
     </span>
    </code>
    <span class="koboSpan" id="kobo.235.1">
     module and call the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.236.1">
      pdb.set_trace()
     </span>
    </code>
    <span class="koboSpan" id="kobo.237.1">
     function:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.238.1">import</span></span><span class="koboSpan" id="kobo.239.1"> pdb; pdb.set_trace()
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.240.1">
     Note that we have used a semi-colon to separate multiple statements on the same line.
    </span>
    <span class="koboSpan" id="kobo.240.2">
     PEP 8 discourages this, but it is quite common when setting a breakpoint like this, as there are fewer lines to remove when you no longer need the breakpoint.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.241.1">
      The
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.242.1">
       breakpoint()
      </span>
     </code>
     <span class="koboSpan" id="kobo.243.1">
      function calls
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.244.1">
       sys.breakpointhook()
      </span>
     </code>
     <span class="koboSpan" id="kobo.245.1">
      , which, in turn, calls
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.246.1">
       pdb.set_trace()
      </span>
     </code>
     <span class="koboSpan" id="kobo.247.1">
      .
     </span>
     <span class="koboSpan" id="kobo.247.2">
      You can override the default behavior of
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.248.1">
       sys.breakpointhook()
      </span>
     </code>
     <span class="koboSpan" id="kobo.249.1">
      by setting the
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.250.1">
       PYTHONBREAKPOINT
      </span>
     </code>
     <span class="koboSpan" id="kobo.251.1">
      environment variable to point to an alternative function to import and call instead of
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.252.1">
       pdb.set_trace()
      </span>
     </code>
     <span class="koboSpan" id="kobo.253.1">
      .
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.254.1">
     The code for this example is in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.255.1">
      pdebugger_pdb.py
     </span>
    </code>
    <span class="koboSpan" id="kobo.256.1">
     module.
    </span>
    <span class="koboSpan" id="kobo.256.2">
     If we now run this code, things get interesting (note that your output may vary a little and that all the comments in this output were added by us):
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.257.1">$ python pdebugger_pdb.py
[0] &gt; .../ch11/pdebugger_pdb.py(17)&lt;module&gt;()
-&gt; for key in keys:
(Pdb++) l
 16
 17 -&gt; for key in keys:  # breakpoint comes in
 18 do_something_with_value(d[key])
 19
(Pdb++) keys  # inspect the keys tuple
('first', 'second', 'third', 'fourth')
(Pdb++) d.keys()  # inspect keys of d
dict_keys(['first', 'second', 'fourth'])
(Pdb++) d['third'] = 'placeholder'  # add missing item
(Pdb++) c  # continue
v1
v2
placeholder
v4
Validation done.
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.258.1">
     First, note
    </span>
    <a id="_idIndexMarker1004">
    </a>
    <span class="koboSpan" id="kobo.259.1">
     that when you reach a breakpoint, you are served a console that tells you where you are (the Python module) and which line is the next one to be executed.
    </span>
    <span class="koboSpan" id="kobo.259.2">
     You can, at this point, perform some exploratory actions, such as inspecting the code before and after the next line, printing a stack trace, and interacting with the objects.
    </span>
    <span class="koboSpan" id="kobo.259.3">
     In our case, we first inspect the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.260.1">
      keys
     </span>
    </code>
    <span class="koboSpan" id="kobo.261.1">
     tuple.
    </span>
    <span class="koboSpan" id="kobo.261.2">
     We also inspect the keys of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.262.1">
      d
     </span>
    </code>
    <span class="koboSpan" id="kobo.263.1">
     .
    </span>
    <span class="koboSpan" id="kobo.263.2">
     We see that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.264.1">
      'third'
     </span>
    </code>
    <span class="koboSpan" id="kobo.265.1">
     is missing, so we put it in ourselves (could this be dangerous?
    </span>
    <span class="koboSpan" id="kobo.265.2">
     Think about it.).
    </span>
    <span class="koboSpan" id="kobo.265.3">
     Finally, now that all the keys are in, we type
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.266.1">
      c
     </span>
    </code>
    <span class="koboSpan" id="kobo.267.1">
     to continue normal execution.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.268.1">
     The debugger also gives you the ability to execute your code one line at a time using the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.269.1">
      n
     </span>
    </code>
    <span class="koboSpan" id="kobo.270.1">
     command (for next).
    </span>
    <span class="koboSpan" id="kobo.270.2">
     You can use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.271.1">
      s
     </span>
    </code>
    <span class="koboSpan" id="kobo.272.1">
     command to step into a function for deeper analysis or set additional breakpoints with the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.273.1">
      b
     </span>
    </code>
    <span class="koboSpan" id="kobo.274.1">
     command.
    </span>
    <span class="koboSpan" id="kobo.274.2">
     For a complete list of commands, please refer to the documentation (which you can find at
    </span>
    <a href="https://docs.python.org/3.12/library/pdb.html">
     <span class="url">
      <span class="koboSpan" id="kobo.275.1">
       https://docs.python.org/3.12/library/pdb.html
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.276.1">
     ) or type
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.277.1">
      h
     </span>
    </code>
    <span class="koboSpan" id="kobo.278.1">
     (for help) in the debugger console.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.279.1">
     You can see, from the output of the preceding run, that we could finally get to the end of the validation.
    </span>
   </p>
   <p class="normal">
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.280.1">
      pdb
     </span>
    </code>
    <span class="koboSpan" id="kobo.281.1">
     (or
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.282.1">
      pdbpp
     </span>
    </code>
    <span class="koboSpan" id="kobo.283.1">
     ) is an invaluable tool that we use every day.
    </span>
    <span class="koboSpan" id="kobo.283.2">
     So, please experiment with it.
    </span>
    <span class="koboSpan" id="kobo.283.3">
     Set a breakpoint somewhere and try to inspect it, follow the official documentation, and try the commands in your code to see their effect and learn them well.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.284.1">
      Notice that, in this example, we have assumed you installed
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.285.1">
       pdbpp
      </span>
     </code>
     <span class="koboSpan" id="kobo.286.1">
      .
     </span>
     <span class="koboSpan" id="kobo.286.2">
      If that is not the case, then you might find that some commands behave a bit differently in plain
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.287.1">
       pdb
      </span>
     </code>
     <span class="koboSpan" id="kobo.288.1">
      .
     </span>
     <span class="koboSpan" id="kobo.288.2">
      One example is the letter
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.289.1">
       d
      </span>
     </em>
     <span class="koboSpan" id="kobo.290.1">
      , which
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.291.1">
       pdb
      </span>
     </code>
     <span class="koboSpan" id="kobo.292.1">
      interprets as the
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.293.1">
       down
      </span>
     </em>
     <span class="koboSpan" id="kobo.294.1">
      command.
     </span>
     <span class="koboSpan" id="kobo.294.2">
      To get around that, you would have to add an
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.295.1">
       !
      </span>
     </code>
     <span class="koboSpan" id="kobo.296.1">
      in front of
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.297.1">
       d
      </span>
     </code>
     <span class="koboSpan" id="kobo.298.1">
      to tell
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.299.1">
       pdb
      </span>
     </code>
     <span class="koboSpan" id="kobo.300.1">
      that it is meant to be interpreted literally, and not as a command.
     </span>
    </p>
   </div>
   <h2 class="heading-2" id="_idParaDest-288">
    <span class="koboSpan" id="kobo.301.1">
     Inspecting logs
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.302.1">
     Another way
    </span>
    <a id="_idIndexMarker1005">
    </a>
    <span class="koboSpan" id="kobo.303.1">
     of debugging a misbehaving application is to inspect its logs.
    </span>
    <span class="koboSpan" id="kobo.303.2">
     A
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.304.1">
      log
     </span>
    </strong>
    <span class="koboSpan" id="kobo.305.1">
     is an ordered list of events that occurred or actions that were taken during the running of an application.
    </span>
    <span class="koboSpan" id="kobo.305.2">
     If a log is written to a file on disk, it is known as a
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.306.1">
      log file
     </span>
    </strong>
    <span class="koboSpan" id="kobo.307.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.308.1">
     Using logs for debugging is, in some ways, similar to adding
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.309.1">
      print()
     </span>
    </code>
    <span class="koboSpan" id="kobo.310.1">
     calls or using a custom debug function.
    </span>
    <span class="koboSpan" id="kobo.310.2">
     The key difference is that we typically add logging to our code from the start to aid future debugging, rather than adding it during debugging and then removing it again.
    </span>
    <span class="koboSpan" id="kobo.310.3">
     Another difference is that logging can easily be configured to output to a file or a network location.
    </span>
    <span class="koboSpan" id="kobo.310.4">
     These two aspects make logging ideal for debugging code that is running on a remote machine that you might not have direct access to.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.311.1">
     The fact that logging is usually added to the code before a bug has occurred does pose the challenge of deciding what to log.
    </span>
    <span class="koboSpan" id="kobo.311.2">
     We would typically expect to find entries in the logs corresponding to the start and completion (and potentially also intermediate steps) of any important process that takes place within the application.
    </span>
    <span class="koboSpan" id="kobo.311.3">
     The values of important variables should be included in these log entries.
    </span>
    <span class="koboSpan" id="kobo.311.4">
     Errors also need to be logged so that if a problem occurs, we can inspect the logs to find out what went wrong.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.312.1">
     Nearly every aspect of logging in Python can be configured in various ways.
    </span>
    <span class="koboSpan" id="kobo.312.2">
     This gives us a lot of power, as we can change where logs are output to, which log messages are output, and how log messages are formatted, simply by changing the logging configuration and without changing any other code.
    </span>
    <span class="koboSpan" id="kobo.312.3">
     The four main types of objects involved in logging in Python are:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.313.1">
       Loggers
      </span>
     </strong>
     <span class="koboSpan" id="kobo.314.1">
      : Expose the interface that the application code uses directly
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.315.1">
       Handlers
      </span>
     </strong>
     <span class="koboSpan" id="kobo.316.1">
      : Send the log records (created by loggers) to the appropriate destination
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.317.1">
       Filters
      </span>
     </strong>
     <span class="koboSpan" id="kobo.318.1">
      : Provide a finer-grained facility for determining which log records to output
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.319.1">
       Formatters
      </span>
     </strong>
     <span class="koboSpan" id="kobo.320.1">
      : Specify the layout of the log records in the final output
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.321.1">
     Logging is performed by calling methods on instances of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.322.1">
      Logger
     </span>
    </code>
    <span class="koboSpan" id="kobo.323.1">
     class.
    </span>
    <span class="koboSpan" id="kobo.323.2">
     Each line you log has a severity level associated with it.
    </span>
    <span class="koboSpan" id="kobo.323.3">
     The most commonly used levels are
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.324.1">
      DEBUG
     </span>
    </code>
    <span class="koboSpan" id="kobo.325.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.326.1">
      INFO
     </span>
    </code>
    <span class="koboSpan" id="kobo.327.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.328.1">
      WARNING
     </span>
    </code>
    <span class="koboSpan" id="kobo.329.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.330.1">
      ERROR
     </span>
    </code>
    <span class="koboSpan" id="kobo.331.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.332.1">
      CRITICAL
     </span>
    </code>
    <span class="koboSpan" id="kobo.333.1">
     .
    </span>
    <span class="koboSpan" id="kobo.333.2">
     Loggers use these levels to determine which log messages to output.
    </span>
    <span class="koboSpan" id="kobo.333.3">
     Anything below the logger’s level will be ignored.
    </span>
    <span class="koboSpan" id="kobo.333.4">
     This means that you must take care to log at the appropriate level.
    </span>
    <span class="koboSpan" id="kobo.333.5">
     If you log everything at the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.334.1">
      DEBUG
     </span>
    </code>
    <span class="koboSpan" id="kobo.335.1">
     level, you will need to configure your logger at (or below) the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.336.1">
      DEBUG
     </span>
    </code>
    <span class="koboSpan" id="kobo.337.1">
     level to see any of your messages.
    </span>
    <span class="koboSpan" id="kobo.337.2">
     This can quickly result in your log files becoming extremely large.
    </span>
    <span class="koboSpan" id="kobo.337.3">
     A similar problem occurs if you log everything at the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.338.1">
      CRITICAL
     </span>
    </code>
    <span class="koboSpan" id="kobo.339.1">
     level.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.340.1">
     Python gives
    </span>
    <a id="_idIndexMarker1006">
    </a>
    <span class="koboSpan" id="kobo.341.1">
     you several choices of where to log to.
    </span>
    <span class="koboSpan" id="kobo.341.2">
     You can log to a file, a network location, a queue, a console, your operating system’s logging facilities, and so on.
    </span>
    <span class="koboSpan" id="kobo.341.3">
     Where you send your logs will typically depend very much on the context.
    </span>
    <span class="koboSpan" id="kobo.341.4">
     For example, when you run your code in your development environment, you will typically log to your terminal.
    </span>
    <span class="koboSpan" id="kobo.341.5">
     If your application runs on a single machine, you might log to a file or send your logs to the operating system’s logging facilities.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.342.1">
     On the other hand, if your application uses a distributed architecture that spans multiple machines (such as in the case of service-oriented or microservice architectures), it is better to implement a centralized solution for logging so that all log messages coming from each service can be stored and investigated in a single place.
    </span>
    <span class="koboSpan" id="kobo.342.2">
     This makes debugging much easier because trying to correlate giant files from multiple sources to figure out what went wrong can become truly challenging.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.343.1">
      A
     </span>
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.344.1">
       service-oriented architecture
      </span>
     </strong>
     <span class="koboSpan" id="kobo.345.1">
      (
     </span>
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.346.1">
       SOA
      </span>
     </strong>
     <span class="koboSpan" id="kobo.347.1">
      ) is an architectural pattern in software design in which application components provide services to other components via a communications protocol, typically over a network.
     </span>
     <span class="koboSpan" id="kobo.347.2">
      The beauty of this system is that, when coded properly, each service can be written in the most appropriate language to serve its purpose.
     </span>
     <span class="koboSpan" id="kobo.347.3">
      The only thing that matters is the communication with the other services, which needs to happen via a common format so that data exchange can be done.
     </span>
    </p>
    <p class="normal">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.348.1">
       Microservice architectures
      </span>
     </strong>
     <span class="koboSpan" id="kobo.349.1">
      are an evolution of SOAs but follow a different set of architectural patterns.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.350.1">
     The downside of the configurability of Python’s logging is that the logging machinery is somewhat complex.
    </span>
    <span class="koboSpan" id="kobo.350.2">
     Fortunately, the defaults are often sufficient, and you only need to override settings when you have a specific need for customization.
    </span>
    <span class="koboSpan" id="kobo.350.3">
     Let us see a simple example of logging a few messages to a file:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.351.1"># log.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.352.1">import</span></span><span class="koboSpan" id="kobo.353.1"> logging
logging.basicConfig(
    filename="ch11.log",
    level=logging.DEBUG, 
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.354.1">format</span></span><span class="koboSpan" id="kobo.355.1">="[%(asctime)s] %(levelname)s: %(message)s",
    datefmt="%m/%d/%Y %I:%M:%S %p")
mylist = [</span><span class="hljs-number"><span class="koboSpan" id="kobo.356.1">1</span></span><span class="koboSpan" id="kobo.357.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.358.1">2</span></span><span class="koboSpan" id="kobo.359.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.360.1">3</span></span><span class="koboSpan" id="kobo.361.1">]
logging.info("Starting to process 'mylist'...")
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.362.1">for</span></span><span class="koboSpan" id="kobo.363.1"> position </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.364.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.365.1">range</span></span><span class="koboSpan" id="kobo.366.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.367.1">4</span></span><span class="koboSpan" id="kobo.368.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.369.1">try</span></span><span class="koboSpan" id="kobo.370.1">:
        logging.debug(
            "Value at position %s is %s",
            position,
            mylist[position]
        )
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.371.1">except</span></span><span class="koboSpan" id="kobo.372.1"> IndexError:
        logging.exception("Faulty position: %s", position)
logging.info("Done processing 'mylist'.")
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.373.1">
     First, we
    </span>
    <a id="_idIndexMarker1007">
    </a>
    <span class="koboSpan" id="kobo.374.1">
     import the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.375.1">
      logging
     </span>
    </code>
    <span class="koboSpan" id="kobo.376.1">
     module, then we set up a basic configuration.
    </span>
    <span class="koboSpan" id="kobo.376.2">
     We specify a filename, configure the logger to output any log messages with the level
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.377.1">
      DEBUG
     </span>
    </code>
    <span class="koboSpan" id="kobo.378.1">
     or higher, and set the message format.
    </span>
    <span class="koboSpan" id="kobo.378.2">
     We want to log the date and time information, the level, and the message.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.379.1">
     With the configuration in place, we can start logging.
    </span>
    <span class="koboSpan" id="kobo.379.2">
     We start by logging an
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.380.1">
      info
     </span>
    </code>
    <span class="koboSpan" id="kobo.381.1">
     message that tells us we are about to process our list.
    </span>
    <span class="koboSpan" id="kobo.381.2">
     Inside the loop, we will log the value at each position (we use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.382.1">
      debug()
     </span>
    </code>
    <span class="koboSpan" id="kobo.383.1">
     function to log at the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.384.1">
      DEBUG
     </span>
    </code>
    <span class="koboSpan" id="kobo.385.1">
     level).
    </span>
    <span class="koboSpan" id="kobo.385.2">
     We use
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.386.1">
      debug()
     </span>
    </code>
    <span class="koboSpan" id="kobo.387.1">
     here so that we can filter out these logs in the future (by configuring the logger’s
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.388.1">
      level
     </span>
    </code>
    <span class="koboSpan" id="kobo.389.1">
     to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.390.1">
      logging.INFO
     </span>
    </code>
    <span class="koboSpan" id="kobo.391.1">
     or more) because we might have to handle large lists, and we do not want to always log all the values.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.392.1">
     If we get
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.393.1">
      IndexError
     </span>
    </code>
    <span class="koboSpan" id="kobo.394.1">
     (and we do, since we are looping over
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.395.1">
      range(4)
     </span>
    </code>
    <span class="koboSpan" id="kobo.396.1">
     ), we call
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.397.1">
      logging.exception()
     </span>
    </code>
    <span class="koboSpan" id="kobo.398.1">
     , which logs at the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.399.1">
      ERROR
     </span>
    </code>
    <span class="koboSpan" id="kobo.400.1">
     level, but also outputs the exception traceback.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.401.1">
     At the end of the code, we log another
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.402.1">
      info
     </span>
    </code>
    <span class="koboSpan" id="kobo.403.1">
     message to say that we are done.
    </span>
    <span class="koboSpan" id="kobo.403.2">
     After running this code, we will have a new
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.404.1">
      ch11.log
     </span>
    </code>
    <span class="koboSpan" id="kobo.405.1">
     file with the following content:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.406.1"># ch11.log
[10/06/2024 10:08:04 PM] INFO: Starting to process 'mylist'...
</span><span class="koboSpan" id="kobo.406.2">[10/06/2024 10:08:04 PM] DEBUG: Value at position 0 is 1
[10/06/2024 10:08:04 PM] DEBUG: Value at position 1 is 2
[10/06/2024 10:08:04 PM] DEBUG: Value at position 2 is 3
[10/06/2024 10:08:04 PM] ERROR: Faulty position: 3
Traceback (most recent call last):
  File ".../ch11/log.py", line 20, in &lt;module&gt;
    mylist[position],
    ~~~~~~^^^^^^^^^^
IndexError: list index out of range
[10/06/2024 10:08:04 PM] INFO: Done processing 'mylist'.
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.407.1">
     This is
    </span>
    <a id="_idIndexMarker1008">
    </a>
    <span class="koboSpan" id="kobo.408.1">
     precisely what we need to be able to debug an application that is running on a remote machine, rather than our own development environment.
    </span>
    <span class="koboSpan" id="kobo.408.2">
     We can see what our code did, the traceback of any exception raised, and so on.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.409.1">
     Feel free to modify the logging levels in the previous example, both the code and the configuration.
    </span>
    <span class="koboSpan" id="kobo.409.2">
     This way, you’ll be able to see how the output changes according to your setup.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.410.1">
      The example presented here only scratches the surface of logging.
     </span>
     <span class="koboSpan" id="kobo.410.2">
      For a more in-depth explanation, you can find information in the
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.411.1">
       Python HOWTOs
      </span>
     </em>
     <span class="koboSpan" id="kobo.412.1">
      section of the official Python documentation:
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.413.1">
       Logging HOWTO
      </span>
     </em>
     <span class="koboSpan" id="kobo.414.1">
      and
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.415.1">
       Logging Cookbook
      </span>
     </em>
     <span class="koboSpan" id="kobo.416.1">
      .
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.417.1">
     Logging is an art.
    </span>
    <span class="koboSpan" id="kobo.417.2">
     You need to find a good balance between logging everything and logging nothing.
    </span>
    <span class="koboSpan" id="kobo.417.3">
     Ideally, you should log anything that you need to make sure your application is working correctly, and possibly all errors or exceptions.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-289">
    <span class="koboSpan" id="kobo.418.1">
     Other techniques
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.419.1">
     We will end this section on debugging by briefly mentioning a couple of other techniques that you may find useful.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-290">
    <span class="koboSpan" id="kobo.420.1">
     Reading tracebacks
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.421.1">
     Bugs often manifest as
    </span>
    <a id="_idIndexMarker1009">
    </a>
    <span class="koboSpan" id="kobo.422.1">
     unhandled exceptions.
    </span>
    <span class="koboSpan" id="kobo.422.2">
     The ability to interpret an exception traceback is therefore a crucial skill for successful debugging.
    </span>
    <span class="koboSpan" id="kobo.422.3">
     Make sure that you have read and understood the section on tracebacks in
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.423.1">
      Chapter 7
     </span>
    </em>
    <span class="koboSpan" id="kobo.424.1">
     ,
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.425.1">
      Exceptions and Context Managers
     </span>
    </em>
    <span class="koboSpan" id="kobo.426.1">
     .
    </span>
    <span class="koboSpan" id="kobo.426.2">
     If you are trying to understand why an exception happened, it is often useful to inspect the state of your program (using the techniques we discussed above) at the lines mentioned in the traceback.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-291">
    <span class="koboSpan" id="kobo.427.1">
     Assertions
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.428.1">
     Bugs are often
    </span>
    <a id="_idIndexMarker1010">
    </a>
    <span class="koboSpan" id="kobo.429.1">
     the result of incorrect assumptions in our code.
    </span>
    <span class="koboSpan" id="kobo.429.2">
     Assertions can be helpful for validating those assumptions.
    </span>
    <span class="koboSpan" id="kobo.429.3">
     If our assumptions are valid, the assertions pass and execution proceeds normally.
    </span>
    <span class="koboSpan" id="kobo.429.4">
     If they are not, we get an exception telling us which of our assumptions are incorrect.
    </span>
    <span class="koboSpan" id="kobo.429.5">
     Sometimes, instead of inspecting with a debugger or
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.430.1">
      print()
     </span>
    </code>
    <span class="koboSpan" id="kobo.431.1">
     statements, it is quicker to drop a couple of assertions in the code just to exclude possibilities.
    </span>
    <span class="koboSpan" id="kobo.431.2">
     Let us see an example:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.432.1"># assertions.py</span></span><span class="koboSpan" id="kobo.433.1">
mylist = [</span><span class="hljs-number"><span class="koboSpan" id="kobo.434.1">1</span></span><span class="koboSpan" id="kobo.435.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.436.1">2</span></span><span class="koboSpan" id="kobo.437.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.438.1">3</span></span><span class="koboSpan" id="kobo.439.1">]  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.440.1">#  pretend this comes from an external source</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.441.1">assert</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.442.1">4</span></span><span class="koboSpan" id="kobo.443.1"> == </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.444.1">len</span></span><span class="koboSpan" id="kobo.445.1">(mylist)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.446.1"># this will break</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.447.1">for</span></span><span class="koboSpan" id="kobo.448.1"> position </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.449.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.450.1">range</span></span><span class="koboSpan" id="kobo.451.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.452.1">4</span></span><span class="koboSpan" id="kobo.453.1">):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.454.1">print</span></span><span class="koboSpan" id="kobo.455.1">(mylist[position])
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.456.1">
     In this
    </span>
    <a id="_idIndexMarker1011">
    </a>
    <span class="koboSpan" id="kobo.457.1">
     example, we pretend that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.458.1">
      mylist
     </span>
    </code>
    <span class="koboSpan" id="kobo.459.1">
     comes from some external source that we do not control (maybe user input).
    </span>
    <span class="koboSpan" id="kobo.459.2">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.460.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.461.1">
     loop assumes that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.462.1">
      mylist
     </span>
    </code>
    <span class="koboSpan" id="kobo.463.1">
     has four elements and we have added an assertion to validate that assumption.
    </span>
    <span class="koboSpan" id="kobo.463.2">
     When we run the code, the result is this:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.464.1">$ python assertions.py
Traceback (most recent call last):
  File ".../ch11/assertions.py", line 4, in &lt;module&gt;
    assert 4 == len(mylist)  # this will break
           ^^^^^^^^^^^^^^^^
AssertionError
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.465.1">
     This tells us exactly where the problem is.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.466.1">
      Running a program with the
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.467.1">
       -O
      </span>
     </code>
     <span class="koboSpan" id="kobo.468.1">
      flag active will cause Python to ignore all assertions.
     </span>
     <span class="koboSpan" id="kobo.468.2">
      This is something to keep in mind if our code depends on assertions to work.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.469.1">
     Assertions also allow for a longer format that includes a second expression, such as:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.470.1">assert</span></span><span class="koboSpan" id="kobo.471.1"> expression1, expression2
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.472.1">
     The second expression is passed to the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.473.1">
      AssertionError
     </span>
    </code>
    <span class="koboSpan" id="kobo.474.1">
     exception raised by the statement.
    </span>
    <span class="koboSpan" id="kobo.474.2">
     It is typically a string with an error message.
    </span>
    <span class="koboSpan" id="kobo.474.3">
     For example, if we changed the assertion in the last example to the following:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.475.1">assert</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.476.1">4</span></span><span class="koboSpan" id="kobo.477.1"> == </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.478.1">len</span></span><span class="koboSpan" id="kobo.479.1">(mylist), f"Mylist has {</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.480.1">len</span></span><span class="koboSpan" id="kobo.481.1">(mylist)} elements"
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.482.1">
     the result would be:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.483.1">$ python assertions.py
Traceback (most recent call last):
  File ".../ch11/assertions.py", line 19, in &lt;module&gt;
    assert 4 == len(mylist), f"Mylist has {len(mylist)} elements"
           ^^^^^^^^^^^^^^^^
AssertionError: Mylist has 3 elements
</span></code></pre>
   <h2 class="heading-2" id="_idParaDest-292">
    <span class="koboSpan" id="kobo.484.1">
     Where to find information
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.485.1">
     The
    </span>
    <a id="_idIndexMarker1012">
    </a>
    <span class="koboSpan" id="kobo.486.1">
     official Python documentation contains a section dedicated to debugging and profiling.
    </span>
    <span class="koboSpan" id="kobo.486.2">
     There, you can read about the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.487.1">
      bdb
     </span>
    </code>
    <span class="koboSpan" id="kobo.488.1">
     debugger framework and about modules such as
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.489.1">
      faulthandler
     </span>
    </code>
    <span class="koboSpan" id="kobo.490.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.491.1">
      timeit
     </span>
    </code>
    <span class="koboSpan" id="kobo.492.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.493.1">
      trace
     </span>
    </code>
    <span class="koboSpan" id="kobo.494.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.495.1">
      tracemalloc
     </span>
    </code>
    <span class="koboSpan" id="kobo.496.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.497.1">
      pdb
     </span>
    </code>
    <span class="koboSpan" id="kobo.498.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.499.1">
     Let us now explore some troubleshooting guidelines.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-293">
    <span class="koboSpan" id="kobo.500.1">
     Troubleshooting guidelines
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.501.1">
     In this short section, we
    </span>
    <a id="_idIndexMarker1013">
    </a>
    <span class="koboSpan" id="kobo.502.1">
     would like to give you a few tips that come from our troubleshooting experience.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-294">
    <span class="koboSpan" id="kobo.503.1">
     Where to inspect
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.504.1">
     Our first
    </span>
    <a id="_idIndexMarker1014">
    </a>
    <span class="koboSpan" id="kobo.505.1">
     suggestion concerns where to place your debugging breakpoints.
    </span>
    <span class="koboSpan" id="kobo.505.2">
     Regardless of whether you are using
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.506.1">
      print()
     </span>
    </code>
    <span class="koboSpan" id="kobo.507.1">
     , a custom function,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.508.1">
      pdb
     </span>
    </code>
    <span class="koboSpan" id="kobo.509.1">
     , or logging, you still have to choose where to place the calls that provide you with the information.
    </span>
    <span class="koboSpan" id="kobo.509.2">
     Some places are definitely better than others, and there are ways to handle the debugging progression that are better than others.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.510.1">
     We normally avoid placing a breakpoint inside an
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.511.1">
      if
     </span>
    </code>
    <span class="koboSpan" id="kobo.512.1">
     clause.
    </span>
    <span class="koboSpan" id="kobo.512.2">
     If the branch containing the breakpoint is not executed, we lose the chance to get the information we want.
    </span>
    <span class="koboSpan" id="kobo.512.3">
     Sometimes, it can be difficult to reproduce a bug, or it may take a while for your code to reach the breakpoint, so think carefully before placing them.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.513.1">
     Another important thing is where to start.
    </span>
    <span class="koboSpan" id="kobo.513.2">
     Imagine that you have 100 lines of code that handle your data.
    </span>
    <span class="koboSpan" id="kobo.513.3">
     Data comes in at line 1, and somehow, it is wrong at line 100.
    </span>
    <span class="koboSpan" id="kobo.513.4">
     You do not know where the bug is, so what do you do?
    </span>
    <span class="koboSpan" id="kobo.513.5">
     You can place a breakpoint at line 1 and patiently step through all 100 lines, checking your data at every step.
    </span>
    <span class="koboSpan" id="kobo.513.6">
     In the worst-case scenario, 99 lines (and many cups of coffee) later, you spot the bug.
    </span>
    <span class="koboSpan" id="kobo.513.7">
     So, consider using a different approach.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.514.1">
     Start at line 50 and inspect.
    </span>
    <span class="koboSpan" id="kobo.514.2">
     If the data is good, it means the bug happens later, in which case you place your next breakpoint at line 75.
    </span>
    <span class="koboSpan" id="kobo.514.3">
     If the data at line 50 is already bad, you go on by
    </span>
    <a id="_idIndexMarker1015">
    </a>
    <span class="koboSpan" id="kobo.515.1">
     placing a breakpoint at line 25.
    </span>
    <span class="koboSpan" id="kobo.515.2">
     Then, you repeat.
    </span>
    <span class="koboSpan" id="kobo.515.3">
     Each time, you move either backward or forward, by half the jump you did last time.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.516.1">
     In our worst-case scenario, your debugging would go from 1, 2, 3, ..., 99, in a linear fashion, to a series of jumps such as 50, 75, 87, 93, 96, ..., 99, which is much faster.
    </span>
    <span class="koboSpan" id="kobo.516.2">
     In fact, it is logarithmic.
    </span>
    <span class="koboSpan" id="kobo.516.3">
     This searching technique is
    </span>
    <a id="_idIndexMarker1016">
    </a>
    <span class="koboSpan" id="kobo.517.1">
     called
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.518.1">
      binary search
     </span>
    </strong>
    <span class="koboSpan" id="kobo.519.1">
     ; it is based on a divide-and-conquer approach, and it is highly effective, so try to master it.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-295">
    <span class="koboSpan" id="kobo.520.1">
     Using tests to debug
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.521.1">
     In
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.522.1">
      Chapter 10
     </span>
    </em>
    <span class="koboSpan" id="kobo.523.1">
     ,
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.524.1">
      Testing
     </span>
    </em>
    <span class="koboSpan" id="kobo.525.1">
     , we
    </span>
    <a id="_idIndexMarker1017">
    </a>
    <span class="koboSpan" id="kobo.526.1">
     briefly introduced you
    </span>
    <a id="_idIndexMarker1018">
    </a>
    <span class="koboSpan" id="kobo.527.1">
     to
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.528.1">
      test-driven development
     </span>
    </strong>
    <span class="koboSpan" id="kobo.529.1">
     (
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.530.1">
      TDD
     </span>
    </strong>
    <span class="koboSpan" id="kobo.531.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.531.2">
     One TDD practice that you really should adopt, even if you do not subscribe to TDD as a whole, is writing tests that reproduce a bug before you start changing your code to fix the bug.
    </span>
    <span class="koboSpan" id="kobo.531.3">
     There are several reasons for this.
    </span>
    <span class="koboSpan" id="kobo.531.4">
     If you have a bug and all tests are passing, it means something is wrong or missing in your test code base.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.532.1">
     Adding these tests will help you ensure that you really do fix the bug: the tests should only pass if the bug is gone.
    </span>
    <span class="koboSpan" id="kobo.532.2">
     Finally, having these tests will protect you from inadvertently reintroducing the same bug again.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-296">
    <span class="koboSpan" id="kobo.533.1">
     Monitoring
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.534.1">
     Monitoring is
    </span>
    <a id="_idIndexMarker1019">
    </a>
    <span class="koboSpan" id="kobo.535.1">
     also important.
    </span>
    <span class="koboSpan" id="kobo.535.2">
     Software applications can sometimes behave in unexpected ways in edge-case situations, such as the network being down, a queue being full, or an external component being unresponsive.
    </span>
    <span class="koboSpan" id="kobo.535.3">
     In these cases, it is important to have an idea of what the big picture was when the problem occurred and be able to correlate it to something related to it in a subtle, perhaps mysterious, way.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.536.1">
     You can monitor API endpoints, processes, web pages’ availability and load times, and everything that you can code.
    </span>
    <span class="koboSpan" id="kobo.536.2">
     In general, when starting an application from scratch, it can be helpful to think about how you want to monitor it from the earliest design stages.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.537.1">
     Now, let us move on to see how we can profile Python code.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-297">
    <span class="koboSpan" id="kobo.538.1">
     Profiling Python
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.539.1">
     Profiling
    </span>
    <a id="_idIndexMarker1020">
    </a>
    <span class="koboSpan" id="kobo.540.1">
     means having the application run while keeping track of several different parameters, such as the number of times a function is called, and the amount of time spent inside it.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.541.1">
     Profiling is closely related to debugging.
    </span>
    <span class="koboSpan" id="kobo.541.2">
     Although the tools and processes used are quite different, both activities involve probing and analyzing your code to understand where the root of a problem lies, and then making changes to fix it.
    </span>
    <span class="koboSpan" id="kobo.541.3">
     The difference is that instead of incorrect output or crashing, the problem we are trying to solve is poor performance.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.542.1">
     Sometimes, profiling will point to where the performance bottleneck is, at which point you will need to use the debugging techniques we discussed earlier in this chapter to understand why a particular piece of code does not perform as well as it should.
    </span>
    <span class="koboSpan" id="kobo.542.2">
     For example, faulty logic in a database query might result in loading thousands of rows from a table instead of just hundreds.
    </span>
    <span class="koboSpan" id="kobo.542.3">
     Profiling might show you that a particular function is called many more times than expected, at which point you would need to use your debugging skills to work out why that is and address the problem.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.543.1">
     There are a few ways to
    </span>
    <a id="_idIndexMarker1021">
    </a>
    <span class="koboSpan" id="kobo.544.1">
     profile a Python application.
    </span>
    <span class="koboSpan" id="kobo.544.2">
     If you look at the Profiling section in the standard library official documentation, you will see that there are two different implementations of the same profiling interface,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.545.1">
      profile
     </span>
    </code>
    <span class="koboSpan" id="kobo.546.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.547.1">
      cProfile
     </span>
    </code>
    <span class="koboSpan" id="kobo.548.1">
     :
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.549.1">
       cProfile
      </span>
     </code>
     <span class="koboSpan" id="kobo.550.1">
      is written in C and adds comparatively little overhead, which makes it suitable for profiling long-running programs.
     </span>
    </li>
    <li class="bulletList">
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.551.1">
       profile
      </span>
     </code>
     <span class="koboSpan" id="kobo.552.1">
      is implemented in pure Python and, as a result, adds significant overhead to profiled programs.
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.553.1">
     This interface
    </span>
    <a id="_idIndexMarker1022">
    </a>
    <span class="koboSpan" id="kobo.554.1">
     does
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.555.1">
      deterministic profiling
     </span>
    </strong>
    <span class="koboSpan" id="kobo.556.1">
     , which means that all
    </span>
    <a id="_idIndexMarker1023">
    </a>
    <span class="koboSpan" id="kobo.557.1">
     function calls, function returns, and exception events are monitored, and precise timings are made for the intervals between these events.
    </span>
    <span class="koboSpan" id="kobo.557.2">
     Another approach, called
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.558.1">
      statistical profiling
     </span>
    </strong>
    <span class="koboSpan" id="kobo.559.1">
     , randomly
    </span>
    <a id="_idIndexMarker1024">
    </a>
    <span class="koboSpan" id="kobo.560.1">
     samples the program’s call stack at
    </span>
    <a id="_idIndexMarker1025">
    </a>
    <span class="koboSpan" id="kobo.561.1">
     regular intervals and deduces where time is being spent.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.562.1">
     The latter usually involves less overhead but provides only approximate results.
    </span>
    <span class="koboSpan" id="kobo.562.2">
     Moreover, because of the way the Python interpreter runs the code, deterministic profiling does not add as much overhead as one would think, so we will show you a simple example using
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.563.1">
      cProfile
     </span>
    </code>
    <span class="koboSpan" id="kobo.564.1">
     from the command line.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.565.1">
      There are situations where even the relatively low overhead of
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.566.1">
       cProfile
      </span>
     </code>
     <span class="koboSpan" id="kobo.567.1">
      is not acceptable, for example, if you need to profile code on a live production web server because you cannot reproduce the performance problem in your development environment.
     </span>
     <span class="koboSpan" id="kobo.567.2">
      For such cases, you really do need a statistical profiler.
     </span>
     <span class="koboSpan" id="kobo.567.3">
      If you are interested in statistical profiling for Python, we suggest you look at
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.568.1">
       py-spy
      </span>
     </code>
     <span class="koboSpan" id="kobo.569.1">
      (
     </span>
     <a href="https://github.com/benfred/py-spy">
      <span class="url">
       <span class="koboSpan" id="kobo.570.1">
        https://github.com/benfred/py-spy
       </span>
      </span>
     </a>
     <span class="koboSpan" id="kobo.571.1">
      ).
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.572.1">
     We are going to
    </span>
    <a id="_idIndexMarker1026">
    </a>
    <span class="koboSpan" id="kobo.573.1">
     calculate Pythagorean triples again, using the following code:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.574.1"># profiling/triples.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.575.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.576.1">calc_triples</span></span><span class="koboSpan" id="kobo.577.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.578.1">mx</span></span><span class="koboSpan" id="kobo.579.1">):
    triples = []
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.580.1">for</span></span><span class="koboSpan" id="kobo.581.1"> a </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.582.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.583.1">range</span></span><span class="koboSpan" id="kobo.584.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.585.1">1</span></span><span class="koboSpan" id="kobo.586.1">, mx + </span><span class="hljs-number"><span class="koboSpan" id="kobo.587.1">1</span></span><span class="koboSpan" id="kobo.588.1">):
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.589.1">for</span></span><span class="koboSpan" id="kobo.590.1"> b </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.591.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.592.1">range</span></span><span class="koboSpan" id="kobo.593.1">(a, mx + </span><span class="hljs-number"><span class="koboSpan" id="kobo.594.1">1</span></span><span class="koboSpan" id="kobo.595.1">):
            hypotenuse = calc_hypotenuse(a, b)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.596.1">if</span></span><span class="koboSpan" id="kobo.597.1"> is_int(hypotenuse):
                triples.append((a, b, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.598.1">int</span></span><span class="koboSpan" id="kobo.599.1">(hypotenuse)))
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.600.1">return</span></span><span class="koboSpan" id="kobo.601.1"> triples
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.602.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.603.1">calc_hypotenuse</span></span><span class="koboSpan" id="kobo.604.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.605.1">a, b</span></span><span class="koboSpan" id="kobo.606.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.607.1">return</span></span><span class="koboSpan" id="kobo.608.1"> (a**</span><span class="hljs-number"><span class="koboSpan" id="kobo.609.1">2</span></span><span class="koboSpan" id="kobo.610.1"> + b**</span><span class="hljs-number"><span class="koboSpan" id="kobo.611.1">2</span></span><span class="koboSpan" id="kobo.612.1">) ** </span><span class="hljs-number"><span class="koboSpan" id="kobo.613.1">0.5</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.614.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.615.1">is_int</span></span><span class="koboSpan" id="kobo.616.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.617.1">n</span></span><span class="koboSpan" id="kobo.618.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.619.1">return</span></span><span class="koboSpan" id="kobo.620.1"> n.is_integer()
triples = calc_triples(</span><span class="hljs-number"><span class="koboSpan" id="kobo.621.1">1000</span></span><span class="koboSpan" id="kobo.622.1">)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.623.1">
     The script is simple; we iterate over the interval
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.624.1">
      [1,
     </span>
    </code>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.625.1">
      mx]
     </span>
    </code>
    <span class="koboSpan" id="kobo.626.1">
     with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.627.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.628.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.629.1">
      b
     </span>
    </code>
    <span class="koboSpan" id="kobo.630.1">
     (avoiding repetition of pairs by setting
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.631.1">
      b &gt;= a
     </span>
    </code>
    <span class="koboSpan" id="kobo.632.1">
     ) and we check whether they belong to a right triangle.
    </span>
    <span class="koboSpan" id="kobo.632.2">
     We use
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.633.1">
      calc_hypotenuse()
     </span>
    </code>
    <span class="koboSpan" id="kobo.634.1">
     to get
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.635.1">
      hypotenuse
     </span>
    </code>
    <span class="koboSpan" id="kobo.636.1">
     for
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.637.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.638.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.639.1">
      b
     </span>
    </code>
    <span class="koboSpan" id="kobo.640.1">
     , and then, with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.641.1">
      is_int()
     </span>
    </code>
    <span class="koboSpan" id="kobo.642.1">
     , we check whether it is an integer, which means
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.643.1">
      (a, b, hypotenuse)
     </span>
    </code>
    <span class="koboSpan" id="kobo.644.1">
     is a Pythagorean triple.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.645.1">
     When we profile this script, we get information in a tabular form.
    </span>
    <span class="koboSpan" id="kobo.645.2">
     The columns are
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.646.1">
      ncalls
     </span>
    </code>
    <span class="koboSpan" id="kobo.647.1">
     (the number of calls to the function),
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.648.1">
      tottime
     </span>
    </code>
    <span class="koboSpan" id="kobo.649.1">
     (the total time spent in each function),
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.650.1">
      percall
     </span>
    </code>
    <span class="koboSpan" id="kobo.651.1">
     (the average time spent in each function per call),
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.652.1">
      cumtime
     </span>
    </code>
    <span class="koboSpan" id="kobo.653.1">
     (the cumulative time spent in a function plus all functions it calls),
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.654.1">
      percall
     </span>
    </code>
    <span class="koboSpan" id="kobo.655.1">
     (the average cumulative time spent per call), and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.656.1">
      filename:lineno(function)
     </span>
    </code>
    <span class="koboSpan" id="kobo.657.1">
     .
    </span>
    <span class="koboSpan" id="kobo.657.2">
     Here is the result we got (to save space, we are omitting the two
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.658.1">
      percall
     </span>
    </code>
    <span class="koboSpan" id="kobo.659.1">
     columns):
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.660.1">$ python -m cProfile profiling/triples.py
1502538 function calls in 0.393 seconds
Ordered by: cumulative time
ncalls tottime cumtime filename:lineno(function)
     1   0.000   0.393 {built-in method builtins.exec}
     1   0.000   0.393 triples.py:1(&lt;module&gt;)
     1   0.143   0.393 triples.py:1(calc_triples)
500500   0.087   0.147 triples.py:15(is_int)
500500   0.102   0.102 triples.py:11(calc_hypotenuse)
500500   0.060   0.060 {method 'is_integer' of 'float' objects}
  1034   0.000   0.000 {method 'append' of 'list' objects}
     1   0.000   0.000 {method 'disable' of '_lsprof.Profiler' objects}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.661.1">
     Even with
    </span>
    <a id="_idIndexMarker1027">
    </a>
    <span class="koboSpan" id="kobo.662.1">
     this limited amount of data, we can still infer some useful information about this code.
    </span>
    <span class="koboSpan" id="kobo.662.2">
     First, we can see that the time complexity of the algorithm we have chosen grows with the square of the input size.
    </span>
    <span class="koboSpan" id="kobo.662.3">
     The number of calls to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.663.1">
      calc_hypotenuse()
     </span>
    </code>
    <span class="koboSpan" id="kobo.664.1">
     is exactly
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.665.1">
      mx (mx + 1) / 2
     </span>
    </em>
    <span class="koboSpan" id="kobo.666.1">
     .
    </span>
    <span class="koboSpan" id="kobo.666.2">
     We ran the script with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.667.1">
      mx = 1000,
     </span>
    </code>
    <span class="koboSpan" id="kobo.668.1">
     and we got exactly 500,500 calls.
    </span>
    <span class="koboSpan" id="kobo.668.2">
     Three main things happen inside the loop: we call
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.669.1">
      calc_hypotenuse()
     </span>
    </code>
    <span class="koboSpan" id="kobo.670.1">
     , we call
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.671.1">
      is_int()
     </span>
    </code>
    <span class="koboSpan" id="kobo.672.1">
     , and, if the condition is met, we append it to the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.673.1">
      triples
     </span>
    </code>
    <span class="koboSpan" id="kobo.674.1">
     list.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.675.1">
     Taking a look at the cumulative times in the profiling report, we notice that the program spent 0.147 seconds inside
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.676.1">
      is_int()
     </span>
    </code>
    <span class="koboSpan" id="kobo.677.1">
     , compared to 0.102 seconds spent inside
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.678.1">
      calc_hypotenuse()
     </span>
    </code>
    <span class="koboSpan" id="kobo.679.1">
     .
    </span>
    <span class="koboSpan" id="kobo.679.2">
     These functions were called the same number of times, so our first target for optimization should be the more expensive
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.680.1">
      is_int()
     </span>
    </code>
    <span class="koboSpan" id="kobo.681.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.682.1">
     If we look at the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.683.1">
      tottime
     </span>
    </code>
    <span class="koboSpan" id="kobo.684.1">
     column, we see that the program spent 0.087 seconds
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.685.1">
      in
     </span>
    </code>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.686.1">
      is_int()
     </span>
    </code>
    <span class="koboSpan" id="kobo.687.1">
     .
    </span>
    <span class="koboSpan" id="kobo.687.2">
     This excludes the 0.060 seconds spent in calls from
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.688.1">
      is_int()
     </span>
    </code>
    <span class="koboSpan" id="kobo.689.1">
     to the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.690.1">
      is_integer()
     </span>
    </code>
    <span class="koboSpan" id="kobo.691.1">
     method of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.692.1">
      float
     </span>
    </code>
    <span class="koboSpan" id="kobo.693.1">
     objects.
    </span>
    <span class="koboSpan" id="kobo.693.2">
     However,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.694.1">
      is_int()
     </span>
    </code>
    <span class="koboSpan" id="kobo.695.1">
     does not do anything other than call the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.696.1">
      is_integer()
     </span>
    </code>
    <span class="koboSpan" id="kobo.697.1">
     method of its parameter
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.698.1">
      n
     </span>
    </code>
    <span class="koboSpan" id="kobo.699.1">
     .
    </span>
    <span class="koboSpan" id="kobo.699.2">
     This means that just the additional function call adds an overhead of 87 milliseconds.
    </span>
    <span class="koboSpan" id="kobo.699.3">
     In this program, there is not much benefit to having the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.700.1">
      is_int()
     </span>
    </code>
    <span class="koboSpan" id="kobo.701.1">
     function, so we can gain 87 milliseconds by just calling
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.702.1">
      hypotenuse.is_integer()
     </span>
    </code>
    <span class="koboSpan" id="kobo.703.1">
     directly instead.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.704.1">
     If we rerun the profiling, we see that we now spend more time in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.705.1">
      calc_hypotenuse()
     </span>
    </code>
    <span class="koboSpan" id="kobo.706.1">
     than in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.707.1">
      is_integer()
     </span>
    </code>
    <span class="koboSpan" id="kobo.708.1">
     method.
    </span>
    <span class="koboSpan" id="kobo.708.2">
     Let us see if we can improve that as well.
    </span>
    <span class="koboSpan" id="kobo.708.3">
     As we mentioned in
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.709.1">
      Chapter 5
     </span>
    </em>
    <span class="koboSpan" id="kobo.710.1">
     ,
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.711.1">
      Comprehensions and Generators
     </span>
    </em>
    <span class="koboSpan" id="kobo.712.1">
     , using the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.713.1">
      **
     </span>
    </code>
    <span class="koboSpan" id="kobo.714.1">
     power operator to calculate the square of a number is more expensive than multiplying it by itself.
    </span>
    <span class="koboSpan" id="kobo.714.2">
     With that in mind, we can try to improve performance by changing
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.715.1">
      calc_hypotenuse()
     </span>
    </code>
    <span class="koboSpan" id="kobo.716.1">
     to the following:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.717.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.718.1">calc_hypotenuse</span></span><span class="koboSpan" id="kobo.719.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.720.1">a, b</span></span><span class="koboSpan" id="kobo.721.1">): 
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.722.1">return</span></span><span class="koboSpan" id="kobo.723.1"> (a * a + b * b) ** </span><span class="hljs-number"><span class="koboSpan" id="kobo.724.1">0.5</span></span> 
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.725.1">
     After rerunning the profiling again, we find that the program now spends 0.084 seconds in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.726.1">
      calc_hypotenuse()
     </span>
    </code>
    <span class="koboSpan" id="kobo.727.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.727.2">
     We have gained only 18 milliseconds.
    </span>
    <span class="koboSpan" id="kobo.727.3">
     We could potentially gain more by eliminating the overhead of the call to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.728.1">
      calc_hypotenuse()
     </span>
    </code>
    <span class="koboSpan" id="kobo.729.1">
     and calculating the hypotenuse directly:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.730.1">            hypotenuse = (a * a + b * b) ** </span><span class="hljs-number"><span class="koboSpan" id="kobo.731.1">0.5</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.732.1">
     Profiling this
    </span>
    <a id="_idIndexMarker1028">
    </a>
    <span class="koboSpan" id="kobo.733.1">
     version shows that we can gain up to 100 milliseconds in this way.
    </span>
    <span class="koboSpan" id="kobo.733.2">
     However, we think that, in this case, the benefits of readability, maintainability, and testability that the function gives us outweigh the performance improvement of removing it.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.734.1">
     You will find all four versions of this program in the source code for the book.
    </span>
    <span class="koboSpan" id="kobo.734.2">
     We encourage you to run the profiling yourself and experiment with other changes to the code to see what impact they have on performance (for example, you could try to convert
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.735.1">
      calc_triples()
     </span>
    </code>
    <span class="koboSpan" id="kobo.736.1">
     into a generator function).
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.737.1">
     This example was trivial, of course, but enough to show you how you could profile an application.
    </span>
    <span class="koboSpan" id="kobo.737.2">
     Having the number of calls that are made to a function helps us better understand the time complexity of our algorithms.
    </span>
    <span class="koboSpan" id="kobo.737.3">
     For example, many coders fail to see that those two
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.738.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.739.1">
     loops run proportionally to the square of the input size.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.740.1">
     We have seen profiling of functions, but it is also possible to go to an even higher level of granularity and profile each line of a piece of code, if necessary.
    </span>
    <span class="koboSpan" id="kobo.740.2">
     The average Python programmer will not need to do much profiling in their career, but it might happen, so it is good to know the options we have.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.741.1">
     One thing to mention: the results of profiling will quite likely differ depending on what system you are running on.
    </span>
    <span class="koboSpan" id="kobo.741.2">
     Therefore, it is important to be able to profile software on a system that is as close as possible to the one the software is deployed on, if not actually on it.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.742.1">
      In this section, we have focused on profiling and optimizing the running time of a program.
     </span>
     <span class="koboSpan" id="kobo.742.2">
      Profiling
     </span>
     <a id="_idIndexMarker1029">
     </a>
     <span class="koboSpan" id="kobo.743.1">
      can also be used to analyze and optimize memory usage.
     </span>
     <span class="koboSpan" id="kobo.743.2">
      One of the most popular tools for memory profiling in Python is memray.
     </span>
     <span class="koboSpan" id="kobo.743.3">
      You can read more about it at
     </span>
     <a href="https://bloomberg.github.io/memray/">
      <span class="url">
       <span class="koboSpan" id="kobo.744.1">
        https://bloomberg.github.io/memray/
       </span>
      </span>
     </a>
     <span class="koboSpan" id="kobo.745.1">
      .
     </span>
    </p>
   </div>
   <h2 class="heading-2" id="_idParaDest-298">
    <span class="koboSpan" id="kobo.746.1">
     When to profile
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.747.1">
     It is important to
    </span>
    <a id="_idIndexMarker1030">
    </a>
    <span class="koboSpan" id="kobo.748.1">
     know when it is appropriate to profile, and what to do with the results we get.
    </span>
    <span class="koboSpan" id="kobo.748.2">
     Donald Knuth once said, “
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.749.1">
      Premature optimization is the root of all evil
     </span>
    </em>
    <span class="koboSpan" id="kobo.750.1">
     ,” and, although we wouldn’t have put it quite so strongly, we do agree with him.
    </span>
    <span class="koboSpan" id="kobo.750.2">
     For example, it is seldom worth sacrificing readability or maintainability for the sake of gaining a few milliseconds in speed.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.751.1">
     Your primary concern should always be
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.752.1">
      correctness
     </span>
    </em>
    <span class="koboSpan" id="kobo.753.1">
     .
    </span>
    <span class="koboSpan" id="kobo.753.2">
     You want your code to deliver the correct results, therefore write tests, find edge cases, and stress your code in every way you think makes sense.
    </span>
    <span class="koboSpan" id="kobo.753.3">
     Do not be protective; do not put things in the back of your brain for later because you think they are not likely to happen.
    </span>
    <span class="koboSpan" id="kobo.753.4">
     Be thorough.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.754.1">
     Second, take care of coding
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.755.1">
      best practices
     </span>
    </em>
    <span class="koboSpan" id="kobo.756.1">
     .
    </span>
    <span class="koboSpan" id="kobo.756.2">
     Remember the following: readability, extensibility, loose coupling, modularity, and design.
    </span>
    <span class="koboSpan" id="kobo.756.3">
     Apply OOP principles: encapsulation, abstraction, single responsibility, open/closed, and so on.
    </span>
    <span class="koboSpan" id="kobo.756.4">
     Read up on these concepts.
    </span>
    <span class="koboSpan" id="kobo.756.5">
     They will open horizons for you, and they will expand the way you think about code.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.757.1">
     Third,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.758.1">
      refactor
     </span>
    </em>
    <span class="koboSpan" id="kobo.759.1">
     .
    </span>
    <span class="koboSpan" id="kobo.759.2">
     The Boy Scouts rule says:
    </span>
   </p>
   <blockquote class="packt_quote">
    <p class="quote">
     <span class="koboSpan" id="kobo.760.1">
      Always leave the campground cleaner than you found it.
     </span>
    </p>
   </blockquote>
   <p class="normal">
    <span class="koboSpan" id="kobo.761.1">
     Apply this rule to your code.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.762.1">
     Finally, when all of this has been taken care of, then and only then take care of optimizing and profiling.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.763.1">
     Run your profiler and identify bottlenecks.
    </span>
    <span class="koboSpan" id="kobo.763.2">
     When analyzing the profiling results, focus on the functions that were called the most.
    </span>
    <span class="koboSpan" id="kobo.763.3">
     As we mentioned in
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.764.1">
      Chapter 5
     </span>
    </em>
    <span class="koboSpan" id="kobo.765.1">
     ,
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.766.1">
      Comprehensions and Generators
     </span>
    </em>
    <span class="koboSpan" id="kobo.767.1">
     , you will often gain more from even a small improvement to a function that is called a million times than from trying to improve a function that is only called a few times.
    </span>
    <span class="koboSpan" id="kobo.767.2">
     When you have an idea of the bottlenecks you need to address, start with the worst one first.
    </span>
    <span class="koboSpan" id="kobo.767.3">
     Sometimes, fixing a bottleneck causes a ripple effect that will expand and change the way the rest of the code works.
    </span>
    <span class="koboSpan" id="kobo.767.4">
     Sometimes, this is only a little, and sometimes, it is a bit more, depending on how your code was designed and implemented.
    </span>
    <span class="koboSpan" id="kobo.767.5">
     Therefore, start with the biggest issue first.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.768.1">
     One of the reasons Python is so popular is that it is possible to extend it with modules written in faster, compiled languages like C or C++.
    </span>
    <span class="koboSpan" id="kobo.768.2">
     So, if you have some critical piece of code and you simply cannot achieve the performance you need in pure Python, you always have the option of rewriting part of it in C.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-299">
    <span class="koboSpan" id="kobo.769.1">
     Measuring execution time
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.770.1">
     Before
    </span>
    <a id="_idIndexMarker1031">
    </a>
    <span class="koboSpan" id="kobo.771.1">
     we finish this chapter, we want to briefly touch on the topic of measuring the execution time of code.
    </span>
    <span class="koboSpan" id="kobo.771.2">
     Sometimes, it is helpful to measure the performance of small pieces of code to compare their performance.
    </span>
    <span class="koboSpan" id="kobo.771.3">
     For example, if you have different ways of implementing some operation and you really need the fastest version, you may want to compare their performance without profiling your entire application.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.772.1">
     We have already seen some examples of measuring and comparing execution times earlier in this book, for example, in
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.773.1">
      Chapter 5
     </span>
    </em>
    <span class="koboSpan" id="kobo.774.1">
     ,
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.775.1">
      Comprehensions and Generators
     </span>
    </em>
    <span class="koboSpan" id="kobo.776.1">
     , when we compared the performance of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.777.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.778.1">
     loops, list comprehensions, and the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.779.1">
      map()
     </span>
    </code>
    <span class="koboSpan" id="kobo.780.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.780.2">
     At this point, we would like to introduce you to a better approach, using the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.781.1">
      timeit
     </span>
    </code>
    <span class="koboSpan" id="kobo.782.1">
     module.
    </span>
    <span class="koboSpan" id="kobo.782.2">
     This module uses techniques such as timing many repeated executions of the code to improve measurement accuracy.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.783.1">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.784.1">
      timeit
     </span>
    </code>
    <span class="koboSpan" id="kobo.785.1">
     module can be a bit tricky to use.
    </span>
    <span class="koboSpan" id="kobo.785.2">
     We recommend that you read about it in the official Python documentation and experiment with the examples there until you understand how to use it.
    </span>
    <span class="koboSpan" id="kobo.785.3">
     Here, we will just give a brief demonstration of using the command-line interface to time our two different versions of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.786.1">
      calc_hypotenuse()
     </span>
    </code>
    <span class="koboSpan" id="kobo.787.1">
     from the previous example:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.788.1">$ python -m timeit -s 'a=2; b=3' '(a**2 + b**2) ** .5'
5000000 loops, best of 5: 91 nsec per loop
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.789.1">
     Here, we are running the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.790.1">
      timeit
     </span>
    </code>
    <span class="koboSpan" id="kobo.791.1">
     module, initializing variables
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.792.1">
      a = 2
     </span>
    </code>
    <span class="koboSpan" id="kobo.793.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.794.1">
      b = 3
     </span>
    </code>
    <span class="koboSpan" id="kobo.795.1">
     , before timing the execution of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.796.1">
      (a**2 + b**2) ** .5
     </span>
    </code>
    <span class="koboSpan" id="kobo.797.1">
     .
    </span>
    <span class="koboSpan" id="kobo.797.2">
     In the output, we can see that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.798.1">
      timeit
     </span>
    </code>
    <span class="koboSpan" id="kobo.799.1">
     ran 5 repetitions timing 5,000,000 loop iterations executing our calculation.
    </span>
    <span class="koboSpan" id="kobo.799.2">
     Out of those 5 repetitions, the best average execution time over 5,000,000 iterations was 91 nanoseconds.
    </span>
    <span class="koboSpan" id="kobo.799.3">
     Let us see how the alternative calculation,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.800.1">
      (a*a + b*b) ** .5
     </span>
    </code>
    <span class="koboSpan" id="kobo.801.1">
     , performs:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.802.1">$ python -m timeit -s 'a=2; b=3' '(a*a + b*b) ** .5'
5000000 loops, best of 5: 72.8 nsec per loop
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.803.1">
     This time, we get an average of 72.8 nanoseconds per loop.
    </span>
    <span class="koboSpan" id="kobo.803.2">
     This confirms again that the second version is slightly faster.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.804.1">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.805.1">
      timeit
     </span>
    </code>
    <span class="koboSpan" id="kobo.806.1">
     module automatically chooses the number of iterations to ensure the total running time is at least 0.2 seconds.
    </span>
    <span class="koboSpan" id="kobo.806.2">
     This helps to improve accuracy by reducing the relative impact of measurement overhead.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.807.1">
      For further information
     </span>
     <a id="_idIndexMarker1032">
     </a>
     <span class="koboSpan" id="kobo.808.1">
      about measuring Python performance, make sure you check out
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.809.1">
       pyperf
      </span>
     </code>
     <span class="koboSpan" id="kobo.810.1">
      (
     </span>
     <a href="https://github.com/psf/pyperf">
      <span class="url">
       <span class="koboSpan" id="kobo.811.1">
        https://github.com/psf/pyperf
       </span>
      </span>
     </a>
     <span class="koboSpan" id="kobo.812.1">
      ) and
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.813.1">
       pyperformance
      </span>
     </code>
     <span class="koboSpan" id="kobo.814.1">
      (
     </span>
     <a href="https://github.com/python/pyperformance">
      <span class="url">
       <span class="koboSpan" id="kobo.815.1">
        https://github.com/python/pyperformance
       </span>
      </span>
     </a>
     <span class="koboSpan" id="kobo.816.1">
      ).
     </span>
    </p>
   </div>
   <h1 class="heading-1" id="_idParaDest-300">
    <span class="koboSpan" id="kobo.817.1">
     Summary
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.818.1">
     In this short chapter, we looked at different techniques and suggestions for debugging, troubleshooting, and profiling our code.
    </span>
    <span class="koboSpan" id="kobo.818.2">
     Debugging is an activity that is always part of a software developer’s work, so it is important to be good at it.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.819.1">
     If approached with the correct attitude, it can be fun and rewarding.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.820.1">
     We explored techniques to inspect our code using custom functions, logging, debuggers, traceback information, profiling, and assertions.
    </span>
    <span class="koboSpan" id="kobo.820.2">
     We saw simple examples of most of them.
    </span>
    <span class="koboSpan" id="kobo.820.3">
     We also discussed some guidelines that will help when it comes to facing the fire.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.821.1">
     Remember always to
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.822.1">
      stay calm and focused
     </span>
    </em>
    <span class="koboSpan" id="kobo.823.1">
     , and debugging will be much easier.
    </span>
    <span class="koboSpan" id="kobo.823.2">
     This, too, is a skill that needs to be learned and it is the most important.
    </span>
    <span class="koboSpan" id="kobo.823.3">
     An agitated and stressed mind cannot work properly, logically, and creatively.
    </span>
    <span class="koboSpan" id="kobo.823.4">
     Therefore, if you do not strengthen it, it will be difficult for you to put all your knowledge to good use.
    </span>
    <span class="koboSpan" id="kobo.823.5">
     So, when facing a difficult bug, if you have the opportunity, make sure you go for a short walk or take a power nap—relax.
    </span>
    <span class="koboSpan" id="kobo.823.6">
     Often, the solution presents itself after a good break.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.824.1">
     In the next chapter, we are going to explore type hinting and the use of static type checkers, which can be useful for reducing the likelihood of certain types of bugs.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-301">
    <span class="koboSpan" id="kobo.825.1">
     Join our community on Discord
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.826.1">
     Join our community’s Discord space for discussions with the authors and other readers:
    </span>
   </p>
   <p class="normal">
    <a href="Chapter_11.xhtml">
     <span class="url">
      <span class="koboSpan" id="kobo.827.1">
       https://discord.com/invite/uaKmaz7FEC
      </span>
     </span>
    </a>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.828.1">
     <img alt="img" src="../Images/QR_Code119001106417026468.png"/>
    </span>
   </p>
  </div>
 </body></html>