- en: Advanced RESTful API Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every software designer agrees that design patterns, and solving familiar yet
    recurring design problems by implementing design patterns, are inevitable in the
    modern software design-and-development life cycle. In general, there are various
    API design patterns, and in our earlier chapter, we covered a few fundamental
    RESTful API patterns. We'll delve into few advanced API design patterns in this
    chapter, as those patterns are necessary for real-time RESTful services and what
    the software industry needed at this moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is part two of API design patterns; the intention is to cover
    a number of advanced design patterns, such as versioning, and backend for frontend.
    Once readers have gone through this chapter, they should know how to implement
    the following patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uniform contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entity endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Endpoint redirection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Idempotent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bulk operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breaker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API facade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backend for frontend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please don't forget to go through the Investor Service code examples and learn
    the advance pattern implementations as well.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As this chapter deals with advanced patterns, we expect that readers have knowledge
    of a few basic software design patterns and practices, Java's programming ability,Spring
    framework, and RESTful services.
  prefs: []
  type: TYPE_NORMAL
- en: To run this chapter's sample code, please refer to [Chapter 3,](bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml)
    *Essential RESTful API Patterns, *for the additional technical requirement and
    information on how to run the sample codes provided here.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful API advanced patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered few critical RESTful patterns in the earlier chapter; now it's time
    to get into more advanced patterns and get our hands dirty to provide our customers
    and app developers with the best-possible RESTful services implementation. Let's
    start learning how to implement versioning for our services.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many books and articles recommend avoiding versioning APIs if possible. However,
    it's not practical to believe that we'll develop one API that caters to almost
    every requirement within the first release and never changes, so we avoid versioning
    altogether. A few others recommend providing different URIs for different (major)
    version changes. Ideally, we'd manage APIs just like website URLs (most of the
    time the URL address never changes, regardless of any changes/implementations).
  prefs: []
  type: TYPE_NORMAL
- en: 'The general rules of thumb we''d like to follow when versioning APIs are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Upgrade the API to a new major version when the new implementation breaks the
    existing customer implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrade the API to a new minor version of the API when the new implementation
    provides enhancements and bug fixes; however, ensure that the implementation takes
    care of backward-compatibility and has no impact on the existing customer implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's consider that we need to manage the versions in our API; there are four
    different ways that we can implement the versioning, and we will see each type
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning through the URI path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The major and minor version changes can be a part of the URI, for example, to
    represent `v1` or `v2` of the API the URI can be `http://localhost:9090/v1/investors` or `http://localhost:9090/v2/investors`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code implementation of the URI path versioning within our investor service
    examples is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef8d6d77-07f1-4b04-89b8-4338b44fed22.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the Postman execution of the URI path-versioning
    example.
  prefs: []
  type: TYPE_NORMAL
- en: URI path changes according to the version violates the RESTful principles of
    URI and its resource representation (two different URIs represent the same resources—the
    only difference is `v1`, `v2`, and so on, in our example). However, URI path versioning
    is a popular way of managing API versions due to its simple implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning through query parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The other simple method for implementing the version reference is to make it
    part of the request parameters, as we see in the following examples—`http://localhost:9090/investors?version=1`,` http://localhost:9090/investors?version=2.1.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58f88ef3-5e1c-4134-80b5-ae18620aeab4.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the implementation of versioning through parameters
    within our sample.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning through custom headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Define a new header that contains the version number in the request as part
    of request header itself. A custom header allows the client to maintain the same
    URIs, regardless of any version upgrades. This implementation is the kind of content-negotiation
    that we saw in [Chapter 2](edae86df-d90e-4b4c-9ada-4de80edaef71.xhtml), *Design
    Strategy, Guidelines, and Best Practices* and we''ll see it in the next section
    as well. The following code snippet will help us understand the version implementation
    through a custom header named `x-resource-version`. Please note that the custom
    header name can be any name; in our example, we name it `x-resource-version`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/739fc842-0022-4445-b372-e02e5bf7d622.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot is an example of versioning through the `x-resource-version` custom
    header and executing the same code example with postman.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning through content-negotiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Providing the version information through the Accept (request) header along
    with the content-type (media) in response is the preferred way as this helps to
    version APIs without any impact on the URI. As we''ve already learned about content-negotiation,
    in [Chapter 2](edae86df-d90e-4b4c-9ada-4de80edaef71.xhtml), *Design Strategy,
    Guidelines, and Best Practices*, let''s jump to a code implementation of versioning
    through Accept and Content-Type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a61c3d39-725e-4418-a1bc-64ee56ea21ef.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot of the postman tool depicts the execution of our investor
    service app versioning through the Accept header. Please observe the response
    header content-type as well.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, each type of versioning methodology has advantages and disadvantages,
    so we need to determine the right approach on a case-by-case basis. However, the
    content-negotiation and custom headers are a proponent of RESTful-compliant services.
    We will move on to one of the essential pattern authentication and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've built a sample application investor service with various incorporated
    patterns. Now, how do we ensure our REST API implementation is accessible only
    to genuine users and not to everyone? In our example, the investor's list should
    not be visible to all users, and the stocks URI should not be exposed to anyone
    other than the legitimate investor. Here comes the Authorization header to help
    us out. We'll use a scheme called **basic authentication** as it solves our current
    requirement. Please note that there are different schemes, such as basic authentication,
    **hash-based message authentication** (**HMAC**), **JSON Web Token** (**JWT**),
    and OAuth 2.0 bearer authentication token scheme, that are available to secure
    the REST APIs. However, for this section, we are implementing simple basic authentication
    through the authorization header, and we'll cover OAuth 2.0 in detail in [Chapter
    6](adb6e30f-4e7f-49d7-bf62-7dddebd4afc5.xhtml), *RESTful Services API Testing
    and Security*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with a simple overview of basic authentication. It's a standard
    HTTP header (RESTful API constraint compliant) with the user's credentials encoded
    in Base64\. The credentials (username and password) are encoded in the format
    of username—password. Please note that the credentials are encoded not encrypted,
    and it's vulnerable to specific security attacks, so it's inevitable that the
    rest API implementing basic authentication will communicate over SSL (https).
  prefs: []
  type: TYPE_NORMAL
- en: We will also need to understand authentication versus authorization. The authentication
    verifies who (user) is accessing the APIs, and authorization is whether the accessing
    user has privileges or is authorized to access the API resources. Admin users
    of our investor service example are authorized to see all the investors, and individual
    users aren't authorized to see other investors' information.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring security framework provides an out-of-the-box security implementation,
    and we'll use Spring-provided functionalities to secure our API. As we are going
    to discuss more security implementations in [Chapter 9](5f63aa25-ec1b-41a2-afef-4c4ab7ab1cfd.xhtml),
    *A More In-depth View of the RESTful Services Paradigm*, we'll stick to a basic
    authentication implementation in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization with the default key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Securing the REST API with basic authentication is exceptionally simplified
    by the Spring security framework. Merely adding the following entries in `pom.xml` provides
    basic authentication to our investor service app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now rebuild (`mvn clean package`) the application and restart it. It''s time
    to test our APIs with the postman tool. When we hit the URL, unlike our earlier
    examples, we''ll see an error complaining `Full authorization required to access
    this resource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae6b7bf4-3260-405a-b013-faa999ef1472.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding error is due to the addition of spring-security into our `pom.xml`
    file. How are we going to access our REST API now? Don''t worry, on the console
    where we started our app, we can observe a text using the default security password
    or search for it in our log file. That''s the key for anyone to access our API.
    The following screenshot shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eddef983-d7e3-4657-9bf5-4f9ad082fff9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we see in the preceding screenshot, our console displays the password that
    we can use to access our API, and so let''s use it for the same URL that we have
    got error earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24c652c5-e03d-4861-ba6d-33b5c3a2615b.png)'
  prefs: []
  type: TYPE_IMG
- en: As we observe in the previous screenshot, we need to provide BasicAuth as the Authorization
    header for the API that we are accessing; we will see the results now without
    any authentication errors. Please note that the Authorization header that carries
    the `XYZKL...` token prefixed with `Basic`, as we use the HTTP Authentication
    header to enforce REST API authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization with credentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many real-time situations, we need to use specific credentials to access
    the API and not the default one; in such cases, we can enhance our investor service
    application and secure it with our custom credentials by using few additional
    out-of-the-box spring modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our investor service, we will have a new class, called `PatronAuthConfig.java`,
    which helps the app to enforce the credentials to the URLs that we would like
    to secure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As we see in the preceding code block, with a few annotations, we can implement
    the security. The following code snippet shows an override method implementation
    as well as a few lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code does the magic of forcing authorization headers to validate
    for credentials in each request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that our example uses the following username and password along
    with two roles. We''ve provided the sample execution script and postman scripts
    to execute various scenarios by just clicking the labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **User Id** | **Password** | **Role** |'
  prefs: []
  type: TYPE_TB
- en: '| `admin` | `admSecret` | `ADMIN` |'
  prefs: []
  type: TYPE_TB
- en: '| `user` | `usrSecret` | `USER` |'
  prefs: []
  type: TYPE_TB
- en: 'Now, please observe the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f28eb49c-7bac-49da-8ab8-4640c0e03b51.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot depicts a sample run of one rest API call that needs
    admin credentials as the authentication header and shows result for valid credentials.
    On the left-hand side, we can see various test cases; each one has the necessary
    prerequisites. Now we need to run them one by one and observe the results of each
    case. Ensure to see the authentication headers as well for each execution.
  prefs: []
  type: TYPE_NORMAL
- en: The only difference between the investor services example in [Chapter 3](bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml),
    *Essential RESTful API Patterns,* and this authentication example is that we have
    added a new class, `PatronsAuthConfig.java`, that extends the configuration for
    authentication with the Authorization header implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Uniform contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned earlier in the *API versioning* section, services will always
    evolve with additional capabilities, enhancements, and defects fixes, however,
    now a service consumer can consume the latest version of our services without
    the need to keep changing their implementation or REST API endpoints. Also, the
    service consumer needs to be aware of the latest and evolving details of those
    service contracts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The uniform contract pattern comes to the rescue to overcome these problems.
    The pattern suggests the following measures:'
  prefs: []
  type: TYPE_NORMAL
- en: Standardize the service contract and make it uniform across any service endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract the service endpoints from individual services capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follow the REST principles where the endpoints use only HTTP verbs, and express
    the underlying resources executable actions only with HTTP verbs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please refer to the API versioning examples in the *API versioning* section
    as the implementation is already available and it has the flavor (please refer
    our investor service examples with `GET`, `POST`, `DELETE`, and so on) of the
    uniform contract.
  prefs: []
  type: TYPE_NORMAL
- en: Entity endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If service clients want to interact with entities, such as investors, and their
    stocks without needing them to manage a compound identifier for both investor
    and stock, we need a pattern called **entity endpoint**. Entity endpoints suggest
    exposing each entity as individual lightweight endpoints of the service they reside
    in, so the service consumers get the global addressability of service entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e14e1db2-4090-4592-800a-7ee0dcef4368.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot illustrates how a service consumer can access individual
    entity endpoints instead of service endpoints. The entity endpoints expose reusable
    enterprise resources, so service consumers can reuse and share the entity resources.
  prefs: []
  type: TYPE_NORMAL
- en: Our rest service, the investor service, exposes a couple of entity endpoints,
    such as `/investors/investorId`, and `investor/stockId` , and they are few examples
    of entity endpoints that our service consumer can reuse and standardize.
  prefs: []
  type: TYPE_NORMAL
- en: Endpoint redirection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Changing service endpoints isn''t always ideal, However, if it needs to, will
    the service client know about it and use the new endpoint? Yes, with standard
    HTTP return codes, `3xx`, and with the **Location** header, then by receiving
    `301 Moved permanently` or `307 Temporary Redirect`, the service client can act
    accordingly. The endpoint redirection pattern suggests returning standard HTTP
    headers and provides an automatic reference of stale endpoints to the current
    endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5eeeb69-01ff-4962-9994-e0ab4bd7f7b7.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the service consumers may call the new endpoints that are found
    in the **Location** header.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to our investor service example for header implementations if you
    want to play around with 3xx codes and **Location** headers.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that with the HATEOAS implementation at the services, the client
    could potentially avoid these endpoint redirections.
  prefs: []
  type: TYPE_NORMAL
- en: Idempotent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine a bank's debit API failed immediately after deducting some amount from
    the client account. However, the client doesn't know about it (as it didn't get
    any response from the server) and reissues the call to debit! Alas, the client
    loses money. So how can a service implementation handle messages/data and produce
    the same results, even after multiple calls?
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary meaning of idempotent is *representing an element of a set that
    is untouched when it involves some operations or is otherwise operated on by itself.*
  prefs: []
  type: TYPE_NORMAL
- en: '**Idempotent** is one of the fundamental resilience and scalable patterns,
    as it decouples the service implementation nodes across distributed systems. Whether
    dealing with data or messages, the services should always have designed for sticking
    to Idempotent in nature.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a simple solution: use the idempotent capabilities of the HTTP web
    APIs, whereby services can provide a guarantee that any number of repeated calls
    due to intermittent failures of communication to the service is safe, and process
    those multiple calls from the server without any side effects.'
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to [Chapter 3](bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml), *Essential
    RESTful API Patterns*, for examples of `DELETE`, `PUT`, and `PATCH`, as those
    are all typical implementation of idempotent services; that is, even after we
    call `DELETE` multiple times for the same stock, it's safe; and the same applies
    to  `PUT` as well.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to dealing with concurrency, the services can be enhanced with
    E-Tag and send back a `409` conflict response to inform the client that the resource called
    is in an inconsistent state.
  prefs: []
  type: TYPE_NORMAL
- en: Bulk operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen many REST API patterns and their implementations. However, we have
    yet to discuss an essential pattern, called **bulk operations**, within the REST
    API. It's inevitable that our design should thrive, which will reduce performance
    bottlenecks, such as response time, and the number of round trips between the
    server and clients.
  prefs: []
  type: TYPE_NORMAL
- en: Marking a list of emails as read in our email client could be an example of
    a bulk operation; the customer chooses more than one email to tag as `Read`, and
    one REST API call does the job instead of multiple calls to an underlying API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take our investor service API: if a client wants to create a set of
    stocks for their portfolio rather than one by one, the client needs to call our
    REST endpoint as many times as the number of stocks that they wanted to create.
    If they need to update 100 stocks, they need to call the endpoint 100 times, and
    indeed, it isn''t an elegant solution. The bulk operations pattern comes to the
    rescue in such scenarios, without compromising the REST principles. Let''s see
    how our investor services can be modified to provide bulk operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The investor service accepts `PATCH` for a single element, and we need to think
    about enhancing the same resource to also accept multiple insertions, or we can
    have another separate URI to support a bulk operation. Having another URI for
    the same resource isn''t a clean approach as it may deviate from the RESTful principle,
    and so let''s move ahead with the same `PATCH` request to support the update of
    more than one stock through the request. The following two approaches are suggested
    for implementing bulk operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Content-based bulk operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom-header action-identifier-based bulk operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our code example follows both approaches; please note that we don''t use any
    specifics of the framework-provided annotations for the bulk operation. However,
    we continue to use the custom header and the enhanced request body to support
    a list of stocks in the client request. The following screenshot depicts the difference
    in the requests for a non-bulk operation and bulk-operation patch request along
    with headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4534b4fa-69fc-4f8b-b2be-7ffa7fc10b99.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code snippet from the `InvestorController` class enforces the
    custom header, and the list of the `Stock` object, unlike the `PUT` example in [Chapter
    3](bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml), *Essential RESTful API Patterns*, (accepts
    only one `Stock` object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: By running our `PATCH` example, we can understand the bulk operations of the
    RESTful API by grouping multiple items in one request. Please note that the bulk
    operations may involve many other aspects, such as E-tag, asynchronous executions,
    or parallel-stream implementation to make it effective. However, we aren't covering
    these special topics here, and we encourage readers to refer to the *Sources,
    references, and further reading *section for resources.
  prefs: []
  type: TYPE_NORMAL
- en: Bulk operations versus batch operations
  prefs: []
  type: TYPE_NORMAL
- en: Bulk operations deal with a single target operation on a varied list of business
    objects within a single REQ, and batch operations (not covered in this chapter)
    deal with a heterogeneous and homogeneous list of business objects, but with multiple
    REQs.
  prefs: []
  type: TYPE_NORMAL
- en: Circuit breaker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We regularly encounter circuit breakers; the circuit breaker is an automatic
    switch designed to protect entire electrical circuits from damage due to excess
    current load as a result of a short circuit or overload.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same concept applies when services interact with many other services. Failure
    due to any (network) issue can potentially create catastrophic effects across
    the application, and preventing cascading impacts is the sole aim of a circuit-breaker
    pattern. Hence, this pattern helps subsystems to fail gracefully and also prevents
    complete system failure as a result of a subsystem failures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b70fe87f-468c-4e3e-baa7-dc0909f91f82.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot illustrates the circuit-breaker concept in which one
    of the downstream services is non-communicable. However, the circuit breaker implementation
    handles it in such a way that the **API** continues to serve its multiple clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we delve into the implementation, let''s understand the three different
    states that constitute the circuit breaker:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Closed**: This is when all the service interconnections are intact (closed),
    and all the calls go through intended services. This state needs to keep track
    of failures to determine threshold limits. If the number of failures exceeds threshold
    limits, the services will move to the open state to avoid cascading impacts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open**: The open state of the services is responsible for returning errors
    without really executing their intended functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Half-open**: Once the services land in the open state, it should periodically
    (timeout) check for failures that made the services be in the open state. Moreover,
    if those failures are still occuring, it continues to keep the services in the
    open state until the next check. If the failures are no longer detected, the responsibility
    of this state is to trigger back to the closed state for the continuous function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's time to get our hands dirty with the circuit-breaker implementation. We'll
    use spring annotations, along with an incredibly dominant open source library
    called **hysterix**, and we can implement the entire concept with very little
    effort.
  prefs: []
  type: TYPE_NORMAL
- en: We need to have a minimum of two services to explain the circuit-breaker implementation,
    so we are creating circuit-breaker-service and circuit-breaker-consumer services,
    which will have the circuit-breaker pattern implemented. The following sections
    elucidate the investor services implementation of circuit-breaker.
  prefs: []
  type: TYPE_NORMAL
- en: Bring up any service that we've already developed, or, to simplify we have a
    lightweight service called **circuit-breaker-service**, and please note that this
    service doesn't have any specific implementation for circuit-breaker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the critical part of our implementation; that is, a new service called
    **circuit-breaker-service-consumer**, which will have all the necessary circuit-breaker
    implementations, along with a call to our first service (circuit-breaker-service).
    Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the hysterix dependency to our `pom.xml` (`circuit-breaker-service-consumer/pom.xml`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Annotate `InvestorController` to enable circuit-breaker and introduce a new
    method for us to test (`circuit-breaker-service-consumer/com/**/InvestorController.java`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the *Hystrix* command and create a method for the circuit-breaker implementation
    as well as a fallback method, as can be seen in the following code block. We will
    have two methods: one for the actual call (`InvestorService.java/circuitBreakerImplWelcome`)
    and another for fallback (`InvestoreService.java/welcomeUrlFailureFallback`),
    so that in case there are failures with the actual call, the app will call the
    fallback method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Cool, isn''t it! Implementing the circuit-breaker with *Hysterix* is that simple.
    Now, let''s build and run our services by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a terminal and build circuit-breaker-service (`mvn clean package` of circuit-breaker-service)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bring up circuit-breaker-service
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a new terminal and build circuit-breaker-service-consumer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bring up circuit-breaker-service-consumer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open Postman and run `http://localhost:9090/welcome`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Observe the Japanese welcome text
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, execute the circuit-breaker experimentation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop the circuit-breaker-service that we started in step 2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run step 5 again, and now observe the English message
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, the circuit-breaker fallback is activated, and so we see the English message,
    not the Japanese message, as the circuit-breaker-service is down. However, the
    `/welcome` URI didn't break.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot captured various phases for verifying the circuit-breaker
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6f18627-1693-4a6f-bfe1-e791d4a460b4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot is another phase of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cd57a68-7473-4762-8fc1-2b273d4f9671.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can observe in the preceding screenshots, in the pre-implementation of
    circuit-breaker, the `/welcome` call is failing and shows console message connection
    errors as well. However, after we implement circuit-breaker, the same call shows
    the content from the fallback method, even though the connections with the circuit-breaker-service
    are still failing.
  prefs: []
  type: TYPE_NORMAL
- en: Readers and designers are encouraged to test and enhance circuit-breaker-consumer
    with more fallback methods for other method calls as well.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of the circuit-breaker pattern is that the applications/services
    involved may experience slight performance hits. However, it's a good trade-off
    for many real-world applications.
  prefs: []
  type: TYPE_NORMAL
- en: Combining the circuit pattern and the retry pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As software designers, we understand the importance of gracefully handling application
    failures and failure operations. We may achieve better results by combining the
    retry pattern and the circuit breaker pattern as it provides the application with
    greater flexibility in handling failures.
  prefs: []
  type: TYPE_NORMAL
- en: The retry patterns enable the application to retry failed operations, expecting
    those operations to become operational and eventually succeed. However, it may
    result in a **denial of service** (**DoS**) attack within our application. The
    circuit-breaker pattern prevents an application from performing an operation that's
    likely to fail. How about an intelligent retry mechanism that's sensitive to any
    failures returned by the circuit breaker that indicates no transient failures,
    and so the application abandons any further retry attempts?
  prefs: []
  type: TYPE_NORMAL
- en: API facade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We knew the pattern called **facade** from GoF, which abstracts the complex
    subsystem from the callers and exposes only necessary details as interfaces to
    the end user. API facade' is also aligned with the same definitions and implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following diagram, which depicts a simple implementation
    of multiple service calls from a client with and without the API facade pattern
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb797c53-fd6f-4a9c-ba89-3ff368e9431d.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding diagram, the client is calling one API facade
    to make it simpler and more meaningful in cases where the clients need multiple
    service calls. However, that can be implemented with a single API endpoint instead
    of the client calling multiple endpoints. The API facades provide high scalability
    and high performance as well.
  prefs: []
  type: TYPE_NORMAL
- en: Our investor services have implemented a simple API facade implementation for
    its delete operations. As we saw earlier, the delete methods call the design for
    intent methods. However, we have made the *design for the intent* method abstract
    to the caller by introducing a simple interface to our investor services. That
    brings the facade to our API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface for the delete service is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation for the delete service interface is shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As a simple exercise, we encourage the reader to implement our circuit breaker
    service call as an API facade and to also complete the bulk delete method within
    the delete service.
  prefs: []
  type: TYPE_NORMAL
- en: Backend for frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have developed various restful service APIs and endpoints so that
    any app developer can start to use it. However, we need to ensure those services
    will cater to various types of devices, since its real purpose is to serve any
    customer using any device, and not only for desktop users or as web-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: Providing a better user experience across any device is vital, regardless of
    its backend services, and having figured out all possible best practices of developing
    RESTful services become meaningless if we aren't providing a better mechanism
    to use those services by heterogeneous end users and to their devices.
  prefs: []
  type: TYPE_NORMAL
- en: '**Backend for frontend** (**BFF**) is a pattern first described by Sam Newman;
    it helps to bridge any API design gaps. BFF suggests introducing a layer between
    the user experience and the resources it calls. It also helps API designers to
    avoid customizing a single backend (services) for multiple interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d474933-241c-44be-9196-14c92592d5c8.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram depicts a simple implementation of the BFF pattern in
    the form of exclusive interfaces for both desktop and mobile devices. Each interface
    can define its necessary and unique requirements that cater to frontend requirements
    without worrying about impacting other frontend implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine a number of specific requirements of each interface so that
    we understand why we need to have multiple interfaces for the same backend services:'
  prefs: []
  type: TYPE_NORMAL
- en: Response payload formatting and size may differ for each client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance bottlenecks and optimization requirements due to the number of calls
    to be made to services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When in need of shared or general purpose backend services, but with less development
    and maintenance overhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BFF may not fit in cases such as multiple interfaces making the same requests
    to the backend, or using only one interface to interact with the backend services.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that there are drawbacks with BFF, and exercise caution when deciding
    on separate, exclusive APIs/interfaces, as it warrants additional and lifelong
    maintenance, security improvement within layers, additional customized designs
    that lead to lapses in security, and defect leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning the patterns with a few code examples always provides us with great
    insights. In this chapter, we discussed versioning our APIs, securing APIs with
    authorization, and enabling the service clients with uniform contract, entity
    endpoint, and endpoint redirection implementations. We also learned about Idempotent
    and its importance, which powers APIs with bulk operations. The most important
    part of this chapter is the circuit-breaker implementation with *Hysterix*, where
    we envisioned and implemented the resiliency patterns of API designs.
  prefs: []
  type: TYPE_NORMAL
- en: Having covered various advanced patterns, we concluded the chapter with the
    BFF pattern, and we learned how it reduces churns within the cross-implementation
    team by helping them to develop an exclusive interface for target environments.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover RESTful API gateways, which should be an equally
    exciting read for API designers.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RESTful Java Patterns and Best Practices: [https://www.packtpub.com/application-development/restful-java-patterns-and-best-practices](https://www.packtpub.com/application-development/restful-java-patterns-and-best-practices)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
