<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-42" class="chapter-number" lang="en-GB"><a id="_idTextAnchor042"/>3</h1>&#13;
			<h1 id="_idParaDest-43" lang="en-GB"><a id="_idTextAnchor043"/>Data Flow in a Computer</h1>&#13;
			<p lang="en-GB">In this chapter, we will learn how a computer executes an instruction. We have to understand how a computer operates internally before we can simulate its behavior in Python. We will also introduce the concept of a computer instruction (the smallest operation that it can be commanded to perform) and show you what a computer instruction looks like.</p>&#13;
			<p lang="en-GB">What is a computer? How does it work? What does it do? We will answer these questions by demonstrating how a computer can be designed using Python, and how programs can be run on this simulated computer. Here, we are interested only in how a computer behaves at the machine level – that is, the type of operations it carries out. We are not concerned with the internal design of the computer or how the computer is implemented electronically (i.e., the circuits used to build a computer).</p>&#13;
			<p lang="en-GB">We will cover the following topics in this chapter:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">The instruction set architecture (ISA)</li>&#13;
				<li lang="en-GB">The Von Neumann architecture</li>&#13;
				<li lang="en-GB">An assembly-level program</li>&#13;
				<li lang="en-GB">The machine-level instruction</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-44" lang="en-GB"><a id="_idTextAnchor044"/>Technical requirements</h1>&#13;
			<p lang="en-GB">You can find the programs used in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter03">https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter03</a>.</p>&#13;
			<h1 id="_idParaDest-45" lang="en-GB"><a id="_idTextAnchor045"/>The Instruction Architecture Level (ISA)</h1>&#13;
			<p lang="en-GB">In this section, we will show how a <a id="_idIndexMarker103"/><a id="_idIndexMarker104"/>computer can be described in different ways and explain that this book is about computers from the point of view of their instruction sets and capabilities.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The term <em class="italic">computer</em> means different things to different people. To an engineer, a computer is a collection of circuits that perform a certain function; to a pilot, it’s a machine that flies an aircraft from one airport to another and can land it in thick fog.</p>&#13;
			<p lang="en-GB"><em class="italic">Table 3.1</em> demonstrates the hierarchy of computer languages and structures. At the top you have the actual application for which the computer is used. At this level, the application may be a user-selected program (flight simulator), or it may be a program that runs on an embedded system (e.g., an ATM). Communication with that application is universal and independent of the actual computer on which the application runs.</p>&#13;
			<table id="table001-2" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="bold">Level</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="bold">Realization</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="bold">Universality</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">1. Application</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">Word, Excel, Photoshop, and flight sim</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">Universal</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">2. High-level language</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">Python, Java, C++</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">Universal</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB">3. Assembly language</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB">ADD r1,r2, and r3</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB">Computer family</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB">4. Binary (machine code)</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>00111010111100001010101110001010</code> binary</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB">Computer family</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-1" lang="en-GB">5. Circuit (microprocessor)</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-1" lang="en-GB">Gates, adders, counters, and memory</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-1" lang="en-GB">Specific family member</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-1" lang="en-GB">6. Silicon</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-1" lang="en-GB">The physical silicon chip</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-1" lang="en-GB">Specific chip</p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.1 – The hierarchy of computer languages and systems</p>&#13;
			<p lang="en-GB">Below the application level, you <a id="_idIndexMarker105"/><a id="_idIndexMarker106"/>have the high-level language used to build the application. This language may be Python, Java, C++, and so on. High-level languages were designed to enable programmers to build applications that run on different types of computers. For example, a program written in Python will run on any machine for which a Python interpreter or compiler is available. Before the introduction of high-level languages, you had to design the application for each specific computer.</p>&#13;
			<p lang="en-GB">Most computers are currently unable to directly execute high-level languages. Each computer has a native language that is understood by a computer family (e.g., Intel Core, Motorola 68K, ARMv4, and MIPS). These languages are related to the structure of the computer and its hardware, which is expressed by a computer’s ISA. This level is represented by two layers in <em class="italic">Table 3.1</em>, <em class="italic">assembly language and </em><em class="italic">machine code</em>.</p>&#13;
			<p lang="en-GB">The layer below the high-level language is the assembly language level, which is a human representation of the computer’s binary machine code. People can’t remember or easily manipulate strings of 1s and 0s. Assembly language is a textual version of machine code. For example, the assembly language operation <code>ADD </code>A<code>,B,C</code> means add <code>B</code> to <code>C</code> and put the result in <code>A (i.e., A = B + C)</code> and might be represented in machine code as <code>00110101011100111100001010101010</code>.</p>&#13;
			<p lang="en-GB">The <em class="italic">machine code</em> layer is the binary code that the computer actually executes. In the PC world, a machine-code program has the <code>.exe</code> file extension because it can be <em class="italic">executed</em> by the computer. All computers execute binary code, although this layer is different for each type of computer – for example, Intel Core, ARM, and MIPS are three computer families, and each has its own machine code.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Although the assembly language layer is a representation of the machine code layer, there is a difference between these two layers. The assembly language layer includes facilities to help a programmer write programs, such as the ability to define variable names and to link independently written modules into a single machine-code program.</p>&#13;
			<p lang="en-GB">Below the machine-code layer are the electronic circuits, which are generically called microprocessors, or just chips. This is the hardware that companies such as Intel make, and it’s this hardware that reads programs from memory and executes them. In general, this layer cannot be programmed or modified any more than you can change the number of cylinders in your car’s engine.</p>&#13;
			<p lang="en-GB">Today, some digital systems do have circuits that can be modified electronically – that is, it is possible for the circuits of a computer to be restructured by changing the routing of signals through a circuit called a <strong class="bold">field programmable gate array (FPGA)</strong>. The FPGA <a id="_idIndexMarker107"/>contains a very large number of gates and special-purpose circuit blocks that can be interconnected by programming. An FPGA can be programmed to perform dedicated applications such as signal processing in medical or aerospace systems.</p>&#13;
			<p lang="en-GB">At the electronic circuit<a id="_idIndexMarker108"/><a id="_idIndexMarker109"/> level, it’s possible to have different versions of the same set of circuits. For example, a microprocessor can be realized using 7 nm or 14 nm device technology (these figures express the basic size of components on the chip, and smaller is better). The two circuits may be operationally identical in every way, but one version may be faster, cheaper, more reliable, or use less power than the other.</p>&#13;
			<p lang="en-GB">This book is about assembly language and machine code layers, and the layers in <em class="italic">Table 3.1</em> allow us to write programs that are executed by a computer. By the end of this book, you will be able to design your own machine code, your own assembly language, and your own computer.</p>&#13;
			<p lang="en-GB">In the 1940s and 1950s, all programming was done in assembly language (or even machine code). Not today. Writing assembly language programs is tedious and very challenging. Computer scientists have created high-level languages such as C++, Java, Python, and Fortran. These languages were developed to allow programmers to write programs in a near-English language that expresses more powerful ideas than assembly language. For example, in Python, you can print the text <code>"Hello World"</code> on the screen with the instruction <code>print("Hello World.")</code>. If you wanted to do that in assembly language, you would have to write out, say, 100 individual machine-level instructions. Moreover, the Python version will run on all computers, but the machine-level version has to be written for each specific computer type.</p>&#13;
			<p lang="en-GB">The high-level language’s secret is the <em class="italic">compiler</em>. You write a program in a high-level language and then compile it to the machine code of the specific computer you want to run it on. You may come across the term <em class="italic">interpreter</em>, which performs the same function as a compiler. A compiler translates an entire high-level language program into machine code, whereas an interpreter performs the translation line by line, executing each line as it is interpreted.</p>&#13;
			<p lang="en-GB">Writing code in assembly language is not popular today (outside academia). However, it has the advantage that (in principle) you can write optimized code that runs faster than compiled code.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">A principal theme of this book is <em class="italic">learning by doing</em>. We will explain what a computer is, introduce the instructions it executes, and then show how it can be built (i.e., simulated) in a high-level language. We will call the program we are going to<a id="_idIndexMarker110"/><a id="_idIndexMarker111"/> construct <strong class="bold">TC1 (Teaching Computer 1)</strong>. This program will execute the assembly language of a hypothetical computer. You will be able to write a program in assembly language, and the TC1 program will read the instructions and execute them as if they were running on a real TC1 computer.</p>&#13;
			<p lang="en-GB">When you run the program, you can execute instructions one by one and observe their outcomes v – that is, you can read the values of data in registers and memory as the program runs. The purpose of this computer is not to perform useful computing functions but to show what instructions look like and how they are executed.</p>&#13;
			<p lang="en-GB">This computer demonstrates how instructions are executed and how to use assembly language. Moreover, you can modify the instruction set of the computer to create your own special-purpose instructions. You can remove instructions, add new instructions, extend instructions, and even change the format of instructions. TC1 was designed to enable students that study computer architecture to understand instruction formats, instruction decoding, and instruction <a id="_idIndexMarker112"/><a id="_idIndexMarker113"/>complexity. It is also very helpful to understand addressing modes (i.e., how data is located in memory), such as pointer-based addressing. We will discuss these topics in more detail later.</p>&#13;
			<p lang="en-GB">TC1 has several useful facilities that are not present in conventional computer instruction sets. For example, you can directly input data into the computer from the keyboard, and you can load random numbers into memory. This allows you to create data for testing purposes.</p>&#13;
			<p lang="en-GB">First, we need to introduce the prototype computer, the so-called von Neumann machine, which was created in the 1940s and 1950s and became the template for most modern computers. In reality, there’s been quite a departure from the pure von Neumann architecture, but we still tend to use the term to distinguish between other classes of computers (e.g., analog computers, neural networks, and quantum computers).</p>&#13;
			<h2 id="_idParaDest-46" lang="en-GB"><a id="_idTextAnchor046"/>ISAs – the Naming of Parts</h2>&#13;
			<p lang="en-GB">Before we introduce the structure of a computer, we need to introduce several terms that you need to know:</p>&#13;
			<ul>&#13;
				<li lang="en-GB"><code>0</code> or <code>1</code>. You can set a bit to <code>0</code>, to <code>1</code>, or toggle it (flip it over).</li>&#13;
				<li lang="en-GB"><code>8</code>, <code>16</code>, <code>32</code>, or <code>64</code>. In general, the word is the basic unit of data that the computer operates on. An<a id="_idIndexMarker116"/><a id="_idIndexMarker117"/> instruction such as <code>ADD </code>a<code>,b,c</code> executed on a 64-bit computer would add the 64-bits of word <code>b</code> to the 64-bits or word <code>c</code> and put the 64-bit result in word <code>a</code>. The <code>a</code>, <code>b</code>, and <code>c</code> variables refer to storage locations in either memory or registers.</li>&#13;
				<li lang="en-GB"><strong class="bold">Instruction</strong>: A machine-level <a id="_idIndexMarker118"/><a id="_idIndexMarker119"/>instruction is the most primitive operation that a programmer can specify and defines a single action carried out by the computer. Even more primitive level operations may exist on the silicon, but a programmer cannot directly access these. Instructions largely fall into three classes – data movement that copies data from one place to another, arithmetic and logical operations that process data, and instruction sequence commands that determine the order in which instructions are carried out (necessary to implement decisions of the form <em class="italic">if this, then </em><em class="italic">do that</em>).</li>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB"><strong class="bold">Immediate access memory</strong>: This is<a id="_idIndexMarker120"/><a id="_idIndexMarker121"/> often just called memory or RAM or DRAM by many programmers. It is where programs and data are stored during the execution of a program. The term <em class="italic">random access memory</em> today means the same thing. However, strictly speaking, the term <em class="italic">random</em> indicates that the access time for a memory element chosen at random is the same for every element (unlike, say, magnetic tape, where the access time depends on where data is on the tape).</li>&#13;
				<li lang="en-GB"><code>8</code> to <code>64</code> registers on a chip, it requires only <code>3</code> to <code>6</code> bits to specify a given register, rather than the <code>32</code> or <code>64</code> bits typically used to access a memory location. Most computer operations act <a id="_idIndexMarker122"/><a id="_idIndexMarker123"/>on the contents of registers rather than the main memory. There is no universal convention for the naming of registers. In this chapter, we will generally use for register names – for example, <code>INC r3</code> increments the contents of register <code>r3</code> by <code>1</code>.</li>&#13;
				<li lang="en-GB"><code>32</code> bits or <code>64</code> bits long. However, 8- and 16-bit computers are frequently used in embedded control applications (e.g., toys, TVs, washing machines, and automobiles).</li>&#13;
				<li lang="en-GB"><code>ADD </code>a<code>,b,5</code> where <code>5</code> is a literal, then it means, add the <code>5</code> integer to <code>b</code>. Some computers use a <code>#</code> to indicate a literal – for example, <code>ADD </code>a<code>,b,#12</code> means, add the number <code>12</code> to the contents of memory location <code>b</code>.</li>&#13;
				<li lang="en-GB"><code>A</code> and then ends up at <code>B</code> – simplicity itself. In computing, the term <em class="italic">move</em> indicates that something that was at <code>A</code> ends up at <code>B</code>, as well – that is, it is now in both <code>A</code> and <code>B</code>. In other words, programmers use <em class="italic">move</em> to mean <em class="italic">copy</em>. If you <em class="italic">move</em> data from a register to memory, the data remains in the register and is <em class="italic">copied</em> to memory. We will introduce the prototype computer in the following section.</li>&#13;
			</ul>&#13;
			<p lang="en-GB">The next step is to introduce the notion of the von Neumann computer, which can be regarded as the grandfather of most modern computers. The mathematician von Neumann was one of the authors of <em class="italic">The First Draft Report on the EDVAC</em> in 1945, which characterized the structure of the digital computer.</p>&#13;
			<h1 id="_idParaDest-47" lang="en-GB"><a id="_idTextAnchor047"/>The von Neumann architecture</h1>&#13;
			<p lang="en-GB">The prototype computer is often called a stored program von Neumann machine. It has a program in memory that is executed instruction by<a id="_idIndexMarker130"/><a id="_idIndexMarker131"/> instruction sequentially. Moreover, the program is stored in the same memory as the data that the computer operates on. This structure is named in honor of one of the pioneers of computing, John von Neumann. Once you understand the von Neumann machine, you understand all computers.</p>&#13;
			<p lang="en-GB"><em class="italic">Figure 3</em><em class="italic">.1</em> illustrates a simplified von Neumann machine that contains three basic elements:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">A memory that holds the program and any data used by the program</li>&#13;
				<li lang="en-GB">A set of registers that each holds one<a id="_idIndexMarker132"/><a id="_idIndexMarker133"/> word of data (in <em class="italic">Figure 3</em><em class="italic">.1</em>, there is one register, <code>r0</code>)</li>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB">An <strong class="bold">arithmetic and logic unit (ALU)</strong> that performs all data processing</li>&#13;
			</ul>&#13;
			<div>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_3.01_B19624.jpg" alt="Figure 3.1 – The von Neumann architecture" width="1471" height="1224"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – The von Neumann architecture</p>&#13;
			<p lang="en-GB">The memory contains instructions to be executed. Both data and instructions are stored in binary form, although we will often <a id="_idIndexMarker134"/><a id="_idIndexMarker135"/>show operations in assembly language form for ease of reading. Each instruction is read from memory, decoded, and interpreted (i.e., executed). The principal simplification of <em class="italic">Figure 3</em><em class="italic">.1</em> is the lack of a means of executive conditional operations (i.e., <code>if… then</code>). We will fix that later.</p>&#13;
			<p lang="en-GB"><em class="italic">Figure 3</em><em class="italic">.1</em> looks complicated. It’s not. We’ll explain its operation step by step. Once we see how a computer operates in principle, we can look at how it may be implemented in software. We describe the operation of a very simple, so-called <em class="italic">one-and-a-half</em> address machine, whose instructions have two operands – one in memory and one in a register. Instructions are written in the form <code>ADD </code>B<code>,A</code>, which adds <code>A</code> to <code>B</code> and puts the result in <code>B</code>. Either <code>A</code> or <code>B</code> must be in a register. Both operands may be in registers. The term <em class="italic">one-and-a-half address</em> machine is a comment about the fact that the memory address is 16 to 32 bits and selects one of millions of memory locations, whereas the register address is typically 2 to 6 bits and selects only one of a small number of registers.</p>&#13;
			<p lang="en-GB">Instead of introducing the computer all at once, we will build up a CPU step by step. This approach helps demonstrate how an instruction is executed because the development of the computer broadly follows the sequence of events taking place during the execution of an instruction. Real computers don’t execute an instruction from start to finish. Today’s computers <em class="italic">overlap</em> the execution of instructions. As soon as one instruction is fetched from memory, the next instruction is fetched before the previous instruction has completed its execution. This mechanism is called <em class="italic">pipelining</em> and is a major<a id="_idIndexMarker136"/><a id="_idIndexMarker137"/> aspect of a <a id="_idIndexMarker138"/><a id="_idIndexMarker139"/>modern computer’s organization. Pipelining is analogous to the automobile production line, where computer instructions are executed in stages so that several instructions may be in the process of being executed at the same time. We will begin with the address paths that are used to locate the next instruction to be executed. In this book, we will not cover pipelining because it is a factor or implementation and not an instruction set design.</p>&#13;
			<h2 id="_idParaDest-48" lang="en-GB"><a id="_idTextAnchor048"/>The address path</h2>&#13;
			<p lang="en-GB">An address is a number<a id="_idIndexMarker140"/><a id="_idIndexMarker141"/> representing the location of an item of data within memory. <em class="italic">Figure 3</em><em class="italic">.2</em> shows only the address paths needed to read an instruction from memory.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_3.02_B19624.jpg" alt="Figure 3.2 – The CPU’s address paths" width="1770" height="1129"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 3.2 – The CPU’s address paths</p>&#13;
			<p lang="en-GB">An address path is a data highway that moves addresses between the CPU and memory. The address tells memory where we want to read data from, or where we want to store it. For example, the instruction <code>ADD </code>r0<code>,234</code> indicates the operation <em class="italic">read the contents of memory location 234, add them to the contents of register r0, and then put the result in r0</em>. <em class="italic">Figure 3</em><em class="italic">.2</em> omits the data paths required to execute instructions to avoid clutter.</p>&#13;
			<p lang="en-GB">There are three types of information flow in a computer – address, data, and control. Data comprises the instructions, constants, and variables stored in <a id="_idIndexMarker142"/><a id="_idIndexMarker143"/>memory and registers. Control paths comprise the signals that trigger events, provide clocks, and determine the flow of data and addresses throughout the computer.</p>&#13;
			<h2 id="_idParaDest-49" lang="en-GB"><a id="_idTextAnchor049"/>Reading the instruction</h2>&#13;
			<p lang="en-GB">Before the CPU can execute an instruction, the instruction<a id="_idIndexMarker144"/><a id="_idIndexMarker145"/> must be brought from the computer’s memory. We begin our description of the way in which a program is executed with the CPU’s <em class="italic">program counter</em> (also called <em class="italic">instruction pointer</em> or <em class="italic">location counter</em>). The expression <em class="italic">program counter</em> is a misnomer. The program counter doesn’t count programs or anything else, but instead contains the address of the next instruction in memory to be executed.</p>&#13;
			<p lang="en-GB">The program counter <em class="italic">points</em> to the next instruction to be executed. If, for example, <code>[PC] = 1234</code> (i.e., the <code>PC</code> contains the number <code>1234</code>), the next instruction to be executed will be found in memory location <code>1234</code>.</p>&#13;
			<p lang="en-GB">Fetching an instruction begins with the contents of the program counter being moved to the memory address register (i.e., <code>[MAR]</code> ← <code>[PC]</code>). Once the contents of the program counter have been transferred to the memory address register, the contents of the program counter are incremented and moved back to the program counter, as follows:</p>&#13;
			<p lang="en-GB"><code>[PC]</code> ← <code>[PC] + </code>1.</p>&#13;
			<p lang="en-GB">The PC increment is <code>1</code> because the next instruction is one location on. Real computers are normally byte-addressed – that is, the bytes are numbered sequentially <code>0, 1, 2, 3 …</code> Modern computers have 32- or 64-bit data words – that is, 4- or 8-byte words. Consequently, real computers increment the PC by 4 or 8 after each instruction.</p>&#13;
			<p lang="en-GB">After this operation, the program counter points to the <em class="italic">next</em> instruction while the current instruction is executed.</p>&#13;
			<p lang="en-GB">The <strong class="bold">memory address register (MAR)</strong> holds the address <a id="_idIndexMarker146"/><a id="_idIndexMarker147"/>of the location<a id="_idIndexMarker148"/><a id="_idIndexMarker149"/> in the memory into which data is written in a write cycle, or from which data is read in a read cycle.</p>&#13;
			<p lang="en-GB">When a <em class="italic">memory read cycle</em> is performed, the <a id="_idIndexMarker150"/><a id="_idIndexMarker151"/>contents of the memory location specified by the MAR are read from the memory and transferred to the <strong class="bold">memory buffer register (MBR)</strong>. We can <a id="_idIndexMarker152"/><a id="_idIndexMarker153"/>represent this read operation in RTL terms as follows:</p>&#13;
			<pre class="source-code">[MBR] ← [[MAR]]   @ A read operation (example of indirect addressing)</pre>&#13;
			<p lang="en-GB">We interpret the <code>[[MAR]]</code> expression as <em class="italic">the contents of the memory whose address is given by the contents of the MAR</em>. The memory buffer register is a temporary holding place for data received from memory in a read cycle, or for data to be transferred to <a id="_idIndexMarker154"/><a id="_idIndexMarker155"/>memory in a write cycle. Some texts refer to the MBR as the <strong class="bold">memory data register (MDR).</strong> At this point in the execution of an instruction, the MBR contains the bit pattern of the instruction to be executed.</p>&#13;
			<p lang="en-GB">The instruction is next moved from the MBR to the <strong class="bold">instruction register (IR)</strong>, where it is divided into two fields. A <em class="italic">field</em> is part of a word in which the bits are <a id="_idIndexMarker156"/><a id="_idIndexMarker157"/>grouped together into a logical entity – for example, a person’s name can be divided into two fields, the given name and the family name. One field in the IR contains the <em class="italic">operation code</em> (opcode) that tells the CPU what operation is to be carried out. The other field, called the <em class="italic">operand field</em>, contains the address of the data to be used by the instruction. The operand field can also provide a constant to be employed by the operation code when immediate or literal addressing is used – that is, when the operand is an actual (i.e., literal) value and not an address. For our current purposes, the register address is considered to be<a id="_idIndexMarker158"/><a id="_idIndexMarker159"/> part of the instruction. Later, we will introduce computers with multiple registers. Real computers divide the instruction into more than two fields – for example, there may be two or three register-select fields.</p>&#13;
			<p lang="en-GB">The <strong class="bold">control unit (CU)</strong> takes the opcode<a id="_idIndexMarker160"/><a id="_idIndexMarker161"/> from the instruction register, together with a stream of clock pulses, and generates signals that control all parts of the CPU. The time between individual clock pulses is typically in the range 0.3 ns to 100 ns (i.e., 3 x 10-10 to 10-7 s), corresponding to frequencies of 3.3 GHz to 10 MHz. The CU is responsible for moving the contents of the program counter into the MAR, executing a read cycle, and moving the contents of the MBR to the IR.</p>&#13;
			<p lang="en-GB">Instructions are executed in a two-phase <em class="italic">fetch-execute cycle</em>. During the <em class="italic">fetch phase</em>, the instruction is read from memory and decoded by the control unit. The fetch phase is followed by an <em class="italic">execute phase</em>, in which the control unit generates all the signals necessary to execute the instruction. The following RTL notation describes the sequence of operations that take place in a fetch phase. <code>FETCH</code> is a label that serves to indicate a particular line in the sequence of operations. The notation IRopcode means the operation-code field of the instruction register. We use <code>#</code> to indicate a comment in Python and <code>@</code> in assembly language to be compatible with ARM’s convention. Some assemblers use a semicolon to indicate a comment field:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
FETCH [MAR] ← [PC]        @ Copy contents of the PC to the MAR&#13;
      [PC]  ← [PC] + 1    @ Increment the contents of the PC to point to next instruction&#13;
      [MBR] ← [[MAR]]     @ Read the instruction from memory&#13;
      [IR]  ← [MBR]       @ Move the instruction to the instruction register for processing</pre>&#13;
			<pre class="source-code">      CU    ← [IRopcode]  @ Transmit the opcode to the control unit</pre>&#13;
			<p lang="en-GB">The following is an example of how we can code the fetch cycle as a function in Python, together with the code needed to test it. We define a 12-bit instruction with a 4-bit opcode and an 8-bit address. The memory has 16 locations, and we load the first two with dummy values to test the program. The Python expression p &gt;&gt; q takes the binary value p and shifts it q places right, and <code>&amp;</code> performs a logical <code>AND</code>. We will discuss this in more detail later. For example, 0110<code>00001010 &gt;&gt; 8</code> becomes 0110. This extracts the opcode. Similarly, <code>0b011011111010 &amp; 0b111111111111 = 0b000000001010</code> to extract the address:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
                                # Testing the fetch cycle&#13;
mem = [0] * 16                  # Set up 16 locations in memory&#13;
pc = 0                          # Initialize pc to 0&#13;
mem[0] = 0b<strong class="bold">0110</strong>00001010         # Dummy first instruction (opcode in bold) 0b indicates binary value&#13;
mem[1] = 0b<strong class="bold">1000</strong>11111111         # Dummy second instruction&#13;
def fetch(memory):              # Fetch cycle implemented using a function&#13;
    global pc                   # Make pc global because we change it&#13;
    mar = pc                    # Copy pc to mar&#13;
    pc = pc + 1                 # Increment the pc ready for next instruction&#13;
    mbr = memory[mar]           # Read instruction from memory&#13;
    ir = mbr                    # Copy instruction to instruction register&#13;
    cu = ir &gt;&gt; 8                # Shift instruction 8 places right to get the operation code&#13;
    address = ir &amp; 0xFF         # Mask opcode to 8-bit address&#13;
    return(cu, address)         # Return instruction and address&#13;
<strong class="bold">opCode,address = fetch(mem)</strong>     # Do a fetch cycle&#13;
print('pc =', pc - 1, 'opcode =', opCode, ' Operand =', address)&#13;
<strong class="bold">opCode,address = fetch(mem)</strong>     # Do a fetch cycle&#13;
print('pc =', pc - 1, 'opcode =', opCode, ' Operand =', address)</pre>&#13;
			<p lang="en-GB">In the preceding code, the numeric <code>0b011000001010</code> value is expressed in binary form by the <code>0b</code> prefix. Similarly, the <code>0xFF</code> notation indicates<a id="_idIndexMarker162"/><a id="_idIndexMarker163"/> a number in hexadecimal form – that is, <code>255</code> in decimal or <code>11111111</code> in binary form.</p>&#13;
			<p lang="en-GB">The function is tested by calling it twice with <code>opCode,address = fetch(mem)</code>. Python lets us receive the two returned parameters, opcode and address, on one line. Note how closely the Python code follows the RTL. In practice, you would not write this code. We don’t need the MAR and MBR registers. I included them to help model the hardware. We can simply write the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
    ir  = mem[pc]               # Read current instruction into ir&#13;
    pc = pc + 1                 # Increment program counter ready for next cycle&#13;
    cu = ir &gt;&gt; 8                # Extract the opcode&#13;
    address = ir &amp; 0xFF         # Extract the operand address</pre>&#13;
			<h2 id="_idParaDest-50" lang="en-GB"><a id="_idTextAnchor050"/>The CPU’s data paths</h2>&#13;
			<p lang="en-GB">Having sorted out the fetch phase, let’s see what <a id="_idIndexMarker164"/><a id="_idIndexMarker165"/>else we need to execute instructions. <em class="italic">Figure 3</em><em class="italic">.3</em> adds data paths to the CPU of <em class="italic">Figure 3</em><em class="italic">.2</em>, plus an address path from the address field of the instruction register to the memory address register. Other additions are a data register, <code>r0</code>, and an ALU that does the actual computing. The operations it performs are typically arithmetic (add, subtract, multiply, and divide) and logical (<code>AND</code>, <code>OR</code>, <code>EOR</code>, and shift left or right).</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_3.03_B19624.jpg" alt="Figure 3.3 – The CPU’s address and data paths" width="1471" height="1077"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – The CPU’s address and data paths</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The data register, <code>r0</code>, holds temporary results during a calculation. You need a data register (i.e., an accumulator) because <em class="italic">dyadic</em> operations with two operands such as <code>ADD</code> use one operand specified by the instruction, and the other register is the contents of a data register. <code>ADD </code><code>,P</code> adds the contents of the memory location, <code>P</code>, to the contents of the general-purpose register, <code>r0</code>, and deposits the sum in the data register, destroying one of the original operands. The arrangement of <em class="italic">Figure 3</em><em class="italic">.3</em> has one general-purpose data register that we’ve called <code>r0</code>. A real processor, the ARM, has 16 registers, <code>r0</code> to <code>r15</code> (although not all of them are general-purpose data registers).</p>&#13;
			<h2 id="_idParaDest-51" lang="en-GB"><a id="_idTextAnchor051"/>Typical data movement instructions</h2>&#13;
			<p lang="en-GB">All computers have data move instructions that <a id="_idIndexMarker166"/><a id="_idIndexMarker167"/>transfer (i.e., copy) data from one place to another. These are the simplest instructions because they don’t involve processing data. Data movement instructions vary from computer to computer. Here, we will provide a few typical examples that will help you follow the examples in this chapter. Note that we will use different conventions in this text. For example, we will sometimes prefix a literal by <code>#</code> (e.g., <code>ADD </code><code>,#6</code>) and sometimes add the suffix <code>L</code> to the instruction (e.g., <code>ADDL </code>r1<code>,6</code>). This is because there are several standards/conventions in use in computing, and they vary from computer to computer. The following are simply generic examples of code. Note the duplication of load a literal. Some processors use <code>move</code> and some use <code>load</code>:</p>&#13;
			<table id="table002-2" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Mnemonic</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Example</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Name</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">RTL</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Comment</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>MOV</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>MOV</code>  r1<code>,r4</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">move register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[r1] ← [r4]</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Copy register r4 to register r1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>MOVL</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>MOVL </code>r1<code>,5</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">move literal</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[r1] ← 5</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Copy the integer 5 to register r1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>LDR</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>LDR</code>  r3<code>,12</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">load register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[r3] ← [12]</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Load r3 with contents of memory location 12</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>LDRL</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>LDRL </code>r0<code>,13</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">load literal</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[r0] ← 13</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Load register r0 with the integer 13</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>STR</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>STR</code>  <code>r4,</code>8</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">store register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[8] ← [r4]</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Store contents of r4 in memory location 8</p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.2 – Typical data movement instructions</p>&#13;
			<h2 id="_idParaDest-52" lang="en-GB"><a id="_idTextAnchor052"/>Data processing instructions</h2>&#13;
			<p lang="en-GB">Let’s look at a typical <a id="_idIndexMarker168"/><a id="_idIndexMarker169"/>data-processing operation. We can represent an <code>ADD </code>r0<code>,X</code> instruction with the RTL expression:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
[r0] ← [r0] + [X]       @ Add the contents of the memory&#13;
                         location X to register r0</pre>&#13;
			<p lang="en-GB">The ALU is the workhorse of the CPU because it performs all calculations. Arithmetic and logical operations are applied to the contents of a data register and the contents of a data register or the MBR. The output of the ALU is fed back to the data register or to the MBR.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The fundamental difference between arithmetic and logical operations is that logical operations don’t generate a carry when bit ai of word <code>A</code> and bit bi of <code>B</code> are operated upon. <em class="italic">Table 3.2</em> provides examples of typical arithmetic and logical operations.</p>&#13;
			<table id="table003" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB"><strong class="bold">Operation</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB"><strong class="bold">Class</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB"><strong class="bold">Typical mnemonic</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Addition</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Arithmetic</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">ADD (a = b + c)</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Subtraction</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Arithmetic</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">SUB (a = b - c)</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Negation</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Arithmetic</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">NEG (a = -b)</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Multiplication</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Arithmetic</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">MUL (a = b * c)</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Division</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Arithmetic</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">DIV (a = b / c)</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Divide by 2</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Arithmetic</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">ASR (a = b / 2)</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Multiply by 2</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Arithmetic</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">ASL (a = b * 2)</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">AND</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Logical</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">AND (a = b &amp; c)</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">OR</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Logical</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">OR  (a = b | c)</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">NOT</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Logical</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">NOT (a = !b)</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">EOR</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Logical</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">EOR (a = b ⊕ c)</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Shift left</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Logical</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">LSL (shift all bits left a = b &lt;&lt; 1)</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Shift right</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Logical</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">LSR (shift all bits right a = b &gt;&gt; 1)</p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.3 – Typical arithmetic and logical operations</p>&#13;
			<p lang="en-GB">A logical shift treats an operand as a <a id="_idIndexMarker170"/><a id="_idIndexMarker171"/>string of bits that are moved left or right. An arithmetic shift treats a number as a signed 2s complement value and propagates the sign bit during a right shift (i.e., the sign bit is replicated and duplicated). Most of these operations are implemented by computers such as the 68K, Intel Core, and ARM.</p>&#13;
			<h2 id="_idParaDest-53" lang="en-GB"><a id="_idTextAnchor053"/>Another look at the data flow</h2>&#13;
			<p lang="en-GB">Let’s have another look at <a id="_idIndexMarker172"/><a id="_idIndexMarker173"/>data flow in a computer to cement the basic concepts together. In <em class="italic">Figure 3</em><em class="italic">.4</em>, we have a computer that supports operations involving three registers (a hallmark of computers such as the ARM). Here, we have three registers, <code>r1</code>, <code>r2</code>, and <code>r3</code>. The block labeled <em class="italic">adder</em> is part of the ALU and serves to add two numbers to produce a sum. Instruction <code>LDR </code>r2<code>,X</code> loads the contents of memory address <code>X</code> into register <code>r2</code>. Instruction <code>STR r1,</code>Z stores the contents of register <code>r1</code> in memory address <code>Z</code>.</p>&#13;
			<p lang="en-GB">The instruction <code>ADD </code>r1<code>,r2,r3</code> reads the contents of registers <code>r2</code> and <code>r3</code>, adds them together, and deposits the result in register, <code>r1</code>. Since it’s not clear which register is the destination register (i.e., the result), we use a bold font to highlight the destination operand, which is normally the leftmost operand.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB"><em class="italic">Figure 3</em><em class="italic">.4</em> shows several fundamental components of a computer. This is, essentially, the same as the more detailed structures we used to demonstrate the fetch/execute cycle. Here, we are interested in data flow into and out of memory.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_3.04_B19624.jpg" alt="Figure 3.4 – Details of the von Neumann machine" width="1363" height="814"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Details of the von Neumann machine</p>&#13;
			<p lang="en-GB">The elements of interest are as follows:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">A clock that generates timing pulses. All operations take place when triggered by the clock.</li>&#13;
				<li lang="en-GB">An interpreter or control unit that takes an instruction, together with a stream of clock pulses, and converts it into the actions <a id="_idIndexMarker174"/><a id="_idIndexMarker175"/>required to perform the required operation. In <em class="italic">Figure 3</em><em class="italic">.4</em>, the interpreter routes the contents of registers <code>r2</code> and <code>r3</code> to the adder, makes the adder add the two values together, and then routes the result from the adder to the destination register.</li>&#13;
				<li lang="en-GB">The program in memory. Data is loaded from memory into registers <code>r2</code> and <code>r2</code>. Then, <code>r2</code> and <code>r3</code> are added together and the result is put in <code>r3</code>. Finally, the contents of <code>r3</code> are moved to memory.</li>&#13;
			</ul>&#13;
			<p lang="en-GB">Now that we’ve covered the basic structure of a computer and introduced some instructions, the next step is to look at a complete program that carries out a specific function.</p>&#13;
			<h1 id="_idParaDest-54" lang="en-GB"><a id="_idTextAnchor054"/>An assembly-level program</h1>&#13;
			<p lang="en-GB">Having developed our computer <a id="_idIndexMarker176"/><a id="_idIndexMarker177"/>a little further, in this section, we will show how a simple program is executed. Assume that this computer doesn’t provide three-address instructions (i.e., you can’t specify an operation with three registers and/or memory addresses) and we want to implement the high-level language operation <code>Z = X + Y</code>. Here, the <em class="italic">plus</em> symbol means arithmetic addition. An assembly language program that carries out this operation is given in the following code block. Remember that <code>X</code>, <code>Y</code>, and <code>Z</code> are symbolic names referring to the <em class="italic">locations</em> of the variables in memory. Logically, the store operation should be written <code>STR Z,r2</code>, with the destination operand on the left just like other instructions. By convention, it is written as <code>STR r2,Z</code>, with the source register on the<a id="_idIndexMarker178"/><a id="_idIndexMarker179"/> left. This is a quirk of programming history:</p>&#13;
			<p lang="en-GB"><code>LDR</code><code>,X</code><code>r2</code> with the contents of memory location <code>X</code></p>&#13;
			<p lang="en-GB"><code>ADD</code><code>,Y</code><code>Y</code> to data register <code>r2</code></p>&#13;
			<p lang="en-GB"><code>STR</code><code>r2,</code>Z<code>r2</code> in memory location <code>Z</code></p>&#13;
			<p lang="en-GB">Eight-bit computers had a one-address machine, requiring a rather cumbersome sequence of operations just to carry out the simple act of adding two numbers. If we had a computer with a three-address format, we could have written the following:</p>&#13;
			<p lang="en-GB"><code>ADD</code><code>,X,Y</code><strong class="bold CharOverride-6">  </strong>Add the contents of X to the contents of Y and put the result in Z</p>&#13;
			<p lang="en-GB">Three-address machines are <em class="italic">potentially </em>faster than one-address machines because they can do in one instruction things that take other machines three operations. Unfortunately, it is a factor of technological development that on-chip registers are faster than DRAM, and computer designers try to keep data in registers on-chip as much as possible.</p>&#13;
			<p lang="en-GB">The reality is more complicated. Accessing memory is slow compared to accessing registers. This is a property of the hardware. Consequently, it is more efficient to keep data in registers.</p>&#13;
			<p lang="en-GB">The way in which the CPU operates can best be seen by examining the execution of, say, <code>ADD </code>r2<code>,Y</code> in terms of register-transfer language. In the following code block, we describe the operations carried out during the fetch and execute phases of an <code>ADD </code>r2<code>,Y</code> instruction:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
FETCH [MAR] ← [PC]     <strong class="bold">  </strong> <strong class="bold">  </strong> <strong class="bold">  </strong> <strong class="bold">    </strong>Move the contents of the PC to the MAR&#13;
      [PC]  ← [PC] + 1  <strong class="bold">  </strong> <strong class="bold">  </strong> <strong class="bold">      </strong>Increment the contents of the PC&#13;
      [MBR] ← [[MAR]]   <strong class="bold">  </strong> <strong class="bold">  </strong> <strong class="bold">  </strong> <strong class="bold">   </strong>Read the current instruction from the memory&#13;
      [IR]  ← [MBR]    <strong class="bold">  </strong> <strong class="bold">  </strong> <strong class="bold">  </strong> <strong class="bold">    </strong>Move the contents of the MBR to the IR&#13;
      CU    ← [IRopcode]    <strong class="bold">  </strong> <strong class="bold">    </strong> Move the opcode from the IR to the CU&#13;
<strong class="bold">ADD   [MAR] </strong><strong class="bold CharOverride-8">←</strong><strong class="bold"> [IR</strong>address<strong class="bold">]             </strong>Move the operand address to the MAR&#13;
<strong class="bold">      [MBR] </strong><strong class="bold CharOverride-8">←</strong><strong class="bold"> [[MAR]]              </strong>Read the data from memory&#13;
<strong class="bold">      ALU</strong><strong class="bold">   </strong><strong class="bold CharOverride-8">←</strong><strong class="bold"> [MBR], ALU </strong><strong class="bold CharOverride-8">←</strong><strong class="bold"> [r2]   </strong> Perform the addition&#13;
<strong class="bold">      [r2]  </strong><strong class="bold CharOverride-8">←</strong><strong class="bold"> ALU                  </strong>Move the output of ALU to the data register</pre>&#13;
			<p lang="en-GB">Operations sharing the same line are executed simultaneously.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">During the fetch phase, the opcode is fed to the control unit by CU ← [IRopcode] and used to generate all the internal signals required to place the ALU in its addition mode. When the ALU is programmed for addition, it adds together the data at its two input terminals to produce a sum at its output terminals.</p>&#13;
			<p lang="en-GB">Operations of the form <code>[PC]</code> ← <code>[MAR]</code> or <code>[r2]</code> ← <code>[r2] + [MBR]</code> are often referred to as <em class="italic">microinstructions</em>. Each assembly-level instruction (e.g., <code>MOV, ADD</code>) is executed as a series of microinstructions. Microinstructions are the province of the computer designer. In the 1970s, some machines were user-microprogrammable – that is, you could define your own instruction set.</p>&#13;
			<p lang="en-GB">We can test the execute phase by extending the fetch phase code. The following Python code provides three instructions – load a register with<a id="_idIndexMarker180"/><a id="_idIndexMarker181"/> a literal, add memory contents to the register, and stop. We have also made the Python code more compact – for example, you can put expressions in a function’s return statement. In this example, we return two values: <code>ir &gt;&gt; 8</code> and <code>ir &amp; 0xFF</code>. The operation <code>x &gt;&gt; y</code> takes the binary value of <code>x</code> and shifts the bits <code>y</code> places right; for example, <code>0b0011010110 &gt;&gt; 2</code> gives <code>0b0000110101</code>. The shaded part of the code is the machine-level program we execute:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
# Implement fetch cycle and execute cycle: include three test instructions&#13;
mem = [0] * 12                     # Set up 12-location memory&#13;
pc = 0                             # Initialize pc to 0&#13;
mem[0] = 0b000100001100            # First instruction load r0 with 12&#13;
mem[1] = 0b001000000111            # Second instruction add mem[7] to r0&#13;
mem[2] = 0b111100000000            # Third instruction is stop&#13;
mem[7] = 8                         # Initial data inlocation 7 is 8&#13;
def fetch(memory):                 # Function for fetch phase&#13;
    global pc                      # Make pc a global variable&#13;
    ir = memory[pc]                # Read instruction and move to IR&#13;
    pc = pc + 1                    # Increment program counter for next cycle&#13;
    return(ir &gt;&gt; 8, ir &amp; 0xFF)     # Returns opCode and operand&#13;
run = 1                            # run = 1 to continue&#13;
while run == 1:                    # REPEAT: The program execution loop&#13;
    opCode, address = fetch(mem)   # Call fetch to perform fetch phase&#13;
    if   opCode == 0b1111: run = 0 # Execute phase for  stop (set run to 0 on stop)&#13;
    elif opCode == 0b0001:         # Execute phase for load number&#13;
         r0 = address              # Load r0 with contents of address field&#13;
    elif opCode == 0b0010:         # Execute phase for add&#13;
         mar = address             # Copy address in opCode to MAR&#13;
         mbr = mem[mar]            # Read the number to be dded&#13;
         r0 = mbr + r0             # Do the addition&#13;
    print('pc = ',pc - 1, 'opCode =', opCode, 'Register r0 =',r0)&#13;
                                   # We print pc – 1 because the pc is incremented</pre>&#13;
			<p lang="en-GB">The output from this code is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
pc =  0 opCode = 1  Register r0 = 12&#13;
pc =  1 opCode = 2  Register r0 = 20</pre>&#13;
			<pre class="source-code">pc =  2 opCode = 15 Register r0 = 20</pre>&#13;
			<p lang="en-GB">Note that the Python term <code>elif</code> is short for <em class="italic">else if</em>. The preceding case says, “<em class="italic">Is the opcode stop. If not, is the opcode load. If not, is the opcode add.</em>” This allows for a sequence of tests. We discuss <code>elif</code> in more detail later.</p>&#13;
			<h2 id="_idParaDest-55" lang="en-GB"><a id="_idTextAnchor055"/>Executing conditional instructions</h2>&#13;
			<p lang="en-GB">So far, we’ve looked <a id="_idIndexMarker182"/><a id="_idIndexMarker183"/>at the structure of a CPU capable of executing programs in a purely <em class="italic">sequential</em> mode – that is, the computer can execute only a stream of instructions, one by one, in strict order. We introduced conditional behavior in the previous chapter, and now we will extend the CPU so that it can execute instructions, such as <code>BEQ Target</code> (a branch on a zero flag set to <code>Target</code>), that are able to execute instructions out of sequence.</p>&#13;
			<p lang="en-GB">The computer in <em class="italic">Figure 3</em><em class="italic">.1</em> lacks a mechanism to make choices or repeat a group of instructions. To do this, the CPU must be able to execute <em class="italic">conditional branches</em> or <em class="italic">jumps</em>. The block diagram of <em class="italic">Figure 3</em><em class="italic">.5</em> shows the new address and data paths required by the CPU to implement conditional branches.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_3.05_B19624.jpg" alt="Figure 3.5 – Information paths in the CPU and conditional instructions" width="1471" height="1302"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 3.5 – Information paths in the CPU and conditional instructions</p>&#13;
			<p lang="en-GB">Three items have been added to our computer in <em class="italic">Figure 3</em><em class="italic">.5</em>. These are highlighted:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">A <strong class="bold">condition code </strong><strong class="bold">register (CCR)</strong></li>&#13;
				<li lang="en-GB">A path between the<a id="_idIndexMarker184"/><a id="_idIndexMarker185"/> CCR and the control unit</li>&#13;
				<li lang="en-GB">A path between the address field of the instruction register and the program counter.</li>&#13;
			</ul>&#13;
			<p lang="en-GB">The <em class="italic">condition code register</em> or <em class="italic">processor status register</em> records the ALU state after each instruction has been executed, and updates the carry, negative, zero, and overflow flag bits. A conditional branch instruction interrogates the CCR’s flags. The CU then either executes<a id="_idIndexMarker186"/><a id="_idIndexMarker187"/> the next instruction in sequence or branches to another instruction. Let’s look at the details of the conditional branch. The following is a reminder of the CCR bit functions:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">C = Carry:  A carry occurs when an operation in n bits yields an n+1 bit result (e.g., when your car odometer winds round from 999...9 to 000...0). In 8-bit computer terms, this is when 11111111 + 1 = 0000000 carry 1.</li>&#13;
				<li lang="en-GB">Z = Zero:   This is set if the last operation generated a zero result.</li>&#13;
				<li lang="en-GB">N = Negative: This is set if the last result generated a negative result in 2s complement arithmetic – that is, set if the most significant bit of a word is 1 (for example, 00101010 is positive and 10101010 is negative when the number is viewed as a two’s complement value).</li>&#13;
				<li lang="en-GB">V = Overflow: This is set if the last operation resulted in an arithmetic overflow, which occurs in two’s complement arithmetic if the result is outside its allowable range. In this text, we generally don’t implement the V-flag for the sake of simplicity.</li>&#13;
			</ul>&#13;
			<p lang="en-GB">The condition code register is connected to the control unit, enabling an instruction to interrogate it. For example, some instructions test whether an operation yielded a positive result, whether the carry bit was set, or whether an arithmetic overflow occurred. We need a mechanism that does one thing if the result of the test is <code>true</code> and does another thing if the result of the test is <code>false</code>.</p>&#13;
			<p lang="en-GB">The final modification included in <em class="italic">Figure 3</em><em class="italic">.5</em> is the addition of a path between the operand field (i.e., the target address) of the instruction register and the program counter. It’s this feature that enables the computer to respond to the result of its interrogation of the CCR.</p>&#13;
			<p lang="en-GB">A <em class="italic">conditional branch</em> instruction <a id="_idIndexMarker188"/><a id="_idIndexMarker189"/>such as <strong class="bold">branch on carry set (BCS)</strong> tests the carry bit of the CCR, and if the bit tested is clear, the next instruction is obtained from memory in the normal way. If the bit tested is set, the next instruction is obtained from the location whose <em class="italic">target address</em> is in the instruction register. In the preceding description, we said that a branch is made if a bit of the CCR is set; equally, a branch can be made if the bit is clear (branches can also be made on the combined state of several CCR bits).</p>&#13;
			<p lang="en-GB">Branch operations can be expressed in register-transfer language in the following form:</p>&#13;
			<pre class="source-code">IF condition THEN action</pre>&#13;
			<p lang="en-GB">Typical machine-level conditional operations expressed in RTL are as follows:</p>&#13;
			<ol>&#13;
				<li lang="en-GB">Branch on carry clear (jump to the target address if the carry bit in the CCR is 0)</li>&#13;
			</ol>&#13;
			<p lang="en-GB"><strong class="bold">BCC target: IF [C] = 0 THEN [PC] </strong><strong class="bold CharOverride-3">←</strong><strong class="bold"> [IR</strong>address<strong class="bold">]</strong></p>&#13;
			<ol>&#13;
				<li lang="en-GB" value="2">Branch on equal (jump to the target address if the Z bit in the CCR is 1)</li>&#13;
			</ol>&#13;
			<p lang="en-GB"><strong class="bold">BEQ target: IF [Z] = 1 THEN [PC] </strong><strong class="bold CharOverride-3">←</strong><strong class="bold"> [IR</strong>address<strong class="bold">]</strong></p>&#13;
			<p lang="en-GB">Both these actions have an <code>ELSE</code> condition, which is the default <code>[PC]</code> ← <code>[PC] + </code><code>1</code>.</p>&#13;
			<p lang="en-GB">An example of a conditional<a id="_idIndexMarker190"/><a id="_idIndexMarker191"/> branch in assembly language is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
     SUB  <strong class="bold">r0</strong>,x    @ Subtract the contents of memory location x from register r0&#13;
     <strong class="bold">BEQ  Last</strong>    @ If the result was zero, then branch to Last; otherwise, continue&#13;
     .            @ Execute here if branch not taken&#13;
     .&#13;
Last              @ Target address of branch (if taken)</pre>&#13;
			<p lang="en-GB">The final step in extending the computer architecture is the introduction of data paths to permit literals to be loaded into a register – that is, to load a register with a number that is in the instruction rather than from memory. The z-bit can be confusing. The z-bit is set to 1 if a result yields zero, and it’s set to 0 if the result is not zero.</p>&#13;
			<h2 id="_idParaDest-56" lang="en-GB"><a id="_idTextAnchor056"/>Dealing with literal operands</h2>&#13;
			<p lang="en-GB">Computer instructions such <a id="_idIndexMarker192"/><a id="_idIndexMarker193"/>as <code>ADD </code>r0,<code>abc</code> refer to an operand somewhere within the CPU’s memory. Sometimes, we want to use an instruction such as ADD r0,#12, where the source operand supplies the <em class="italic">actual value</em> of the data being referred to by the opcode part of the instruction – in this case, 12. Although the symbol <code>#</code> appears as part of the operand when this instruction is written in mnemonic form, the assembler uses a different opcode code for the following:</p>&#13;
			<p lang="en-GB"><code>ADD</code>  r0<code>,#literal</code> and <code>ADD</code>  r0<code>,address</code>.</p>&#13;
			<p lang="en-GB">The instruction <code>ADD</code>  r0<code>,#12</code> is defined in <code>RTL</code> as [r0] ← [r0] + 12.</p>&#13;
			<p lang="en-GB">Note that we use two conventions for literals. One is <code>ADD r0,</code>#<code>12</code> and the other is <code>ADD</code>L<code> r0,12</code>. This matches typical instruction sets.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB"><em class="italic">Figure 3</em><em class="italic">.6</em> shows that an additional data path is required between the operand field of the IR and the data register and ALU to deal with literal operands. <em class="italic">Figure 3</em><em class="italic">.6</em> includes three general-purpose registers, <code>r0</code>, <code>r1</code>, and <code>r2</code>. In principle, there is nothing stopping us from adding any number of registers. However, the number of internal registers is limited by the number of bits available to specify a register in the instruction. As you can see, three data buses, <code>A</code>, <code>B</code>, and <code>C</code>, are used to transfer data between the registers and ALU.</p>&#13;
			<p lang="en-GB">The structure of <em class="italic">Figure 3</em><em class="italic">.6</em> can implement instructions with more complex addressing modes than the simple direct (absolute) addressing we have used so far. Consider <code>MOV </code>r1<code>,[r0]</code>, which copies the contents of the memory location whose address is in <code>r0</code>. Here, <code>r0</code> is a pointer to the actual data. This instruction can be implemented by the following sequence of micro-operations:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
MOV   [MAR] ← [r0]        Move the source operand address to the MAR&#13;
      [MBR] ← [[MAR]]     Read the actual operand from memory&#13;
      [MAR] ← [MBR]       Copy the address back to the MAR&#13;
      [r1]  ← [[MAR]]     Copy the data from memory to r1</pre>&#13;
			<p lang="en-GB">This sequence has been simplified <a id="_idIndexMarker194"/><a id="_idIndexMarker195"/>because, as you can see from <em class="italic">Figure 3</em><em class="italic">.6</em>, there is no direct path between register <code>r0</code> and the MBR. You would have to put the contents of r0 onto bus A, pass the contents of bus A through the ALU to bus C, and then copy bus C to the MAR.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_3.06_B19624.jpg" alt="Figure 3.6 – Modifying the CPU to deal with literal operands" width="1254" height="1261"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 3.6 – Modifying the CPU to deal with literal operands</p>&#13;
			<p lang="en-GB">Let’s extend our Python code to include both literal operations and conditional operations. The following Python code implements a load register<a id="_idIndexMarker196"/><a id="_idIndexMarker197"/> with literal instruction, an add/subtract, a conditional branch on zero, and a stop. Here, we use <code>LDRL</code> to indicate a literal, rather than prefixing the literal with #. The program to be executed is as follows:</p>&#13;
			<table id="table004" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Address</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Mnemonic</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Instruction</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Binary code</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Note</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>LDRL </code>r0<code>,9</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">load <code>r0</code> with the literal <code>9</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">0001<code>00001001</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>[r0]</code> ← <code>9</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>SUB </code>r0<code>,7</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">subtract mem<code>[7]</code> from <code>r0</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>0</code>011<code>00000111</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>[r0]</code> ← <code>[r0] – </code><code>mem[7]</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">2</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>BEQ </code>6</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">branch on zero to 6 </p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>0</code>100<code>00000110</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">if <code>z = 1 [PC] ← 6</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">3</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>STOP</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">top execution</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">1111<code>00000000</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">4</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">5</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">6</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>STOP</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">top execution</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">1111<code>00000000</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.4 – Caption</p>&#13;
			<p lang="en-GB">To implement a load register, we simply move the literal in the instruction to the register. The subtraction tests the result and sets the zero-status bit, <code>z</code>, to <code>1</code> if the result is <code>0</code> and <code>0</code> if it is not. The conditional branch tests the z-bit and loads the pc with the literal from the instruction if <code>z = </code><code>1</code>.</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
                             # Simple program to test a branch instruction&#13;
mem = [0] * 12               # Set up a 12-location memory&#13;
pc = 0                       # Initialize program counter to 0&#13;
mem[0] = 0b<strong class="bold">0001</strong>00001001      # First instruction loads r0 with 9 (i.e., 1001)&#13;
mem[1] = 0b<strong class="bold">0011</strong>00000111      # Second instruction subtracts mem[7] from r0&#13;
mem[2] = 0b<strong class="bold">0100</strong>00000110      # Third instruction is BEQ 6 (branch on zero to 6)&#13;
mem[3] = 0b<strong class="bold">1111</strong>00000000      # Fourth instruction is stop&#13;
mem[6] = 0b<strong class="bold">1111</strong>00000000      # Seventh instruction is stop&#13;
mem[7] = 9                   # Initial data in location 7 is 9&#13;
                             # Fetch returns opcode and address&#13;
def fetch(memory):           # This function, fetch, gets the instruction from memory&#13;
    global pc                # Declare pc as global because we modify it in the function&#13;
    ir = memory[pc]          # Read the instruction from memory&#13;
    pc = pc + 1              # Now point to the next instruction&#13;
    return(ir&gt;&gt;8, ir&amp;0xFF)   # Return the opcode and address&#13;
z = 0                                             # Clear z bit initially&#13;
run = 1                                           # run = 1 to continue&#13;
while run == 1:                                   # Main loop REPEAT until stop found&#13;
    pcOld = pc                                    # Save current pc for display&#13;
    opCode, address = fetch(mem)                  # Perform fetch to get opcode&#13;
    if   opCode == 0b1111: run = 0                # Test for stop&#13;
    elif opCode == 0b0001: r0 = address           # Test for load literal&#13;
    elif opCode == 0b0010: r0 = r0 + mem[address] # Test for add&#13;
    elif opCode == 0b0011:                        # Test for subtract&#13;
        r0 = r0 - mem[address]                    # Do subtraction&#13;
        if r0 == 0: z = 1                         # Update z flag on subtract&#13;
        else:       z = 0&#13;
    elif opCode == 0b0100:                        # Test for branch on zero&#13;
        if z == 1: pc = address                   # If BEQ, load PC on zero flag&#13;
    print('pc = ',pcOld,'opCode =',opCode,'\tRegister r0 =',r0,'z = ',z)&#13;
                                                  # The '\t' performs a tab operation</pre>&#13;
			<p lang="en-GB">The output from this Python code is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
pc =  0 opCode = 1  Register r0 = 9 z =  0&#13;
pc =  1 opCode = 3  Register r0 = 0 z =  1&#13;
pc =  2 opCode = 4  Register r0 = 0 z =  1        z = 1 so branch taken&#13;
pc =  6 opCode = 15 Register r0 = 0 z =  1</pre>&#13;
			<p lang="en-GB">We load the literal <code>9</code> into <code>r0</code>, subtract the <a id="_idIndexMarker198"/><a id="_idIndexMarker199"/>contents of memory location <code>7</code> (which contains <code>9</code>), and then branch to location <code>6</code> if the result was <code>0</code>. And that’s what happens.</p>&#13;
			<p lang="en-GB">Having described the structure of a computer, the next step is to look at the instructions that are executed by a computer.</p>&#13;
			<h1 id="_idParaDest-57" lang="en-GB"><a id="_idTextAnchor057"/>The machine-level instruction</h1>&#13;
			<p lang="en-GB">Having described how a computer works, we now take a closer look at the computer. We are interested in what an instruction does and what<a id="_idIndexMarker200"/><a id="_idIndexMarker201"/> resources it needs (i.e., data locations or constants). A low-level computer operation (i.e., machine code or assembly language) operates on binary data in memory or registers. Although computers have become millions of times faster over the decades, the nature of the low-level instruction has hardly changed.</p>&#13;
			<p lang="en-GB">Many first-generation microprocessors (e.g., 8080, 6800, Z80, and 6502) of the 1970s and 1980s used 8-bit instructions that had to be chained together to create a more practical instruction – for example, 8-bit microprocessors provide 16-bit instructions by chaining together two consecutive 8-bit instructions.</p>&#13;
			<p lang="en-GB">The second generation of microprocessors, such as Intel’s 8086 and Motorola’s 68000, had 16-bit instructions. These too were chained together to create sufficiently long instructions to perform all the necessary operations. Indeed, the 68000 actually chained up to five consecutive 16-bit words to create a gigantic 80-bit instruction. Modern high-performance microprocessors (e.g., ARM, MIPS, and RISC-V) have 32-bit or 64-bit instructions that provide a full instruction set without the need to chain consecutive instructions. The CISC approach to chaining instructions together to increase the number of opcodes was a great idea at the time. However, it reduces performance by making it difficult to execute instructions in parallel because a computer does not know where the boundaries lie between instructions until they have been decoded.</p>&#13;
			<p lang="en-GB">Later in this book, we will take <a id="_idIndexMarker202"/><a id="_idIndexMarker203"/>a brief look at the concept of multi-length instruction sets.</p>&#13;
			<h2 id="_idParaDest-58" lang="en-GB"><a id="_idTextAnchor058"/>Instruction types and formats</h2>&#13;
			<p lang="en-GB">Now, we will describe the type <a id="_idIndexMarker204"/><a id="_idIndexMarker205"/>of primitive operations computers perform. First, a surprise. How many different instructions does a computer need? I mean, how many does it need to solve any problem that can be solved by a computer, today, tomorrow, and at any point in the future? The remarkable answer is one. Yes, you can solve any problem with the permutations of one single instruction.</p>&#13;
			<p lang="en-GB">According to Wikipedia, the <code>SBNZ a,b,c,d</code> instruction <em class="italic">(“subtract and branch if not equal to zero”</em>) subtracts the contents at address <code>a</code> from the contents at address <code>b</code>, stores the result at address <code>c</code>, and then, if the result is not <code>0</code>, transfers control to address <code>d</code> (if the result is equal to zero, the execution proceeds to the next instruction in sequence). Expressed in RTL, the <code>SBNZ</code> instruction is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
[c] ← [b] – [a]&#13;
if [c] != 0: [pc] ← d&#13;
else: [pc] ← [pc] + 1</pre>&#13;
			<p lang="en-GB">All computation can be done using this single instruction alone. In practice, such a computer would be impossibly inefficient and impractical. However, it hints that a large and complex set of instructions is not necessarily required to build a computer. Most computers today have a relatively modest number of instructions. However, some computer designers now create optimized special-purpose instruction set enhancements for specific applications (e.g., graphics, signal processing, and AI).</p>&#13;
			<p lang="en-GB">From the first computer to today’s chips with over 10 billion transistors, computers have had instruction sets that include the following three classes of operation. <em class="italic">Table 3.3</em> gives the name of the instruction group, an example of an operation in Python, and a typical assembly language instruction.</p>&#13;
			<table id="table005" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Instruction Group</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Typical </strong><strong class="bold">Python Code</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Assembly Language</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Arithmetic and logical</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>c = (a + b) * c</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>ADD </code><code>,r2,r3</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Data movement</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>x = y</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>MOV </code><code>,r2</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Conditional</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>if x == 4: y = 7</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>BEQ next</code></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.5 – Instruction classes</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The TC1 that we are going to design has a 32-bit instruction and can provide up to 232 = 4,294,967,296 unique instructions. In practice, the instruction provides memory addresses, numerical constants (i.e., literals), and register numbers, which means that the number of unique instructions you can define is a lot smaller.</p>&#13;
			<p lang="en-GB">TC1 has a 32-bit instruction but only a 16-bit data word. This arrangement makes it easier to design and understand the computer, and you can load a 16-bit data word with a single 32-bit instruction. Computers with 32-bit instructions and data have to use convoluted methods to load 32-bit data words, as we shall see when we introduce the ARM.</p>&#13;
			<p lang="en-GB">It may seem strange that I allow a binary number to be specified as either <code>0b1101</code> or <code>%1101</code>, and I allow hexadecimal numbers to be formatted as <code>0x1AC</code> or <code>$1AC</code>. I did this for two reasons. The first is that I was brought up in a Motorola world where the <code>%</code> and <code>$</code> prefixes were used, but now I live in a C world where the <code>0b</code> and <code>0x</code> prefixes are used. Habit makes <code>%</code> and <code>$</code> more natural for me. Secondly, I want to show you that you can choose your own formats and conventions.</p>&#13;
			<p lang="en-GB">TC1’s instruction set is designed for<a id="_idIndexMarker206"/><a id="_idIndexMarker207"/> simplicity rather than computational elegance. The instruction set is realistic in terms of the concepts it involves but not in terms of its implementation. For our purposes, we have given all instructions in identical formats. In a real computer, there are usually several classes of instruction, each with its own format. By having a single format, we can simplify instruction decoding and execution.</p>&#13;
			<p lang="en-GB">A 32-bit instruction set is used by many high-performance microprocessors and is ideal for demonstration and teaching purposes. Typically, computers use the same size for data elements as they do for instructions. TC1 uses 32-bit instructions but 16-bit data elements because it is easier for students to read and manipulate 16-bit values than 32-bit values (modifying the TC1 computer to operate with 32-bit data would be a very easy task).</p>&#13;
			<p lang="en-GB">In order to write a machine-level program for TC1, you would have to hand-code each instruction into a 32-bit binary sequence. This is easy to do, but it’s horribly tedious. We have also designed a simple assembler that allows you to write instructions in assembly language form. The TC1 assembler translates an instruction in the form <code>ADD</code><code> </code>r7<code>,r2,r3</code> into a binary string such as <code>000000111101001100000000000000000</code>.</p>&#13;
			<p lang="en-GB">Normally, an assembler is a separate piece of code from a simulator. You provide the assembler with a <em class="italic">source file</em> (in text format), and the assembler creates a <em class="italic">binary code file</em> that the simulator executes. The TC1 assembler is part of the simulator, so you don’t have to worry about creating binary files for the simulator.</p>&#13;
			<p lang="en-GB">We have made the TC1 assembler as simple as possible to reduce the level of complexity and keep the final Python program reasonably short. It would take a lot more high-level language code to write a comprehensive assembler. This assembler performs no error-checking on the source program (i.e., it doesn’t detect an error when you mistype something). It supports the use of symbolic values for variables and addresses – that is, you can write <code>BEQ loop</code> rather than <code>BEQ 7</code>, where the symbolic name <code>loop</code> labels line number<code> 7</code>.</p>&#13;
			<p lang="en-GB">The TC1 assembler allows you to enter numbers in decimal, binary, or hexadecimal formats – for example, you can write <code>LDRL </code>r0<code>,255, LDRL </code>r0<code>,0xFF, or LDRL </code>r0<code>,%11111111</code>. The operation <code>LDRL</code> means, “<em class="italic">load a register with a literal (i.e., an actual) value</em>.” In each case, the instruction puts the binary value for <code>255</code> in register <code>r0</code>.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">All computers operate on data that is either in memory or in one of a few on-chip registers. Typically, a computer has between <code>2</code> and <code>32</code> on-chip registers. The TC1 computer has eight registers, <code>r0</code> to <code>r7</code>.</p>&#13;
			<p lang="en-GB">Computer instructions have many different formats, depending on the architecture of the computer. The two fundamental formats are as follows:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">CISC-style operations allow general instructions to access memory (e.g., <code>ADD </code>r3<code>,1200</code> means, add the contents of memory location 1,200 to register 3)</li>&#13;
				<li lang="en-GB">RISC-style: All data-processing operations are between registers (e.g., <code>ADD </code>r1<code>,r2,r3</code>), and the only memory accesses are <em class="italic">load a register from memory and store a register </em><em class="italic">in memory</em></li>&#13;
			</ul>&#13;
			<p lang="en-GB">Typical assembly language instruction<a id="_idIndexMarker208"/><a id="_idIndexMarker209"/> formats that we will use in our first computer are as follows:</p>&#13;
			<table id="table006" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Format</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Mnemonic</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Action</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Two address</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>MOV</code><code>  </code>r0<code>,r1</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Copy the contents of register <code>r1</code> to register <code>r0</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Three address</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>ADD</code><code>  </code>r0<code>,r1,r2</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Add the contents of register <code>r1</code> to <code>r2</code> put the result in <code>r0</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Literal</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>ADDL </code>r0<code>,r1,24</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Add literal <code>24</code> to <code>r1</code> and put the result in <code>r0</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Branch</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>BEQ</code><code>  </code><code>5</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">If z-bit set, jump to instruction at address <code>5</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Load register indirect</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>LDRI</code><code>  </code>r0<code>,[r1,10]</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Load <code>r0</code> with the contents of memory at address <code>r1 + </code><code>10</code></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p lang="en-GB">There is no universal assembly language format, and conventions differ from assembler to assembler (even for the same machine). For example, one assembly language might use the format <code>MOV </code>r1<code>,r2</code> to load <code>r1</code> with <code>r2</code>, and the other might use it to load <code>r2</code> with <code>r1</code> – that is, the destination can be on the left or the right. I put the destination for operands on the left, which appears to be the more common convention. I also put the destination in bold font as a reminder.</p>&#13;
			<p lang="en-GB">A simple example of a program that adds together the first 10 integers is shown in the following code snippet in a hypothetical assembly language. This is not the most efficient way of writing this fragment of code; it’s just intended as a demonstration. The version of the TC1 assembler we design here accepts uppercase or lowercase characters, and either a space or a comma can be used as a separator – for example, you can happily write the following:</p>&#13;
			<p lang="en-GB"><code>lOOp aDdL r1 </code><code>R2,r3 or</code></p>&#13;
			<p lang="en-GB"><code>Loop </code><code>ADDL R1,r2,R3.</code></p>&#13;
			<p lang="en-GB">Consider the following example of TC1 assembly language. Note that I use <code>@</code> to indicate a comment field because that is the standard for the ARM assembly language, which we will introduce later. We will continue to use the <code>#</code> symbol for comments in Python.</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
        LDRL <strong class="bold">r0</strong>,0          @ Load register r0 with 0 (the sum)&#13;
        LDRL <strong class="bold">r1</strong>,0          @ Load register r1 with 0 (the counter)&#13;
Loop    ADDL <strong class="bold">r1</strong>,r1,1       @ Increment the counter in r1&#13;
        ADD  <strong class="bold">r0</strong>,r0,r1      @ Add the count to the sum in r0&#13;
        CMPL r1,10         @ Compare the count with 10</pre>&#13;
			<pre class="source-code">        BNE  Loop          @ Branch back to Loop until all numbers added</pre>&#13;
			<h2 id="_idParaDest-59" lang="en-GB"><a id="_idTextAnchor059"/>CISC and RISC</h2>&#13;
			<p lang="en-GB">In this book, we use the terms RISC and CISC repeatedly. These two terms are vital to the understanding of a modern computer. They describe two different approaches to the implementation of a computer. The early 1980s saw the CISC versus RISC war when two different<a id="_idIndexMarker210"/><a id="_idIndexMarker211"/> architectures competed for the computing market. The term <strong class="bold">complex instruction set computer (CISC)</strong> is analogous<a id="_idIndexMarker212"/><a id="_idIndexMarker213"/> to the<a id="_idIndexMarker214"/><a id="_idIndexMarker215"/> term <em class="italic">analog watch</em>. When the digital watch was invented, watches with moving hands suddenly became analog watches in order to distinguish them from <a id="_idIndexMarker216"/><a id="_idIndexMarker217"/>digital watches. Similarly, the term <em class="italic">complex instruction set computer</em> didn’t exist until it was coined to contrast with the <a id="_idIndexMarker218"/><a id="_idIndexMarker219"/>new <strong class="bold">reduced instruction set </strong><strong class="bold">computer (RISC)</strong>.</p>&#13;
			<p lang="en-GB">From the moment computers were<a id="_idIndexMarker220"/><a id="_idIndexMarker221"/> invented, they just grew. As technology advanced, new features were just bolted onto existing computers. Someone once said that if the aircraft had developed like the computer, every jumbo jet would have had a 1903 Wright Flyer at its core. This approach wasn’t cost-effective because technology had changed so dramatically that the design of computers needed to be reconsidered. In particular, memory capacity had grown exponentially, and the cost per bit had plummeted. Similarly, the 8- and 16-bit wordlengths gave way to the 32- and 64-bit instruction sets. Doing things the old way was not efficient.</p>&#13;
			<p lang="en-GB">First- and second-generation microprocessors were <em class="italic">accumulator</em>-based. They applied operations to an accumulator on the processor and a memory location. Instructions were called <em class="italic">one-and-a-half addresses</em> because they had a memory address and an accumulator address (since there were only a few accumulators, they were jokingly referred to as having “<em class="italic">half an address</em>”). To perform <code>C = A + B</code> (where <code>A</code>, <code>B</code>, and <code>C</code> are memory addresses), you would have to write the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
LDA A            @ Load accumulator with A&#13;
ADD B            @ Add B to the accumulator&#13;
STA C            @ Store the accumulator in C</pre>&#13;
			<p lang="en-GB">Passing all data through the accumulator creates a bottleneck. Because computer speed increased faster than memory speed, programmers wanted to keep as much data on-chip as possible.</p>&#13;
			<p lang="en-GB">The RISC solution adopted a <em class="italic">register-to-register</em> architecture. The only operations permitted on memory are the transfer of data between a register and memory. Instead of having one or two accumulators, RISC processors have 16 or 32 registers. The preceding code on a RISC processor can be typically represented by the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
LDR <strong class="bold">r0</strong>,[r1]      @ Load r0 with data pointed at by r1&#13;
LDR <strong class="bold">r2</strong>,[r3]      @ Load r2 with data pointed at by r3&#13;
ADD <strong class="bold">r4</strong>,r0,r2     @ Add r0 and r2, result in r4&#13;
STR r4,<strong class="bold">[r5]</strong>      @ Store r4 in memory pointed at by r5</pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">All data movement is between memory and a register, and data-processing operations apply only to registers. Instructions have three operands.</p>&#13;
			<p lang="en-GB">RISC computers introduced other enhancements, such as overlapping the execution of instructions (called <em class="italic">pipelining</em>). Many in the 1980s expected Intel’s CISC computers to die out. They didn’t. Intel cleverly incorporated RISC features into its CISC processors. AMD designed a RISC architecture that took Intel’s CISC instructions and translated them into a sequence of RISC commands before executing them.</p>&#13;
			<p lang="en-GB">To summarize, CISC processors have instruction sets that perform operations between an operand in memory and one in a register. All RISC data-processing operations take place between operands in registers. The only memory operations RISC processors permit are <em class="italic">loading a register from memory and storing a register </em><em class="italic">in memory</em>.</p>&#13;
			<h2 id="_idParaDest-60" lang="en-GB"><a id="_idTextAnchor060"/>Two ways of representing literals</h2>&#13;
			<p lang="en-GB">Assemblers differ in how they represent <a id="_idIndexMarker222"/><a id="_idIndexMarker223"/>instructions because assemblers developed rapidly over a few short years in competitive industries. Each manufacturer designed an assembler for their own microprocessors. Some adopted a left-to-right convention with the destination operand on the right, and some adopted a right-to-left convention with the destination operand on the right. Consequently, one manufacturer’s <code>mov a,b</code> meant <code>a ← b</code>, and another’s meant <code>b ← a</code>. Similarly, mnemonics were also unstandardized – for example, <code>MOVE, MOV</code>, and <code>LDA</code> all define a copy operation.</p>&#13;
			<p lang="en-GB">Since the assembler is just a human-readable version of machine code, it doesn’t actually matter how we represent an instruction. It’s the binary code that gets executed, irrespective of how we represent it in text form. However, from a teaching and learning perspective, the variations in conventions are a nuisance. Consider the representation of a literal value in an instruction.</p>&#13;
			<p lang="en-GB">Some assemblers represent a literal by using a special instruction – for example, ADD<code> </code>r1<code>,r2,r3</code> for a three-register addition, and <code>ADDL r1,r2,24</code> for a literal operand. Other assemblers use the <em class="italic">same</em> mnemonic in both cases but prefix the literal by a symbol to indicate that it’s a literal operation – for example, <code>ADD r1,r2,#25</code>. Some assemblers use <code>#</code> to indicate a literal and others use <code>%</code>.</p>&#13;
			<p lang="en-GB">In this text, we’ve used the <code>ADDL</code> convention in the design of some simulators, but we will use the <code>#</code> convention when we introduce the ARM processor because that’s used by ARM assemblers. In retrospect, if I were writing this book again, I think I might have been tempted to use only one representation, the <code>#</code> symbol. However, by using <code>ADD</code> and <code>ADDL</code>, I was able to simplify the Python code because the <em class="italic">decision point</em> between register and literal operands was made when examining the mnemonic, not when examining the literal.</p>&#13;
			<h1 id="_idParaDest-61" lang="en-GB"><a id="_idTextAnchor061"/>Summary</h1>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">In this key chapter, we introduced the von Neumann computer with its <code>fetch-execute</code> cycle, where an instruction is read from memory, decoded, and executed in a two-phase operation. It is precisely these actions that we will learn to simulate in later chapters in order to build a computer in software. We have looked at the flow of information as an instruction is executed. The model of the computer we introduced here is the traditional model and does not take into account current technology that executes multiple instructions in a pipeline.</p>&#13;
			<p lang="en-GB">We also looked at the instruction format and described how it has several fields – for example, the opcode that defines the operation and the data required by the operation (e.g., addresses, literals, and register numbers). You will eventually be able to design your own instructions (thereby defining the computer’s instruction set architecture) and create a computer that will execute these instructions.</p>&#13;
			<p lang="en-GB">While describing the operation of a von Neumann computer, we introduced sufficient Python code to show the direction we are heading in and hint at how simulation can be carried out.</p>&#13;
			<p lang="en-GB">In the next chapter, we will begin to look more closely at the concept of an interpreter that reads a machine-level instruction and carries out its intended actions.</p>&#13;
		</div>&#13;
	</div></body></html>