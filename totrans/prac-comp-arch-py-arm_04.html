<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer036" class="_idGenObjectStyleOverride-1">&#13;
			<h1 id="_idParaDest-42" class="chapter-number" lang="en-GB"><a id="_idTextAnchor042"/>3</h1>&#13;
			<h1 id="_idParaDest-43" lang="en-GB"><a id="_idTextAnchor043"/>Data Flow in a Computer</h1>&#13;
			<p lang="en-GB">In this chapter, we will learn how a computer executes an instruction. We have to understand how a computer operates internally before we can simulate its behavior in Python. We will also introduce the concept of a computer instruction (the smallest operation that it can be commanded to perform) and show you what a computer instruction <span class="No-Break">looks like.</span></p>&#13;
			<p lang="en-GB">What is a computer? How does it work? What does it do? We will answer these questions by demonstrating how a computer can be designed using Python, and how programs can be run on this simulated computer. Here, we are interested only in how a computer behaves at the machine level – that is, the type of operations it carries out. We are not concerned with the internal design of the computer or how the computer is implemented electronically (i.e., the circuits used to build <span class="No-Break">a computer).</span></p>&#13;
			<p lang="en-GB">We will cover the following topics in <span class="No-Break">this chapter:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">The instruction set <span class="No-Break">architecture (ISA)</span></li>&#13;
				<li lang="en-GB">The Von <span class="No-Break">Neumann architecture</span></li>&#13;
				<li lang="en-GB">An <span class="No-Break">assembly-level program</span></li>&#13;
				<li lang="en-GB">The <span class="No-Break">machine-level instruction</span></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-44" lang="en-GB"><a id="_idTextAnchor044"/>Technical requirements</h1>&#13;
			<p lang="en-GB">You can find the programs used in this chapter on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter03"><span class="No-Break">https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter03</span></a><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-45" lang="en-GB"><a id="_idTextAnchor045"/>The Instruction Architecture Level (ISA)</h1>&#13;
			<p lang="en-GB">In this section, we will show how a <a id="_idIndexMarker103"/><a id="_idIndexMarker104"/>computer can be described in different ways and explain that this book is about computers from the point of view of their instruction sets <span class="No-Break">and capabilities.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The term <em class="italic">computer</em> means different things to different people. To an engineer, a computer is a collection of circuits that perform a certain function; to a pilot, it’s a machine that flies an aircraft from one airport to another and can land it in <span class="No-Break">thick fog.</span></p>&#13;
			<p lang="en-GB"><em class="italic">Table 3.1</em> demonstrates the hierarchy of computer languages and structures. At the top you have the actual application for which the computer is used. At this level, the application may be a user-selected program (flight simulator), or it may be a program that runs on an embedded system (e.g., an ATM). Communication with that application is universal and independent of the actual computer on which the <span class="No-Break">application runs.</span></p>&#13;
			<table id="table001-2" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="No-Break"><strong class="bold">Level</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="No-Break"><strong class="bold">Realization</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="No-Break"><strong class="bold">Universality</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="No-Break">1. Application</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">Word, Excel, Photoshop, and <span class="No-Break">flight sim</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="No-Break">Universal</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">2. <span class="No-Break">High-level language</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB">Python, <span class="No-Break">Java, C++</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="No-Break">Universal</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB">3. <span class="No-Break">Assembly language</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB">ADD r1,r2, <span class="No-Break">and r3</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="No-Break">Computer family</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB">4. Binary (<span class="No-Break">machine code)</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="No-Break"><strong class="source-inline CharOverride-1">00111010111100001010101110001010</strong></span><span class="No-Break"> binary</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="No-Break">Computer family</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-1" lang="en-GB">5. <span class="No-Break">Circuit (microprocessor)</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-1" lang="en-GB">Gates, adders, counters, <span class="No-Break">and memory</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-1" lang="en-GB">Specific <span class="No-Break">family member</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="No-Break">6. Silicon</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-1" lang="en-GB">The physical <span class="No-Break">silicon chip</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="No-Break">Specific chip</span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.1 – The hierarchy of computer languages and systems</p>&#13;
			<p lang="en-GB">Below the application level, you <a id="_idIndexMarker105"/><a id="_idIndexMarker106"/>have the high-level language used to build the application. This language may be Python, Java, C++, and so on. High-level languages were designed to enable programmers to build applications that run on different types of computers. For example, a program written in Python will run on any machine for which a Python interpreter or compiler is available. Before the introduction of high-level languages, you had to design the application for each <span class="No-Break">specific computer.</span></p>&#13;
			<p lang="en-GB">Most computers are currently unable to directly execute high-level languages. Each computer has a native language that is understood by a computer family (e.g., Intel Core, Motorola 68K, ARMv4, and MIPS). These languages are related to the structure of the computer and its hardware, which is expressed by a computer’s ISA. This level is represented by two layers in <em class="italic">Table 3.1</em>, <em class="italic">assembly language and </em><span class="No-Break"><em class="italic">machine code</em></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The layer below the high-level language is the assembly language level, which is a human representation of the computer’s binary machine code. People can’t remember or easily manipulate strings of 1s and 0s. Assembly language is a textual version of machine code. For example, the assembly language operation <strong class="source-inline">ADD </strong><span class="pcode-bold">A</span><strong class="source-inline">,B,C</strong> means add <strong class="source-inline">B</strong> to <strong class="source-inline">C</strong> and put the result in <strong class="source-inline">A (i.e., A = B + C)</strong> and might be represented in machine code <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">00110101011100111100001010101010</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The <em class="italic">machine code</em> layer is the binary code that the computer actually executes. In the PC world, a machine-code program has the <strong class="source-inline">.exe</strong> file extension because it can be <em class="italic">executed</em> by the computer. All computers execute binary code, although this layer is different for each type of computer – for example, Intel Core, ARM, and MIPS are three computer families, and each has its own <span class="No-Break">machine code.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Although the assembly language layer is a representation of the machine code layer, there is a difference between these two layers. The assembly language layer includes facilities to help a programmer write programs, such as the ability to define variable names and to link independently written modules into a single <span class="No-Break">machine-code program.</span></p>&#13;
			<p lang="en-GB">Below the machine-code layer are the electronic circuits, which are generically called microprocessors, or just chips. This is the hardware that companies such as Intel make, and it’s this hardware that reads programs from memory and executes them. In general, this layer cannot be programmed or modified any more than you can change the number of cylinders in your <span class="No-Break">car’s engine.</span></p>&#13;
			<p lang="en-GB">Today, some digital systems do have circuits that can be modified electronically – that is, it is possible for the circuits of a computer to be restructured by changing the routing of signals through a circuit called a <strong class="bold">field programmable gate array (FPGA)</strong>. The FPGA <a id="_idIndexMarker107"/>contains a very large number of gates and special-purpose circuit blocks that can be interconnected by programming. An FPGA can be programmed to perform dedicated applications such as signal processing in medical or <span class="No-Break">aerospace systems.</span></p>&#13;
			<p lang="en-GB">At the electronic circuit<a id="_idIndexMarker108"/><a id="_idIndexMarker109"/> level, it’s possible to have different versions of the same set of circuits. For example, a microprocessor can be realized using 7 nm or 14 nm device technology (these figures express the basic size of components on the chip, and smaller is better). The two circuits may be operationally identical in every way, but one version may be faster, cheaper, more reliable, or use less power than <span class="No-Break">the other.</span></p>&#13;
			<p lang="en-GB">This book is about assembly language and machine code layers, and the layers in <em class="italic">Table 3.1</em> allow us to write programs that are executed by a computer. By the end of this book, you will be able to design your own machine code, your own assembly language, and your <span class="No-Break">own computer.</span></p>&#13;
			<p lang="en-GB">In the 1940s and 1950s, all programming was done in assembly language (or even machine code). Not today. Writing assembly language programs is tedious and very challenging. Computer scientists have created high-level languages such as C++, Java, Python, and Fortran. These languages were developed to allow programmers to write programs in a near-English language that expresses more powerful ideas than assembly language. For example, in Python, you can print the text <strong class="source-inline">"Hello World"</strong> on the screen with the instruction <strong class="source-inline">print("Hello World.")</strong>. If you wanted to do that in assembly language, you would have to write out, say, 100 individual machine-level instructions. Moreover, the Python version will run on all computers, but the machine-level version has to be written for each specific <span class="No-Break">computer type.</span></p>&#13;
			<p lang="en-GB">The high-level language’s secret is the <em class="italic">compiler</em>. You write a program in a high-level language and then compile it to the machine code of the specific computer you want to run it on. You may come across the term <em class="italic">interpreter</em>, which performs the same function as a compiler. A compiler translates an entire high-level language program into machine code, whereas an interpreter performs the translation line by line, executing each line as it <span class="No-Break">is interpreted.</span></p>&#13;
			<p lang="en-GB">Writing code in assembly language is not popular today (outside academia). However, it has the advantage that (in principle) you can write optimized code that runs faster than <span class="No-Break">compiled code.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">A principal theme of this book is <em class="italic">learning by doing</em>. We will explain what a computer is, introduce the instructions it executes, and then show how it can be built (i.e., simulated) in a high-level language. We will call the program we are going to<a id="_idIndexMarker110"/><a id="_idIndexMarker111"/> construct <strong class="bold">TC1 (Teaching Computer 1)</strong>. This program will execute the assembly language of a hypothetical computer. You will be able to write a program in assembly language, and the TC1 program will read the instructions and execute them as if they were running on a real <span class="No-Break">TC1 computer.</span></p>&#13;
			<p lang="en-GB">When you run the program, you can execute instructions one by one and observe their outcomes v – that is, you can read the values of data in registers and memory as the program runs. The purpose of this computer is not to perform useful computing functions but to show what instructions look like and how they <span class="No-Break">are executed.</span></p>&#13;
			<p lang="en-GB">This computer demonstrates how instructions are executed and how to use assembly language. Moreover, you can modify the instruction set of the computer to create your own special-purpose instructions. You can remove instructions, add new instructions, extend instructions, and even change the format of instructions. TC1 was designed to enable students that study computer architecture to understand instruction formats, instruction decoding, and instruction <a id="_idIndexMarker112"/><a id="_idIndexMarker113"/>complexity. It is also very helpful to understand addressing modes (i.e., how data is located in memory), such as pointer-based addressing. We will discuss these topics in more <span class="No-Break">detail later.</span></p>&#13;
			<p lang="en-GB">TC1 has several useful facilities that are not present in conventional computer instruction sets. For example, you can directly input data into the computer from the keyboard, and you can load random numbers into memory. This allows you to create data for <span class="No-Break">testing purposes.</span></p>&#13;
			<p lang="en-GB">First, we need to introduce the prototype computer, the so-called von Neumann machine, which was created in the 1940s and 1950s and became the template for most modern computers. In reality, there’s been quite a departure from the pure von Neumann architecture, but we still tend to use the term to distinguish between other classes of computers (e.g., analog computers, neural networks, and <span class="No-Break">quantum computers).</span></p>&#13;
			<h2 id="_idParaDest-46" lang="en-GB"><a id="_idTextAnchor046"/>ISAs – the Naming of Parts</h2>&#13;
			<p lang="en-GB">Before we introduce the structure of a computer, we need to introduce several terms that you need <span class="No-Break">to know:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB"><strong class="bold">Bit</strong>: The smallest unit of data in <a id="_idIndexMarker114"/><a id="_idIndexMarker115"/>a computer is the bit, which is <strong class="source-inline">0</strong> or <strong class="source-inline">1</strong>. You can set a bit to <strong class="source-inline">0</strong>, to <strong class="source-inline">1</strong>, or toggle it (flip <span class="No-Break">it over).</span></li>&#13;
				<li lang="en-GB"><strong class="bold">Word</strong>: A word is a group of bits – typically, <strong class="source-inline">8</strong>, <strong class="source-inline">16</strong>, <strong class="source-inline">32</strong>, or <strong class="source-inline">64</strong>. In general, the word is the basic unit of data that the computer operates on. An<a id="_idIndexMarker116"/><a id="_idIndexMarker117"/> instruction such as <strong class="source-inline">ADD </strong><span class="pcode-bold">a</span><strong class="source-inline">,b,c</strong> executed on a 64-bit computer would add the 64-bits of word <strong class="source-inline">b</strong> to the 64-bits or word <strong class="source-inline">c</strong> and put the 64-bit result in word <strong class="source-inline">a</strong>. The <strong class="source-inline">a</strong>, <strong class="source-inline">b</strong>, and <strong class="source-inline">c</strong> variables refer to storage locations in either memory <span class="No-Break">or registers.</span></li>&#13;
				<li lang="en-GB"><strong class="bold">Instruction</strong>: A machine-level <a id="_idIndexMarker118"/><a id="_idIndexMarker119"/>instruction is the most primitive operation that a programmer can specify and defines a single action carried out by the computer. Even more primitive level operations may exist on the silicon, but a programmer cannot directly access these. Instructions largely fall into three classes – data movement that copies data from one place to another, arithmetic and logical operations that process data, and instruction sequence commands that determine the order in which instructions are carried out (necessary to implement decisions of the form <em class="italic">if this, then </em><span class="No-Break"><em class="italic">do that</em></span><span class="No-Break">).</span></li>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB"><strong class="bold">Immediate access memory</strong>: This is<a id="_idIndexMarker120"/><a id="_idIndexMarker121"/> often just called memory or RAM or DRAM by many programmers. It is where programs and data are stored during the execution of a program. The term <em class="italic">random access memory</em> today means the same thing. However, strictly speaking, the term <em class="italic">random</em> indicates that the access time for a memory element chosen at random is the same for every element (unlike, say, magnetic tape, where the access time depends on where data is on <span class="No-Break">the tape).</span></li>&#13;
				<li lang="en-GB"><strong class="bold">Register</strong>: A register is a single-word memory element that is located on the chip. It is used to store frequently accessed data. Because there are typically <strong class="source-inline">8</strong> to <strong class="source-inline">64</strong> registers on a chip, it requires only <strong class="source-inline">3</strong> to <strong class="source-inline">6</strong> bits to specify a given register, rather than the <strong class="source-inline">32</strong> or <strong class="source-inline">64</strong> bits typically used to access a memory location. Most computer operations act <a id="_idIndexMarker122"/><a id="_idIndexMarker123"/>on the contents of registers rather than the main memory. There is no universal convention for the naming of registers. In this chapter, we will generally use for register names – for example, <strong class="source-inline">INC r3</strong> increments the contents of register <strong class="source-inline">r3</strong> <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">.</span></li>&#13;
				<li lang="en-GB"><strong class="bold">Address</strong>: The location of a <a id="_idIndexMarker124"/><a id="_idIndexMarker125"/>data item in memory is called its address. Modern computer addresses are typically <strong class="source-inline">32</strong> bits or <strong class="source-inline">64</strong> bits long. However, 8- and 16-bit computers are frequently used in embedded control applications (e.g., toys, TVs, washing machines, <span class="No-Break">and automobiles).</span></li>&#13;
				<li lang="en-GB"><strong class="bold">Literal</strong>: A literal value is just that, an <a id="_idIndexMarker126"/><a id="_idIndexMarker127"/>actual value. If you have an instruction <strong class="source-inline">ADD </strong><span class="pcode-bold">a</span><strong class="source-inline">,b,5</strong> where <strong class="source-inline">5</strong> is a literal, then it means, add the <strong class="source-inline">5</strong> integer to <strong class="source-inline">b</strong>. Some computers use a <strong class="source-inline">#</strong> to indicate a literal – for example, <strong class="source-inline">ADD </strong><span class="pcode-bold">a</span><strong class="source-inline">,b,#12</strong> means, add the number <strong class="source-inline">12</strong> to the contents of memory <span class="No-Break">location </span><span class="No-Break"><strong class="source-inline">b</strong></span><span class="No-Break">.</span></li>&#13;
				<li lang="en-GB"><strong class="bold">Move</strong>: This is the most<a id="_idIndexMarker128"/><a id="_idIndexMarker129"/> inaccurate word in computing. In plain English, it indicates that something was at <strong class="source-inline">A</strong> and then ends up at <strong class="source-inline">B</strong> – simplicity itself. In computing, the term <em class="italic">move</em> indicates that something that was at <strong class="source-inline">A</strong> ends up at <strong class="source-inline">B</strong>, as well – that is, it is now in both <strong class="source-inline">A</strong> and <strong class="source-inline">B</strong>. In other words, programmers use <em class="italic">move</em> to mean <em class="italic">copy</em>. If you <em class="italic">move</em> data from a register to memory, the data remains in the register and is <em class="italic">copied</em> to memory. We will introduce the prototype computer in the <span class="No-Break">following section.</span></li>&#13;
			</ul>&#13;
			<p lang="en-GB">The next step is to introduce the notion of the von Neumann computer, which can be regarded as the grandfather of most modern computers. The mathematician von Neumann was one of the authors of <em class="italic">The First Draft Report on the EDVAC</em> in 1945, which characterized the structure of the <span class="No-Break">digital computer.</span></p>&#13;
			<h1 id="_idParaDest-47" lang="en-GB"><a id="_idTextAnchor047"/>The von Neumann architecture</h1>&#13;
			<p lang="en-GB">The prototype computer is often called a stored program von Neumann machine. It has a program in memory that is executed instruction by<a id="_idIndexMarker130"/><a id="_idIndexMarker131"/> instruction sequentially. Moreover, the program is stored in the same memory as the data that the computer operates on. This structure is named in honor of one of the pioneers of computing, John von Neumann. Once you understand the von Neumann machine, you understand <span class="No-Break">all computers.</span></p>&#13;
			<p lang="en-GB"><span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.1</em> illustrates a simplified von Neumann machine that contains three <span class="No-Break">basic elements:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">A memory that holds the program and any data used by <span class="No-Break">the program</span></li>&#13;
				<li lang="en-GB">A set of registers that each holds one<a id="_idIndexMarker132"/><a id="_idIndexMarker133"/> word of data (in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.1</em>, there is one <span class="No-Break">register, </span><span class="No-Break"><strong class="source-inline">r0</strong></span><span class="No-Break">)</span></li>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB">An <strong class="bold">arithmetic and logic unit (ALU)</strong> that performs all <span class="No-Break">data processing</span></li>&#13;
			</ul>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer030" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_3.01_B19624.jpg" alt="Figure 3.1 – The von Neumann architecture" width="1471" height="1224"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – The von Neumann architecture</p>&#13;
			<p lang="en-GB">The memory contains instructions to be executed. Both data and instructions are stored in binary form, although we will often <a id="_idIndexMarker134"/><a id="_idIndexMarker135"/>show operations in assembly language form for ease of reading. Each instruction is read from memory, decoded, and interpreted (i.e., executed). The principal simplification of <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.1</em> is the lack of a means of executive conditional operations (i.e., <strong class="source-inline">if… then</strong>). We will fix <span class="No-Break">that later.</span></p>&#13;
			<p lang="en-GB"><span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.1</em> looks complicated. It’s not. We’ll explain its operation step by step. Once we see how a computer operates in principle, we can look at how it may be implemented in software. We describe the operation of a very simple, so-called <em class="italic">one-and-a-half</em> address machine, whose instructions have two operands – one in memory and one in a register. Instructions are written in the form <strong class="source-inline">ADD </strong><span class="pcode-bold">B</span><strong class="source-inline">,A</strong>, which adds <strong class="source-inline">A</strong> to <strong class="source-inline">B</strong> and puts the result in <strong class="source-inline">B</strong>. Either <strong class="source-inline">A</strong> or <strong class="source-inline">B</strong> must be in a register. Both operands may be in registers. The term <em class="italic">one-and-a-half address</em> machine is a comment about the fact that the memory address is 16 to 32 bits and selects one of millions of memory locations, whereas the register address is typically 2 to 6 bits and selects only one of a small number <span class="No-Break">of registers.</span></p>&#13;
			<p lang="en-GB">Instead of introducing the computer all at once, we will build up a CPU step by step. This approach helps demonstrate how an instruction is executed because the development of the computer broadly follows the sequence of events taking place during the execution of an instruction. Real computers don’t execute an instruction from start to finish. Today’s computers <em class="italic">overlap</em> the execution of instructions. As soon as one instruction is fetched from memory, the next instruction is fetched before the previous instruction has completed its execution. This mechanism is called <em class="italic">pipelining</em> and is a major<a id="_idIndexMarker136"/><a id="_idIndexMarker137"/> aspect of a <a id="_idIndexMarker138"/><a id="_idIndexMarker139"/>modern computer’s organization. Pipelining is analogous to the automobile production line, where computer instructions are executed in stages so that several instructions may be in the process of being executed at the same time. We will begin with the address paths that are used to locate the next instruction to be executed. In this book, we will not cover pipelining because it is a factor or implementation and not an instruction <span class="No-Break">set design.</span></p>&#13;
			<h2 id="_idParaDest-48" lang="en-GB"><a id="_idTextAnchor048"/>The address path</h2>&#13;
			<p lang="en-GB">An address is a number<a id="_idIndexMarker140"/><a id="_idIndexMarker141"/> representing the location of an item of data within memory. <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.2</em> shows only the address paths needed to read an instruction <span class="No-Break">from memory.</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer031" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_3.02_B19624.jpg" alt="Figure 3.2 – The CPU’s address paths" width="1770" height="1129"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 3.2 – The CPU’s address paths</p>&#13;
			<p lang="en-GB">An address path is a data highway that moves addresses between the CPU and memory. The address tells memory where we want to read data from, or where we want to store it. For example, the instruction <strong class="source-inline">ADD </strong><span class="pcode-bold">r0</span><strong class="source-inline">,234</strong> indicates the operation <em class="italic">read the contents of memory location 234, add them to the contents of register r0, and then put the result in r0</em>. <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.2</em> omits the data paths required to execute instructions to <span class="No-Break">avoid clutter.</span></p>&#13;
			<p lang="en-GB">There are three types of information flow in a computer – address, data, and control. Data comprises the instructions, constants, and variables stored in <a id="_idIndexMarker142"/><a id="_idIndexMarker143"/>memory and registers. Control paths comprise the signals that trigger events, provide clocks, and determine the flow of data and addresses throughout <span class="No-Break">the computer.</span></p>&#13;
			<h2 id="_idParaDest-49" lang="en-GB"><a id="_idTextAnchor049"/>Reading the instruction</h2>&#13;
			<p lang="en-GB">Before the CPU can execute an instruction, the instruction<a id="_idIndexMarker144"/><a id="_idIndexMarker145"/> must be brought from the computer’s memory. We begin our description of the way in which a program is executed with the CPU’s <em class="italic">program counter</em> (also called <em class="italic">instruction pointer</em> or <em class="italic">location counter</em>). The expression <em class="italic">program counter</em> is a misnomer. The program counter doesn’t count programs or anything else, but instead contains the address of the next instruction in memory to <span class="No-Break">be executed.</span></p>&#13;
			<p lang="en-GB">The program counter <em class="italic">points</em> to the next instruction to be executed. If, for example, <strong class="source-inline">[PC] = 1234</strong> (i.e., the <strong class="source-inline">PC</strong> contains the number <strong class="source-inline">1234</strong>), the next instruction to be executed will be found in memory <span class="No-Break">location </span><span class="No-Break"><strong class="source-inline">1234</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">Fetching an instruction begins with the contents of the program counter being moved to the memory address register (i.e., <strong class="source-inline">[MAR]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">[PC]</strong>). Once the contents of the program counter have been transferred to the memory address register, the contents of the program counter are incremented and moved back to the program counter, <span class="No-Break">as follows:</span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">[PC]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">[PC] + </strong><span class="No-Break"><span class="pcode-bold">1</span></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The PC increment is <strong class="source-inline">1</strong> because the next instruction is one location on. Real computers are normally byte-addressed – that is, the bytes are numbered sequentially <strong class="source-inline">0, 1, 2, 3 …</strong> Modern computers have 32- or 64-bit data words – that is, 4- or 8-byte words. Consequently, real computers increment the PC by 4 or 8 after <span class="No-Break">each instruction.</span></p>&#13;
			<p lang="en-GB">After this operation, the program counter points to the <em class="italic">next</em> instruction while the current instruction <span class="No-Break">is executed.</span></p>&#13;
			<p lang="en-GB">The <strong class="bold">memory address register (MAR)</strong> holds the address <a id="_idIndexMarker146"/><a id="_idIndexMarker147"/>of the location<a id="_idIndexMarker148"/><a id="_idIndexMarker149"/> in the memory into which data is written in a write cycle, or from which data is read in a <span class="No-Break">read cycle.</span></p>&#13;
			<p lang="en-GB">When a <em class="italic">memory read cycle</em> is performed, the <a id="_idIndexMarker150"/><a id="_idIndexMarker151"/>contents of the memory location specified by the MAR are read from the memory and transferred to the <strong class="bold">memory buffer register (MBR)</strong>. We can <a id="_idIndexMarker152"/><a id="_idIndexMarker153"/>represent this read operation in RTL terms <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code">[MBR] <span class="CharOverride-3">←</span> [[MAR]]   <span class="sc-comment">@ A read operation (example of indirect addressing)</span></pre>&#13;
			<p lang="en-GB">We interpret the <strong class="source-inline">[[MAR]]</strong> expression as <em class="italic">the contents of the memory whose address is given by the contents of the MAR</em>. The memory buffer register is a temporary holding place for data received from memory in a read cycle, or for data to be transferred to <a id="_idIndexMarker154"/><a id="_idIndexMarker155"/>memory in a write cycle. Some texts refer to the MBR as the <strong class="bold">memory data register (MDR).</strong> At this point in the execution of an instruction, the MBR contains the bit pattern of the instruction to <span class="No-Break">be executed.</span></p>&#13;
			<p lang="en-GB">The instruction is next moved from the MBR to the <strong class="bold">instruction register (IR)</strong>, where it is divided into two fields. A <em class="italic">field</em> is part of a word in which the bits are <a id="_idIndexMarker156"/><a id="_idIndexMarker157"/>grouped together into a logical entity – for example, a person’s name can be divided into two fields, the given name and the family name. One field in the IR contains the <em class="italic">operation code</em> (opcode) that tells the CPU what operation is to be carried out. The other field, called the <em class="italic">operand field</em>, contains the address of the data to be used by the instruction. The operand field can also provide a constant to be employed by the operation code when immediate or literal addressing is used – that is, when the operand is an actual (i.e., literal) value and not an address. For our current purposes, the register address is considered to be<a id="_idIndexMarker158"/><a id="_idIndexMarker159"/> part of the instruction. Later, we will introduce computers with multiple registers. Real computers divide the instruction into more than two fields – for example, there may be two or three <span class="No-Break">register-select fields.</span></p>&#13;
			<p lang="en-GB">The <strong class="bold">control unit (CU)</strong> takes the opcode<a id="_idIndexMarker160"/><a id="_idIndexMarker161"/> from the instruction register, together with a stream of clock pulses, and generates signals that control all parts of the CPU. The time between individual clock pulses is typically in the range 0.3 ns to 100 ns (i.e., 3 x 10<span class="superscript">-10</span> to 10<span class="superscript">-7</span> s), corresponding to frequencies of 3.3 GHz to 10 MHz. The CU is responsible for moving the contents of the program counter into the MAR, executing a read cycle, and moving the contents of the MBR to <span class="No-Break">the IR.</span></p>&#13;
			<p lang="en-GB">Instructions are executed in a two-phase <em class="italic">fetch-execute cycle</em>. During the <em class="italic">fetch phase</em>, the instruction is read from memory and decoded by the control unit. The fetch phase is followed by an <em class="italic">execute phase</em>, in which the control unit generates all the signals necessary to execute the instruction. The following RTL notation describes the sequence of operations that take place in a fetch phase. <strong class="source-inline">FETCH</strong> is a label that serves to indicate a particular line in the sequence of operations. The notation IR<span class="subscript">opcode</span> means the operation-code field of the instruction register. We use <strong class="source-inline">#</strong> to indicate a comment in Python and <strong class="source-inline">@</strong> in assembly language to be compatible with ARM’s convention. Some assemblers use a semicolon to indicate a <span class="No-Break">comment field:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>FETCH [MAR] <span class="CharOverride-3">←</span> [PC]        <span class="sc-comment">@ Copy contents of the PC to the MAR</span></span>&#13;
<span>      [PC]  <span class="CharOverride-3">←</span> [PC] + 1    <span class="sc-comment">@ Increment the contents of the PC to point to next instruction</span></span>&#13;
<span>      [MBR] <span class="CharOverride-3">←</span> [[MAR]]     <span class="sc-comment">@ Read the instruction from memory</span></span>&#13;
<span>      [IR]  <span class="CharOverride-3">←</span> [MBR]       <span class="sc-comment">@ Move the instruction to the instruction register for processing</span></span></pre>&#13;
			<pre class="source-code">      CU    <span class="CharOverride-3">←</span> [IRopcode]  <span class="sc-comment">@ Transmit the opcode to the </span><span class="sc-comment">control unit</span></pre>&#13;
			<p lang="en-GB">The following is an example of how we can code the fetch cycle as a function in Python, together with the code needed to test it. We define a 12-bit instruction with a 4-bit opcode and an 8-bit address. The memory has 16 locations, and we load the first two with dummy values to test the program. The Python expression p &gt;&gt; q takes the binary value p and shifts it q places right, and <strong class="source-inline">&amp;</strong> performs a logical <strong class="source-inline">AND</strong>. We will discuss this in more detail later. For example, <span class="pcode-bold">0110</span><strong class="source-inline">00001010 &gt;&gt; 8</strong> becomes <span class="pcode-bold">0110</span>. This extracts the opcode. Similarly, <strong class="source-inline">0b011011111010 &amp; 0b111111111111 = 0b000000001010</strong> to extract <span class="No-Break">the address:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>                                <span class="sc-comment"># Testing the fetch cycle</span></span>&#13;
<span>mem = [0] * 16                  <span class="sc-comment"># Set up 16 locations in memory</span></span>&#13;
<span>pc = 0                          <span class="sc-comment"># Initialize pc to 0</span></span>&#13;
<span>mem[0] = 0b<strong class="bold">0110</strong>00001010         <span class="sc-comment"># Dummy first instruction (opcode in bold) 0b indicates binary value</span></span>&#13;
<span>mem[1] = 0b<strong class="bold">1000</strong>11111111         <span class="sc-comment"># Dummy second instruction</span></span>&#13;
<span>def fetch(memory):              <span class="sc-comment"># Fetch cycle implemented using a </span><span class="sc-comment">function</span></span>&#13;
<span>    global pc                   <span class="sc-comment"># Make pc global because we </span><span class="sc-comment">change it</span></span>&#13;
<span>    mar = pc                    <span class="sc-comment"># Copy pc to mar</span></span>&#13;
<span>    pc = pc + 1                 <span class="sc-comment"># Increment the pc ready for next instruction</span></span>&#13;
<span>    mbr = memory[mar]           <span class="sc-comment"># Read instruction from memory</span></span>&#13;
<span>    ir = mbr                    <span class="sc-comment"># Copy instruction to instruction register</span></span>&#13;
<span>    cu = ir &gt;&gt; 8                <span class="sc-comment"># Shift instruction 8 places </span><span class="sc-comment">right to get the operation code</span></span>&#13;
<span>    address = ir &amp; 0xFF         <span class="sc-comment"># Mask opcode to 8-bit address</span></span>&#13;
<span>    return(cu, address)         <span class="sc-comment"># Return instruction and address</span></span>&#13;
<span><strong class="bold">opCode,address = fetch(mem)</strong>     <span class="sc-comment"># Do a fetch cycle</span></span>&#13;
<span>print('pc =', pc - 1, 'opcode =', opCode, ' Operand =', address)</span>&#13;
<span><strong class="bold">opCode,address = fetch(mem)</strong>     <span class="sc-comment"># Do a fetch cycle</span></span>&#13;
<span>print('pc =', pc - 1, 'opcode =', opCode, ' Operand =', address)</span></pre>&#13;
			<p lang="en-GB">In the preceding code, the numeric <strong class="source-inline">0b011000001010</strong> value is expressed in binary form by the <strong class="source-inline">0b</strong> prefix. Similarly, the <strong class="source-inline">0xFF</strong> notation indicates<a id="_idIndexMarker162"/><a id="_idIndexMarker163"/> a number in hexadecimal form – that is, <strong class="source-inline">255</strong> in decimal or <strong class="source-inline">11111111</strong> in <span class="No-Break">binary form.</span></p>&#13;
			<p lang="en-GB">The function is tested by calling it twice with <strong class="source-inline">opCode,address = fetch(mem)</strong>. Python lets us receive the two returned parameters, opcode and address, on one line. Note how closely the Python code follows the RTL. In practice, you would not write this code. We don’t need the MAR and MBR registers. I included them to help model the hardware. We can simply write <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>    ir  = mem[pc]               <span class="sc-comment"># Read current instruction into ir</span></span>&#13;
<span>    pc = pc + 1                 <span class="sc-comment"># Increment program counter ready for next cycle</span></span>&#13;
<span>    cu = ir &gt;&gt; 8                <span class="sc-comment"># Extract the opcode</span></span>&#13;
<span>    address = ir &amp; 0xFF         <span class="sc-comment"># Extract the operand address</span></span></pre>&#13;
			<h2 id="_idParaDest-50" lang="en-GB"><a id="_idTextAnchor050"/>The CPU’s data paths</h2>&#13;
			<p lang="en-GB">Having sorted out the fetch phase, let’s see what <a id="_idIndexMarker164"/><a id="_idIndexMarker165"/>else we need to execute instructions. <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.3</em> adds data paths to the CPU of <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.2</em>, plus an address path from the address field of the instruction register to the memory address register. Other additions are a data register, <strong class="source-inline">r0</strong>, and an ALU that does the actual computing. The operations it performs are typically arithmetic (add, subtract, multiply, and divide) and logical (<strong class="source-inline">AND</strong>, <strong class="source-inline">OR</strong>, <strong class="source-inline">EOR</strong>, and shift left <span class="No-Break">or right).</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer032" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_3.03_B19624.jpg" alt="Figure 3.3 – The CPU’s address and data paths" width="1471" height="1077"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – The CPU’s address and data paths</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The data register, <strong class="source-inline">r0</strong>, holds temporary results during a calculation. You need a data register (i.e., an accumulator) because <em class="italic">dyadic</em> operations with two operands such as <strong class="source-inline">ADD</strong> use one operand specified by the instruction, and the other register is the contents of a data register. <strong class="source-inline">ADD </strong><strong class="bold">r0</strong><strong class="source-inline">,P</strong> adds the contents of the memory location, <strong class="source-inline">P</strong>, to the contents of the general-purpose register, <strong class="source-inline">r0</strong>, and deposits the sum in the data register, destroying one of the original operands. The arrangement of <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.3</em> has one general-purpose data register that we’ve called <strong class="source-inline">r0</strong>. A real processor, the ARM, has 16 registers, <strong class="source-inline">r0</strong> to <strong class="source-inline">r15</strong> (although not all of them are general-purpose <span class="No-Break">data registers).</span></p>&#13;
			<h2 id="_idParaDest-51" lang="en-GB"><a id="_idTextAnchor051"/>Typical data movement instructions</h2>&#13;
			<p lang="en-GB">All computers have data move instructions that <a id="_idIndexMarker166"/><a id="_idIndexMarker167"/>transfer (i.e., copy) data from one place to another. These are the simplest instructions because they don’t involve processing data. Data movement instructions vary from computer to computer. Here, we will provide a few typical examples that will help you follow the examples in this chapter. Note that we will use different conventions in this text. For example, we will sometimes prefix a literal by <strong class="source-inline">#</strong> (e.g., <strong class="source-inline">ADD </strong><strong class="bold">r1</strong><strong class="source-inline">,#6</strong>) and sometimes add the suffix <strong class="source-inline">L</strong> to the instruction (e.g., <strong class="source-inline">ADDL </strong><span class="pcode-bold">r1</span><strong class="source-inline">,6</strong>). This is because there are several standards/conventions in use in computing, and they vary from computer to computer. The following are simply generic examples of code. Note the duplication of load a literal. Some processors use <strong class="source-inline">move</strong> and some <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">load</strong></span><span class="No-Break">:</span></p>&#13;
			<table id="table002-2" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Mnemonic</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Example</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Name</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">RTL</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Comment</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">MOV</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">MOV</strong><span class="CharOverride-4">  </span><span class="No-Break"><span class="pcode-bold">r1</span></span><span class="No-Break"><strong class="source-inline">,r4</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">move register</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[r1] <span class="CharOverride-2">←</span> [<span class="No-Break">r4]</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Copy register r4 to <span class="No-Break">register r1</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">MOVL</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">MOVL </strong></span><span class="No-Break"><span class="pcode-bold">r1</span></span><span class="No-Break"><strong class="source-inline">,5</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">move literal</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[r1] <span class="CharOverride-2">←</span> 5</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Copy the integer 5 to <span class="No-Break">register r1</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">LDR</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">LDR</strong><span class="CharOverride-4">  </span><span class="No-Break"><span class="pcode-bold">r3</span></span><span class="No-Break"><strong class="source-inline">,12</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">load register</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[r3] <span class="CharOverride-3">←</span> [<span class="No-Break">12]</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Load r3 with contents of memory <span class="No-Break">location 12</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">LDRL</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">LDRL </strong></span><span class="No-Break"><span class="pcode-bold">r0</span></span><span class="No-Break"><strong class="source-inline">,13</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">load literal</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[r0] <span class="CharOverride-2">←</span> <span class="No-Break">13</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Load register r0 with the <span class="No-Break">integer 13</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">STR</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">STR</strong><span class="CharOverride-4">  </span><span class="No-Break"><strong class="source-inline">r4,</strong></span><span class="No-Break"><span class="pcode-bold">8</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">store register</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">[8]<span class="CharOverride-4"> </span><span class="CharOverride-2">←</span> [<span class="No-Break">r4]</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Store contents of r4 in memory <span class="No-Break">location 8</span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.2 – Typical data movement instructions</p>&#13;
			<h2 id="_idParaDest-52" lang="en-GB"><a id="_idTextAnchor052"/>Data processing instructions</h2>&#13;
			<p lang="en-GB">Let’s look at a typical <a id="_idIndexMarker168"/><a id="_idIndexMarker169"/>data-processing operation. We can represent an <strong class="source-inline">ADD </strong><span class="pcode-bold">r0</span><strong class="source-inline">,X</strong> instruction with the <span class="No-Break">RTL expression:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>[r0] <span class="CharOverride-3">←</span> [r0] + [X]       <span class="sc-comment">@ Add the contents of the memory</span></span>&#13;
<span>                         <span class="sc-comment">location X to register r0</span></span></pre>&#13;
			<p lang="en-GB">The ALU is the workhorse of the CPU because it performs all calculations. Arithmetic and logical operations are applied to the contents of a data register and the contents of a data register or the MBR. The output of the ALU is fed back to the data register or to <span class="No-Break">the MBR.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The fundamental difference between arithmetic and logical operations is that logical operations don’t generate a carry when bit a<span class="subscript">i</span> of word <strong class="source-inline">A</strong> and bit b<span class="subscript">i</span> of <strong class="source-inline">B</strong> are operated upon. <em class="italic">Table 3.2</em> provides examples of typical arithmetic and <span class="No-Break">logical operations.</span></p>&#13;
			<table id="table003" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Operation</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Class</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Typical mnemonic</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Addition</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Arithmetic</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="CharOverride-5">ADD </span>(a = b + <span class="No-Break">c)</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Subtraction</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Arithmetic</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="CharOverride-5">SUB </span>(a = b - <span class="No-Break">c)</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Negation</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Arithmetic</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="CharOverride-5">NEG </span>(a = -<span class="No-Break">b)</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Multiplication</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Arithmetic</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="CharOverride-5">MUL </span>(a = b * <span class="No-Break">c)</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Division</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Arithmetic</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="CharOverride-5">DIV </span>(a = b / <span class="No-Break">c)</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Divide <span class="No-Break">by 2</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Arithmetic</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="CharOverride-5">ASR </span>(a = b / <span class="No-Break">2)</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Multiply <span class="No-Break">by 2</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Arithmetic</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="CharOverride-5">ASL </span>(a = b * <span class="No-Break">2)</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">AND</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Logical</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="CharOverride-5">AND </span>(a = b &amp; <span class="No-Break">c)</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">OR</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Logical</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="CharOverride-5">OR</span><span class="CharOverride-5" lang="ar-SA" xml:lang="ar-SA">  </span>(a = b | <span class="No-Break">c)</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">NOT</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Logical</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="CharOverride-5">NOT </span>(a = !<span class="No-Break">b)</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">EOR</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Logical</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="CharOverride-5">EOR </span>(a = b <span class="CharOverride-2" lang="ar-SA" xml:lang="ar-SA">⊕</span> <span class="No-Break">c)</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Shift left</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Logical</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="CharOverride-5">LSL </span>(shift all bits left a = b &lt;&lt; <span class="No-Break">1)</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Shift right</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Logical</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="CharOverride-5">LSR </span>(shift all bits right a = b &gt;&gt; <span class="No-Break">1)</span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.3 – Typical arithmetic and logical operations</p>&#13;
			<p lang="en-GB">A logical shift treats an operand as a <a id="_idIndexMarker170"/><a id="_idIndexMarker171"/>string of bits that are moved left or right. An arithmetic shift treats a number as a signed 2s complement value and propagates the sign bit during a right shift (i.e., the sign bit is replicated and duplicated). Most of these operations are implemented by computers such as the 68K, Intel Core, <span class="No-Break">and ARM.</span></p>&#13;
			<h2 id="_idParaDest-53" lang="en-GB"><a id="_idTextAnchor053"/>Another look at the data flow</h2>&#13;
			<p lang="en-GB">Let’s have another look at <a id="_idIndexMarker172"/><a id="_idIndexMarker173"/>data flow in a computer to cement the basic concepts together. In <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.4</em>, we have a computer that supports operations involving three registers (a hallmark of computers such as the ARM). Here, we have three registers, <strong class="source-inline">r1</strong>, <strong class="source-inline">r2</strong>, and <strong class="source-inline">r3</strong>. The block labeled <em class="italic">adder</em> is part of the ALU and serves to add two numbers to produce a sum. Instruction <strong class="source-inline">LDR </strong><span class="pcode-bold">r2</span><strong class="source-inline">,X</strong> loads the contents of memory address <strong class="source-inline">X</strong> into register <strong class="source-inline">r2</strong>. Instruction <strong class="source-inline">STR r1,</strong><span class="pcode-bold">Z</span> stores the contents of register <strong class="source-inline">r1</strong> in memory <span class="No-Break">address </span><span class="No-Break"><strong class="source-inline">Z</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The instruction <strong class="source-inline">ADD </strong><span class="pcode-bold">r1</span><strong class="source-inline">,r2,r3</strong> reads the contents of registers <strong class="source-inline">r2</strong> and <strong class="source-inline">r3</strong>, adds them together, and deposits the result in register, <strong class="source-inline">r1</strong>. Since it’s not clear which register is the destination register (i.e., the result), we use a bold font to highlight the destination operand, which is normally the <span class="No-Break">leftmost operand.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB"><span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.4</em> shows several fundamental components of a computer. This is, essentially, the same as the more detailed structures we used to demonstrate the fetch/execute cycle. Here, we are interested in data flow into and out <span class="No-Break">of memory.</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer033" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_3.04_B19624.jpg" alt="Figure 3.4 – Details of the von Neumann machine" width="1363" height="814"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Details of the von Neumann machine</p>&#13;
			<p lang="en-GB">The elements of interest are <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">A clock that generates timing pulses. All operations take place when triggered by <span class="No-Break">the clock.</span></li>&#13;
				<li lang="en-GB">An interpreter or control unit that takes an instruction, together with a stream of clock pulses, and converts it into the actions <a id="_idIndexMarker174"/><a id="_idIndexMarker175"/>required to perform the required operation. In <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.4</em>, the interpreter routes the contents of registers <strong class="source-inline">r2</strong> and <strong class="source-inline">r3</strong> to the adder, makes the adder add the two values together, and then routes the result from the adder to the <span class="No-Break">destination register.</span></li>&#13;
				<li lang="en-GB">The program in memory. Data is loaded from memory into registers <strong class="source-inline">r2</strong> and <strong class="source-inline">r2</strong>. Then, <strong class="source-inline">r2</strong> and <strong class="source-inline">r3</strong> are added together and the result is put in <strong class="source-inline">r3</strong>. Finally, the contents of <strong class="source-inline">r3</strong> are moved <span class="No-Break">to memory.</span></li>&#13;
			</ul>&#13;
			<p lang="en-GB">Now that we’ve covered the basic structure of a computer and introduced some instructions, the next step is to look at a complete program that carries out a <span class="No-Break">specific function.</span></p>&#13;
			<h1 id="_idParaDest-54" lang="en-GB"><a id="_idTextAnchor054"/>An assembly-level program</h1>&#13;
			<p lang="en-GB">Having developed our computer <a id="_idIndexMarker176"/><a id="_idIndexMarker177"/>a little further, in this section, we will show how a simple program is executed. Assume that this computer doesn’t provide three-address instructions (i.e., you can’t specify an operation with three registers and/or memory addresses) and we want to implement the high-level language operation <strong class="source-inline">Z = X + Y</strong>. Here, the <em class="italic">plus</em> symbol means arithmetic addition. An assembly language program that carries out this operation is given in the following code block. Remember that <strong class="source-inline">X</strong>, <strong class="source-inline">Y</strong>, and <strong class="source-inline">Z</strong> are symbolic names referring to the <em class="italic">locations</em> of the variables in memory. Logically, the store operation should be written <strong class="source-inline">STR Z,r2</strong>, with the destination operand on the left just like other instructions. By convention, it is written as <strong class="source-inline">STR r2,Z</strong>, with the source register on the<a id="_idIndexMarker178"/><a id="_idIndexMarker179"/> left. This is a quirk of <span class="No-Break">programming history:</span></p>&#13;
			<p lang="en-GB"><strong class="bold CharOverride-6">   </strong><strong class="source-inline">LDR</strong><strong class="bold CharOverride-6">  </strong><span class="pcode-bold">r2</span><strong class="source-inline">,X</strong><strong class="bold CharOverride-6">  </strong>Load data register <strong class="source-inline">r2</strong> with the contents of memory <span class="No-Break">location </span><span class="No-Break"><strong class="source-inline">X</strong></span></p>&#13;
			<p lang="en-GB"><strong class="bold CharOverride-6">   </strong><strong class="source-inline">ADD</strong><strong class="bold CharOverride-6">  </strong><span class="pcode-bold">r2</span><strong class="source-inline">,Y</strong><strong class="bold CharOverride-6">  </strong>Add the contents of memory location <strong class="source-inline">Y</strong> to data <span class="No-Break">register </span><span class="No-Break"><strong class="source-inline">r2</strong></span></p>&#13;
			<p lang="en-GB"><strong class="bold CharOverride-6">   </strong><strong class="source-inline">STR</strong><strong class="bold CharOverride-6">  </strong><strong class="source-inline">r2,</strong><span class="pcode-bold">Z</span><strong class="bold CharOverride-6">  </strong>Store the contents of data register <strong class="source-inline">r2</strong> in memory <span class="No-Break">location </span><span class="No-Break"><strong class="source-inline">Z</strong></span></p>&#13;
			<p lang="en-GB">Eight-bit computers had a one-address machine, requiring a rather cumbersome sequence of operations just to carry out the simple act of adding two numbers. If we had a computer with a three-address format, we could have written <span class="No-Break">the following:</span></p>&#13;
			<p lang="en-GB"><strong class="bold CharOverride-6">   </strong><strong class="source-inline">ADD</strong><strong class="bold CharOverride-6">  </strong><span class="pcode-bold">Z</span><strong class="source-inline">,X,Y</strong><strong class="bold CharOverride-6">  </strong><span class="CharOverride-7">Add the contents of X to the contents of Y and put the result </span><span class="No-Break CharOverride-7">in Z</span></p>&#13;
			<p lang="en-GB">Three-address machines are <em class="italic">potentially </em>faster than one-address machines because they can do in one instruction things that take other machines three operations. Unfortunately, it is a factor of technological development that on-chip registers are faster than DRAM, and computer designers try to keep data in registers on-chip as much <span class="No-Break">as possible.</span></p>&#13;
			<p lang="en-GB">The reality is more complicated. Accessing memory is slow compared to accessing registers. This is a property of the hardware. Consequently, it is more efficient to keep data <span class="No-Break">in registers.</span></p>&#13;
			<p lang="en-GB">The way in which the CPU operates can best be seen by examining the execution of, say, <strong class="source-inline">ADD </strong><span class="pcode-bold">r2</span><strong class="source-inline">,Y</strong> in terms of register-transfer language. In the following code block, we describe the operations carried out during the fetch and execute phases of an <strong class="source-inline">ADD </strong><span class="No-Break"><span class="pcode-bold">r2</span></span><span class="No-Break"><strong class="source-inline">,Y</strong></span><span class="No-Break"> instruction:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>FETCH [MAR] ← [PC]     <strong class="bold">  </strong> <strong class="bold">  </strong> <strong class="bold">  </strong> <strong class="bold">    </strong><span class="sc-comment">Move the contents of the PC to the MAR</span></span>&#13;
<span>      [PC]  ← [PC] + 1  <strong class="bold">  </strong> <strong class="bold">  </strong> <strong class="bold">      </strong><span class="sc-comment">Increment the contents of the PC</span></span>&#13;
<span>      [MBR] ← [[MAR]]   <strong class="bold">  </strong> <strong class="bold">  </strong> <strong class="bold">  </strong> <strong class="bold">   </strong><span class="sc-comment">Read the current instruction from the memory</span></span>&#13;
<span>      [IR]  ← [MBR]    <strong class="bold">  </strong> <strong class="bold">  </strong> <strong class="bold">  </strong> <strong class="bold">    </strong><span class="sc-comment">Move the contents of the MBR to the IR</span></span>&#13;
<span>      CU    ← [IRopcode]    <strong class="bold">  </strong> <strong class="bold">    </strong> <span class="sc-comment">Move the opcode from the IR to the CU</span></span>&#13;
<span><strong class="bold">ADD   [MAR] </strong><strong class="bold CharOverride-8">←</strong><strong class="bold"> [IR</strong><span class="subscript">address</span><strong class="bold">]             </strong><span class="sc-comment-bold">Move the operand address to the MAR</span></span>&#13;
<span><strong class="bold">      [MBR] </strong><strong class="bold CharOverride-8">←</strong><strong class="bold"> [[MAR]]              </strong><span class="sc-comment-bold">Read the data from memory</span></span>&#13;
<span><strong class="bold">      ALU</strong><strong class="bold">   </strong><strong class="bold CharOverride-8">←</strong><strong class="bold"> [MBR], ALU </strong><strong class="bold CharOverride-8">←</strong><strong class="bold"> [r2]   </strong><span class="sc-comment"> </span><span class="sc-comment-bold">Perform the addition</span></span>&#13;
<span><strong class="bold">      [r2]  </strong><strong class="bold CharOverride-8">←</strong><strong class="bold"> ALU                  </strong><span class="sc-comment-bold">Move the output of ALU to the data register</span></span></pre>&#13;
			<p lang="en-GB">Operations sharing the same line are <span class="No-Break">executed simultaneously.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">During the fetch phase, the opcode is fed to the control unit by CU <span class="CharOverride-2">←</span> [IR<span class="subscript">opcode</span>] and used to generate all the internal signals required to place the ALU in its addition mode. When the ALU is programmed for addition, it adds together the data at its two input terminals to produce a sum at its <span class="No-Break">output terminals.</span></p>&#13;
			<p lang="en-GB">Operations of the form <strong class="source-inline">[PC]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">[MAR]</strong> or <strong class="source-inline">[r2]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">[r2] + [MBR]</strong> are often referred to as <em class="italic">microinstructions</em>. Each assembly-level instruction (e.g., <strong class="source-inline">MOV, ADD</strong>) is executed as a series of microinstructions. Microinstructions are the province of the computer designer. In the 1970s, some machines were user-microprogrammable – that is, you could define your own <span class="No-Break">instruction set.</span></p>&#13;
			<p lang="en-GB">We can test the execute phase by extending the fetch phase code. The following Python code provides three instructions – load a register with<a id="_idIndexMarker180"/><a id="_idIndexMarker181"/> a literal, add memory contents to the register, and stop. We have also made the Python code more compact – for example, you can put expressions in a function’s return statement. In this example, we return two values: <strong class="source-inline">ir &gt;&gt; 8</strong> and <strong class="source-inline">ir &amp; 0xFF</strong>. The operation <strong class="source-inline">x &gt;&gt; y</strong> takes the binary value of <strong class="source-inline">x</strong> and shifts the bits <strong class="source-inline">y</strong> places right; for example, <strong class="source-inline">0b0011010110 &gt;&gt; 2</strong> gives <strong class="source-inline">0b0000110101</strong>. The shaded part of the code is the machine-level program <span class="No-Break">we execute:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span># Implement fetch cycle and execute cycle: include three test instructions</span>&#13;
<span>mem = [0] * 12                     <span class="sc-comment"># Set up 12-location memory</span></span>&#13;
<span>pc = 0                             <span class="sc-comment"># Initialize pc to 0</span></span>&#13;
<span class="sc-grey" lang="en-GB">mem[0] = 0b000100001100            <span class="sc-comment"># First instruction </span><span class="sc-comment">load r0 with 12</span></span>&#13;
<span class="sc-grey" lang="en-GB">mem[1] = 0b001000000111            <span class="sc-comment"># Second instruction add mem[7] to r0</span></span>&#13;
<span class="sc-grey" lang="en-GB">mem[2] = 0b111100000000            <span class="sc-comment"># Third instruction is stop</span></span>&#13;
<span class="sc-grey" lang="en-GB">mem[7] = 8                         <span class="sc-comment"># Initial data inlocation 7 is 8</span></span>&#13;
<span class="sc-bottom" lang="en-GB">def fetch(memory):                 <span class="sc-comment"># Function for fetch phase</span></span>&#13;
<span class="sc-bottom" lang="en-GB">    global pc                      <span class="sc-comment"># Make pc a global variable</span></span>&#13;
<span class="sc-bottom" lang="en-GB">    ir = memory[pc]                <span class="sc-comment"># Read instruction and </span><span class="sc-comment">move to IR</span></span>&#13;
<span class="sc-bottom" lang="en-GB">    pc = pc + 1                    <span class="sc-comment"># Increment program </span><span class="sc-comment">counter for next cycle</span></span>&#13;
<span class="sc-bottom" lang="en-GB">    return(ir &gt;&gt; 8, ir &amp; 0xFF)     <span class="sc-comment"># Returns opCode and </span><span class="sc-comment">operand</span></span>&#13;
<span class="sc-bottom" lang="en-GB">run = 1                            <span class="sc-comment"># run = 1 to continue</span></span>&#13;
<span class="sc-bottom" lang="en-GB">while run == 1:                    <span class="sc-comment"># REPEAT: The program execution loop</span></span>&#13;
<span class="sc-bottom" lang="en-GB">    opCode, address = fetch(mem)   <span class="sc-comment"># Call fetch to perform </span><span class="sc-comment">fetch phase</span></span>&#13;
<span class="sc-bottom" lang="en-GB">    if   opCode == 0b1111: run = 0 <span class="sc-comment"># Execute phase for  </span><span class="sc-comment">stop (set run to 0 on stop)</span></span>&#13;
<span class="sc-bottom" lang="en-GB">    elif opCode == 0b0001:         <span class="sc-comment"># Execute phase for </span><span class="sc-comment">load number</span></span>&#13;
<span class="sc-bottom" lang="en-GB">         r0 = address              <span class="sc-comment"># Load r0 with contents </span><span class="sc-comment">of address field</span></span>&#13;
<span class="sc-bottom" lang="en-GB">    elif opCode == 0b0010:         <span class="sc-comment"># Execute phase for add</span></span>&#13;
<span class="sc-bottom" lang="en-GB">         mar = address             <span class="sc-comment"># Copy address in opCode to MAR</span></span>&#13;
<span class="sc-bottom" lang="en-GB">         mbr = mem[mar]            <span class="sc-comment"># Read the number to be </span><span class="sc-comment">dded</span></span>&#13;
<span class="sc-bottom" lang="en-GB">         r0 = mbr + r0             <span class="sc-comment"># Do the addition</span></span>&#13;
<span class="sc-bottom" lang="en-GB">    print('pc = ',pc - 1, 'opCode =', opCode, 'Register r0 =',r0)</span>&#13;
<span class="sc-bottom" lang="en-GB">                                   <span class="sc-comment"># We print pc – 1 </span><span class="sc-comment">because the pc is incremented</span></span></pre>&#13;
			<p lang="en-GB">The output from this code is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>pc =  0 opCode = 1  Register r0 = 12</span>&#13;
<span>pc =  1 opCode = 2  Register r0 = 20</span></pre>&#13;
			<pre class="source-code">pc =  2 opCode = 15 Register r0 = 20</pre>&#13;
			<p lang="en-GB">Note that the Python term <strong class="source-inline">elif</strong> is short for <em class="italic">else if</em>. The preceding case says, “<em class="italic">Is the opcode stop. If not, is the opcode load. If not, is the opcode add.</em>” This allows for a sequence of tests. We discuss <strong class="source-inline">elif</strong> in more <span class="No-Break">detail later.</span></p>&#13;
			<h2 id="_idParaDest-55" lang="en-GB"><a id="_idTextAnchor055"/>Executing conditional instructions</h2>&#13;
			<p lang="en-GB">So far, we’ve looked <a id="_idIndexMarker182"/><a id="_idIndexMarker183"/>at the structure of a CPU capable of executing programs in a purely <em class="italic">sequential</em> mode – that is, the computer can execute only a stream of instructions, one by one, in strict order. We introduced conditional behavior in the previous chapter, and now we will extend the CPU so that it can execute instructions, such as <strong class="source-inline">BEQ Target</strong> (a branch on a zero flag set to <strong class="source-inline">Target</strong>), that are able to execute instructions out <span class="No-Break">of sequence.</span></p>&#13;
			<p lang="en-GB">The computer in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.1</em> lacks a mechanism to make choices or repeat a group of instructions. To do this, the CPU must be able to execute <em class="italic">conditional branches</em> or <em class="italic">jumps</em>. The block diagram of <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.5</em> shows the new address and data paths required by the CPU to implement <span class="No-Break">conditional branches.</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer034" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_3.05_B19624.jpg" alt="Figure 3.5 – Information paths in the CPU and conditional instructions" width="1471" height="1302"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 3.5 – Information paths in the CPU and conditional instructions</p>&#13;
			<p lang="en-GB">Three items have been added to our computer in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.5</em>. These <span class="No-Break">are highlighted:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">A <strong class="bold">condition code </strong><span class="No-Break"><strong class="bold">register (CCR)</strong></span></li>&#13;
				<li lang="en-GB">A path between the<a id="_idIndexMarker184"/><a id="_idIndexMarker185"/> CCR and the <span class="No-Break">control unit</span></li>&#13;
				<li lang="en-GB">A path between the address field of the instruction register and the <span class="No-Break">program counter.</span></li>&#13;
			</ul>&#13;
			<p lang="en-GB">The <em class="italic">condition code register</em> or <em class="italic">processor status register</em> records the ALU state after each instruction has been executed, and updates the carry, negative, zero, and overflow flag bits. A conditional branch instruction interrogates the CCR’s flags. The CU then either executes<a id="_idIndexMarker186"/><a id="_idIndexMarker187"/> the next instruction in sequence or branches to another instruction. Let’s look at the details of the conditional branch. The following is a reminder of the CCR <span class="No-Break">bit functions:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">C = Carry:<span class="CharOverride-4">  </span>A carry occurs when an operation in n bits yields an n+1 bit result (e.g., when your car odometer winds round from 999...9 to 000...0). In 8-bit computer terms, this is when 11111111 + 1 = 0000000 <span class="No-Break">carry 1.</span></li>&#13;
				<li lang="en-GB">Z = Zero:<span class="CharOverride-4">   </span>This is set if the last operation generated a <span class="No-Break">zero result.</span></li>&#13;
				<li lang="en-GB">N = Negative: This is set if the last result generated a negative result in 2s complement arithmetic – that is, set if the most significant bit of a word is 1 (for example, 00101010 is positive and 10101010 is negative when the number is viewed as a two’s <span class="No-Break">complement value).</span></li>&#13;
				<li lang="en-GB">V = Overflow: This is set if the last operation resulted in an arithmetic overflow, which occurs in two’s complement arithmetic if the result is outside its allowable range. In this text, we generally don’t implement the V-flag for the sake <span class="No-Break">of simplicity.</span></li>&#13;
			</ul>&#13;
			<p lang="en-GB">The condition code register is connected to the control unit, enabling an instruction to interrogate it. For example, some instructions test whether an operation yielded a positive result, whether the carry bit was set, or whether an arithmetic overflow occurred. We need a mechanism that does one thing if the result of the test is <strong class="source-inline">true</strong> and does another thing if the result of the test <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The final modification included in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.5</em> is the addition of a path between the operand field (i.e., the target address) of the instruction register and the program counter. It’s this feature that enables the computer to respond to the result of its interrogation of <span class="No-Break">the CCR.</span></p>&#13;
			<p lang="en-GB">A <em class="italic">conditional branch</em> instruction <a id="_idIndexMarker188"/><a id="_idIndexMarker189"/>such as <strong class="bold">branch on carry set (BCS)</strong> tests the carry bit of the CCR, and if the bit tested is clear, the next instruction is obtained from memory in the normal way. If the bit tested is set, the next instruction is obtained from the location whose <em class="italic">target address</em> is in the instruction register. In the preceding description, we said that a branch is made if a bit of the CCR is set; equally, a branch can be made if the bit is clear (branches can also be made on the combined state of several <span class="No-Break">CCR bits).</span></p>&#13;
			<p lang="en-GB">Branch operations can be expressed in register-transfer language in the <span class="No-Break">following form:</span></p>&#13;
			<pre class="source-code">IF condition THEN action</pre>&#13;
			<p lang="en-GB">Typical machine-level conditional operations expressed in RTL are <span class="No-Break">as follows:</span></p>&#13;
			<ol>&#13;
				<li lang="en-GB">Branch on carry clear (jump to the target address if the carry bit in the CCR <span class="No-Break">is 0)</span></li>&#13;
			</ol>&#13;
			<p lang="en-GB"><strong class="bold">BCC target: IF [C] = 0 THEN [PC] </strong><strong class="bold CharOverride-3">←</strong><strong class="bold"> [IR</strong><span class="subscript">address</span><strong class="bold">]</strong></p>&#13;
			<ol>&#13;
				<li lang="en-GB" value="2">Branch on equal (jump to the target address if the Z bit in the CCR <span class="No-Break">is 1)</span></li>&#13;
			</ol>&#13;
			<p lang="en-GB"><strong class="bold">BEQ target: IF [Z] = 1 THEN [PC] </strong><strong class="bold CharOverride-3">←</strong><strong class="bold"> [IR</strong><span class="subscript">address</span><strong class="bold">]</strong></p>&#13;
			<p lang="en-GB">Both these actions have an <strong class="source-inline">ELSE</strong> condition, which is the default <strong class="source-inline">[PC]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">[PC] + </strong><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">An example of a conditional<a id="_idIndexMarker190"/><a id="_idIndexMarker191"/> branch in assembly language is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>     SUB  <strong class="bold">r0</strong>,x    <span class="sc-comment">@ Subtract the contents of memory location x from register r0</span></span>&#13;
<span>     <strong class="bold">BEQ  Last</strong>    <span class="sc-comment">@ If the result was zero, then branch to Last; otherwise, continue</span></span>&#13;
<span>     .            <span class="sc-comment">@ Execute here if branch not taken</span></span>&#13;
<span>     .</span>&#13;
<span><span class="sc-source-bg">Last</span>              <span class="sc-comment">@ Target address of branch (if taken)</span></span></pre>&#13;
			<p lang="en-GB">The final step in extending the computer architecture is the introduction of data paths to permit literals to be loaded into a register – that is, to load a register with a number that is in the instruction rather than from memory. The z-bit can be confusing. The z-bit is set to 1 if a result yields zero, and it’s set to 0 if the result is <span class="No-Break">not zero.</span></p>&#13;
			<h2 id="_idParaDest-56" lang="en-GB"><a id="_idTextAnchor056"/>Dealing with literal operands</h2>&#13;
			<p lang="en-GB">Computer instructions such <a id="_idIndexMarker192"/><a id="_idIndexMarker193"/>as <strong class="source-inline">ADD </strong><span class="pcode-bold">r0</span>,<strong class="source-inline">abc</strong> refer to an operand somewhere within the CPU’s memory. Sometimes, we want to use an instruction such as <span class="pcode-bg">ADD </span><span class="pcode-bold">r0</span><span class="pcode-bg">,#12,</span> where the source operand supplies the <em class="italic">actual value</em> of the data being referred to by the opcode part of the instruction – in this case, 12. Although the symbol <strong class="source-inline">#</strong> appears as part of the operand when this instruction is written in mnemonic form, the assembler uses a different opcode code for <span class="No-Break">the following:</span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">ADD</strong><span class="CharOverride-4">  </span><span class="pcode-bold">r0</span><strong class="source-inline">,#literal</strong> and <strong class="source-inline">ADD</strong><span class="CharOverride-4">  </span><span class="No-Break"><span class="pcode-bold">r0</span></span><span class="No-Break"><strong class="source-inline">,address</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The instruction <strong class="source-inline">ADD</strong><span class="CharOverride-4">  </span><span class="pcode-bold">r0</span><strong class="source-inline">,#12</strong> is defined in <strong class="source-inline">RTL</strong> as [r0] <span class="CharOverride-2">←</span> [r0] + <span class="No-Break">12.</span></p>&#13;
			<p lang="en-GB">Note that we use two conventions for literals. One is <strong class="source-inline">ADD r0,</strong><span class="pcode-bold">#</span><strong class="source-inline">12</strong> and the other is <strong class="source-inline">ADD</strong><span class="pcode-bold">L</span><strong class="source-inline"> r0,12</strong>. This matches typical <span class="No-Break">instruction sets.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB"><span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.6</em> shows that an additional data path is required between the operand field of the IR and the data register and ALU to deal with literal operands. <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.6</em> includes three general-purpose registers, <strong class="source-inline">r0</strong>, <strong class="source-inline">r1</strong>, and <strong class="source-inline">r2</strong>. In principle, there is nothing stopping us from adding any number of registers. However, the number of internal registers is limited by the number of bits available to specify a register in the instruction. As you can see, three data buses, <strong class="source-inline">A</strong>, <strong class="source-inline">B</strong>, and <strong class="source-inline">C</strong>, are used to transfer data between the registers <span class="No-Break">and ALU.</span></p>&#13;
			<p lang="en-GB">The structure of <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.6</em> can implement instructions with more complex addressing modes than the simple direct (absolute) addressing we have used so far. Consider <strong class="source-inline">MOV </strong><span class="pcode-bold">r1</span><strong class="source-inline">,[r0]</strong>, which copies the contents of the memory location whose address is in <strong class="source-inline">r0</strong>. Here, <strong class="source-inline">r0</strong> is a pointer to the actual data. This instruction can be implemented by the following sequence <span class="No-Break">of micro-operations:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>MOV   [MAR] <span class="CharOverride-3">←</span> [r0]        <span class="sc-comment">Move the source operand address to the MAR</span></span>&#13;
<span>      [MBR] <span class="CharOverride-3">←</span> [[MAR]]     <span class="sc-comment">Read the actual operand from memory</span></span>&#13;
<span>      [MAR] <span class="CharOverride-3">←</span> [MBR]       <span class="sc-comment">Copy the address back to the MAR</span></span>&#13;
<span>      [r1]  <span class="CharOverride-3">←</span> [[MAR]]     <span class="sc-comment">Copy the data from memory to r1</span></span></pre>&#13;
			<p lang="en-GB">This sequence has been simplified <a id="_idIndexMarker194"/><a id="_idIndexMarker195"/>because, as you can see from <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.6</em>, there is no direct path between register <strong class="source-inline">r0</strong> and the MBR. You would have to put the contents of r0 onto bus A, pass the contents of bus A through the ALU to bus C, and then copy bus C to <span class="No-Break">the MAR.</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer035" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_3.06_B19624.jpg" alt="Figure 3.6 – Modifying the CPU to deal with literal operands" width="1254" height="1261"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 3.6 – Modifying the CPU to deal with literal operands</p>&#13;
			<p lang="en-GB">Let’s extend our Python code to include both literal operations and conditional operations. The following Python code implements a load register<a id="_idIndexMarker196"/><a id="_idIndexMarker197"/> with literal instruction, an add/subtract, a conditional branch on zero, and a stop. Here, we use <strong class="source-inline">LDRL</strong> to indicate a literal, rather than prefixing the literal with <span class="pcode-bold">#</span>. The program to be executed is <span class="No-Break">as follows:</span></p>&#13;
			<table id="table004" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Address</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Mnemonic</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Instruction</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Binary code</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Note</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">0</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">LDRL </strong></span><span class="No-Break"><span class="pcode-bold">r0</span></span><span class="No-Break"><strong class="source-inline">,9</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">load <strong class="source-inline">r0</strong> with the <span class="No-Break">literal </span><span class="No-Break"><strong class="source-inline">9</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><span class="pcode-bold">0001</span></span><span class="No-Break"><strong class="source-inline">00001001</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">[r0]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">9</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">SUB </strong></span><span class="No-Break"><span class="pcode-bold">r0</span></span><span class="No-Break"><strong class="source-inline">,7</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">subtract mem<strong class="source-inline">[7]</strong> <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">r0</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break"><span class="pcode-bold">011</span></span><span class="No-Break"><strong class="source-inline">00000111</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">[r0]</strong> <span class="CharOverride-2">←</span> <strong class="source-inline">[r0] – </strong><span class="No-Break"><strong class="source-inline">mem[7]</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">2</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">BEQ </strong></span><span class="No-Break"><span class="pcode-bold">6</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">branch on zero to 6 </p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break"><span class="pcode-bold">100</span></span><span class="No-Break"><strong class="source-inline">00000110</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">if <strong class="source-inline">z = 1 [PC] ← 6</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">3</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">STOP</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">top execution</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><span class="pcode-bold">1111</span></span><span class="No-Break"><strong class="source-inline">00000000</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">4</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">5</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">6</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">STOP</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">top execution</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><span class="pcode-bold">1111</span></span><span class="No-Break"><strong class="source-inline">00000000</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1"/>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.4 – Caption</p>&#13;
			<p lang="en-GB">To implement a load register, we simply move the literal in the instruction to the register. The subtraction tests the result and sets the zero-status bit, <strong class="source-inline">z</strong>, to <strong class="source-inline">1</strong> if the result is <strong class="source-inline">0</strong> and <strong class="source-inline">0</strong> if it is not. The conditional branch tests the z-bit and loads the pc with the literal from the instruction if <strong class="source-inline">z = </strong><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">.</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>                             <span class="sc-comment"># Simple program to test a branch instruction</span></span>&#13;
<span>mem = [0] * 12               <span class="sc-comment"># Set up a 12-location memory</span></span>&#13;
<span>pc = 0                       <span class="sc-comment"># Initialize program counter to 0</span></span>&#13;
<span>mem[0] = 0b<strong class="bold">0001</strong>00001001      <span class="sc-comment"># First instruction loads r0 with 9 (i.e., 1001)</span></span>&#13;
<span>mem[1] = 0b<strong class="bold">0011</strong>00000111      <span class="sc-comment"># Second instruction subtracts mem[7] from r0</span></span>&#13;
<span>mem[2] = 0b<strong class="bold">0100</strong>00000110      <span class="sc-comment"># Third instruction is BEQ 6 (branch on zero to 6)</span></span>&#13;
<span>mem[3] = 0b<strong class="bold">1111</strong>00000000      <span class="sc-comment"># Fourth instruction is stop</span></span>&#13;
<span>mem[6] = 0b<strong class="bold">1111</strong>00000000      <span class="sc-comment"># Seventh instruction is stop</span></span>&#13;
<span>mem[7] = 9                   <span class="sc-comment"># Initial data in location 7 is 9</span></span>&#13;
<span>                             <span class="sc-comment"># Fetch returns opcode and address</span></span>&#13;
<span>def fetch(memory):           <span class="sc-comment"># This function, fetch, gets the instruction from memory</span></span>&#13;
<span>    global pc                <span class="sc-comment"># Declare pc as global because we modify it in the function</span></span>&#13;
<span>    ir = memory[pc]          <span class="sc-comment"># Read the instruction from memory</span></span>&#13;
<span>    pc = pc + 1              <span class="sc-comment"># Now point to the next instruction</span></span>&#13;
<span>    return(ir&gt;&gt;8, ir&amp;0xFF)   <span class="sc-comment"># Return the opcode and address</span></span>&#13;
<span>z = 0                                             <span class="sc-comment"># Clear z bit initially</span></span>&#13;
<span>run = 1                                           <span class="sc-comment"># run = 1 to continue</span></span>&#13;
<span>while run == 1:                                   <span class="sc-comment"># Main loop REPEAT until stop found</span></span>&#13;
<span>    pcOld = pc                                    <span class="sc-comment"># Save current pc for display</span></span>&#13;
<span>    opCode, address = fetch(mem)                  <span class="sc-comment"># Perform fetch to get opcode</span></span>&#13;
<span>    if   opCode == 0b1111: run = 0                <span class="sc-comment"># Test for stop</span></span>&#13;
<span>    elif opCode == 0b0001: r0 = address           <span class="sc-comment"># Test for load literal</span></span>&#13;
<span>    elif opCode == 0b0010: r0 = r0 + mem[address] <span class="sc-comment"># Test for add</span></span>&#13;
<span>    elif opCode == 0b0011:                        <span class="sc-comment"># Test for subtract</span></span>&#13;
<span>        r0 = r0 - mem[address]                    <span class="sc-comment"># Do subtraction</span></span>&#13;
<span>        if r0 == 0: z = 1                         <span class="sc-comment"># Update z flag on subtract</span></span>&#13;
<span>        else:       z = 0</span>&#13;
<span>    elif opCode == 0b0100:                        <span class="sc-comment"># Test for branch on zero</span></span>&#13;
<span>        if z == 1: pc = address                   <span class="sc-comment"># If BEQ, load PC on zero flag</span></span>&#13;
<span>    print('pc = ',pcOld,'opCode =',opCode,'\tRegister r0 =',r0,'z = ',z)</span>&#13;
<span>                                                  <span class="sc-comment"># The '\t' performs a tab operation</span></span></pre>&#13;
			<p lang="en-GB">The output from this Python code is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>pc =  0 opCode = 1  Register r0 = 9 z =  0</span>&#13;
<span>pc =  1 opCode = 3  Register r0 = 0 z =  1</span>&#13;
<span>pc =  2 opCode = 4  Register r0 = 0 z =  1        <span class="sc-comment">z = 1 so branch taken</span></span>&#13;
<span>pc =  6 opCode = 15 Register r0 = 0 z =  1</span></pre>&#13;
			<p lang="en-GB">We load the literal <strong class="source-inline">9</strong> into <strong class="source-inline">r0</strong>, subtract the <a id="_idIndexMarker198"/><a id="_idIndexMarker199"/>contents of memory location <strong class="source-inline">7</strong> (which contains <strong class="source-inline">9</strong>), and then branch to location <strong class="source-inline">6</strong> if the result was <strong class="source-inline">0</strong>. And that’s <span class="No-Break">what happens.</span></p>&#13;
			<p lang="en-GB">Having described the structure of a computer, the next step is to look at the instructions that are executed by <span class="No-Break">a computer.</span></p>&#13;
			<h1 id="_idParaDest-57" lang="en-GB"><a id="_idTextAnchor057"/>The machine-level instruction</h1>&#13;
			<p lang="en-GB">Having described how a computer works, we now take a closer look at the computer. We are interested in what an instruction does and what<a id="_idIndexMarker200"/><a id="_idIndexMarker201"/> resources it needs (i.e., data locations or constants). A low-level computer operation (i.e., machine code or assembly language) operates on binary data in memory or registers. Although computers have become millions of times faster over the decades, the nature of the low-level instruction has <span class="No-Break">hardly changed.</span></p>&#13;
			<p lang="en-GB">Many first-generation microprocessors (e.g., 8080, 6800, Z80, and 6502) of the 1970s and 1980s used 8-bit instructions that had to be chained together to create a more practical instruction – for example, 8-bit microprocessors provide 16-bit instructions by chaining together two consecutive <span class="No-Break">8-bit instructions.</span></p>&#13;
			<p lang="en-GB">The second generation of microprocessors, such as Intel’s 8086 and Motorola’s 68000, had 16-bit instructions. These too were chained together to create sufficiently long instructions to perform all the necessary operations. Indeed, the 68000 actually chained up to five consecutive 16-bit words to create a gigantic 80-bit instruction. Modern high-performance microprocessors (e.g., ARM, MIPS, and RISC-V) have 32-bit or 64-bit instructions that provide a full instruction set without the need to chain consecutive instructions. The CISC approach to chaining instructions together to increase the number of opcodes was a great idea at the time. However, it reduces performance by making it difficult to execute instructions in parallel because a computer does not know where the boundaries lie between instructions until they have <span class="No-Break">been decoded.</span></p>&#13;
			<p lang="en-GB">Later in this book, we will take <a id="_idIndexMarker202"/><a id="_idIndexMarker203"/>a brief look at the concept of multi-length <span class="No-Break">instruction sets.</span></p>&#13;
			<h2 id="_idParaDest-58" lang="en-GB"><a id="_idTextAnchor058"/>Instruction types and formats</h2>&#13;
			<p lang="en-GB">Now, we will describe the type <a id="_idIndexMarker204"/><a id="_idIndexMarker205"/>of primitive operations computers perform. First, a surprise. How many different instructions does a computer need? I mean, how many does it need to solve any problem that can be solved by a computer, today, tomorrow, and at any point in the future? The remarkable answer is one. Yes, you can solve any problem with the permutations of one <span class="No-Break">single instruction.</span></p>&#13;
			<p lang="en-GB">According to Wikipedia, the <strong class="source-inline">SBNZ a,b,c,d</strong> instruction <em class="italic">(“subtract and branch if not equal to zero”</em>) subtracts the contents at address <strong class="source-inline">a</strong> from the contents at address <strong class="source-inline">b</strong>, stores the result at address <strong class="source-inline">c</strong>, and then, if the result is not <strong class="source-inline">0</strong>, transfers control to address <strong class="source-inline">d</strong> (if the result is equal to zero, the execution proceeds to the next instruction in sequence). Expressed in RTL, the <strong class="source-inline">SBNZ</strong> instruction is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>[c] ← [b] – [a]</span>&#13;
<span>if [c] != 0: [pc] ← d</span>&#13;
<span>else: [pc] ← [pc] + 1</span></pre>&#13;
			<p lang="en-GB">All computation can be done using this single instruction alone. In practice, such a computer would be impossibly inefficient and impractical. However, it hints that a large and complex set of instructions is not necessarily required to build a computer. Most computers today have a relatively modest number of instructions. However, some computer designers now create optimized special-purpose instruction set enhancements for specific applications (e.g., graphics, signal processing, <span class="No-Break">and AI).</span></p>&#13;
			<p lang="en-GB">From the first computer to today’s chips with over 10 billion transistors, computers have had instruction sets that include the following three classes of operation. <em class="italic">Table 3.3</em> gives the name of the instruction group, an example of an operation in Python, and a typical assembly <span class="No-Break">language instruction.</span></p>&#13;
			<table id="table005" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Instruction Group</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Typical </strong><span class="No-Break"><strong class="bold">Python Code</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Assembly Language</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Arithmetic <span class="No-Break">and logical</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">c = (a + b) * c</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">ADD </strong></span><span class="No-Break"><strong class="bold">r1</strong></span><span class="No-Break"><strong class="source-inline">,r2,r3</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Data movement</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">x = y</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">MOV </strong></span><span class="No-Break"><strong class="bold">r1</strong></span><span class="No-Break"><strong class="source-inline">,r2</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Conditional</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">if x == 4: y = 7</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">BEQ next</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.5 – Instruction classes</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The TC1 that we are going to design has a 32-bit instruction and can provide up to 2<span class="superscript">32</span> = 4,294,967,296 unique instructions. In practice, the instruction provides memory addresses, numerical constants (i.e., literals), and register numbers, which means that the number of unique instructions you can define is a <span class="No-Break">lot smaller.</span></p>&#13;
			<p lang="en-GB">TC1 has a 32-bit instruction but only a 16-bit data word. This arrangement makes it easier to design and understand the computer, and you can load a 16-bit data word with a single 32-bit instruction. Computers with 32-bit instructions and data have to use convoluted methods to load 32-bit data words, as we shall see when we introduce <span class="No-Break">the ARM.</span></p>&#13;
			<p lang="en-GB">It may seem strange that I allow a binary number to be specified as either <strong class="source-inline">0b1101</strong> or <strong class="source-inline">%1101</strong>, and I allow hexadecimal numbers to be formatted as <strong class="source-inline">0x1AC</strong> or <strong class="source-inline">$1AC</strong>. I did this for two reasons. The first is that I was brought up in a Motorola world where the <strong class="source-inline">%</strong> and <strong class="source-inline">$</strong> prefixes were used, but now I live in a C world where the <strong class="source-inline">0b</strong> and <strong class="source-inline">0x</strong> prefixes are used. Habit makes <strong class="source-inline">%</strong> and <strong class="source-inline">$</strong> more natural for me. Secondly, I want to show you that you can choose your own formats <span class="No-Break">and conventions.</span></p>&#13;
			<p lang="en-GB">TC1’s instruction set is designed for<a id="_idIndexMarker206"/><a id="_idIndexMarker207"/> simplicity rather than computational elegance. The instruction set is realistic in terms of the concepts it involves but not in terms of its implementation. For our purposes, we have given all instructions in identical formats. In a real computer, there are usually several classes of instruction, each with its own format. By having a single format, we can simplify instruction decoding <span class="No-Break">and execution.</span></p>&#13;
			<p lang="en-GB">A 32-bit instruction set is used by many high-performance microprocessors and is ideal for demonstration and teaching purposes. Typically, computers use the same size for data elements as they do for instructions. TC1 uses 32-bit instructions but 16-bit data elements because it is easier for students to read and manipulate 16-bit values than 32-bit values (modifying the TC1 computer to operate with 32-bit data would be a very <span class="No-Break">easy task).</span></p>&#13;
			<p lang="en-GB">In order to write a machine-level program for TC1, you would have to hand-code each instruction into a 32-bit binary sequence. This is easy to do, but it’s horribly tedious. We have also designed a simple assembler that allows you to write instructions in assembly language form. The TC1 assembler translates an instruction in the form <strong class="source-inline">ADD</strong><strong class="source-inline"> </strong><span class="pcode-bold">r7</span><strong class="source-inline">,r2,r3</strong> into a binary string such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">000000111101001100000000000000000</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">Normally, an assembler is a separate piece of code from a simulator. You provide the assembler with a <em class="italic">source file</em> (in text format), and the assembler creates a <em class="italic">binary code file</em> that the simulator executes. The TC1 assembler is part of the simulator, so you don’t have to worry about creating binary files for <span class="No-Break">the simulator.</span></p>&#13;
			<p lang="en-GB">We have made the TC1 assembler as simple as possible to reduce the level of complexity and keep the final Python program reasonably short. It would take a lot more high-level language code to write a comprehensive assembler. This assembler performs no error-checking on the source program (i.e., it doesn’t detect an error when you mistype something). It supports the use of symbolic values for variables and addresses – that is, you can write <strong class="source-inline">BEQ loop</strong> rather than <strong class="source-inline">BEQ 7</strong>, where the symbolic name <strong class="source-inline">loop</strong> labels line <span class="No-Break">number</span><span class="No-Break"><strong class="source-inline"> 7</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The TC1 assembler allows you to enter numbers in decimal, binary, or hexadecimal formats – for example, you can write <strong class="source-inline">LDRL </strong><span class="pcode-bold">r0</span><strong class="source-inline">,255, LDRL </strong><span class="pcode-bold">r0</span><strong class="source-inline">,0xFF, or LDRL </strong><span class="pcode-bold">r0</span><strong class="source-inline">,%11111111</strong>. The operation <strong class="source-inline">LDRL</strong> means, “<em class="italic">load a register with a literal (i.e., an actual) value</em>.” In each case, the instruction puts the binary value for <strong class="source-inline">255</strong> in <span class="No-Break">register </span><span class="No-Break"><strong class="source-inline">r0</strong></span><span class="No-Break">.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">All computers operate on data that is either in memory or in one of a few on-chip registers. Typically, a computer has between <strong class="source-inline">2</strong> and <strong class="source-inline">32</strong> on-chip registers. The TC1 computer has eight registers, <strong class="source-inline">r0</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">r7</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">Computer instructions have many different formats, depending on the architecture of the computer. The two fundamental formats are <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">CISC-style operations allow general instructions to access memory (e.g., <strong class="source-inline">ADD </strong><span class="pcode-bold">r3</span><strong class="source-inline">,1200</strong> means, add the contents of memory location 1,200 to <span class="No-Break">register 3</span><span class="No-Break">)</span></li>&#13;
				<li lang="en-GB">RISC-style: All data-processing operations are between registers (e.g., <strong class="source-inline">ADD </strong><span class="pcode-bold">r1</span><strong class="source-inline">,r2,r3</strong>), and the only memory accesses are <em class="italic">load a register from memory and store a register </em><span class="No-Break"><em class="italic">in memory</em></span></li>&#13;
			</ul>&#13;
			<p lang="en-GB">Typical assembly language instruction<a id="_idIndexMarker208"/><a id="_idIndexMarker209"/> formats that we will use in our first computer are <span class="No-Break">as follows:</span></p>&#13;
			<table id="table006" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Format</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Mnemonic</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Action</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Two address</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">MOV</strong><strong class="source-inline CharOverride-9">  </strong><span class="No-Break"><span class="pcode-bold">r0</span></span><span class="No-Break"><strong class="source-inline">,r1</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Copy the contents of register <strong class="source-inline">r1</strong> to <span class="No-Break">register </span><span class="No-Break"><strong class="source-inline">r0</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Three address</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">ADD</strong><strong class="source-inline CharOverride-9">  </strong><span class="No-Break"><span class="pcode-bold">r0</span></span><span class="No-Break"><strong class="source-inline">,r1,r2</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Add the contents of register <strong class="source-inline">r1</strong> to <strong class="source-inline">r2</strong> put the result <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">r0</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Literal</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">ADDL </strong></span><span class="No-Break"><span class="pcode-bold">r0</span></span><span class="No-Break"><strong class="source-inline">,r1,24</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Add literal <strong class="source-inline">24</strong> to <strong class="source-inline">r1</strong> and put the result <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">r0</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Branch</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">BEQ</strong><strong class="source-inline CharOverride-9">  </strong><strong class="source-inline">5</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">If z-bit set, jump to instruction at <span class="No-Break">address </span><span class="No-Break"><strong class="source-inline">5</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Load <span class="No-Break">register indirect</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">LDRI</strong><strong class="source-inline CharOverride-9">  </strong><span class="No-Break"><span class="pcode-bold">r0</span></span><span class="No-Break"><strong class="source-inline">,[r1,10]</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Load <strong class="source-inline">r0</strong> with the contents of memory at address <strong class="source-inline">r1 + </strong><span class="No-Break"><strong class="source-inline">10</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p lang="en-GB">There is no universal assembly language format, and conventions differ from assembler to assembler (even for the same machine). For example, one assembly language might use the format <strong class="source-inline">MOV </strong><span class="pcode-bold">r1</span><strong class="source-inline">,r2</strong> to load <strong class="source-inline">r1</strong> with <strong class="source-inline">r2</strong>, and the other might use it to load <strong class="source-inline">r2</strong> with <strong class="source-inline">r1</strong> – that is, the destination can be on the left or the right. I put the destination for operands on the left, which appears to be the more common convention. I also put the destination in bold font as <span class="No-Break">a reminder.</span></p>&#13;
			<p lang="en-GB">A simple example of a program that adds together the first 10 integers is shown in the following code snippet in a hypothetical assembly language. This is not the most efficient way of writing this fragment of code; it’s just intended as a demonstration. The version of the TC1 assembler we design here accepts uppercase or lowercase characters, and either a space or a comma can be used as a separator – for example, you can happily write <span class="No-Break">the following:</span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">lOOp aDdL r1 </strong><span class="No-Break"><strong class="source-inline">R2,r3 or</strong></span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">Loop </strong><span class="No-Break"><strong class="source-inline">ADDL R1,r2,R3.</strong></span></p>&#13;
			<p lang="en-GB">Consider the following example of TC1 assembly language. Note that I use <strong class="source-inline">@</strong> to indicate a comment field because that is the standard for the ARM assembly language, which we will introduce later. We will continue to use the <strong class="source-inline">#</strong> symbol for comments <span class="No-Break">in Python.</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>        LDRL <strong class="bold">r0</strong>,0          <span class="sc-comment">@ Load register r0 with 0 (the sum)</span></span>&#13;
<span>        LDRL <strong class="bold">r1</strong>,0          <span class="sc-comment">@ Load register r1 with 0 (the counter)</span></span>&#13;
<span>Loop    ADDL <strong class="bold">r1</strong>,r1,1       <span class="sc-comment">@ Increment the counter in r1</span></span>&#13;
<span>        ADD  <strong class="bold">r0</strong>,r0,r1      <span class="sc-comment">@ Add the count to the sum in r0</span></span>&#13;
<span>        CMPL r1,10         <span class="sc-comment">@ Compare the count with 10</span></span></pre>&#13;
			<pre class="source-code">        BNE  Loop          <span class="sc-comment">@ Branch back to Loop until all numbers added</span></pre>&#13;
			<h2 id="_idParaDest-59" lang="en-GB"><a id="_idTextAnchor059"/>CISC and RISC</h2>&#13;
			<p lang="en-GB">In this book, we use the terms RISC and CISC repeatedly. These two terms are vital to the understanding of a modern computer. They describe two different approaches to the implementation of a computer. The early 1980s saw the CISC versus RISC war when two different<a id="_idIndexMarker210"/><a id="_idIndexMarker211"/> architectures competed for the computing market. The term <strong class="bold">complex instruction set computer (CISC)</strong> is analogous<a id="_idIndexMarker212"/><a id="_idIndexMarker213"/> to the<a id="_idIndexMarker214"/><a id="_idIndexMarker215"/> term <em class="italic">analog watch</em>. When the digital watch was invented, watches with moving hands suddenly became analog watches in order to distinguish them from <a id="_idIndexMarker216"/><a id="_idIndexMarker217"/>digital watches. Similarly, the term <em class="italic">complex instruction set computer</em> didn’t exist until it was coined to contrast with the <a id="_idIndexMarker218"/><a id="_idIndexMarker219"/>new <strong class="bold">reduced instruction set </strong><span class="No-Break"><strong class="bold">computer (RISC)</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">From the moment computers were<a id="_idIndexMarker220"/><a id="_idIndexMarker221"/> invented, they just grew. As technology advanced, new features were just bolted onto existing computers. Someone once said that if the aircraft had developed like the computer, every jumbo jet would have had a 1903 Wright Flyer at its core. This approach wasn’t cost-effective because technology had changed so dramatically that the design of computers needed to be reconsidered. In particular, memory capacity had grown exponentially, and the cost per bit had plummeted. Similarly, the 8- and 16-bit wordlengths gave way to the 32- and 64-bit instruction sets. Doing things the old way was <span class="No-Break">not efficient.</span></p>&#13;
			<p lang="en-GB">First- and second-generation microprocessors were <em class="italic">accumulator</em>-based. They applied operations to an accumulator on the processor and a memory location. Instructions were called <em class="italic">one-and-a-half addresses</em> because they had a memory address and an accumulator address (since there were only a few accumulators, they were jokingly referred to as having “<em class="italic">half an address</em>”). To perform <strong class="source-inline">C = A + B</strong> (where <strong class="source-inline">A</strong>, <strong class="source-inline">B</strong>, and <strong class="source-inline">C</strong> are memory addresses), you would have to write <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>LDA A            <span class="sc-comment">@ Load accumulator with A</span></span>&#13;
<span>ADD B            <span class="sc-comment">@ Add B to the accumulator</span></span>&#13;
<span>STA C            <span class="sc-comment">@ Store the accumulator in C</span></span></pre>&#13;
			<p lang="en-GB">Passing all data through the accumulator creates a bottleneck. Because computer speed increased faster than memory speed, programmers wanted to keep as much data on-chip <span class="No-Break">as possible.</span></p>&#13;
			<p lang="en-GB">The RISC solution adopted a <em class="italic">register-to-register</em> architecture. The only operations permitted on memory are the transfer of data between a register and memory. Instead of having one or two accumulators, RISC processors have 16 or 32 registers. The preceding code on a RISC processor can be typically represented by <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>LDR <strong class="bold">r0</strong>,[r1]      <span class="sc-comment">@ Load r0 with data pointed at by r1</span></span>&#13;
<span>LDR <strong class="bold">r2</strong>,[r3]      <span class="sc-comment">@ Load r2 with data pointed at by r3</span></span>&#13;
<span>ADD <strong class="bold">r4</strong>,r0,r2     <span class="sc-comment">@ Add r0 and r2, result in r4</span></span>&#13;
<span>STR r4,<strong class="bold">[r5]</strong>      <span class="sc-comment">@ Store r4 in memory pointed at by r5</span></span></pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">All data movement is between memory and a register, and data-processing operations apply only to registers. Instructions have <span class="No-Break">three operands.</span></p>&#13;
			<p lang="en-GB">RISC computers introduced other enhancements, such as overlapping the execution of instructions (called <em class="italic">pipelining</em>). Many in the 1980s expected Intel’s CISC computers to die out. They didn’t. Intel cleverly incorporated RISC features into its CISC processors. AMD designed a RISC architecture that took Intel’s CISC instructions and translated them into a sequence of RISC commands before <span class="No-Break">executing them.</span></p>&#13;
			<p lang="en-GB">To summarize, CISC processors have instruction sets that perform operations between an operand in memory and one in a register. All RISC data-processing operations take place between operands in registers. The only memory operations RISC processors permit are <em class="italic">loading a register from memory and storing a register </em><span class="No-Break"><em class="italic">in memory</em></span><span class="No-Break">.</span></p>&#13;
			<h2 id="_idParaDest-60" lang="en-GB"><a id="_idTextAnchor060"/>Two ways of representing literals</h2>&#13;
			<p lang="en-GB">Assemblers differ in how they represent <a id="_idIndexMarker222"/><a id="_idIndexMarker223"/>instructions because assemblers developed rapidly over a few short years in competitive industries. Each manufacturer designed an assembler for their own microprocessors. Some adopted a left-to-right convention with the destination operand on the right, and some adopted a right-to-left convention with the destination operand on the right. Consequently, one manufacturer’s <strong class="source-inline">mov a,b</strong> meant <strong class="source-inline">a ← b</strong>, and another’s meant <strong class="source-inline">b ← a</strong>. Similarly, mnemonics were also unstandardized – for example, <strong class="source-inline">MOVE, MOV</strong>, and <strong class="source-inline">LDA</strong> all define a <span class="No-Break">copy operation.</span></p>&#13;
			<p lang="en-GB">Since the assembler is just a human-readable version of machine code, it doesn’t actually matter how we represent an instruction. It’s the binary code that gets executed, irrespective of how we represent it in text form. However, from a teaching and learning perspective, the variations in conventions are a nuisance. Consider the representation of a literal value in <span class="No-Break">an instruction.</span></p>&#13;
			<p lang="en-GB">Some assemblers represent a literal by using a special instruction – for example, <span class="pcode-bg">ADD</span><strong class="source-inline"> </strong><span class="pcode-bold">r1</span><strong class="source-inline">,r2,r3</strong> for a three-register addition, and <strong class="source-inline">ADDL r1,r2,24</strong> for a literal operand. Other assemblers use the <em class="italic">same</em> mnemonic in both cases but prefix the literal by a symbol to indicate that it’s a literal operation – for example, <strong class="source-inline">ADD r1,r2,#25</strong>. Some assemblers use <strong class="source-inline">#</strong> to indicate a literal and others <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">%</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">In this text, we’ve used the <strong class="source-inline">ADDL</strong> convention in the design of some simulators, but we will use the <strong class="source-inline">#</strong> convention when we introduce the ARM processor because that’s used by ARM assemblers. In retrospect, if I were writing this book again, I think I might have been tempted to use only one representation, the <strong class="source-inline">#</strong> symbol. However, by using <strong class="source-inline">ADD</strong> and <strong class="source-inline">ADDL</strong>, I was able to simplify the Python code because the <em class="italic">decision point</em> between register and literal operands was made when examining the mnemonic, not when examining <span class="No-Break">the literal.</span></p>&#13;
			<h1 id="_idParaDest-61" lang="en-GB"><a id="_idTextAnchor061"/>Summary</h1>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">In this key chapter, we introduced the von Neumann computer with its <strong class="source-inline">fetch-execute</strong> cycle, where an instruction is read from memory, decoded, and executed in a two-phase operation. It is precisely these actions that we will learn to simulate in later chapters in order to build a computer in software. We have looked at the flow of information as an instruction is executed. The model of the computer we introduced here is the traditional model and does not take into account current technology that executes multiple instructions in <span class="No-Break">a pipeline.</span></p>&#13;
			<p lang="en-GB">We also looked at the instruction format and described how it has several fields – for example, the opcode that defines the operation and the data required by the operation (e.g., addresses, literals, and register numbers). You will eventually be able to design your own instructions (thereby defining the computer’s instruction set architecture) and create a computer that will execute <span class="No-Break">these instructions.</span></p>&#13;
			<p lang="en-GB">While describing the operation of a von Neumann computer, we introduced sufficient Python code to show the direction we are heading in and hint at how simulation can be <span class="No-Break">carried out.</span></p>&#13;
			<p lang="en-GB">In the next chapter, we will begin to look more closely at the concept of an interpreter that reads a machine-level instruction and carries out its <span class="No-Break">intended actions.</span></p>&#13;
		</div>&#13;
	</div></body></html>