<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Web Services</h1></div></div></div><p>In<a class="link" href="ch05.html" title="Chapter 5. A Photoblog Application">Chapter 5</a>, we defined the data access layer and the entities our application would manipulate. In this chapter, we will explain how we can articulate our photoblog application by using web services as an API to access and operate the entities we have defined. We will introduce the concept of web services based on the REST principles as well as the Atom Publishing Protocol and explain how we can implement them using CherryPy. By the end of this chapter, you should understand how web services can enhance and extend the capacities of your web application while providing a simple entry point for third-party applications.<a id="id168" class="indexterm"/>
</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec01"/>Traditional Web Development</h1></div></div></div><p>Most web applications use the same base URI to handle the serving of resources and the manipulation of resources. For instance, it's common to find something such as the following:<a id="id169" class="indexterm"/>
</p><div><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col width="1.5" style="text-align: left" class="C1"/><col width="1.3125" style="text-align: left" class="C2"/><col width="0.697916666666667" style="text-align: left" class="C3"/><col width="1.77708333333333" style="text-align: left" class="C4"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>URI</p>
</th><th style="text-align: left" valign="bottom">
<p>Request Body</p>
</th><th style="text-align: left" valign="bottom">
<p>HTTP Method</p>
</th><th style="text-align: left" valign="bottom">
<p>Operation</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">/album/</code>
</p>
</td><td style="text-align: left" valign="top">
<p>N/A</p>
</td><td style="text-align: left" valign="top">
<p>GET</p>
</td><td style="text-align: left" valign="top">
<p>Fetch all albums</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">/album/?id=12</code>
</p>
</td><td style="text-align: left" valign="top">
<p>N/A</p>
</td><td style="text-align: left" valign="top">
<p>GET</p>
</td><td style="text-align: left" valign="top">
<p>Fetch the album with the ID 12</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">/album/edit?id=12</code>
</p>
</td><td style="text-align: left" valign="top">
<p>N/A</p>
</td><td style="text-align: left" valign="top">
<p>GET</p>
</td><td style="text-align: left" valign="top">
<p>Return a form to perform an action on a resource</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">/album/create</code>
</p>
</td><td style="text-align: left" valign="top">
<p>title=Friends</p>
</td><td style="text-align: left" valign="top">
<p>POST</p>
</td><td style="text-align: left" valign="top">
<p>Create an album</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">/album/delete</code>
</p>
</td><td style="text-align: left" valign="top">
<p>id=12</p>
</td><td style="text-align: left" valign="top">
<p>POST</p>
</td><td style="text-align: left" valign="top">
<p>Delete the album with the ID 12</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">/album/update</code>
</p>
</td><td style="text-align: left" valign="top">
<p>id=12&amp;title=Family</p>
</td><td style="text-align: left" valign="top">
<p>POST</p>
</td><td style="text-align: left" valign="top">
<p>Update the album with the ID 12</p>
</td></tr></tbody></table></div><p>Within an application hosted with CherryPy, this could be translated into:</p><div><pre class="programlisting">class Album:
@cherrypy.expose
def index(self, id=None):
# returns all albums as HTML or the one
# requested by the id parameter if provided
@cherrypy.expose
def edit(self, id=None):
# returns an HTML page with a form to perform
# an action on a resource (create, update, delete)
@cherrypy.expose
def create(self, title):
# create an album with a title
# returns an HTML page stating the success
@cherrypy.expose
def update(self, id, title):
# update an album with a title
# returns an HTML page stating the success
@cherrypy.expose
def delete(self, id):
# delete the album with the given id
# returns an HTML page stating the success
</pre></div><p>Although this methodology is valid, it is not the best choice when it needs to open itself to different kinds of user agents (browser, robot, service, etc.). For instance, imagine we decide to provide a fat client application to manipulate albums. In such a case, the HTML page returned by the page handlers would be useless; XML or JSON data would be more relevant. We may also want to offer part of our application as a service for third-party applications.<a id="id170" class="indexterm"/>
</p><p>One notable example is the service provided by flickr, (<a class="ulink" href="http://www.flickr.com/">http://www.flickr.com/</a>) the online photo-management application, which allows someone to query the flickr service (<a class="ulink" href="http://www.flickr.com/services/api/">http://www.flickr.com/services/api/</a>) for their data in many contexts like getting current photos, activities, blog posts, comments, etc. in different formats. Thanks to these web services a large set of third-party applications have grown to extend flickr users' experience from a web application or even from a fat client application.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec01"/>Separation of Concerns</h2></div></div></div><p>The issue with the previous design example is the lack of<strong> separation of concerns</strong>. As Tim Bray said about the Web (please refer to <a class="ulink" href="http://www.tbray.org/ongoing/When/200x/2006/03/26/On-REST">http://www.tbray.org/ongoing/When/200x/2006/03/26/On-REST</a> for more details):<a id="id171" class="indexterm"/>
</p><p>
<em>You have a lot of things in the system, identified by URIs</em>.</p><p>
<em>There are two kinds of operations against a resource in the system: those that can change its state, and those that can't</em>.</p><p>From the first statement we put a<em> name</em> on anything that can pass through the system; we call it a resource. Examples of resources could be a picture, a poem, results of a basketball game, temperature in Australia, etc. We also learn that each resource should be identified in a non-equivocal way. From Tim's second statement we realize that we should logically separate in our design—operations that are read-only and those that can change the resource.</p><p>An important corollary of these distinctions is that we would like to let the client inform the server about the content type that it would prefer to receive. In our example, our page handlers solely return HTML pages while it would be more flexible to check what the client can handle and send it the best representation of the resource.</p><p>Web application developers should consider the following principles:</p><div><ul class="itemizedlist"><li class="listitem"><p>Anything is a resource.</p></li><li class="listitem"><p>A resource has one or several identifiers but one identifier can lead to only one resource.</p></li><li class="listitem"><p>A resource has one or many representations that the client can request.</p></li><li class="listitem"><p>Operations on resources are divided into those that alter the state of the resource and those that do not.</p></li></ul></div><p>Based on these elements we can redefine our design as follows:</p><div><pre class="programlisting">class Album:
@cherrypy.expose
def index(self):
# returns all albums as HTML
@cherrypy.expose
def default(self, id):
# returns the album specified or raise a NotFound
@cherrypy.expose
def edit(self, id=None):
# returns an HTML page with a form to perform
# an action on a resource (create, update, delete)
class AlbumManager:
@cherrypy.expose
def create(self, title):
# create an album with a title
# returns an XML/JSon/XHTML document
# representing the resource
@cherrypy.expose
def update(self, id, title):
# update an album with a title
# returns an XML/JSon/XHTML document
# representing the resource
@cherrypy.expose
def delete(self, id):
# delete the album with the given id
# returns nothing
<a id="id172" class="indexterm"/>
</pre></div><p>By doing so we allow any kind of user agent to manipulate a resource by requesting the<code class="literal"> AlbumManager</code> exposed handlers. A browser would still fetch an HTML representation of an album from the<code class="literal"> Album</code> page handlers. You might argue that a browser would not know what is to be done with the returned XML or JSON data from the<code class="literal"> AlbumManager</code> page handlers. The missing piece of information here is that submission of the HTML form and the handling of its response would be performed by some client-side scripting code via JavaScript that would be able to process the XML or JSON chunk of data accordingly. We will go through this technique in more detail in<a class="link" href="ch07.html" title="Chapter 7. The Presentation Layer">Chapter 7</a>.</p><p>The principles defined above are the basis of what are referred to today as<strong> web services</strong>. A web service is an API provided by a web application so that heterogeneous user agents can interact with the application through formats other than HTML. There are different ways to create web services via REST, SOAP, XML-RPC, Atom, etc. For the purpose of this book we will review REST and the Atom Publishing Protocol as web services for the photoblog application.</p></div></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec02"/>REST</h1></div></div></div><p>
<strong>Representational State Transfer</strong> (<strong>REST</strong>) is an architecture style for distributed hypermedia systems described by Roy T. Fielding in his dissertation Architectural Styles and the Design of Network-based Software Architectures in 2000.<a id="id173" class="indexterm"/>
</p><p>REST is based on the following elements:</p><div><ul class="itemizedlist"><li class="listitem"><p>
<em>Resource:</em> A resource is the abstract concept of anything. For instance, it can be an image, a blog entry, the current rate between two currencies, a sport result, a mathematical equation, etc.<a id="id174" class="indexterm"/>
</p></li><li class="listitem"><p>
<em>Resource identifier:</em> Allows components of the distributed system to identify a resource in a unique way.</p></li><li class="listitem"><p>
<em>Representation:</em> A representation of the resource is simply data.</p></li><li class="listitem"><p>
<em>Representation metadata:</em> Information about the representation itself.</p></li><li class="listitem"><p>
<em>Resource metadata:</em> Information about the resource.</p></li><li class="listitem"><p>
<em>Control data:</em> Information about the messages passing through the system between components.</p></li></ul></div><p>REST also suggests that each message flowing should be<strong> stateless</strong> meaning that it should contain enough information for its processing by the next component within the system and thus should not depend on previous or following messages. Each message is self-contained. This is achieved through the use of resource metadata and representation metadata.</p><p>These are the elements describing REST but they are not tied to any underlying protocol. The most commonly used case of REST can be found within the Web and is implemented using the HTTP protocol. In spite of that REST can be implemented using other protocols in other environments.</p><p>HTTP is a good candidate to implement REST for the following reasons:<a id="id175" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem"><p>It is the base of the Web, which is a distributed hypermedia system.</p></li><li class="listitem"><p>It is stateless.</p></li><li class="listitem"><p>Each request can contain enough information to be processed independently of the rest of the system.</p></li><li class="listitem"><p>The content-type and accept headers used by HTTP provide the means to represent a single resource through different representations.</p></li><li class="listitem"><p>URIs are powerful and common resource identifiers.</p></li></ul></div></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec03"/>Uniform Resource Identifier</h1></div></div></div><p>REST is about naming resources on a network and providing a unified mechanism to perform operations on these resources. That's why REST tells us that a resource is identified by at least one identifier. When implementing a REST infrastructure based on the HTTP protocol, these identifiers are defined as<strong> Uniform Resource Identifiers</strong> (<strong>URIs</strong>).<a id="id176" class="indexterm"/>
</p><p>Two common subsets of the URI set are:<a id="id177" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem"><p>
<strong>Uniform Resource Locator</strong> (<strong>URL</strong>), such as:
<a class="ulink" href="http://www.cherrypy.org/">http://www.cherrypy.org/</a>
</p></li><li class="listitem"><p>
<strong>Uniform Resource Name</strong> (<strong>URN</strong>), such as:
</p><div><pre class="programlisting">urn:isbn:0-201-71088-9
urn:uuid:13e8cf26-2a25-11db-8693-000ae4ea7d46
</pre></div></li></ul></div><p>The interesting aspect of URLs is that they contain enough information to locate the resource on the network. Thus in the given URL we know that to locate the resource we need to use the HTTP protocol associated to the HTTP scheme hosted on the host <a class="ulink" href="http://www.cherrypy.org">www.cherrypy.org</a> at the path<code class="literal"> /</code>. (Note, however, that not everyone in the Web community thinks that this multiplexing of capabilities is a positive aspect of URLs but this discussion is out of the scope of this book.)</p></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec04"/>HTTP Methods</h1></div></div></div><p>If URIs offer the way to name resources, HTTP methods provide the means by which we can operate on those resources. Let's review the most common methods (also referred to as verbs) in HTTP 1.1.<a id="id178" class="indexterm"/>
</p><div><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col width="1.09305555555556" style="text-align: left" class="C1"/><col width="1.20833333333333" style="text-align: left" class="C2"/><col width="2.98611111111111" style="text-align: left" class="C3"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>HTTP Method</p>
</th><th style="text-align: left" valign="bottom">
<p>Idempotent</p>
</th><th style="text-align: left" valign="bottom">
<p>Operation</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">HEAD</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>Retrieves the resource metadata. The response is the same as the one to a GET minus the body.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GET</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>Retrieves resource metadata and content.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">POST</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>Requests the server to create a new resource using the data enclosed in the request body.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PUT</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>Requests the server to replace an existing resource with the one enclosed in the request body. The server cannot apply the enclosed resource to a resource not identified by that URI.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">DELETE</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>Requests the server to remove the resource identified by that URI.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">OPTIONS</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>Requests the server to return details about capabilities either globally or specifically towards a resource.</p>
</td></tr></tbody></table></div><p>The idempotent column of the table indicates whether the request using that particular HTTP method will have the same side-effects with two consecutive identical calls.</p><p>By default CherryPy handlers reflect the path of the Request-URI and the handler matches one element of the URI, but as we have seen CherryPy's dispatcher can be changed not to look for the handler within the URI but from the request metadata such as the HTTP method used.</p><p>Let's review an example applied to the photoblog application:</p><div><pre class="programlisting">import cherrypy
from cherrypy.lib.cptools import accept
from models import Photoblog, Album
from lib.config import conf
from lib.tools import find_acceptable_within
class AlbumRESTService(object):
exposed = True
def GET(self, album_id):
best = accept(['application/xml', 'application/atom+xml',
'text/json', 'text/x-json'])
album = Album.fetch(album_id)
if not album:
raise cherrypy.NotFound()
if best in ['application/xml','application/atom+xml']:
cherrypy.response.headers['Content-Type'] =
'application/atom+xml'
entry = album.to_atom_entry()
return entry.xml()
if best in ['application/json', 'text/x-json', 'text/json']:
cherrypy.response.headers['Content-Type'] =
'application/json'
return album.to_json()
raise cherrypy.HTTPError(400, 'Bad Request')
def POST(self, title, segment, author, description, content,
blog_id):
photoblog = Photoblog.fetch(blog_id)
if not photoblog:
raise cherrypy.NotFound()
album = Album()
album.create(photoblog, title, segment, author, description,
content)
cherrypy.response.status = '201 Created'
cherrypy.response.headers['Location'] = '%s/album/%d' %
(conf.app.base_url, album.ID)
def PUT(self, album_id, title, segment, author, description,
content):
album = Album.fetch(album_id)
if not album:
raise cherrypy.NotFound()
album.update(title, segment, author, description, content)
def DELETE(self, album_id):
album = Album.fetch(album_id)
if album:
album.delete()
cherrypy.response.status = '204 No Content'
</pre></div><p>Let's explain what each HTTP method does in this context.</p><div><ul class="itemizedlist"><li class="listitem"><p>
<code class="literal">GET:</code> This returns the representation of the requested resource depending on the<code class="literal"> Accept</code> header. Our application allows<code class="literal"> application/xml, application/atom+xml, text/json</code>, or<code class="literal"> text/x-json</code>. We use a function called<code class="literal"> accept</code>, which returns the acceptable header found or raises a<code class="literal"> cherrypy.HTTPError (406, 'Not Acceptable')</code> error immediately to inform the user agent that our application cannot deal with its request. Then we verify if the resource still exists; if not, we raise a<code class="literal"> cherrypy.NotFound</code> error, which is a shortcut to<code class="literal"> cherrypy.HTTPError(404, 'Not Found')</code>. Once we have our pre-conditions checked, we return the requested representation of the resource.</p><p>Note that this is equivalent to the <code class="literal">index()</code> method with the default dispatcher. Bear in mind though that there is no equivalent to the <code class="literal">default()</code> method when using the method dispatcher.
</p></li><li class="listitem"><p>
<code class="literal">POST:</code> The HTTP<code class="literal"> POST</code> method allows a user agent to create a new resource. The first step is to check if the photoblog that will handle that resource exists. Then we create the resource and we return a status code<code class="literal"> 201 Created</code> along with the<code class="literal"> Location</code> header indicating the URI to retrieve the newly created resource.</p></li><li class="listitem"><p>
<code class="literal">PUT:</code> The HTTP<code class="literal"> PUT</code> method allows the user agent to replace a resource with the one provided in the request body. It is often considered as an update operation. Although RFC 2616 does not forbid<code class="literal"> PUT</code> to also create a new resource, we will not use it that way in our application as we will explain later.</p></li><li class="listitem"><p>
<code class="literal">DELETE:</code> The<code class="literal"> DELETE</code> method requests the server to remove the resource. A response to this method can either be<code class="literal"> 200 OK</code> or<code class="literal"> 204 No Content</code>. The latter informs the user agent that it should not change its current state since the response has no body.</p></li></ul></div><p>The (lack of) difference between<code class="literal"> POST</code> and<code class="literal"> PUT</code> has long been a source of discussion among web developers. Some consider that having two methods is misleading. Let's try to understand why they are distinct and why we need both.</p><p>
<code class="literal">POST</code> request:</p><div><pre class="programlisting">POST /album HTTP/1.1
Host: localhost:8080
Content-Length: 77
Content-Type: application/x-www-form-urlencoded
blog_id=1&amp;description=Family&amp;author=sylvain&amp;title=My+family&amp;content=&amp;
segment=
</pre></div><p>
<code class="literal">POST</code> response:</p><div><pre class="programlisting">HTTP/1.1 201 Created
Content-Length: 0
Location: http://localhost:8080/album/12
Allow: DELETE, GET, HEAD, POST, PUT
Date: Sun, 21 Jan 2007 16:30:43 GMT
Server: CherryPy/3.0.0
Connection: close
</pre></div><p>
<code class="literal">PUT</code> request:</p><div><pre class="programlisting">PUT /album/12 HTTP/1.1
Host: localhost:8080
Content-Length: 69
Content-Type: application/x-www-form-urlencoded
description=Family&amp;author=sylvain&amp;title=Your+family&amp;content=&amp;segment=
</pre></div><p>
<code class="literal">PUT</code> response:</p><div><pre class="programlisting">HTTP/1.1 200 OK
Date: Sun, 21 Jan 2007 16:37:12 GMT
Content-Length: 0
Allow: DELETE, GET, HEAD, POST, PUT
Server: CherryPy/3.0.0
Connection: close
</pre></div><p>At first look, two requests seem fairly similar but in fact they have a very important difference, which is the requested URI.</p><p>One can<code class="literal"> POST</code> data to a URI where a process may or may not create a resource whereas in the case of<code class="literal"> PUT</code> the URI is one of the resources itself and the content sent is the new representation of the resource. In that case, if the resource does not exist yet at that URI, the server can create it if it has been implemented to do so; otherwise the server can return an HTTP error message indicating it is not fulfilling the request. In a nutshell, client POST data to a process but PUT the new representation of the resource identified by the request URI.<a id="id179" class="indexterm"/>
</p><p>One of the root causes of the problem is the fact that many web applications rely only on the<code class="literal"> POST</code> method to achieve any operation on a resource, whether creating, updating, or deleting it. This is notably the case because these applications often offer only HTML forms, which only support<code class="literal"> GET</code> and<code class="literal"> POST</code>, to perform those operations.</p><p>Considering the fact that more and more web applications take advantage of separation of concerns and handle submission through client code via JavaScript or external services, it is likely that the use of the<code class="literal"> PUT</code> and<code class="literal"> DELETE</code> methods increasing, though it might be a problem in some environments where firewall policies forbid<code class="literal"> PUT</code> and<code class="literal"> DELETE</code> requests.</p></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec05"/>Putting it Together</h1></div></div></div><p>Our photoblog application will provide a REST interface for the following entities: Album, Film, and Entry. Because of the information they carry, their relationship, and their design we can provide the same interface independent of the entity itself. Therefore we refactor the<code class="literal"> Album</code> class and create a<code class="literal"> Resource</code> class that will centralize the implementation of each operation. Each entity-service interface will simply pass the information to the<code class="literal"> Resource</code> class and let it deal with the hard work. We thus avoid the duplication of code.</p><div><pre class="programlisting">import cherrypy
from cherrypy.lib.cptools import accept
from models import Photoblog
from lib import conf
from lib.tools import find_acceptable_within
class Resource(object):
def handle_GET(self, obj_id):
best = accept(['application/xml', 'application/atom+xml',
'text/json', 'text/x-json',
'application/json'])
obj = self.__source_class.fetch(obj_id)
if not obj:
raise cherrypy.NotFound()
if best in ['application/xml', 'application/atom+xml']:
cherrypy.response.headers['Content-Type'] = 'application/atom+xml'
entry = obj.to_atom_entry()
return entry.xml()
if best in ['text/json', 'text/x-json', 'application/json']:
cherrypy.response.headers['Content-Type'] =
'application/json'
return obj.to_json()
raise cherrypy.HTTPError(400, 'Bad Request')
def handle_POST(self container_cls, container_id,
location_scheme, *args, **kwargs):
container = container_cls.fetch(container_id)
if not container:
raise cherrypy.NotFound()
obj = self.__source_class()
obj.create(container, *args, **kwargs)
cherrypy.response.status = '201 Created'
cherrypy.response.headers['Location'] = location_scheme %
(conf.app.base_url, obj.ID)
def handle_PUT(cls, source_cls, obj_id, *args, **kwargs):
obj = self.__source_class.fetch(obj_id)
if not obj:
raise cherrypy.NotFound()
obj.update(obj, *args, **kwargs)
def handle_DELETE(cls, source_cls, obj_id):
obj = self.__source_class.fetch(obj_id)
if obj:
obj.delete(obj)
cherrypy.response.status = '204 No Content'
</pre></div><p>Then let's redefine our<code class="literal"> AlbumRESTService</code> class to exploit the<code class="literal"> Resource</code> class:</p><div><pre class="programlisting">from models import Photoblog, Album
from _resource import Resource
class AlbumRESTService(Resource):
exposed = True
# The entity class that will be used by the Resource class
_source_class = Album
def GET(self, album_id):
return self.handle_GET(album_id)
def POST(self, title, segment, author, description, content,
blog_id):
self.handle_POST(Photoblog, blog_id, '%s/album/%d',
title, segment, author, description,content)
def PUT(self, album_id, title, segment, author, description,
content):
self.handle_PUT(album_id,
title, segment, author, description, content)
def DELETE(self, album_id):
self.handle_DELETE(album_id)
</pre></div><p>We have now a RESTful interface that will handle the Album resource. Both the Film and Photo entities will be managed the same way. This means that our application will now support requests such as:</p><div><pre class="programlisting">POST http://somehost.net/service/rest/album/
GET http://somehost.net/service/rest/album/12
PUT http://somehost.net/service/rest/album/12
DELETE http://somehost.net/service/rest/album/12
</pre></div><p>In each of these calls the URI is the unique identifier or name of a resource and the HTTP method is the operation to carry out on that resource.</p></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec06"/>REST Interface through CherryPy</h1></div></div></div><p>Until now, we have described services that our photoblog application will support without detailing how to achieve it through CherryPy.<a id="id180" class="indexterm"/>
</p><p>As we have seen in the previous sections HTTP REST relies on HTTP methods to inform a web application of the kind of operation a user agent wishes to carry out. In order to implement REST through CherryPy for our photoblog application we will use the HTTP method dispatcher as reviewed in<a class="link" href="ch04.html" title="Chapter 4. CherryPy in Depth">Chapter 4</a> to handle incoming requests to the service classes defined above, something along these lines:</p><div><pre class="programlisting">rest_service = Service()
rest_service.album = AlbumRESTService()
conf = {'/': {'request.dispatch': cherrypy.dispatch.MethodDispatcher()}}
cherrypy.tree.mount(rest_service, '/service/rest', config=conf)
</pre></div><p>This implies that requests applying to a URI path such as<code class="literal"> /service/rest/album/</code> will be applied in a REST spirit.</p><p>REST is quite a common term but building true RESTful applications can be a difficult task. The difficulty resides in defining a sensible and meaningful URI set associated with the application resources. In other words, the difficult part lies in the designing of the API. This section should have introduced you to the principles behind REST but developing the architecture of a large system around REST requires a high-level understanding of the resources dealt with, their naming convention, and their relationship.<a id="id181" class="indexterm"/>
</p></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec07"/>Atom Publishing Protocol</h1></div></div></div><p>In the previous section we have introduced REST and showed how it can be used as a service for web applications. In this section we will introduce the<strong> Atom Publishing Protocol</strong> (<strong>APP</strong>), which at the time of writing this book was on its way to becoming a new IETF standard. This means that some aspects of this section might no longer be up to date by the time you read them.<a id="id182" class="indexterm"/>
</p><p>APP has arisen from the Atom community as an application-level protocol on top of HTTP to allow the publishing and editing of web resources. The unit of messages between an APP server and a client is based on the Atom XML-document format defined in RFC 4287.</p><p>Although APP is not specified as being an implementation of the REST principles, the protocol does follow the same ideas, which give it a RESTful aspect. Therefore, many of the principles of the previous section will apply here; but first let's overview the Atom XML-document format.</p></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec08"/>Atom XML-Document Format</h1></div></div></div><p>The Atom XML-document format describes a set of information through two top-level elements:<a id="id183" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem"><p>Feed: A feed consists of:</p><div><ul class="itemizedlist"><li class="listitem"><p>metadata (sometimes referred as the<em> head</em> of the feed)</p></li><li class="listitem"><p>zero or more entries</p></li></ul></div></li><li class="listitem"><p>Entry: An entry is made up of:</p><div><ul class="itemizedlist"><li class="listitem"><p>metadata</p></li><li class="listitem"><p>some content</p></li></ul></div></li></ul></div><p>Example of an Atom 1.0 feed document as per RFC4287:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;feed &gt;
&lt;title&gt;Photoblog feed&lt;/title&gt;
&lt;published&gt;2006-08-13T10:57:18Z&lt;/published&gt;
&lt;updated&gt;2006-08-13T11:18:01Z&lt;/updated&gt;
&lt;link rel="self" href="http://host/blog/feed/album/" type="application/atom+xml" /&gt;
&lt;author&gt;
&lt;name&gt;Sylvain Hellegouarch&lt;/name&gt;
&lt;/author&gt;
&lt;id&gt;urn:uuid:13e8cf26-2a25-11db-8693-000ae4ea7d46&lt;/id&gt;
&lt;entry&gt;
&lt;title&gt;This is my family album&lt;/title&gt;
&lt;id&gt;urn:uuid:25cd2014-2ab3-11db-902d-000ae4ea7d46&lt;/id&gt;
&lt;link rel="self" href="http://host/blog/feed/album/12"
type="application/atom+xml" /&gt;
&lt;link rel="alternate" href="http://host/blog/album/12"
type="text/html" /&gt;
&lt;updated&gt;2006-08-13T11:18:01Z&lt;/updated&gt;
&lt;content type="text"&gt;Some content&lt;/content&gt;
&lt;/entry&gt;
&lt;/feed&gt;
</pre></div><p>A web application can serve Atom documents for subscription thus providing a way for user agents to syndicate themselves to information the application developer chooses to provide.<a id="id184" class="indexterm"/>
</p><p>Our photoblog application will provide Atom feeds of the following entities:</p><div><ul class="itemizedlist"><li class="listitem"><p>Photoblog: Each entry of the feed will link to an album feed of the blog.</p></li><li class="listitem"><p>Album: Each entry of the feed will link to a film feed of the album.</p></li><li class="listitem"><p>Film: Each entry will relate to a photo of the film.</p></li></ul></div><p>We will not explain every element of an Atom document but review a few of the most common ones.</p><div><ul class="itemizedlist"><li class="listitem"><p>
<code class="literal">id, title</code>, and<code class="literal"> updated</code> are compulsory elements in any feed or entry.</p><div><ul class="itemizedlist"><li class="listitem"><p>
<code class="literal">id</code> must be an IRI as defined in RFC 3987 as a complement to URIs</p></li><li class="listitem"><p>
<code class="literal">updated</code> must follow RFC 3339. RFC 4287 says that this element only needs to be updated when the modification is semantically significant.</p></li></ul></div></li><li class="listitem"><p>
<code class="literal">author</code> is compulsory within an Atom feed whether in the<code class="literal"> feed</code> element,<code class="literal"> entry</code> element, or both. However, entries of a feed can inherit the feed<code class="literal"> author</code> element if they do not provide one.</p></li><li class="listitem"><p>
<code class="literal">link</code> is not mandatory but is recommended and very useful to provide the following:</p><div><ul class="itemizedlist"><li class="listitem"><p>the URI of the resource associated to the entry or the feed using<code class="literal"> rel="self"</code>
</p></li><li class="listitem"><p>the URI of alternative representations of the resource using<code class="literal"> rel="alternate"</code> and specifying the media-type of the resource</p></li><li class="listitem"><p>the URI to related resources using<code class="literal"> rel="related"</code>
</p></li></ul></div></li><li class="listitem"><p>
<code class="literal">content</code> should be present at most once. Either the content of an entry is inlined within the entry as text, escaped HTML or XHTML, or the content is referenced by the<code class="literal"> src</code> attribute providing the URI of the actual content.</p></li></ul></div><p>Thus we will have for a film feed:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;feed &gt;
&lt;id&gt;urn:uuid:8ed4ae87-2ac9-11db-b2c4-000ae4ea7d46&lt;/id&gt;
&lt;title&gt;Film of my holiday&lt;/title&gt;
&lt;updated&gt;2006-08-13T13:50:49Z&lt;/updated&gt;
&lt;author&gt;
&lt;name&gt;Sylvain Hellegouarch&lt;/name&gt;
&lt;/author&gt;
&lt;entry&gt;
APPAtom XML-document&lt;id&gt;urn:uuid:41548439-c12d-48b5-baec-a72b1bf8576f&lt;/id&gt;
&lt;published&gt;2006-08-13T13:45:38Z&lt;/published&gt;
&lt;updated&gt;2006-08-13T13:50:49Z&lt;/updated&gt;
&lt;title&gt;At the beach&lt;/title&gt;
&lt;link rel="self" href="http://host/feed/photo/at-the-beach"
type="application/atom+xml"/&gt;
&lt;link rel="alternate" href="http://host/photo/at-the-beach"
type="text/html" /&gt;
&lt;content src="img/IMAGE001.png"
type="image/png" /&gt;
&lt;/entry&gt;
&lt;/feed&gt;
</pre></div><p>The Atom format is commonly used in the blog environment to allow users to subscribe to it. However, thanks to its flexibility and extensibility the Atom format is now used in different contexts such as publishing, archiving, and exporting content.</p></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec09"/>APP Implementation</h1></div></div></div><p>The aim of providing an<strong> Atom Publishing Protocol</strong> (APP) implementation within the photoblog application is to introduce the protocol and to provide two different services demonstrating the benefits of the separation of concerns. Because APP is not yet a standard and because at the time of writing this book it was under a fairly good amount of discussion, it is possible that by the time you read this section our implementation will no longer be compliant. However, there is minimum risk as the current version of the protocol draft, i.e. 13, seems stable enough regarding its main characteristics.<a id="id186" class="indexterm"/>
</p><p>The Atom Publishing Protocol defines a set of operations between an APP service and a user-agent using HTTP and its mechanisms and the Atom XML-document format as the unit of messages.</p><p>APP first defines a service document, which provides the user agent with the URI of the different collections served by the APP service. It is of the form:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;service  xmlns:atom=
"http://www.w3.org/2005/Atom"&gt;
&lt;workspace&gt;
&lt;collection href="http://host/service/atompub/album/"&gt;
&lt;atom:title&gt;Friends Albums&lt;/atom:title&gt;
&lt;categories fixed="yes"&gt;
&lt;atom:category term="friends" /&gt;
&lt;/categories&gt;
&lt;/collection&gt;
&lt;collection href="http://host/service/atompub/film/"&gt;
&lt;atom:title&gt;Films&lt;/atom:title&gt;
&lt;accept&gt;image/png,image/jpeg&lt;/accept&gt;
&lt;/collection&gt;
&lt;/workspace&gt;
&lt;/service&gt;
</pre></div><p>Once a user agent has fetched that service document it knows there are two<code class="literal"> collections</code> available. The first<code class="literal"> collection</code> informs the user-agent that it will only accept Atom documents that have a category matching the one defined. The second<code class="literal"> collection</code> will only accept data with the<code class="literal"> image/png</code> or<code class="literal"> image/jpeg</code> MIME types.</p><p>
<strong>Collections</strong> are the containers of what APP refers to as members. The operation of creating a member is done against a collection but operations of retrieving, updating, and deleting are done against that member itself and not the collection.</p><p>A collection is represented as an Atom feed in which entries are referred as to members. The critical addition to the Atom entry is the use of an Atom link with the<code class="literal"> rel</code> attribute set to<code class="literal"> edit</code> to describe the member resource. By setting this attribute to this value we indicate that the<code class="literal"> href</code> attribute of the link element references the URL of the member resource that can be retrieved, edited, and deleted at that URI. An Atom entry containing such a link element is called a<strong> member</strong> of a collection.</p><p>APP specifies how to perform the basic CRUD operations against a member of a collection or the collection itself by using HTTP methods as described in the following table.</p><div><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col style="text-align: left" class="C1"/><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Operation</p>
</th><th style="text-align: left" valign="bottom">
<p>HTTP Method</p>
</th><th style="text-align: left" valign="bottom">
<p>Status Code</p>
</th><th style="text-align: left" valign="bottom">
<p>Returned Content</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Retrieve</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">GET</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">200</code></p>
</td><td style="text-align: left" valign="top">
<p>An Atom entry representing the resource</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Create</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">POST</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">201</code></p>
</td><td style="text-align: left" valign="top">
<p>An Atom entry representing the resource</p>
<p>The URI of the newly created resource via the Location and Content-Location headers</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Update</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">PUT</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">200</code></p>
</td><td style="text-align: left" valign="top">
<p>An Atom entry representing the resource</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Delete</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">DELETE</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">200</code></p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td></tr></tbody></table></div><p>When creating or updating a resource, the APP server is free to modify part of the resource such as its<code class="literal"> id</code>, its<code class="literal"> updated</code> value, etc. Therefore user agents should not rely on their version of the resource and always synchronize with the server.</p><p>Although members of a collection are Atom entries, it is not compulsory to create a new member by submitting an Atom entry. APP supports any media type as long as it is allowed through the<code class="literal"> app:accept</code> element of an<code class="literal"> app:collection</code> element. That element takes a comma-separated list of media types specifying to the client which content types the collection will process on POST requests.</p><p>If you<code class="literal"> POST</code> a PNG image to a collection that accepts it, the server will create at least two resources.<a id="id187" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem"><p>A member resource, which can be seen as the metadata of the image</p></li><li class="listitem"><p>A media resource</p></li></ul></div><p>Remember that an APP server has total control over the content sent and therefore it is imaginable that an APP server could convert the PNG content to JPEG before storing it. A client cannot assume that the content or resource sent will be copied, as done by a server. In any case the server returns the member resource when creation has succeeded (please refer to the APP specification for detailed examples) and this is precisely what makes APP so powerful, since whichever type of resource a server says it handles APP ensures that metadata will be generated under the form of an Atom entry.</p><p>In addition to defining an interface to manipulate members within a collection, APP provides support for paging when a collection gets too big. This allows the user agent to request a given range of members within a collection. We will not explain this feature but you can review the APP specification if you are interested in this feature.</p><p>Furthermore, since the photoblog application will follow the REST principles as closely as possible for implementing APP, we invite you to refer yourself to the REST section for more specific details on how APP uses REST principles.<a id="id188" class="indexterm"/>
</p><p>In this section, we have briefly presented the Atom Publishing Protocol, a protocol based on the Atom XML-document format to allow the publishing of heterogeneous data types. In spite of not yet being an official standard, APP already interests many organizations and it is quite likely you will find it in more and more applications.</p></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec10"/>Summary</h1></div></div></div><p>This chapter has introduced you to the concept of web services, which defines the idea of offering an API via common web protocols such as HTTP. By providing such APIs your web application becomes much more flexible, powerful, and extensible. Web services are not a must-have feature though and not every web application would offer them. Our photoblog application, in its spirit of demonstrating some of the common modern web techniques, uses them as an example rather than as a compulsory feature. However, by reviewing the code of our photoblog application you will understand some of the interesting benefits of web services, which will hopefully give you ideas for your own applications.</p></div></div></div>
</body></html>