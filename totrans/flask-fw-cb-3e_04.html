<html><head></head><body>
<div id="_idContainer024">
<h1 class="chapter-number" id="_idParaDest-103"><a id="_idTextAnchor184"/><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-104"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.2.1">Working with Views</span></h1>
<p><span class="koboSpan" id="kobo.3.1">With any web application, it is very important to control how you interact with web requests and the proper responses to cater to these requests. </span><span class="koboSpan" id="kobo.3.2">This chapter takes us through the various methods of handling requests properly and designing them in the </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">best way.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Flask offers several ways of designing and laying out URL routing for our applications. </span><span class="koboSpan" id="kobo.5.2">Also, it gives us the flexibility to keep the architecture of our views as just functions or to create classes, which can be inherited and modified as required. </span><span class="koboSpan" id="kobo.5.3">In earlier versions, Flask just had function-based views. </span><span class="koboSpan" id="kobo.5.4">Later, however, in Version 0.7, inspired by Django, Flask introduced the concept of pluggable views, which allows us to have classes and then write methods in these classes. </span><span class="koboSpan" id="kobo.5.5">This also makes the process of building a RESTful API pretty straightforward, with every HTTP method being handled by the corresponding class method. </span><span class="koboSpan" id="kobo.5.6">Also, we can always go a level deeper into the Werkzeug library and use the more flexible, but slightly complex, concept of URL maps. </span><span class="koboSpan" id="kobo.5.7">In fact, large applications and frameworks prefer using </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">URL maps.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">following recipes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Writing function-based views and </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">URL routes</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Writing </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">class-based views</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Implementing URL routing and </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">product-based pagination</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Rendering </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">to templates</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Dealing with </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">XHR requests</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Using decorators to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">requests beautifully</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Creating custom 4xx and 5xx </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">error handlers</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Flashing messages for better </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">user feedback</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Implementing </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">SQL-based searching</span></span></li>
</ul>
<h1 id="_idParaDest-105"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.27.1">Writing function-based views and URL routes</span></h1>
<p><span class="koboSpan" id="kobo.28.1">This is the </span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.29.1">simplest way of writing </span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.30.1">views and URL routes in Flask. </span><span class="koboSpan" id="kobo.30.2">We can </span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.31.1">just write a method and decorate </span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.32.1">it with the endpoint. </span><span class="koboSpan" id="kobo.32.2">In this recipe, we will write a few URL routes for </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">GET</span></strong><span class="koboSpan" id="kobo.34.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.35.1">POST</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.36.1"> reques</span><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.37.1">ts.</span></span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.38.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.39.1">To go through this recipe, we can start with any Flask application. </span><span class="koboSpan" id="kobo.39.2">The app can be a new, empty, or complex app. </span><span class="koboSpan" id="kobo.39.3">We just need to understand the methods outlined in </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">this reci</span><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.41.1">pe.</span></span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.42.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.43.1">The following section explains the three most widely used different kinds of requests, demonstrated by means of </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">small exampl</span><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.45.1">es.</span></span></p>
<h3><span class="koboSpan" id="kobo.46.1">A simple GET request</span></h3>
<p><span class="koboSpan" id="kobo.47.1">The following </span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.48.1">is a </span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.49.1">simple example of what a </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">GET</span></strong><span class="koboSpan" id="kobo.51.1"> request </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">looks like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.53.1">
@app.route('/a-get-request')
def get_request():
    bar = request.args.get('foo', 'bar')
    return 'A simple Flask request where foo is %s' % bar</span></pre>
<p><span class="koboSpan" id="kobo.54.1">Here, we just check whether the URL query has an argument called </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">foo</span></strong><span class="koboSpan" id="kobo.56.1">. </span><span class="koboSpan" id="kobo.56.2">If yes, we display this in the response; otherwise, the default </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">is</span><a id="_idTextAnchor193"/> </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">bar</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.60.1">A simple POST request</span></h3>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">POST</span></strong><span class="koboSpan" id="kobo.62.1"> is similar </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.63.1">to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">GET</span></strong><span class="koboSpan" id="kobo.65.1"> request, but </span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.66.1">with a </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">few differences:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.68.1">
@app.route('/a-post-request', methods=['POST'])
def post_request():
    bar = request.form.get('foo', 'bar')
    return 'A simple Flask request where foo is %s' % bar</span></pre>
<p><span class="koboSpan" id="kobo.69.1">The route </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.70.1">now contains an extra argument called </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">methods</span></strong><span class="koboSpan" id="kobo.72.1">. </span><span class="koboSpan" id="kobo.72.2">Also, instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">request.args</span></strong><span class="koboSpan" id="kobo.74.1">, we now use </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">request.form</span></strong><span class="koboSpan" id="kobo.76.1">, as </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">POST</span></strong><span class="koboSpan" id="kobo.78.1"> assumes </span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.79.1">that the data is submitted in </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">a for</span><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.81.1">m.</span></span></p>
<h3><span class="koboSpan" id="kobo.82.1">A simple GET/POST request</span></h3>
<p><span class="koboSpan" id="kobo.83.1">An amalgamation </span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.84.1">of both </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">GET</span></strong><span class="koboSpan" id="kobo.86.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">POST</span></strong><span class="koboSpan" id="kobo.88.1"> into a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">view</span></strong><span class="koboSpan" id="kobo.90.1"> function can be written as </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.92.1">
@app.route('/a-request', methods=['GET', 'POST'])
def some_request():
    if request.method == 'GET':
        bar = request.args.get('foo', 'bar')
    else:
        bar = request.form.get('foo', 'bar')
    return 'A simple Flask request where foo is</span><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.93.1"> %s' % bar</span></pre>
<h2 id="_idParaDest-108"><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.94.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.95.1">Let’s try </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.96.1">to understand how the preceding play of </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">methods works.</span></span></p>
<p><span class="koboSpan" id="kobo.98.1">By default, any Flask </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">view</span></strong><span class="koboSpan" id="kobo.100.1"> function supports only </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">GET</span></strong><span class="koboSpan" id="kobo.102.1"> requests. </span><span class="koboSpan" id="kobo.102.2">In order to support or handle any other kind of request, we have to specifically tell our </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">route()</span></strong><span class="koboSpan" id="kobo.104.1"> decorator about the methods we want to support. </span><span class="koboSpan" id="kobo.104.2">This is precisely what we did in our last two methods for </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">POST</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.106.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">GET/POST</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">For </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">GET</span></strong><span class="koboSpan" id="kobo.111.1"> requests, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">request</span></strong><span class="koboSpan" id="kobo.113.1"> object will look for </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">args</span></strong><span class="koboSpan" id="kobo.115.1"> – that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">request.args.get()</span></strong><span class="koboSpan" id="kobo.117.1"> – and for </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">POST</span></strong><span class="koboSpan" id="kobo.119.1">, it will look for </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">form</span></strong><span class="koboSpan" id="kobo.121.1"> – that </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">is, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">request.form.get()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.125.1">Also, if we try to make a </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">GET</span></strong><span class="koboSpan" id="kobo.127.1"> request to a method that supports only </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">POST</span></strong><span class="koboSpan" id="kobo.129.1">, the request will fail with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">405</span></strong><span class="koboSpan" id="kobo.131.1"> HTTP error. </span><span class="koboSpan" id="kobo.131.2">The same holds true for all the methods. </span><span class="koboSpan" id="kobo.131.3">Refer to the </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer019">
<span class="koboSpan" id="kobo.133.1"><img alt="Figure 4.1 – The Method Not Allowed ﻿error page" src="image/B19111_04_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.134.1">Figure 4.1 – The Method Not Allowed </span><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.135.1">error page</span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.136.1">There’s more...</span></h2>
<p><span class="koboSpan" id="kobo.137.1">Sometimes, we might want to </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.138.1">have a URL map kind of a pattern, where we prefer to define all the URL rules with endpoints in a single place, rather than them being scattered all around an application. </span><span class="koboSpan" id="kobo.138.2">For this, we will need to define our methods without the </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">route()</span></strong><span class="koboSpan" id="kobo.140.1"> decorator and define the route on our application object, as </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.142.1">
def get_request():
    bar = request.args.get('foo', 'bar')
    return 'A simple Flask request where foo is %s' % bar
app = Flask(__name__)
app.add_url_rule('/a-get-request', view_func=get_request)</span></pre>
<p><span class="koboSpan" id="kobo.143.1">Make sure that you give the correct relative path to the method assigned </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">to</span><a id="_idTextAnchor199"/> </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">view_func</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">.</span></span></p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.147.1">Writing class-based views</span></h1>
<p><span class="koboSpan" id="kobo.148.1">Flask introduced </span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.149.1">the concept of pluggable views in </span><em class="italic"><span class="koboSpan" id="kobo.150.1">Version 0.7</span></em><span class="koboSpan" id="kobo.151.1">; this added a lot of flexibility to the existing implementation. </span><span class="koboSpan" id="kobo.151.2">We can write views in the form of classes; these views can be written in a generic fashion and allow for easy and understandable inheritance. </span><span class="koboSpan" id="kobo.151.3">In this recipe, we will look at how to create such </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">class-</span><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.153.1">based views.</span></span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.154.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.155.1">Refer to the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.156.1">Writing function-based views and URL routes</span></em><span class="koboSpan" id="kobo.157.1">, to see the basic function-based </span><a id="_idTextAnchor203"/><span class="No-Break"><span class="koboSpan" id="kobo.158.1">views first.</span></span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.159.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.160.1">Flask provides </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.161.1">a class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">View</span></strong><span class="koboSpan" id="kobo.163.1">, which can be inherited to add our custom behavior. </span><span class="koboSpan" id="kobo.163.2">The following is an example of a simple </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">GET</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.165.1"> request:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.166.1">
from flask.views import View
class GetRequest(View):
    def dispatch_request(self):
        bar = request.args.get('foo', 'bar')
        return 'A simple Flask request where foo is %s' %
          bar
app.add_url_rule(
    '/a-get-request',
      view_func=GetRequest.as_view('get_request')
)</span></pre>
<p><span class="koboSpan" id="kobo.167.1">The name of the view provided in </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">as_view</span></strong><span class="koboSpan" id="kobo.169.1"> (i.e., </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">get_request</span></strong><span class="koboSpan" id="kobo.171.1">) signifies the name that will be used when referring to this endpoint </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">url_for()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.175.1">To accommodate both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">GET</span></strong><span class="koboSpan" id="kobo.177.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">POST</span></strong><span class="koboSpan" id="kobo.179.1"> requests, we can write the </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.181.1">
class GetPostRequest(View):
    methods = ['GET', 'POST']
    def dispatch_request(self):
        if request.method == 'GET':
            bar = request.args.get('foo', 'bar')
        if request.method == 'POST':
            bar = request.form.get('foo', 'bar')
        return 'A simple Flask request where foo is %s' %
          bar
app.add_url_rule(
    '/a-request',
    view_func=GetPostRequest.as_view('</span><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.182.1">a_request')
)</span></pre>
<h2 id="_idParaDest-113"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.183.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.184.1">We know that by default, any Flask </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">view</span></strong><span class="koboSpan" id="kobo.186.1"> function supports only </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">GET</span></strong><span class="koboSpan" id="kobo.188.1"> requests. </span><span class="koboSpan" id="kobo.188.2">The same applies </span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.189.1">to class-based views. </span><span class="koboSpan" id="kobo.189.2">In order to support or handle any other kind of request, we have to specifically tell our class, via a class attribute called </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">methods</span></strong><span class="koboSpan" id="kobo.191.1">, about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">HTTP</span></strong><span class="koboSpan" id="kobo.193.1"> methods we want to support. </span><span class="koboSpan" id="kobo.193.2">This is exactly what we did in our last example of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">GET/POST</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.195.1"> requests.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">For </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">GET</span></strong><span class="koboSpan" id="kobo.198.1"> requests, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">request</span></strong><span class="koboSpan" id="kobo.200.1"> object will look for </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">args</span></strong><span class="koboSpan" id="kobo.202.1"> – that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">request.args.get()</span></strong><span class="koboSpan" id="kobo.204.1"> – and for </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">POST</span></strong><span class="koboSpan" id="kobo.206.1">, it will look for </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">form</span></strong><span class="koboSpan" id="kobo.208.1"> – that </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">is, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">request.form.get()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.212.1">Also, if we try to make a </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">GET</span></strong><span class="koboSpan" id="kobo.214.1"> request to a method that supports only </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">POST</span></strong><span class="koboSpan" id="kobo.216.1">, the request will fail with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">405</span></strong><span class="koboSpan" id="kobo.218.1"> HTTP error. </span><span class="koboSpan" id="kobo.218.2">The same holds true for al</span><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.219.1">l </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">the methods.</span></span></p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.221.1">There’s more...</span></h2>
<p><span class="koboSpan" id="kobo.222.1">Now, many of </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.223.1">you may be considering whether it would be possible to just declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">GET</span></strong><span class="koboSpan" id="kobo.225.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">POST</span></strong><span class="koboSpan" id="kobo.227.1"> methods inside a </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">View</span></strong><span class="koboSpan" id="kobo.229.1"> class and let Flask handle the rest of the stuff. </span><span class="koboSpan" id="kobo.229.2">The answer to this question is </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">MethodView</span></strong><span class="koboSpan" id="kobo.231.1">. </span><span class="koboSpan" id="kobo.231.2">Let’s write our previous snippet </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">MethodView</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.235.1">
from flask.views import MethodView
class GetPostRequest(MethodView):
    def get(self):
        bar = request.args.get('foo', 'bar')
        return 'A simple Flask request where foo is %s' %
          bar
    def post(self):
        bar = request.form.get('foo', 'bar')
        return 'A simple Flask request where foo is %s' %
          bar
app.add_url_rule(
    '/a-request',
    view_func=GetPostRequest.as_view</span><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.236.1">('a_request')
)</span></pre>
<h2 id="_idParaDest-115"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.237.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.238.1">Refer to the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.239.1">Writing function-based views and URL routes</span></em><span class="koboSpan" id="kobo.240.1">, to understand the contrast between class- and </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">functi</span><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.242.1">on-based views.</span></span></p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.243.1">Implementing URL routing and product-based pagination</span></h1>
<p><span class="koboSpan" id="kobo.244.1">At times, we may </span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.245.1">encounter a problem where there is a need to </span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.246.1">parse the various parts of a URL differently. </span><span class="koboSpan" id="kobo.246.2">For example, a URL can have an integer part, a string part, a string part of a specific length, and slashes in the URL. </span><span class="koboSpan" id="kobo.246.3">We can parse all these combinations in our URLs using URL converters. </span><span class="koboSpan" id="kobo.246.4">In this recipe, we will see how to do this. </span><span class="koboSpan" id="kobo.246.5">Also, we will learn how to implement pagination using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">Flask-SQLA</span><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.248.1">lchemy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.249.1"> extension.</span></span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.250.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.251.1">We have already seen several instances of basic URL converters in this book. </span><span class="koboSpan" id="kobo.251.2">In this recipe, we will look at some advanced URL converters and learn</span><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.252.1"> how to </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">use them.</span></span></p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.254.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.255.1">Let’s say we have a URL route defined </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.257.1">
@app.route('/test/&lt;name&gt;')
def get_name(name):
    return name</span></pre>
<p><span class="koboSpan" id="kobo.258.1">Here, the URL, </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">http://127.0.0.1:5000/test/Shalabh</span></strong><span class="koboSpan" id="kobo.260.1">, will result in </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">Shalabh</span></strong><span class="koboSpan" id="kobo.262.1"> being parsed and passed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">name</span></strong><span class="koboSpan" id="kobo.264.1"> argument of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">get_name</span></strong><span class="koboSpan" id="kobo.266.1"> method. </span><span class="koboSpan" id="kobo.266.2">This is a Unicode or string converter, which is the default one and need not be </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">specified explicitly.</span></span></p>
<p><span class="koboSpan" id="kobo.268.1">We can also have strings with specific lengths. </span><span class="koboSpan" id="kobo.268.2">Let’s say we want to parse a URL that may contain a country code or currency code. </span><span class="koboSpan" id="kobo.268.3">Country codes are usually two characters long, and currency codes are three characters long. </span><span class="koboSpan" id="kobo.268.4">This can be done </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.270.1">
@app.route('/test/&lt;string(minlength=2,maxlength=3):code&gt;')
def get_name(code):
    return code</span></pre>
<p><span class="koboSpan" id="kobo.271.1">This will match both </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">US</span></strong><span class="koboSpan" id="kobo.273.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">USD</span></strong><span class="koboSpan" id="kobo.275.1"> in the URL – that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">http://127.0.0.1:5000/test/USD</span></strong><span class="koboSpan" id="kobo.277.1">  and </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">http://127.0.0.1:5000/test/US</span></strong><span class="koboSpan" id="kobo.279.1"> will be treated similarly. </span><span class="koboSpan" id="kobo.279.2">We can also match the exact length using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">length</span></strong><span class="koboSpan" id="kobo.281.1"> parameter instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">minlength</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.283.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">maxlength</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.286.1">We can </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.287.1">also parse integer values in a </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">similar fashion:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.289.1">
@app.route('/test/&lt;int:age&gt;')
def get_age(age):
    return str(age)</span></pre>
<p><span class="koboSpan" id="kobo.290.1">We can </span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.291.1">also specify the minimum and maximum values that can be accepted. </span><span class="koboSpan" id="kobo.291.2">For example, to limit the acceptable age between 18 and 99, the URL can be structured as </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">@app.route('/test/&lt;int(min=18,max=99):age&gt;')</span></strong><span class="koboSpan" id="kobo.293.1">. </span><span class="koboSpan" id="kobo.293.2">We can also parse float values using </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">float</span></strong><span class="koboSpan" id="kobo.295.1"> in place of </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">int</span></strong><span class="koboSpan" id="kobo.297.1"> in the</span><a id="_idTextAnchor217"/> <span class="No-Break"><span class="koboSpan" id="kobo.298.1">preceding example.</span></span></p>
<p><span class="koboSpan" id="kobo.299.1">Let’s understand </span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.300.1">the concept of </span><strong class="bold"><span class="koboSpan" id="kobo.301.1">pagination</span></strong><span class="koboSpan" id="kobo.302.1"> next. </span><span class="koboSpan" id="kobo.302.2">In the </span><em class="italic"><span class="koboSpan" id="kobo.303.1">Creating a basic product model</span></em><span class="koboSpan" id="kobo.304.1"> recipe in </span><a href="B19111_03.xhtml#_idTextAnchor129"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.305.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.306.1">, </span><em class="italic"><span class="koboSpan" id="kobo.307.1">Data Modeling in Flask</span></em><span class="koboSpan" id="kobo.308.1">, we created a handler to list all the products in our database. </span><span class="koboSpan" id="kobo.308.2">If we have thousands of products, then generating a list of all of these products in one go can take a lot of time. </span><span class="koboSpan" id="kobo.308.3">Also, if we have to render these products in a template, then we would not want to show more than 10–20 products on a page in one go. </span><span class="koboSpan" id="kobo.308.4">Pagination proves to be a big help in building </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">great applications.</span></span></p>
<p><span class="koboSpan" id="kobo.310.1">Let’s modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">products()</span></strong><span class="koboSpan" id="kobo.312.1"> method to list products to </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">support pagination:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.314.1">
@catalog.route('/products')
@catalog.route('/products/&lt;int:page&gt;')
def products(page=1):
    products = Product.query.paginate(page, 10).items
    res = {}
    for product in products:
        res[product.id] = {
            'name': product.name,
            'price': product.price,
            'category': product.category.name
        }
    return jsonify(res)</span></pre>
<p><span class="koboSpan" id="kobo.315.1">In the </span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.316.1">preceding handler, we added a new URL </span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.317.1">route that adds a </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">page</span></strong><span class="koboSpan" id="kobo.319.1"> parameter to the URL. </span><span class="koboSpan" id="kobo.319.2">Now, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">http://127.0.0.1:5000/products</span></strong><span class="koboSpan" id="kobo.321.1"> URL will be the same as </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">http://127.0.0.1:5000/products/1</span></strong><span class="koboSpan" id="kobo.323.1">, and both will return a list of the first 10 products from the database. </span><span class="koboSpan" id="kobo.323.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">http://127.0.0.1:5000/products/2</span></strong><span class="koboSpan" id="kobo.325.1"> URL will return the next 10 products, and </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">so on.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.327.1">Information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.328.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">paginate()</span></strong><span class="koboSpan" id="kobo.330.1"> method takes </span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.331.1">four arguments and returns an object of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">Pagination</span></strong><span class="koboSpan" id="kobo.333.1"> class. </span><span class="koboSpan" id="kobo.333.2">These four arguments are </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">as follows:</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.335.1">•  </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">page</span></strong><span class="koboSpan" id="kobo.337.1">: This is the current page to </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">be listed.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.339.1">•  </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">per_page</span></strong><span class="koboSpan" id="kobo.341.1">: This is the number of items to be listed </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">per page.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.343.1">•  </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">error_out</span></strong><span class="koboSpan" id="kobo.345.1">: If no items are found for the page, then this aborts with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">404</span></strong><span class="koboSpan" id="kobo.347.1"> error. </span><span class="koboSpan" id="kobo.347.2">To prevent this behavior, set this parameter to </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">False</span></strong><span class="koboSpan" id="kobo.349.1">, and then it will just return an </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">empty list.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.351.1">•  </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">max_per_page</span></strong><span class="koboSpan" id="kobo.353.1">: If this value is specified, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">per_page</span></strong><span class="koboSpan" id="kobo.355.1"> will </span><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.356.1">be limited to </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">the same.</span></span></p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.358.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.359.1">Refer to the </span><em class="italic"><span class="koboSpan" id="kobo.360.1">Creating a basic product model</span></em><span class="koboSpan" id="kobo.361.1"> recipe in </span><a href="B19111_03.xhtml#_idTextAnchor129"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.362.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.363.1">, </span><em class="italic"><span class="koboSpan" id="kobo.364.1">Data Modeling in Flask</span></em><span class="koboSpan" id="kobo.365.1">, to understand the context of this recipe for pagination, as this reci</span><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.366.1">pe builds on top </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">of it.</span></span></p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.368.1">Rendering to templates</span></h1>
<p><span class="koboSpan" id="kobo.369.1">After writing </span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.370.1">the views, we will surely want to render the content in a template and get information from </span><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.371.1">the </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">underlying database.</span></span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.373.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.374.1">To render templates, we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">Jinja</span></strong><span class="koboSpan" id="kobo.376.1"> as the templating language. </span><span class="koboSpan" id="kobo.376.2">Refer to </span><a href="B19111_02.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.377.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.378.1">, </span><em class="italic"><span class="koboSpan" id="kobo.379.1">Templating with Jinja2</span></em><span class="koboSpan" id="kobo.380.1">, to underst</span><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.381.1">and templating </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">in depth.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.383.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.384.1">We will again work in reference to our existing catalog application from the previous recipe. </span><span class="koboSpan" id="kobo.384.2">Let’s modify our views to render templates and then display data from the database in </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">these templates.</span></span></p>
<p><span class="koboSpan" id="kobo.386.1">The following is the modified </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">views.py</span></strong><span class="koboSpan" id="kobo.388.1"> code and the templates. </span><span class="koboSpan" id="kobo.388.2">The complete app can be downloaded from the code bundle provided with this book or from the </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">GitHub repository.</span></span></p>
<p><span class="koboSpan" id="kobo.390.1">We will start by modifying our views – that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">flask_catalog_template/my_app/catalog/views.py</span></strong><span class="koboSpan" id="kobo.392.1"> – to render templates on </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">specific handlers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.394.1">
from flask import request, Blueprint, render_template
from my_app import db
from my_app.catalog.models import Product, Category
catalog = Blueprint('catalog', __name__)
@catalog.route('/')
@catalog.route('/home')
def home():
    return render_template('home.html')</span></pre>
<p><span class="koboSpan" id="kobo.395.1">Note the </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">render_template()</span></strong><span class="koboSpan" id="kobo.397.1"> method. </span><span class="koboSpan" id="kobo.397.2">This method will render </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">home.html</span></strong><span class="koboSpan" id="kobo.399.1"> when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">home</span></strong><span class="koboSpan" id="kobo.401.1"> handler </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">is called.</span></span></p>
<p><span class="koboSpan" id="kobo.403.1">The following </span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.404.1">method handles the rendering of </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">product.html</span></strong><span class="koboSpan" id="kobo.406.1"> with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">product</span></strong><span class="koboSpan" id="kobo.408.1"> object in the </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">template context:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.410.1">
@catalog.route('/product/&lt;id&gt;')
def product(id):
    product = Product.query.get_or_404(id)
    return render_template('product.html', product=product)</span></pre>
<p><span class="koboSpan" id="kobo.411.1">To get the paginated list of all products, see the </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">following method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.413.1">
@catalog.route('/products')
@catalog.route('/products/&lt;int:page&gt;')
def products(page=1):
    products = Product.query.paginate(page, 10)
    return render_template('products.html',
      products=products)</span></pre>
<p><span class="koboSpan" id="kobo.414.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">products.html</span></strong><span class="koboSpan" id="kobo.416.1"> template will be rendered with the list of paginated </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">product</span></strong><span class="koboSpan" id="kobo.418.1"> objects in </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">the context.</span></span></p>
<p><span class="koboSpan" id="kobo.420.1">To render the product template on the creation of a new product, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">create_product()</span></strong><span class="koboSpan" id="kobo.422.1"> method can be modified, as </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.424.1">
@catalog.route('/product-create', methods=['POST',])
def create_product():
    # ...Same code as before ...
</span><span class="koboSpan" id="kobo.424.2">    return render_template('product.html', product=product)</span></pre>
<p><span class="koboSpan" id="kobo.425.1">This can also </span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.426.1">be done using </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">redirect()</span></strong><span class="koboSpan" id="kobo.428.1">, but we will cover this at a later stage. </span><span class="koboSpan" id="kobo.428.2">Have a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.430.1">
@catalog.route('/category-create', methods=['POST',])
def create_category():
    # ...Same code as before ...
</span><span class="koboSpan" id="kobo.430.2">    return render_template('category.html',
      category=category)
@catalog.route('/category/&lt;id&gt;')
def category(id):
    category = Category.query.get_or_404(id)
    return render_template('category.html',
      category=category)
@catalog.route('/categories')
def categories():
    categories = Category.query.all()
    return render_template(
        'categories.html', categories=categories)</span></pre>
<p><span class="koboSpan" id="kobo.431.1">All three handlers in the preceding code work in a similar way, as discussed earlier when rendering the </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">product-related templates.</span></span></p>
<p><span class="koboSpan" id="kobo.433.1">The following are all the templates created and rendered as part of the application. </span><span class="koboSpan" id="kobo.433.2">For more information on how these templates are written and how they work, refer to </span><a href="B19111_02.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.434.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.435.1">, </span><em class="italic"><span class="koboSpan" id="kobo.436.1">Templating </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.437.1">with Jinja2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.439.1">The first template file is </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">flask_catalog_template/my_app/templates/base.html</span></strong><span class="koboSpan" id="kobo.441.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.443.1">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width,
      initial-scale=1"&gt;
    &lt;title&gt;Flask Framework Cookbook&lt;/title&gt;
    &lt;link href="{{ url_for('static', filename
      ='css/bootstrap.min.css') }}" rel="stylesheet"&gt;
    &lt;link href="{{ url_for('static', filename
      ='css/main.css') }}" rel="stylesheet"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class="navbar navbar-inverse navbar-fixed-top"
      role="navigation"&gt;
      &lt;div class="container"&gt;
        &lt;div class="navbar-header"&gt;
          &lt;a class="navbar-brand" href="{{ url_for
            ('catalog.home') }}"&gt;Flask Cookbook&lt;/a&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="container"&gt;
    {% block container %}{% endblock %}
    &lt;/div&gt;
    &lt;!-- jQuery (necessary for Bootstrap's JavaScript
      plugins) --&gt;
    &lt;script src="https://ajax.googleapis.com/ajax/libs
      /jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt;
    &lt;script src="{{ url_for('static', filename
      ='js/bootstrap.min.js') }}"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</span></pre>
<p><span class="koboSpan" id="kobo.444.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">flask_catalog_template/my_app/templates/home.html</span></strong><span class="koboSpan" id="kobo.446.1"> file appears </span><a id="_idIndexMarker158"/><span class="No-Break"><span class="koboSpan" id="kobo.447.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.448.1">
{% extends 'base.html' %}
{% block container %}
  &lt;h1&gt;Welcome to the Catalog Home&lt;/h1&gt;
  &lt;a href="{{ url_for('catalog.products') }}"&gt;Click here to
    see the catalog&lt;/a&gt;
{% endblock %}</span></pre>
<p><span class="koboSpan" id="kobo.449.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">flask_catalog_template/my_app/templates/product.html</span></strong><span class="koboSpan" id="kobo.451.1"> file appears </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.453.1">
{% extends 'home.html' %}
{% block container %}
  &lt;div class="top-pad"&gt;
    &lt;h1&gt;{{ product.name }}&lt;small&gt; {{ product.category.name
      }}&lt;/small&gt;&lt;/h1&gt;
    &lt;h4&gt;{{ product.company }}&lt;/h4&gt;
    &lt;h3&gt;{{ product.price }}&lt;/h3&gt;
  &lt;/div&gt;
{% endblock %}</span></pre>
<p><span class="koboSpan" id="kobo.454.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">flask_catalog_template/my_app/templates/products.html</span></strong><span class="koboSpan" id="kobo.456.1"> file appears </span><a id="_idIndexMarker159"/><span class="No-Break"><span class="koboSpan" id="kobo.457.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.458.1">
{% extends 'home.html' %}
{% block container %}
  &lt;div class="top-pad"&gt;
    {% for product in products.items %}
      &lt;div class="well"&gt;
        &lt;h2&gt;
          &lt;a href="{{ url_for('catalog.product', id
            =product.id) }}"&gt;{{ product.name }}&lt;/a&gt;
          &lt;small&gt;$ {{ product.price }}&lt;/small&gt;
        &lt;/h2&gt;
      &lt;/div&gt;
    {% endfor %}
    {% if products.has_prev %}
      &lt;a href="{{ url_for(request.endpoint, page
        =products.prev_num) }}"&gt;
        {{"&lt;&lt; Previous Page"}}
      &lt;/a&gt;
    {% else %}
      {{"&lt;&lt; Previous Page"}}
    {% endif %} |
    {% if products.has_next %}
      &lt;a href="{{ url_for(request.endpoint, page
        =products.next_num) }}"&gt;
        {{"Next page &gt;&gt;"}}
      &lt;/a&gt;
    {% else %}
      {{"Next page &gt;&gt;"}}
    {% endif %}
  &lt;/div&gt;
{% endblock %}</span></pre>
<p><span class="koboSpan" id="kobo.459.1">Note how </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.460.1">the URL is being created for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">Previous page</span></strong><span class="koboSpan" id="kobo.462.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">Next page</span></strong><span class="koboSpan" id="kobo.464.1"> links. </span><span class="koboSpan" id="kobo.464.2">We are using </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">request.endpoint</span></strong><span class="koboSpan" id="kobo.466.1"> so that pagination works for the current URL, which will make the template reusable with </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">search</span></strong><span class="koboSpan" id="kobo.468.1"> as well. </span><span class="koboSpan" id="kobo.468.2">We will see this later in </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.470.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">flask_catalog_template/my_app/templates/category.html</span></strong><span class="koboSpan" id="kobo.472.1"> file appears </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.474.1">
{% extends 'home.html' %}
{% block container %}
  &lt;div class="top-pad"&gt;
    &lt;h2&gt;{{ category.name }}&lt;/h2&gt;
    &lt;div class="well"&gt;
      {% for product in category.products %}
        &lt;h3&gt;
          &lt;a href="{{ url_for('catalog.product', id
            =product.id) }}"&gt;{{ product.name }}&lt;/a&gt;
          &lt;small&gt;$ {{ product.price }}&lt;/small&gt;
        &lt;/h3&gt;
      {% endfor %}
    &lt;/div&gt;
  &lt;/div&gt;
{% endblock %}</span></pre>
<p><span class="koboSpan" id="kobo.475.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">flask_catalog_template/my_app/templates/categories.html</span></strong><span class="koboSpan" id="kobo.477.1"> file </span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.478.1">appears </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.480.1">
{% extends 'home.html' %}
{% block container %}
  &lt;div class="top-pad"&gt;
    {% for category in categories %}
    &lt;a href="{{ url_for('catalog.category',
      id=category.id) }}"&gt;
      &lt;h2&gt;{{ category.name }}&lt;/h2&gt;
    &lt;/a&gt;
    {% end</span><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.481.1">for %}
  &lt;/div&gt;
{% endblock %}</span></pre>
<h2 id="_idParaDest-123"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.482.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.483.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">view</span></strong><span class="koboSpan" id="kobo.485.1"> methods </span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.486.1">have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">render_template</span></strong><span class="koboSpan" id="kobo.488.1"> method </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.489.1">call at the end. </span><span class="koboSpan" id="kobo.489.2">This means that following the successful completion of the method operations, we will render a template with some parameters added to </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">the context.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.491.1">Information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.492.1">Note how pagination has been implemented in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">products.html</span></strong><span class="koboSpan" id="kobo.494.1"> file. </span><span class="koboSpan" id="kobo.494.2">It can be improved further to show the page numbers as well between the two links for navigation. </span><span class="koboSpan" id="kobo.494.3">You sh</span><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.495.1">ould undertake this on </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">your own.</span></span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.497.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.498.1">Refer to the </span><em class="italic"><span class="koboSpan" id="kobo.499.1">Implementing URL routing and product-based pagination</span></em><span class="koboSpan" id="kobo.500.1"> recipe to understand pagination and the remainder of the </span><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.501.1">application used in </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">this recipe.</span></span></p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.503.1">Dealing with XHR requests</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.504.1">Asynchronous JavaScript</span></strong><span class="koboSpan" id="kobo.505.1">, commonly </span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.506.1">known as </span><strong class="bold"><span class="koboSpan" id="kobo.507.1">Ajax</span></strong><span class="koboSpan" id="kobo.508.1">, has become </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.509.1">an important part of web applications over the last decade or so. </span><span class="koboSpan" id="kobo.509.2">The built-in </span><strong class="bold"><span class="koboSpan" id="kobo.510.1">XMLHttpRequest </span></strong><span class="koboSpan" id="kobo.511.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.512.1">XHR</span></strong><span class="koboSpan" id="kobo.513.1">) object in a browser is used to execute Ajax on web pages. </span><span class="koboSpan" id="kobo.513.2">With the advent of single-page applications and </span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.514.1">JavaScript application frameworks such as </span><strong class="bold"><span class="koboSpan" id="kobo.515.1">Angular</span></strong><span class="koboSpan" id="kobo.516.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.517.1">Vue</span></strong><span class="koboSpan" id="kobo.518.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.519.1">React</span></strong><span class="koboSpan" id="kobo.520.1">, this </span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.521.1">technique of </span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.522.1">web development has risen exponentially. </span><span class="koboSpan" id="kobo.522.2">In this recipe, we will implement an Ajax request to facilitate asynchronous communication between the backend and </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">the frontend.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.524.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.525.1">In this book, I am opting to use Ajax to demonstrate </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">async</span></strong><span class="koboSpan" id="kobo.527.1"> requests because it is simpler to understand and demonstrate and keeps the focus of the book on Flask. </span><span class="koboSpan" id="kobo.527.2">You can choose to use any JavaScript platform/framework. </span><span class="koboSpan" id="kobo.527.3">The Flask code would remain the same, while the JavaScript code would have to change acc</span><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.528.1">ording to the framework that </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">you used.</span></span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.530.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.531.1">Flask provides an easy way to handle the XHR requests in the view handlers. </span><span class="koboSpan" id="kobo.531.2">We can even have common methods for normal web requests and XHRs. </span><span class="koboSpan" id="kobo.531.3">We can just check for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">XMLHttpRequest</span></strong><span class="koboSpan" id="kobo.533.1"> header in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">request</span></strong><span class="koboSpan" id="kobo.535.1"> object to determine the type of call and </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">act accordingly.</span></span></p>
<p><span class="koboSpan" id="kobo.537.1">We will update </span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.538.1">the catalog application from the previous recipe to have </span><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.539.1">a feature to demonstrate </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">XHR requests.</span></span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.541.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.542.1">The Flask </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">request</span></strong><span class="koboSpan" id="kobo.544.1"> object has a provision to check for the headers sent along with the request from the browser. </span><span class="koboSpan" id="kobo.544.2">We can check the </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">X-Requested-With</span></strong><span class="koboSpan" id="kobo.546.1"> header for </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">XMLHttpRequest</span></strong><span class="koboSpan" id="kobo.548.1">, which tells us whether the request made is an XHR request or a simple web request. </span><span class="koboSpan" id="kobo.548.2">Usually, when we have an XHR request, the caller expects the result to be in the JSON format, which can then be used to render content in the correct place on the web page without reloading </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">the page.</span></span></p>
<p><span class="koboSpan" id="kobo.550.1">So, let’s say we have an Ajax call to fetch the number of products in the database on the home page itself. </span><span class="koboSpan" id="kobo.550.2">One way to fetch the products is to send the count of products along with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">render_template()</span></strong><span class="koboSpan" id="kobo.552.1"> context. </span><span class="koboSpan" id="kobo.552.2">Another way is to send this information over as a response to an Ajax call. </span><span class="koboSpan" id="kobo.552.3">We will implement the latter to see how Flask </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">handles XHR:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.554.1">
from flask import request, render_template, jsonify
@catalog.route('/')
@catalog.route('/home')
def home():
    if request.headers.get("X-Requested-With") ==
      "XMLHttpRequest":
        products = Product.query.all()
        return jsonify({
            'count': len(products)
        })
    return render_template('home.html')</span></pre>
<p><span class="koboSpan" id="kobo.555.1">In the preceding method, we first checked whether this is an XHR. </span><span class="koboSpan" id="kobo.555.2">If it is, we return the JSON data; otherwise, we just render </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">home.html</span></strong><span class="koboSpan" id="kobo.557.1">, as we have </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">done hitherto.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.559.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.560.1">This design of handling XHR and regular requests together in one method can become a bit bloated as the application grows in size, and different logic handling has to be executed in the case of XHR, compared to regular requests. </span><span class="koboSpan" id="kobo.560.2">In such cases, these two types of requests can be separated into different methods, where the handling of XHR is done separately from regular requests. </span><span class="koboSpan" id="kobo.560.3">This can even be extended so that we have different blueprints to make URL handling </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">even cleaner.</span></span></p>
<p><span class="koboSpan" id="kobo.562.1">Next, modify </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">flask_catalog_template/my_app/templates/base.html</span></strong><span class="koboSpan" id="kobo.564.1"> to a block for </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">scripts</span></strong><span class="koboSpan" id="kobo.566.1">. </span><span class="koboSpan" id="kobo.566.2">This empty block, which is shown here, can be placed after the line where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">Bootstrap.js</span></strong><span class="koboSpan" id="kobo.568.1"> script </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">is included:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.570.1">
{% block scripts %}
{% endblock %}</span></pre>
<p><span class="koboSpan" id="kobo.571.1">Next, we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">flask_catalog_template/my_app/templates/home.html</span></strong><span class="koboSpan" id="kobo.573.1">, where we </span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.574.1">send an Ajax call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">home()</span></strong><span class="koboSpan" id="kobo.576.1"> handler, which checks whether the request is an XHR request. </span><span class="koboSpan" id="kobo.576.2">If it is, it fetches the count of products from the database and returns it as a JSON object. </span><span class="koboSpan" id="kobo.576.3">Check the code inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">scripts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.578.1"> block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.579.1">
{% extends 'base.html' %}
{% block container %}
  &lt;h1&gt;Welcome to the Catalog Home&lt;/h1&gt;
  &lt;a href="{{ url_for('catalog.products') }}"
    id="catalog_link"&gt;
    Click here to see the catalog
  &lt;/a&gt;
{% endblock %}
{% block scripts %}
&lt;script&gt;
$(document).ready(function(){
  $.getJSON("/home", function(data) {
    $('#catalog_link').append('&lt;span class="badge"&gt;' +
      data.count + '&lt;/span</span><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.580.1">&gt;');
  });
});
&lt;/script&gt;
{% endblock %}</span></pre>
<h2 id="_idParaDest-128"><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.581.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.582.1">Now, our home </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.583.1">page contains a badge, which shows the number of products in the database. </span><span class="koboSpan" id="kobo.583.2">This badge will load only after the whole page has loaded. </span><span class="koboSpan" id="kobo.583.3">The difference in the loading of the badge and the other content on the page will be notable when the database has a substantially high number </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">of products.</span></span></p>
<p><span class="koboSpan" id="kobo.585.1">The following is a screenshot that shows what the home page looks </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">like now:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer020">
<span class="koboSpan" id="kobo.587.1"><img alt="Figure 4.2 – The home page﻿ with the count loaded using AJAX calls" src="image/B19111_04_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.588.1">Figure 4.2 – The home page</span><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.589.1"> with the count loaded using AJAX calls</span></p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.590.1">Using decorators to handle requests beautifully</span></h1>
<p><span class="koboSpan" id="kobo.591.1">Some of you </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.592.1">may believe that checking every time whether a request is XHR, as shown in the last recipe, kills code readability. </span><span class="koboSpan" id="kobo.592.2">To solve this, we have an easy solution. </span><span class="koboSpan" id="kobo.592.3">In this recipe, we will write a simple decorator tha</span><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.593.1">t can handle this redundant code </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">for us.</span></span></p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor241"/><span class="koboSpan" id="kobo.595.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.596.1">In this recipe, we will write a decorator. </span><span class="koboSpan" id="kobo.596.2">For some Python beginners, this might seem like alien territory. </span><span class="koboSpan" id="kobo.596.3">If so, read </span><a href="http://legacy.python.org/dev/peps/pep-0318/"><span class="koboSpan" id="kobo.597.1">http://legacy.python.org/dev/peps/pep-0318/</span></a><span class="koboSpan" id="kobo.598.1"> f</span><a id="_idTextAnchor242"/><span class="koboSpan" id="kobo.599.1">or a better understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">of decorators.</span></span></p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor243"/><span class="koboSpan" id="kobo.601.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.602.1">The following is the decorator method that we have written for </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">this recipe:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.604.1">
from functools import wraps
def template_or_json(template=None):
    """"Return a dict from your view and this will either
    pass it to a template or render json. </span><span class="koboSpan" id="kobo.604.2">Use like:
    @template_or_json('template.html')
    """
    def decorated(f):
        @wraps(f)
        def decorated_fn(*args, **kwargs):
            ctx = f(*args, **kwargs)
            if request.headers.get("X-Requested-With") ==
              "XMLHttpRequest" or not template:
                return jsonify(ctx)
            else:
                return render_template(template, **ctx)
        return decorated_fn
    return decorated</span></pre>
<p><span class="koboSpan" id="kobo.605.1">This decorator simply does what we did in the previous recipe to handle XHR – that is, check whether </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.606.1">our request is XHR and, based on the outcome, either render the template or return </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">JSON data.</span></span></p>
<p><span class="koboSpan" id="kobo.608.1">Now, let’s apply this decorator to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">home()</span></strong><span class="koboSpan" id="kobo.610.1"> method, which handled the XHR call in the </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">last recipe:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.612.1">
@catalog.route('/')
@catalog.route('/home')
@template_or_json('home.html')
def home():
    products = Product.query.</span><a id="_idTextAnchor244"/><span class="koboSpan" id="kobo.613.1">all()
    return {'count': len(products)}</span></pre>
<h2 id="_idParaDest-132"><a id="_idTextAnchor245"/><span class="koboSpan" id="kobo.614.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.615.1">Refer to the </span><em class="italic"><span class="koboSpan" id="kobo.616.1">Dealing with XHR requests</span></em><span class="koboSpan" id="kobo.617.1"> recipe to understand how this recipe changes the coding pattern. </span><span class="koboSpan" id="kobo.617.2">The reference for this recipe comes </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">from </span></span><a href="http://justindonato.com/notebook/template-or-json-decorator-for-flask.html"><span class="No-Break"><span class="koboSpan" id="kobo.619.1">http://justindonato.com/notebook/t</span><span id="_idTextAnchor246"/><span class="koboSpan" id="kobo.620.1">emplate-or-json-decorator-for-flask.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.621.1">.</span></span></p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor247"/><span class="koboSpan" id="kobo.622.1">Creating custom 4xx and 5xx error handlers</span></h1>
<p><span class="koboSpan" id="kobo.623.1">Every application </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.624.1">throws errors to users at some point </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.625.1">in time. </span><span class="koboSpan" id="kobo.625.2">These errors can be due to a user typing a non-existent URL (</span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">404</span></strong><span class="koboSpan" id="kobo.627.1">), application overload (</span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">500</span></strong><span class="koboSpan" id="kobo.629.1">), or something forbidden for a certain user to access (</span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">403</span></strong><span class="koboSpan" id="kobo.631.1">). </span><span class="koboSpan" id="kobo.631.2">A good application handles these errors in a user-interactive way instead of showing an ugly white page, which makes no sense to most users. </span><span class="koboSpan" id="kobo.631.3">Flask provides an easy-to-use decorator to handle these errors. </span><span class="koboSpan" id="kobo.631.4">In this recipe, we will und</span><a id="_idTextAnchor248"/><span class="koboSpan" id="kobo.632.1">erstand how we can leverage </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">this decorator.</span></span></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor249"/><span class="koboSpan" id="kobo.634.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.635.1">The Flask </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">app</span></strong><span class="koboSpan" id="kobo.637.1"> object has a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">errorhandler()</span></strong><span class="koboSpan" id="kobo.639.1">, which enables us to handle our application’s errors in </span><a id="_idTextAnchor250"/><span class="koboSpan" id="kobo.640.1">a much more beautiful and </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">efficient manner.</span></span></p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor251"/><span class="koboSpan" id="kobo.642.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.643.1">Create a </span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.644.1">method that is decorated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">errorhandler()</span></strong><span class="koboSpan" id="kobo.646.1"> and renders the </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">404.html</span></strong><span class="koboSpan" id="kobo.648.1"> template whenever the </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">404 Not Found</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.650.1">error occurs:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.651.1">
@app.errorhandler(404)
def page_not_found(e):
    return render_template('404.html'), 404</span></pre>
<p><span class="koboSpan" id="kobo.652.1">The </span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.653.1">following lines of code represent the </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">flask_catalog_template/my_app/templates/404.html</span></strong><span class="koboSpan" id="kobo.655.1"> template, which is rendered if there are any </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">404</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.657.1"> errors:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.658.1">
{% extends 'home.html' %}
{% block container %}
  &lt;div class="top-pad"&gt;
    &lt;h3&gt;Hola Friend! </span><span class="koboSpan" id="kobo.658.2">Looks like in your quest you have
      reached a location which does not exist yet.&lt;/h3&gt;
    &lt;h4&gt;To continue, either check your map location (URL)
      or go back &lt;a href="{{ url_for('catalog.home')
  </span><a id="_idTextAnchor252"/><span class="koboSpan" id="kobo.659.1">    }}"&gt;home&lt;/a&gt;&lt;/h4&gt;
  &lt;/div&gt;
{% endblock %}</span></pre>
<h2 id="_idParaDest-136"><a id="_idTextAnchor253"/><span class="koboSpan" id="kobo.660.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.661.1">So, now, if we </span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.662.1">open an incorrect URL – for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">http://127.0.0.1:5000/i-am- lost</span></strong><span class="koboSpan" id="kobo.664.1"> – then we will get the screen shown </span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.665.1">in the </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<span class="koboSpan" id="kobo.667.1"><img alt="Figure 4.3 – A custom error handler page" src="image/B19111_04_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.668.1">Figure 4.3 – A custom error handler page</span></p>
<p><span class="koboSpan" id="kobo.669.1">Similarly, we can add </span><a id="_idTextAnchor254"/><span class="koboSpan" id="kobo.670.1">more error handlers for other error </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">codes too.</span></span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor255"/><span class="koboSpan" id="kobo.672.1">There’s more...</span></h2>
<p><span class="koboSpan" id="kobo.673.1">It is also possible to create custom errors as per application requirements and bind them to error codes and custom error screens. </span><span class="koboSpan" id="kobo.673.2">This can be done </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.675.1">
class MyCustom404(Exception):
    pass
@app.errorhandler(MyCustom404)
def special_page_not_found(error):
    return </span><a id="_idTextAnchor256"/><span class="koboSpan" id="kobo.676.1">render_template("errors/custom_404.html"), 404</span></pre>
<h1 id="_idParaDest-138"><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.677.1">Flashing messages for better user feedback</span></h1>
<p><span class="koboSpan" id="kobo.678.1">An important </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.679.1">aspect of all good web applications is to give users feedback regarding various activities. </span><span class="koboSpan" id="kobo.679.2">For example, when a user creates a product and is redirected to the newly created product, then it is good practice to tell them that the product has been created. </span><span class="koboSpan" id="kobo.679.3">In this recipe, we will see how flashing messages can </span><a id="_idTextAnchor258"/><span class="koboSpan" id="kobo.680.1">be used as a good feedback mechanism </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">for users.</span></span></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.682.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.683.1">We will start by adding the flash message functionality to our existing catalog application. </span><span class="koboSpan" id="kobo.683.2">We also have to make sure that we add a secret key to the application because the session depends on it, and if it’s absent,</span><a id="_idTextAnchor260"/><span class="koboSpan" id="kobo.684.1"> the application will error out </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">while flashing.</span></span></p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor261"/><span class="koboSpan" id="kobo.686.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.687.1">To demonstrate </span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.688.1">the flashing of messages, we will flash messages upon a </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">product’s creation.</span></span></p>
<p><span class="koboSpan" id="kobo.690.1">First, we will add a secret key to our app configuration in </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">flask_catalog_template/my_app</span></strong></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">__init__.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.694.1">
app.secret_key = 'some_random_key'</span></pre>
<p><span class="koboSpan" id="kobo.695.1">Now, we will modify our </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">create_product()</span></strong><span class="koboSpan" id="kobo.697.1"> handler in </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">flask_catalog_template/my_app/catalog/views.py</span></strong><span class="koboSpan" id="kobo.699.1"> to flash a message to the user regarding the </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">product’s creation.</span></span></p>
<p><span class="koboSpan" id="kobo.701.1">Also, another change has been made to this handler; now, it is possible to create the product from a web interface using a form. </span><span class="koboSpan" id="kobo.701.2">This change will make it easier to demonstrate how this recipe </span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">would work.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.703.1">
@catalog.route('/product-create', methods=['GET', 'POST'])
def create_product():
    if request.method == 'POST':
        name = request.form.get('name')
        price = request.form.get('price')
        categ_name = request.form.get('category')
        category = Category.query.filter_by(
            name=categ_name).first()
        if not category:
            category = Category(categ_name)
        product = Product(name, price, category)
        db.session.add(product)
        db.session.commit()
        flash('The product %s has been created' % name,
          'success')
        return redirect(
            url_for('catalog.product', id=product.id))
    return render_template('product-create.html')</span></pre>
<p><span class="koboSpan" id="kobo.704.1">In the preceding method, we first check whether the request type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">POST</span></strong><span class="koboSpan" id="kobo.706.1">. </span><span class="koboSpan" id="kobo.706.2">If yes, then we proceed </span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.707.1">to product creation as always, or render the page with a form to create a new product. </span><span class="koboSpan" id="kobo.707.2">Also, note the </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">flash</span></strong><span class="koboSpan" id="kobo.709.1"> statement, which will alert a user in the event of the successful creation of a product. </span><span class="koboSpan" id="kobo.709.2">The first argument to </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">flash()</span></strong><span class="koboSpan" id="kobo.711.1"> is the message to be displayed, and the second is the category of the message. </span><span class="koboSpan" id="kobo.711.2">We can use any suitable identifier in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">message</span></strong><span class="koboSpan" id="kobo.713.1"> category. </span><span class="koboSpan" id="kobo.713.2">This can be used later to determine the type of alert message to </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">be shown.</span></span></p>
<p><span class="koboSpan" id="kobo.715.1">A new template is added; this holds the code for the product form. </span><span class="koboSpan" id="kobo.715.2">The path of the template will </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">flask_catalog_template/my_app/templates/product-create.html</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.719.1">
{% extends 'home.html' %}
{% block container %}
  &lt;div class="top-pad"&gt;
    &lt;form
        class="form-horizontal"
        method="POST"
        action="{{ url_for('catalog.create_product') }}"
        role="form"&gt;
      &lt;div class="form-group"&gt;
        &lt;label for="name" class="col-sm-2 control-
          label"&gt;Name&lt;/label&gt;
        &lt;div class="col-sm-10"&gt;
          &lt;input type="text" class="form-control" id="name"
            name="name"&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class="form-group"&gt;
        &lt;label for="price" class="col-sm-2 control-
          label"&gt;Price&lt;/label&gt;
        &lt;div class="col-sm-10"&gt;
          &lt;input type="number" class="form-control"
            id="price" name="price"&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class="form-group"&gt;
        &lt;label for="category" class="col-sm-2 control-
          label"&gt;Category&lt;/label&gt;
        &lt;div class="col-sm-10"&gt;
          &lt;input type="text" class="form-control"
            id="category" name="category"&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;button type="submit" class="btn
        btn-default"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  &lt;/div&gt;
{% endblock %}</span></pre>
<p><span class="koboSpan" id="kobo.720.1">We will also </span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.721.1">modify our base template – that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">flask_catalog_template/my_app/templates/base.html</span></strong><span class="koboSpan" id="kobo.723.1"> – to accommodate flashed messages. </span><span class="koboSpan" id="kobo.723.2">Just add the following lines of code inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">&lt;div&gt;</span></strong><span class="koboSpan" id="kobo.725.1"> container before the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">container</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.727.1"> block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.728.1">
    &lt;br/&gt;
    &lt;div&gt;
      {% for category, message in
        get_flashed_messages(with_categories=true) %}
        &lt;div class="alert alert-{{category}}
          alert-dismissable"&gt;
          &lt;button type="button" class="close" data-dismiss
            ="alert" aria-hidden="true"&gt;&amp;times;&lt;/button&gt;
          {{ message }}
        &lt;/div&gt;
      {% endfor %}
    &lt;/div&gt;</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.729.1">Information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.730.1">Note that in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">&lt;div&gt;</span></strong><span class="koboSpan" id="kobo.732.1"> container, we have added a mechanism to show a flashed message that fetches the flashed messa</span><a id="_idTextAnchor262"/><span class="koboSpan" id="kobo.733.1">ges in the template, </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">get_flashed_messages()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">.</span></span></p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor263"/><span class="koboSpan" id="kobo.737.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.738.1">A form like </span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.739.1">the one shown in the following screenshot will appear upon moving </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">http://127.0.0.1:5000/product-create</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.743.1"><img alt="Figure 4.4 – Creating a product" src="image/B19111_04_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.744.1">Figure 4.4 – Creating a product</span></p>
<p><span class="koboSpan" id="kobo.745.1">Fill in the form and click on </span><strong class="bold"><span class="koboSpan" id="kobo.746.1">Submit</span></strong><span class="koboSpan" id="kobo.747.1">. </span><span class="koboSpan" id="kobo.747.2">This will lead to the usual product page with an alert message at </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">the top:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<span class="koboSpan" id="kobo.749.1"><img alt="Figure 4.5 –﻿ The flash message on successful product creation" src="image/B19111_04_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.750.1">Figure 4.5 –</span><a id="_idTextAnchor264"/><span class="koboSpan" id="kobo.751.1"> The flash message on successful product creation</span></p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor265"/><span class="koboSpan" id="kobo.752.1">Implementing SQL-based searching</span></h1>
<p><span class="koboSpan" id="kobo.753.1">In any web application, it is important to be able to search a database for records based on certain criteria. </span><span class="koboSpan" id="kobo.753.2">In this recipe, we will go through how to implement basic SQL-based searching in SQLAlchemy. </span><span class="koboSpan" id="kobo.753.3">The same principle</span><a id="_idTextAnchor266"/><span class="koboSpan" id="kobo.754.1"> can be used to search any other </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">database system.</span></span></p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor267"/><span class="koboSpan" id="kobo.756.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.757.1">We have </span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.758.1">implemented some level of search functionality in our catalog application from the beginning. </span><span class="koboSpan" id="kobo.758.2">Whenever we show the product page, we search for a specific product using its ID. </span><span class="koboSpan" id="kobo.758.3">We will now take it to a slightly more advanced l</span><a id="_idTextAnchor268"/><span class="koboSpan" id="kobo.759.1">evel and search on the basis of name </span><span class="No-Break"><span class="koboSpan" id="kobo.760.1">and category.</span></span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor269"/><span class="koboSpan" id="kobo.761.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.762.1">The following is a method that searches in our catalog application for name, price, company, and category. </span><span class="koboSpan" id="kobo.762.2">We can search for any one criterion, or multiple criteria (except for a search by category, which can only be searched alone). </span><span class="koboSpan" id="kobo.762.3">Note that we have different expressions for different values. </span><span class="koboSpan" id="kobo.762.4">For a float value in </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">price</span></strong><span class="koboSpan" id="kobo.764.1">, we can search for equality, and in the case of a string, we can search using </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">like</span></strong><span class="koboSpan" id="kobo.766.1">. </span><span class="koboSpan" id="kobo.766.2">Also, carefully note how </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">join</span></strong><span class="koboSpan" id="kobo.768.1"> is implemented in the case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">category</span></strong><span class="koboSpan" id="kobo.770.1">. </span><span class="koboSpan" id="kobo.770.2">Place this method </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.771.1">in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">views</span></strong><span class="koboSpan" id="kobo.773.1"> file – that </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">is, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">flask_catalog_template/my_app/catalog/views.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.777.1">
from sqlalchemy.orm import join
@catalog.route('/product-search')
@catalog.route('/product-search/&lt;int:page&gt;')
def product_search(page=1):
    name = request.args.get('name')
    price = request.args.get('price')
    company = request.args.get('company')
    category = request.args.get('category')
    products = Product.query
    if name:
        products = products.filter(Product.name.like('%' +
          name + '%'))
    if price:
        products = products.filter(Product.price == price)
    if company:
        products = products.filter(Product.company.like('%'
          + company + '%'))
    if category:
        products = products.select_from(join(Product,
          Category)).filter(
            Category.name.like('%' + category + '%')
        )
    return render_template(
        'products.html', p</span><a id="_idTextAnchor270"/><span class="koboSpan" id="kobo.778.1">roducts=products.paginate(page,
          10)
    )</span></pre>
<h2 id="_idParaDest-145"><a id="_idTextAnchor271"/><span class="koboSpan" id="kobo.779.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.780.1">We can </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.781.1">search for products by entering a URL, something like </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">http://127.0.0.1:5000/product-search?name=iPhone</span></strong><span class="koboSpan" id="kobo.783.1">. </span><span class="koboSpan" id="kobo.783.2">This will search for products with the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">iPhone</span></strong><span class="koboSpan" id="kobo.785.1"> and list the results on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">products.html</span></strong><span class="koboSpan" id="kobo.787.1"> template. </span><span class="koboSpan" id="kobo.787.2">Similarly, we can search for price and/or company or category as required. </span><span class="koboSpan" id="kobo.787.3">Try various combinations by yourself to aid </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">your understanding.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.789.1">Information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.790.1">We have used the same product list page to render our search results. </span><span class="koboSpan" id="kobo.790.2">It will be interesting to implement the search using Ajax. </span><span class="koboSpan" id="kobo.790.3">I will leave this to you to </span><span class="No-Break"><span class="koboSpan" id="kobo.791.1">implement yourself.</span></span></p>
</div>


<div class="Content" id="_idContainer025">
<h1 id="_idParaDest-146"><a id="_idTextAnchor272"/><span class="koboSpan" id="kobo.1.1">Part 2: Flask Deep Dive</span></h1>
<p><span class="koboSpan" id="kobo.2.1">Once the basic Flask web application is built, the next question concerns creating beautiful and reusable web forms and authentication. </span><span class="koboSpan" id="kobo.2.2">The first two chapters in this part focus specifically on </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">these topics.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">As a developer, you can always build web forms using plain HTML, but it is usually a cumbersome task and difficult to maintain consistent reusable components. </span><span class="koboSpan" id="kobo.4.2">This is where Jinja helps, with a better definition of forms and super-easy validations while being extensible </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">and customizable.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">Authentication is one of the most important parts of any application, whether web, mobile, or desktop. </span><a href="B19111_06.xhtml#_idTextAnchor328"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.7.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.8.1"> focuses on various techniques of authentication, which range from social to completely managed in-house. </span></p>
<p><span class="koboSpan" id="kobo.9.1">The next chapter deals with APIs, which are an integral part of any web application, and one of the major strengths of Flask lies in building APIs in a very clear, concise, and readable format. </span><span class="koboSpan" id="kobo.9.2">This is followed by adding the capability to support multiple languages in your </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">Flask application.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">Flask by default does not come with an admin interface as you would find in Django, which is another popular web framework written in Python. </span><span class="koboSpan" id="kobo.11.2">However, it is possible to create a completely custom admin interface in Flask quickly by leveraging some extensions. </span><span class="koboSpan" id="kobo.11.3">The last chapter in this part deals with </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">this subject.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">This part of the book comprises the </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">following chapters:</span></span></p>
<ul>
<li><a href="B19111_05.xhtml#_idTextAnchor273"><em class="italic"><span class="koboSpan" id="kobo.15.1">Chapter 5</span></em></a><em class="italic"><span class="koboSpan" id="kobo.16.1">, Web Forms with WTForms</span></em></li>
<li><a href="B19111_06.xhtml#_idTextAnchor328"><em class="italic"><span class="koboSpan" id="kobo.17.1">Chapter 6</span></em></a><em class="italic"><span class="koboSpan" id="kobo.18.1">, Authenticating in Flask</span></em></li>
<li><a href="B19111_07.xhtml#_idTextAnchor385"><em class="italic"><span class="koboSpan" id="kobo.19.1">Chapter 7</span></em></a><em class="italic"><span class="koboSpan" id="kobo.20.1">, RESTful API Building</span></em></li>
<li><a href="B19111_08.xhtml#_idTextAnchor414"><em class="italic"><span class="koboSpan" id="kobo.21.1">Chapter 8</span></em></a><em class="italic"><span class="koboSpan" id="kobo.22.1">, Internationalization and Localization</span></em></li>
<li><a href="B19111_09.xhtml#_idTextAnchor469"><em class="italic"><span class="koboSpan" id="kobo.23.1">Chapter 9</span></em></a><em class="italic"><span class="koboSpan" id="kobo.24.1">, Admin Interface for Flask Apps</span></em></li>
</ul>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer026">
</div>
</div>
<div>
<div id="_idContainer027">
</div>
</div>
</body></html>