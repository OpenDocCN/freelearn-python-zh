- en: Chapter 9. Advanced Techniques of Selenium WebDriver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in the book, we have seen how to set up Selenium WebDriver for testing
    web applications and some of the important features and APIs for locating and
    interacting with various elements in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore some of the advanced APIs of Selenium WebDriver.
    These features come in handy when you're testing fairly complex applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn more about:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating tests that simulate keyboard or mouse events using the `Actions` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating mouse operations such as drag-and-drop and double-click
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running JavaScript code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing screenshots and movies of test runs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling browser navigation and cookies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods for performing keyboard and mouse actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Selenium WebDriver's advanced user interactions API allows us to perform
    operations from simple keyboard and mouse events to complex mouse events such
    as drag-and-drop, pressing a hotkey combination, holding a key, and performing
    mouse operations. This is accomplished by using the `ActionChains` class in the
    Selenium WebDriver Python API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of the important methods supported by the `ActionChains` class
    for performing keyboard and mouse events:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description | Argument | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `click(on_element=None)` | This method performs the click operation. | `on_element`:
    This is the element to click. If `None`, clicks on the current mouse position.
    | `click(main_link)` |'
  prefs: []
  type: TYPE_TB
- en: '| `click_and_hold(on_element=None)` | This method holds down the left mouse
    button on an element. | `on_element`: This is the element to click and hold down
    the mouse button. If `None`, clicks on current mouse position. | `click_and_hold(gmail_link)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `double_click(on_element=None)` | This method performs a double-click on
    an element. | `on_element`: This is the element to double-click. If `None`, clicks
    on current mouse position. | `double_click(info_box)` |'
  prefs: []
  type: TYPE_TB
- en: '| `drag_and_drop(source, target)` | This method performs the drag-and-drop
    operation. | `source`: This is the element to mouse down.`target`: The element
    to mouse up. | `drag_and_drop(img, canvas)` |'
  prefs: []
  type: TYPE_TB
- en: '| `key_down(value, element=None)` | This method sends a key press only, without
    releasing it. This should only be used with modifier keys (such as the *Ctrl*,
    *Alt*, and *Shift* keys). | `key`: This is the modifier key to send. Values are
    defined in the `Keys` class.`target`: The element to send keys. If `None`, sends
    a key to current focused element. | `key_down(Keys.SHIFT)\ send_keys(''n'')\ key_up(Keys.SHIFT)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `key_up(value, element=None)` | This method releases a modifier key. | `key`:
    This is the modifier key to send. Values are defined in the `Keys` class.`target`:
    This is the element to send keys. If `None`, sends a key to current focused element.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `move_to_element(to_element)` | This method moves the mouse to the middle
    of an element. | `to_element`: This is the element to move to. | `move_to_element(gmail_link)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `perform()` | This method performs all stored actions. |   | `perform()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `release(on_element=None)` | This method releases a held mouse button. |
    `on_element`: This is the element to mouse up | `release(banner_img)` |'
  prefs: []
  type: TYPE_TB
- en: '| `send_keys(keys_to_send)` | This method sends keys to an element that has
    current focus. | `keys_to_send`: This is the keys to send | `send_keys("hello")`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `send_keys_to_element(element, keys_to_send)` | This method sends keys to
    an element. | `element`: This is the element to send keys.`keys_to_send`: The
    keys to send. | `send_keys_to_element(firstName, "John")` |'
  prefs: []
  type: TYPE_TB
- en: For a detailed list visit [http://selenium.googlecode.com/git/docs/api/py/webdriver/selenium.webdriver.common.action_chains.html](http://selenium.googlecode.com/git/docs/api/py/webdriver/selenium.webdriver.common.action_chains.html).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Interactions` API is not supported on Safari. Also, there are limitations
    for certain events on various browsers. For more details, refer to [https://code.google.com/p/selenium/wiki/AdvancedUserInteractions](https://code.google.com/p/selenium/wiki/AdvancedUserInteractions).
  prefs: []
  type: TYPE_NORMAL
- en: Keyboard actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a test that demonstrates how to use the keyboard actions such
    as pressing a hot key combination. In the sample app when we press the *Shift*
    + *N* key combination, a label will change its color, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can perform a hotkey press operation using the `ActionChains` class. In
    this example, we used a combination of `key_down()`, `send_key()`, and `key_up()`
    methods to perform *Shift* + *N* key press as if a real user has pressed these
    keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `ActionChains` class requires the `driver` instance to be passed. We can
    then arrange the sequence of events by calling the available methods and executing
    the action calling the `perform()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The mouse movement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is another example that calls the mouse move event by calling the `move_to_element()`
    method of the `ActionChains` class. This is equivalent to the `onMouseOver` event.
    The `move_to_element()` method will move the mouse cursor from its current location
    to the supplied element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The double_click method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can double-click on an element by calling the `double_click()` method of
    the `ActionChains` class in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The drag_and_drop method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Selenium WebDriver, we can perform the drag-and-drop operation by calling
    the `drag_and_drop()` method of the `ActionChains` class. This method requires
    the source element that will be dragged, and the target element where the source
    element will be dropped. Here is an example of the `drag_and_drop` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Executing JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can execute JavaScript code through Selenium WebDriver using the methods
    available from the `WebDriver` class. This is useful when we cannot perform certain
    operations using the Selenium WebDriver API or we want to test the JavaScript
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The WebDriver class provides the following methods to execute JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description | Argument | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `execute_async_script(script, *args)` | This method asynchronously executes
    JavaScript in the current window/frame. | `script`: This is the JavaScript code`args`:
    This is any arguments for the JavaScript code | `driver.execute_async_script("return
    document.title")` |'
  prefs: []
  type: TYPE_TB
- en: '| `execute_script(script, *args)` | This method synchronously executes JavaScript
    in the current window/frame. | `script`: This is the JavaScript code`args`: This
    is any arguments for the JavaScript code | `driver.execute_script("return document.title")`
    |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s create a test with a utility method, which highlights the elements before
    performing actions on these elements by using the JavaScript methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can execute the JavaScript code by calling the `execute_script` method of
    the `WebDriver` class, as shown in the following example. We can also pass arguments
    to the JavaScript code through this method. In this example, we are modifying
    the border style for a moment and reverting that change back. This will highlight
    the given element with green border during the execution. It is useful to know
    which step is being executed on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Capturing screenshots of failures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Capturing screenshots during the test run comes very handy when you want to
    communicate failures to the developers. It also helps in debugging tests or creating
    evidence of the test run. Selenium WebDriver comes with built-in methods to capture
    screenshots during the test run. The `WebDriver` class provides the following
    methods to capture and save a screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description | Argument | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Save_screenshot(filename)` | This method gets the screenshot of the current
    window and saves the image to the specified file. | `filename`: This is the path/name
    of the file to which the screenshot will be saved | `Driver.save_screenshot("homepage.png")`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `get_screenshot_as_base64()` | This method gets the screenshot of the current
    window as a base64 encoded string, which is useful in embedding images in HTML.
    |   | `driver.get_screenshot_as_base64()` |'
  prefs: []
  type: TYPE_TB
- en: '| `get_screenshot_as_file(filename)` | This method gets the screenshot of the
    current window. It returns `False` if there is any IOError, else returns `Tr`
    `ue`. It uses full paths in your filename. | `filename`: This is the path/name
    of the file to which the screenshot will be saved | `driver.get_screenshot_as_file(''/results/screenshots/HomePage.png'')`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `get_screenshot_as_png()` | This method gets the screenshot of the current
    window as binary data. |   | `driver.get_screenshot_as_png()` |'
  prefs: []
  type: TYPE_TB
- en: Let's create a test that captures a screenshot when it leads to failure. In
    this example, we'll locate an element that should be present on the application's
    home page. However, if the test doesn't find this element, it will throw `NoSuchElementException`
    and take a screenshot of the page displayed in the browser window, which we can
    use for debugging or sending to a developer as evidence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, when the test doesn''t find the promotion banner element,
    it takes a screenshot using the `save_screenshot()` method. We need to pass the
    path and name of the file to which the resulting image will be saved, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While capturing and saving the screenshot, it is recommended to use unique names
    for the image files such as including a timestamp and also using the **Portable
    Network** **Graphics** (**PNG**) format for highest compression of the file, which
    also results in minimal file size.
  prefs: []
  type: TYPE_NORMAL
- en: Recording a video of the test run
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to capturing screenshots, recording a video of the test run helps in
    recording complete test sessions in a visual way. We can watch the recorded video
    to understand what happens during the test run. This can be used as evidence for
    other project stakeholders as well, or can also be used as demos.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium WebDriver does not have built-in features to record video. Recording
    a video of the test run can be achieved by using a Python library called `Castro`
    separately. It was created by Jason Huggin, the creator of Selenium.
  prefs: []
  type: TYPE_NORMAL
- en: Castro is based on a cross-platform screen recording tool named **Pyvnc2swf**
    (refer to [http://www.unixuser.org/~euske/vnc2swf/pyvnc2swf.html](http://www.unixuser.org/~euske/vnc2swf/pyvnc2swf.html)).
    It captures the screen where the tests are running using the VNC protocol and
    generates a **Shockwave Flash** (**SWF**) movie file.
  prefs: []
  type: TYPE_NORMAL
- en: Castro also allows recording sessions from a remote machine using the VNC protocol.
    It needs a VNC program installed on the machine to record the videos. Before installing
    Castro we need PyGame library to be installed. The PyGame package cannot be installed
    with pip command and we need to get PyGame installer from [http://www.pygame.org/download.shtml](http://www.pygame.org/download.shtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install Castro using `pip` with the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We also need to install or enable VNC on the desktop, where the tests will be
    executed. On Windows, we need to install a VNC program. **TightVNC** ([http://www.tightvnc.com/](http://www.tightvnc.com/))
    will be a good choice. Install the TightVNC server and viewer on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: On Ubuntu, go to **Settings** | **Preference** | **Remote Desktop** and check
    the **Allow other users to view your** **desktop** checkbox. For Mac, we can install
    the Vine VNC server from [http://www.testplant.com/products/vine/](http://www.testplant.com/products/vine/)
    or enable **Remote Desktop** from **System Preferences**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s capture a video recording of the search test case that we created in
    the earlier chapters, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a new video recording session, we need to create an Castro object
    and initialize the instance with the path and name of the capture file as an argument
    to the constructor. Screen capture is started with the `start()` method, which
    will record the entire screen until the `stop` method is called. Testing with
    the `setUp()` method is the best way to initialize the Castro instance and start
    the recording as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To stop the recording, call the `stop()` method. Again, the `teadDown()` method
    is a good place to call this method so that we can capture the entire test case,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If there are multiple tests in a class, we can initialize and stop the recording
    in the class level using the `setUp()` and `teardown()` methods instead of creating
    a new file for each test.
  prefs: []
  type: TYPE_NORMAL
- en: Handling pop-up windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing pop-up windows involves identifying a pop-up window by its name attribute
    or window handle, switching the driver context to the desired pop-up window and
    then executing steps on the pop-up window, and finally switching back to the parent
    window.
  prefs: []
  type: TYPE_NORMAL
- en: When we create an instance of the browser from our tests, it is a parent window
    and any subsequent windows that are created from the parent window are called
    child windows or pop-up windows. We can work with any child window as long as
    it belongs to the current WebDriver context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a pop-up window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling pop-up windows](img/3506OS_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new test class `PopupWindowTest` with the test method `test_popup_window()`
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Before the context is moved to the child window, we can save the handle of
    the parent window using the `current_window_handle` property. We will use this
    value later to switch back to the parent window from the child window. We can
    switch to the child window by using its name or window handle by calling the `switch_to.window()`
    method of the `WebDriver` class. In this example, we are using the name of the
    window, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After performing actions and checking on the help window, we can close it by
    calling the `close()` method and switch back to the parent window, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Managing cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cookies are important for any web applications to store information on the
    user''s computer for a better user experience. Cookies are used to store user
    preferences, login information, and various other details of the client. The Selenium
    WebDriver API provides various methods to manage these cookies during testing.
    We can read cookie values, add cookies, and delete cookies during the test. This
    can be used to test how the application reacts when cookies are manipulated. The
    `WebDriver` class provides the following methods to manage cookies:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description | Argument | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `add_cookie(cookie_dict)` | This method adds a cookie to the current session
    | `cookie_dict`: This is a dictionary containing a cookie name and value pair
    | `driver.add_cookie({"foo","bar"})` |'
  prefs: []
  type: TYPE_TB
- en: '| `delete_all_cookies()` | This method deletes all the cookies from the current
    session |   | `driver.delete_all_cookies()` |'
  prefs: []
  type: TYPE_TB
- en: '| `delete_cookie(name)` | This method deletes a single cookie with the specified
    name | `name`: This is the name of the cookie to be deleted | `driver.delete_cookie("foo")`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `get_cookie(name)` | This method gets a single cookie by the name and returns
    the dictionary for the cookie if found, none, if not | `name`: This is the name
    of the cookie to search | `driver.get_cookie("foo")` |'
  prefs: []
  type: TYPE_TB
- en: '| `get_cookies()` | This method gets a set of dictionaries corresponding to
    cookies from the current session |   | `driver.get_cookies()` |'
  prefs: []
  type: TYPE_TB
- en: 'Here is an example that validates a cookie created to store the language selected
    by the user on the demo application''s home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can retrieve the value of the cookie using the `get_cookie()` method of the
    `WebDriver` class. We need to pass the name of the cookie. This method returns
    a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about advanced features of Selenium WebDriver API
    for handling the keyboard and mouse events, capturing screenshots, recording videos,
    and handling cookies.
  prefs: []
  type: TYPE_NORMAL
- en: We used the `ActionChains` class to perform various keyboard and mouse operations.
    These features are very useful when dealing with applications that heavily use
    keyboard and mouse actions.
  prefs: []
  type: TYPE_NORMAL
- en: You saw how to run JavaScript code from your tests. This is a very powerful
    feature while dealing with applications that use Ajax and we can use the underlying
    JavaScript API from our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: You captured screenshots for errors during test runs and also recorded a test
    session. This helps in debugging the tests as well as creating evidences for test
    runs.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned about the browser navigation methods and cookies.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to integrate our tests with other tools
    such as Continuous Integration tools to run the tests as part of the build process.
  prefs: []
  type: TYPE_NORMAL
