<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. The Singleton Design Pattern</h1></div></div></div><p class="calibre6">In the previous chapter, we explored design patterns and their classifications. As we are aware, design patterns can be classified under three main categories: structural, behavioral, and creational patterns.</p><p class="calibre6">In this chapter, we will go through the Singleton design pattern—one of the simplest and well-known Creational design patterns used in application development. This chapter will give you a brief introduction to the Singleton pattern, take you through a real-world example where this pattern can be used, and explain it in detail with the help of Python implementations. You will learn about the Monostate (or Borg) design pattern that is a variant of the Singleton design pattern.</p><p class="calibre6">In this chapter, we will cover the following topics in brief:</p><div><ul class="itemizedlist"><li class="listitem">An understanding of the Singleton design pattern</li><li class="listitem">A real-world example of the Singleton pattern</li><li class="listitem">The Singleton pattern implementation in Python</li><li class="listitem">The Monostate (Borg) pattern</li></ul></div><p class="calibre6">At the end of the chapter, we have a short summary on Singletons. This will help you think independently about some of the aspects of the Singleton design pattern.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec15" class="calibre1"/>Understanding the Singleton design pattern</h1></div></div></div><p class="calibre6">Singleton provides you with a mechanism to have one, and only one, object of a given type and provides a global point of access. Hence, Singletons are typically used in cases such as logging or database operations, printer spoolers, and many others, where there is a need to have only one instance that is available across the application to avoid conflicting requests on the same resource. For example, we may want to use one database object to perform operations on the DB to maintain data consistency or one object of the logging class across multiple services to dump log messages in a particular log file sequentially.</p><p class="calibre6">In brief, the intentions of the Singleton design pattern are as follows:</p><div><ul class="itemizedlist"><li class="listitem">Ensuring that one and only one object of the class gets created</li><li class="listitem">Providing an access point for an object that is global to the program</li><li class="listitem">Controlling concurrent access to resources that are shared</li></ul></div><p class="calibre6">The following is the UML diagram for Singleton:</p><div><img src="img/00003.jpeg" alt="Understanding the Singleton design pattern" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre6">A simple way of implementing Singleton is by making the constructor private and creating a static method that does the object initialization. This way, one object gets created on the first call and the class returns the same object thereafter.</p><p class="calibre6">In Python, we will implement it in a different way as there's no option to create private constructors. Let's take a look at how Singletons are implemented in the Python language.</p></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec26" class="calibre1"/>Implementing a classical Singleton in Python</h2></div></div></div><p class="calibre6">Here is<a id="id70" class="calibre1"/> a sample code of the Singleton pattern in Python v3.5. In this example, we will do two major things:</p><div><ol class="orderedlist"><li class="listitem" value="1">We will allow the creation of only one instance of the <code class="email">Singleton</code> class.</li><li class="listitem" value="2">If an instance exists, we will serve the same object again.</li></ol><div></div><p class="calibre6">The following code shows this:</p><div><pre class="programlisting">class Singleton(object):
     def __new__(cls):
       if not hasattr(cls, 'instance'):
         cls.instance = super(Singleton, cls).__new__(cls)
       return cls.instance

s = Singleton()
print("Object created", s)

s1 = Singleton()
print("Object created", s1)</pre></div><pre></div><p class="calibre15"> 
override the <code class="email">__new__</code> method (Python's special method to instantiate objects) to control the object creation. The s object gets created with the <code class="email">__new__</code> method, but before this, it checks whether the object already exists. The <code class="email">hasattr</code> method (Python's special method to know if an object has a certain property) is used to see if the <code class="email">cls</code> object has the instance property, which checks whether the class already has an object. Till the time the <code class="email">s1</code> object is requested, <code class="email">hasattr()</code> detects that an object already exists and hence <code class="email">s1</code> allocates the existing object instance (located at <code class="email">0x102078ba8</code>).</pre></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec16" class="calibre1"/>Lazy instantiation in the Singleton pattern</h1></div></div></div><p class="calibre6">One <a id="id72" class="calibre1"/>of the use cases for the Singleton pattern is lazy instantiation. For example, in the case of module imports, we may accidently create an object even when it's not needed. Lazy instantiation makes sure that the object gets created when it's actually needed. Consider lazy instantiation as the way to work with reduced resources and create them only when needed.</p><p class="calibre6">In the following code example, when we say <code class="email">s=Singleton()</code>, it calls the <code class="email">__init__</code> method but no new object gets created. However, actual object creation happens when we call <code class="email">Singleton.getInstance()</code>. This is how lazy instantiation is achieved.</p><div><pre class="programlisting">class Singleton:
    __instance = None
    def __init__(self):
        if not Singleton.__instance:
            print(" __init__ method called..")
        else:
            print("Instance already created:", self.getInstance())
    @classmethod
    def getInstance(cls):
        if not cls.__instance:
            cls.__instance = Singleton()
        return cls.__instance


s = Singleton() ## class initialized, but object not created
print("Object created", Singleton.getInstance()) # Object gets created here
s1 = Singleton() ## instance already created</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec17" class="calibre1"/>Module-level Singletons</h1></div></div></div><p class="calibre6">All modules<a id="id73" class="calibre1"/> are Singletons by default because of Python's importing behavior. Python works in the following way:</p><div><ol class="orderedlist"><li class="listitem" value="1">Checks whether a Python module has been imported.</li><li class="listitem" value="2">If imported, returns the object for the module. If not imported, imports and instantiates it.</li><li class="listitem" value="3">So when a module gets imported, it is initialized. However, when the same module is imported again, it's not initialized again, which relates to the Singleton behavior of having only one object and returning the same object.</li></ol><div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec18" class="calibre1"/>The Monostate Singleton pattern</h1></div></div></div><p class="calibre6">We <a id="id74" class="calibre1"/>discussed the Gang of Four and their book in <a class="calibre1" title="Chapter 1. Introduction to Design Patterns" href="part0015_split_000.html#E9OE1-5ae934a69a004514b92177e2702ed0a9">Chapter 1</a>, <em class="calibre13">Introduction to Design Patterns</em>. GoF's Singleton design pattern says that there should be one and only one object of a class. However, as per Alex Martelli, typically what a programmer needs is to have instances sharing the same state. He suggests that developers should be bothered about the state and behavior rather than the identity. As the concept is based on all objects sharing the same state, it is also known as the Monostate pattern.</p><p class="calibre6">The Monostate pattern can be achieved in a very simple way in Python. In the following code, we assign the <code class="email">__dict__</code> variable (a special variable of Python) with the <code class="email">__shared_state</code> class variable. Python uses <code class="email">__dict__</code> to store the state of every object of a class. In the following code, we intentionally assign <code class="email">__shared_state</code> to all the created instances. So when we create two instances, <code class="email">'b'</code> and <code class="email">'b1'</code>, we get two different objects unlike Singleton where we have just one object. However, the object states, <code class="email">b.__dict__</code> and <code class="email">b1.__dict__</code> are the same. Now, even if the object variable <code class="email">x</code> changes for object <code class="email">b</code>, the change is copied over to the <code class="email">__dict__</code> variable that is shared by all objects and even <code class="email">b1</code> gets this change of the <code class="email">x</code> setting from one to four:</p><div><pre class="programlisting">class Borg:
    __shared_state = {"1":"2"}
    def __init__(self):
        self.x = 1
        self.__dict__ = self.__shared_state
        pass

b = Borg()
b1 = Borg()
b.x = 4

print("Borg Object 'b': ", b) ## b and b1 are distinct objects
print("Borg Object 'b1': ", b1)
print("Object State 'b':", b.__dict__)## b and b1 share same state
print("Object State 'b1':", b1.__dict__)</pre></div><pre></div><p class="calibre15"> </pre><p class="calibre6">Another way to implement the Borg pattern is by tweaking the <code class="email">__new__</code> method itself. As we know, the <code class="email">__new__</code> method is responsible for the creation of the object instance:</p><div><pre class="programlisting">class Borg(object):
     _shared_state = {}
     def __new__(cls, *args, **kwargs):
       obj = super(Borg, cls).__new__(cls, *args, **kwargs)
       obj.__dict__ = cls._shared_state
       return obj</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec19" class="calibre1"/>Singletons and metaclasses</h1></div></div></div><p class="calibre6">Let's start <a id="id76" class="calibre1"/>with<a id="id77" class="calibre1"/> a brief introduction to metaclasses. A metaclass is a class of a class, which means that the class is an instance of its metaclass. With metaclasses, programmers get an opportunity to create classes of their own type from the predefined Python classes. For instance, if you have an object, <code class="email">MyClass</code>, you can create a metaclass, <code class="email">MyKls</code>, that redefines the behavior of <code class="email">MyClass</code> to the way that you need. Let's understand them in detail.</p><p class="calibre6">In Python, everything is an object. If we say <code class="email">a=5</code>, then <code class="email">type(a)</code> returns <code class="email">&lt;type 'int'&gt;</code>, which means <code class="email">a</code> is of the int type. However, <code class="email">type(int)</code> returns <code class="email">&lt;type 'type'&gt;</code>, which suggests the presence of a metaclass as int is a class of the <code class="email">type</code> type.</p><p class="calibre6">The definition of class is decided by its metaclass, so when we create a class with <code class="email">class A</code>, Python creates it by <code class="email">A = type(name, bases, dict)</code>:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">name</code>: This is the name of the class</li><li class="listitem"><code class="email">base</code>: This is the base class</li><li class="listitem"><code class="email">dict</code>: This is the attribute variable</li></ul></div><p class="calibre6">Now, if a<a id="id78" class="calibre1"/> class <a id="id79" class="calibre1"/>has a predefined metaclass (by the name of <code class="email">MetaKls</code>), Python creates the class by <code class="email">A = MetaKls(name, bases, dict)</code>.</p><p class="calibre6">Let's look at a sample metaclass implementation in Python 3.5:</p><div><pre class="programlisting">class MyInt(type):
    def __call__(cls, *args, **kwds):
        print("***** Here's My int *****", args)
        print("Now do whatever you want with these objects...")
        return type.__call__(cls, *args, **kwds)


class int(metaclass=MyInt):
    def __init__(self, x, y):
        self.x = x
        self.y = y


i = int(4,5)</pre></div><p class="calibre6">The following is the output of the preceding code:</p><div><img src="img/00006.jpeg" alt="Singletons and metaclasses" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre6">Python's special <code class="email">__call__</code> method gets called when an object needs to be created for an already existing class. In this code, when we instantiate the <code class="email">int</code> class with <code class="email">int(4,5)</code>, the <code class="email">__call__</code> method of the <code class="email">MyInt</code> metaclass gets called, which means that the metaclass now controls the instantiation of the object. Wow, isn't this great?!</p><p class="calibre6">The preceding philosophy is used in the Singleton design pattern as well. As the metaclass has more control over class creation and object instantiation, it can be used to create Singletons. (Note: To control the creation and initialization of a class, metaclasses override the <code class="email">__new__</code> and <code class="email">__init__</code> method.)</p><p class="calibre6">The Singleton implementation with metclasses can be explained better with the following example code:</p><div><pre class="programlisting">class MetaSingleton(type):
    _instances = {}
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(MetaSingleton, \
                cls).__call__(*args, **kwargs)
        return cls._instances[cls]

class Logger(metaclass=MetaSingleton):
    pass

logger1 = Logger()
logger2 = Logger()
print(logger1, logger2)</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec20" class="calibre1"/>A real-world scenario – the Singleton pattern, part 1</h1></div></div></div><p class="calibre6">As a <a id="id80" class="calibre1"/>practical use case, we will look at a database application to show the use of Singletons. Consider an example of a cloud service that involves multiple read and write operations on the database. The complete cloud service is split across multiple services that perform database operations. An action on the UI (web app) internally will call an API, which eventually results in a DB operation.</p><p class="calibre6">It's clear that the shared resource across different services is the database itself. So, if we need to design the cloud service better, the following points must be taken care of:</p><div><ul class="itemizedlist"><li class="listitem">Consistency across operations in the database—one operation shouldn't result in conflicts with other operations</li><li class="listitem">Memory and CPU utilization should be optimal for the handling of multiple operations on the database</li></ul></div><p class="calibre6">A sample Python implementation is given here:</p><div><pre class="programlisting">import sqlite3
class MetaSingleton(type):
    _instances = {}
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(MetaSingleton, \
                cls).__call__(*args, **kwargs)
        return cls._instances[cls]

class Database(metaclass=MetaSingleton):
  connection = None
  def connect(self):
    if self.connection is None:
        self.connection = sqlite3.connect("db.sqlite3")
        self.cursorobj = self.connection.cursor()
    return self.cursorobj

db1 = Database().connect()
db2 = Database().connect()

print ("Database Objects DB1", db1)
print ("Database Objects DB2", db2)</pre></div><p class="calibre6">The output of the preceding code is given here:</p><div><img src="img/00007.jpeg" alt="A real-world scenario – the Singleton pattern, part 1" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre6">In the <a id="id81" class="calibre1"/>preceding code, we can see following points being covered:</p><div><ol class="orderedlist"><li class="listitem" value="1">We created a metaclass by the name of <code class="email">MetaSingleton</code>. Like we explained in the previous section, the special <code class="email">__call__</code> method of Python is used in the metaclass to create a Singleton.</li><li class="listitem" value="2">The <code class="email">database</code> class is decorated by the <code class="email">MetaSingleton</code> class and starts acting like a Singleton. So, when the <code class="email">database</code> class is instantiated, it creates only one object.</li><li class="listitem" value="3">When the web app wants to perform certain operations on the DB, it instantiates the database class multiple times, but only one object gets created. As there is only one object, calls to the database are synchronized. Additionally, this is inexpensive on system resources and we can avoid the situation of memory or CPU resource.</li></ol><div></div><p class="calibre6">Consider that instead of having one webapp, we have a clustered setup with multiple web apps but only one DB. Now, this is not a good situation for Singletons because, with every web app addition, a new Singleton gets created and a new object gets added that queries the database. This results in unsynchronized database operations and is heavy on resources. In such cases, database connection pooling is better than implementing Singletons.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec21" class="calibre1"/>A real-world scenario – the Singleton pattern, part 2</h1></div></div></div><p class="calibre6">Let's <a id="id82" class="calibre1"/>consider another scenario where we implement health check services (such as Nagios) for our infrastructure. We create the <code class="email">HealthCheck</code> class, which is implemented as a Singleton. We also maintain a list of servers against which the health check needs to run. If a server is removed from this list, the health check software should detect it and remove it from the servers configured to check.</p><p class="calibre6">In the following code, the <code class="email">hc1</code> and <code class="email">hc2</code> objects are the same as the class in Singleton.</p><p class="calibre6">Servers<a id="id83" class="calibre1"/> are added to the infrastructure for the health check with the <code class="email">addServer()</code> method. First, the iteration of the health check runs against these servers. The <code class="email">changeServer()</code> method removes the last server and adds a new one to the infrastructure scheduled for the health check. So, when the health check runs in the second iteration, it picks up the changed list of servers.</p><p class="calibre6">All this is possible with Singletons. When the servers get added or removed, the health check must be the same object that has the knowledge of the changes made to the infrastructure:</p><div><pre class="programlisting">class HealthCheck:
    _instance = None
    def __new__(cls, *args, **kwargs):
        if not HealthCheck._instance:
            HealthCheck._instance = super(HealthCheck, \
                cls).__new__(cls, *args, **kwargs)
        return HealthCheck._instance
    def __init__(self):
        self._servers = []
    def addServer(self):
        self._servers.append("Server 1")
        self._servers.append("Server 2")
        self._servers.append("Server 3")
        self._servers.append("Server 4")
    def changeServer(self):
        self._servers.pop()
        self._servers.append("Server 5")

hc1 = HealthCheck()
hc2 = HealthCheck()

hc1.addServer()
print("Schedule health check for servers (1)..")
for i in range(4):
    print("Checking ", hc1._servers[i])

hc2.changeServer()
print("Schedule health check for servers (2)..")
for i in range(4):
    print("Checking ", hc2._servers[i])</pre></div><p class="calibre6">The output<a id="id84" class="calibre1"/> of the code is as follows:</p><div><img src="img/00008.jpeg" alt="A real-world scenario – the Singleton pattern, part 2" class="calibre14"/></div><p class="calibre15"> </p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec22" class="calibre1"/>Drawbacks of the Singleton pattern</h1></div></div></div><p class="calibre6">While<a id="id85" class="calibre1"/> Singletons are used in multiple places to good effect, there can be a few gotchas with this pattern. As Singletons have a global point of access, the following issues can occur:</p><div><ul class="itemizedlist"><li class="listitem">Global variables can be changed by mistake at one place and, as the developer may think that they have remained unchanged, the variables get used elsewhere in the application.</li><li class="listitem">Multiple references may get created to the same object. As Singleton creates only one object, multiple references can get created at this point to the same object.</li><li class="listitem">All classes that are dependent on global variables get tightly coupled as a change to the global data by one class can inadvertently impact the other class.</li></ul></div><div><h3 class="title2"><a id="note02" class="calibre1"/>Note</h3><p class="calibre6">As part of this chapter, you learned a lot on Singletons. Here are a few points that we<a id="id86" class="calibre1"/> should remember about Singletons:</p><div><ul class="itemizedlist"><li class="listitem">There are many real-world applications where we need to create only one object, such as thread pools, caches, dialog boxes, registry settings, and so on. If we create multiple instances for each of these applications, it will result in the overuse of resources. Singletons work very well in such situations.</li><li class="listitem">Singleton; a time-tested and proven method of presenting a global point of access without many downsides.</li><li class="listitem">Of course, there are a few downsides; Singletons can have an inadvertent impact working with global variables or instantiating classes that are resource-intensive but end up not utilizing them.</li></ul></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec23" class="calibre1"/>Summary</h1></div></div></div><p class="calibre6">In this chapter, you learned about the Singleton design pattern and the context in which it's used. We understood that Singletons are used when there is a need to have only one object for a class.</p><p class="calibre6">We also looked at various ways in which Singletons can be implemented in Python. The classical implementation allowed multiple instantiation attempts but returned the same object.</p><p class="calibre6">We also discussed the Borg or Monostate pattern, which is a variation of the Singleton pattern. Borg allows the creation of multiple objects that share the same state unlike the single pattern described by GoF.</p><p class="calibre6">We went on to explore the webapp application where Singleton can be applied for consistent database operations across multiple services.</p><p class="calibre6">Finally, we also looked at situations where Singletons can go wrong and what situations developers need to avoid.</p><p class="calibre6">At the end of this chapter, we're now comfortable enough to take the next step and study other creational patterns and benefit from them.</p><p class="calibre6">In the next chapter, we'll take a look at another creational pattern and the Factory design pattern. We'll cover the <code class="email">Factory</code> method and Abstract Factory patterns and understand them in the Python implementation.</p></div></body></html>