<html><head></head><body>
  <div id="_idContainer058">
    <h1 class="chapterNumber">4</h1>
    <h1 id="_idParaDest-94" class="chapterTitle">The SOLID Principles</h1>
    <p class="normal">In this chapter, we will continue to explore concepts of clean design applied to Python. In particular, we will review the <strong class="keyword">SOLID</strong> principles and how to implement them in a Pythonic way. These principles entail a series of good practices to achieve better-quality software. In case some of you aren't aware of what SOLID stands for, here it is:</p>
    <ul>
      <li class="bullet"><strong class="keyword">S</strong>: Single responsibility principle</li>
      <li class="bullet"><strong class="keyword">O</strong>: Open/closed principle</li>
      <li class="bullet"><strong class="keyword">L</strong>: Liskov's substitution principle</li>
      <li class="bullet"><strong class="keyword">I</strong>: Interface segregation principle</li>
      <li class="bullet"><strong class="keyword">D</strong>: Dependency inversion principle</li>
    </ul>
    <p class="normal">The goals of this chapter are as follows:</p>
    <ul>
      <li class="bullet">To become acquainted with SOLID principles for software design</li>
      <li class="bullet">To design software components that follow the single responsibility principle</li>
      <li class="bullet">To achieve more maintainable code through the open/closed principle</li>
      <li class="bullet">To implement proper class hierarchies in object-oriented design, by complying with Liskov's substitution principle</li>
      <li class="bullet">To design with interface segregation and dependency inversion</li>
    </ul>
    <h1 id="_idParaDest-95" class="title">The single responsibility principle</h1>
    <p class="normal">The <strong class="keyword">single responsibility principle</strong> (<strong class="keyword">SRP</strong>) states that a software component (in general, a class) must have only<a id="_idIndexMarker230"/> one responsibility. The fact that the class has a sole responsibility means that it is in charge of doing just one concrete thing, and as a consequence of that, we can conclude that it must have only one reason to change.</p>
    <p class="normal">Only if one thing on the domain problem changes will the class have to be updated. If we have to make modifications to a class for different reasons, it means the abstraction is incorrect, and that the class has too many responsibilities. This is probably an indication that there is at least one abstraction missing: more objects need to be created to address the extra responsibility that's overloading the current class in question.</p>
    <p class="normal">As introduced in <em class="chapterRef">Chapter 2</em>, <em class="italic">Pythonic Code</em>, this design principle helps us build more cohesive abstractions—objects that do one thing, and just one thing, well, following the Unix philosophy. What we want to avoid in all cases is having objects with multiple responsibilities (often called <strong class="keyword">God objects</strong>, because <a id="_idIndexMarker231"/>they know too much, or more than they should). These objects group different (mostly unrelated) behaviors, thus making them harder to maintain.</p>
    <p class="normal">Again, the smaller the class, the better.</p>
    <p class="normal">The SRP is closely related to the idea of cohesion in software design, which we already explored in <em class="chapterRef">Chapter 3</em>, <em class="italic">General Traits of Good Code</em>, when we discussed the separation of concerns in software. What we strive to achieve here is that classes are designed in such a way that most of their properties and their attributes are used by their methods, most of the time. When <a id="_idIndexMarker232"/>this happens, we know they are related concepts, and therefore it makes sense to group them under the same abstraction.</p>
    <p class="normal">In a way, this idea is somewhat analogous to the concept of normalization in relational database design. When we detect that there are partitions on the attributes or methods of the interface of an object, they might as well be moved somewhere else—it is a sign that they are two or more different abstractions mixed into one.</p>
    <p class="normal">There is another way of looking at this principle. If, when looking at a class, we find methods that are mutually exclusive and do not relate to each other, they are the different responsibilities that have to be broken down into smaller classes.</p>
    <h2 id="_idParaDest-96" class="title">A class with too many responsibilities</h2>
    <p class="normal">In this example, we are<a id="_idIndexMarker233"/> going to create a case for an application that is in charge of reading information about events from a source (this could be log files, a database, or many more sources), and identify the actions corresponding to each particular log.</p>
    <p class="normal">A design that fails to conform to the SRP would look like this:</p>
    <figure class="mediaobject"><img src="../Images/B16567_04_01.png" alt="Picture 2"/></figure>
    <p class="packt_figref">Figure 4.1: A class with too many responsibilities</p>
    <p class="normal">Without considering the implementation, the code for the class might look as in the following listing:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># srp_1.py</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">SystemMonitor</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">load_activity</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        """Get the events <span class="hljs-keyword">from</span> a source, to be processed."""
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">identify_events</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        """Parse the source raw data into events (domain objects)."""
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">stream_events</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        """Send the parsed events to an external agent."""
</code></pre>
    <p class="normal">The problem <a id="_idIndexMarker234"/>with this class is that it defines an interface with a set of methods that correspond to actions that are orthogonal: each one can be done independently of the rest.</p>
    <p class="normal">This design flaw makes the class rigid, inflexible, and error-prone because it is hard to maintain. In this example, each method represents a responsibility of the class. Each responsibility entails a reason why the class might need to be modified. In this case, each method represents one of the various reasons why the class will have to be modified.</p>
    <p class="normal">Consider the loader method, which retrieves the information from a particular source. Regardless of how this is done (we can abstract the implementation details here), it will have its own sequence of steps, for instance, connecting to the data source, loading the data, parsing it into the expected format, and so on. If we need to change something (for example, we want to change the data structure used for holding the data), the <code class="Code-In-Text--PACKT-">SystemMonitor</code> class will need to change. Ask yourself whether this makes sense. Does a system monitor object have to change because we changed the representation of the data? No.</p>
    <p class="normal">The same reasoning applies to the other two methods. If we change how we fingerprint events, or how we deliver them to another data source, we end up making changes to the same class.</p>
    <p class="normal">It should be clear by now that this class is rather fragile and not very maintainable. There are lots of <a id="_idIndexMarker235"/>different reasons that will impact changes in this class. Instead, we want external factors to impact our code as little as possible. The solution, again, is to create smaller and more cohesive abstractions.</p>
    <h2 id="_idParaDest-97" class="title">Distributing responsibilities</h2>
    <p class="normal">To make the solution <a id="_idIndexMarker236"/>more maintainable, we separate every method into a different class. This way, each class will have a single responsibility:</p>
    <figure class="mediaobject"><img src="../Images/B16567_04_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.2: Distributing responsibilities throughout classes</p>
    <p class="normal">The same behavior is achieved by using an object that interacts with instances of these new classes, using those objects as collaborators, but the idea remains that each class encapsulates a specific set of methods that are independent of the rest. The idea now is that changes to any of these classes do not impact the rest, and all of them have a clear and specific meaning. If we need to change something in how we load events from the data sources, the alert system is not even aware of these changes, so we do not have to modify anything on the system monitor (as long as the contract is still preserved), and the data target is also unmodified.</p>
    <p class="normal">Changes are now local, the impact is minimal, and each class is easier to maintain.</p>
    <p class="normal">The new classes define interfaces that are not only more maintainable but also reusable. Imagine that now, in another part of the application, we also need to read the activity from the logs, but for different purposes. With this design, we can simply use objects of the <code class="Code-In-Text--PACKT-">ActivityWatcher</code> type (which would actually be an interface, but for the purposes of this section, that detail is not relevant and will be explained later for the next principles). This would make sense, whereas it would not have made sense in the previous design, because attempts to reuse the only class we had defined would have also carried extra methods (such as <code class="Code-In-Text--PACKT-">identify_events()</code> or <code class="Code-In-Text--PACKT-">stream_events()</code>) that were not needed at all.</p>
    <p class="normal">One important clarification is that the principle does not mean at all that each class must have a single method. Any of the new classes might have extra methods, as long as they correspond to the same logic that that class is in charge of handling.</p>
    <p class="normal">An interesting observation of most (if not all) of the principles we're exploring in this chapter is that we shouldn't try to get them right from the very first design. The idea is to design software that can be easily extended and changed, and that can evolve toward a more stable version.</p>
    <p class="normal">In particular, you <a id="_idIndexMarker237"/>can use the SRP as a thought process. For example, if you're designing a component (let's say a class), and there are a lot of different things that need to be done (as in the previous example), right from the beginning you can anticipate that this will not end well, and that you need to separate responsibilities. That's a good start, but then the question is: what are the right boundaries to separate responsibilities? So, to understand this, you can start writing a monolithic class, in order to understand what the internal collaborations are and how responsibilities are distributed. This will help you get a clearer picture of the new abstractions that need to be created.</p>
    <h1 id="_idParaDest-98" class="title">The open/closed principle</h1>
    <p class="normal">The <strong class="keyword">open/closed principle</strong> (<strong class="keyword">OCP</strong>) states <a id="_idIndexMarker238"/>that a module should be both open and closed (but with respect to different aspects).</p>
    <p class="normal">When designing a class, for instance, we should carefully encapsulate the implementation details, so that it has good maintenance, meaning that we want it to be open to extension but closed to modification.</p>
    <p class="normal">What this means in simple terms is that, of course, we want our code to be extensible, to adapt to new requirements or changes in the domain problem. That means when something new appears on the domain problem, we only want to add new things to our model, not change anything existing that is closed to modification.</p>
    <p class="normal">If for some reason, when something new has to be added we find ourselves modifying the code, then that logic is probably poorly designed. Ideally, when requirements change, we want to just have to extend the module with the new behavior, but without having to alter the current logic significantly.</p>
    <p class="normal">This principle applies to <a id="_idIndexMarker239"/>several software abstractions. It could be a class or even a module we're talking about, but the idea remains the same. We will see examples of each one in the following two subsections.</p>
    <h2 id="_idParaDest-99" class="title">Example of maintainability perils for not following the OCP</h2>
    <p class="normal">Let's begin with an <a id="_idIndexMarker240"/>example<a id="_idIndexMarker241"/> of a system that is designed in such a way that does not follow the OCP, in order to see the maintainability problems this carries, and the inflexibility of such a design.</p>
    <p class="normal">The idea is that we have a part of the system that is in charge of identifying events as they occur in another system, which is being monitored. At each point, we want this component to identify the type of event, correctly, according to the values of the data that was previously gathered (for simplicity, we will assume it is packaged into a dictionary, and was previously retrieved through another means such as logs, queries, and many more). We have a class that, based on this data, will retrieve the event, which is another type with its own hierarchy.</p>
    <p class="normal">From the class diagram in <em class="italic">Figure 4.3</em>, we see an object that works with an interface (a base class, with several subclasses that can be used polymorphically):</p>
    <figure class="mediaobject"><img src="../Images/B16567_04_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.3: A design that's not closed for modification</p>
    <p class="normal">At first glance this might look like it's an extensible design: adding a new event would be about creating a new subclass of <code class="Code-In-Text--PACKT-">Event</code>, and then the system monitor should be able to work with them. However, this is not quite accurate, as it all depends on the actual implementation within the method used in the system monitor class.</p>
    <p class="normal">A first <a id="_idIndexMarker242"/>attempt<a id="_idIndexMarker243"/> to solve this problem might look like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># openclosed_1.py</span>
<span class="hljs-title">@dataclass</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Event</span><span class="hljs-class">:</span>
    raw_data: dict 
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">UnknownEvent</span><span class="hljs-class">(</span><span class="hljs-params">Event</span><span class="hljs-class">):</span>
    """A <span class="hljs-built_in">type</span> of event that cannot be identified <span class="hljs-keyword">from</span> its data."""
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">LoginEvent</span><span class="hljs-class">(</span><span class="hljs-params">Event</span><span class="hljs-class">):</span>
    """A event representing a user that has just entered the system."""
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">LogoutEvent</span><span class="hljs-class">(</span><span class="hljs-params">Event</span><span class="hljs-class">):</span>
    """An event representing a user that has just left the system."""
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">SystemMonitor</span><span class="hljs-class">:</span>
    """Identify events that occurred <span class="hljs-keyword">in</span> the system."""
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, event_data</span><span class="hljs-function">):</span>
        self.event_data = event_data
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">identify_event</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">if</span> (
            self.event_data["before"]["session"] == <span class="hljs-number">0</span>
            <span class="hljs-keyword">and</span> self.event_data["after"]["session"] == <span class="hljs-number">1</span>
        ):
            <span class="hljs-keyword">return</span> LoginEvent(self.event_data)
        <span class="hljs-keyword">elif</span> (
            self.event_data["before"]["session"] == <span class="hljs-number">1</span>
            <span class="hljs-keyword">and</span> self.event_data["after"]["session"] == <span class="hljs-number">0</span>
        ):
            <span class="hljs-keyword">return</span> LogoutEvent(self.event_data)
        <span class="hljs-keyword">return</span> UnknownEvent(self.event_data)
</code></pre>
    <p class="normal">The following is the expected behavior of the preceding code:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; l1 = SystemMonitor({"before": {"session": 0}, "after": {"session": 1}})</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; l1.identify_event().__class__.__name__</span>
'LoginEvent'
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; l2 = SystemMonitor({"before": {"session": 1}, "after": {"session": 0}})</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; l2.identify_event().__class__.__name__</span>
'LogoutEvent'
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; l3 = SystemMonitor({"before": {"session": 1}, "after": {"session": 1}})</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; l3.identify_event().__class__.__name__</span>
'UnknownEvent'
</code></pre>
    <p class="normal">Notice the<a id="_idIndexMarker244"/> hierarchy<a id="_idIndexMarker245"/> of event types, and some business logic to construct them. For instance, when there was no previous flag for a session, but there is now, we identify that record as a login event. Conversely, when the opposite happens, it means that it was a logout event. If it was not possible to identify an event, an event of type unknown is returned. This is to preserve polymorphism by following the <code class="Code-In-Text--PACKT-">null</code> object pattern (instead of returning <code class="Code-In-Text--PACKT-">None</code>, it retrieves an object of the corresponding type with some default logic). The <code class="Code-In-Text--PACKT-">null</code> object pattern is described in <em class="chapterRef">Chapter 9</em>, <em class="italic">Common Design Patterns</em>.</p>
    <p class="normal">This design has some problems. The first issue is that the logic for determining the types of events is centralized inside a monolithic method. As the number of events we want to support grows, this method will as well, and it could end up being a very long method, which is bad because, as we have already discussed, it will not be doing just one thing and one thing well.</p>
    <p class="normal">On the same line, we can see that this method is not closed for modification. Every time we want to add a new type of event to the system, we will have to change something in this method (not to mention that the chain of <code class="Code-In-Text--PACKT-">elif</code> statements will be a nightmare to read!).</p>
    <p class="normal">We want to be able to add new types of events without having to change this method (closed for modification). We also want to be able to support new types of events (open for extension) so that <a id="_idIndexMarker246"/>when<a id="_idIndexMarker247"/> a new event is added, we only have to add code, not change the code that already exists.</p>
    <h2 id="_idParaDest-100" class="title">Refactoring the events system for extensibility</h2>
    <p class="normal">The problem<a id="_idIndexMarker248"/> with the <a id="_idIndexMarker249"/>previous example was that the <code class="Code-In-Text--PACKT-">SystemMonitor</code> class was interacting directly with the concrete classes it was going to retrieve.</p>
    <p class="normal">In order to achieve a design that honors the open/closed principle, we have to design towards abstractions.</p>
    <p class="normal">A possible alternative would be to think of this class as it collaborates with the events, and then we delegate the logic for each particular type of event to its corresponding class:</p>
    <figure class="mediaobject"><img src="../Images/B16567_04_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.4: A design that follows the OCP</p>
    <p class="normal">Then we have to add a new (polymorphic) method to each type of event with the single responsibility of determining if it corresponds to the data being passed or not, and we also have to change the logic to go through all events, finding the right one.</p>
    <p class="normal">The new code should look like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># openclosed_2.py</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Event</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, raw_data</span><span class="hljs-function">):</span>
        self.raw_data = raw_data
<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">meets_condition</span><span class="hljs-function">(</span><span class="hljs-params">event_data: </span><span class="hljs-built_in">dict</span><span class="hljs-function">) -&gt; bool:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">UnknownEvent</span><span class="hljs-class">(</span><span class="hljs-params">Event</span><span class="hljs-class">):</span>
    """A <span class="hljs-built_in">type</span> of event that cannot be identified <span class="hljs-keyword">from</span> its data"""
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">LoginEvent</span><span class="hljs-class">(</span><span class="hljs-params">Event</span><span class="hljs-class">):</span>
<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">meets_condition</span><span class="hljs-function">(</span><span class="hljs-params">event_data: </span><span class="hljs-built_in">dict</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">return</span> (
            event_data["before"]["session"] == <span class="hljs-number">0</span>
            <span class="hljs-keyword">and</span> event_data["after"]["session"] == <span class="hljs-number">1</span>
        )
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">LogoutEvent</span><span class="hljs-class">(</span><span class="hljs-params">Event</span><span class="hljs-class">):</span>
<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">meets_condition</span><span class="hljs-function">(</span><span class="hljs-params">event_data: </span><span class="hljs-built_in">dict</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">return</span> (
            event_data["before"]["session"] == <span class="hljs-number">1</span>
            <span class="hljs-keyword">and</span> event_data["after"]["session"] == <span class="hljs-number">0</span>
        )
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">SystemMonitor</span><span class="hljs-class">:</span>
    """Identify events that occurred <span class="hljs-keyword">in</span> the system."""
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, event_data</span><span class="hljs-function">):</span>
        self.event_data = event_data
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">identify_event</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">for</span> event_cls <span class="hljs-keyword">in</span> Event.__subclasses__():
            <span class="hljs-keyword">try</span>:
                <span class="hljs-keyword">if</span> event_cls.meets_condition(self.event_data):
                    <span class="hljs-keyword">return</span> event_cls(self.event_data)
            <span class="hljs-keyword">except</span> KeyError:
                <span class="hljs-keyword">continue</span>
        <span class="hljs-keyword">return</span> UnknownEvent(self.event_data)
</code></pre>
    <p class="normal">Notice how the interaction is now oriented towards an abstraction (in this case, it would be the generic base class <code class="Code-In-Text--PACKT-">Event</code>, which might even be an abstract base class or an interface, but for the purposes of this example it is enough to have a concrete base class). The method no longer works with specific types of events, but just with generic events that follow a common interface—they are all polymorphic with respect to the <code class="Code-In-Text--PACKT-">meets_condition</code> method.</p>
    <p class="normal">Notice how events are discovered through the <code class="Code-In-Text--PACKT-">__subclasses__()</code> method. Supporting new types of events is now just about creating a new class for that event that has to extend <code class="Code-In-Text--PACKT-">Event</code> and <a id="_idIndexMarker250"/>implement <a id="_idIndexMarker251"/>its own <code class="Code-In-Text--PACKT-">meets_condition()</code> method, according to its particular criteria.</p>
    <p class="normal">This example relies on the <code class="Code-In-Text--PACKT-">__subclasses__()</code> method, because it's enough to illustrate the idea of an extensible design. Other alternatives can be used as well, such as registering classes using the <code class="Code-In-Text--PACKT-">abc</code> module, or creating our own registry, but the main idea is the same, and the relationship between the objects wouldn't change.</p>
    <p class="normal">With this design, the original <code class="Code-In-Text--PACKT-">identify_event</code> method is closed: it doesn't have to be modified when we add a new type of event to our domain. Conversely, the hierarchy of events is open for extension: when a new event appears in the domain, we only need to create a new entity and define its criteria according to the interface it implements.</p>
    <h2 id="_idParaDest-101" class="title">Extending the events system</h2>
    <p class="normal">Now, let's prove<a id="_idIndexMarker252"/> that this design is <a id="_idIndexMarker253"/>actually as extensible as we wanted it to be. Imagine that a new requirement arises, and we have to also support events that correspond to transactions that the user executed on the monitored system.</p>
    <p class="normal">The class diagram for the design has to include this new event type, as shown in <em class="italic">Figure 4.5</em>:</p>
    <figure class="mediaobject"><img src="../Images/B16567_04_05.png" alt=""/></figure>
    <figure class="mediaobject">Figure 4.5: The design extended</figure>
    <p class="normal">We create the new class, implement the criteria on its <code class="Code-In-Text--PACKT-">meets_condition</code> method, and the rest of the logic should continue to work as before (with the new behavior included).</p>
    <p class="normal">Assuming all the rest <a id="_idIndexMarker254"/>of the previous<a id="_idIndexMarker255"/> definitions don't change, here's the code for the new class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># openclosed_3.py</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">TransactionEvent</span><span class="hljs-class">(</span><span class="hljs-params">Event</span><span class="hljs-class">):</span>
    """Represents a transaction that has just occurred on the system."""
<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">meets_condition</span><span class="hljs-function">(</span><span class="hljs-params">event_data: </span><span class="hljs-built_in">dict</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">return</span> event_data["after"].get("transaction") <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>
</code></pre>
    <p class="normal">We can verify that the previous cases work as before and that the new event is also correctly identified:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; l1 = SystemMonitor({"before": {"session": 0}, "after": {"session": 1}})</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; l1.identify_event().__class__.__name__</span>
'LoginEvent'
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; l2 = SystemMonitor({"before": {"session": 1}, "after": {"session": 0}})</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; l2.identify_event().__class__.__name__</span>
'LogoutEvent'
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; l3 = SystemMonitor({"before": {"session": 1}, "after": {"session": 1}})</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; l3.identify_event().__class__.__name__</span>
'UnknownEvent'
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; l4 = SystemMonitor({"after": {"transaction": "Tx001"}})</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; l4.identify_event().__class__.__name__</span>
'TransactionEvent'
</code></pre>
    <p class="normal">Notice that the <code class="Code-In-Text--PACKT-">SystemMonitor.identify_event()</code> method did not change at all when we added the new event type. We therefore say that this method is closed with respect to new types of events.</p>
    <p class="normal">Conversely, the <code class="Code-In-Text--PACKT-">Event</code> class allowed us to add a new type of event when we were required to do so. We then say that events are open for an extension with respect to new types.</p>
    <p class="normal">This is the true essence <a id="_idIndexMarker256"/>of this principle—when <a id="_idIndexMarker257"/>something new appears on the domain problem, we only want to add new code, not modify any existing code.</p>
    <h2 id="_idParaDest-102" class="title">Final thoughts about the OCP</h2>
    <p class="normal">As you might have <a id="_idIndexMarker258"/>noticed, this principle is closely related to the effective use of polymorphism. We want to work towards designing abstractions that respect a polymorphic contract that the client can use, to a structure that is generic enough that extending the model is possible, as long as the polymorphic relationship is preserved.</p>
    <p class="normal">This principle tackles an important problem in software engineering: maintainability. The perils of not following the OCP are ripple effects and problems in the software where a single change triggers changes all over the code base, or risks breaking other parts of the code.</p>
    <p class="normal">One important final note is that, in order to achieve this design in which we do not change the code to extend behavior, we need to be able to create proper closure against the abstractions we want to protect (in this example, new types of events). This is not always possible in all programs, as some abstractions might collide (for example, we might have a proper abstraction that provides closure against a requirement but does not work for other types of requirements). In these cases, we need to be selective and apply a strategy that provides the best closure for the types of requirements that require being the most extensible.</p>
    <h1 id="_idParaDest-103" class="title">Liskov's substitution principle</h1>
    <p class="normal"><strong class="keyword">Liskov's substitution principle</strong> (<strong class="keyword">LSP</strong>) states that there is a series of properties that an object type must <a id="_idIndexMarker259"/>hold to preserve the reliability of its design.</p>
    <p class="normal">The main idea behind LSP is that, for any class, a client should be able to use any of its subtypes indistinguishably, without even noticing, and therefore without compromising the expected behavior at runtime. That means that clients are completely isolated and unaware of changes in the class hierarchy.</p>
    <p class="normal">More formally, this is the original definition (LISKOV 01) of LSP: if <em class="italic">S</em> is a subtype of <em class="italic">T</em>, then objects of type <em class="italic">T</em> may be replaced by objects of type <em class="italic">S</em>, without breaking the program.</p>
    <p class="normal">This can be understood with the help of a generic diagram such as the following one. Imagine that there is some client class that requires (includes) objects of another type. Generally speaking, we will want this client to interact with objects of some type, namely, it will work through an interface.</p>
    <p class="normal">Now, this type might as well be just a generic interface definition, an abstract class or an interface, not a class with the behavior itself. There may be several subclasses extending this type (described in <em class="italic">Figure 4.6</em> with the name <code class="Code-In-Text--PACKT-">Subtype</code>, up to <code class="Code-In-Text--PACKT-">N</code>). The idea behind this principle is that if the hierarchy is correctly implemented, the client class has to be able to work with instances of any of the subclasses without even noticing. These objects should be interchangeable, as <em class="italic">Figure 4.6</em> shows:</p>
    <figure class="mediaobject"><img src="../Images/B16567_04_06.png" alt="Picture 6"/></figure>
    <p class="packt_figref">Figure 4.6: A generic subtypes hierarchy</p>
    <p class="normal">This is related to other design principles we have already visited, like designing for interfaces. A good class must define a clear and concise interface, and as long as subclasses honor that interface, the program will remain correct.</p>
    <p class="normal">As a consequence of this, the principle also relates to the ideas behind designing by contract. There is a<a id="_idIndexMarker260"/> contract between a given type and a client. By following the rules of LSP, the design will make sure that subclasses respect the contracts as they are defined by parent classes.</p>
    <h2 id="_idParaDest-104" class="title">Detecting LSP issues with tools</h2>
    <p class="normal">There are some <a id="_idIndexMarker261"/>scenarios so notoriously wrong with respect to the LSP that they can be easily identified by the tools we have learned to configure in <em class="chapterRef">Chapter 1</em>, <em class="italic">Introduction, Code Formatting, and Tools</em> (mainly <code class="Code-In-Text--PACKT-">mypy</code> and <code class="Code-In-Text--PACKT-">pylint</code>).</p>
    <h3 id="_idParaDest-105" class="title">Using mypy to detect incorrect method signatures</h3>
    <p class="normal">By using type <a id="_idIndexMarker262"/>annotations (as <a id="_idIndexMarker263"/>recommended<a id="_idIndexMarker264"/> previously in <em class="chapterRef">Chapter 1</em>, <em class="italic">Introduction, Code Formatting, and Tools</em>), throughout our code, and configuring <code class="Code-In-Text--PACKT-">mypy</code>, we can quickly detect some basic errors early, and check basic compliance with LSP for free.</p>
    <p class="normal">If one of the subclasses of the <code class="Code-In-Text--PACKT-">Event</code> class were to override a method in an incompatible fashion, <code class="Code-In-Text--PACKT-">mypy</code> would notice this by inspecting the annotations:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Event</span><span class="hljs-class">:</span>
    ...
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">meets_condition</span><span class="hljs-function">(</span><span class="hljs-params">self, event_data: </span><span class="hljs-built_in">dict</span><span class="hljs-function">) -&gt; bool:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">LoginEvent</span><span class="hljs-class">(</span><span class="hljs-params">Event</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">meets_condition</span><span class="hljs-function">(</span><span class="hljs-params">self, event_data: </span><span class="hljs-built_in">list</span><span class="hljs-function">) -&gt; bool:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bool</span>(event_data)
</code></pre>
    <p class="normal">When we run <code class="Code-In-Text--PACKT-">mypy</code> on this file, we will get an error message saying the following:</p>
    <pre class="programlisting con"><code class="hljs-con">error: Argument 1 of "meets_condition" incompatible with supertype "Event"
</code></pre>
    <p class="normal">The violation to LSP is clear—since the derived class is using a type for the <code class="Code-In-Text--PACKT-">event_data</code> parameter that is different from the one defined on the base class, we cannot expect them to work equally. Remember that, according to this principle, any caller of this hierarchy has to be able to work with <code class="Code-In-Text--PACKT-">Event</code> or <code class="Code-In-Text--PACKT-">LoginEvent</code> transparently, without noticing any difference. Interchanging objects of these two types should not make the application fail. Failure to do so would break the polymorphism on the hierarchy.</p>
    <p class="normal">The same error would have occurred if the return type was changed for something other than a <code class="Code-In-Text--PACKT-">Boolean</code> value. The rationale is that clients of this code are expecting a <code class="Code-In-Text--PACKT-">Boolean</code> value to work with. If one of the derived classes changes this return type, it would be breaking the contract, and again, we cannot expect the program to continue working normally.</p>
    <p class="normal">A quick note about types that are not the same but share a common interface: even though this is just a simple example to demonstrate the error, it is still true that both dictionaries and lists have something in common; they are both iterables. This means that in some cases, it might be valid to have a method that expects a dictionary and another one expecting to receive a list, as long as both treat the parameters through the iterable interface. In <a id="_idIndexMarker265"/>this case, the problem <a id="_idIndexMarker266"/>would not lie in the logic itself (LSP might still apply), but in the<a id="_idIndexMarker267"/> definition of the types of the signature, which should read neither <code class="Code-In-Text--PACKT-">list</code> nor <code class="Code-In-Text--PACKT-">dict</code>, but a union of both. Regardless of the case, something has to be modified, whether it is the code of the method, the entire design, or just the type annotations, but in no case should we silence the warning and ignore the error given by <code class="Code-In-Text--PACKT-">mypy</code>.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Do not ignore errors such as this by using <code class="Code-In-Text--PACKT-"># type: ignore</code> or something similar. Refactor or change the code to solve the real problem. The tools are reporting an actual design flaw for a valid reason.</p>
    </div>
    <p class="normal">This principle also makes sense from an object-oriented design perspective. Remember that subclassing should create more specific types, but each subclass must be what the parent class declares. With the example from the previous section, the system monitor wants to be able to work with any of the event types interchangeably. But each of these event types is an event (a <code class="Code-In-Text--PACKT-">LoginEvent</code> must be an <code class="Code-In-Text--PACKT-">Event</code>, and so must the rest of the subclasses). If any of these objects break the hierarchy by not implementing a message from the base <code class="Code-In-Text--PACKT-">Event</code> class, implementing another public method not declared in this one, or changing the signature of the methods, then the <code class="Code-In-Text--PACKT-">identify_event</code> method might no longer work.</p>
    <h3 id="_idParaDest-106" class="title">Detecting incompatible signatures with pylint</h3>
    <p class="normal">Another strong <a id="_idIndexMarker268"/>violation<a id="_idIndexMarker269"/> of LSP is when, instead of varying the types of the parameters on the hierarchy, the signatures of the<a id="_idIndexMarker270"/> methods differ completely. This might seem like quite a blunder, but detecting it might not always be so easy to remember; Python is interpreted, so there is no compiler to detect these types of errors early on, and therefore they will not be caught until runtime. Luckily, we have static code analyzers such as <code class="Code-In-Text--PACKT-">mypy</code> and <code class="Code-In-Text--PACKT-">pylint</code> to catch errors such as this one early on.</p>
    <p class="normal">While <code class="Code-In-Text--PACKT-">mypy</code> will also catch these types of errors, it is a good idea to also run <code class="Code-In-Text--PACKT-">pylint</code> to gain more insight.</p>
    <p class="normal">In the presence of a class that breaks the compatibility defined by the hierarchy (for example, by changing the signature of the method, adding an extra parameter, and so on) such as the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># lsp_1.py</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">LogoutEvent</span><span class="hljs-class">(</span><span class="hljs-params">Event</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">meets_condition</span><span class="hljs-function">(</span><span class="hljs-params">self, event_data: </span><span class="hljs-built_in">dict</span><span class="hljs-params">, override: </span><span class="hljs-built_in">bool</span><span class="hljs-function">) -&gt; bool:</span>
        <span class="hljs-keyword">if</span> override:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        ...
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">pylint</code> will detect it, printing an informative error:</p>
    <pre class="programlisting con"><code class="hljs-con">Parameters differ from overridden 'meets_condition' method (arguments-differ)
</code></pre>
    <p class="normal">Once again, like in the previous case, do not suppress these errors. Pay attention to the warnings and errors the tools give and adapt the code accordingly.</p>
    <h2 id="_idParaDest-107" class="title">More subtle cases of LSP violations</h2>
    <p class="normal">In other cases, however, the <a id="_idIndexMarker271"/>way LSP is broken is not so clear or obvious that a tool can automatically identify it for us, and we have to rely upon careful code inspection when doing a code review.</p>
    <p class="normal">Cases where contracts are modified are particularly harder to detect automatically. Given that the entire idea of LSP is that subclasses can be used by clients just like their parent class, it must also be true that contracts are correctly preserved on the hierarchy.</p>
    <p class="normal">Remember from <em class="chapterRef">Chapter 3</em>, <em class="italic">General Traits of Good Code</em>, when designing by contract, the contract between the client and supplier sets some rules—the client must provide the preconditions to the method, which the supplier might validate, and it returns some result to the client that it will check in the form of postconditions.</p>
    <p class="normal">The parent class defines a contract with its clients. Subclasses of this one must respect such a contract. This means that for example:</p>
    <ul>
      <li class="bullet">A subclass can never make preconditions stricter than they are defined on the parent class</li>
      <li class="bullet">A subclass can never make postconditions weaker than they are defined on the parent class</li>
    </ul>
    <p class="normal">Consider the example of the events hierarchy defined in the previous section, but now with a change to illustrate the relationship between LSP and DbC.</p>
    <p class="normal">This time, we are going to assume a precondition for the method that checks the criteria based on the data, that the provided parameter must be a dictionary that contains both keys <code class="Code-In-Text--PACKT-">"before"</code> and <code class="Code-In-Text--PACKT-">"after"</code>, and that their values are also nested dictionaries. This allows us to encapsulate <a id="_idIndexMarker272"/>even further, because now the client does not need to catch the <code class="Code-In-Text--PACKT-">KeyError</code> exception, but instead just calls the precondition method (assuming that it is acceptable to fail if the system is operating under the wrong assumptions). </p>
    <p class="normal">As a side note, it is good that we can remove this from the client, as now, <code class="Code-In-Text--PACKT-">SystemMonitor</code> does not need to know which types of exceptions the methods of the collaborator class might raise (remember that exceptions weaken encapsulation, as they require the caller to know something extra about the object they are calling).</p>
    <p class="normal">Such a design might be represented with the following changes in the code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># lsp_2.py</span>
<span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Mapping
 
 
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Event</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, raw_data</span><span class="hljs-function">):</span>
        self.raw_data = raw_data
 
<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">meets_condition</span><span class="hljs-function">(</span><span class="hljs-params">event_data: </span><span class="hljs-built_in">dict</span><span class="hljs-function">) -&gt; bool:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
 
<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">validate_precondition</span><span class="hljs-function">(</span><span class="hljs-params">event_data: </span><span class="hljs-built_in">dict</span><span class="hljs-function">):</span>
        """Precondition of the contract of this interface.
 
        Validate that the ``event_data`` parameter <span class="hljs-keyword">is</span> properly formed.
        """
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(event_data, Mapping):
            <span class="hljs-keyword">raise</span> ValueError(f"{event_data!r} <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> a <span class="hljs-built_in">dict</span>")
        <span class="hljs-keyword">for</span> moment <span class="hljs-keyword">in</span> ("before", "after"):
            <span class="hljs-keyword">if</span> moment <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> event_data:
                <span class="hljs-keyword">raise</span> ValueError(f"{moment} <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> {event_data}")
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(event_data[moment], Mapping):
                <span class="hljs-keyword">raise</span> ValueError(f"event_data[{moment!r}] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> a <span class="hljs-built_in">dict</span>")
</code></pre>
    <p class="normal">And now the code that tries to detect the correct event type just checks the precondition once, and <a id="_idIndexMarker273"/>proceeds to find the right type of event:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># lsp_2.py</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">SystemMonitor</span><span class="hljs-class">:</span>
    """Identify events that occurred <span class="hljs-keyword">in</span> the system."""
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, event_data</span><span class="hljs-function">):</span>
        self.event_data = event_data
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">identify_event</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        Event.validate_precondition(self.event_data)
        event_cls = <span class="hljs-built_in">next</span>(
            (
                event_cls
                <span class="hljs-keyword">for</span> event_cls <span class="hljs-keyword">in</span> Event.__subclasses__()
                <span class="hljs-keyword">if</span> event_cls.meets_condition(self.event_data)
            ),
            UnknownEvent,
        )
        <span class="hljs-keyword">return</span> event_cls(self.event_data)
</code></pre>
    <p class="normal">The contract only states that the top-level keys <code class="Code-In-Text--PACKT-">"before"</code> and <code class="Code-In-Text--PACKT-">"after"</code> are mandatory and that their values should also be dictionaries. Any attempt in the subclasses to demand a more restrictive parameter will fail.</p>
    <p class="normal">The class for the transaction event was originally correctly designed. Look at how the code does not impose a restriction on the internal key named <code class="Code-In-Text--PACKT-">"transaction"</code>; it only uses its value if it is there, but this is not mandatory:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># lsp_2.py</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">TransactionEvent</span><span class="hljs-class">(</span><span class="hljs-params">Event</span><span class="hljs-class">):</span>
    """Represents a transaction that has just occurred on the system."""
<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">meets_condition</span><span class="hljs-function">(</span><span class="hljs-params">event_data: </span><span class="hljs-built_in">dict</span><span class="hljs-function">) -&gt; bool:</span>
        <span class="hljs-keyword">return</span> event_data["after"].get("transaction") <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>
</code></pre>
    <p class="normal">However, the original two methods are not correct, because they demand the presence of a key named <code class="Code-In-Text--PACKT-">"session"</code>, which is not part of the original contract. This breaks the contract, and now the client cannot use these classes in the same way it uses the rest of them because it will raise <code class="Code-In-Text--PACKT-">KeyError</code>.</p>
    <p class="normal">After fixing this (changing the square brackets for the <code class="Code-In-Text--PACKT-">.get()</code> method), the order on the LSP has been<a id="_idIndexMarker274"/> reestablished, and polymorphism prevails:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; l1 = SystemMonitor({"before": {"session": 0}, "after": {"session": 1}})</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; l1.identify_event().__class__.__name__</span>
'LoginEvent'
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; l2 = SystemMonitor({"before": {"session": 1}, "after": {"session": 0}})</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; l2.identify_event().__class__.__name__</span>
'LogoutEvent'
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; l3 = SystemMonitor({"before": {"session": 1}, "after": {"session": 1}})</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; l3.identify_event().__class__.__name__'UnknownEvent'</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; l4 = SystemMonitor({"before": {}, "after": {"transaction": "Tx001"}})</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; l4.identify_event().__class__.__name__</span>
'TransactionEvent'
</code></pre>
    <p class="normal">It is unreasonable to expect automated tools (regardless of how good and helpful they are) to detect cases such as this one. We have to be careful when designing classes that we do not accidentally<a id="_idIndexMarker275"/> change the input or output of the methods in a way that would be incompatible with what the clients are originally expecting.</p>
    <h2 id="_idParaDest-108" class="title">Remarks on the LSP</h2>
    <p class="normal">The LSP is fundamental to <a id="_idIndexMarker276"/>good object-oriented software design because it emphasizes one of its core traits—polymorphism. It is about creating correct hierarchies so that classes derived from a base one are polymorphic along the parent one, with respect to the methods on their interface.</p>
    <p class="normal">It is also interesting to notice how this principle relates to the previous one—if we attempt to extend a class with a new one that is incompatible, it will fail, the contract with the client will be broken, and as a result such an extension will not be possible (or, to make it possible, we would have to break the other end of the principle and modify code in the client that should be closed for modification, which is completely undesirable and unacceptable).</p>
    <p class="normal">Carefully thinking about new classes in the way that LSP suggests helps us to extend the hierarchy correctly. We could then say that LSP contributes to the OCP.</p>
    <h1 id="_idParaDest-109" class="title">Interface segregation</h1>
    <p class="normal">The <strong class="keyword">interface segregation principle</strong> (<strong class="keyword">ISP</strong>) provides some guidelines for an idea that we have revisited quite <a id="_idIndexMarker277"/>repeatedly already: that interfaces should be small.</p>
    <p class="normal">In object-oriented terms, an <strong class="keyword">interface</strong> is<a id="_idIndexMarker278"/> represented by the set of methods and properties an object exposes. That is to say that all the messages that an object is able to receive or interpret constitute its interface, and this is what other clients can request. The interface separates the definition of the exposed behavior for a class from its implementation.</p>
    <p class="normal">In Python, interfaces are implicitly defined by a class according to its methods. This is because Python follows<a id="_idIndexMarker279"/> the so-called <strong class="keyword">duck typing</strong> principle.</p>
    <p class="normal">Traditionally, the idea behind duck typing was that any object is really represented by the methods it has, and by what it is capable of doing. This means that, regardless of the type of the class, its name, docstring, class attributes, or instance attributes, what ultimately defines the essence of the object are the methods it has. The methods defined in a class (what it knows how to do) are what determines what that object will be. It was called duck typing because of the idea that "If it walks like a duck, and quacks like a duck, it must be a duck."</p>
    <p class="normal">For a long time, duck typing<a id="_idIndexMarker280"/> was the sole way interfaces were defined in Python. Later on, PEP-3119 introduced the concept of abstract base classes as a way to define interfaces in a different way. The basic idea of abstract base classes is that they define a basic behavior or interface that some derived classes are responsible for implementing. This is useful in situations where we want to make sure that certain critical methods are actually overridden, and it also works as a mechanism for overriding or extending the functionality of methods such as <code class="Code-In-Text--PACKT-">isinstance()</code>.</p>
    <p class="normal">The introduction of abstract base classes was done to provide a useful and powerful tool for developers to indicate things that must actually be implemented. For example, and considering the previous principle exposed (LSP), if we have a generic <code class="Code-In-Text--PACKT-">Event</code> class, we don't want to use that class itself (because by its own it doesn't mean anything), so we probably want to deal with one of the actual events (the subclasses, like <code class="Code-In-Text--PACKT-">LoginEvent</code>, for example). In this case we could define <code class="Code-In-Text--PACKT-">Event</code> as an abstract base class, to make this explicit. Then the system monitor works with a type of event, and the <code class="Code-In-Text--PACKT-">Event</code> class acts like an interface (as a <a id="_idIndexMarker281"/>way of saying "any object that has this kind of behavior"). We can go further and decide that the default implementation of the <code class="Code-In-Text--PACKT-">meets_condition</code> method is not enough (or that sometimes, an implementation can't be provided by the interface), and force each derived class to implement it. For this, we would use an <code class="Code-In-Text--PACKT-">@abstractmethod</code> decorator.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">abc</code> module also contains a way of registering some types as part of a hierarchy, in what is called a virtual subclass. The idea is that this extends the concept of duck typing a little bit further by adding a new criterion—walks like a duck, quacks like a duck, or... it says it is a duck.</p>
    <p class="normal">These notions of how Python interprets interfaces are important for understanding this principle and the next one.</p>
    <p class="normal">In abstract terms, the ISP states that when we define an interface that provides multiple methods, it is better to instead break it down into multiple ones, each one containing fewer methods (preferably just one), with a very specific and accurate scope. By separating interfaces into the smallest possible units, to favor code reusability, each class that wants to implement one of these interfaces will most likely be highly cohesive given that it has a quite definite behavior and set of responsibilities.</p>
    <h2 id="_idParaDest-110" class="title">An interface that provides too much</h2>
    <p class="normal">Now, we want to be able to parse an event from several data sources, in different formats (XML and JSON, for instance). Following good practices, we decide to target an interface as our dependency instead of a concrete class, and something like the following is devised:</p>
    <figure class="mediaobject"><img src="../Images/B16567_04_07.png" alt="Picture 7"/></figure>
    <p class="packt_figref">Figure 4.7: An interface providing too many disjoint capabilities</p>
    <p class="normal">In order to create this as an interface in Python, we would use an abstract base class and define the methods (<code class="Code-In-Text--PACKT-">from_xml()</code> and <code class="Code-In-Text--PACKT-">from_json()</code>) as abstract, to force derived classes to implement them. Events that derive from this abstract base class and implement these methods would be able to work with their corresponding types.</p>
    <p class="normal">But what if a particular<a id="_idIndexMarker282"/> class does not need the XML method, and can only be constructed from a JSON? It would still carry the <code class="Code-In-Text--PACKT-">from_xml()</code> method from the interface, and since it does not need it, it will have to pass. This is not very flexible as it creates coupling and forces clients of the interface to work with methods that they do not need.</p>
    <h2 id="_idParaDest-111" class="title">The smaller the interface, the better</h2>
    <p class="normal">It would be better to separate this into two different interfaces, one for each method. We can still achieve the same functionality by making our event parser class implement both interfaces (because interfaces or abstract base classes are just regular classes with some enhanced constraints, and Python supports multiple inheritance). The difference now is that we have each method declared in a more specific interface that we can reuse should we need it somewhere else in our code:</p>
    <figure class="mediaobject"><img src="../Images/B16567_04_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.8: The same functionality achieved through separate interfaces</p>
    <p class="normal">With this design, objects that derive from <code class="Code-In-Text--PACKT-">XMLEventParser</code> and implement the <code class="Code-In-Text--PACKT-">from_xml()</code> method will know how to be constructed from an XML, and the same for a JSON file, but most <a id="_idIndexMarker283"/>importantly, we maintain the orthogonality of two independent functions, and preserve the flexibility of the system without losing any functionality that can still be achieved by composing new smaller objects.</p>
    <p class="normal">This is how the code might look for the representation of <em class="italic">Figure 4.8</em>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABCMeta, abstractmethod
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">XMLEventParser</span><span class="hljs-class">(</span><span class="hljs-params">metaclass=ABCMeta</span><span class="hljs-class">):</span>
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">from_xml</span><span class="hljs-function">(</span><span class="hljs-params">xml_data: </span><span class="hljs-built_in">str</span><span class="hljs-function">):</span>
        """Parse an event from a source in XML representation."""
 
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">JSONEventParser</span><span class="hljs-class">(</span><span class="hljs-params">metaclass=ABCMeta</span><span class="hljs-class">):</span>
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">from_json</span><span class="hljs-function">(</span><span class="hljs-params">json_data: </span><span class="hljs-built_in">str</span><span class="hljs-function">):</span>
        """Parse an event from a source in JSON format."""
 
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">EventParser</span><span class="hljs-class">(</span><span class="hljs-params">XMLEventParser, JSONEventParser</span><span class="hljs-class">):</span>
    """An event parser that can create an event from source data either in XML or JSON format.
    """
 
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">from_xml</span><span class="hljs-function">(</span><span class="hljs-params">xml_data</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">pass</span>
 
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">from_json</span><span class="hljs-function">(</span><span class="hljs-params">json_data: </span><span class="hljs-built_in">str</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">pass</span>
</code></pre>
    <p class="normal">Note that the abstract methods required by the interface must be implemented in the concrete class (their actual implementation is not relevant for the example though). If we weren't to implement them, a runtime error would trigger, for example:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; from src.isp import EventParser</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; EventParser()</span>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: Can't instantiate abstract class EventParser with abstract methods from_json, from_xml
</code></pre>
    <p class="normal">There is some resemblance to the SRP, but the main difference is that here we are talking about interfaces, so it is an abstract definition of behavior. There is no reason to change because there<a id="_idIndexMarker284"/> is nothing there until the interface is actually implemented. However, failure to comply with this principle will create an interface that will be coupled with orthogonal functionality, and this derived class will also fail to comply with the SRP (it will have more than one reason to change).</p>
    <h2 id="_idParaDest-112" class="title">How small should an interface be?</h2>
    <p class="normal">The point made in the previous section is valid, but it also needs a warning—avoid a dangerous path if it's misunderstood or taken to the extreme.</p>
    <p class="normal">A base class (abstract or not) defines an interface for all the other classes to extend it. The fact that this should be as small as possible has to be understood in terms of cohesion—it should do one thing. That doesn't mean it must necessarily have one method. In the previous example, it was by coincidence that both methods were doing disjointed things; hence it made sense to separate them into different classes.</p>
    <p class="normal">But it could be the case that more than one method rightfully belongs to the same class. Imagine that you want to provide a mixin class that abstracts certain logic in a context manager so that all classes derived from that mixin gain that context manager logic for free. As we already know, a context manager entails two methods: <code class="Code-In-Text--PACKT-">__enter__</code> and <code class="Code-In-Text--PACKT-">__exit__</code>. They must go together, or the outcome will not be a valid context manager at all!</p>
    <p class="normal">Failure to place both methods in the same class will result in a broken component that is not only useless but also dangerous. Hopefully, this exaggerated example works as a counterbalance to <a id="_idIndexMarker285"/>the one in the previous section, and together you can get a more accurate picture of designing interfaces.</p>
    <h1 id="_idParaDest-113" class="title">Dependency inversion</h1>
    <p class="normal">This is a really powerful idea that will come up again later when we explore some design patterns in <em class="chapterRef">Chapter 9</em>, <em class="italic">Common Design Patterns</em>, and <em class="chapterRef">Chapter 10</em>, <em class="italic">Clean Architecture</em>.</p>
    <p class="normal">The <strong class="keyword">dependency inversion principle</strong> (<strong class="keyword">DIP</strong>) proposes an interesting design principle by which we protect our <a id="_idIndexMarker286"/>code by making it independent of things that are fragile, volatile, or out of our control. The idea of inverting dependencies is that our code should not adapt to details or concrete implementations, but rather the other way around: we want to force whatever implementation or detail to adapt to our code via a sort of API.</p>
    <p class="normal">Abstractions have to be organized in such a way that they do not depend on details, but rather the other way around—the details (concrete implementations) should depend on abstractions.</p>
    <p class="normal">Imagine that two objects in our design need to collaborate, <em class="italic">A</em> and <em class="italic">B</em>. <em class="italic">A</em> works with an instance of <em class="italic">B</em>, but as it turns out, our module doesn't control <em class="italic">B</em> directly (it might be an external library, or a module maintained by another team, and so on). If our code heavily depends on <em class="italic">B</em>, when this changes the code will break. To prevent this, we have to invert the dependency: make <em class="italic">B</em> have to adapt to <em class="italic">A</em>. This is done by presenting an interface and forcing our code not to depend on the concrete implementation of <em class="italic">B</em>, but rather on the interface we have defined. It is then <em class="italic">B</em>'s responsibility to comply with that interface.</p>
    <p class="normal">In line with the concepts explored in previous sections, abstractions also come in the form of interfaces (or abstract base classes in Python).</p>
    <p class="normal">In general, we could expect concrete implementations to change much more frequently than abstract components. It is for this reason that we place abstractions (interfaces) as flexibility points where we expect our system to change, be modified, or extended without the abstraction itself having to be changed.</p>
    <h2 id="_idParaDest-114" class="title">A case of rigid dependencies</h2>
    <p class="normal">The last part of our event's monitoring system is to deliver the<a id="_idIndexMarker287"/> identified events to a data collector to be further analyzed. A naïve implementation of such an idea would consist of having an event streamer class that interacts with a data destination, for example, <code class="Code-In-Text--PACKT-">Syslog</code>:</p>
    <figure class="mediaobject"><img src="../Images/B16567_04_09.png" alt="Picture 9"/></figure>
    <p class="packt_figref">Figure 4.9: A class that has a strong dependency on another</p>
    <p class="normal">However, this design is not very good, because we have a high-level class (<code class="Code-In-Text--PACKT-">EventStreamer</code>) depending on a low-level one (<code class="Code-In-Text--PACKT-">Syslog</code> is an implementation detail). If something changes in the way we want to send data to <code class="Code-In-Text--PACKT-">Syslog</code>, <code class="Code-In-Text--PACKT-">EventStreamer</code> will have to be modified. If we want to change the data destination for <a id="_idIndexMarker288"/>a different one or add new ones at runtime, we are also in trouble because we will find ourselves constantly modifying the <code class="Code-In-Text--PACKT-">stream()</code> method to adapt it to these requirements.</p>
    <h2 id="_idParaDest-115" class="title">Inverting the dependencies</h2>
    <p class="normal">The solution to these problems is to make <code class="Code-In-Text--PACKT-">EventStreamer</code> work<a id="_idIndexMarker289"/> with an interface, rather than a concrete class. This way, implementing this interface is up to the low-level classes that contain the implementation details:</p>
    <figure class="mediaobject"><img src="../Images/B16567_04_10.png" alt="Picture 10"/></figure>
    <p class="packt_figref">Figure 4.10: The functionality refactored by inverting the dependencies.</p>
    <p class="normal">Now there is an interface that represents a generic data target where data is going to be sent. Notice how the dependencies have now been inverted since <code class="Code-In-Text--PACKT-">EventStreamer</code> does not depend on a concrete implementation of a particular data target, it does not have to change in line with changes on this one, and it is up to every particular data target to implement the interface correctly and adapt to changes if necessary.</p>
    <p class="normal">In other words, the original <code class="Code-In-Text--PACKT-">EventStreamer</code> of the first implementation only worked with objects of type <code class="Code-In-Text--PACKT-">Syslog</code>, which was not very flexible. Then we realized that it could work with any object that could respond to a <code class="Code-In-Text--PACKT-">.send()</code> message, and identified this method as the interface that it needed to comply with. Now, in this version, <code class="Code-In-Text--PACKT-">Syslog</code> is actually extending the abstract base class named <code class="Code-In-Text--PACKT-">DataTargetClient</code>, which defines the <code class="Code-In-Text--PACKT-">send()</code> method. From now on, it is up to every new type of data target (email, for instance) to extend this abstract base class and implement the <code class="Code-In-Text--PACKT-">send()</code> method.</p>
    <p class="normal">We can even modify this<a id="_idIndexMarker290"/> property at runtime for any other object that implements a <code class="Code-In-Text--PACKT-">send()</code> method, and it will still work. This is the reason why<a id="_idIndexMarker291"/> it is often called <strong class="keyword">dependency injection</strong>: because the dependency can be provided (injected) dynamically.</p>
    <p class="normal">The astute reader might be wondering why this is necessary. Python is flexible enough (sometimes too flexible) and will allow us to provide an object like <code class="Code-In-Text--PACKT-">EventStreamer</code> with any particular data target object, without this one having to comply with any interface because it is dynamically typed. The question is this: why do we need to define the abstract base class (interface) at all when we can simply pass an object with a <code class="Code-In-Text--PACKT-">send()</code> method to it?</p>
    <p class="normal">In all fairness, this is true; there is actually no need to do that, and the program will work just the same. After all, polymorphism does not mean (or require) inheritance has to work. However, defining the abstract base class is a good practice that comes with some advantages, the first one being duck typing. Together with duck typing, we can mention the fact that the models become more readable—remember that inheritance follows the rule of <strong class="keyword">is a</strong>, so by declaring the abstract base class and extending from it, we are saying that, for instance, <code class="Code-In-Text--PACKT-">Syslog</code> is <code class="Code-In-Text--PACKT-">DataTargetClient</code>, which is something users of your code can read and understand (again, this is duck typing).</p>
    <p class="normal">All in all, it is not mandatory to define the abstract base class, but it is desirable in order to achieve a cleaner design. This is one of the things this book is for—to help programmers avoid easy-to-make mistakes, just because Python is too flexible, and we can get away with it.</p>
    <h2 id="_idParaDest-116" class="title">Dependency injection</h2>
    <p class="normal">The concept explored in the previous section gave us a powerful idea: instead of making our code dependent on a specific and concrete implementation, let's create a powerful abstraction that acts as a layer in between. In the example, we discussed how depending on <code class="Code-In-Text--PACKT-">Syslog</code> would lead to a rigid design, so we created an interface for all clients, and decided that <code class="Code-In-Text--PACKT-">Syslog</code> just<a id="_idIndexMarker292"/> happens to be one of them, because it implements the <code class="Code-In-Text--PACKT-">DataTargetClient</code> interface. This opens up the door to more clients we want to add in the future: just create a new class that implements the interface and defines the <code class="Code-In-Text--PACKT-">send</code> method. The design is now open for extension and closed for modification (we're starting to see how the principles relate to each other).</p>
    <p class="normal">Now, how would the collaboration among these objects be? In this part, we explore how the dependency is provided to the object that actually needs it.</p>
    <p class="normal">One way of doing it would be to just declare that the event streamer works by directly creating the object it needs, in this case a <code class="Code-In-Text--PACKT-">Syslog</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">EventStreamer</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        self._target = Syslog()
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">stream</span><span class="hljs-function">(</span><span class="hljs-params">self, events: </span><span class="hljs-built_in">list</span><span class="hljs-params">[Event]</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> events:
            self._target.send(event.serialise())
</code></pre>
    <p class="normal">However, this is not a very flexible design, and it doesn't take full advantage of the interface we have created. Note that this design is also harder to test: if you were to write a unit test for this class you would have to either patch the creation of the <code class="Code-In-Text--PACKT-">Syslog</code> object or override it after it has just been created. If the <code class="Code-In-Text--PACKT-">Syslog</code> has side effects at creation time (not good practice in general, but okay in some cases, for example, when you might want to establish a connection), then these side effects are carried to this initialization as well. It's true that this can be overcome by using a lazy property, but the inflexibility of actually controlling the object we provide is still there.</p>
    <p class="normal">A better design will use dependency injection, and let the target be provided to the event streamer:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">EventStreamer</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, target: DataTargetClient</span><span class="hljs-function">):</span>
        self._target = target
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">stream</span><span class="hljs-function">(</span><span class="hljs-params">self, events: </span><span class="hljs-built_in">list</span><span class="hljs-params">[Event]</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> events:
            self._target.send(event.serialise())
</code></pre>
    <p class="normal">This makes use of the interface and enables polymorphism. Now we can pass any object that implements this interface at initialization time, and it also makes it more explicit that an event streamer works with this kind of object.</p>
    <p class="normal">As opposed to the previous case, this version is also simpler to test. If we don't want to deal with <code class="Code-In-Text--PACKT-">Syslog</code> in our unit tests, we can provide a test double (just a new class that complies with the interface and is useful for whatever we need to test).</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Don't force the creation of dependencies in the initialization method. Instead, let your users define the dependencies in a more flexible way, by using an argument in the <code class="Code-In-Text--PACKT-">__init__</code> method.</p>
    </div>
    <p class="normal">In some cases, when the objects have a more complicated initialization (more arguments), or there are many of them, it could be a good idea to declare the interaction between<a id="_idIndexMarker293"/> your objects in a dependency graph, and then let a library do the actual creation of the objects for you (that is, to remove the boilerplate of the glue code that binds different objects).</p>
    <p class="normal">An example of such a <a id="_idIndexMarker294"/>library can be <code class="Code-In-Text--PACKT-">pinject</code> (<a href="https://github.com/google/pinject"><span class="url">https://github.com/google/pinject</span></a>), which lets you declare how the objects interact. In our simple example, one possibility would be to write the code like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">EventStreamer</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, target: DataTargetClient</span><span class="hljs-function">):</span>
        self.target = target
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">stream</span><span class="hljs-function">(</span><span class="hljs-params">self, events: </span><span class="hljs-built_in">list</span><span class="hljs-params">[Event]</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> events:
            self.target.send(event.serialise())
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">_EventStreamerBindingSpec</span><span class="hljs-class">(</span><span class="hljs-params">pinject.BindingSpec</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">provide_target</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">return</span> Syslog()
object_graph = pinject.new_object_graph(
    binding_specs=[_EventStreamerBindingSpec()])
</code></pre>
    <p class="normal">With the same definition of our class as before, we can define a binding specification, which is an object that knows how the dependencies are injected. In this object, any method named as provide<code class="Code-In-Text--PACKT-">_&lt;dependency&gt;</code> should return the dependency with that name as the suffix (we settled for <code class="Code-In-Text--PACKT-">Syslog</code> in our simple example). </p>
    <p class="normal">Then we create the <code class="Code-In-Text--PACKT-">graph</code> object, which we will use to get objects with the dependencies already provided; for example</p>
    <pre class="programlisting code"><code class="hljs-code">event_streamer = object_graph.provide(EventStreamer)
</code></pre>
    <p class="normal">will give us an <code class="Code-In-Text--PACKT-">event_streamer</code> object, whose target is an instance of <code class="Code-In-Text--PACKT-">Syslog</code>.</p>
    <p class="normal">When you have multiple dependencies or interrelations among objects, it's probably a good idea to write them declarative and let a tool handle the initialization for you. In this case, the idea is that for these kinds of objects, we define how they're created in a single place, and let the tool do that for us (in that sense it is similar to a factory object).</p>
    <p class="normal">Keep in mind that this<a id="_idIndexMarker295"/> doesn't lose the flexibility originally obtained from our design. The object graph is an object that knows how to build other entities based on the definitions made, but we still are in full control of the <code class="Code-In-Text--PACKT-">EventStreamer</code> class we've created, and can use it just as before, by passing any object in the initialization method that complies with the required interface.</p>
    <h1 id="_idParaDest-117" class="title">Summary</h1>
    <p class="normal">The SOLID principles are key guidelines for good object-oriented software design.</p>
    <p class="normal">Building software is an incredibly hard task—the logic of the code is complex, its behavior at runtime is hard (if even possible, sometimes) to predict, requirements change constantly as well as the environment, and there are multiple things that can go wrong.</p>
    <p class="normal">In addition, there are multiple ways of constructing software with different techniques, paradigms, or tools, which can work together to solve a particular problem in a specific manner. However, not all of these approaches will prove to be correct as time passes, and requirements change or evolve. However, by this time, it will already be too late to do something about an incorrect design, as it is rigid, inflexible, and therefore hard to change a refactor into the proper solution.</p>
    <p class="normal">This means that, if we get the design wrong, it will cost us a lot in the future. How can we then achieve a good design that will eventually pay off? The answer is that we do not know for sure. We are dealing with the future, and the future is uncertain—there is no way to determine if our design will be correct and if our software will be flexible and adaptable for years to come. It is precisely for that reason that we have to stick to principles.</p>
    <p class="normal">This is where the SOLID principles come into play. They are not a magic rule (after all, there are no silver bullets in software engineering), but they provide good guidelines to follow that have been proven to work in past projects and will make our software much more likely to succeed. The idea isn't to get all the requirements right from the very first version, but to achieve a design that's extensible and flexible enough to change, so that we can adapt it as needed.</p>
    <p class="normal">In this chapter, we have explored the SOLID principles with the goal of understanding clean design. In the following chapters, we will continue to explore details of the language, and see in some cases how these tools and features can be used with these principles.</p>
    <p class="normal"><em class="chapterRef">Chapter 5</em>, <em class="italic">Using Decorators to Improve Our Code</em>, explores how we can improve our code by taking advantage of decorators. Unlike this chapter, which was more focused on abstract ideas of software engineering, <em class="chapterRef">Chapter 5</em>, <em class="italic">Using Decorators to Improve Our Code</em>, will be more Python-focused, but we'll use the principles we've just learned.</p>
    <h1 id="_idParaDest-118" class="title">References</h1>
    <p class="normal">Here is a list of information you may refer to:</p>
    <ul>
      <li class="bullet"><em class="italic">SRP 01</em>: <em class="italic">The Single Responsibility Principle</em> (<a href="https://8thlight.com/blog/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html"><span class="url">https://8thlight.com/blog/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html</span></a>)</li>
      <li class="bullet"><em class="italic">PEP-3119</em>: <em class="italic">Introducing Abstract Base Classes</em> (<a href="https://www.python.org/dev/peps/pep-3119/"><span class="url">https://www.python.org/dev/peps/pep-3119/</span></a>)</li>
      <li class="bullet"><em class="italic">Object-Oriented Software Construction</em>, <em class="italic">Second Edition</em>, written by <em class="italic">Bertrand Meyer</em></li>
      <li class="bullet"><em class="italic">LISKOV 01</em>: A paper written by <em class="italic">Barbara Liskov</em> called <em class="italic">Data Abstraction and Hierarchy</em> (<a href="https://www.cs.tufts.edu/~nr/cs257/archive/barbara-liskov/data-abstraction-and-hierarchy.pdf"><span class="url">https://www.cs.tufts.edu/~nr/cs257/archive/barbara-liskov/data-abstraction-and-hierarchy.pdf</span></a>)</li>
    </ul>
  </div>
</body></html>