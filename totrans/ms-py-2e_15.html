<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer271" class="Basic-Text-Frame">&#13;
    <h1 class="chapterNumber">15</h1>&#13;
    <h1 id="_idParaDest-424" class="chapterTitle">Scientific Python and Plotting</h1>&#13;
    <p class="normal">The Python programming language is quite suited for scientific work. This is due to it being really easy to program for while being powerful enough to do almost anything you need. This combination has spawned a whole bunch of (very large) Python projects, such as <code class="inlineCode">numpy</code>, <code class="inlineCode">scipy</code>, <code class="inlineCode">matplotlib</code>, <code class="inlineCode">pandas</code>, and so on, over the years. While these libraries are all large enough to warrant entire books for themselves, we can offer a little insight into where and when they can be useful so you have an idea of where to start.</p>&#13;
    <p class="normal">The major topics and libraries covered in this chapter are split into three sections:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><strong class="keyWord">Arrays and matrices</strong>: NumPy, Numba, SciPy, Pandas, statsmodels, and xarray</li>&#13;
      <li class="bulletList"><strong class="keyWord">Mathematics and precise calculations</strong>: gmpy2, Sage, mpmath, SymPy, and Patsy</li>&#13;
      <li class="bulletList"><strong class="keyWord">Plotting, graphing, and charting</strong>: Matplotlib, Seaborn, Yellowbrick, Plotly, Bokeh, and Datashader</li>&#13;
    </ul>&#13;
    <p class="normal">It is very likely that not all libraries in this chapter are relevant to you, so don’t feel bad for not reading through all of it. However, I would recommend you at least look at the NumPy and Pandas sections briefly, as they are used heavily in the next chapter on machine learning.</p>&#13;
    <p class="normal">Additionally, I would also recommend taking a look at the Matplotlib and Plotly sections, since those could be very useful in a wide range of scenarios.</p>&#13;
    <h1 id="_idParaDest-425" class="heading-1">Installing the packages</h1>&#13;
    <p class="normal">As is always the case with <a id="_idIndexMarker1229"/>Python libraries that are built on C and other non-Python code, installing is very platform-dependent. On most platforms, thanks to binary wheels, we can simply do:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>pip3 install &lt;package&gt;&#13;
</code></pre>&#13;
    <p class="normal">For this and the next chapter, however, I would recommend an alternative solution instead. While some of the libraries, such as <code class="inlineCode">numpy</code>, are easy to install on most platforms, some of the other<a id="_idIndexMarker1230"/> libraries are more challenging. For this reason, I would recommend the use of either the <strong class="keyWord">Anaconda</strong> distribution or one of the <strong class="keyWord">Jupyter Docker Stacks</strong>.</p>&#13;
    <p class="normal">The Jupyter Docker Stacks<a id="_idIndexMarker1231"/> require you to have Docker working on your system, but if you do, it can be extremely easy to launch very complicated systems that would be near impossible to set up otherwise. The list of available stacks can be found here: <a href="https://jupyter-docker-stacks.readthedocs.io/en/latest/using/selecting.html#core-stacks"><span class="url">https://jupyter-docker-stacks.readthedocs.io/en/latest/using/selecting.html#core-stacks</span></a>.</p>&#13;
    <p class="normal">A good starting point for this chapter is the <code class="inlineCode">jupyter/scipy-notebook</code> stack, which includes a huge list of packages such as <code class="inlineCode">numpy</code>, <code class="inlineCode">scipy</code>, <code class="inlineCode">numba</code>, <code class="inlineCode">matplotlib</code>, <code class="inlineCode">cython</code>, and many more. Running this image (assuming you have Docker running) is as easy as:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> docker run -p 8888:8888 jupyter/scipy-notebook&#13;
</code></pre>&#13;
    <p class="normal">After running the command, it will give you some information on how to open Jupyter in your browser.</p>&#13;
    <h1 id="_idParaDest-426" class="heading-1">Arrays and matrices</h1>&#13;
    <p class="normal">Matrices are at<a id="_idIndexMarker1232"/> the heart of most scientific Python and artificial intelligence libraries because they are very convenient for storing a lot of related data. They are also suitable for really fast bulk processing, and calculations on them can be performed much faster than you could achieve with many separate variables. In some cases, these calculations can even be offloaded to the GPU for even faster processing.</p>&#13;
    <p class="normal">Note that a 0D matrix is<a id="_idIndexMarker1233"/> effectively a single number, a 1D matrix is a regular array, and there is no real limit to the number of dimensions you can use. It should be noted that both size and processing time quickly increase with multiple dimensions, of course.</p>&#13;
    <h2 id="_idParaDest-427" class="heading-2">NumPy – Fast arrays and matrices</h2>&#13;
    <p class="normal">The <code class="inlineCode">numpy</code> package<a id="_idIndexMarker1234"/> spawned most of the scientific Python development and is still used at the core of many of the libraries covered in this chapter and the next. The library is largely (where it matters, at least) written in C, which makes it extremely fast; we will see a few benchmarks later, but depending on the operation, it can easily be 100 times faster than pure Python for the CPython interpreter. </p>&#13;
    <p class="normal">Since <code class="inlineCode">numpy</code> has numerous features, we can only cover a few of the basics. But these already demonstrate how incredibly powerful (and fast) it is and why it is the basis for many of the other scientific Python packages in this chapter.</p>&#13;
    <p class="normal">The core feature of the <code class="inlineCode">numpy</code> library is the <code class="inlineCode">numpy.ndarray</code> object. The <code class="inlineCode">numpy.ndarray</code> object is implemented in C and offers a very fast and memory-efficient array. It can be represented as a single-dimension array or a multi-dimensional matrix with very powerful slicing features. You can store any Python object in one of these arrays, but to take full benefit of the power of <code class="inlineCode">numpy</code>, you will need to use numbers such as integers or floating point numbers.</p>&#13;
    <div class="packt_tip">&#13;
      <p class="normal">One important thing to note about <code class="inlineCode">numpy</code> arrays is that they have a <strong class="keyWord">fixed</strong> size and cannot be resized because they reserve a contiguous block of memory. If you need to make them smaller or larger, you will need to create a new array.</p>&#13;
    </div>&#13;
    <p class="normal">Let’s look at a few basic examples of how this array can be used and why it is very convenient:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># A commonly used shorthand for numpy is np</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> numpy <span class="hljs-con-keyword">as</span> np&#13;
&#13;
<span class="hljs-con-comment"># Generate a list of numbers from 0 up to 1 million</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a = np.arange(<span class="hljs-con-number">1000000</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a&#13;
array([     0,      1,      2, ..., 999997, 999998, 999999])&#13;
&#13;
<span class="hljs-con-comment"># Change the shape (still references the same data) to a</span>&#13;
<span class="hljs-con-comment"># 2-dimensional 1000x1000 array</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b = a.reshape((<span class="hljs-con-number">1000</span>, <span class="hljs-con-number">1000</span>))&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b&#13;
array([[     0,      1,      2, ...,    997,    998,    999],&#13;
       [  1000,   1001,   1002, ...,   1997,   1998,   1999],&#13;
       ...,&#13;
       [998000, 998001, 998002, ..., 998997, 998998, 998999],&#13;
       [999000, 999001, 999002, ..., 999997, 999998, 999999]])&#13;
&#13;
<span class="hljs-con-comment"># The first row of the matrix</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b[<span class="hljs-con-number">0</span>]&#13;
array([  0,   1,   2,   3, ..., 995, 996, 997, 998, 999])&#13;
&#13;
<span class="hljs-con-comment"># The first column of the matrix</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b[:, <span class="hljs-con-number">0</span>]&#13;
array([     0,   1000,   2000,   ..., 997000, 998000, 999000])&#13;
&#13;
<span class="hljs-con-comment"># Row 10 up to 12, the even columns between 20 and 30</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b[<span class="hljs-con-number">10</span>:<span class="hljs-con-number">12</span>, <span class="hljs-con-number">20</span>:<span class="hljs-con-number">30</span>:<span class="hljs-con-number">2</span>]&#13;
array([[10020, 10022, 10024, 10026, 10028],&#13;
       [11020, 11022, 11024, 11026, 11028]])&#13;
&#13;
<span class="hljs-con-comment"># Row 10, columns 5 up to 10:</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b[<span class="hljs-con-number">10</span>, <span class="hljs-con-number">5</span>:<span class="hljs-con-number">10</span>]&#13;
array([10005, 10006, 10007, 10008, 10009])&#13;
&#13;
<span class="hljs-con-comment"># Alternative syntax for the last slice</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b[<span class="hljs-con-number">10</span>][<span class="hljs-con-number">5</span>:<span class="hljs-con-number">10</span>]&#13;
array([10005, 10006, 10007, 10008, 10009])&#13;
</code></pre>&#13;
    <p class="normal">As you can see, the<a id="_idIndexMarker1235"/> slicing options of <code class="inlineCode">numpy</code> are very powerful, but what is even more useful about these slices is that they are all references/views instead of copies.</p>&#13;
    <p class="normal">This means that if you modify the data in a slice, the original array will be modified as well. To illustrate using the array we created in the earlier examples:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> b[<span class="hljs-con-number">0</span>] *= <span class="hljs-con-number">10</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b[:, <span class="hljs-con-number">0</span>] *= <span class="hljs-con-number">20</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a&#13;
array([     0,     10,     20, ..., 999997, 999998, 999999])&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b[<span class="hljs-con-number">0</span>:<span class="hljs-con-number">2</span>]&#13;
array([[    0,    10,    20, ...,  9970,  9980,  9990],&#13;
       [20000,  1001,  1002, ...,  1997,  1998,  1999]])&#13;
</code></pre>&#13;
    <p class="normal">As you can see, after modifying the first row and the first column for each row, we now see that <code class="inlineCode">a</code>, <code class="inlineCode">b</code>, and consequently all slices of <code class="inlineCode">a</code> and <code class="inlineCode">b</code> have been modified; and all of that in a single operation instead of having to loop.</p>&#13;
    <p class="normal">Let’s try to run a simple<a id="_idIndexMarker1236"/> benchmark to see how fast <code class="inlineCode">numpy</code> can be at certain operations. If you are familiar with linear algebra, you undoubtedly know what a dot product is. If not, the dot product is an algebraic operation on two equal-length arrays of numbers, which are multiplied pair-wise and summed after. In mathematical terms, it looks like this:</p>&#13;
    <p class="center"><img src="Images/B15882_15_001.png" alt="" width="408" height="67"/></p>&#13;
    <p class="normal">It is a rather simple procedure and not that computationally heavy, but still something that is much faster when executed through <code class="inlineCode">numpy</code>.</p>&#13;
    <div class="note">&#13;
      <p class="normal"> The goal of the dot product is to apply the growth of the second vector (array) onto the first vector. When applied to matrices, this can be used to move/rotate/scale a point or even an <em class="italic">n</em>-dimensional object. Simply put, if you have a 3D model stored in <code class="inlineCode">numpy</code>, you can run a full transform on it using <code class="inlineCode">numpy.dot</code>. Some examples of these operations can be found in my <code class="inlineCode">numpy-stl</code> package: <a href="https://pypi.org/project/numpy-stl/."><span class="url">https://pypi.org/project/numpy-stl/.</span></a></p>&#13;
      <p class="normal">Within this example, we will keep to the standard dot product of two 1-dimensional arrays, however.</p>&#13;
    </div>&#13;
    <p class="normal">To easily time the results, we will execute this from an IPython shell:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">In [1]: import numpy&#13;
&#13;
In [2]: a = list(range(1000000))&#13;
In [3]: b = numpy.array(a)&#13;
&#13;
In [4]: def dot(xs, ys):&#13;
   ...:     total = 0&#13;
   ...:     for x, y in zip(xs, ys):&#13;
   ...:         total += x * y&#13;
   ...:     return total&#13;
   ...:&#13;
&#13;
In [5]: %timeit dot(a, a)&#13;
78.7 ms ± 1.03 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)&#13;
In [6]: %timeit numpy.dot(b, b)&#13;
518 µs ± 27.6 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)&#13;
</code></pre>&#13;
    <p class="normal">In this basic<a id="_idIndexMarker1237"/> example, we can see that the pure Python version takes 78.7 ms and the <code class="inlineCode">numpy</code> version takes 518 µs. That means that the <code class="inlineCode">numpy</code> version is 150 times faster. Depending on what you are trying to do and on the size of the array, the advantage can be far greater.</p>&#13;
    <p class="normal">To create an array, there are several options available, but the following are the most useful in my experience:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">numpy.array(source_array)</code> creates an array from a different array (as we saw in the previous example).</li>&#13;
      <li class="bulletList"><code class="inlineCode">numpy.arange(n)</code> creates an array with the given range. Effectively identical to <code class="inlineCode">numpy.array(range(n))</code>.</li>&#13;
      <li class="bulletList"><code class="inlineCode">numpy.zeros(n)</code> creates an array of size <code class="inlineCode">n</code>, filled with zeros. It also supports tuples to create matrices: <code class="inlineCode">numpy.zeros((x, y, z))</code>.</li>&#13;
      <li class="bulletList"><code class="inlineCode">numpy.fromfunction(function, (x, y, z))</code> creates an array with the given shape using the given function. It should be noted that this function will be passed the index/indices of the current item, so the <code class="inlineCode">x</code>, <code class="inlineCode">y</code>, and <code class="inlineCode">z</code> indices in this case.</li>&#13;
    </ul>&#13;
    <p class="normal">The <code class="inlineCode">numpy</code> library has many more useful functions, but at the very least it offers an array with nearly unbeatable performance and a very easy-to-use interface. </p>&#13;
    <h2 id="_idParaDest-428" class="heading-2">Numba – Faster Python on CPU or GPU</h2>&#13;
    <p class="normal">We already covered the basics of <code class="inlineCode">numba</code> in <em class="chapterRef">Chapter 12</em>, <em class="italic">Performance – Tracking and Reducing Your Memory and CPU Usage</em>. Combined with <code class="inlineCode">numpy</code>, <code class="inlineCode">numba</code> gets even more powerful because it<a id="_idIndexMarker1238"/> natively supports functions that broadcast over <code class="inlineCode">numpy</code> arrays (<code class="inlineCode">numpy</code> calls these <code class="inlineCode">ufuncs</code> or <strong class="keyWord">universal functions</strong>), similar to how the built-in <code class="inlineCode">numpy</code> functions work. The only important difference between a regular <code class="inlineCode">numba</code> function and one that <a id="_idIndexMarker1239"/>supports <code class="inlineCode">numpy</code> per-element processing is which decorator function you use. Normally you would use <code class="inlineCode">numba.jit()</code>; for <code class="inlineCode">numpy</code> per-element processing you need to use the <code class="inlineCode">numba.vectorize(...)</code> decorator with the input and output types as parameters:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> numpy&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> numba&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> numbers = numpy.arange(<span class="hljs-con-number">500</span>, dtype=numpy.int64)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@numba.vectorize(</span><span class="hljs-con-params">[numba.int64(numba.int64)]</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span> <span class="hljs-con-title">add_one</span>(<span class="hljs-con-params">x</span>):&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> x + <span class="hljs-con-number">1</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> numbers&#13;
array([  0,   1,   2, ..., 498, 499])&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> add_one(numbers)&#13;
array([  1,   2,   3, ..., 499, 500])&#13;
</code></pre>&#13;
    <p class="normal">Adding 1 is a useless example of course, but you can do anything you want here, which makes it very useful. The real point is how easy it is; as long as your function is purely functional (in other words, does not mutate external variables), it can be made extremely fast with very little effort. That is also the reason why several of the other libraries in this chapter heavily <a id="_idIndexMarker1240"/>depend on <code class="inlineCode">numba</code> for their performance.</p>&#13;
    <div class="note">&#13;
      <p class="normal">As we specified <code class="inlineCode">numba.vectorize([numba.int64(numba.int64)])</code>, our function will only accept a 64-bit integer and will return a 64-bit integer. To create a function that takes two 32- or 64-bit floats and returns a 64-bit integer, we would use the following:</p>&#13;
      <pre class="programlisting code"><code class="hljs-code">@numba.vectorize([&#13;
    numba.int64(numba.float32, numba.float32), &#13;
    numba.int64(numba.float64, numba.float64),&#13;
])&#13;
</code></pre>&#13;
    </div>&#13;
    <p class="normal">In addition to the <code class="inlineCode">numba.vectorize()</code> decorator, we have several other options available, such as the <code class="inlineCode">numba.jitclass()</code> decorator for JIT-compiling an entire class, or the <code class="inlineCode">numba.jit_module()</code> function to enhance an entire module. </p>&#13;
    <h2 id="_idParaDest-429" class="heading-2">SciPy – Mathematical algorithms and NumPy utilities</h2>&#13;
    <p class="normal">The <code class="inlineCode">scipy</code> (Scientific Python) package<a id="_idIndexMarker1241"/> contains a collection of mathematical algorithms for many different problems. The functions vary from signal processing to spatial algorithms to statistical functions.</p>&#13;
    <p class="normal">Here’s a list of some of the <a id="_idIndexMarker1242"/>current sub-packages available in the <code class="inlineCode">scipy</code> library (according to the <code class="inlineCode">scipy</code> manual):</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">cluster</code>: Clustering algorithms such as <em class="italic">k</em>-means</li>&#13;
      <li class="bulletList"><code class="inlineCode">fftpack</code>: Fast Fourier Transform routines</li>&#13;
      <li class="bulletList"><code class="inlineCode">integrate</code>: Integration and ordinary differential equation solvers</li>&#13;
      <li class="bulletList"><code class="inlineCode">interpolate</code>: Interpolation and spline smoothing functions</li>&#13;
      <li class="bulletList"><code class="inlineCode">linalg</code>: Linear algebra functions such as linear equation solving</li>&#13;
      <li class="bulletList"><code class="inlineCode">ndimage</code>: <em class="italic">N</em>-dimensional image processing</li>&#13;
      <li class="bulletList"><code class="inlineCode">odr</code>: Orthogonal distance regression</li>&#13;
      <li class="bulletList"><code class="inlineCode">optimize</code>: Optimization and root-finding routines</li>&#13;
      <li class="bulletList"><code class="inlineCode">signal</code>: Signal processing functions such as peak finding and spectral analysis</li>&#13;
      <li class="bulletList"><code class="inlineCode">sparse</code>: Sparse matrices and associated routines to save memory</li>&#13;
      <li class="bulletList"><code class="inlineCode">spatial</code>: Spatial data structures and algorithms for triangulation and plotting</li>&#13;
      <li class="bulletList"><code class="inlineCode">stats</code>: Statistical distributions and functions</li>&#13;
    </ul>&#13;
    <p class="normal">As you can see, <code class="inlineCode">scipy</code> features algorithms for a large range of topics and many of the functions are really fast, so it is definitely worth taking a look at.</p>&#13;
    <p class="normal">With most of these topics, you can already guess by their names whether or not they apply to your use case, but there are a few that warrant a small example. So, let’s look at one.</p>&#13;
    <h3 id="_idParaDest-430" class="heading-3">Sparse matrices</h3>&#13;
    <p class="normal">One of the most useful <a id="_idIndexMarker1243"/>features of <code class="inlineCode">scipy</code> (in my opinion, at least) is <code class="inlineCode">scipy.sparse</code>. This module allows you to create sparse arrays, which can save you a huge amount of memory. While a <code class="inlineCode">numpy</code> array takes roughly the amount of memory you are reserving, the <code class="inlineCode">sparse</code> arrays only store the non-zero values or the non-zero blocks/rows/columns, depending on the type you choose. In the case of <code class="inlineCode">numpy</code>, storing 1 million 64-bit integers takes 64 million bits or 8 megabytes.</p>&#13;
    <p class="normal">Naturally, the advantage of a sparse array comes with a bunch of downsides, such as slower processing for certain operations or directions. The <code class="inlineCode">scipy.sparse.csc_matrix</code> method, for example, produces sparse matrices that are really fast to slice in the column direction, but slow when slicing rows. Meanwhile, <code class="inlineCode">scipy.sparse.csr_matrix</code> is the opposite.</p>&#13;
    <p class="normal">Usage of sparse arrays is roughly as straightforward as a <code class="inlineCode">numpy</code> array, but care has to be taken when selecting the specific sparse matrix type. The options are:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">bsr_matrix(arg1[, shape, dtype, copy, blocksize])</code>: Block Sparse Row matrix</li>&#13;
      <li class="bulletList"><code class="inlineCode">coo_matrix(arg1[, shape, dtype, copy])</code>: A sparse matrix in COOrdinate format.</li>&#13;
      <li class="bulletList"><code class="inlineCode">csc_matrix(arg1[, shape, dtype, copy])</code>: Compressed Sparse Column matrix</li>&#13;
      <li class="bulletList"><code class="inlineCode">csr_matrix(arg1[, shape, dtype, copy])</code>: Compressed Sparse Row matrix</li>&#13;
      <li class="bulletList"><code class="inlineCode">dia_matrix(arg1[, shape, dtype, copy])</code>: Sparse matrix with DIAgonal storage</li>&#13;
      <li class="bulletList"><code class="inlineCode">dok_matrix(arg1[, shape, dtype, copy])</code>: Dictionary Of Keys-based sparse matrix.</li>&#13;
      <li class="bulletList"><code class="inlineCode">lil_matrix(arg1[, shape, dtype, copy])</code>: Row-based List-Of-Lists sparse matrix</li>&#13;
    </ul>&#13;
    <p class="normal">If you only need something <a id="_idIndexMarker1244"/>like a large identity matrix, this can be extremely useful. It is easy to construct and takes very little memory. The following two matrices are identical in contents:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> numpy&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> scipy <span class="hljs-con-keyword">import</span> sparse&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> x = numpy.identity(<span class="hljs-con-number">10000</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> y = sparse.identity(<span class="hljs-con-number">10000</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> x.data.nbytes&#13;
800000000&#13;
&#13;
<span class="hljs-con-comment"># Summing the memory usage of scipy.sparse objects requires the summing</span>&#13;
<span class="hljs-con-comment"># of all internal arrays. We can test for these arrays using the</span>&#13;
<span class="hljs-con-comment"># nbytes attribute.</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> arrays = [a <span class="hljs-con-keyword">for</span> a <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">vars</span>(y).values() <span class="hljs-con-keyword">if</span> <span class="hljs-con-built_in">hasattr</span>(a, <span class="hljs-con-string">'nbytes'</span>)]&#13;
&#13;
<span class="hljs-con-comment"># Sum the bytes from all arrays</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">sum</span>(a.nbytes <span class="hljs-con-keyword">for</span> a <span class="hljs-con-keyword">in</span> arrays)&#13;
80004&#13;
</code></pre>&#13;
    <p class="normal">As you can see here, the non-sparse version of the identity matrix (<code class="inlineCode">x</code>) took 10,000 times more memory. In this case, it is 800 megabytes versus 80 kilobytes, but if you have a much larger matrix this quickly becomes impossible. Since the matrix grows in size quadratically (<code class="inlineCode">n^2</code>; the matrix above has size 10,000x10,000=100,000,000) this can make a very dramatic difference. The sparse matrix (in this case, at least) grows linearly (<code class="inlineCode">n</code>).</p>&#13;
    <p class="normal">For smaller non-sparse arrays (up to a billion numbers) the memory usage is still workable and it would take <a id="_idIndexMarker1245"/>about 8 gigabytes of memory for a billion 64-bit numbers, but when you go beyond that, most systems will quickly run out of memory. As is often the case, these memory savings do come at the cost of increased CPU time for many operations, so I would not recommend replacing all of your <code class="inlineCode">numpy</code> arrays with sparse arrays.</p>&#13;
    <p class="normal">In conclusion, <code class="inlineCode">scipy</code> is a versatile and very useful module that supports a wide variety of calculations and algorithms. If <code class="inlineCode">scipy</code> has an algorithm available for your goal, it is likely one of the fastest options you are going to find within the Python ecosystem. Many of the functions are very domain-specific, however, so you can probably guess which are (and are not) useful for you.</p>&#13;
    <h2 id="_idParaDest-431" class="heading-2">Pandas – Real-world data analysis</h2>&#13;
    <p class="normal">While the focus of <code class="inlineCode">numpy</code>, <code class="inlineCode">scipy</code>, and <code class="inlineCode">sympy</code> is mostly mathematical, Pandas is focused more on real-world data analysis. With Pandas, you are generally expected to load data from some external source such as databases or CSV files. Once you have the data loaded, you can easily calculate statistics, visualize the data, or combine the data with other datasets.</p>&#13;
    <p class="normal">To store data, Pandas offers two <a id="_idIndexMarker1246"/>different data structures. The <code class="inlineCode">pandas.Series</code> is a 1-dimensional array and the <code class="inlineCode">pandas.DataFrame</code> is a 2-dimensional matrix where the columns can be labeled if needed. Internally these objects wrap a <code class="inlineCode">numpy.ndarray</code>, so all <code class="inlineCode">numpy</code> operations are still possible on these objects as well.</p>&#13;
    <p class="normal">Why do we need<a id="_idIndexMarker1247"/> Pandas on top of <code class="inlineCode">numpy</code>? It all comes down to convenience, and Pandas offers several features on top of <code class="inlineCode">numpy</code> that are beneficial for doing real-world data analysis:</p>&#13;
    <ul>&#13;
      <li class="bulletList">It can gracefully handle missing data. Within a <code class="inlineCode">numpy</code> floating point number, you can store <code class="inlineCode">NaN</code> (not a number), but not all <code class="inlineCode">numpy</code> methods will handle that nicely without custom filtering.</li>&#13;
      <li class="bulletList">As opposed to the fixed-size <code class="inlineCode">numpy.ndarray</code>, columns can be added and removed to a <code class="inlineCode">numpy.DataFrame</code> as desired.</li>&#13;
      <li class="bulletList">It provides bundled data management functions to easily group, aggregate, or transform data. While you can easily modify <code class="inlineCode">numpy</code> data, grouping data is a lot harder out of the box.</li>&#13;
      <li class="bulletList">It also provides utility functions for data containing time series, allowing you to easily apply moving window statistics and compare newer to older data with very little effort.</li>&#13;
    </ul>&#13;
    <p class="normal">Let’s create a simple example that stores the release dates of major Python releases with their versions. The data is <a id="_idIndexMarker1248"/>sourced from Wikipedia, which has a nice table that we can quickly use and copy: <a href="https://en.wikipedia.org/wiki/History_of_Python#Table_of_versions"><span class="url">https://en.wikipedia.org/wiki/History_of_Python#Table_of_versions</span></a>.</p>&#13;
    <p class="normal">For brevity, we are showing a shortened version of the code here, but you can copy/paste the full table from Wikipedia or look in the GitHub project for this book.</p>&#13;
    <p class="normal">First, let’s read the data<a id="_idIndexMarker1249"/> into a dataframe:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># A commonly used shorthand for pandas is pd</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> re&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> io&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> pandas <span class="hljs-con-keyword">as</span> pd&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> data = <span class="hljs-con-string">'''</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-string">Version\tLatest micro version\tRelease date\tEnd of full support\tEnd ...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-string">0.9\t0.9.9[2]\t1991-02-20[2]\t1993-07-29[a][2]</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-string">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-string">3.9\t3.9.5[60]\t2020-10-05[60]\t2022-05[61]\t2025-10[60][61]</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-string">3.10\t\t2021-10-04[62]\t2023-05[62]\t2026-10[62]</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-string">'''</span>.strip()&#13;
&#13;
<span class="hljs-con-comment"># Slightly clean up data by removing references</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> data = re.sub(<span class="hljs-con-string">r'\[.+?\]'</span>, <span class="hljs-con-string">''</span>, data)&#13;
&#13;
<span class="hljs-con-comment"># df is often used as a shorthand for pandas.DataFrame</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> df = pd.read_table(io.StringIO(data))&#13;
</code></pre>&#13;
    <p class="normal">In this case, we have the entire table stored in <code class="inlineCode">data</code> as a tab-separated string. Since that includes the references that Wikipedia uses, we use a regular expression to clean up everything that looks like <code class="inlineCode">[...]</code>. Lastly, we read the data into a <code class="inlineCode">pandas.DataFrame</code> object using <code class="inlineCode">pandas.read_table()</code>. The <code class="inlineCode">read_table()</code> function supports either a filename or a file handle and, since we have the data as a string, we’re using <code class="inlineCode">io.StringIO()</code> to convert the string to a file handle.</p>&#13;
    <p class="normal">Now that we have the data, let’s see what we can do with it:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># List the columns</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> df.columns&#13;
Index(['Version', ..., 'Release date', ...], dtype='object')&#13;
<span class="hljs-con-comment"># List the versions:</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> df[<span class="hljs-con-string">'Version'</span>]&#13;
0     0.9&#13;
<span class="hljs-con-meta">...</span>&#13;
25    3.9&#13;
26    3.1&#13;
Name: Version, dtype: float64&#13;
&#13;
<span class="hljs-con-comment"># Oops... where did Python 3.10 go in the output above? The</span>&#13;
<span class="hljs-con-comment"># conversion to float trimmed the 0 so we need to disable that.</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> df = pd.read_table(io.StringIO(data), dtype=<span class="hljs-con-built_in">dict</span>(Version=<span class="hljs-con-built_in">str</span>))&#13;
&#13;
<span class="hljs-con-comment"># Much better, we didn't lose the version info this time</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> df[<span class="hljs-con-string">'Version'</span>]&#13;
0      0.9&#13;
<span class="hljs-con-meta">...</span>&#13;
25     3.9&#13;
26     3.10&#13;
Name: Version, dtype: object&#13;
</code></pre>&#13;
    <p class="normal">Now that we know how to <a id="_idIndexMarker1250"/>read the data from the table, let’s see how we can do something more useful with it. This time we are going to convert it into a time series so we can do analysis based on dates/times:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># The release date is read as a string by default, so we convert</span>&#13;
<span class="hljs-con-comment"># it to a datetime:</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> df[<span class="hljs-con-string">'Release date'</span>] = pd.to_datetime(df[<span class="hljs-con-string">'</span><span class="hljs-con-string">Release date'</span>])&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> df[<span class="hljs-con-string">'Release date'</span>]&#13;
0      1991-02-20&#13;
<span class="hljs-con-meta">...</span>&#13;
26     2021-10-04&#13;
Name: Release date, dtype: datetime64[ns]&#13;
&#13;
<span class="hljs-con-comment"># Let's see which month is the most popular for Python releases.</span>&#13;
<span class="hljs-con-comment"># First we run groupby() on the release month and after that we</span>&#13;
<span class="hljs-con-comment"># run a count() on the version:</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> df.groupby([df[<span class="hljs-con-string">'Release date'</span>].dt.month])[<span class="hljs-con-string">'Version'</span>].count()&#13;
Release date&#13;
1     2&#13;
2     2&#13;
3     1&#13;
4     2&#13;
6     3&#13;
7     1&#13;
9     4&#13;
10    8&#13;
11    1&#13;
12    3&#13;
Name: Version, dtype: int64&#13;
</code></pre>&#13;
    <p class="normal">While you could do all of this with plain <code class="inlineCode">numpy</code>, it is certainly much more convenient with <code class="inlineCode">pandas</code>.</p>&#13;
    <h3 id="_idParaDest-432" class="heading-3">Input and output options</h3>&#13;
    <p class="normal">One huge advantage of Pandas is the huge amount of readily available input and output options. Let’s start by saying that this list will never be complete because you can easily implement your own method, or install a library to handle other types for you. We will see an example of this later in this chapter when we cover <code class="inlineCode">xarray</code>.</p>&#13;
    <p class="normal">At the time of writing, the <code class="inlineCode">pandas</code> library natively supports a huge list of input<a id="_idIndexMarker1251"/> and/or <a id="_idIndexMarker1252"/>output formats:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Common formats such as Pickle, CSV, JSON, HTML, and XML</li>&#13;
      <li class="bulletList">Spreadsheets such as Excel files</li>&#13;
      <li class="bulletList">Data formats used by other statistical systems such as HDF5, Feather, Parquet, ORC, SAS, SPSS, and Stata</li>&#13;
      <li class="bulletList">Many types of databases using SQLAlchemy</li>&#13;
    </ul>&#13;
    <p class="normal">If your preferred format is not on the list, the odds are that you can easily find a converter for it. Alternatively, it is fairly easy to write a converter yourself as you can implement them in plain Python.</p>&#13;
    <h3 id="_idParaDest-433" class="heading-3">Pivoting and grouping</h3>&#13;
    <p class="normal">One very useful feature of Pandas is the ability to <strong class="keyWord">pivot</strong> and <strong class="keyWord">unpivot</strong> a DataFrame. When pivoting, we can convert rows to columns based on their values, effectively grouping them. The <code class="inlineCode">pandas</code> library has several options to pivot/unpivot your data:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">pivot</code>: Returns a <a id="_idIndexMarker1253"/>reshaped pivot table without aggregation (e.g. sum/count/etc.) support</li>&#13;
      <li class="bulletList"><code class="inlineCode">pivot_table</code>: Returns a pivot table with aggregation support</li>&#13;
      <li class="bulletList"><code class="inlineCode">melt</code>: Reverses the operation of <code class="inlineCode">pivot</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">wide_to_long</code>: A simpler <a id="_idIndexMarker1254"/>version of <code class="inlineCode">melt</code> that can be more convenient to use</li>&#13;
    </ul>&#13;
    <p class="normal">What can we achieve by pivoting? Let’s create a very simple example of some temperature measurements in a long list, and <a id="_idIndexMarker1255"/>pivot them so we get the days as columns instead of rows:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> pandas <span class="hljs-con-keyword">as</span> pd&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> numpy <span class="hljs-con-keyword">as</span> np&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> df = pd.DataFrame(<span class="hljs-con-built_in">dict</span>(&#13;
<span class="hljs-con-meta">...</span>     building=[<span class="hljs-con-string">'x'</span>, <span class="hljs-con-string">'x'</span>, <span class="hljs-con-string">'</span><span class="hljs-con-string">y'</span>, <span class="hljs-con-string">'x'</span>, <span class="hljs-con-string">'x'</span>, <span class="hljs-con-string">'y'</span>, <span class="hljs-con-string">'z'</span>, <span class="hljs-con-string">'z'</span>, <span class="hljs-con-string">'z'</span>],&#13;
<span class="hljs-con-meta">...</span>     rooms=[<span class="hljs-con-string">'a'</span>, <span class="hljs-con-string">'</span><span class="hljs-con-string">a'</span>, <span class="hljs-con-string">'a'</span>, <span class="hljs-con-string">'b'</span>, <span class="hljs-con-string">'b'</span>, <span class="hljs-con-string">'b'</span>, <span class="hljs-con-string">'c'</span>, <span class="hljs-con-string">'c'</span>, <span class="hljs-con-string">'c'</span>],&#13;
<span class="hljs-con-meta">...</span>     hours=[<span class="hljs-con-number">10</span>, <span class="hljs-con-number">11</span>, <span class="hljs-con-number">12</span>, <span class="hljs-con-number">10</span>, <span class="hljs-con-number">11</span>, <span class="hljs-con-number">12</span>, <span class="hljs-con-number">10</span>, <span class="hljs-con-number">11</span>, <span class="hljs-con-number">12</span>],&#13;
<span class="hljs-con-meta">...</span>     &#13;
<span class="hljs-con-meta">...</span>     temperatures=np.arange(<span class="hljs-con-number">0.0</span>, <span class="hljs-con-number">9.0</span>),&#13;
<span class="hljs-con-meta">...</span> ))&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> df&#13;
  building rooms  hours  temperatures&#13;
0        x     a     10           0.0&#13;
1        x     a     11           1.0&#13;
<span class="hljs-con-meta">...</span>&#13;
7        z     c     11           7.0&#13;
8        z     c     12           8.0&#13;
</code></pre>&#13;
    <p class="normal">The way this data is set up is similar to how a data logging tool would usually return it, with a single row for a single measurement. However, this is often not the most convenient way to read or analyze the data, and that is where pivoting can really help.</p>&#13;
    <p class="normal">Let’s look at the mean room temperature per hour:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> pd.pivot_table(&#13;
<span class="hljs-con-meta">...</span>     df, values=<span class="hljs-con-string">'temperatures'</span>, index=[<span class="hljs-con-string">'rooms'</span>],&#13;
<span class="hljs-con-meta">...</span>     columns=[<span class="hljs-con-string">'hours'</span>], aggfunc=np.mean)&#13;
hours   10   11   12&#13;
rooms&#13;
a      0.0  1.0  2.0&#13;
b      3.0  4.0  5.0&#13;
c      6.0  7.0  8.0&#13;
</code></pre>&#13;
    <p class="normal">That shows a row for each room and a column for each hour, with the values generated through <code class="inlineCode">numpy.mean()</code>.</p>&#13;
    <p class="normal">We can also<a id="_idIndexMarker1256"/> get the mean room<a id="_idIndexMarker1257"/> temperature per building, per room, per hour:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> pd.pivot_table(&#13;
<span class="hljs-con-meta">...</span>     df, values=<span class="hljs-con-string">'temperatures'</span>, index=[<span class="hljs-con-string">'building'</span>, <span class="hljs-con-string">'rooms'</span>],&#13;
<span class="hljs-con-meta">...</span>     columns=[<span class="hljs-con-string">'</span><span class="hljs-con-string">hours'</span>], aggfunc=np.mean)&#13;
hours            10   11   12&#13;
building rooms&#13;
x        a      0.0  1.0  NaN&#13;
         b      3.0  4.0  NaN&#13;
y        a      NaN  NaN  2.0&#13;
         b      NaN  NaN  5.0&#13;
z        c      6.0  7.0  8.0&#13;
</code></pre>&#13;
    <p class="normal">As you can see, <code class="inlineCode">pandas</code> handles missing values by showing <code class="inlineCode">NaN</code> for the missing data and gives us a very nice aggregate result.</p>&#13;
    <p class="normal">In addition to these pivoting features, Pandas provides a huge list of grouping functions that also allow you to aggregate results. The big advantage of the grouping feature over pivoting is that you can group over arbitrary ranges and functions. For time-based results, for example, you could choose to group per second, minute, hour, 5 minutes, or any other interval that might be useful to you.</p>&#13;
    <p class="normal">As a basic example with the data above:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> df.groupby(pd.Grouper(key=<span class="hljs-con-string">'hours'</span>)).mean()&#13;
       temperatures&#13;
hours&#13;
10              3.0&#13;
11              4.0&#13;
12              5.0&#13;
</code></pre>&#13;
    <p class="normal">This example already shows how the <code class="inlineCode">groupby</code> feature can be used, but the real power comes when combining it with timestamps. For instance, you could do <code class="inlineCode">pd.Grouper(freq='5min')</code>.</p>&#13;
    <h3 id="_idParaDest-434" class="heading-3">Merging</h3>&#13;
    <p class="normal">Another extremely useful feature of <a id="_idIndexMarker1258"/>Pandas is that you can merge data, similar to how you would join tables in a database. As is the case with pivoting, the <code class="inlineCode">pandas</code> library has several join methods:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">pandas.merge</code>: The <code class="inlineCode">merge</code> function is pretty much the straight equivalent of a database join. It can <a id="_idIndexMarker1259"/>do inner, outer, left, right, and cross joins, similar to many databases. Additionally, it can validate if the relations between the columns are correct (i.e. one-to-one, one-to-many, many-to-one, and many-to-many), in a similar way to how referential integrity in a database functions.</li>&#13;
      <li class="bulletList"><code class="inlineCode">pandas.merge_ordered</code>: Similar to <code class="inlineCode">merge</code> but allows for optional filling/interpolation <a id="_idIndexMarker1260"/>using a function.</li>&#13;
      <li class="bulletList"><code class="inlineCode">pandas.merge_asof</code>: This function does a left join on the nearest key instead of requiring an exact<a id="_idIndexMarker1261"/> match. </li>&#13;
    </ul>&#13;
    <p class="normal">The ability to easily merge multiple <code class="inlineCode">DataFrame</code> objects is a really powerful feature that is invaluable when processing real-world data. </p>&#13;
    <h3 id="_idParaDest-435" class="heading-3">Rolling or expanding windows</h3>&#13;
    <p class="normal">In Pandas, windows can help you to efficiently run calculations on rolling subsets of (expanding) data. Naively calculating is of course possible, but that can be highly inefficient and infeasible for larger datasets. With a <strong class="keyWord">rolling window</strong>, you can have a running mean, sum, or other function on a<a id="_idIndexMarker1262"/> fixed window size in an efficient manner. </p>&#13;
    <p class="normal">To illustrate, let’s assume you have an array with 100 items and you want to get the mean value using a window size of 10. The naïve solution would be to sum the first 10 items and divide them by 10, then repeat that for items 1 to 11, and so on.</p>&#13;
    <p class="normal">For each of these, you would have to walk through all 10 items in the window. If we take <code class="inlineCode">n</code> as the length of the array and <code class="inlineCode">w</code> as the size of the window, this takes <code class="inlineCode">O(n*w)</code> time. We can do much better if we keep track of the intermediate sum, however; if we simply add the next number and simultaneously remove the first number from our running sum, we can do the same in <code class="inlineCode">O(n)</code> instead. </p>&#13;
    <p class="normal">Let’s illustrate how <code class="inlineCode">pandas</code> can take care of this for us:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> pandas <span class="hljs-con-keyword">as</span> pd&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> numpy <span class="hljs-con-keyword">as</span> np&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> pd_series = pd.Series(np.arange(<span class="hljs-con-number">100</span>))  <span class="hljs-con-comment"># [0, 1, 2, ... 99]</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-comment"># Create a rolling window with size 10</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> window = pd_series.rolling(<span class="hljs-con-number">10</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-comment"># Calculate the running mean and ignore the N/A values at the</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-comment"># beginning before the window is full</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> window.mean().dropna()&#13;
9      4.5&#13;
10     5.5&#13;
      ...&#13;
99    94.5&#13;
Length: 91, dtype: float64&#13;
</code></pre>&#13;
    <p class="normal">The rolling window <a id="_idIndexMarker1263"/>as we have seen above supports functions for count, sum, mean, median, variance, standard deviation, quantiles, and several more. If you need something special, you can also provide your own function.</p>&#13;
    <p class="normal">There are a few extra features to these windows. Instead of having all items calculated with the same weight, you can also <a id="_idIndexMarker1264"/>use <strong class="keyWord">weighted windows</strong> to vary the weight of the items so recent data becomes more relevant than older data. In addition to regular weighted windows, you can also opt for <strong class="keyWord">exponentially weighted windows</strong> to<a id="_idIndexMarker1265"/> increase the effect even further.</p>&#13;
    <p class="normal">Lastly, we also have <strong class="keyWord">expanding windows</strong>. With these, you get the result from the beginning of the dataset up to<a id="_idIndexMarker1266"/> your current point. If you were to sum a series with values <code class="inlineCode">1, 2, 3, 4, 5</code>, it would return <code class="inlineCode">1, 3, 6, 10, 15</code>, with each item being the total sum from the beginning of the series up to that point.</p>&#13;
    <p class="normal">To conclude, the <code class="inlineCode">pandas</code> library is extremely useful for analyzing data from varying sources. Since it was built on top of <code class="inlineCode">numpy</code> it is also extremely fast, which makes it very convenient for in-depth analysis.</p>&#13;
    <p class="normal">If you ever have a large amount of data to process, or data from several different sources, give <code class="inlineCode">pandas</code> a try and see if it can help you to sort it out.</p>&#13;
    <h2 id="_idParaDest-436" class="heading-2">Statsmodels – Statistical models on top of Pandas</h2>&#13;
    <p class="normal">Similar to how <code class="inlineCode">scipy</code> builds on top of <code class="inlineCode">numpy</code>, we have <code class="inlineCode">statsmodels</code> that builds on top of <code class="inlineCode">pandas</code>. Initially, it was part of the <code class="inlineCode">scipy</code> package, but later split off and greatly improved.</p>&#13;
    <p class="normal">The <code class="inlineCode">statsmodels</code> library<a id="_idIndexMarker1267"/> offers a host of statistical methods and plotting tools and can be used to create regression models, choice models, analysis of variance (ANOVA), forecasting, and more.</p>&#13;
    <p class="normal">A quick example of a weighted least squares regression, which attempts to fit a line to a set of data points, can be applied like this:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># The common shorthand for statsmodels is sm</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> statsmodels.api <span class="hljs-con-keyword">as</span> sm&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> numpy <span class="hljs-con-keyword">as</span> np&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Y = np.arange(<span class="hljs-con-number">8</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> X = np.ones(<span class="hljs-con-number">8</span>)&#13;
&#13;
<span class="hljs-con-comment"># Create the weighted-least-squares model</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> model = sm.WLS(Y, X)&#13;
&#13;
<span class="hljs-con-comment"># Fit the model and generate the regression results</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> fit = model.fit()&#13;
&#13;
<span class="hljs-con-comment"># Show the estimated parameters and the t-values:</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> fit.params&#13;
array([3.5])&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> fit.tvalues&#13;
array([4.04145188])&#13;
</code></pre>&#13;
    <p class="normal">While it still requires some background knowledge about statistics to be able to apply this properly, it does show how easily you can do a regression with <code class="inlineCode">statsmodels</code>.</p>&#13;
    <p class="normal">An abbreviated list of the models and analysis types that are currently supported by <code class="inlineCode">statmodels</code> from the <code class="inlineCode">statsmodels</code> manual follows.</p>&#13;
    <p class="normal">Regression and linear models:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Linear regression</li>&#13;
      <li class="bulletList">Generalized linear models</li>&#13;
      <li class="bulletList">Generalized estimating equations</li>&#13;
      <li class="bulletList">Generalized additive models (GAMs)</li>&#13;
      <li class="bulletList">Robust linear models</li>&#13;
      <li class="bulletList">Linear mixed effects models</li>&#13;
      <li class="bulletList">Regression with discrete dependent variable</li>&#13;
      <li class="bulletList">Generalized linear mixed effects models</li>&#13;
      <li class="bulletList">ANOVA</li>&#13;
    </ul>&#13;
    <p class="normal">Time series analysis:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Generic time series analysis such as univariate and vector autoregressive models (ARs/VARs)</li>&#13;
      <li class="bulletList">Time series analysis by state space methods</li>&#13;
      <li class="bulletList">Vector autoregressions</li>&#13;
    </ul>&#13;
    <p class="normal">Other models:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Methods for survival and duration analysis</li>&#13;
      <li class="bulletList">Nonparametric methods</li>&#13;
      <li class="bulletList">Generalized method of moments</li>&#13;
      <li class="bulletList">Multivariate statistics</li>&#13;
    </ul>&#13;
    <p class="normal">The actual list of supported <a id="_idIndexMarker1268"/>features is quite a bit longer, but this should give you a good indication as to whether it is a useful library for you. If you are familiar with statistical models, you should be able to get started with <code class="inlineCode">statsmodels</code> rather quickly and the package is well documented with great examples.</p>&#13;
    <h2 id="_idParaDest-437" class="heading-2">xarray – Labeled arrays and datasets</h2>&#13;
    <p class="normal">The <code class="inlineCode">xarray</code> library<a id="_idIndexMarker1269"/> is very similar to <code class="inlineCode">pandas</code> and is also built on top of <code class="inlineCode">numpy</code>. The main differences are that <code class="inlineCode">xarray</code> is multi-dimensional, whereas <code class="inlineCode">pandas</code> supports one-dimensional <a id="_idIndexMarker1270"/>and two-dimensional data only, and it was created with the <strong class="keyWord">netCDF</strong> (<strong class="keyWord">Network Common Data Form</strong>) formats in mind. The netCDF formats are commonly used for scientific research data, which (as opposed to CSV files, for example) contain both the data and metadata such as variable labels, data descriptions, and documentation, allowing for easy use in a multitude of software.</p>&#13;
    <p class="normal">The <code class="inlineCode">xarray</code> library can easily work together with <code class="inlineCode">pandas</code>, so for this example, we will re-use the data from our earlier <code class="inlineCode">pandas</code> example. The other way around is also easily possible using the <code class="inlineCode">to_dataframe()</code> method on an <code class="inlineCode">xarray.DataArray</code> object (the standard <code class="inlineCode">xarray</code> matrix object). In this example, we will assume that you still have the <code class="inlineCode">df</code> variable available from the <code class="inlineCode">pandas</code> example earlier:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># The common shorthand for xarray is xr</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> xarray <span class="hljs-con-keyword">as</span> xr&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ds = xr.Dataset.from_dataframe(df)&#13;
&#13;
<span class="hljs-con-comment"># For reference, the pandas version of the groupby</span>&#13;
<span class="hljs-con-comment"># df.groupby([df['Release date'].dt.month])['Version'].count()</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ds.groupby(<span class="hljs-con-string">'Release date.month'</span>).count()[<span class="hljs-con-string">'Version'</span>]&#13;
&#13;
&lt;xarray.DataArray 'Version' (month: 10)&gt;&#13;
array([2, 2, 1, 2, 3, 1, 4, 8, 1, 3])&#13;
Coordinates:&#13;
  * month    (month) int64 1 2 3 4 6 7 9 10 11 12&#13;
</code></pre>&#13;
    <p class="normal">The syntax for the <code class="inlineCode">groupby()</code> is slightly different from <code class="inlineCode">pandas</code>, and less Pythonic (if you ask me) due to the use of strings over variables, but it essentially comes down to the same operation.</p>&#13;
    <div class="note">&#13;
      <p class="normal">In the <code class="inlineCode">pandas</code> version, the order of the <code class="inlineCode">count()</code> and the <code class="inlineCode">['Version']</code> can be swapped to be even more similar. That is, the following is also valid and returns the same results:</p>&#13;
      <pre class="programlisting code"><code class="hljs-code">df.groupby([df[<span class="hljs-string">'Release date'</span>].dt.month]).count()[<span class="hljs-string">'Version'</span>]&#13;
</code></pre>&#13;
    </div>&#13;
    <p class="normal">Additionally, for this use <a id="_idIndexMarker1271"/>case, I would argue that the output of <code class="inlineCode">xarray</code> is not all that readable, but it certainly isn’t bad either. Often, you will have so many data points that you won’t be too interested in the raw data anyway.</p>&#13;
    <p class="normal">The real advantage to <code class="inlineCode">xarray</code> over <code class="inlineCode">pandas</code> (in my opinion, at least) is the support for multi-dimensional data. You can add as much as you want to the <code class="inlineCode">Dataset</code> object:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> xarray <span class="hljs-con-keyword">as</span> xr&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> numpy <span class="hljs-con-keyword">as</span> np&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> points = np.arange(<span class="hljs-con-number">27</span>).reshape((<span class="hljs-con-number">3</span>, <span class="hljs-con-number">3</span>, <span class="hljs-con-number">3</span>))&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> triangles = np.arange(<span class="hljs-con-number">27</span>).reshape((<span class="hljs-con-number">3</span>, <span class="hljs-con-number">3</span>, <span class="hljs-con-number">3</span>))&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ds = xr.Dataset(<span class="hljs-con-built_in">dict</span>(&#13;
<span class="hljs-con-meta">...</span>     triangles=([<span class="hljs-con-string">'p0'</span>, <span class="hljs-con-string">'p1'</span>, <span class="hljs-con-string">'p2'</span>], triangles),&#13;
<span class="hljs-con-meta">...</span> ), coords=<span class="hljs-con-built_in">dict</span>(&#13;
<span class="hljs-con-meta">...</span>     points=([<span class="hljs-con-string">'x'</span>, <span class="hljs-con-string">'y'</span>, <span class="hljs-con-string">'z'</span>], points),&#13;
<span class="hljs-con-meta">...</span> ))&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ds&#13;
&lt;xarray.Dataset&gt;&#13;
Dimensions:    (p0: 3, p1: 3, p2: 3, x: 3, y: 3, z: 3)&#13;
Coordinates:&#13;
    points     (x, y, z) int64 0 1 2 3 4 5 ... 21 22 23 24 25 26&#13;
Dimensions without coordinates: p0, p1, p2, x, y, z&#13;
Data variables:&#13;
    triangles  (p0, p1, p2) int64 0 1 2 3 4 ... 21 22 23 24 25 26&#13;
</code></pre>&#13;
    <p class="normal">In this case, we only added the <code class="inlineCode">triangles</code> and the <code class="inlineCode">points</code>, but you can add as much as you want and you can use <code class="inlineCode">xarray</code> to combine these so you can reference multi-dimensional objects easily. Data combination can be achieved through several methods such as concatenation, merging to combine multiple datasets into one, combining based on field values, through per-row updates, and others.</p>&#13;
    <p class="normal">When it comes <a id="_idIndexMarker1272"/>down to <code class="inlineCode">pandas</code> versus <code class="inlineCode">xarray</code>, I would recommend simply giving them both a try and seeing which is more convenient for your use case. The libraries are very similar in features and usability and both have their own advantages. The multi-dimensionality of <code class="inlineCode">xarray</code> is a huge advantage over <code class="inlineCode">pandas</code> if you need it, however.</p>&#13;
    <p class="normal">If it’s all the same to you then I would currently recommend <code class="inlineCode">pandas</code> over <code class="inlineCode">xarray</code>, simply because it is currently the most used of the two, which results in more documentation/blog posts/books being available.</p>&#13;
    <h2 id="_idParaDest-438" class="heading-2">STUMPY – Finding patterns in time series</h2>&#13;
    <p class="normal">The <code class="inlineCode">stumpy</code> library offers<a id="_idIndexMarker1273"/> several tools to automatically detect patterns and anomalies in your time series matrices. It is built upon <code class="inlineCode">numpy</code>, <code class="inlineCode">scipy</code>, and <code class="inlineCode">numba</code> to provide great performance and gives you the possibility of employing GPU (video card) power as well, to process the data even faster.</p>&#13;
    <p class="normal">Using <code class="inlineCode">stumpy</code> you could, for example, automatically detect if a website is getting an abnormal number of visitors. One of the nice features of <code class="inlineCode">stumpy</code> in this scenario is that, in addition to static matrices, you can also add more data in a streaming way, which allows you to do real-time analysis without too much overhead.</p>&#13;
    <p class="normal">As an example, let’s assume we have a list of temperatures for a living room thermostat and see if we can find any repeating patterns:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> numpy <span class="hljs-con-keyword">as</span> np&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> stumpy&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> temperatures = np.array([<span class="hljs-con-number">22.</span>, <span class="hljs-con-number">21.</span>, <span class="hljs-con-number">22.</span>, <span class="hljs-con-number">21.</span>, <span class="hljs-con-number">22.</span>, <span class="hljs-con-number">23.</span>])&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> window_size = <span class="hljs-con-number">3</span>&#13;
&#13;
<span class="hljs-con-comment"># Calculate a Euclidean distance matrix between the windows</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> stump = stumpy.stump(temperatures, window_size)&#13;
&#13;
<span class="hljs-con-comment"># Show the distance matrix. The row number is the index in the</span>&#13;
<span class="hljs-con-comment"># input array. The first column is the distance; the next columns</span>&#13;
<span class="hljs-con-comment"># are the indices of the nearest match, the left match, and the</span>&#13;
<span class="hljs-con-comment"># right match.</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> stump&#13;
array([[0.0, 2, -1, 2],&#13;
      [2.449489742783178, 3, -1, 3],&#13;
      [0.0, 0, 0, -1],&#13;
      [2.449489742783178, 1, 1, -1]], dtype=object)&#13;
&#13;
<span class="hljs-con-comment"># As we can see in the matrix above, the first window has a</span>&#13;
<span class="hljs-con-comment"># distance of 0 to the window at index 2, meaning that they are</span>&#13;
<span class="hljs-con-comment"># identical. We can easily verify that by showing both windows:</span>&#13;
&#13;
<span class="hljs-con-comment"># The first window:</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> temperatures[<span class="hljs-con-number">0</span>:window_size]&#13;
array([22., 21., 22.])&#13;
&#13;
<span class="hljs-con-comment"># The window at index 2:</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> temperatures[<span class="hljs-con-number">2</span>:<span class="hljs-con-number">2</span> + window_size]&#13;
array([22., 21., 22.])&#13;
</code></pre>&#13;
    <p class="normal">The observant among <a id="_idIndexMarker1274"/>you may have noticed that this distance matrix only has <code class="inlineCode">4</code> rows for <code class="inlineCode">6</code> values instead of the traditional <code class="inlineCode">n*n</code> (<code class="inlineCode">6*6</code> in this case) distance matrix. This is in part because we use a window size of <code class="inlineCode">3</code> and we only look at the number of windows (which is <code class="inlineCode">n-window_size+1=4</code>). A larger part is due to <code class="inlineCode">stumpy</code> storing only the closest pairs, resulting in only requiring <code class="inlineCode">O(n)</code> space instead of the normal <code class="inlineCode">O(n*n)</code>.</p>&#13;
    <p class="normal">While you can do these types of analysis with plain <code class="inlineCode">numpy</code> as well, <code class="inlineCode">stumpy</code> uses a very smart algorithm and relies heavily on <code class="inlineCode">numba</code> for faster processing, so if you can use the library, I would recommend it.</p>&#13;
    <h1 id="_idParaDest-439" class="heading-1">Mathematics and precise calculations</h1>&#13;
    <p class="normal">Python has a decent number of mathematical functions and features built in, but there are cases where you need more advanced features or something faster. In this section, we will discuss a few libraries that help by introducing many extra mathematical functions and/or increase mathematical precision<a id="_idIndexMarker1275"/> and/or performance quite a bit.</p>&#13;
    <p class="normal">First, let’s discuss the options in the Python core libraries to store numbers and perform calculations with varying precision:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">int</code>: To store whole numbers (e.g. <code class="inlineCode">1, 2, 3</code>), we have the <code class="inlineCode">int</code> object in Python. The <code class="inlineCode">int</code> is<a id="_idIndexMarker1276"/> directly translated into a C <code class="inlineCode">int64</code> on most systems as long as it can fit within 64-bit. Outside of that, it is internally cast to a Python <code class="inlineCode">long</code> type (not to be confused with a C <code class="inlineCode">long</code>), which can be arbitrarily large. This allows for infinite accuracy but only works as long as you use whole numbers.</li>&#13;
      <li class="bulletList"><code class="inlineCode">fractions.Fraction</code>: The <code class="inlineCode">Fraction</code> object makes it possible to store fractional numbers (for example, <code class="inlineCode">1/2</code>, <code class="inlineCode">1/3</code>, <code class="inlineCode">2/3</code>) and they are infinitely precise since they rely on two <code class="inlineCode">int</code> (or <code class="inlineCode">long</code>) objects internally as the denominator and <a id="_idIndexMarker1277"/>the numerator. However, these only work if the number you are trying to store can be represented as a fraction. Irrational numbers such as Pi cannot be represented this way.</li>&#13;
      <li class="bulletList"><code class="inlineCode">float</code>: Floating point <a id="_idIndexMarker1278"/>numbers make it really easy to store numbers that include decimals (for example <code class="inlineCode">1.23</code>, <code class="inlineCode">4.56</code>). These numbers are generally stored as a 64-bit floating point, which is a combination of a sign (1 bit positive or negative), exponent (11 bits), and a fraction (52 bits), resulting in the following equation:<img src="Images/B15882_15_002.png" alt="" style="height: 1.6em !important;" width="329" height="25"/> . This means that a number such as 0.5 is stored using fraction 0 and exponent -1, resulting in: <img src="Images/B15882_15_003.png" alt="" style="height: 1.2em !important;" width="125" height="21"/> . In the case of 0.5, this can be stored perfectly; in many other cases, this is problematic because not every number can be accurately described like this, which causes floating point inaccuracies.</li>&#13;
      <li class="bulletList"><code class="inlineCode">decimal.Decimal</code>: The <code class="inlineCode">Decimal</code> object allows for calculations with an arbitrary but specified <a id="_idIndexMarker1279"/>precision. You can choose how many decimals you want, but it is not all that fast.</li>&#13;
    </ul>&#13;
    <p class="normal">Several of the following libraries offer solutions to enhance the precision of your calculations.</p>&#13;
    <h2 id="_idParaDest-440" class="heading-2">gmpy2 – Fast and precise calculations</h2>&#13;
    <p class="normal">The <code class="inlineCode">gmpy2</code> library<a id="_idIndexMarker1280"/> uses libraries that are written in C for really fast high-precision calculations. On Linux/Unix systems it will rely on GMP (hence the name); on Windows it will use MPIR, which is based on GMP. Additionally, the MPFR and MPC libraries are used for correctly rounding floating point real and complex numbers respectively. Lastly, it uses <code class="inlineCode">mpz_lucas</code> and <code class="inlineCode">mpz_prp</code> for really fast primality testing.</p>&#13;
    <p class="normal">Here’s a tiny example on how to get Pi to 1000 places, which you can’t easily do with the Python core library:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> gmpy2&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> gmpy2.const_pi(<span class="hljs-con-number">1000</span>)&#13;
mpfr('3.14159265358979...33936072602491412736',1000)&#13;
</code></pre>&#13;
    <p class="normal">This library is invaluable if you need fast and high-precision calculations.</p>&#13;
    <div class="packt_tip">&#13;
      <p class="normal">For my personal use case, the <code class="inlineCode">gmpy</code> library (<code class="inlineCode">gmpy2</code> didn’t exist yet at that time) has been extremely helpful when competing in the fun online math challenge project called <a id="_idIndexMarker1281"/>Project Euler: <a href="https://projecteuler.net/"><span class="url">https://projecteuler.net/</span></a>.</p>&#13;
    </div>&#13;
    <h2 id="_idParaDest-441" class="heading-2">Sage – An alternative to Mathematica/Maple/MATLAB</h2>&#13;
    <p class="normal">If you have ever taken an advanced math class in college or university, chances are that you have encountered software such as Mathematica, Maple, MATLAB, or Magma. Or perhaps you have used WolframAlpha, which is built on Mathematica. The Sage project is meant as a free and <a id="_idIndexMarker1282"/>open source alternative to those really expensive software packages.</p>&#13;
    <div class="note">&#13;
      <p class="normal">For reference, at the time of writing, the basic Mathematica Home edition, which can only run at 4 CPU cores at the same time, costs 413 euros (487 US dollars).</p>&#13;
    </div>&#13;
    <p class="normal">The Sage<a id="_idIndexMarker1283"/> package can be used to solve equations both numerically and exactly, plot charts, and perform many other tasks from the Sage interpreter. Similar to IPython and Jupyter, Sage offers its own interpreter with a custom language so it feels closer to mathematical packages such as Mathematica. Naturally, you could import the Sage code from regular Python as well.</p>&#13;
    <p class="normal">A small example of solving for a variable using Sage with the Sage interpreter:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">sage: x, y, z = var('x, y, z')&#13;
sage: solve([x + y == 10, x - y == 5, x + y + z == 1], x, y, z)&#13;
[[x == (15/2), y == (5/2), z == -9]]&#13;
</code></pre>&#13;
    <p class="normal">In this case, we asked Sage to solve an equation with three variables for us given the following constraints:</p>&#13;
    <p class="center"><img src="Images/B15882_15_004.png" alt="" width="96" height="25"/></p>&#13;
     <p class="center"><img src="Images/B15882_15_005.png" alt="" width="83" height="25"/></p>&#13;
      <p class="center"><img src="Images/B15882_15_006.png" alt="" width="117" height="25"/></p>&#13;
    &#13;
    <p class="normal">According to Sage (correctly), this results in:</p>&#13;
    <p class="center"><img src="Images/B15882_15_007.png" alt="" style="height: 2.9em !important;" width="190" height="46"/></p>&#13;
    <p class="normal">If you are looking for a full-fledged mathematical software system (or some features of one), Sage is a good option.</p>&#13;
    <h2 id="_idParaDest-442" class="heading-2">mpmath – Convenient, precise calculations</h2>&#13;
    <p class="normal">The <code class="inlineCode">mpmath</code> library<a id="_idIndexMarker1284"/> is an all-round mathematical library offering functions for trigonometry, calculus, matrices, and many others while still maintaining a configurable precision.</p>&#13;
    <p class="normal">Installing <code class="inlineCode">mpmath</code> is really easy since it is pure Python and has no required dependencies, but it does offer speedups using Sage and <code class="inlineCode">gmpy2</code> if they are available. This combines the benefits of the Sage and <code class="inlineCode">gmpy2</code> libraries for speed with the convenience of a pure Python installation if those are not available.</p>&#13;
    <p class="normal">Let’s illustrate the advantages of configurable precision versus regular floating point numbers in Python:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> N = <span class="hljs-con-number">10</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> x = <span class="hljs-con-number">0.1</span>&#13;
&#13;
<span class="hljs-con-comment"># Regular addition</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a = <span class="hljs-con-number">0.0</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> _ <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(N):&#13;
<span class="hljs-con-meta">...</span>     a += x  &#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a&#13;
0.9999999999999999&#13;
&#13;
<span class="hljs-con-comment"># Using sum, the same result as addition</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">sum</span>(x <span class="hljs-con-keyword">for</span> _ <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(N))&#13;
0.9999999999999999&#13;
</code></pre>&#13;
    <p class="normal">As you can see, both regular addition and <code class="inlineCode">sum()</code> are both inaccurate. Python does have a better method available for this specific problem:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># Sum using Python's optimized fsum:</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> math&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> math.fsum(x <span class="hljs-con-keyword">for</span> _ <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(N))&#13;
1.0&#13;
</code></pre>&#13;
    <p class="normal">When it comes to the general case, however, floating point math will always be inaccurate and at times that can be problematic. So, if your calculations do require floating point math but you want more accuracy, <code class="inlineCode">mpmath</code> can help you:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> mpmath&#13;
&#13;
<span class="hljs-con-comment"># Increase the mpmath precision to 100 decimal places</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> mpmath.mp.dps = <span class="hljs-con-number">100</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> y = mpmath.mpf(<span class="hljs-con-string">'0.1'</span>)&#13;
&#13;
<span class="hljs-con-comment"># Using mpmath with addition:</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b = mpmath.mpf(<span class="hljs-con-string">'0.0'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> _ <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(N):&#13;
<span class="hljs-con-meta">...</span>     b += y&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b&#13;
mpf('1.00000000000000000000000000...00000000000000000000000014')&#13;
&#13;
<span class="hljs-con-comment"># Or a regular sum with mpmath:</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">sum</span>(y <span class="hljs-con-keyword">for</span> _ <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(N))&#13;
mpf('1.00000000000000000000000000...00000000000000000000000014')&#13;
</code></pre>&#13;
    <p class="normal">While these results are obviously still not perfect (you would assume the result to be 1.0, like what <code class="inlineCode">math.fsum()</code> produced), it can help to reduce floating point errors a lot more. Make<a id="_idIndexMarker1285"/> sure to feed <code class="inlineCode">mpmath</code> strings or integers, otherwise your variable can already introduce floating point errors. If we had used <code class="inlineCode">x</code> in the sum instead of <code class="inlineCode">y</code>, it would have resulted in floating point inaccuracy similar to regular Python math.</p>&#13;
    <p class="normal">Naturally, <code class="inlineCode">fpmath</code> can do a lot more than simply reduce your floating point errors, such as plotting and calculus, but I will leave that for you to explore. If you are looking for solutions to mathematical problems, this library should be on your list.</p>&#13;
    <h2 id="_idParaDest-443" class="heading-2">SymPy – Symbolic mathematics</h2>&#13;
    <p class="normal">The <code class="inlineCode">sympy</code> module<a id="_idIndexMarker1286"/> is a library that you might never need, but it is such a great library that it should be covered. The goal of <code class="inlineCode">sympy</code> is to be a fully featured <strong class="keyWord">Computer Algebra System</strong> (<strong class="keyWord">CAS</strong>) so you<a id="_idIndexMarker1287"/> can manipulate mathematical expressions similar to how you would do so on paper. </p>&#13;
    <p class="normal">Let’s start with a little demo on how we can express and solve an integral using <code class="inlineCode">sympy</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> sympy <span class="hljs-con-keyword">import</span> *&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> init_printing(use_unicode=<span class="hljs-con-literal">True</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> x, y, z = symbols(<span class="hljs-con-string">'x y z'</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> integral = Integral(x * cos(x), x)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> integral&#13;
⌠&#13;
| x cos(x) dx&#13;
⌡&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> integral.doit()&#13;
x sin(x) + cos(x)&#13;
</code></pre>&#13;
    <p class="normal">Apologies if this gave you horrible flashbacks to some calculus exam, but I think it is amazing to be able to do this. This code first imports <code class="inlineCode">sympy</code> using a wildcard because the equations would quickly become unreadable if all functions needed to be prefixed by <code class="inlineCode">sympy</code>.</p>&#13;
    <p class="normal">After that, we<a id="_idIndexMarker1288"/> use the <code class="inlineCode">init_printing()</code> function with the Unicode flag enabled to tell <code class="inlineCode">sympy</code> that our shell supports Unicode characters. This allows for pretty rendering of many mathematical formulas, but certainly not all of them. The alternatives to this are basic ASCII rendering (as you can imagine, this does not look too pretty for an integral), and LaTeX output, which can render as images (for example, when using Jupyter). There are actually several other rendering modes available, but they greatly depend on your environment so we will not be getting into those.</p>&#13;
    <p class="normal">Because you can use any variable name in an equation, we need to specifically declare <code class="inlineCode">x</code>, <code class="inlineCode">y</code>, and <code class="inlineCode">z</code> as variables. Even though we only use <code class="inlineCode">x</code> in this case, you will often need the others as well, so why not declare them in advance?</p>&#13;
    <p class="normal">Now we use the <code class="inlineCode">Integral</code> function to declare the integral. Due to font limitations, the example above is not perfect, but the rendered integral should look like this in your shell or browser:</p>&#13;
    <p class="center"><img src="Images/B15882_15_008.png" alt="" style="height: 3em !important;" width="102" height="46"/></p>&#13;
    <p class="normal">Lastly, we tell <code class="inlineCode">sympy</code> to solve the integral using the <code class="inlineCode">doit()</code> method. This correctly results in the equation:</p>&#13;
    <p class="center"><img src="Images/B15882_15_009.png" alt="" style="height: 1.6em !important;" width="121" height="21"/></p>&#13;
    <p class="normal">The only nitpick I have here is that <code class="inlineCode">sympy</code> omits the integration constant by default. Ideally, it would include the <code class="inlineCode">+ C</code>.</p>&#13;
    <p class="normal">If you’re looking to represent (and solve) an equation, <code class="inlineCode">sympy</code> can certainly help. I personally think it is a really great library even though I have very little use for it.</p>&#13;
    <h2 id="_idParaDest-444" class="heading-2">Patsy – Describing statistical models </h2>&#13;
    <p class="normal">Similar to how <code class="inlineCode">sympy</code> can describe mathematical formulas in Python, <code class="inlineCode">patsy</code> can describe statistical models, which<a id="_idIndexMarker1289"/> makes it go hand in hand with the <code class="inlineCode">statsmodels</code> package. It can also use regular Python functions or directly apply <code class="inlineCode">numpy</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> patsy&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> numpy <span class="hljs-con-keyword">as</span> np&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> array = np.arange(<span class="hljs-con-number">2</span>, <span class="hljs-con-number">6</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> data = <span class="hljs-con-built_in">dict</span>(a=array, b=array, c=array)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> patsy.dmatrix(<span class="hljs-con-string">'a + np.square(b) + np.power(c, 3)'</span>, data)&#13;
DesignMatrix with shape (4, 4)&#13;
  Intercept  a  np.square(b)  np.power(c, 3)&#13;
          1  2             4               8&#13;
          1  3             9              27&#13;
          1  4            16              64&#13;
          1  5            25             125&#13;
  Terms:&#13;
    'Intercept' (column 0)&#13;
    'a' (column 1)&#13;
    'np.square(b)' (column 2)&#13;
    'np.power(c, 3)' (column 3)&#13;
</code></pre>&#13;
    <p class="normal">In this example, we created a <code class="inlineCode">numpy</code> array with a range from 2 to 6 and passed this to the <code class="inlineCode">patsy.dmatrix()</code> function under the names <code class="inlineCode">a</code>, <code class="inlineCode">b</code>, and <code class="inlineCode">c</code>, since duplicate names will be ignored. After that, we created the matrix using <code class="inlineCode">patsy</code>; as you can see, the <code class="inlineCode">+</code> in the <code class="inlineCode">patsy</code> language tells it to add a new column. Those columns can be plain columns such as <code class="inlineCode">a</code>, but they can also call functions such as <code class="inlineCode">np.square(b)</code>.</p>&#13;
    <p class="normal">If you are familiar with the mathematics behind vectors and matrices, this library might feel very natural to you. At the very least, it can be a slightly more obvious way to declare how your data interacts.</p>&#13;
    <h1 id="_idParaDest-445" class="heading-1">Plotting, graphing, and charting</h1>&#13;
    <p class="normal">Being able to read, process, and write data is important, of course, but to understand the meaning of data it is often far more convenient to create a plot, graph, or chart. As the old adage goes: “A picture is worth a thousand words.”</p>&#13;
    <p class="normal">If you have<a id="_idIndexMarker1290"/> experience with any of the libraries mentioned earlier in this chapter, you may know that many of them have options for graphical output. In (almost?) all cases, however, this is not really a built-in feature but a convenient shortcut to an external library<a id="_idIndexMarker1291"/> such as <code class="inlineCode">matplotlib</code>.</p>&#13;
    <p class="normal">As is the case with <a id="_idIndexMarker1292"/>several of the libraries mentioned in this chapter, there are multiple libraries with similar features and possibilities, so this is certainly not an exhaustive list. To make visual plotting easier, for these examples we will mostly rely on <code class="inlineCode">jupyter-notebook</code> with the use of the <code class="inlineCode">ipywidgets</code> to create interactive samples. As always, the code (in these cases, the <code class="inlineCode">jupyter-notebooks</code>) can be found on GitHub at <a href="https://github.com/mastering-python/code_2"><span class="url">https://github.com/mastering-python/code_2</span></a>.</p>&#13;
    <h2 id="_idParaDest-446" class="heading-2">Matplotlib</h2>&#13;
    <p class="normal">The <code class="inlineCode">matplotlib</code> library<a id="_idIndexMarker1293"/> is the reliable standard for plotting and is supported by many of the scientific libraries in this chapter.</p>&#13;
    <p class="normal">Most of the libraries mentioned earlier in this chapter either explain how <code class="inlineCode">matplotlib</code> can be used with the library, or even have utility functions to facilitate plotting with <code class="inlineCode">matplotlib</code>.</p>&#13;
    <p class="normal">Does this mean that the <code class="inlineCode">matplotlib</code> library is the gold standard for plotting? As usual, it depends. While <code class="inlineCode">matplotlib</code> is certainly the most used scientific plotting Python library with a huge array of features, it is not always the most beautiful option. That doesn’t mean you cannot configure it to be pretty, but out of the box, the library focuses on easy-to-read, consistent results and works for everyone and all scenarios. Some of the prettier libraries might look fantastic on a web page and have very useful interactive features but are not that suited for publishing and printing. </p>&#13;
    <p class="normal">The basic example is trivially easy:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># The common shorthand for pyplot is plt</span>&#13;
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt&#13;
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np&#13;
&#13;
<span class="hljs-comment"># Enable in-line rendering for the Jupyter notebook</span>&#13;
%matplotlib inline&#13;
&#13;
a = np.arange(<span class="hljs-number">100</span>) ** <span class="hljs-number">2</span>&#13;
plt.plot(a)&#13;
</code></pre>&#13;
    <p class="normal">Effectively, we only need <code class="inlineCode">plt.plot()</code> to plot a basic chart:</p>&#13;
    <figure class="mediaobject"><img src="Images/B15882_15_01.png" alt="" width="618" height="377"/></figure>&#13;
    <p class="packt_figref">Figure 15.1: Matplotlib plot</p>&#13;
    <p class="normal">This simple example <a id="_idIndexMarker1294"/>was very easy to plot, but <code class="inlineCode">matplotlib</code> can do so much more. Let’s take a look at how we can combine a few graphs and make the plot interactive using <code class="inlineCode">ipywidgets</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">%matplotlib notebook&#13;
&#13;
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt&#13;
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np&#13;
<span class="hljs-keyword">import</span> ipywidgets <span class="hljs-keyword">as</span> widgets&#13;
&#13;
<span class="hljs-comment"># Using interact, we create 2 sliders here for size and step.</span>&#13;
<span class="hljs-comment"># In this case we have size which goes from 1 to 25 with increments</span>&#13;
<span class="hljs-comment"># of 1, and step, which goes from 0.1 to 1 with increments of 0.1</span>&#13;
<span class="hljs-meta">@widgets.interact(</span><span class="hljs-params">size=(</span><span class="hljs-number">1</span><span class="hljs-params">, </span><span class="hljs-number">25</span><span class="hljs-params">, </span><span class="hljs-number">1</span><span class="hljs-params">), step=(</span><span class="hljs-number">0.1</span><span class="hljs-params">, </span><span class="hljs-number">1</span><span class="hljs-params">, </span><span class="hljs-number">0.1</span><span class="hljs-params">)</span><span class="hljs-meta">)</span>&#13;
<span class="hljs-keyword">def</span> <span class="hljs-title">plot</span>(<span class="hljs-params">size, step</span>):&#13;
    <span class="hljs-comment"># Create a matplotlib figure</span>&#13;
    <span class="hljs-comment"># We will render everything onto this figure</span>&#13;
    fig = plt.figure()&#13;
    &#13;
    <span class="hljs-comment"># Add a subplot. You could add multiple subplots but only one will </span>&#13;
    <span class="hljs-comment"># be shown when using '%matplotlib notebook'</span>&#13;
    ax = fig.add_subplot(projection=<span class="hljs-string">'3d'</span>)&#13;
    &#13;
    <span class="hljs-comment"># We want X and Y to be the same, so generate a single range</span>&#13;
    XY = np.arange(-size, size, step)&#13;
    &#13;
    <span class="hljs-comment"># Convert the vectors into a matrix</span>&#13;
    X, Y = np.meshgrid(XY, XY)&#13;
    &#13;
    R = np.sqrt(X**<span class="hljs-number">2</span> + Y**<span class="hljs-number">2</span>)&#13;
    &#13;
    <span class="hljs-comment"># Plot using sine</span>&#13;
    Z = np.sin(R)&#13;
    ax.plot_surface(X, Y, Z)&#13;
&#13;
    <span class="hljs-comment"># Plot using cosine with a Z-offset of 10 to plot above each other</span>&#13;
    Z = np.cos(R)&#13;
    ax.plot_surface(X, Y, Z + <span class="hljs-number">10</span>)&#13;
</code></pre>&#13;
    <p class="normal">This function<a id="_idIndexMarker1295"/> generates the following figure:</p>&#13;
    <figure class="mediaobject"><img src="Images/B15882_15_02.png" alt="" width="517" height="454"/></figure>&#13;
    <p class="packt_figref">Figure 15.2: Matplotlib in Jupyter Notebook with adjustable sliders</p>&#13;
    <p class="normal">With a combination of <code class="inlineCode">jupyter-notebook</code> and <code class="inlineCode">matplotlib</code>, we can create interactive plots. If you run this in your own browser, not only can you drag the 3D plot around and view it from all sides, but you can also modify the <code class="inlineCode">size</code> and <code class="inlineCode">step</code> parameters by dragging the sliders.</p>&#13;
    <p class="normal">With regard to actual<a id="_idIndexMarker1296"/> plot types supported by <code class="inlineCode">matplotlib</code>, there are really too many options and variations to list here, but if you are looking for any type of chart, graph, or plot, you are likely to find a solution using <code class="inlineCode">matplotlib</code>. Additionally, many of the scientific Python libraries natively support it, which makes it an easy choice. This short section really does not do justice to the depth and features of <code class="inlineCode">matplotlib</code>, but fear not – we are far from done with it as it, is the basis of a few other plotting libraries in this chapter.</p>&#13;
    <h3 id="_idParaDest-447" class="heading-3">Seaborn</h3>&#13;
    <p class="normal">The <code class="inlineCode">seaborn</code> library<a id="_idIndexMarker1297"/> is related to <code class="inlineCode">matplotlib</code> in a similar way to how <code class="inlineCode">statsmodels</code> works on top of <code class="inlineCode">pandas</code>. It provides an interface for <code class="inlineCode">matplotlib</code> with a strong focus on statistical data. The major feature of <code class="inlineCode">seaborn</code> is that it makes it really easy to automatically generate an entire grid of plots.</p>&#13;
    <p class="normal">Additionally, which is very convenient for our examples, <code class="inlineCode">seaborn</code> comes with some test data so we can show fully fledged demonstrations based on real data. To illustrate, let’s look at how easily we can create a very elaborate set of plots:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">%matplotlib notebook&#13;
&#13;
<span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns&#13;
&#13;
sns.pairplot(&#13;
    <span class="hljs-comment"># Load the bundled Penguin dataset</span>&#13;
    sns.load_dataset(<span class="hljs-string">'penguins'</span>),&#13;
    <span class="hljs-comment"># Show a different "color" for each species</span>&#13;
    hue=<span class="hljs-string">'species'</span>,&#13;
    <span class="hljs-comment"># Specify the markers (matplotlib.markers)</span>&#13;
    markers=[<span class="hljs-string">'o'</span>, <span class="hljs-string">'s'</span>, <span class="hljs-string">'</span><span class="hljs-string">v'</span>],&#13;
    <span class="hljs-comment"># Gray was chosen due to the book being printed in black and white</span>&#13;
    palette=<span class="hljs-string">'Greys'</span>,&#13;
    <span class="hljs-comment"># Specify which rows and columns to show. The default is to show all</span>&#13;
    y_vars=[<span class="hljs-string">'body_mass_g'</span>, <span class="hljs-string">'flipper_length_mm'</span>],&#13;
    x_vars=[<span class="hljs-string">'body_mass_g'</span>, <span class="hljs-string">'flipper_length_mm'</span>, <span class="hljs-string">'bill_length_mm'</span>])&#13;
</code></pre>&#13;
    <p class="normal">This produces the following set of plots:</p>&#13;
    <figure class="mediaobject"><img src="Images/B15882_15_03.png" alt="" width="874" height="502"/></figure>&#13;
    <p class="packt_figref">Figure 15.3: Seaborn pairplot render</p>&#13;
    <p class="normal">While this still seems like a <a id="_idIndexMarker1298"/>very elaborate call, you could actually get away with just using <code class="inlineCode">sns.pairplot(df)</code> to get great results. Without the <code class="inlineCode">hue=...</code> parameter, the results will not be split by species, however. </p>&#13;
    <p class="normal">The <code class="inlineCode">seaborn</code> library has support for many types of plots:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Relational plots such as line plots and scatter plots</li>&#13;
      <li class="bulletList">Distribution plots such as histograms</li>&#13;
      <li class="bulletList">Categorical plots such as box plots</li>&#13;
      <li class="bulletList">Matrix plots such as heatmaps</li>&#13;
    </ul>&#13;
    <p class="normal">The <code class="inlineCode">seaborn</code> library also has many shortcuts for creating sets of plots or automatically processing the data using algorithms such as kernel density estimation.</p>&#13;
    <p class="normal">If you are looking for a nice-looking plotting library, <code class="inlineCode">seaborn</code> is a very good option, especially due to the multi-plot grid features. The list of plots above are all specific plots, but as we saw with <code class="inlineCode">pairplot</code>, <code class="inlineCode">seaborn</code> can generate an entire grid of plots in just a single line of code, which is extremely useful. You could do the same with <code class="inlineCode">matplotlib</code> directly, but it would probably take you a few dozen lines of code.</p>&#13;
    <h3 id="_idParaDest-448" class="heading-3">Yellowbrick</h3>&#13;
    <p class="normal">As is the case with <code class="inlineCode">seaborn</code>, <code class="inlineCode">yellowbrick</code> is also built on top of <code class="inlineCode">matplotlib</code>. The difference <a id="_idIndexMarker1299"/>is that <code class="inlineCode">yellowbrick</code> is focused on visualizing machine learning results and depends on the scikit-learn (<code class="inlineCode">sklearn</code>) machine learning library. The scikit-learn integration is also what makes this library very powerful in those scenarios; it natively understands the scikit-learn data structures so it can easily plot them for you with almost no configuration. In the next chapter, we will see more on scikit-learn.</p>&#13;
    <p class="normal">This example, straight from the <code class="inlineCode">yellowbrick</code> manual, shows how you can visualize a regression in effectively a single line of code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">%matplotlib notebook&#13;
&#13;
<span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestRegressor&#13;
<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split <span class="hljs-keyword">as</span> tts&#13;
&#13;
<span class="hljs-keyword">from</span> yellowbrick.datasets <span class="hljs-keyword">import</span> load_concrete&#13;
<span class="hljs-keyword">from</span> yellowbrick.regressor <span class="hljs-keyword">import</span> residuals_plot&#13;
&#13;
<span class="hljs-comment"># Load the dataset and split into train/test (pandas.DataFrame) splits</span>&#13;
X, y = load_concrete()&#13;
&#13;
X_train, X_test, y_train, y_test = tts(X, y, test_size=<span class="hljs-number">0.2</span>, shuffle=<span class="hljs-literal">True</span>)&#13;
&#13;
<span class="hljs-comment"># Create the visualizer, fit, score, and show it</span>&#13;
viz = residuals_plot(RandomForestRegressor(), X_train, y_train, X_test, y_test)&#13;
</code></pre>&#13;
    <p class="normal">This generates the following scatter plot:</p>&#13;
    <figure class="mediaobject"><img src="Images/B15882_15_04.png" alt="" width="860" height="616"/></figure>&#13;
    <p class="packt_figref">Figure 15.4: Yellowbrick regression plot</p>&#13;
    <p class="normal">These kinds of shortcut functions make it really easy to generate usable output and work on your regression instead of having to worry about how to properly plot the data. In addition to plotting<a id="_idIndexMarker1300"/> regressions, <code class="inlineCode">yellowbrick</code> has many more visualizers organized by analysis type. Similar to <code class="inlineCode">seaborn</code>, <code class="inlineCode">yellowbrick</code> can take care of not only the plotting but also the calculations and analysis for you.</p>&#13;
    <p class="normal">The <code class="inlineCode">yellowbrick</code> library has functions for many types of analysis such as:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><strong class="keyWord">Feature visualization</strong>: Displaying<a id="_idIndexMarker1301"/> features as scatter plots, detecting relationships and ranking them, creating a circular plot of related features, and so on</li>&#13;
      <li class="bulletList"><strong class="keyWord">Classification visualization</strong>: Displaying <a id="_idIndexMarker1302"/>the thresholds, precision, and the error prediction for classifications as line, area, or matrix plots</li>&#13;
      <li class="bulletList"><strong class="keyWord">Regression visualization</strong>: Displaying <a id="_idIndexMarker1303"/>a scatter or a combination of scatter plots and histograms</li>&#13;
      <li class="bulletList"><strong class="keyWord">Cluster visualization</strong>: Displaying<a id="_idIndexMarker1304"/> maps to visualize the distance between the clusters</li>&#13;
      <li class="bulletList"><strong class="keyWord">Model selection visualization</strong>: Displaying the learning curve through a combination <a id="_idIndexMarker1305"/>of lines and area or showing the feature importance as a bar chart</li>&#13;
    </ul>&#13;
    <p class="normal">The <code class="inlineCode">yellowbrick</code> library is currently the most convenient option for visualizing scikit-learn output, but most of the charting options also apply to other data types such as <code class="inlineCode">pandas.DataFrame</code> objects, so it’s worth taking a look if <code class="inlineCode">seaborn</code> does not suit your needs.</p>&#13;
    <h2 id="_idParaDest-449" class="heading-2">Plotly</h2>&#13;
    <p class="normal">The <code class="inlineCode">plotly</code> library<a id="_idIndexMarker1306"/> supports a lot of different types of plots and even has native support for controls such as sliders, so you can change parameters when viewing from a web browser. Additionally, similar to how <code class="inlineCode">seaborn</code> makes usage of <code class="inlineCode">matplotlib</code> much easier in some cases, <code class="inlineCode">plotly</code> also includes Plotly Express (often denoted as <code class="inlineCode">px</code>), which makes usage trivially easy.</p>&#13;
    <p class="normal">To illustrate how easy Plotly Express can be, let’s try to replicate the plots we made with <code class="inlineCode">seaborn</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns&#13;
<span class="hljs-keyword">import</span> plotly.express <span class="hljs-keyword">as</span> px&#13;
&#13;
fig = px.scatter_matrix(&#13;
    <span class="hljs-comment"># Load the Penguin dataset from seaborn</span>&#13;
    sns.load_dataset(<span class="hljs-string">'</span><span class="hljs-string">penguins'</span>),&#13;
    <span class="hljs-comment"># Show a different "color" for each species</span>&#13;
    color=<span class="hljs-string">'species'</span>,&#13;
    <span class="hljs-comment"># Specify that the symbols/markers are species-dependent</span>&#13;
    symbol=<span class="hljs-string">'species'</span>,&#13;
    <span class="hljs-comment"># Specify which rows and columns to show. The default is to show all</span>&#13;
    dimensions=[<span class="hljs-string">'body_mass_g'</span>, <span class="hljs-string">'flipper_length_mm'</span>, <span class="hljs-string">'bill_length_mm'</span>],&#13;
)&#13;
fig.show()&#13;
</code></pre>&#13;
    <p class="normal">Here is the result:</p>&#13;
    <figure class="mediaobject"><img src="Images/B15882_15_05.png" alt="" width="878" height="417"/></figure>&#13;
    <p class="packt_figref">Figure 15.5: Plotly Express example output</p>&#13;
    <p class="normal">While I would argue that the <code class="inlineCode">seaborn</code> output is slightly prettier in this specific case, it does show just how easy it is to create useful plots using Plotly Express.</p>&#13;
    <p class="normal">You might be wondering <a id="_idIndexMarker1307"/>how easy or difficult it is to use the regular <code class="inlineCode">plotly</code> API, as opposed to Plotly Express. For that, let’s see if we can replicate the 3D <code class="inlineCode">matplotlib</code> render:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> plotly&#13;
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np&#13;
<span class="hljs-keyword">import</span> ipywidgets <span class="hljs-keyword">as</span> widgets&#13;
<span class="hljs-keyword">import</span> plotly.graph_objects <span class="hljs-keyword">as</span> go&#13;
&#13;
<span class="hljs-comment"># Using interact, we create 2 sliders here for size and step.</span>&#13;
<span class="hljs-comment"># In this case we have size which goes from 1 to 25 with increments</span>&#13;
<span class="hljs-comment"># of 1, and step, which goes from 0.1 to 1 with increments of 0.1</span>&#13;
<span class="hljs-meta">@widgets.interact(</span><span class="hljs-params">size=(</span><span class="hljs-number">1</span><span class="hljs-params">, </span><span class="hljs-number">25</span><span class="hljs-params">, </span><span class="hljs-number">1</span><span class="hljs-params">), step=(</span><span class="hljs-number">0.1</span><span class="hljs-params">, </span><span class="hljs-number">1</span><span class="hljs-params">, </span><span class="hljs-number">0.1</span><span class="hljs-params">)</span><span class="hljs-meta">)</span>&#13;
<span class="hljs-keyword">def</span> <span class="hljs-title">plot</span>(<span class="hljs-params">size, step</span>):&#13;
    <span class="hljs-comment"># Create a plotly figure, we will render everything onto this figure</span>&#13;
    fig = go.Figure()&#13;
        &#13;
    <span class="hljs-comment"># We want X and Y to be the same, so generate a single range</span>&#13;
    XY = np.arange(-size, size, step)&#13;
    &#13;
    <span class="hljs-comment"># Convert the vectors into a matrix</span>&#13;
    X, Y = np.meshgrid(XY, XY)&#13;
    &#13;
    R = np.sqrt(X**<span class="hljs-number">2</span> + Y**<span class="hljs-number">2</span>)&#13;
    &#13;
    <span class="hljs-comment"># Plot using sine</span>&#13;
    Z = np.sin(R)&#13;
    fig.add_trace(go.Surface(x=X, y=Y, z=Z))&#13;
&#13;
    <span class="hljs-comment"># Plot using cosine with a Z-offset of 10 to plot above each other</span>&#13;
    Z = np.cos(R)&#13;
    fig.add_trace(go.Surface(x=X, y=Y, z=Z + <span class="hljs-number">10</span>))&#13;
    fig.show()&#13;
</code></pre>&#13;
    <p class="normal">Here’s the final result with<a id="_idIndexMarker1308"/> the two cosines plotted in 3D:</p>&#13;
    <figure class="mediaobject"><img src="Images/B15882_15_06.png" alt="" width="539" height="394"/></figure>&#13;
    <p class="packt_figref">Figure 15.6: 3D plot using plotly</p>&#13;
    <p class="normal">This is pretty much identical to <code class="inlineCode">matplotlib</code>, and I would argue that it’s even slightly better due to being even more interactive (which the book cannot effectively show, unfortunately). By default, <code class="inlineCode">plotly</code> features a very useful display of the values when you hover with the mouse and allows for really easy zooming and filtering interactively.</p>&#13;
    <p class="normal">When it comes to the choice between <code class="inlineCode">matplotlib</code> and <code class="inlineCode">plotly</code>, I would recommend looking at your specific use case. I think <code class="inlineCode">plotly</code> is slightly easier and more convenient to use, but <code class="inlineCode">matplotlib</code> is deeply integrated with many scientific Python libraries, which makes it a very convenient option. As always, opinions vary, so make sure to take a look at both.</p>&#13;
    <h2 id="_idParaDest-450" class="heading-2">Bokeh</h2>&#13;
    <p class="normal">The <code class="inlineCode">bokeh</code> library<a id="_idIndexMarker1309"/> is a beautiful and powerful visualization library with a strong focus on interactive visualizations in web browsers. Being able to make plots interactive can be extremely useful for analyzing the results. Instead of having to create multiple plots in a grid as we saw with <code class="inlineCode">seaborn</code>, you can use a single grid and filter interactively. As this is a book, however, we cannot really demonstrate the full power of <code class="inlineCode">bokeh</code>.</p>&#13;
    <p class="normal">Before we get started with some examples, we need to talk about the two ways you can use <code class="inlineCode">bokeh</code>. Effectively it comes down to <strong class="keyWord">static</strong> versus <strong class="keyWord">dynamic</strong>, where the static version uses a static snapshot of all data shown and the dynamic version loads data on demand.</p>&#13;
    <p class="normal">The static version is similar to how <code class="inlineCode">matplotlib</code> and most plotting libraries work: all data is contained in a single image or on a single web page without loading external resources. This works great for many cases, but not all.</p>&#13;
    <p class="normal">What if you have a <em class="italic">lot</em> of data? A nice example of a visualization like this is Google Earth. You could never realistically download all of the data from Google Earth onto your computer (according to some estimates, currently over 100 petabytes of data), so you need to load it as you move around the map. For this purpose, <code class="inlineCode">bokeh</code> has a server built in so the visualization can dynamically load the results as you filter. For the purpose of this book that makes little sense because it will be static in all cases, but we can show examples of both.</p>&#13;
    <p class="normal">First, let’s create a very basic plot:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np&#13;
&#13;
<span class="hljs-keyword">from</span> bokeh.plotting <span class="hljs-keyword">import</span> figure, show&#13;
<span class="hljs-keyword">from</span> bokeh.io <span class="hljs-keyword">import</span> output_notebook&#13;
&#13;
<span class="hljs-comment"># Load all javascript/css for bokeh</span>&#13;
output_notebook()&#13;
&#13;
<span class="hljs-comment"># Create a numpy array of length 100 from 0 to 4 pi</span>&#13;
x = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>*np.pi, <span class="hljs-number">100</span>)&#13;
&#13;
<span class="hljs-comment"># Create a bokeh figure to draw on</span>&#13;
p = figure()&#13;
<span class="hljs-comment"># Draw both a sine and a cosine</span>&#13;
p.line(x, np.sin(x), legend_label=<span class="hljs-string">'sin(x)'</span>, line_dash=<span class="hljs-string">'dotted'</span>)&#13;
p.line(x, np.cos(x), legend_label=<span class="hljs-string">'cos(x)'</span>)&#13;
&#13;
<span class="hljs-comment"># Render the output</span>&#13;
show(p)&#13;
</code></pre>&#13;
    <p class="normal">From this, we get the <a id="_idIndexMarker1310"/>sine and cosine rendered as lines:</p>&#13;
    <figure class="mediaobject"><img src="Images/B15882_15_07.png" alt="" width="713" height="740"/></figure>&#13;
    <p class="packt_figref">Figure 15.7: Bokeh basic render</p>&#13;
    <p class="normal">As you can see, rendering basic <em class="italic">x</em>/<em class="italic">y</em> data as a line is really easy and does not look too different from the <code class="inlineCode">matplotlib</code> output. If you look carefully, however, you might also notice the buttons on the right. These are what <code class="inlineCode">bokeh</code> calls <strong class="keyWord">tools</strong>, and they can be used for zooming by either scrolling or by drawing a rectangle around what you wish to see. Panning can be done by dragging the image. It is also possible to save the render as an image file. If desired, you <a id="_idIndexMarker1311"/>can create tooltips that respond to mouse clicks or mouse hovers. </p>&#13;
    <p class="normal">Now let’s see if we can recreate a more advanced plot like the one we made with <code class="inlineCode">seaborn</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np&#13;
<span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns&#13;
&#13;
<span class="hljs-keyword">from</span> bokeh.plotting <span class="hljs-keyword">import</span> figure, show&#13;
<span class="hljs-keyword">from</span> bokeh.io <span class="hljs-keyword">import</span> output_notebook&#13;
<span class="hljs-keyword">from</span> bokeh.layouts <span class="hljs-keyword">import</span> gridplot&#13;
<span class="hljs-keyword">from</span> bokeh.transform <span class="hljs-keyword">import</span> factor_cmap, factor_mark&#13;
&#13;
output_notebook()&#13;
&#13;
<span class="hljs-comment"># Load the seaborn penguin dataset (pandas.DataFrame)</span>&#13;
penguins = sns.load_dataset(<span class="hljs-string">'penguins'</span>)&#13;
<span class="hljs-comment"># Get the unique list of species for the marker and color mapping</span>&#13;
species = penguins[<span class="hljs-string">'species'</span>].unique()&#13;
<span class="hljs-comment"># Specify the marker list which will be mapped to the 3 species</span>&#13;
markers = [<span class="hljs-string">'circle'</span>, <span class="hljs-string">'square'</span>, <span class="hljs-string">'triangle'</span>]&#13;
<span class="hljs-comment"># Create a list of rows so we can build the grid of plots</span>&#13;
rows = []&#13;
&#13;
<span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> (<span class="hljs-string">'body_mass_g'</span>, <span class="hljs-string">'flipper_length_mm'</span>):&#13;
    row = []&#13;
    rows.append(row)&#13;
&#13;
    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> (<span class="hljs-string">'body_mass_g'</span>, <span class="hljs-string">'flipper_length_mm'</span>, <span class="hljs-string">'bill_length_mm'</span>):&#13;
        <span class="hljs-comment"># Create a figure with a fixed size and pass along the labels</span>&#13;
        p = figure(width=<span class="hljs-number">250</span>, height=<span class="hljs-number">250</span>,&#13;
            x_axis_label=x, y_axis_label=y)&#13;
        row.append(p)&#13;
        &#13;
        <span class="hljs-keyword">if</span> x == y:&#13;
            <span class="hljs-comment"># Calculate the histogram using numpy and make sure to drop</span>&#13;
            <span class="hljs-comment"># the NaN values</span>&#13;
            hist, edges = np.histogram(penguins[x].dropna(), bins=<span class="hljs-number">250</span>)&#13;
            <span class="hljs-comment"># Draw the histograms as quadrilaterals (rectangles)</span>&#13;
            p.quad(top=hist, bottom=<span class="hljs-number">0</span>, left=edges[:-<span class="hljs-number">1</span>], right=edges[<span class="hljs-number">1</span>:])&#13;
        <span class="hljs-keyword">else</span>:&#13;
            <span class="hljs-comment"># Create a scatter-plot</span>&#13;
            p.scatter(&#13;
                <span class="hljs-comment"># Specify the columns of the dataframe to show on the</span>&#13;
                <span class="hljs-comment"># x and y axis</span>&#13;
                x, y,&#13;
                <span class="hljs-comment"># Specify the datasource, the pandas.DataFrame is</span>&#13;
                <span class="hljs-comment"># natively supported by bokeh</span>&#13;
                source=penguins,&#13;
                <span class="hljs-comment"># Specify the column that contains the legend data</span>&#13;
                legend_field=<span class="hljs-string">'species'</span>,&#13;
                <span class="hljs-comment"># Map the species onto our list of markers</span>&#13;
                marker=factor_mark(<span class="hljs-string">'</span><span class="hljs-string">species'</span>, markers, species),&#13;
                <span class="hljs-comment"># Map the species to the Greys4 color palette</span>&#13;
                color=factor_cmap(<span class="hljs-string">'species'</span>, <span class="hljs-string">'Greys4'</span>, factors=species),&#13;
                <span class="hljs-comment"># Add transparency to the markers to make them easier</span>&#13;
                <span class="hljs-comment"># to see</span>&#13;
                fill_alpha=<span class="hljs-number">0.2</span>,&#13;
            )&#13;
    &#13;
<span class="hljs-comment"># Show a grid of plots. Expects a 2D array</span>&#13;
show(gridplot(rows))&#13;
</code></pre>&#13;
    <p class="normal">This results in a<a id="_idIndexMarker1312"/> collection of scatter plots and histograms: </p>&#13;
    <figure class="mediaobject"><img src="Images/B15882_15_08.png" alt="" width="876" height="622"/></figure>&#13;
    <p class="packt_figref">Figure 15.8: Seaborn-like plots using Bokeh</p>&#13;
    <p class="normal">This somewhat resembles what we created with <code class="inlineCode">seaborn</code>, but it still took quite a bit of effort to do. It does show how we can fairly easily combine several plots (and types of plots) together even when using a <code class="inlineCode">pandas.DataFrame</code> as a source.</p>&#13;
    <p class="normal">Should you <a id="_idIndexMarker1313"/>use <code class="inlineCode">bokeh</code>? I think <code class="inlineCode">bokeh</code> is a nicely documented plotting library with a lot of merits, but so are many of the others. In my opinion, the main feature of <code class="inlineCode">bokeh</code> is the support for dynamic data loading through the <code class="inlineCode">bokeh</code> server, which can be a really useful feature in some cases. As opposed to <code class="inlineCode">plotly</code>, the <code class="inlineCode">bokeh</code> server has more features for maintaining its own state, so chart changes can be made easily without recalculation.</p>&#13;
    <h2 id="_idParaDest-451" class="heading-2">Datashader</h2>&#13;
    <p class="normal">The <code class="inlineCode">datashader</code> library<a id="_idIndexMarker1314"/> is a special case but I believe it deserves a mention. The <code class="inlineCode">datashader</code> plotting library can be used for regular plotting, but it is specially optimized for high performance and large datasets. As a little example, this plot with 10 million data points only takes about a second to render:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np, pandas <span class="hljs-keyword">as</span> pd, datashader <span class="hljs-keyword">as</span> ds&#13;
<span class="hljs-keyword">from</span> datashader <span class="hljs-keyword">import</span> transfer_functions <span class="hljs-keyword">as</span> tf&#13;
<span class="hljs-keyword">from</span> datashader.colors <span class="hljs-keyword">import</span> inferno, viridis&#13;
<span class="hljs-keyword">from</span> numba <span class="hljs-keyword">import</span> jit&#13;
<span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sin, cos, sqrt, fabs&#13;
&#13;
<span class="hljs-comment"># Set the number of points to calculate, takes about a second with</span>&#13;
<span class="hljs-comment"># 10 million</span>&#13;
n=<span class="hljs-number">10000000</span>&#13;
&#13;
<span class="hljs-comment"># The Clifford attractor code, JIT-compiled using numba</span>&#13;
<span class="hljs-meta">@jit(</span><span class="hljs-params">nopython=</span><span class="hljs-literal">True</span><span class="hljs-meta">)</span>&#13;
<span class="hljs-keyword">def</span> <span class="hljs-title">Clifford</span>(<span class="hljs-params">x, y, a, b, c, d, *o</span>):&#13;
    <span class="hljs-keyword">return</span> sin(a * y) + c * cos(a * x), \&#13;
           sin(b * x) + d * cos(b * y)&#13;
&#13;
<span class="hljs-comment"># Coordinate calculation, also JIT-compiled</span>&#13;
<span class="hljs-meta">@jit(</span><span class="hljs-params">nopython=</span><span class="hljs-literal">True</span><span class="hljs-meta">)</span>&#13;
<span class="hljs-keyword">def</span> <span class="hljs-title">trajectory_coords</span>(<span class="hljs-params">fn, x0, y0, a, b=</span><span class="hljs-number">0</span><span class="hljs-params">, c=</span><span class="hljs-number">0</span><span class="hljs-params">, d=</span><span class="hljs-number">0</span><span class="hljs-params">, e=</span><span class="hljs-number">0</span><span class="hljs-params">, f=</span><span class="hljs-number">0</span><span class="hljs-params">, n=n</span>):&#13;
    x, y = np.zeros(n), np.zeros(n)&#13;
    x[<span class="hljs-number">0</span>], y[<span class="hljs-number">0</span>] = x0, y0&#13;
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(n-<span class="hljs-number">1</span>):&#13;
        x[i+<span class="hljs-number">1</span>], y[i+<span class="hljs-number">1</span>] = fn(x[i], y[i], a, b, c, d, e, f)&#13;
    <span class="hljs-keyword">return</span> x,y&#13;
&#13;
<span class="hljs-keyword">def</span> <span class="hljs-title">trajectory</span>(<span class="hljs-params">fn, x0, y0, a, b=</span><span class="hljs-number">0</span><span class="hljs-params">, c=</span><span class="hljs-number">0</span><span class="hljs-params">, d=</span><span class="hljs-number">0</span><span class="hljs-params">, e=</span><span class="hljs-number">0</span><span class="hljs-params">, f=</span><span class="hljs-number">0</span><span class="hljs-params">, n=n</span>):&#13;
    x, y = trajectory_coords(fn, x0, y0, a, b, c, d, e, f, n)&#13;
    <span class="hljs-keyword">return</span> pd.DataFrame(<span class="hljs-built_in">dict</span>(x=x,y=y))&#13;
&#13;
<span class="hljs-comment"># Calculate the pandas.DataFrame</span>&#13;
df = trajectory(Clifford, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1.7</span>, <span class="hljs-number">1.5</span>, -<span class="hljs-number">0.5</span>, <span class="hljs-number">0.7</span>)&#13;
&#13;
<span class="hljs-comment"># Create a canvas and render</span>&#13;
cvs = ds.Canvas()&#13;
agg = cvs.points(df, <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>)&#13;
tf.shade(agg, cmap=[<span class="hljs-string">"white"</span>, <span class="hljs-string">"black"</span>])&#13;
</code></pre>&#13;
    <p class="normal">Here is the plot <a id="_idIndexMarker1315"/>generated by calculating the 10 million points:</p>&#13;
    <figure class="mediaobject"> <img src="Images/B15882_15_09.png" alt="/var/folders/ph/3d51j84d2gg_pltczn6244q80000gn/T/com.microsoft.Word/Content.MSO/EC6EBE9A.tmp" width="436" height="436"/></figure>&#13;
    <p class="packt_figref">Figure 15.9: Datashader attractor render</p>&#13;
    <h1 id="_idParaDest-452" class="heading-1">Exercises</h1>&#13;
    <p class="normal">Due to the nature of this chapter, we have only covered the absolute basics of the mentioned libraries and they really do deserve much more. In this case, as an exercise, I recommend that you try and use some (or all) of the mentioned libraries and see if you can do something useful with them, using the variety of examples we have introduced already as inspiration.</p>&#13;
    <p class="normal">Some suggestions:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Create your own beautiful datashader plots</li>&#13;
      <li class="bulletList">Render the lines of code per project of your personal workspace</li>&#13;
      <li class="bulletList">Continuing from the lines of code per project, see if you can cluster the projects by programming language</li>&#13;
       </ul>&#13;
        <div class="note">&#13;
          <p class="normal">Example answers for these exercises can be found on GitHub: <a href="Chapter_15.xhtml"><span class="url">https://github.com/mastering-python/exercises</span></a>. You are encouraged to submit your own solutions and learn about alternative solutions from others.</p>&#13;
        </div>&#13;
      &#13;
   &#13;
    <h1 id="_idParaDest-453" class="heading-1">Summary</h1>&#13;
    <p class="normal">This chapter has shown us a sample of the most commonly used and generic scientific Python libraries. While it covered a lot of libraries, there are many more available, especially when you start looking for domain-specific libraries. With regard to plotting alone, there are at least several other very big libraries that could be useful for your use cases but would be superfluous for this chapter.</p>&#13;
    <p class="normal">To recap, we have covered the basics of working with NumPy matrices and Pandas data objects, both of which are important for the next chapter. We have also seen a few libraries that focus on mathematics and really precise calculations. Lastly, we have covered several plotting libraries, some of which will be used in the next chapter as well.</p>&#13;
    <p class="normal">Next up is the chapter about artificial intelligence and machine learning in Python. As is the case with this chapter, we cannot go into too much depth, but we can cover the most important technologies and libraries so you know where to look.</p>&#13;
    <h1 class="heading-1">Join our community on Discord</h1>&#13;
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://discord.gg/QMzJenHuJf"><span class="url">https://discord.gg/QMzJenHuJf</span></a></p>&#13;
    <p class="normal"><img src="Images/QR_Code156081100001293319171.png" alt="" width="177" height="177"/></p>&#13;
  </div>&#13;
</div></body></html>