<html><head></head><body>
		<div id="_idContainer011">
			<h1 id="_idParaDest-59" class="chapter-number"><a id="_idTextAnchor061"/>3</h1>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor062"/>Creational Design Patterns</h1>
			<p>Design patterns<a id="_idIndexMarker086"/> are reusable programming solutions that have been used in various real-world contexts and have proved to produce expected results. They are shared among programmers and continue to be improved over time. This topic is popular thanks to the book by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, titled <em class="italic">Design Patterns: Elements of Reusable </em><span class="No-Break"><em class="italic">Object-Oriented Software</em></span><span class="No-Break">.</span></p>
			<p>Here is a quote about design patterns from the <em class="italic">Gang of </em><span class="No-Break"><em class="italic">Four </em></span><span class="No-Break">book:</span></p>
			<p><em class="italic">A design pattern systematically names, motivates, and explains a general design that addresses a recurring design problem in object-oriented systems. It describes the problem, the solution, when to apply the solution, and its consequences. It also gives implementation hints and examples. The solution is a general arrangement of objects and classes that solve the problem. The solution is customized and implemented to solve the problem in a </em><span class="No-Break"><em class="italic">particular context.</em></span></p>
			<p>There <a id="_idIndexMarker087"/>are several categories of design patterns used in <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>), depending on the type of problem they address and/or the types of solutions they help us build. In their book, the <em class="italic">Gang of Four</em> presents 23 design patterns, split into three categories: <em class="italic">creational</em>, <em class="italic">structural</em>, <span class="No-Break">and </span><span class="No-Break"><em class="italic">behavioral</em></span><span class="No-Break">.</span></p>
			<p><strong class="bold">Creational design patterns</strong> are <a id="_idIndexMarker088"/>the first category we will cover throughout this chapter. These patterns deal with different aspects of object creation. Their goal is to provide better alternatives for situations where direct object creation, which in Python happens within the <strong class="source-inline">__init__()</strong> function, is <span class="No-Break">not convenient.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>The <span class="No-Break">factory pattern</span></li>
				<li>The <span class="No-Break">builder pattern</span></li>
				<li>The <span class="No-Break">prototype pattern</span></li>
				<li>The <span class="No-Break">singleton pattern</span></li>
				<li>The object <span class="No-Break">pool pattern</span></li>
			</ul>
			<p>By the end of the chapter, you will have a solid understanding of creational design patterns, whether they are useful or not in Python, and how to use them when they <span class="No-Break">are useful.</span></p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor063"/>Technical requirements</h1>
			<p>See the requirements presented in <a href="B21896_01.xhtml#_idTextAnchor017"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor064"/>The factory pattern</h1>
			<p>We will start<a id="_idIndexMarker089"/> with the first <a id="_idIndexMarker090"/>creational design pattern from the <em class="italic">Gang of Four</em> book: the factory design pattern. In the factory design pattern, a client (meaning client code) asks for an object without knowing where the object is coming from (that is, which class is used to generate it). The idea behind a factory is to simplify the object creation process. It is easier to track which objects are created if this is done through a central function, compared to letting a client create objects using a direct class instantiation. A factory reduces the complexity of maintaining an application by decoupling the code that creates an object from the code that <span class="No-Break">uses it.</span></p>
			<p>Factories typically come in two forms—the factory method, which is a method (or simply a function for a Python developer) that returns a different object per input parameter, and the abstract factory, which is a group of factory methods used to create a family of <span class="No-Break">related objects.</span></p>
			<p>Let’s discuss the two forms of <em class="italic">factory pattern</em>, starting with the <span class="No-Break">factory method.</span></p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor065"/>The factory method</h2>
			<p>The factory method<a id="_idIndexMarker091"/> is based on a single function written to handle our object creation task. We execute it, passing a parameter that provides information about what we want, and, as a result, the wanted object <span class="No-Break">is created.</span></p>
			<p>Interestingly, when using the factory method, we are not required to know any details about how the resulting object is implemented and where it is <span class="No-Break">coming from.</span></p>
			<h3>Real-world examples</h3>
			<p>We can find the factory <a id="_idIndexMarker092"/>method pattern used in real life in the context of a plastic toy construction kit. The molding material used to construct plastic toys is the same, but different toys (different figures or shapes) can be produced using the right plastic molds. This is like having a factory method in which the input is the name of the toy that we want (for example, a duck or car) and the output (after the molding) is the plastic toy that <span class="No-Break">was requested.</span></p>
			<p>In the software world, the Django web framework uses the factory method pattern for creating the fields of a web form. The <strong class="source-inline">forms</strong> module included in Django (<a href="https://github.com/django/django/blob/main/django/forms/forms.py">https://github.com/django/django/blob/main/django/forms/forms.py</a>) supports the creation of different kinds of fields (for example, <strong class="source-inline">CharField</strong>, <strong class="source-inline">EmailField</strong>, and so on). Parts of their behavior can <a id="_idIndexMarker093"/>be customized using attributes such as <strong class="source-inline">max_length</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">required</strong></span><span class="No-Break">.</span></p>
			<h3>Use cases for the factory method pattern</h3>
			<p>If you <a id="_idIndexMarker094"/>realize that<a id="_idIndexMarker095"/> you cannot track the objects created by your application because the code that creates them is in many different places instead of in a single function/method, you should consider using the factory method pattern. The factory method centralizes object creation and tracking your objects becomes much easier. Note that it is fine to create more than one factory method, and this is how it is typically done in practice. Each factory method logically groups the creation of objects that have similarities. For example, one factory method might be responsible for connecting you to different databases (MySQL, SQLite); another factory method might be responsible for creating the geometrical object that you request (circle, triangle); and <span class="No-Break">so on.</span></p>
			<p>The factory method is also useful when you want to decouple object creation from object usage. We are not coupled to a specific class when creating an object; we just provide partial information about what we want by calling a function. This means that introducing changes to the function is easy and does not require any changes to the code that <span class="No-Break">uses it.</span></p>
			<p>Another use case worth mentioning is related to improving the performance and memory usage of an application. A factory method can improve performance and memory usage by creating new objects only if it is necessary. When we create objects using a direct class instantiation, extra memory is allocated every time a new object is created (unless the class uses caching internally, which is usually not the case). We can see that in practice in the following code (<strong class="source-inline">ch03/factory/id.py</strong>), which creates two instances of the same class, <strong class="source-inline">MyClass</strong>, and uses the <strong class="source-inline">id()</strong> function to compare their memory addresses. The addresses are also printed in the output so that we can inspect them. The fact that the memory addresses are different means that two distinct objects are created. The code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class MyClass:
    pass
if __name__ == "__main__":
    a = MyClass()
    b = MyClass()
    print(id(a) == id(b))
    print(id(a))
    print(id(b))</pre>			<p>Executing the <a id="_idIndexMarker096"/>code (<strong class="source-inline">ch03/factory/id.py</strong>) on my <a id="_idIndexMarker097"/>computer results in the <span class="No-Break">following output:</span></p>
			<pre class="console">
False
4330224656
4331646704</pre>			<p class="callout-heading">Note</p>
			<p class="callout">The addresses that you see if you execute the file, where the <strong class="source-inline">id()</strong> function is called, are not the same as the ones I see because they depend on the current memory layout and allocation. But the result must be the same—the two addresses should be different. There’s one exception that happens if you write and execute the code in the Python <strong class="bold">Read-Eval-Print Loop</strong> (<strong class="bold">REPL</strong>)—or, simply<a id="_idIndexMarker098"/> put, the interactive prompt—but that’s a REPL-specific optimization that does not <span class="No-Break">happen normally.</span></p>
			<h3>Implementing the factory method pattern</h3>
			<p>Data comes<a id="_idIndexMarker099"/> in many forms. There are two main file categories for storing/retrieving data: human-readable files and binary files. Examples of human-readable files are XML, RSS/Atom, YAML, and JSON. Examples of binary files are the <strong class="source-inline">.sq3</strong> file format used by SQLite and the <strong class="source-inline">.mp3</strong> audio file format used to listen <span class="No-Break">to music.</span></p>
			<p>In this example, we will focus on two popular human-readable formats—XML and JSON. Although human-readable files are generally slower to parse than binary files, they make data exchange, inspection, and modification much easier. For this reason, it is advised that you work with human-readable files unless there are other restrictions that do not allow it (mainly unacceptable performance or proprietary <span class="No-Break">binary formats).</span></p>
			<p>In this case, we have some input data stored in an XML and a JSON file, and we want to parse them and retrieve some information. At the same time, we want to centralize the client’s connection to those (and all future) external services. We will use the factory method to solve this problem. The example focuses only on XML and JSON, but adding support for more<a id="_idIndexMarker100"/> services should <span class="No-Break">be straightforward.</span></p>
			<p>First, let’s look at the <span class="No-Break">data files.</span></p>
			<p>The JSON file, <strong class="source-inline">movies.json</strong>, is a sample of a dataset containing information about American movies (title, year, director name, genre, and <span class="No-Break">so on):</span></p>
			<pre class="source-code">
[
  {
    "title": "After Dark in Central Park",
    "year": 1900,
    "director": null,
    "cast": null,
    "genre": null
  },
  {
    "title": "Boarding School Girls' Pajama Parade",
    "year": 1900,
    "director": null,
    "cast": null,
    "genre": null
  },
  {
    "title": "Buffalo Bill's Wild West Parad",
    "year": 1900,
    "director": null,
    "cast": null,
    "genre": null
  },
  {
    "title": "Caught",
    "year": 1900,
    "director": null,
    "cast": null,
    "genre": null
  },
  {
    "title": "Clowns Spinning Hats",
    "year": 1900,
    "director": null,
    "cast": null,
    "genre": null
  },
  {
    "title": "Capture of Boer Battery by British",
    "year": 1900,
    "director": "James H. White",
    "cast": null,
    "genre": "Short documentary"
  },
  {
    "title": "The Enchanted Drawing",
    "year": 1900,
    "director": "J. Stuart Blackton",
    "cast": null,
    "genre": null
  },
  {
    "title": "Family Troubles",
    "year": 1900,
    "director": null,
    "cast": null,
    "genre": null
  },
  {
    "title": "Feeding Sea Lions",
    "year": 1900,
    "director": null,
    "cast": "Paul Boyton",
    "genre": null
  }
]</pre>			<p>The XML file, <strong class="source-inline">person.xml</strong>, contains<a id="_idIndexMarker101"/> information about <a id="_idIndexMarker102"/>individuals (<strong class="source-inline">firstName</strong>, <strong class="source-inline">lastName</strong>, <strong class="source-inline">gender</strong>, and so on), <span class="No-Break">as follows:</span></p>
			<ol>
				<li>We start with the enclosing tag of the <strong class="source-inline">persons</strong> <span class="No-Break">XML container:</span><pre class="source-code">
<strong class="bold">&lt;persons&gt;</strong></pre></li>				<li>Then, an XML element representing a person’s data code is presented <span class="No-Break">as follows:</span><pre class="source-code">
&lt;person&gt;
  &lt;firstName&gt;John&lt;/firstName&gt;
  &lt;lastName&gt;Smith&lt;/lastName&gt;
  &lt;age&gt;25&lt;/age&gt;
  &lt;address&gt;
    &lt;streetAddress&gt;21 2nd Street&lt;/streetAddress&gt;
    &lt;city&gt;New York&lt;/city&gt;
    &lt;state&gt;NY&lt;/state&gt;
    &lt;postalCode&gt;10021&lt;/postalCode&gt;
  &lt;/address&gt;
  &lt;phoneNumbers&gt;
    &lt;number type="home"&gt;212 555-1234&lt;/number&gt;
    &lt;number type="fax"&gt;646 555-4567&lt;/number&gt;
  &lt;/phoneNumbers&gt;
  &lt;gender&gt;
    &lt;type&gt;male&lt;/type&gt;
  &lt;/gender&gt;
&lt;/person&gt;</pre></li>				<li>An XML<a id="_idIndexMarker103"/> element representing another person’s<a id="_idIndexMarker104"/> data is shown by the <span class="No-Break">following code:</span><pre class="source-code">
&lt;person&gt;
  &lt;firstName&gt;Jimy&lt;/firstName&gt;
  &lt;lastName&gt;Liar&lt;/lastName&gt;
  &lt;age&gt;19&lt;/age&gt;
  &lt;address&gt;
    &lt;streetAddress&gt;18 2nd Street&lt;/streetAddress&gt;
    &lt;city&gt;New York&lt;/city&gt;
    &lt;state&gt;NY&lt;/state&gt;
    &lt;postalCode&gt;10021&lt;/postalCode&gt;
  &lt;/address&gt;
  &lt;phoneNumbers&gt;
    &lt;number type="home"&gt;212 555-1234&lt;/number&gt;
  &lt;/phoneNumbers&gt;
  &lt;gender&gt;
    &lt;type&gt;male&lt;/type&gt;
  &lt;/gender&gt;
&lt;/person&gt;</pre></li>				<li>An XML element representing a third person’s data is shown by the <span class="No-Break">following code:</span><pre class="source-code">
&lt;person&gt;
  &lt;firstName&gt;Patty&lt;/firstName&gt;
  &lt;lastName&gt;Liar&lt;/lastName&gt;
  &lt;age&gt;20&lt;/age&gt;
  &lt;address&gt;
    &lt;streetAddress&gt;18 2nd Street&lt;/streetAddress&gt;
    &lt;city&gt;New York&lt;/city&gt;
    &lt;state&gt;NY&lt;/state&gt;
    &lt;postalCode&gt;10021&lt;/postalCode&gt;
  &lt;/address&gt;
  &lt;phoneNumbers&gt;
    &lt;number type="home"&gt;212 555-1234&lt;/number&gt;
    &lt;number type="mobile"&gt;001 452-8819&lt;/number&gt;
  &lt;/phoneNumbers&gt;
  &lt;gender&gt;
    &lt;type&gt;female&lt;/type&gt;
  &lt;/gender&gt;
&lt;/person&gt;</pre></li>				<li>Finally, we close the <span class="No-Break">XML container:</span><pre class="source-code">
&lt;/persons&gt;</pre></li>			</ol>
			<p>We will <a id="_idIndexMarker105"/>use two libraries that are part of the Python distribution for <a id="_idIndexMarker106"/>working with JSON and XML: <strong class="source-inline">json</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">xml.etree.ElementTree</strong></span><span class="No-Break">.</span></p>
			<p>We start by importing what we need for the various manipulations (<strong class="source-inline">json</strong>, <strong class="source-inline">ElementTree</strong>, and <strong class="source-inline">pathlib</strong>), and we define a <strong class="source-inline">JSONDataExtractor</strong> class, loading the data from the file and using the <strong class="source-inline">parsed_data</strong> property to get it. That part of the code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
import json
import xml.etree.ElementTree as ET
from pathlib import Path
class JSONDataExtractor:
    def __init__(self, filepath: Path):
        self.data = {}
        with open(filepath) as f:
            self.data = json.load(f)
    @property
    def parsed_data(self):
        return self.data</pre>			<p>We also <a id="_idIndexMarker107"/>define an <strong class="source-inline">XMLDataExtractor</strong> class, loading the data in the <a id="_idIndexMarker108"/>file via <strong class="source-inline">ElementTree</strong>’s parser, and using the <strong class="source-inline">parsed_data</strong> property to get the result, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class XMLDataExtractor:
    def __init__(self, filepath: Path):
        self.tree = ET.parse(filepath)
    @property
    def parsed_data(self):
        return self.tree</pre>			<p>Now, we provide the factory function that helps select the right data extractor class depending on the target file’s extension (or raise an exception if it is not supported), <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
def extract_factory(filepath: Path):
    ext = filepath.name.split(".")[-1]
    if ext == "json":
        return JSONDataExtractor(filepath)
    elif ext == "xml":
        return XMLDataExtractor(filepath)
    else:
        raise ValueError("Cannot extract data")</pre>			<p>Next, we define the<a id="_idIndexMarker109"/> main function of our program, <strong class="source-inline">extract()</strong>; in the <a id="_idIndexMarker110"/>first part of the function, the code handles the JSON case, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
def extract(case: str):
    dir_path = Path(__file__).parent
    if case == "json":
        path = dir_path / Path("movies.json")
        factory = extract_factory(path)
        data = factory.parsed_data
        for movie in data:
            print(f"- {movie['title']}")
            director = movie["director"]
            if director:
                print(f"   Director: {director}")
            genre = movie["genre"]
            if genre:
                print(f"   Genre: {genre}")</pre>			<p>We add the<a id="_idIndexMarker111"/> final part of the <strong class="source-inline">extract()</strong> function, working with the <a id="_idIndexMarker112"/>XML file using the factory method. XPath is used to find all person elements that have the last name <strong class="source-inline">Liar</strong>. For each matched person, the basic name and phone number information are shown. The code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
    elif case == "xml":
        path = dir_path / Path("person.xml")
        factory = extract_factory(path)
        data = factory.parsed_data
        search_xpath = ".//person[lastName='Liar']"
        items = data.findall(search_xpath)
        for item in items:
            first = item.find("firstName").text
            last = item.find("lastName").text
            print(f"- {first} {last}")
            for pn in item.find("phoneNumbers"):
                pn_type = pn.attrib["type"]
                pn_val = pn.text
                phone = f"{pn_type}: {pn_val}"
                print(f"   {phone}")</pre>			<p>Finally, we add some <span class="No-Break">testing code:</span></p>
			<pre class="source-code">
if __name__ == "__main__":
    print("* JSON case *")
    extract(case="json")
    print("* XML case *")
    extract(case="xml")</pre>			<p>Here is a<a id="_idIndexMarker113"/> summary <a id="_idIndexMarker114"/>of the implementation (in the <span class="No-Break"><strong class="source-inline">ch03/factory/factory_method.py</strong></span><span class="No-Break"> file):</span></p>
			<ol>
				<li>After importing the modules we need, we start by defining a JSON data extractor class (<strong class="source-inline">JSONDataExtractor</strong>) and an XML data extractor <span class="No-Break">class (</span><span class="No-Break"><strong class="source-inline">XMLDataExtractor</strong></span><span class="No-Break">).</span></li>
				<li>We add a factory function, <strong class="source-inline">extract_factory()</strong>, to get the right data extractor class <span class="No-Break">to instantiate.</span></li>
				<li>We also add our wrapper and main <span class="No-Break">function, </span><span class="No-Break"><strong class="source-inline">extract()</strong></span><span class="No-Break">.</span></li>
				<li>Finally, we add testing code, where we extract data from a JSON file and an XML file and parse the <span class="No-Break">resulting text.</span></li>
			</ol>
			<p>To test the example, run the <span class="No-Break">following command:</span></p>
			<pre class="console">
python ch03/factory/factory_method.py</pre>			<p>You should get the <span class="No-Break">following output:</span></p>
			<pre class="console">
* JSON case *
- After Dark in Central Park
- Boarding School Girls' Pajama Parade
- Buffalo Bill's Wild West Parad
- Caught
- Clowns Spinning Hats
- Capture of Boer Battery by British
   Director: James H. White
   Genre: Short documentary
- The Enchanted Drawing
   Director: J. Stuart Blackton
- Family Troubles
- Feeding Sea Lions
* XML case *
- Jimy Liar
   home: 212 555-1234
- Patty Liar
   home: 212 555-1234
   mobile: 001 452-8819</pre>			<p>Notice that although <strong class="source-inline">JSONDataExtractor</strong> and <strong class="source-inline">XMLDataExtractor</strong> have the same interfaces, what is returned by <strong class="source-inline">parsed_data()</strong> is not handled in a uniform way; in one case we have a list, and in the other, we have a tree. Different Python code must be used to work with each data extractor. Although it would be nice to be able to use the same code for all extractors, this is not realistic for the most part unless we use some kind of common mapping for the data, which is often provided by external data providers. Assuming<a id="_idIndexMarker115"/> that you can use the same code for handling the <a id="_idIndexMarker116"/>XML and JSON files, what changes are required to support a third format—for example, SQLite? Find an SQLite file or create your own and <span class="No-Break">try it.</span></p>
			<h3>Should you use the factory method pattern?</h3>
			<p>The main critique that veteran Python developers often express toward the factory method pattern is that it can be considered over-engineered or unnecessarily complex for many use cases. Python’s dynamic typing and first-class functions often allow for simpler, more straightforward solutions to problems that the factory method aims to solve. In Python, you can often use simple functions or class methods to create objects directly without needing to create separate factory classes or functions. This keeps the code more readable and Pythonic, adhering to the language’s philosophy of <em class="italic">Simple is better </em><span class="No-Break"><em class="italic">than complex</em></span><span class="No-Break">.</span></p>
			<p>Also, Python’s support for default arguments, keyword arguments, and other language features often makes it easier to extend constructors in a backward-compatible way, reducing the need for separate factory methods. So, while the factory method pattern is a well-established design pattern in statically typed languages such as Java or C++, it is often seen as too cumbersome or verbose for Python’s more flexible and <span class="No-Break">dynamic nature.</span></p>
			<p>To show how one could deal with simple use cases without the factory method pattern, an alternative implementation has been provided in the <strong class="source-inline">ch03/factory/factory_method_not_needed.py</strong> file. As<a id="_idTextAnchor066"/> you can see, there is no more factory. And the following extract from the code shows what we mean when we say that in Python, you just create objects where you need them, without an intermediary function <a id="_idIndexMarker117"/>or class, which makes your code <span class="No-Break">more Pythonic:</span></p>
			<pre class="source-code">
if case == "json":
    path = dir_path / Path("movies.json")
    data = JSONDataExtractor(path).parsed_data</pre>			<h2 id="_idParaDest-64"><a id="_idTextAnchor067"/>The abstract factory pattern</h2>
			<p>The abstract factory <a id="_idIndexMarker118"/>pattern<a id="_idIndexMarker119"/> is a generalization of the factory method idea. Basically, an abstract factory is a (logical) group of factory methods, where each factory method is responsible for generating a different kind <span class="No-Break">of object.</span></p>
			<p>We are going to discuss some examples, use cases, and a <span class="No-Break">possible implementation.</span></p>
			<h3>Real-world examples</h3>
			<p>The abstract factory is used in car <a id="_idIndexMarker120"/>manufacturing. The same machinery is used for stamping the parts (doors, panels, hoods, fenders, and mirrors) of different car models. The model that is assembled by the machinery is configurable and easy to change at <span class="No-Break">any time.</span></p>
			<p>In the software category, the <strong class="source-inline">factory_boy</strong> package (<a href="https://github.com/FactoryBoy/factory_boy">https://github.com/FactoryBoy/factory_boy</a>) provides an abstract factory implementation for creating Django models in tests. An alternative tool is <strong class="source-inline">model_bakery</strong> (<a href="https://github.com/model-bakers/model_bakery">https://github.com/model-bakers/model_bakery</a>). Both packages are used for creating instances of models that support test-specific attributes. This is important because, this way, the readability of your tests is improved, and you avoid sharing <span class="No-Break">unnecessary </span><span class="No-Break"><a id="_idIndexMarker121"/></span><span class="No-Break">code.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Django models are special classes used by the framework to help store and interact with data in the database (tab<a href="https://docs.djangoproject.com">les). See the Django documenta</a>tion (<a href="https://docs.djangoproject.com">https://docs.djangoproject.com</a>) for <span class="No-Break">more details.</span></p>
			<h3>Use cases for the abstract factory pattern</h3>
			<p>Since the abstract<a id="_idIndexMarker122"/> factory pattern is a generalization of the <a id="_idIndexMarker123"/>factory method pattern, it offers the same benefits: it makes tracking an object creation easier, it decouples object creation from object usage, and it gives us the potential to improve the memory usage and performance of <span class="No-Break">our application.</span></p>
			<h3>Implementing the abstract factory pattern</h3>
			<p>To demonstrate<a id="_idIndexMarker124"/> the abstract factory pattern, I will reuse one of my favorite examples, included in the book <em class="italic">Python 3 Patterns, Recipes and Idioms</em>, by Bruce Eckel. Imagine that we are creating a game or we want to include a mini-game as part of our application to entertain our users. We want to include at least two games, one for children and one for adults. We will decide which game to create and launch at runtime, based on user input. An abstract factory takes care of the game <span class="No-Break">creation part.</span></p>
			<p>Let’s start with the kids’ game. It is <a id="_idIndexMarker125"/>called <strong class="bold">FrogWorld</strong>. The main hero is a frog who enjoys eating bugs. Every hero needs a good name, and in our case, the name is given by the user at runtime. The <strong class="source-inline">interact_with()</strong> method is used to describe the interaction of the frog with an obstacle (for example, a bug, puzzle, and other frogs) <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class Frog:
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return self.name
    def interact_with(self, obstacle):
        act = obstacle.action()
        msg = f"{self} the Frog encounters {obstacle} and {act}!"
        print(msg)</pre>			<p>There can be many kinds of obstacles, but for our example, an obstacle can only be a bug. When the frog encounters a bug, only one action is supported. It <span class="No-Break">eats it:</span></p>
			<pre class="source-code">
class Bug:
    def __str__(self):
        return "a bug"
    def action(self):
        return "eats it"</pre>			<p>The <strong class="source-inline">FrogWorld</strong> class is an<a id="_idIndexMarker126"/> abstract factory. Its main <a id="_idIndexMarker127"/>responsibilities are creating the main character and the obstacle(s) in the game. Keeping the creation methods separate and their names generic (for example, <strong class="source-inline">make_character()</strong> and <strong class="source-inline">make_obstacle()</strong>) allows us to change the active factory (and, therefore, the active game) dynamically without any code changes. The code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class FrogWorld:
    def __init__(self, name):
        print(self)
        self.player_name = name
    def __str__(self):
        return "\n\n\t------ Frog World -------"
    def make_character(self):
        return Frog(self.player_name)
    def make_obstacle(self):
        return Bug()</pre>			<p>The <strong class="bold">WizardWorld</strong> game<a id="_idIndexMarker128"/> is similar. The <a id="_idIndexMarker129"/>only difference is <a id="_idIndexMarker130"/>that the wizard battles against monsters such as orks instead of <span class="No-Break">eating bugs!</span></p>
			<p>Here is the definition of the <strong class="source-inline">Wizard</strong> class, which is similar to the <span class="No-Break"><strong class="source-inline">Frog</strong></span><span class="No-Break"> one:</span></p>
			<pre class="source-code">
class Wizard:
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return self.name
    def interact_with(self, obstacle):
        act = obstacle.action()
        msg = f"{self} the Wizard battles against {obstacle} and {act}!"
        print(msg)</pre>			<p>Then, the definition of the <strong class="source-inline">Ork</strong> class is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class Ork:
    def __str__(self):
        return "an evil ork"
    def action(self):
        return "kills it"</pre>			<p>We also need to<a id="_idIndexMarker131"/> define a <strong class="source-inline">WizardWorld</strong> class, similar to the <strong class="source-inline">FrogWorld</strong> one that we have discussed; the<a id="_idIndexMarker132"/> obstacle, in this case, is an <span class="No-Break"><strong class="source-inline">Ork</strong></span><span class="No-Break"> instance:</span></p>
			<pre class="source-code">
class WizardWorld:
    def __init__(self, name):
        print(self)
        self.player_name = name
    def __str__(self):
        return "\n\n\t------ Wizard World -------"
    def make_character(self):
        return Wizard(self.player_name)
    def make_obstacle(self):
        return Ork()</pre>			<p>The <strong class="source-inline">GameEnvironment</strong> class is the main entry point of our game. It accepts the factory as an input and uses it to create the world of the game. The <strong class="source-inline">play()</strong> method initiates the interaction between the created hero and the obstacle, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class GameEnvironment:
    def __init__(self, factory):
        self.hero = factory.make_character()
        self.obstacle = factory.make_obstacle()
    def play(self):
        self.hero.interact_with(self.obstacle)</pre>			<p>The <strong class="source-inline">validate_age()</strong> function <a id="_idIndexMarker133"/>prompts the user to give a valid age. If<a id="_idIndexMarker134"/> the age is not valid, it returns a tuple with the first element set to <strong class="source-inline">False</strong>. If the age is fine, the first element of the tuple is set to <strong class="source-inline">True</strong>, and that’s the case where we care about the second element of the tuple, which is the age given by the user, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
def validate_age(name):
    age = None
    try:
        age_input = input(
            f"Welcome {name}. How old are you? "
        )
        age = int(age_input)
    except ValueError:
        print(
            f"Age {age} is invalid, please try again..."
        )
        return False, age
    return True, age</pre>			<p>Finally <a id="_idIndexMarker135"/>comes the <strong class="source-inline">main()</strong> function definition, followed <a id="_idIndexMarker136"/>by calling it. It asks for the user’s name and age and decides which game should be played, given the age of the user, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
def main():
    name = input("Hello. What's your name? ")
    valid_input = False
    while not valid_input:
        valid_input, age = validate_age(name)
    game = FrogWorld if age &lt; 18 else WizardWorld
    environment = GameEnvironment(game(name))
    environment.play()
if __name__ == "__main__":
    main()</pre>			<p>The summary for the implementation we just discussed (see the complete code in the <strong class="source-inline">ch03/factory/abstract_factory.py</strong> file) is <span class="No-Break">as follows:</span></p>
			<ol>
				<li>We define <strong class="source-inline">Frog</strong> and <strong class="source-inline">Bug</strong> classes for <a id="_idIndexMarker137"/>the <span class="No-Break"><strong class="bold">FrogWorld</strong></span><span class="No-Break"> game.</span></li>
				<li>We add a <strong class="source-inline">FrogWorld</strong> class, where we use our <strong class="source-inline">Frog</strong> and <span class="No-Break"><strong class="source-inline">Bug</strong></span><span class="No-Break"> classes.</span></li>
				<li>We define <strong class="source-inline">Wizard</strong> and <strong class="source-inline">Ork</strong> classes for<a id="_idIndexMarker138"/> the <span class="No-Break"><strong class="bold">WizardWorld</strong></span><span class="No-Break"> game.</span></li>
				<li>We add a <strong class="source-inline">WizardWorld</strong> class, where we use our <strong class="source-inline">Wizard</strong> and <span class="No-Break"><strong class="source-inline">Ork</strong></span><span class="No-Break"> classes.</span></li>
				<li>We define a <span class="No-Break"><strong class="source-inline">GameEnvironment</strong></span><span class="No-Break"> class.</span></li>
				<li>We add a <span class="No-Break"><strong class="source-inline">validate_age()</strong></span><span class="No-Break"> function.</span></li>
				<li>Finally, we have the <strong class="source-inline">main()</strong> function, followed by the conventional trick for calling it. The following are the aspects of <span class="No-Break">this function:</span><ul><li>We get the user’s input for name <span class="No-Break">and age.</span></li><li>We decide which game class to use based on the <span class="No-Break">user’s age.</span></li><li>We instantiate the right game class, and then the <span class="No-Break"><strong class="source-inline">GameEnvironment</strong></span><span class="No-Break"> class.</span></li><li>We call <strong class="source-inline">.play()</strong> on the <strong class="source-inline">environment</strong> object to play <span class="No-Break">the game.</span></li></ul></li>
			</ol>
			<p>Let’s call this<a id="_idIndexMarker139"/> program<a id="_idIndexMarker140"/> using the <strong class="source-inline">python ch03/factory/abstract_factory.py</strong> command and see some <span class="No-Break">sample output.</span></p>
			<p>The sample output for a teenager is <span class="No-Break">as follows:</span></p>
			<pre class="console">
Hello. What's your name? Arthur
Welcome Arthur. How old are you? 13
------ Frog World -------
Arthur the Frog encounters a bug and eats it!</pre>			<p>The sample output for an adult is <span class="No-Break">as follows:</span></p>
			<pre class="console">
Hello. What's your name? Tom
Welcome Tom. How old are you? 34
------ Wizard World -------
Tom the Wizard battles against an evil ork and kills it!</pre>			<p>Try extending the game to make it more complete. You can go as far as you want; create many obstacles, many enemies, and whatever else <span class="No-Break">you like.</span></p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor068"/>The builder pattern</h1>
			<p>We just covered <a id="_idIndexMarker141"/>the first two creational patterns, the factory method and the abstract factory, which both offer <a id="_idIndexMarker142"/>approaches to improve the way we create objects in <span class="No-Break">nontrivial cases.</span></p>
			<p>Now, imagine that we want to create an object that is composed of multiple parts, and the composition needs to be done step by step. The object is not complete unless all its parts are fully created. That’s where the builder design pattern can help us. The builder pattern separates the construction of a complex object from its representation. By keeping the construction separate from the representation, the same construction can be used to create several <span class="No-Break">different representations.</span></p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor069"/>Real-world examples</h2>
			<p>In our everyday life, the builder<a id="_idIndexMarker143"/> design pattern is used in fast-food restaurants. The same procedure is always used to prepare a burger and the packaging (box and paper bag), even if there are many kinds of burgers (classic, cheeseburger, and more) and different packages (small-sized box, medium-sized box, and so forth). The difference between a classic burger and a cheeseburger is in the representation and not in the construction procedure. In this case, the director is the cashier who gives instructions about what needs to be prepared to the crew, and the builder is the person from the crew who takes care of the <span class="No-Break">specific order.</span></p>
			<p>In so<a href="https://github.com/ambitioninc/django-query-builder">ftware, we can think of the <strong class="source-inline">django-query-builder</strong> li</a>brary (<a href="https://github.com/ambitioninc/django-query-builder">https://github.com/ambitioninc/django-query-builder</a>), a third-party Django library that relies on the builder pattern. This library can be used for building SQL queries dynamically, allowing you to control all aspects of a query and create a different range of queries, from<a id="_idIndexMarker144"/> simple to very <span class="No-Break">complex ones.</span></p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor070"/>Comparison with the factory pattern</h2>
			<p>At this point, the <a id="_idIndexMarker145"/>distinction between the <a id="_idIndexMarker146"/>builder pattern and the factory pattern might not be very clear. The main difference is that a factory pattern creates an object in a single step, whereas a builder pattern creates an object in multiple steps and almost always uses <span class="No-Break">a </span><span class="No-Break"><em class="italic">director</em></span><span class="No-Break">.</span></p>
			<p>Another difference is that<a id="_idIndexMarker147"/> while the factory pattern returns a <a id="_idIndexMarker148"/>created object immediately, in the builder pattern, the client code explicitly asks the director to return the final object when it <span class="No-Break">needs it.</span></p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor071"/>Use cases for the builder pattern</h2>
			<p>The builder pattern is <a id="_idIndexMarker149"/>particularly useful when an object needs to be constructed with numerous possible configurations. A typical case is a situation where a class has multiple constructors with a varying number of parameters, often leading to confusion or <span class="No-Break">error-prone code.</span></p>
			<p>The pattern is also beneficial when the object’s construction process is more complex than simply setting initial values. For example, if an object’s full creation involves multiple steps, such as parameter validation, setting up data structures, or even making calls to external services, the builder pattern can encapsulate <span class="No-Break">this complexity.</span></p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor072"/>Implementing the builder pattern</h2>
			<p>Let’s see how we can use<a id="_idIndexMarker150"/> the builder design pattern to make a pizza-ordering application. This example is particularly interesting because a pizza is prepared in steps that should follow a specific order. To add the sauce, you first need to <a id="_idIndexMarker151"/>prepare the dough. To add the topping, you first need to add the sauce. And you can’t start baking the pizza unless both the sauce and the topping are placed on the dough. Moreover, each pizza usually requires a different baking time, depending on the thickness of its dough and the <span class="No-Break">topping used.</span></p>
			<p>We start <a id="_idIndexMarker152"/>by importing the required modules and declaring a few <strong class="source-inline">Enum</strong> parameters plus a constant that is used many times in the application. The <strong class="source-inline">STEP_DELAY</strong> constant is used to add a time delay between the different steps of preparing a pizza (prepare the dough, add the sauce, and so on) <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
import time
from enum import Enum
PizzaProgress = Enum(
    "PizzaProgress", "queued preparation baking ready"
)
PizzaDough = Enum("PizzaDough", "thin thick")
PizzaSauce = Enum("PizzaSauce", "tomato creme_fraiche")
PizzaTopping = Enum(
    "PizzaTopping",
    "mozzarella double_mozzarella bacon ham mushrooms red_onion oregano",
)
# Delay in seconds
STEP_DELAY = 3</pre>			<p>Our end product is a pizza, which is described by the <strong class="source-inline">Pizza</strong> class. When using the builder pattern, the end product does not have many responsibilities, since it is not supposed to be instantiated directly. A builder creates an instance of the end product and makes sure that it is properly prepared. That’s why the <strong class="source-inline">Pizza</strong> class is so minimal. It basically initializes all data to sane default values. An exception is the <span class="No-Break"><strong class="source-inline">prepare_dough()</strong></span><span class="No-Break"> method.</span></p>
			<p>The <strong class="source-inline">prepare_dough()</strong> method is defined in the <strong class="source-inline">Pizza</strong> class instead of a builder for two reasons. First, to <a id="_idIndexMarker153"/>clarify the fact that the end product is typically minimal, which <a id="_idIndexMarker154"/>does not mean that you should never assign it any responsibilities. Second, to promote code reuse <span class="No-Break">through composition.</span></p>
			<p>So, we define our <strong class="source-inline">Pizza</strong> class <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class Pizza:
    def __init__(self, name):
        self.name = name
        self.dough = None
        self.sauce = None
        self.topping = []
    def __str__(self):
        return self.name
    def prepare_dough(self, dough):
        self.dough = dough
        print(
            f"preparing the {self.dough.name} dough of your {self}..."
        )
        time.sleep(STEP_DELAY)
        print(f"done with the {self.dough.name} dough")</pre>			<p>There are two builders: one for creating a margarita pizza (<strong class="source-inline">MargaritaBuilder</strong>) and another for creating a creamy bacon pizza (<strong class="source-inline">CreamyBaconBuilder</strong>). Each builder creates a <strong class="source-inline">Pizza</strong> instance and contains methods that follow the pizza-making procedure: <strong class="source-inline">prepare_dough()</strong>, <strong class="source-inline">add_sauce()</strong>, <strong class="source-inline">add_topping()</strong>, and <strong class="source-inline">bake()</strong>. To be precise, <strong class="source-inline">prepare_dough()</strong> is just a wrapper to the <strong class="source-inline">prepare_dough()</strong> method of the <span class="No-Break"><strong class="source-inline">Pizza</strong></span><span class="No-Break"> class.</span></p>
			<p>Notice how each builder takes care of all the pizza-specific details. For example, the topping of the margarita pizza is double mozzarella and oregano, while the topping of the creamy bacon pizza is mozzarella, bacon, ham, mushrooms, red onion, <span class="No-Break">and oregano.</span></p>
			<p>An extract of <a id="_idIndexMarker155"/>the code of the <strong class="source-inline">MargaritaBuilder</strong> class is<a id="_idIndexMarker156"/> as follows (see the <strong class="source-inline">ch03/builder.py</strong> file for the <span class="No-Break">whole code):</span></p>
			<pre class="source-code">
class MargaritaBuilder:
    def __init__(self):
        self.pizza = Pizza("margarita")
        self.progress = PizzaProgress.queued
        self.baking_time = 5
    def prepare_dough(self):
        self.progress = PizzaProgress.preparation
        self.pizza.prepare_dough(PizzaDough.thin)
    ...</pre>			<p>An extract of the code of the <strong class="source-inline">CreamyBaconBuilder</strong> class is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class CreamyBaconBuilder:
    def __init__(self):
        self.pizza = Pizza("creamy bacon")
        self.progress = PizzaProgress.queued
        self.baking_time = 7
    def prepare_dough(self):
        self.progress = PizzaProgress.preparation
        self.pizza.prepare_dough(PizzaDough.thick)
    ...</pre>			<p>The <em class="italic">director</em> in this <a id="_idIndexMarker157"/>example is the waiter. The core of the <strong class="source-inline">Waiter</strong> class is<a id="_idIndexMarker158"/> the <strong class="source-inline">construct_pizza()</strong> method, which accepts a builder as a parameter and executes all the pizza-preparation steps in the right order. Choosing the appropriate builder, which can even be done at runtime, gives us the ability to create different pizza styles without modifying any of the code of the director (<strong class="source-inline">Waiter</strong>). The <strong class="source-inline">Waiter</strong> class also contains the <strong class="source-inline">pizza()</strong> method, which returns the end product (prepared pizza) as a variable to the caller. The <a id="_idIndexMarker159"/>code for<a id="_idIndexMarker160"/> that class is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class Waiter:
    def __init__(self):
        self.builder = None
    def construct_pizza(self, builder):
        self.builder = builder
        steps = (
            builder.prepare_dough,
            builder.add_sauce,
            builder.add_topping,
            builder.bake,
        )
        [step() for step in steps]
    @property
    def pizza(self):
        return self.builder.pizza</pre>			<p>The <strong class="source-inline">validate_style()</strong> method is similar to the <strong class="source-inline">validate_age()</strong> function, as described in the section titled <em class="italic">The factory pattern</em> earlier in this chapter. It is used to make sure that the user gives valid input, which in this case is a character that is mapped to a pizza builder. The <strong class="source-inline">m</strong> character uses the <strong class="source-inline">MargaritaBuilder</strong> class, and the <strong class="source-inline">c</strong> character uses the <strong class="source-inline">CreamyBaconBuilder</strong> class. These mappings are in the <strong class="source-inline">builder</strong> parameter. A tuple is returned, with the first element set to <strong class="source-inline">True</strong> if the<a id="_idIndexMarker161"/> input is<a id="_idIndexMarker162"/> valid or <strong class="source-inline">False</strong> if it is invalid, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
def validate_style(builders):
    try:
        input_msg = "What pizza would you like, [m]argarita or [c]reamy bacon? "
        pizza_style = input(input_msg)
        builder = builders[pizza_style]()
        valid_input = True
    except KeyError:
        error_msg = "Sorry, only margarita (key m) and creamy bacon (key c) are available"
        print(error_msg)
        return (False, None)
    return (True, builder)</pre>			<p>The last part is the <strong class="source-inline">main()</strong> function. The <strong class="source-inline">main()</strong> function contains code for instantiating a pizza builder. The pizza builder is then used by the <strong class="source-inline">Waiter</strong> director to prepare the pizza. The created pizza <a id="_idIndexMarker163"/>can be delivered to the client at any <span class="No-Break">later point:</span></p>
			<pre class="source-code">
def main():
    builders = dict(m=MargaritaBuilder, c=CreamyBaconBuilder)
    valid_input = False
    while not valid_input:
        valid_input, builder = validate_style(builders)
    print()
    waiter = Waiter()
    waiter.construct_pizza(builder)
    pizza = waiter.pizza
    print()
    print(f"Enjoy your {pizza}!")</pre>			<p>Here is a<a id="_idIndexMarker164"/> summary of the implementation (in the <span class="No-Break"><strong class="source-inline">ch03/builder.py</strong></span><span class="No-Break"> file):</span></p>
			<ol>
				<li>We start with a couple of imports we need, for the standard <strong class="source-inline">Enum</strong> class and <span class="No-Break"><strong class="source-inline">time</strong></span><span class="No-Break"> module.</span></li>
				<li>We declare variables for<a id="_idIndexMarker165"/> a few constants: <strong class="source-inline">PizzaProgress</strong>, <strong class="source-inline">PizzaDough</strong>, <strong class="source-inline">PizzaSauce</strong>, <strong class="source-inline">PizzaTopping</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">STEP_DELAY</strong></span><span class="No-Break">.</span></li>
				<li>We define our <span class="No-Break"><strong class="source-inline">Pizza</strong></span><span class="No-Break"> class.</span></li>
				<li>We define classes for two builders, <strong class="source-inline">MargaritaBuilder</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">CreamyBaconBuilder</strong></span><span class="No-Break">.</span></li>
				<li>We define our <span class="No-Break"><strong class="source-inline">Waiter</strong></span><span class="No-Break"> class.</span></li>
				<li>We add a <strong class="source-inline">validate_style()</strong> function to improve things regarding <span class="No-Break">exception handling.</span></li>
				<li>Finally, we have the <strong class="source-inline">main()</strong> function, followed by a snippet for calling it when the program is run. In the <strong class="source-inline">main()</strong> function, the <span class="No-Break">following happens:</span><ul><li>We make it possible to choose the pizza builder based on the user’s input, after validation via the <span class="No-Break"><strong class="source-inline">validate_style()</strong></span><span class="No-Break"> function.</span></li><li>The pizza builder is used by the waiter for preparing <span class="No-Break">the pizza.</span></li><li>The created pizza is <span class="No-Break">then delivered.</span></li></ul></li>
			</ol>
			<p>Here is the output<a id="_idIndexMarker166"/> produced by calling the <strong class="source-inline">python ch03/builder.py</strong> command to execute this <span class="No-Break">example program:</span></p>
			<pre class="console">
What pizza would you like, [m]argarita or [c]reamy bacon? c
preparing the thick dough of your creamy bacon...
done with the thick dough
adding the crème fraîche sauce to your creamy bacon
done with the crème fraîche sauce
adding the topping (mozzarella, bacon, ham, mushrooms, red onion, oregano) to your creamy bacon
done with the topping (mozzarella, bacon, ham, mushrooms, red onion, oregano)
baking your creamy bacon for 7 seconds
your creamy bacon is ready
Enjoy your creamy bacon!</pre>			<p>That was a <span class="No-Break">nice result.</span></p>
			<p>But... supporting<a id="_idIndexMarker167"/> only two pizza types is a shame. Feel like getting <a id="_idIndexMarker168"/>a Hawaiian pizza builder? Consider using <em class="italic">inheritance</em> after thinking about the advantages and disadvantages. Or <em class="italic">composition</em>, which has its advantages, as we have seen in <a href="B21896_01.xhtml#_idTextAnchor017"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Foundational </em><span class="No-Break"><em class="italic">Design Principles</em></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor073"/>The prototype pattern</h1>
			<p>The prototype pattern<a id="_idIndexMarker169"/> allows you to create new objects by copying existing ones, rather<a id="_idIndexMarker170"/> than creating them from scratch. This pattern is particularly useful when the cost of initializing an object is more expensive or complex than copying an existing one. In essence, the prototype pattern enables you to create a new instance of a class by duplicating an existing instance, thereby avoiding the overhead of initializing a <span class="No-Break">new object.</span></p>
			<p>In its simplest version, this pattern is just a <strong class="source-inline">clone()</strong> function that accepts an object as an input parameter and returns a clone of it. In Python, this can be done using the <span class="No-Break"><strong class="source-inline">copy.deepcopy()</strong></span><span class="No-Break"> function.</span></p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor074"/>Real-world examples</h2>
			<p>Cloning a plant by taking a<a id="_idIndexMarker171"/> cutting is a real-world example of the prototype pattern. Using this approach, you don’t grow the plant from a seed; you create a new plant that’s a copy of an <span class="No-Break">existing one.</span></p>
			<p>Many Python applications make use of the prototype pattern, but it is rarely referred to as <em class="italic">prototype</em> since cloning objects is a built-in feature of the <span class="No-Break">Python language.</span></p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor075"/>Use cases for the prototype pattern</h2>
			<p>The prototype pattern is <a id="_idIndexMarker172"/>useful when we have an existing object that needs to <a id="_idIndexMarker173"/>stay untouched and we want to create an exact copy of it, allowing changes in some parts of <span class="No-Break">the copy.</span></p>
			<p>There is also the frequent need for duplicating an object that is populated from a database and has references to other database-based objects. It is costly (multiple queries to a database) to clone such a complex object, so a prototype is a convenient way to solve <span class="No-Break">the problem.</span></p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor076"/>Implementing the prototype pattern</h2>
			<p>Nowadays, some<a id="_idIndexMarker174"/> organizations, even of small size, deal with many websites and apps via their infrastructure/DevOps teams, hosting <a id="_idIndexMarker175"/>providers, or <strong class="bold">cloud service </strong><span class="No-Break"><strong class="bold">providers</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">CSPs</strong></span><span class="No-Break">).</span></p>
			<p>When you have to manage multiple websites, there is a point where it becomes difficult to follow. You need to access information quickly, such as IP addresses that are involved, domain names and their expiration dates, and maybe details about DNS parameters. So, you need a kind of <span class="No-Break">inventory tool.</span></p>
			<p>Let’s imagine how these teams deal with this type of data for daily activities, and touch on the implementation of a piece of software that helps consolidate and maintain the data (other than in <span class="No-Break">Excel spreadsheets).</span></p>
			<p>First, we need to import Python’s standard <strong class="source-inline">copy</strong> module, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
import copy</pre>			<p>At the heart of this system, we will have a <strong class="source-inline">Website</strong> class for holding all useful information such as the name, the domain name, a description, the author of a website we are managing, and <span class="No-Break">so on.</span></p>
			<p>In the <strong class="source-inline">__init__()</strong> method of the class, only some parameters are fixed: <strong class="source-inline">name</strong>, <strong class="source-inline">domain</strong>, and <strong class="source-inline">description</strong>. But we also want flexibility, and client code can pass more parameters in the form of keywords (<strong class="source-inline">name=value</strong>) using the <strong class="source-inline">kwargs</strong> variable-length collection (each pair becomes an item of the <strong class="source-inline">kwargs</strong> <span class="No-Break">Python dictionary).</span></p>
			<p class="callout-heading">Additional information</p>
			<p class="callout">There is a Python idiom that helps to set an arbitrary attribute named <strong class="source-inline">attr</strong> with a <strong class="source-inline">val</strong> value on an <strong class="source-inline">obj</strong> object, using the <strong class="source-inline">setattr()</strong> built-in function: <strong class="source-inline">setattr(obj, </strong><span class="No-Break"><strong class="source-inline">attr, val)</strong></span><span class="No-Break">.</span></p>
			<p>So we are <a id="_idIndexMarker176"/>defining a <strong class="source-inline">Website</strong> class and initializing its objects, using the <strong class="source-inline">setattr</strong> technique for optional<a id="_idIndexMarker177"/> attributes, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class Website:
    def __init__(
        self,
        name: str,
        domain: str,
        description: str,
        **kwargs,
    ):
        self.name = name
        self.domain = domain
        self.description = description
        for key in kwargs:
            setattr(self, key, kwargs[key])</pre>			<p>That’s not<a id="_idIndexMarker178"/> all. To improve the usability of the class, we also add its <a id="_idIndexMarker179"/>string representation method (<strong class="source-inline">__str__()</strong>). We extract the values of all instance attributes, using the <strong class="source-inline">vars()</strong> trick, and inject those values into the string that the method returns. Also, since we plan to clone objects, we include the object’s memory address using the <strong class="source-inline">id()</strong> function. The code i<a id="_idTextAnchor077"/>s <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
def __str__(self) -&gt; str:
    summary = [
        f"- {self.name} (ID: {id(self)})\n",
    ]
    infos = vars(self).items()
    ordered_infos = sorted(infos)
    for attr, val in ordered_infos:
        if attr == "name":
            continue
        summary.append(f"{attr}: {val}\n")
    return "".join(summary)</pre>			<p class="callout-heading">Additional information</p>
			<p class="callout">The <strong class="source-inline">vars()</strong> function in Python returns the <strong class="source-inline">__dict__</strong> attribute of an object. The <strong class="source-inline">__dict__</strong> attribute is a dictionary containing the object’s attributes (both data attributes and methods). This function is useful for debugging, as it allows you to inspect the attributes and methods of an object or the local variables within a function. But note that not all objects have a <strong class="source-inline">__dict__</strong> attribute. For example, built-in types such as lists and dictionaries do not have <span class="No-Break">this attribute.</span></p>
			<p>Next, we <a id="_idIndexMarker180"/>add a <strong class="source-inline">Prototype</strong> class that implements the prototype design pattern. At the heart of this class, we have the <strong class="source-inline">clone()</strong> method, which is in charge of cloning the object using the <span class="No-Break"><strong class="source-inline">copy.deepcopy()</strong></span><span class="No-Break"> function.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">When we clone an object using <strong class="source-inline">copy.deepcopy()</strong>, the memory address of the clone must be different from the memory address of the <span class="No-Break">original object.</span></p>
			<p>Since cloning means <a id="_idIndexMarker181"/>that we allow setting values for optional attributes, notice how we use the <strong class="source-inline">setattr</strong> technique here with the <strong class="source-inline">attrs</strong> dictionary. Also, for more convenience, the <strong class="source-inline">Prototype</strong> class contains the <strong class="source-inline">register()</strong> and <strong class="source-inline">unregister()</strong> methods, which can be used to keep track of the cloned objects in a registry (a dictionary). The code of that class is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class Prototype:
    def __init__(self):
        self.registry = {}
    def register(self, identifier: int, obj: object):
        self.registry[identifier] = obj
    def unregister(self, identifier: int):
        del self.registry[identifier]
    def clone(self, identifier: int, **attrs) -&gt; object:
        found = self.registry.get(identifier)
        if not found:
            raise ValueError(
              f"Incorrect object identifier: {identifier}"
            )
        obj = copy.deepcopy(found)
        for key in attrs:
            setattr(obj, key, attrs[key])
        return obj</pre>			<p>In the <strong class="source-inline">main()</strong> function, which we define next, we complete the program: we clone a first <strong class="source-inline">Website</strong> instance, <strong class="source-inline">site1</strong>, to get a second object <strong class="source-inline">site2</strong>. Basically, we instantiate the <strong class="source-inline">Prototype</strong> class and <a id="_idIndexMarker182"/>we use its <strong class="source-inline">.clone()</strong> method. Then, we display the result. The<a id="_idIndexMarker183"/> code for that function is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
def main():
    keywords = (
        "python",
        "programming",
        "scripting",
        "data",
        "automation",
    )
    site1 = Website(
        "Python",
        domain="python.org",
        description="Programming language and ecosystem",
        category="Open Source Software",
        keywords=keywords,
    )
    proto = Prototype()
    proto.register("python-001", site1)
    site2 = proto.clone(
        "python-001",
        name="Python Package Index",
        domain="pypi.org",
        description="Repository for published packages",
        category="Open Source Software",
    )
    for site in (site1, site2):
        print(site)</pre>			<p>Finally, we call the <strong class="source-inline">main()</strong> function, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
if __name__ == "__main__":
    main()</pre>			<p>Here is a <a id="_idIndexMarker184"/>summary of <a id="_idIndexMarker185"/>what we do in the <span class="No-Break">code (</span><span class="No-Break"><strong class="source-inline">ch03/prototype.py</strong></span><span class="No-Break">):</span></p>
			<ol>
				<li>We start by importing the <span class="No-Break"><strong class="source-inline">copy</strong></span><span class="No-Break"> module.</span></li>
				<li>We define a <strong class="source-inline">Website</strong> class, with its initialization method (<strong class="source-inline">__init__()</strong>) and its string representation <span class="No-Break">method (</span><span class="No-Break"><strong class="source-inline">__str__()</strong></span><span class="No-Break">).</span></li>
				<li>We define our <strong class="source-inline">Prototype</strong> class as <span class="No-Break">shown earlier.</span></li>
				<li>Then, we have the <strong class="source-inline">main()</strong> function, where we do <span class="No-Break">the following:</span><ul><li>We define a <strong class="source-inline">keywords</strong> list <span class="No-Break">we need.</span></li><li>We create an instance of the <strong class="source-inline">Website</strong> class, called <strong class="source-inline">site1</strong> (we use the <strong class="source-inline">keywords</strong> <span class="No-Break">list here).</span></li><li>We create a <strong class="source-inline">Prototype</strong> object and we use its <strong class="source-inline">register()</strong> method to register <strong class="source-inline">site1</strong> with its identifier (this helps us keep track of the cloned objects in <span class="No-Break">a dictionary).</span></li><li>We clone the <strong class="source-inline">site1</strong> object to <span class="No-Break">get </span><span class="No-Break"><strong class="source-inline">site2</strong></span><span class="No-Break">.</span></li><li>We display the result (both <span class="No-Break"><strong class="source-inline">Website</strong></span><span class="No-Break"> objects).</span></li></ul></li>
			</ol>
			<p>A sample output when I<a id="_idIndexMarker186"/> execute the <strong class="source-inline">python ch03/prototype.py</strong> command<a id="_idIndexMarker187"/> on my computer is <span class="No-Break">as follows:</span></p>
			<pre class="console">
- Python (ID: 4369628560)
category: Open Source Software
description: Programming language and ecosystem
domain: python.org
keywords: ('python', 'programming', 'scripting', 'data', 'automation')
- Python Package Index (ID: 4369627552)
category: Open Source Software
description: Repository site for Python's published packages
domain: pypi.org
keywords: ('python', 'programming', 'scripting', 'data', 'automation')</pre>			<p>Indeed, <strong class="source-inline">Prototype</strong> works as expected. We can see information about the original <strong class="source-inline">Website</strong> object and <span class="No-Break">its clone.</span></p>
			<p>And looking at the ID value<a id="_idIndexMarker188"/> for each <strong class="source-inline">Website</strong> object, we can see that the <a id="_idIndexMarker189"/>two addresses <span class="No-Break">are different.</span></p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor078"/>The singleton pattern</h1>
			<p>One of the original <a id="_idIndexMarker190"/>design patterns for OOP, the singleton pattern restricts the<a id="_idIndexMarker191"/> instantiation of a class to <em class="italic">one</em> object, which is useful when you need one object to coordinate actions for <span class="No-Break">the system.</span></p>
			<p>The basic idea is that only one instance of a particular class, doing a job, is created for the needs of the program. To ensure that this works, we need mechanisms that prevent the instantiation of the class more than once and also <span class="No-Break">prevent cloning.</span></p>
			<p>In the Python programmer community, the singleton pattern is actually considered an anti-pattern. Let’s explore the pattern first, and later we will discuss the alternative approaches we are encouraged to use <span class="No-Break">in Python.</span></p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor079"/>Real-world examples</h2>
			<p>In a real-life <a id="_idIndexMarker192"/>scenario, we can think of the captain of a ship or a boat. On the ship, they are the ones in charge. They are responsible for important decisions, and a number of requests are directed to them because of <span class="No-Break">this responsibility.</span></p>
			<p>Another example is the printer spooler, in an office environment, which ensures that print jobs are coordinated through a single point, avoiding conflicts and ensuring <span class="No-Break">orderly printing.</span></p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor080"/>Use cases for the singleton pattern</h2>
			<p>The<a id="_idIndexMarker193"/> singleton design pattern is useful when you need to create only one object or you need some sort of object capable of maintaining a global state for <span class="No-Break">your program.</span></p>
			<p>Other possible use cases are <span class="No-Break">the following:</span></p>
			<ul>
				<li>Controlling concurrent access to a shared resource—for example, the class managing the connection to <span class="No-Break">a database</span></li>
				<li>A service or resource that is transversal in the sense that it can be accessed from different parts of the application or by different users and do its work—for example, the<a id="_idIndexMarker194"/> class at the core of a logging system <span class="No-Break">or utility</span></li>
			</ul>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor081"/>Implementing the singleton pattern</h2>
			<p>As discussed, the<a id="_idIndexMarker195"/> singleton pattern ensures that a class has only one <a id="_idIndexMarker196"/>instance and provides a global point to access it. In this example, we’ll create a <strong class="source-inline">URLFetcher</strong> class that fetches content from web pages. We want to ensure that only one instance of this class exists to keep track of all <span class="No-Break">fetched URLs.</span></p>
			<p>Imagine you have multiple fetchers in different parts of your program, but you want to keep track of all URLs that have been fetched. This is a classic case for a singleton pattern. By ensuring that all parts of your program use the same fetcher instance, you can easily keep track of all fetched URLs in <span class="No-Break">one place.</span></p>
			<p>Initially, we create a naive version of the <strong class="source-inline">URLFetcher</strong> class. This class has a <strong class="source-inline">fetch()</strong> method that fetches the web page content and stores the URL in <span class="No-Break">a list:</span></p>
			<pre class="source-code">
import urllib.request
class URLFetcher:
    def __init__(self):
        self.urls = []
    def fetch(self, url):
        req = urllib.request.Request(url)
        with urllib.request.urlopen(req) as response:
            if response.code == 200:
                page_content = response.read()
             with open("content.html", "a") as f:
                 f.write(page_content + "\n")
             self.urls.append(url)</pre>			<p>To check if<a id="_idIndexMarker197"/> our class is a <strong class="bold">singleton</strong>, we can compare two instances of the class using the <strong class="source-inline">is</strong> operator. If they are the same, then it’s <span class="No-Break">a singleton:</span></p>
			<pre class="source-code">
if __name__ == "__main__":
    print(URLFetcher() is URLFetcher())</pre>			<p>If you run this code (<strong class="source-inline">ch03/singleton/before_singleton.py</strong>), you’ll see that the output is <span class="No-Break">the following:</span></p>
			<pre class="console">
False</pre>			<p>This output shows that the class in this version does not yet respect the singleton pattern. To <a id="_idIndexMarker198"/>make it a<a id="_idIndexMarker199"/> singleton, we’ll use the <span class="No-Break"><strong class="bold">metaclass</strong></span><span class="No-Break"> technique.</span></p>
			<p class="callout-heading">Additional information</p>
			<p class="callout">A metaclass in Python is a class of a class that defines how a <span class="No-Break">class behaves.</span></p>
			<p>We’ll create a <strong class="source-inline">SingletonType</strong> metaclass that ensures that only one instance of <strong class="source-inline">URLFetcher</strong> exists, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
import urllib.request
class SingletonType(type):
    _instances = {}
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            obj = super(SingletonType, cls).__call__(*args, **kwargs)
            cls._instances[cls] = obj
        return cls._instances[cls]</pre>			<p>Now, we <a id="_idIndexMarker200"/>modify our <strong class="source-inline">URLFetcher</strong> class to use this metaclass, <span class="No-Break">as</span><span class="No-Break"><a id="_idIndexMarker201"/></span><span class="No-Break"> follows:</span></p>
			<pre class="source-code">
class URLFetcher(metaclass=SingletonType):
    def __init__(self):
        self.urls = []
    def fetch(self, url):
        req = urllib.request.Request(url)
        with urllib.request.urlopen(req) as response:
            if response.code == 200:
                page_content = response.read()
                with open("content.html", "a") as f:
                    f.write(str(page_content))
                self.urls.append(url)</pre>			<p>Finally, we create a <strong class="source-inline">main()</strong> function and call it to test our singleton, with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
def main():
    my_urls = [
            "http://python.org",
            "https://planetpython.org/",
            "https://www.djangoproject.com/",
    ]
    print(URLFetcher() is URLFetcher())
    fetcher = URLFetcher()
    for url in my_urls:
        fetcher.fetch(url)
    print(f"Done URLs: {fetcher.urls}")
if __name__ == "__main__":
    main()</pre>			<p>Here is a summary of what we do in the <span class="No-Break">code (</span><span class="No-Break"><strong class="source-inline">ch03</strong></span><span class="No-Break"><strong class="source-inline">/singleton/singleton.py</strong></span><span class="No-Break">):</span></p>
			<ol>
				<li>We start with our needed module <span class="No-Break">imports (</span><span class="No-Break"><strong class="source-inline">urllib.request</strong></span><span class="No-Break">).</span></li>
				<li>We define a <strong class="source-inline">SingletonType</strong> class, with its special <span class="No-Break"><strong class="source-inline">__call__()</strong></span><span class="No-Break"> method.</span></li>
				<li>We define <strong class="source-inline">URLFetcher</strong>, the class implementing the fetcher for the web pages, initializing it with the <strong class="source-inline">urls</strong> attribute; as discussed, we add its <span class="No-Break"><strong class="source-inline">fetch()</strong></span><span class="No-Break"> method.</span></li>
				<li>Lastly, we <a id="_idIndexMarker202"/>add our <strong class="source-inline">main()</strong> function, and we add Python’s<a id="_idIndexMarker203"/> conventional snippet used to <span class="No-Break">call it.</span></li>
			</ol>
			<p>To test the implementation, run the <strong class="source-inline">python ch03/singleton/singleton.py</strong> command. You should get the <span class="No-Break">following output:</span></p>
			<pre class="console">
True
Done URLs: ['http://python.org', 'https://planetpython.org/', 'https://www.djangoproject.com/']</pre>			<p>In addition, you <a id="_idIndexMarker204"/>will find that a file called <strong class="source-inline">content.html</strong> has been created, with the HTML text that comes from the different URLs added <span class="No-Break">to it.</span></p>
			<p>So, the program did its job as expected. This is a demonstration of how the singleton pattern may <span class="No-Break">be used.</span></p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor082"/>Should you use the singleton pattern?</h2>
			<p>While the<a id="_idIndexMarker205"/> singleton pattern has its merits, it may not always be the most Pythonic approach to managing global states or resources. Our implementation example worked, but if we stop a minute to analyze the code again, we notice <span class="No-Break">the following:</span></p>
			<ul>
				<li>The techniques used for the implementation are rather advanced and not easy to explain to <span class="No-Break">a beginner</span></li>
				<li>By reading the <strong class="source-inline">SingletonType</strong> class definition, it is not easy to immediately see that it provides a metaclass for a singleton if the name does not <span class="No-Break">suggest it</span></li>
			</ul>
			<p>In Python, developers often prefer a simpler alternative to singleton: using a module-level <span class="No-Break">global object.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Python modules act as natural namespaces that can contain variables, functions, and classes, making them ideal for organizing and sharing <span class="No-Break">global resources.</span></p>
			<p>By adopting the global object technique, as explained by Brandon Rhodes in what he calls the <em class="italic">Global Object Pattern</em> (<a href="https://python-patterns.guide/python/module-globals/">https://python-patterns.guide/python/module-globals/</a>), you can achieve the same result as the singleton pattern without the need for complex instantiation processes or forcing a class to only have <span class="No-Break">one instance.</span></p>
			<p>As an exercise, you can re-write the implementation of our example using a global object. For reference, the equivalent code, defining a global object, is provided in the <strong class="source-inline">ch03/singleton/instead_of_singleton/example.py</strong> file; for its use, check the <span class="No-Break"><strong class="source-inline">ch03/singleton/instead_of_singleton/use_example.py</strong></span><span class="No-Break"> file.</span></p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor083"/>The object pool pattern</h1>
			<p>The <a id="_idIndexMarker206"/>object pool pattern is <a id="_idIndexMarker207"/>a creational design pattern that allows you to reuse existing objects instead of creating new ones when they are needed. This pattern is particularly useful when the cost, in terms of system resources, time, and so on of initializing a new object <span class="No-Break">is high.</span></p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor084"/>Real-world examples</h2>
			<p>Consider a car rental service. When a <a id="_idIndexMarker208"/>customer rents a car, the service doesn’t manufacture a new car for them. Instead, it provides one from a pool of available cars. Once the customer returns the car, it goes back into the pool, ready to be used by the <span class="No-Break">next customer.</span></p>
			<p>Another example would be a public swimming pool. Rather than filling the pool with water every time someone wants to swim, the water is treated and reused for multiple swimmers. This saves both time <span class="No-Break">and resources.</span></p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor085"/>Use cases for the object pool pattern</h2>
			<p>The object pool pattern is<a id="_idIndexMarker209"/> especially useful in scenarios where resource initialization is costly or time-consuming. This could be in terms of CPU cycles, memory usage, or even network bandwidth. For example, in a shooting video game, you might use this pattern to manage bullet objects. Creating a new bullet every time a gun is fired could be resource-intensive. Instead, you could have a pool of bullet objects that <span class="No-Break">are reused.</span></p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor086"/>Implementing the object pool pattern</h2>
			<p>Let’s implement a pool <a id="_idIndexMarker210"/>of reusable <strong class="source-inline">car</strong> objects, for a car rental application, to avoid creating and destroying <span class="No-Break">them repeatedly.</span></p>
			<p>First, we need to define a <strong class="source-inline">Car</strong> class, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class Car:
    def __init__(self, make: str, model: str):
        self.make = make
        self.model = model
        self.in_use = False</pre>			<p>Then, we start defining a <strong class="source-inline">CarPool</strong> class with its initialization, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class CarPool:
    def __init__(self):
        self._available = []
        self._in_use = []</pre>			<p>We need to<a id="_idIndexMarker211"/> express what happens when a client acquires a <a id="_idIndexMarker212"/>car. For that, we define a method on the class doing the following: if no car is available, we instantiate one and add it to the list of available cars in the pool; else, we return an available <strong class="source-inline">car</strong> object, while doing <span class="No-Break">the following:</span></p>
			<ul>
				<li>Setting the <strong class="source-inline">_in_use</strong> attribute of the <strong class="source-inline">car</strong> object <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">True</strong></span></li>
				<li>Adding the <strong class="source-inline">car</strong> object to the list of “in use” cars (stored in the <strong class="source-inline">_in_use</strong> attribute of the <span class="No-Break"><strong class="source-inline">pool</strong></span><span class="No-Break"> object)</span></li>
			</ul>
			<p>We add the code of that method to the class <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
    def acquire_car(self) -&gt; Car:
        if len(self._available) == 0:
            new_car = Car("BMW", "M3")
            self._available.append(new_car)
        car = self._available.pop()
        self._in_use.append(car)
        car.in_use = True
        return car</pre>			<p>We then add a method that handles things when a client releases a car, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
    def release_car(self, car: Car) -&gt; None:
        car.in_use = False
        self._in_use.remove(car)
        self._available.append(car)</pre>			<p>Finally, we <a id="_idIndexMarker213"/>add some <a id="_idIndexMarker214"/>code for testing the result of the implementation, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
if __name__ == "__main__":
    pool = CarPool()
    car_name = "Car 1"
    print(f"Acquire {car_name}")
    car1 = pool.acquire_car()
    print(f"{car_name} in use: {car1.in_use}")
    print(f"Now release {car_name}")
    pool.release_car(car1)
    print(f"{car_name} in use: {car1.in_use}")</pre>			<p>Here is a summary of what we do in the code (in <span class="No-Break">file </span><span class="No-Break"><strong class="source-inline">ch03/object_pool.py</strong></span><span class="No-Break">):</span></p>
			<ol>
				<li>We define a <span class="No-Break"><strong class="source-inline">Car</strong></span><span class="No-Break"> class.</span></li>
				<li>We define a <strong class="source-inline">CarPool</strong> class with the <strong class="source-inline">acquire_car()</strong> and <strong class="source-inline">release_car()</strong> methods, as <span class="No-Break">shown earlier.</span></li>
				<li>We add code for testing the result of the implementation, as <span class="No-Break">shown earlier.</span></li>
			</ol>
			<p>To test the program, run the <span class="No-Break">following command:</span></p>
			<pre class="console">
python ch03/object_pool.py</pre>			<p>You should get the <span class="No-Break">following output:</span></p>
			<pre class="console">
Acquire Car 1
Car 1 in use: True
Now release Car 1
Car 1 in use: False</pre>			<p>Well done! This<a id="_idIndexMarker215"/> output shows that our object pool pattern <a id="_idIndexMarker216"/>implementation works <span class="No-Break">as intended.</span></p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor087"/>Summary</h1>
			<p>In this chapter, we have seen <em class="italic">creational design patterns</em>, which are essential for crafting flexible, maintainable, and modular code. We kicked off the chapter by examining two variations of the factory pattern, each offering unique advantages for object creation. Next, we navigated through the builder pattern, which provides a more readable and maintainable way to construct complex objects. The prototype pattern followed, introducing a method to clone objects efficiently. Finally, we rounded out the chapter by discussing the singleton and object pool patterns, both of which are geared toward optimizing resource management and ensuring consistent state across <span class="No-Break">the application.</span></p>
			<p>Now, equipped with these foundational patterns for object creation, we are well prepared for the next chapter, where we will discover <em class="italic">structural </em><span class="No-Break"><em class="italic">design patterns</em></span><span class="No-Break">.</span></p>
		</div>
	</body></html>