<html><head></head><body>
		<div><h1 id="_idParaDest-59" class="chapter-number"><a id="_idTextAnchor061"/>3</h1>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor062"/>Creational Design Patterns</h1>
			<p>Design patterns<a id="_idIndexMarker086"/> are reusable programming solutions that have been used in various real-world contexts and have proved to produce expected results. They are shared among programmers and continue to be improved over time. This topic is popular thanks to the book by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, titled <em class="italic">Design Patterns: Elements of Reusable </em><em class="italic">Object-Oriented Software</em>.</p>
			<p>Here is a quote about design patterns from the <em class="italic">Gang of </em><em class="italic">Four </em>book:</p>
			<p><em class="italic">A design pattern systematically names, motivates, and explains a general design that addresses a recurring design problem in object-oriented systems. It describes the problem, the solution, when to apply the solution, and its consequences. It also gives implementation hints and examples. The solution is a general arrangement of objects and classes that solve the problem. The solution is customized and implemented to solve the problem in a </em><em class="italic">particular context.</em></p>
			<p>There <a id="_idIndexMarker087"/>are several categories of design patterns used in <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>), depending on the type of problem they address and/or the types of solutions they help us build. In their book, the <em class="italic">Gang of Four</em> presents 23 design patterns, split into three categories: <em class="italic">creational</em>, <em class="italic">structural</em>, and <em class="italic">behavioral</em>.</p>
			<p><code>__init__()</code> function, is not convenient.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>The factory pattern</li>
				<li>The builder pattern</li>
				<li>The prototype pattern</li>
				<li>The singleton pattern</li>
				<li>The object pool pattern</li>
			</ul>
			<p>By the end of the chapter, you will have a solid understanding of creational design patterns, whether they are useful or not in Python, and how to use them when they are useful.</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor063"/>Technical requirements</h1>
			<p>See the requirements presented in <a href="B21896_01.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>.</p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor064"/>The factory pattern</h1>
			<p>We will start<a id="_idIndexMarker089"/> with the first <a id="_idIndexMarker090"/>creational design pattern from the <em class="italic">Gang of Four</em> book: the factory design pattern. In the factory design pattern, a client (meaning client code) asks for an object without knowing where the object is coming from (that is, which class is used to generate it). The idea behind a factory is to simplify the object creation process. It is easier to track which objects are created if this is done through a central function, compared to letting a client create objects using a direct class instantiation. A factory reduces the complexity of maintaining an application by decoupling the code that creates an object from the code that uses it.</p>
			<p>Factories typically come in two forms—the factory method, which is a method (or simply a function for a Python developer) that returns a different object per input parameter, and the abstract factory, which is a group of factory methods used to create a family of related objects.</p>
			<p>Let’s discuss the two forms of <em class="italic">factory pattern</em>, starting with the factory method.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor065"/>The factory method</h2>
			<p>The factory method<a id="_idIndexMarker091"/> is based on a single function written to handle our object creation task. We execute it, passing a parameter that provides information about what we want, and, as a result, the wanted object is created.</p>
			<p>Interestingly, when using the factory method, we are not required to know any details about how the resulting object is implemented and where it is coming from.</p>
			<h3>Real-world examples</h3>
			<p>We can find the factory <a id="_idIndexMarker092"/>method pattern used in real life in the context of a plastic toy construction kit. The molding material used to construct plastic toys is the same, but different toys (different figures or shapes) can be produced using the right plastic molds. This is like having a factory method in which the input is the name of the toy that we want (for example, a duck or car) and the output (after the molding) is the plastic toy that was requested.</p>
			<p>In the software world, the Django web framework uses the factory method pattern for creating the fields of a web form. The <code>forms</code> module included in Django (<a href="https://github.com/django/django/blob/main/django/forms/forms.py">https://github.com/django/django/blob/main/django/forms/forms.py</a>) supports the creation of different kinds of fields (for example, <code>CharField</code>, <code>EmailField</code>, and so on). Parts of their behavior can <a id="_idIndexMarker093"/>be customized using attributes such as <code>max_length</code> and <code>required</code>.</p>
			<h3>Use cases for the factory method pattern</h3>
			<p>If you <a id="_idIndexMarker094"/>realize that<a id="_idIndexMarker095"/> you cannot track the objects created by your application because the code that creates them is in many different places instead of in a single function/method, you should consider using the factory method pattern. The factory method centralizes object creation and tracking your objects becomes much easier. Note that it is fine to create more than one factory method, and this is how it is typically done in practice. Each factory method logically groups the creation of objects that have similarities. For example, one factory method might be responsible for connecting you to different databases (MySQL, SQLite); another factory method might be responsible for creating the geometrical object that you request (circle, triangle); and so on.</p>
			<p>The factory method is also useful when you want to decouple object creation from object usage. We are not coupled to a specific class when creating an object; we just provide partial information about what we want by calling a function. This means that introducing changes to the function is easy and does not require any changes to the code that uses it.</p>
			<p>Another use case worth mentioning is related to improving the performance and memory usage of an application. A factory method can improve performance and memory usage by creating new objects only if it is necessary. When we create objects using a direct class instantiation, extra memory is allocated every time a new object is created (unless the class uses caching internally, which is usually not the case). We can see that in practice in the following code (<code>ch03/factory/id.py</code>), which creates two instances of the same class, <code>MyClass</code>, and uses the <code>id()</code> function to compare their memory addresses. The addresses are also printed in the output so that we can inspect them. The fact that the memory addresses are different means that two distinct objects are created. The code is as follows:</p>
			<pre class="source-code">
class MyClass:
    pass
if __name__ == "__main__":
    a = MyClass()
    b = MyClass()
    print(id(a) == id(b))
    print(id(a))
    print(id(b))</pre>			<p>Executing the <a id="_idIndexMarker096"/>code (<code>ch03/factory/id.py</code>) on my <a id="_idIndexMarker097"/>computer results in the following output:</p>
			<pre class="console">
False
4330224656
4331646704</pre>			<p class="callout-heading">Note</p>
			<p class="callout">The addresses that you see if you execute the file, where the <code>id()</code> function is called, are not the same as the ones I see because they depend on the current memory layout and allocation. But the result must be the same—the two addresses should be different. There’s one exception that happens if you write and execute the code in the Python <strong class="bold">Read-Eval-Print Loop</strong> (<strong class="bold">REPL</strong>)—or, simply<a id="_idIndexMarker098"/> put, the interactive prompt—but that’s a REPL-specific optimization that does not happen normally.</p>
			<h3>Implementing the factory method pattern</h3>
			<p>Data comes<a id="_idIndexMarker099"/> in many forms. There are two main file categories for storing/retrieving data: human-readable files and binary files. Examples of human-readable files are XML, RSS/Atom, YAML, and JSON. Examples of binary files are the <code>.sq3</code> file format used by SQLite and the <code>.mp3</code> audio file format used to listen to music.</p>
			<p>In this example, we will focus on two popular human-readable formats—XML and JSON. Although human-readable files are generally slower to parse than binary files, they make data exchange, inspection, and modification much easier. For this reason, it is advised that you work with human-readable files unless there are other restrictions that do not allow it (mainly unacceptable performance or proprietary binary formats).</p>
			<p>In this case, we have some input data stored in an XML and a JSON file, and we want to parse them and retrieve some information. At the same time, we want to centralize the client’s connection to those (and all future) external services. We will use the factory method to solve this problem. The example focuses only on XML and JSON, but adding support for more<a id="_idIndexMarker100"/> services should be straightforward.</p>
			<p>First, let’s look at the data files.</p>
			<p>The JSON file, <code>movies.json</code>, is a sample of a dataset containing information about American movies (title, year, director name, genre, and so on):</p>
			<pre class="source-code">
[
  {
    "title": "After Dark in Central Park",
    "year": 1900,
    "director": null,
    "cast": null,
    "genre": null
  },
  {
    "title": "Boarding School Girls' Pajama Parade",
    "year": 1900,
    "director": null,
    "cast": null,
    "genre": null
  },
  {
    "title": "Buffalo Bill's Wild West Parad",
    "year": 1900,
    "director": null,
    "cast": null,
    "genre": null
  },
  {
    "title": "Caught",
    "year": 1900,
    "director": null,
    "cast": null,
    "genre": null
  },
  {
    "title": "Clowns Spinning Hats",
    "year": 1900,
    "director": null,
    "cast": null,
    "genre": null
  },
  {
    "title": "Capture of Boer Battery by British",
    "year": 1900,
    "director": "James H. White",
    "cast": null,
    "genre": "Short documentary"
  },
  {
    "title": "The Enchanted Drawing",
    "year": 1900,
    "director": "J. Stuart Blackton",
    "cast": null,
    "genre": null
  },
  {
    "title": "Family Troubles",
    "year": 1900,
    "director": null,
    "cast": null,
    "genre": null
  },
  {
    "title": "Feeding Sea Lions",
    "year": 1900,
    "director": null,
    "cast": "Paul Boyton",
    "genre": null
  }
]</pre>			<p>The XML file, <code>person.xml</code>, contains<a id="_idIndexMarker101"/> information about <a id="_idIndexMarker102"/>individuals (<code>firstName</code>, <code>lastName</code>, <code>gender</code>, and so on), as follows:</p>
			<ol>
				<li>We start with the enclosing tag of the <code>persons</code> XML container:<pre class="source-code">
<strong class="bold">&lt;persons&gt;</strong></pre></li>				<li>Then, an XML element representing a person’s data code is presented as follows:<pre class="source-code">
&lt;person&gt;
  &lt;firstName&gt;John&lt;/firstName&gt;
  &lt;lastName&gt;Smith&lt;/lastName&gt;
  &lt;age&gt;25&lt;/age&gt;
  &lt;address&gt;
    &lt;streetAddress&gt;21 2nd Street&lt;/streetAddress&gt;
    &lt;city&gt;New York&lt;/city&gt;
    &lt;state&gt;NY&lt;/state&gt;
    &lt;postalCode&gt;10021&lt;/postalCode&gt;
  &lt;/address&gt;
  &lt;phoneNumbers&gt;
    &lt;number type="home"&gt;212 555-1234&lt;/number&gt;
    &lt;number type="fax"&gt;646 555-4567&lt;/number&gt;
  &lt;/phoneNumbers&gt;
  &lt;gender&gt;
    &lt;type&gt;male&lt;/type&gt;
  &lt;/gender&gt;
&lt;/person&gt;</pre></li>				<li>An XML<a id="_idIndexMarker103"/> element representing another person’s<a id="_idIndexMarker104"/> data is shown by the following code:<pre class="source-code">
&lt;person&gt;
  &lt;firstName&gt;Jimy&lt;/firstName&gt;
  &lt;lastName&gt;Liar&lt;/lastName&gt;
  &lt;age&gt;19&lt;/age&gt;
  &lt;address&gt;
    &lt;streetAddress&gt;18 2nd Street&lt;/streetAddress&gt;
    &lt;city&gt;New York&lt;/city&gt;
    &lt;state&gt;NY&lt;/state&gt;
    &lt;postalCode&gt;10021&lt;/postalCode&gt;
  &lt;/address&gt;
  &lt;phoneNumbers&gt;
    &lt;number type="home"&gt;212 555-1234&lt;/number&gt;
  &lt;/phoneNumbers&gt;
  &lt;gender&gt;
    &lt;type&gt;male&lt;/type&gt;
  &lt;/gender&gt;
&lt;/person&gt;</pre></li>				<li>An XML element representing a third person’s data is shown by the following code:<pre class="source-code">
&lt;person&gt;
  &lt;firstName&gt;Patty&lt;/firstName&gt;
  &lt;lastName&gt;Liar&lt;/lastName&gt;
  &lt;age&gt;20&lt;/age&gt;
  &lt;address&gt;
    &lt;streetAddress&gt;18 2nd Street&lt;/streetAddress&gt;
    &lt;city&gt;New York&lt;/city&gt;
    &lt;state&gt;NY&lt;/state&gt;
    &lt;postalCode&gt;10021&lt;/postalCode&gt;
  &lt;/address&gt;
  &lt;phoneNumbers&gt;
    &lt;number type="home"&gt;212 555-1234&lt;/number&gt;
    &lt;number type="mobile"&gt;001 452-8819&lt;/number&gt;
  &lt;/phoneNumbers&gt;
  &lt;gender&gt;
    &lt;type&gt;female&lt;/type&gt;
  &lt;/gender&gt;
&lt;/person&gt;</pre></li>				<li>Finally, we close the XML container:<pre class="source-code">
&lt;/persons&gt;</pre></li>			</ol>
			<p>We will <a id="_idIndexMarker105"/>use two libraries that are part of the Python distribution for <a id="_idIndexMarker106"/>working with JSON and XML: <code>json</code> and <code>xml.etree.ElementTree</code>.</p>
			<p>We start by importing what we need for the various manipulations (<code>json</code>, <code>ElementTree</code>, and <code>pathlib</code>), and we define a <code>JSONDataExtractor</code> class, loading the data from the file and using the <code>parsed_data</code> property to get it. That part of the code is as follows:</p>
			<pre class="source-code">
import json
import xml.etree.ElementTree as ET
from pathlib import Path
class JSONDataExtractor:
    def __init__(self, filepath: Path):
        self.data = {}
        with open(filepath) as f:
            self.data = json.load(f)
    @property
    def parsed_data(self):
        return self.data</pre>			<p>We also <a id="_idIndexMarker107"/>define an <code>XMLDataExtractor</code> class, loading the data in the <a id="_idIndexMarker108"/>file via <code>ElementTree</code>’s parser, and using the <code>parsed_data</code> property to get the result, as follows:</p>
			<pre class="source-code">
class XMLDataExtractor:
    def __init__(self, filepath: Path):
        self.tree = ET.parse(filepath)
    @property
    def parsed_data(self):
        return self.tree</pre>			<p>Now, we provide the factory function that helps select the right data extractor class depending on the target file’s extension (or raise an exception if it is not supported), as follows:</p>
			<pre class="source-code">
def extract_factory(filepath: Path):
    ext = filepath.name.split(".")[-1]
    if ext == "json":
        return JSONDataExtractor(filepath)
    elif ext == "xml":
        return XMLDataExtractor(filepath)
    else:
        raise ValueError("Cannot extract data")</pre>			<p>Next, we define the<a id="_idIndexMarker109"/> main function of our program, <code>extract()</code>; in the <a id="_idIndexMarker110"/>first part of the function, the code handles the JSON case, as follows:</p>
			<pre class="source-code">
def extract(case: str):
    dir_path = Path(__file__).parent
    if case == "json":
        path = dir_path / Path("movies.json")
        factory = extract_factory(path)
        data = factory.parsed_data
        for movie in data:
            print(f"- {movie['title']}")
            director = movie["director"]
            if director:
                print(f"   Director: {director}")
            genre = movie["genre"]
            if genre:
                print(f"   Genre: {genre}")</pre>			<p>We add the<a id="_idIndexMarker111"/> final part of the <code>extract()</code> function, working with the <a id="_idIndexMarker112"/>XML file using the factory method. XPath is used to find all person elements that have the last name <code>Liar</code>. For each matched person, the basic name and phone number information are shown. The code is as follows:</p>
			<pre class="source-code">
    elif case == "xml":
        path = dir_path / Path("person.xml")
        factory = extract_factory(path)
        data = factory.parsed_data
        search_xpath = ".//person[lastName='Liar']"
        items = data.findall(search_xpath)
        for item in items:
            first = item.find("firstName").text
            last = item.find("lastName").text
            print(f"- {first} {last}")
            for pn in item.find("phoneNumbers"):
                pn_type = pn.attrib["type"]
                pn_val = pn.text
                phone = f"{pn_type}: {pn_val}"
                print(f"   {phone}")</pre>			<p>Finally, we add some testing code:</p>
			<pre class="source-code">
if __name__ == "__main__":
    print("* JSON case *")
    extract(case="json")
    print("* XML case *")
    extract(case="xml")</pre>			<p>Here is a<a id="_idIndexMarker113"/> summary <a id="_idIndexMarker114"/>of the implementation (in the <code>ch03/factory/factory_method.py</code> file):</p>
			<ol>
				<li>After importing the modules we need, we start by defining a JSON data extractor class (<code>JSONDataExtractor</code>) and an XML data extractor class (<code>XMLDataExtractor</code>).</li>
				<li>We add a factory function, <code>extract_factory()</code>, to get the right data extractor class to instantiate.</li>
				<li>We also add our wrapper and main function, <code>extract()</code>.</li>
				<li>Finally, we add testing code, where we extract data from a JSON file and an XML file and parse the resulting text.</li>
			</ol>
			<p>To test the example, run the following command:</p>
			<pre class="console">
python ch03/factory/factory_method.py</pre>			<p>You should get the following output:</p>
			<pre class="console">
* JSON case *
- After Dark in Central Park
- Boarding School Girls' Pajama Parade
- Buffalo Bill's Wild West Parad
- Caught
- Clowns Spinning Hats
- Capture of Boer Battery by British
   Director: James H. White
   Genre: Short documentary
- The Enchanted Drawing
   Director: J. Stuart Blackton
- Family Troubles
- Feeding Sea Lions
* XML case *
- Jimy Liar
   home: 212 555-1234
- Patty Liar
   home: 212 555-1234
   mobile: 001 452-8819</pre>			<p>Notice that although <code>JSONDataExtractor</code> and <code>XMLDataExtractor</code> have the same interfaces, what is returned by <code>parsed_data()</code> is not handled in a uniform way; in one case we have a list, and in the other, we have a tree. Different Python code must be used to work with each data extractor. Although it would be nice to be able to use the same code for all extractors, this is not realistic for the most part unless we use some kind of common mapping for the data, which is often provided by external data providers. Assuming<a id="_idIndexMarker115"/> that you can use the same code for handling the <a id="_idIndexMarker116"/>XML and JSON files, what changes are required to support a third format—for example, SQLite? Find an SQLite file or create your own and try it.</p>
			<h3>Should you use the factory method pattern?</h3>
			<p>The main critique that veteran Python developers often express toward the factory method pattern is that it can be considered over-engineered or unnecessarily complex for many use cases. Python’s dynamic typing and first-class functions often allow for simpler, more straightforward solutions to problems that the factory method aims to solve. In Python, you can often use simple functions or class methods to create objects directly without needing to create separate factory classes or functions. This keeps the code more readable and Pythonic, adhering to the language’s philosophy of <em class="italic">Simple is better </em><em class="italic">than complex</em>.</p>
			<p>Also, Python’s support for default arguments, keyword arguments, and other language features often makes it easier to extend constructors in a backward-compatible way, reducing the need for separate factory methods. So, while the factory method pattern is a well-established design pattern in statically typed languages such as Java or C++, it is often seen as too cumbersome or verbose for Python’s more flexible and dynamic nature.</p>
			<p>To show how one could deal with simple use cases without the factory method pattern, an alternative implementation has been provided in the <code>ch03/factory/factory_method_not_needed.py</code> file. As<a id="_idTextAnchor066"/> you can see, there is no more factory. And the following extract from the code shows what we mean when we say that in Python, you just create objects where you need them, without an intermediary function <a id="_idIndexMarker117"/>or class, which makes your code more Pythonic:</p>
			<pre class="source-code">
if case == "json":
    path = dir_path / Path("movies.json")
    data = JSONDataExtractor(path).parsed_data</pre>			<h2 id="_idParaDest-64"><a id="_idTextAnchor067"/>The abstract factory pattern</h2>
			<p>The abstract factory <a id="_idIndexMarker118"/>pattern<a id="_idIndexMarker119"/> is a generalization of the factory method idea. Basically, an abstract factory is a (logical) group of factory methods, where each factory method is responsible for generating a different kind of object.</p>
			<p>We are going to discuss some examples, use cases, and a possible implementation.</p>
			<h3>Real-world examples</h3>
			<p>The abstract factory is used in car <a id="_idIndexMarker120"/>manufacturing. The same machinery is used for stamping the parts (doors, panels, hoods, fenders, and mirrors) of different car models. The model that is assembled by the machinery is configurable and easy to change at any time.</p>
			<p>In the software category, the <code>factory_boy</code> package (<a href="https://github.com/FactoryBoy/factory_boy">https://github.com/FactoryBoy/factory_boy</a>) provides an abstract factory implementation for creating Django models in tests. An alternative tool is <code>model_bakery</code> (<a href="https://github.com/model-bakers/model_bakery">https://github.com/model-bakers/model_bakery</a>). Both packages are used for creating instances of models that support test-specific attributes. This is important because, this way, the readability of your tests is improved, and you avoid sharing unnecessary <a id="_idIndexMarker121"/>code.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Django models are special classes used by the framework to help store and interact with data in the database (tab<a href="https://docs.djangoproject.com">les). See the Django documenta</a>tion (<a href="https://docs.djangoproject.com">https://docs.djangoproject.com</a>) for more details.</p>
			<h3>Use cases for the abstract factory pattern</h3>
			<p>Since the abstract<a id="_idIndexMarker122"/> factory pattern is a generalization of the <a id="_idIndexMarker123"/>factory method pattern, it offers the same benefits: it makes tracking an object creation easier, it decouples object creation from object usage, and it gives us the potential to improve the memory usage and performance of our application.</p>
			<h3>Implementing the abstract factory pattern</h3>
			<p>To demonstrate<a id="_idIndexMarker124"/> the abstract factory pattern, I will reuse one of my favorite examples, included in the book <em class="italic">Python 3 Patterns, Recipes and Idioms</em>, by Bruce Eckel. Imagine that we are creating a game or we want to include a mini-game as part of our application to entertain our users. We want to include at least two games, one for children and one for adults. We will decide which game to create and launch at runtime, based on user input. An abstract factory takes care of the game creation part.</p>
			<p>Let’s start with the kids’ game. It is <a id="_idIndexMarker125"/>called <code>interact_with()</code> method is used to describe the interaction of the frog with an obstacle (for example, a bug, puzzle, and other frogs) as follows:</p>
			<pre class="source-code">
class Frog:
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return self.name
    def interact_with(self, obstacle):
        act = obstacle.action()
        msg = f"{self} the Frog encounters {obstacle} and {act}!"
        print(msg)</pre>			<p>There can be many kinds of obstacles, but for our example, an obstacle can only be a bug. When the frog encounters a bug, only one action is supported. It eats it:</p>
			<pre class="source-code">
class Bug:
    def __str__(self):
        return "a bug"
    def action(self):
        return "eats it"</pre>			<p>The <code>FrogWorld</code> class is an<a id="_idIndexMarker126"/> abstract factory. Its main <a id="_idIndexMarker127"/>responsibilities are creating the main character and the obstacle(s) in the game. Keeping the creation methods separate and their names generic (for example, <code>make_character()</code> and <code>make_obstacle()</code>) allows us to change the active factory (and, therefore, the active game) dynamically without any code changes. The code is as follows:</p>
			<pre class="source-code">
class FrogWorld:
    def __init__(self, name):
        print(self)
        self.player_name = name
    def __str__(self):
        return "\n\n\t------ Frog World -------"
    def make_character(self):
        return Frog(self.player_name)
    def make_obstacle(self):
        return Bug()</pre>			<p>The <strong class="bold">WizardWorld</strong> game<a id="_idIndexMarker128"/> is similar. The <a id="_idIndexMarker129"/>only difference is <a id="_idIndexMarker130"/>that the wizard battles against monsters such as orks instead of eating bugs!</p>
			<p>Here is the definition of the <code>Wizard</code> class, which is similar to the <code>Frog</code> one:</p>
			<pre class="source-code">
class Wizard:
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return self.name
    def interact_with(self, obstacle):
        act = obstacle.action()
        msg = f"{self} the Wizard battles against {obstacle} and {act}!"
        print(msg)</pre>			<p>Then, the definition of the <code>Ork</code> class is as follows:</p>
			<pre class="source-code">
class Ork:
    def __str__(self):
        return "an evil ork"
    def action(self):
        return "kills it"</pre>			<p>We also need to<a id="_idIndexMarker131"/> define a <code>WizardWorld</code> class, similar to the <code>FrogWorld</code> one that we have discussed; the<a id="_idIndexMarker132"/> obstacle, in this case, is an <code>Ork</code> instance:</p>
			<pre class="source-code">
class WizardWorld:
    def __init__(self, name):
        print(self)
        self.player_name = name
    def __str__(self):
        return "\n\n\t------ Wizard World -------"
    def make_character(self):
        return Wizard(self.player_name)
    def make_obstacle(self):
        return Ork()</pre>			<p>The <code>GameEnvironment</code> class is the main entry point of our game. It accepts the factory as an input and uses it to create the world of the game. The <code>play()</code> method initiates the interaction between the created hero and the obstacle, as follows:</p>
			<pre class="source-code">
class GameEnvironment:
    def __init__(self, factory):
        self.hero = factory.make_character()
        self.obstacle = factory.make_obstacle()
    def play(self):
        self.hero.interact_with(self.obstacle)</pre>			<p>The <code>validate_age()</code> function <a id="_idIndexMarker133"/>prompts the user to give a valid age. If<a id="_idIndexMarker134"/> the age is not valid, it returns a tuple with the first element set to <code>False</code>. If the age is fine, the first element of the tuple is set to <code>True</code>, and that’s the case where we care about the second element of the tuple, which is the age given by the user, as follows:</p>
			<pre class="source-code">
def validate_age(name):
    age = None
    try:
        age_input = input(
            f"Welcome {name}. How old are you? "
        )
        age = int(age_input)
    except ValueError:
        print(
            f"Age {age} is invalid, please try again..."
        )
        return False, age
    return True, age</pre>			<p>Finally <a id="_idIndexMarker135"/>comes the <code>main()</code> function definition, followed <a id="_idIndexMarker136"/>by calling it. It asks for the user’s name and age and decides which game should be played, given the age of the user, as follows:</p>
			<pre class="source-code">
def main():
    name = input("Hello. What's your name? ")
    valid_input = False
    while not valid_input:
        valid_input, age = validate_age(name)
    game = FrogWorld if age &lt; 18 else WizardWorld
    environment = GameEnvironment(game(name))
    environment.play()
if __name__ == "__main__":
    main()</pre>			<p>The summary for the implementation we just discussed (see the complete code in the <code>ch03/factory/abstract_factory.py</code> file) is as follows:</p>
			<ol>
				<li>We define <code>Frog</code> and <code>Bug</code> classes for <a id="_idIndexMarker137"/>the <strong class="bold">FrogWorld</strong> game.</li>
				<li>We add a <code>FrogWorld</code> class, where we use our <code>Frog</code> and <code>Bug</code> classes.</li>
				<li>We define <code>Wizard</code> and <code>Ork</code> classes for<a id="_idIndexMarker138"/> the <strong class="bold">WizardWorld</strong> game.</li>
				<li>We add a <code>WizardWorld</code> class, where we use our <code>Wizard</code> and <code>Ork</code> classes.</li>
				<li>We define a <code>GameEnvironment</code> class.</li>
				<li>We add a <code>validate_age()</code> function.</li>
				<li>Finally, we have the <code>main()</code> function, followed by the conventional trick for calling it. The following are the aspects of this function:<ul><li>We get the user’s input for name and age.</li><li>We decide which game class to use based on the user’s age.</li><li>We instantiate the right game class, and then the <code>GameEnvironment</code> class.</li><li>We call <code>.play()</code> on the <code>environment</code> object to play the game.</li></ul></li>
			</ol>
			<p>Let’s call this<a id="_idIndexMarker139"/> program<a id="_idIndexMarker140"/> using the <code>python ch03/factory/abstract_factory.py</code> command and see some sample output.</p>
			<p>The sample output for a teenager is as follows:</p>
			<pre class="console">
Hello. What's your name? Arthur
Welcome Arthur. How old are you? 13
------ Frog World -------
Arthur the Frog encounters a bug and eats it!</pre>			<p>The sample output for an adult is as follows:</p>
			<pre class="console">
Hello. What's your name? Tom
Welcome Tom. How old are you? 34
------ Wizard World -------
Tom the Wizard battles against an evil ork and kills it!</pre>			<p>Try extending the game to make it more complete. You can go as far as you want; create many obstacles, many enemies, and whatever else you like.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor068"/>The builder pattern</h1>
			<p>We just covered <a id="_idIndexMarker141"/>the first two creational patterns, the factory method and the abstract factory, which both offer <a id="_idIndexMarker142"/>approaches to improve the way we create objects in nontrivial cases.</p>
			<p>Now, imagine that we want to create an object that is composed of multiple parts, and the composition needs to be done step by step. The object is not complete unless all its parts are fully created. That’s where the builder design pattern can help us. The builder pattern separates the construction of a complex object from its representation. By keeping the construction separate from the representation, the same construction can be used to create several different representations.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor069"/>Real-world examples</h2>
			<p>In our everyday life, the builder<a id="_idIndexMarker143"/> design pattern is used in fast-food restaurants. The same procedure is always used to prepare a burger and the packaging (box and paper bag), even if there are many kinds of burgers (classic, cheeseburger, and more) and different packages (small-sized box, medium-sized box, and so forth). The difference between a classic burger and a cheeseburger is in the representation and not in the construction procedure. In this case, the director is the cashier who gives instructions about what needs to be prepared to the crew, and the builder is the person from the crew who takes care of the specific order.</p>
			<p>In so<a href="https://github.com/ambitioninc/django-query-builder">ftware, we can think of the <code>django-query-builder</code> li</a>brary (<a href="https://github.com/ambitioninc/django-query-builder">https://github.com/ambitioninc/django-query-builder</a>), a third-party Django library that relies on the builder pattern. This library can be used for building SQL queries dynamically, allowing you to control all aspects of a query and create a different range of queries, from<a id="_idIndexMarker144"/> simple to very complex ones.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor070"/>Comparison with the factory pattern</h2>
			<p>At this point, the <a id="_idIndexMarker145"/>distinction between the <a id="_idIndexMarker146"/>builder pattern and the factory pattern might not be very clear. The main difference is that a factory pattern creates an object in a single step, whereas a builder pattern creates an object in multiple steps and almost always uses a <em class="italic">director</em>.</p>
			<p>Another difference is that<a id="_idIndexMarker147"/> while the factory pattern returns a <a id="_idIndexMarker148"/>created object immediately, in the builder pattern, the client code explicitly asks the director to return the final object when it needs it.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor071"/>Use cases for the builder pattern</h2>
			<p>The builder pattern is <a id="_idIndexMarker149"/>particularly useful when an object needs to be constructed with numerous possible configurations. A typical case is a situation where a class has multiple constructors with a varying number of parameters, often leading to confusion or error-prone code.</p>
			<p>The pattern is also beneficial when the object’s construction process is more complex than simply setting initial values. For example, if an object’s full creation involves multiple steps, such as parameter validation, setting up data structures, or even making calls to external services, the builder pattern can encapsulate this complexity.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor072"/>Implementing the builder pattern</h2>
			<p>Let’s see how we can use<a id="_idIndexMarker150"/> the builder design pattern to make a pizza-ordering application. This example is particularly interesting because a pizza is prepared in steps that should follow a specific order. To add the sauce, you first need to <a id="_idIndexMarker151"/>prepare the dough. To add the topping, you first need to add the sauce. And you can’t start baking the pizza unless both the sauce and the topping are placed on the dough. Moreover, each pizza usually requires a different baking time, depending on the thickness of its dough and the topping used.</p>
			<p>We start <a id="_idIndexMarker152"/>by importing the required modules and declaring a few <code>Enum</code> parameters plus a constant that is used many times in the application. The <code>STEP_DELAY</code> constant is used to add a time delay between the different steps of preparing a pizza (prepare the dough, add the sauce, and so on) as follows:</p>
			<pre class="source-code">
import time
from enum import Enum
PizzaProgress = Enum(
    "PizzaProgress", "queued preparation baking ready"
)
PizzaDough = Enum("PizzaDough", "thin thick")
PizzaSauce = Enum("PizzaSauce", "tomato creme_fraiche")
PizzaTopping = Enum(
    "PizzaTopping",
    "mozzarella double_mozzarella bacon ham mushrooms red_onion oregano",
)
# Delay in seconds
STEP_DELAY = 3</pre>			<p>Our end product is a pizza, which is described by the <code>Pizza</code> class. When using the builder pattern, the end product does not have many responsibilities, since it is not supposed to be instantiated directly. A builder creates an instance of the end product and makes sure that it is properly prepared. That’s why the <code>Pizza</code> class is so minimal. It basically initializes all data to sane default values. An exception is the <code>prepare_dough()</code> method.</p>
			<p>The <code>prepare_dough()</code> method is defined in the <code>Pizza</code> class instead of a builder for two reasons. First, to <a id="_idIndexMarker153"/>clarify the fact that the end product is typically minimal, which <a id="_idIndexMarker154"/>does not mean that you should never assign it any responsibilities. Second, to promote code reuse through composition.</p>
			<p>So, we define our <code>Pizza</code> class as follows:</p>
			<pre class="source-code">
class Pizza:
    def __init__(self, name):
        self.name = name
        self.dough = None
        self.sauce = None
        self.topping = []
    def __str__(self):
        return self.name
    def prepare_dough(self, dough):
        self.dough = dough
        print(
            f"preparing the {self.dough.name} dough of your {self}..."
        )
        time.sleep(STEP_DELAY)
        print(f"done with the {self.dough.name} dough")</pre>			<p>There are two builders: one for creating a margarita pizza (<code>MargaritaBuilder</code>) and another for creating a creamy bacon pizza (<code>CreamyBaconBuilder</code>). Each builder creates a <code>Pizza</code> instance and contains methods that follow the pizza-making procedure: <code>prepare_dough()</code>, <code>add_sauce()</code>, <code>add_topping()</code>, and <code>bake()</code>. To be precise, <code>prepare_dough()</code> is just a wrapper to the <code>prepare_dough()</code> method of the <code>Pizza</code> class.</p>
			<p>Notice how each builder takes care of all the pizza-specific details. For example, the topping of the margarita pizza is double mozzarella and oregano, while the topping of the creamy bacon pizza is mozzarella, bacon, ham, mushrooms, red onion, and oregano.</p>
			<p>An extract of <a id="_idIndexMarker155"/>the code of the <code>MargaritaBuilder</code> class is<a id="_idIndexMarker156"/> as follows (see the <code>ch03/builder.py</code> file for the whole code):</p>
			<pre class="source-code">
class MargaritaBuilder:
    def __init__(self):
        self.pizza = Pizza("margarita")
        self.progress = PizzaProgress.queued
        self.baking_time = 5
    def prepare_dough(self):
        self.progress = PizzaProgress.preparation
        self.pizza.prepare_dough(PizzaDough.thin)
    ...</pre>			<p>An extract of the code of the <code>CreamyBaconBuilder</code> class is as follows:</p>
			<pre class="source-code">
class CreamyBaconBuilder:
    def __init__(self):
        self.pizza = Pizza("creamy bacon")
        self.progress = PizzaProgress.queued
        self.baking_time = 7
    def prepare_dough(self):
        self.progress = PizzaProgress.preparation
        self.pizza.prepare_dough(PizzaDough.thick)
    ...</pre>			<p>The <em class="italic">director</em> in this <a id="_idIndexMarker157"/>example is the waiter. The core of the <code>Waiter</code> class is<a id="_idIndexMarker158"/> the <code>construct_pizza()</code> method, which accepts a builder as a parameter and executes all the pizza-preparation steps in the right order. Choosing the appropriate builder, which can even be done at runtime, gives us the ability to create different pizza styles without modifying any of the code of the director (<code>Waiter</code>). The <code>Waiter</code> class also contains the <code>pizza()</code> method, which returns the end product (prepared pizza) as a variable to the caller. The <a id="_idIndexMarker159"/>code for<a id="_idIndexMarker160"/> that class is as follows:</p>
			<pre class="source-code">
class Waiter:
    def __init__(self):
        self.builder = None
    def construct_pizza(self, builder):
        self.builder = builder
        steps = (
            builder.prepare_dough,
            builder.add_sauce,
            builder.add_topping,
            builder.bake,
        )
        [step() for step in steps]
    @property
    def pizza(self):
        return self.builder.pizza</pre>			<p>The <code>validate_style()</code> method is similar to the <code>validate_age()</code> function, as described in the section titled <em class="italic">The factory pattern</em> earlier in this chapter. It is used to make sure that the user gives valid input, which in this case is a character that is mapped to a pizza builder. The <code>m</code> character uses the <code>MargaritaBuilder</code> class, and the <code>c</code> character uses the <code>CreamyBaconBuilder</code> class. These mappings are in the <code>builder</code> parameter. A tuple is returned, with the first element set to <code>True</code> if the<a id="_idIndexMarker161"/> input is<a id="_idIndexMarker162"/> valid or <code>False</code> if it is invalid, as follows:</p>
			<pre class="source-code">
def validate_style(builders):
    try:
        input_msg = "What pizza would you like, [m]argarita or [c]reamy bacon? "
        pizza_style = input(input_msg)
        builder = builders[pizza_style]()
        valid_input = True
    except KeyError:
        error_msg = "Sorry, only margarita (key m) and creamy bacon (key c) are available"
        print(error_msg)
        return (False, None)
    return (True, builder)</pre>			<p>The last part is the <code>main()</code> function. The <code>main()</code> function contains code for instantiating a pizza builder. The pizza builder is then used by the <code>Waiter</code> director to prepare the pizza. The created pizza <a id="_idIndexMarker163"/>can be delivered to the client at any later point:</p>
			<pre class="source-code">
def main():
    builders = dict(m=MargaritaBuilder, c=CreamyBaconBuilder)
    valid_input = False
    while not valid_input:
        valid_input, builder = validate_style(builders)
    print()
    waiter = Waiter()
    waiter.construct_pizza(builder)
    pizza = waiter.pizza
    print()
    print(f"Enjoy your {pizza}!")</pre>			<p>Here is a<a id="_idIndexMarker164"/> summary of the implementation (in the <code>ch03/builder.py</code> file):</p>
			<ol>
				<li>We start with a couple of imports we need, for the standard <code>Enum</code> class and <code>time</code> module.</li>
				<li>We declare variables for<a id="_idIndexMarker165"/> a few constants: <code>PizzaProgress</code>, <code>PizzaDough</code>, <code>PizzaSauce</code>, <code>PizzaTopping</code>, and <code>STEP_DELAY</code>.</li>
				<li>We define our <code>Pizza</code> class.</li>
				<li>We define classes for two builders, <code>MargaritaBuilder</code> and <code>CreamyBaconBuilder</code>.</li>
				<li>We define our <code>Waiter</code> class.</li>
				<li>We add a <code>validate_style()</code> function to improve things regarding exception handling.</li>
				<li>Finally, we have the <code>main()</code> function, followed by a snippet for calling it when the program is run. In the <code>main()</code> function, the following happens:<ul><li>We make it possible to choose the pizza builder based on the user’s input, after validation via the <code>validate_style()</code> function.</li><li>The pizza builder is used by the waiter for preparing the pizza.</li><li>The created pizza is then delivered.</li></ul></li>
			</ol>
			<p>Here is the output<a id="_idIndexMarker166"/> produced by calling the <code>python ch03/builder.py</code> command to execute this example program:</p>
			<pre class="console">
What pizza would you like, [m]argarita or [c]reamy bacon? c
preparing the thick dough of your creamy bacon...
done with the thick dough
adding the crème fraîche sauce to your creamy bacon
done with the crème fraîche sauce
adding the topping (mozzarella, bacon, ham, mushrooms, red onion, oregano) to your creamy bacon
done with the topping (mozzarella, bacon, ham, mushrooms, red onion, oregano)
baking your creamy bacon for 7 seconds
your creamy bacon is ready
Enjoy your creamy bacon!</pre>			<p>That was a nice result.</p>
			<p>But... supporting<a id="_idIndexMarker167"/> only two pizza types is a shame. Feel like getting <a id="_idIndexMarker168"/>a Hawaiian pizza builder? Consider using <em class="italic">inheritance</em> after thinking about the advantages and disadvantages. Or <em class="italic">composition</em>, which has its advantages, as we have seen in <a href="B21896_01.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">Foundational </em><em class="italic">Design Principles</em>.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor073"/>The prototype pattern</h1>
			<p>The prototype pattern<a id="_idIndexMarker169"/> allows you to create new objects by copying existing ones, rather<a id="_idIndexMarker170"/> than creating them from scratch. This pattern is particularly useful when the cost of initializing an object is more expensive or complex than copying an existing one. In essence, the prototype pattern enables you to create a new instance of a class by duplicating an existing instance, thereby avoiding the overhead of initializing a new object.</p>
			<p>In its simplest version, this pattern is just a <code>clone()</code> function that accepts an object as an input parameter and returns a clone of it. In Python, this can be done using the <code>copy.deepcopy()</code> function.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor074"/>Real-world examples</h2>
			<p>Cloning a plant by taking a<a id="_idIndexMarker171"/> cutting is a real-world example of the prototype pattern. Using this approach, you don’t grow the plant from a seed; you create a new plant that’s a copy of an existing one.</p>
			<p>Many Python applications make use of the prototype pattern, but it is rarely referred to as <em class="italic">prototype</em> since cloning objects is a built-in feature of the Python language.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor075"/>Use cases for the prototype pattern</h2>
			<p>The prototype pattern is <a id="_idIndexMarker172"/>useful when we have an existing object that needs to <a id="_idIndexMarker173"/>stay untouched and we want to create an exact copy of it, allowing changes in some parts of the copy.</p>
			<p>There is also the frequent need for duplicating an object that is populated from a database and has references to other database-based objects. It is costly (multiple queries to a database) to clone such a complex object, so a prototype is a convenient way to solve the problem.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor076"/>Implementing the prototype pattern</h2>
			<p>Nowadays, some<a id="_idIndexMarker174"/> organizations, even of small size, deal with many websites and apps via their infrastructure/DevOps teams, hosting <a id="_idIndexMarker175"/>providers, or <strong class="bold">cloud service </strong><strong class="bold">providers</strong> (<strong class="bold">CSPs</strong>).</p>
			<p>When you have to manage multiple websites, there is a point where it becomes difficult to follow. You need to access information quickly, such as IP addresses that are involved, domain names and their expiration dates, and maybe details about DNS parameters. So, you need a kind of inventory tool.</p>
			<p>Let’s imagine how these teams deal with this type of data for daily activities, and touch on the implementation of a piece of software that helps consolidate and maintain the data (other than in Excel spreadsheets).</p>
			<p>First, we need to import Python’s standard <code>copy</code> module, as follows:</p>
			<pre class="source-code">
import copy</pre>			<p>At the heart of this system, we will have a <code>Website</code> class for holding all useful information such as the name, the domain name, a description, the author of a website we are managing, and so on.</p>
			<p>In the <code>__init__()</code> method of the class, only some parameters are fixed: <code>name</code>, <code>domain</code>, and <code>description</code>. But we also want flexibility, and client code can pass more parameters in the form of keywords (<code>name=value</code>) using the <code>kwargs</code> variable-length collection (each pair becomes an item of the <code>kwargs</code> Python dictionary).</p>
			<p class="callout-heading">Additional information</p>
			<p class="callout">There is a Python idiom that helps to set an arbitrary attribute named <code>attr</code> with a <code>val</code> value on an <code>obj</code> object, using the <code>setattr()</code> built-in function: <code>setattr(obj, </code><code>attr, val)</code>.</p>
			<p>So we are <a id="_idIndexMarker176"/>defining a <code>Website</code> class and initializing its objects, using the <code>setattr</code> technique for optional<a id="_idIndexMarker177"/> attributes, as follows:</p>
			<pre class="source-code">
class Website:
    def __init__(
        self,
        name: str,
        domain: str,
        description: str,
        **kwargs,
    ):
        self.name = name
        self.domain = domain
        self.description = description
        for key in kwargs:
            setattr(self, key, kwargs[key])</pre>			<p>That’s not<a id="_idIndexMarker178"/> all. To improve the usability of the class, we also add its <a id="_idIndexMarker179"/>string representation method (<code>__str__()</code>). We extract the values of all instance attributes, using the <code>vars()</code> trick, and inject those values into the string that the method returns. Also, since we plan to clone objects, we include the object’s memory address using the <code>id()</code> function. The code i<a id="_idTextAnchor077"/>s as follows:</p>
			<pre class="source-code">
def __str__(self) -&gt; str:
    summary = [
        f"- {self.name} (ID: {id(self)})\n",
    ]
    infos = vars(self).items()
    ordered_infos = sorted(infos)
    for attr, val in ordered_infos:
        if attr == "name":
            continue
        summary.append(f"{attr}: {val}\n")
    return "".join(summary)</pre>			<p class="callout-heading">Additional information</p>
			<p class="callout">The <code>vars()</code> function in Python returns the <code>__dict__</code> attribute of an object. The <code>__dict__</code> attribute is a dictionary containing the object’s attributes (both data attributes and methods). This function is useful for debugging, as it allows you to inspect the attributes and methods of an object or the local variables within a function. But note that not all objects have a <code>__dict__</code> attribute. For example, built-in types such as lists and dictionaries do not have this attribute.</p>
			<p>Next, we <a id="_idIndexMarker180"/>add a <code>Prototype</code> class that implements the prototype design pattern. At the heart of this class, we have the <code>clone()</code> method, which is in charge of cloning the object using the <code>copy.deepcopy()</code> function.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When we clone an object using <code>copy.deepcopy()</code>, the memory address of the clone must be different from the memory address of the original object.</p>
			<p>Since cloning means <a id="_idIndexMarker181"/>that we allow setting values for optional attributes, notice how we use the <code>setattr</code> technique here with the <code>attrs</code> dictionary. Also, for more convenience, the <code>Prototype</code> class contains the <code>register()</code> and <code>unregister()</code> methods, which can be used to keep track of the cloned objects in a registry (a dictionary). The code of that class is as follows:</p>
			<pre class="source-code">
class Prototype:
    def __init__(self):
        self.registry = {}
    def register(self, identifier: int, obj: object):
        self.registry[identifier] = obj
    def unregister(self, identifier: int):
        del self.registry[identifier]
    def clone(self, identifier: int, **attrs) -&gt; object:
        found = self.registry.get(identifier)
        if not found:
            raise ValueError(
              f"Incorrect object identifier: {identifier}"
            )
        obj = copy.deepcopy(found)
        for key in attrs:
            setattr(obj, key, attrs[key])
        return obj</pre>			<p>In the <code>main()</code> function, which we define next, we complete the program: we clone a first <code>Website</code> instance, <code>site1</code>, to get a second object <code>site2</code>. Basically, we instantiate the <code>Prototype</code> class and <a id="_idIndexMarker182"/>we use its <code>.clone()</code> method. Then, we display the result. The<a id="_idIndexMarker183"/> code for that function is as follows:</p>
			<pre class="source-code">
def main():
    keywords = (
        "python",
        "programming",
        "scripting",
        "data",
        "automation",
    )
    site1 = Website(
        "Python",
        domain="python.org",
        description="Programming language and ecosystem",
        category="Open Source Software",
        keywords=keywords,
    )
    proto = Prototype()
    proto.register("python-001", site1)
    site2 = proto.clone(
        "python-001",
        name="Python Package Index",
        domain="pypi.org",
        description="Repository for published packages",
        category="Open Source Software",
    )
    for site in (site1, site2):
        print(site)</pre>			<p>Finally, we call the <code>main()</code> function, as follows:</p>
			<pre class="source-code">
if __name__ == "__main__":
    main()</pre>			<p>Here is a <a id="_idIndexMarker184"/>summary of <a id="_idIndexMarker185"/>what we do in the code (<code>ch03/prototype.py</code>):</p>
			<ol>
				<li>We start by importing the <code>copy</code> module.</li>
				<li>We define a <code>Website</code> class, with its initialization method (<code>__init__()</code>) and its string representation method (<code>__str__()</code>).</li>
				<li>We define our <code>Prototype</code> class as shown earlier.</li>
				<li>Then, we have the <code>main()</code> function, where we do the following:<ul><li>We define a <code>keywords</code> list we need.</li><li>We create an instance of the <code>Website</code> class, called <code>site1</code> (we use the <code>keywords</code> list here).</li><li>We create a <code>Prototype</code> object and we use its <code>register()</code> method to register <code>site1</code> with its identifier (this helps us keep track of the cloned objects in a dictionary).</li><li>We clone the <code>site1</code> object to get <code>site2</code>.</li><li>We display the result (both <code>Website</code> objects).</li></ul></li>
			</ol>
			<p>A sample output when I<a id="_idIndexMarker186"/> execute the <code>python ch03/prototype.py</code> command<a id="_idIndexMarker187"/> on my computer is as follows:</p>
			<pre class="console">
- Python (ID: 4369628560)
category: Open Source Software
description: Programming language and ecosystem
domain: python.org
keywords: ('python', 'programming', 'scripting', 'data', 'automation')
- Python Package Index (ID: 4369627552)
category: Open Source Software
description: Repository site for Python's published packages
domain: pypi.org
keywords: ('python', 'programming', 'scripting', 'data', 'automation')</pre>			<p>Indeed, <code>Prototype</code> works as expected. We can see information about the original <code>Website</code> object and its clone.</p>
			<p>And looking at the ID value<a id="_idIndexMarker188"/> for each <code>Website</code> object, we can see that the <a id="_idIndexMarker189"/>two addresses are different.</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor078"/>The singleton pattern</h1>
			<p>One of the original <a id="_idIndexMarker190"/>design patterns for OOP, the singleton pattern restricts the<a id="_idIndexMarker191"/> instantiation of a class to <em class="italic">one</em> object, which is useful when you need one object to coordinate actions for the system.</p>
			<p>The basic idea is that only one instance of a particular class, doing a job, is created for the needs of the program. To ensure that this works, we need mechanisms that prevent the instantiation of the class more than once and also prevent cloning.</p>
			<p>In the Python programmer community, the singleton pattern is actually considered an anti-pattern. Let’s explore the pattern first, and later we will discuss the alternative approaches we are encouraged to use in Python.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor079"/>Real-world examples</h2>
			<p>In a real-life <a id="_idIndexMarker192"/>scenario, we can think of the captain of a ship or a boat. On the ship, they are the ones in charge. They are responsible for important decisions, and a number of requests are directed to them because of this responsibility.</p>
			<p>Another example is the printer spooler, in an office environment, which ensures that print jobs are coordinated through a single point, avoiding conflicts and ensuring orderly printing.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor080"/>Use cases for the singleton pattern</h2>
			<p>The<a id="_idIndexMarker193"/> singleton design pattern is useful when you need to create only one object or you need some sort of object capable of maintaining a global state for your program.</p>
			<p>Other possible use cases are the following:</p>
			<ul>
				<li>Controlling concurrent access to a shared resource—for example, the class managing the connection to a database</li>
				<li>A service or resource that is transversal in the sense that it can be accessed from different parts of the application or by different users and do its work—for example, the<a id="_idIndexMarker194"/> class at the core of a logging system or utility</li>
			</ul>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor081"/>Implementing the singleton pattern</h2>
			<p>As discussed, the<a id="_idIndexMarker195"/> singleton pattern ensures that a class has only one <a id="_idIndexMarker196"/>instance and provides a global point to access it. In this example, we’ll create a <code>URLFetcher</code> class that fetches content from web pages. We want to ensure that only one instance of this class exists to keep track of all fetched URLs.</p>
			<p>Imagine you have multiple fetchers in different parts of your program, but you want to keep track of all URLs that have been fetched. This is a classic case for a singleton pattern. By ensuring that all parts of your program use the same fetcher instance, you can easily keep track of all fetched URLs in one place.</p>
			<p>Initially, we create a naive version of the <code>URLFetcher</code> class. This class has a <code>fetch()</code> method that fetches the web page content and stores the URL in a list:</p>
			<pre class="source-code">
import urllib.request
class URLFetcher:
    def __init__(self):
        self.urls = []
    def fetch(self, url):
        req = urllib.request.Request(url)
        with urllib.request.urlopen(req) as response:
            if response.code == 200:
                page_content = response.read()
             with open("content.html", "a") as f:
                 f.write(page_content + "\n")
             self.urls.append(url)</pre>			<p>To check if<a id="_idIndexMarker197"/> our class is a <code>is</code> operator. If they are the same, then it’s a singleton:</p>
			<pre class="source-code">
if __name__ == "__main__":
    print(URLFetcher() is URLFetcher())</pre>			<p>If you run this code (<code>ch03/singleton/before_singleton.py</code>), you’ll see that the output is the following:</p>
			<pre class="console">
False</pre>			<p>This output shows that the class in this version does not yet respect the singleton pattern. To <a id="_idIndexMarker198"/>make it a<a id="_idIndexMarker199"/> singleton, we’ll use the <strong class="bold">metaclass</strong> technique.</p>
			<p class="callout-heading">Additional information</p>
			<p class="callout">A metaclass in Python is a class of a class that defines how a class behaves.</p>
			<p>We’ll create a <code>SingletonType</code> metaclass that ensures that only one instance of <code>URLFetcher</code> exists, as follows:</p>
			<pre class="source-code">
import urllib.request
class SingletonType(type):
    _instances = {}
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            obj = super(SingletonType, cls).__call__(*args, **kwargs)
            cls._instances[cls] = obj
        return cls._instances[cls]</pre>			<p>Now, we <a id="_idIndexMarker200"/>modify our <code>URLFetcher</code> class to use this metaclass, as<a id="_idIndexMarker201"/> follows:</p>
			<pre class="source-code">
class URLFetcher(metaclass=SingletonType):
    def __init__(self):
        self.urls = []
    def fetch(self, url):
        req = urllib.request.Request(url)
        with urllib.request.urlopen(req) as response:
            if response.code == 200:
                page_content = response.read()
                with open("content.html", "a") as f:
                    f.write(str(page_content))
                self.urls.append(url)</pre>			<p>Finally, we create a <code>main()</code> function and call it to test our singleton, with the following code:</p>
			<pre class="source-code">
def main():
    my_urls = [
            "http://python.org",
            "https://planetpython.org/",
            "https://www.djangoproject.com/",
    ]
    print(URLFetcher() is URLFetcher())
    fetcher = URLFetcher()
    for url in my_urls:
        fetcher.fetch(url)
    print(f"Done URLs: {fetcher.urls}")
if __name__ == "__main__":
    main()</pre>			<p>Here is a summary of what we do in the code (<code>ch03</code><code>/singleton/singleton.py</code>):</p>
			<ol>
				<li>We start with our needed module imports (<code>urllib.request</code>).</li>
				<li>We define a <code>SingletonType</code> class, with its special <code>__call__()</code> method.</li>
				<li>We define <code>URLFetcher</code>, the class implementing the fetcher for the web pages, initializing it with the <code>urls</code> attribute; as discussed, we add its <code>fetch()</code> method.</li>
				<li>Lastly, we <a id="_idIndexMarker202"/>add our <code>main()</code> function, and we add Python’s<a id="_idIndexMarker203"/> conventional snippet used to call it.</li>
			</ol>
			<p>To test the implementation, run the <code>python ch03/singleton/singleton.py</code> command. You should get the following output:</p>
			<pre class="console">
True
Done URLs: ['http://python.org', 'https://planetpython.org/', 'https://www.djangoproject.com/']</pre>			<p>In addition, you <a id="_idIndexMarker204"/>will find that a file called <code>content.html</code> has been created, with the HTML text that comes from the different URLs added to it.</p>
			<p>So, the program did its job as expected. This is a demonstration of how the singleton pattern may be used.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor082"/>Should you use the singleton pattern?</h2>
			<p>While the<a id="_idIndexMarker205"/> singleton pattern has its merits, it may not always be the most Pythonic approach to managing global states or resources. Our implementation example worked, but if we stop a minute to analyze the code again, we notice the following:</p>
			<ul>
				<li>The techniques used for the implementation are rather advanced and not easy to explain to a beginner</li>
				<li>By reading the <code>SingletonType</code> class definition, it is not easy to immediately see that it provides a metaclass for a singleton if the name does not suggest it</li>
			</ul>
			<p>In Python, developers often prefer a simpler alternative to singleton: using a module-level global object.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Python modules act as natural namespaces that can contain variables, functions, and classes, making them ideal for organizing and sharing global resources.</p>
			<p>By adopting the global object technique, as explained by Brandon Rhodes in what he calls the <em class="italic">Global Object Pattern</em> (<a href="https://python-patterns.guide/python/module-globals/">https://python-patterns.guide/python/module-globals/</a>), you can achieve the same result as the singleton pattern without the need for complex instantiation processes or forcing a class to only have one instance.</p>
			<p>As an exercise, you can re-write the implementation of our example using a global object. For reference, the equivalent code, defining a global object, is provided in the <code>ch03/singleton/instead_of_singleton/example.py</code> file; for its use, check the <code>ch03/singleton/instead_of_singleton/use_example.py</code> file.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor083"/>The object pool pattern</h1>
			<p>The <a id="_idIndexMarker206"/>object pool pattern is <a id="_idIndexMarker207"/>a creational design pattern that allows you to reuse existing objects instead of creating new ones when they are needed. This pattern is particularly useful when the cost, in terms of system resources, time, and so on of initializing a new object is high.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor084"/>Real-world examples</h2>
			<p>Consider a car rental service. When a <a id="_idIndexMarker208"/>customer rents a car, the service doesn’t manufacture a new car for them. Instead, it provides one from a pool of available cars. Once the customer returns the car, it goes back into the pool, ready to be used by the next customer.</p>
			<p>Another example would be a public swimming pool. Rather than filling the pool with water every time someone wants to swim, the water is treated and reused for multiple swimmers. This saves both time and resources.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor085"/>Use cases for the object pool pattern</h2>
			<p>The object pool pattern is<a id="_idIndexMarker209"/> especially useful in scenarios where resource initialization is costly or time-consuming. This could be in terms of CPU cycles, memory usage, or even network bandwidth. For example, in a shooting video game, you might use this pattern to manage bullet objects. Creating a new bullet every time a gun is fired could be resource-intensive. Instead, you could have a pool of bullet objects that are reused.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor086"/>Implementing the object pool pattern</h2>
			<p>Let’s implement a pool <a id="_idIndexMarker210"/>of reusable <code>car</code> objects, for a car rental application, to avoid creating and destroying them repeatedly.</p>
			<p>First, we need to define a <code>Car</code> class, as follows:</p>
			<pre class="source-code">
class Car:
    def __init__(self, make: str, model: str):
        self.make = make
        self.model = model
        self.in_use = False</pre>			<p>Then, we start defining a <code>CarPool</code> class with its initialization, as follows:</p>
			<pre class="source-code">
class CarPool:
    def __init__(self):
        self._available = []
        self._in_use = []</pre>			<p>We need to<a id="_idIndexMarker211"/> express what happens when a client acquires a <a id="_idIndexMarker212"/>car. For that, we define a method on the class doing the following: if no car is available, we instantiate one and add it to the list of available cars in the pool; else, we return an available <code>car</code> object, while doing the following:</p>
			<ul>
				<li>Setting the <code>_in_use</code> attribute of the <code>car</code> object to <code>True</code></li>
				<li>Adding the <code>car</code> object to the list of “in use” cars (stored in the <code>_in_use</code> attribute of the <code>pool</code> object)</li>
			</ul>
			<p>We add the code of that method to the class as follows:</p>
			<pre class="source-code">
    def acquire_car(self) -&gt; Car:
        if len(self._available) == 0:
            new_car = Car("BMW", "M3")
            self._available.append(new_car)
        car = self._available.pop()
        self._in_use.append(car)
        car.in_use = True
        return car</pre>			<p>We then add a method that handles things when a client releases a car, as follows:</p>
			<pre class="source-code">
    def release_car(self, car: Car) -&gt; None:
        car.in_use = False
        self._in_use.remove(car)
        self._available.append(car)</pre>			<p>Finally, we <a id="_idIndexMarker213"/>add some <a id="_idIndexMarker214"/>code for testing the result of the implementation, as follows:</p>
			<pre class="source-code">
if __name__ == "__main__":
    pool = CarPool()
    car_name = "Car 1"
    print(f"Acquire {car_name}")
    car1 = pool.acquire_car()
    print(f"{car_name} in use: {car1.in_use}")
    print(f"Now release {car_name}")
    pool.release_car(car1)
    print(f"{car_name} in use: {car1.in_use}")</pre>			<p>Here is a summary of what we do in the code (in file <code>ch03/object_pool.py</code>):</p>
			<ol>
				<li>We define a <code>Car</code> class.</li>
				<li>We define a <code>CarPool</code> class with the <code>acquire_car()</code> and <code>release_car()</code> methods, as shown earlier.</li>
				<li>We add code for testing the result of the implementation, as shown earlier.</li>
			</ol>
			<p>To test the program, run the following command:</p>
			<pre class="console">
python ch03/object_pool.py</pre>			<p>You should get the following output:</p>
			<pre class="console">
Acquire Car 1
Car 1 in use: True
Now release Car 1
Car 1 in use: False</pre>			<p>Well done! This<a id="_idIndexMarker215"/> output shows that our object pool pattern <a id="_idIndexMarker216"/>implementation works as intended.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor087"/>Summary</h1>
			<p>In this chapter, we have seen <em class="italic">creational design patterns</em>, which are essential for crafting flexible, maintainable, and modular code. We kicked off the chapter by examining two variations of the factory pattern, each offering unique advantages for object creation. Next, we navigated through the builder pattern, which provides a more readable and maintainable way to construct complex objects. The prototype pattern followed, introducing a method to clone objects efficiently. Finally, we rounded out the chapter by discussing the singleton and object pool patterns, both of which are geared toward optimizing resource management and ensuring consistent state across the application.</p>
			<p>Now, equipped with these foundational patterns for object creation, we are well prepared for the next chapter, where we will discover <em class="italic">structural </em><em class="italic">design patterns</em>.</p>
		</div>
	</body></html>