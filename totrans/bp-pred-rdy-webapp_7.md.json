["```py\nfrom quart import Response\nfrom werkzeug.http import COOP \n@app.after_request\nasync def add_headers(response: Response) -> Response:\n    response.content_security_policy.default_src = \"'self'\"\n    response.content_security_policy.connect_src = \"'self' *.sentry.io\"\n    response.content_security_policy.frame_ancestors = \"'none'\"\n    response.content_security_policy.report_uri = \"https://ingest.sentry.io\"        \n    response.content_security_policy.style_src = \"'self' 'unsafe-inline'\"\n    response.cross_origin_opener_policy = COOP.SAME_ORIGIN\n    response.headers[\"Referrer-Policy\"] = \"no-referrer, strict-origin-when-cross-origin\"\n    response.headers[\"X-Content-Type-Options\"] = \"nosniff\"\n    response.headers[\"X-Frame-Options\"] = \"SAMEORIGIN\"\n    response.headers[\n        \"Strict-Transport-Security\"\n    ] = \"max-age=63072000; includeSubDomains; preload\"\n    return response\n```", "```py\nREFERENCE_HASH = \"$2b$12$A.BRD7hCbGciBiqNRTqxZ.odBxGo.XmRmgN4u9Jq7VUkW9xRmPxK.\"\n@blueprint.post(\"/sessions/\")\n@rate_limit(5, timedelta(minutes=1))\n@validate_request(LoginData)\nasync def login(data: LoginData) -> ResponseReturnValue:\n    \"\"\"Login to the app.\n\n    By providing credentials and then saving the     returned cookie.\n    \"\"\"\n    result = await select_member_by_email(        g.connection, data.email     )\n    password_hash = REFERENCE_HASH\n    if result is not None:\n        password_hash = result.password_hash \n    passwords_match = bcrypt.checkpw(\n        data.password.encode(\"utf-8\"),\n        password_hash.encode(\"utf-8\"),\n    )\n    if passwords_match and result is not None:\n        login_user(AuthUser(str(result.id)), data.remember)\n        return {}, 200\n    else:\n        raise APIError(401, \"INVALID_CREDENTIALS\")\n```", "```py\npdm add disposable-email-domains\n```", "```py\nfrom disposable_email_domains import blocklist  # type: ignore\nasync def register(data: MemberData) -> ResponseReturnValue:\n    email_domain = data.email.split(\"@\", 1)[1]\n    if email_domain in blocklist:\n        raise APIError(400, \"INVALID_DOMAIN\")\n    ...\n```", "```py\nconst useRegister = () => { \n      ...\n      if (\n        error.response?.status === 400 &&\n        error.response?.data.code === \"WEAK_PASSWORD\"\n      ) {\n        setFieldError(\"password\", \"Password is too weak\");\n      } else if (\n        error.response?.status === 400 &&\n        error.response?.data.code === \"INVALID_DOMAIN\"\n      ) {\n        setFieldError(\"email\", \"Invalid email domain\");\n      } else {\n        addToast(\"Try again\", \"error\");\n      }\n      ...\n}\n```", "```py\nname: Audit\n\non: \n  schedule:\n    - cron: \"0 9 * * 2\"\njobs:\n```", "```py\n  frontend-audit:\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        working-directory: frontend\n\n    steps:\n      - name: Use Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '18'\n\n      - uses: actions/checkout@v3  \n      - name: Initialise dependencies\n        run: npm ci --cache .npm --prefer-offline\n      - name: Audit the dependencies\n        run: npm audit\n```", "```py\npdm add --dev pip-audit\n```", "```py\n[tool.pdm.scripts]\naudit = \"pip-audit\"\n```", "```py\n  backend-audit:\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        working-directory: backend\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v4\n        with:\n          python-version: '3.10'\n\n      - name: Initialise dependencies\n        run: |\n          pip install pdm\n          pdm install \n      - name: Audit the dependencies\n        run: pdm run audit\n```", "```py\n  \"dependencies\": {\n    \"@emotion/react\": \"*\",\n    \"@emotion/styled\": \"*\",\n     ...\n  },\n  \"devDependencies\": {\n    \"@types/zxcvbn\": \"*\",\n    \"eslint\": \"*\",\n    ...\n  }\n```", "```py\nnpm update \n```", "```py\npdm update \n```", "```py\nterraform init –upgrade\n```", "```py\nfrom quart_db import Connection\nasync def migrate(connection: Connection) -> None:\n    await connection.execute(\n        \"ALTER TABLE members ADD COLUMN totp_secret TEXT\"\n    )\n    await connection.execute(\n        \"ALTER TABLE members ADD COLUMN last_totp TEXT\"\n    )\nasync def valid_migration(connection: Connection) -> bool:\n    return True\n```", "```py\n@dataclass\nclass Member:\n    id: int\n    email: str\n    password_hash: str\n    created: datetime\n    email_verified: datetime | None \n    last_totp: str | None\n    totp_secret: str | None\n```", "```py\nasync def select_member_by_email(\n    db: Connection, email: str\n) -> Member | None:\n    result = await db.fetch_one(\n        \"\"\"SELECT id, email, password_hash, created,\n                  email_verified, last_totp, totp_secret\n             FROM members\n            WHERE LOWER(email) = LOWER(:email)\"\"\",\n        {\"email\": email},\n    )\n    return None if result is None else Member(**result)\nasync def select_member_by_id(\n    db: Connection, id: int\n) -> Member | None:\n    result = await db.fetch_one(\n        \"\"\"SELECT id, email, password_hash, created,\n                  email_verified, last_totp, totp_secret\n             FROM members\n            WHERE id = :id\"\"\",\n        {\"id\": id},\n    )\n    return None if result is None else Member(**result)\nasync def insert_member(\n    db: Connection, email: str, password_hash: str\n) -> Member:\n    result = await db.fetch_one(\n        \"\"\"INSERT INTO members (email, password_hash)\n                VALUES (:email, :password_hash)\n             RETURNING id, email, password_hash, created,\n                       email_verified, last_totp,                       totp_secret\"\"\",\n        {\"email\": email, \"password_hash\": password_hash},\n    )\n    return Member(**result)\n```", "```py\nasync def update_totp_secret(\n    db: Connection, id: int, totp_secret: str | None\n) -> None:\n    await db.execute(\n        \"\"\"UPDATE members\n              SET totp_secret = :totp_secret\n            WHERE id = :id\"\"\",\n        {\"id\": id, \"totp_secret\": totp_secret},\n    )\nasync def update_last_totp(\n    db: Connection, id: int, last_totp: str | None\n) -> None:\n    await db.execute(\n        \"\"\"UPDATE members\n              SET last_totp = :last_totp\n            WHERE id = :id\"\"\",\n        {\"id\": id, \"last_totp\": last_totp},\n    )\n```", "```py\npdm add pyotp\n```", "```py\nfrom typing import Literal\nfrom pyotp.totp import TOTP\nfrom quart_schema import validate_response\n@dataclass\nclass TOTPData:\n    state: Literal[\"ACTIVE\", \"PARTIAL\", \"INACTIVE\"]\n    totp_uri: str | None\n@blueprint.get(\"/members/mfa/\")\n@rate_limit(10, timedelta(seconds=10))\n@login_required\n@validate_response(TOTPData)\nasync def get_mfa_status() -> TOTPData:\n    member_id = int(cast(str, current_user.auth_id))\n    member = await select_member_by_id(g.connection, member_id)\n    assert member is not None  # nosec\n    totp_uri = None\n    state: Literal[\"ACTIVE\", \"PARTIAL\", \"INACTIVE\"]\n    if member.totp_secret is None:\n        state = \"INACTIVE\"\n    elif (\n        member.totp_secret is not None and         member.last_totp is None\n    ):\n        totp_uri = TOTP(member.totp_secret).provisioning_uri(\n            member.email, issuer_name=\"Tozo\"\n        )\n        state = \"PARTIAL\"\n    else:\n        state = \"ACTIVE\"\n    return TOTPData(state=state, totp_uri=totp_uri)\n```", "```py\nfrom pyotp import random_base32\nfrom backend.models.member import update_totp_secret\n@blueprint.post(\"/members/mfa/\")\n@rate_limit(10, timedelta(seconds=10))\n@login_required\n@validate_response(TOTPData)\nasync def initiate_mfa() -> TOTPData:\n    member_id = int(cast(str, current_user.auth_id))\n    member = await select_member_by_id(g.connection, member_id)\n    assert member is not None  # nosec\n    if member.totp_secret is not None:\n        raise APIError(409, \"ALREADY_ACTIVE\")\n    totp_secret = random_base32()\n    totp_uri = TOTP(totp_secret).provisioning_uri(\n        member.email, issuer_name=\"Tozo\"\n    )\n    await update_totp_secret(g.connection, member_id, totp_      secret)\n    return TOTPData(state=\"PARTIAL\", totp_uri=totp_uri) \n```", "```py\nfrom backend.models.member import update_last_totp\n@dataclass \nclass TOTPToken: \n    token: str\n@blueprint.put(\"/members/mfa/\")\n@rate_limit(10, timedelta(seconds=10))\n@login_required\n@validate_request(TOTPToken)\nasync def confirm_mfa(data: TOTPToken) -> ResponseReturnValue:\n    member_id = int(cast(str, current_user.auth_id))\n    member = await select_member_by_id(g.connection, member_id)\n    assert member is not None  # nosec\n    if member.totp_secret is None:\n        raise APIError(409, \"NOT_ACTIVE\")\n    totp = TOTP(member.totp_secret)\n    if totp.verify(data.token):\n        await update_last_totp(g.connection, member_id, data.          token)\n        return {}\n    else:\n        raise APIError(400, \"INVALID_TOKEN\")\n```", "```py\nnpm install qrcode.react\n```", "```py\nimport TextField, { TextFieldProps } from \"@mui/material/TextField\";\nimport { FieldHookConfig, useField } from \"formik\";\nimport { combineHelperText } from \"src/utils\";\nconst TotpField = (props: FieldHookConfig<string> & TextFieldProps) => {\n  const [field, meta] = useField<string>(props);\n  return (\n    <TextField\n      {...props}\n      autoComplete=\"one-time-code\"\n      error={Boolean(meta.error) && meta.touched}\n      helperText={combineHelperText(props.helperText, meta)}\n      inputProps={{ inputMode: \"numeric\", maxLength: 6,        pattern: \"[0-9]*\" }}\n      margin=\"normal\"\n      type=\"text\"\n      {...field}\n    />\n  );\n};\nexport default TotpField;\n```", "```py\nimport axios from \"axios\"; \nimport { useQueryClient } from \"@tanstack/react-query\";\nimport { useMutation } from \"src/query\";\nconst useActivateMFA = (): [() => Promise<void>, boolean] => {\n  const queryClient = useQueryClient();\n  const { mutateAsync: activate, isLoading } = useMutation(\n    async () => await axios.post(\"/members/mfa/\"),\n    {\n      onSuccess: () => queryClient.invalidateQueries([\"mfa\"]),\n    },\n  );\n  return [\n    async () => {\n      await activate();\n    },\n    isLoading,\n  ];\n};\n```", "```py\nimport { FormikHelpers } from \"formik\";\nimport { useContext } from \"react\";\nimport { ToastContext } from \"src/ToastContext\";\ninterface IForm {\n  token: string;\n}\nconst useConfirmMFA = () => {\n  const { addToast } = useContext(ToastContext);\n  const queryClient = useQueryClient();\n  const { mutateAsync: confirm } = useMutation(\n    async (data: IForm) => await axios.put(\"/members/mfa/\", data),\n    {\n      onSuccess: () => queryClient.invalidateQueries([\"mfa\"]),\n    },\n  );\n  return async (\n    data: IForm, { setFieldError }: FormikHelpers<IForm>\n  ) => {\n    try {\n      await confirm(data);\n    } catch (error: any) {\n      if (axios.isAxiosError(error) && \n          error.response?.status === 400) {\n        setFieldError(\"token\", \"Invalid code\");\n      } else {\n        addToast(\"Try again\", \"error\");\n      }\n    }\n  };\n};\n```", "```py\nimport LoadingButton from \"@mui/lab/LoadingButton\";\nimport Skeleton from \"@mui/material/Skeleton\";\nimport Typography from \"@mui/material/Typography\";\nimport { Form, Formik } from \"formik\";\nimport { QRCodeSVG } from \"qrcode.react\";\nimport * as yup from \"yup\";\nimport FormActions from \"src/components/FormActions\";\nimport Title from \"src/components/Title\";\nimport TotpField from \"src/components/TotpField\";\nimport { useQuery } from \"src/query\";\nconst validationSchema = yup.object({\n  token: yup.string().required(\"Required\"),\n}); \nconst MFA = () => {\n  const { data } = useQuery([\"mfa\"], async () => {\n    const response = await axios.get(\"/members/mfa/\");\n    return response.data;\n  });\n  const [activate, isLoading] = useActivateMFA();\n  const onSubmit = useConfirmMFA();\n  let content = <Skeleton />;\n  if (data?.state === \"ACTIVE\") {\n    content = <Typography variant=\"body1\">MFA Active</Typography>;\n  } else if (data?.state === \"INACTIVE\") {\n    content = (\n      <LoadingButton loading={isLoading} onClick={activate}>\n        Activate\n      </LoadingButton>\n    );\n  } else if (data !== undefined) {\n    content = (\n      <>\n        <QRCodeSVG value={data.totpUri} />\n        <Formik<IForm>\n          initialValues={{ token: \"\" }}\n          onSubmit={onSubmit}\n          validationSchema={validationSchema}\n        >\n          {({ dirty, isSubmitting }) => (\n            <Form>\n              <TotpField\n                fullWidth={true}\n                label=\"One time code\"\n                name=\"token\"\n                required={true}\n              />\n              <FormActions\n                disabled={!dirty}\n                isSubmitting={isSubmitting}\n                label=\"Confirm\"\n                links={[{ label: \"Back\", to: \"/\" }]}\n              />\n            </Form>\n          )}\n        </Formik>\n      </>\n    );\n  }\n  return (\n    <>\n      <Title title=\"Multi-Factor Authentication\" />\n      {content}\n    </>\n  );\n};\nexport default MFA; \n```", "```py\nimport MFA from \"src/pages/MFA\";\nconst Router = () => (\n  <BrowserRouter>\n   ...\n    <Routes>\n      ...\n      <Route\n        path=\"/mfa/\"\n        element={<RequireAuth><MFA /></RequireAuth>}\n      />\n    </Routes>\n  </BrowserRouter>\n);\n```", "```py\n<MenuItem  \n  component={Link}  \n  onClick={onMenuClose}  \n  to=\"/mfa/\" \n> \n  MFA\n</MenuItem>\n```", "```py\nfrom pyotp.totp import TOTP\nfrom backend.models.member import update_last_totp\n@dataclass\nclass LoginData:\n    email: EmailStr\n    password: str\n    remember: bool = False\n    token: str | None = None\n@blueprint.post(\"/sessions/\")\n@rate_limit(5, timedelta(minutes=1))\n@validate_request(LoginData)\nasync def login(data: LoginData) -> ResponseReturnValue:\n    member = await select_member_by_email(g.connection, data.email)\n    password_hash = REFERENCE_HASH\n    if member is not None:\n        password_hash = member.password_hash \n    passwords_match = bcrypt.checkpw(\n        data.password.encode(\"utf-8\"),\n        password_hash.encode(\"utf-8\"),\n    )\n    if passwords_match:\n        assert member is not None  # nosec\n        if (\n            member.totp_secret is not None and \n            member.last_totp is not None\n        ):\n            if data.token is None:\n                raise APIError(400, \"TOKEN_REQUIRED\")\n            totp = TOTP(member.totp_secret)\n            if (\n                not totp.verify(data.token) or \n                data.token == member.last_totp\n            ):\n                raise APIError(401, \"INVALID_CREDENTIALS\")\n            await update_last_totp(\n                g.connection, member.id, data.token\n            )\n        login_user(AuthUser(str(member.id)), data.remember)\n        return {}, 200\n    else:\n        raise APIError(401, \"INVALID_CREDENTIALS\")\n```", "```py\nimport { useState } from \"react\";\ninterface IForm {\n  email: string;\n  password: string;\n  token: string;\n}\nconst useLogin = (): [(data: IForm, helpers: FormikHelpers<IForm>) => Promise<void>, boolean] => {\n  const [requiresMFA, setRequiresMFA] = useState(false);\n  const location = useLocation();\n  const navigate = useNavigate();\n  const { addToast } = useContext(ToastContext);\n  const { setAuthenticated } = useContext(AuthContext);\n  const { mutateAsync: login } = useMutation(\n    async (data: IForm) => await axios.post(\"/sessions/\",       data),\n  );\n  return [\n    async (data: IForm, { setFieldError }:       FormikHelpers<IForm>)=>{\n      const loginData: any = {\n        email: data.email,\n        password: data.password,\n      };\n      if (requiresMFA) {\n        loginData[\"token\"] = data.token;\n      }\n      try {\n        await login(loginData);\n        setAuthenticated(true);\n        navigate((location.state as any)?.from ?? \"/\");\n      } catch (error: any) {\n        if (error.response?.status === 400) {\n          setRequiresMFA(true);\n        } else if (error.response?.status === 401) {\n          setFieldError(\"email\", \"Invalid credentials\");\n          setFieldError(\"password\", \"Invalid credentials\");\n          setFieldError(\"token\", \"Invalid credentials\");\n        } else {\n          addToast(\"Try again\", \"error\");\n        }\n      }\n    },\n    requiresMFA,\n  ];\n};\n```", "```py\nimport TotpField from \"src/components/TotpField\"; \nconst Login = () => {\n  const [onSubmit, requiresMFA] = useLogin();\n  ...\n  return (\n    <>\n      <Formik<IForm> \n        initialValues={{\n          email: (location.state as any)?.email ?? \"\",\n          password: \"\",\n          token: \"\",\n        }}\n        onSubmit={onSubmit}\n        validationSchema={validationSchema}\n      >\n        {({ isSubmitting, values }) => (\n          <Form>\n            {requiresMFA ? (\n              <TotpField\n                fullWidth={true}\n                label=\"One time code\"\n                name=\"token\"\n                required={true}\n              />\n            ) : null}\n          </Form>\n        )}\n      </Formik>\n    </>\n  );\n};\n```", "```py\nnpx create-react-app temp --template cra-template-pwa-typescript\n```", "```py\nimport * as serviceWorkerRegistration from \"src/serviceWorkerRegistration\"; \nserviceWorkerRegistration.register();\n```", "```py\nnpm install workbox-background-sync workbox-background-sync workbox-cacheable-response workbox-core workbox-expiration workbox-navigation-preload workbox-precaching workbox-range-requests workbox-routing workbox-strategies workbox-streams\n```", "```py\nnpm run build\n```", "```py\nCOPY --from=frontend /frontend/build/*.js* /app/backend/static/\n```", "```py\n<link rel=\"icon\" href=\"%PUBLIC_URL%/favicon.svg\" />\n```", "```py\n{\n  \"short_name\": \"Tozo\",\n  \"name\": \"Tozo todo app\",\n  \"icons\": [\n    {\n      \"src\": \"favicon.svg\",\n      \"sizes\": \"64x64 32x32 24x24 16x16\",\n      \"type\": \" image/svg+xml\"\n    },\n    {\n      \"src\": \"logo192.png\",\n      \"type\": \"image/png\",\n      \"sizes\": \"192x192\"\n    },\n    {\n      \"src\": \"logo512.png\",\n      \"type\": \"image/png\",\n      \"sizes\": \"512x512\"\n    }\n  ],\n  \"start_url\": \".\",\n  \"display\": \"standalone\",\n  \"theme_color\": \"#1976d2\",\n  \"background_color\": \"#ffffff\"\n}\n```", "```py\nCOPY --from=frontend /frontend/build/*.png /frontend/build/*.svg /app/backend/static/\n```", "```py\nfrom quart import current_app, send_from_directory\n@blueprint.get(\n    \"/<any('service-worker.js', 'service-worker.js.map', 'manifest.json', 'asset-manifest.json', 'favicon.svg', 'logo192.png', 'logo512.png'):path>\"  # noqa: E501\n)\n@rate_exempt\nasync def resources(path: str) -> ResponseReturnValue:\n    assert current_app.static_folder is not None  # nosec\n    return await send_from_directory(\n        current_app.static_folder, path\n    )\n```"]