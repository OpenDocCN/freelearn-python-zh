- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a Reusable Frontend with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we built an API to manage sessions, members, and to-dos.
    In this chapter, we will create a frontend that is capable of connecting to that
    API or any other you may wish to use. In addition, we’ll add styling, routing,
    validated data entry, and feedback via toasts.
  prefs: []
  type: TYPE_NORMAL
- en: Styling, routing, data entry, and feedback are all features that will be useful
    in your app and are not specific to to-dos. Therefore, at the end of this chapter,
    we’ll have created a frontend to which we can add a user interface with any specific
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the basic React app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling data entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the app state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting toast feedback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following additional folders are required in this chapter and should be
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To follow the development in this chapter using the companion repository, [https://github.com/pgjones/tozo](https://github.com/pgjones/tozo),
    see the commits between the `r1-ch4-start` and `r1-ch4-end` tags.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the basic React app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Installing NodeJS for frontend development* section of [*Chapter 1*](B18727_01.xhtml#_idTextAnchor015)*,
    Setting Up Our System for Development*, we used the `create-react-app` tool to
    create a standard React app, which we can now configure for our usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, as we are using a frontend development server, we will need to proxy
    API requests to our backend by adding the following to *frontend/package.json*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted ellipsis represents the existing code; note the additional trailing
    comma that has been added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll configure the import system so that we can use full paths with
    *src* as the root (i.e., *src/components/Component*) rather than, for example,
    *../components/Component*. This makes the imported file easier to find as we can
    always relate the path to the *src* directory. It also matches the type of import
    paths we’ve used already in the backend. To do so, we need to add the following
    to *frontend/tsconfig.json*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `compilerOptions` section should already exist, to which the `baseUrl`
    entry should be added (the highlighted ellipsis represents the existing code).
    In addition, we need to install `eslint-import-resolver-typescript` to inform
    `eslint` to use the same `baseUrl` by running the following in the *frontend*
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is then configured by adding the following to the `eslintConfig` section
    in *frontend/package.json*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted line represents the existing code within the existing `eslintConfig`
    section.
  prefs: []
  type: TYPE_NORMAL
- en: With these small configuration changes, we can now focus on styling the app,
    adding page titles, and adding an authentication context.
  prefs: []
  type: TYPE_NORMAL
- en: Styling the app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It takes a lot of effort to build a design system and use it consistently to
    style an app. Fortunately, `MUI` ([mui.com](http://mui.com)) is an existing React
    component library that can be used to create apps using the Material Design System
    pioneered by Google. `MUI` is installed by running the following in the *frontend*
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As material design and MUI are based on the Roboto font, we will need to install
    that as well by running the following in the *frontend* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This font also needs to be included in the bundle and hence the following imports
    should be added to *frontend/src/App.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The number refers to the font weight (boldness); by default, `MUI` only uses
    `300`, `400`, `500`, and `700` weights, so these are the only ones we need.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic HTML
  prefs: []
  type: TYPE_NORMAL
- en: MUI is very good at using the most descriptive HTML tags for the elements; for
    example, MUI buttons use the `Button` tag rather than styling a `div` tag. This
    is called **semantic HTML** as it uses HTML to reinforce the semantics of the
    content. This is an important thing to do as it aids accessibility and improves
    the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, our app will look exactly the same as the default `MUI` app, but we
    can change that by theming our app. To do so, let’s create a `ThemeProvider` element
    by placing the following in *frontend/src/ThemeProvider.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’ve used the `CssBaseline` component to reset and normalize the browser’s
    styling, thereby ensuring our app looks the same in all browsers. We’ve also used
    the `prefers-color-scheme` system preference to switch the app to a dark mode
    if the user’s system indicates that’s their preference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ThemeProvider` should be rendered in the `App` component as the parent
    of any styled components, i.e. *frontend/src/App.tsx* should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that I’ve changed the `App` function definition syntax to use the arrow
    function syntax rather than the function definition syntax as created for us by
    `create-react-app`.
  prefs: []
  type: TYPE_NORMAL
- en: Function style
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript allows for functions to be defined with a `function` keyword or via
    the arrow `=>` syntax. While there are differences between these two styles, for
    a React component it makes no practical difference which style is used. In this
    book, I’ll use the arrow syntax based on my preference.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’ve changed the `App` component, we also need to update the test by replacing
    *frontend/src/App.test.tsx* with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We are aiming for our app to be usable on small mobile screens, large desktop
    screens, and everything in-between. We can achieve this by building the app for
    small mobile screens and allowing it to resize with the screen size. However,
    as you can see in *Figure 4.1*, this starts to look odd with large horizontal
    widths:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: How the app would look without a Container  ](img/B18727_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: How the app would look without a Container'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is fixed by adding a `Container` within the `ThemeProvider` in *frontend/src/App.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted lines show the additions, and the result is shown in *Figure
    4.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: How the app looks with the Container ](img/B18727_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: How the app looks with the Container'
  prefs: []
  type: TYPE_NORMAL
- en: With the styling in place, we can now add a title for each page.
  prefs: []
  type: TYPE_NORMAL
- en: Adding page titles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can give the user a better experience by configuring the page title as it
    is displayed in the user’s browser, as seen in *Figure 4.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: The title (as displayed by Chrome)  ](img/B18727_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: The title (as displayed by Chrome)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the title, we can use `react-helmet-async`, which is installed by running
    the following in the *frontend* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To use `react-helmet-async`, we need to add `HelmetProvider` as an ancestor
    to our components by adding the following to *frontend/src/App.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines will set the default page title to be `Tozo` and should
    be added to the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now create a `Title` component that both sets the title displayed by
    the browser and displays clear title text on the page, by adding the following
    to *frontend/src/components/Title.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With this small addition, we can now consider how the app knows whether the
    user is authenticated or not.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an authentication context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The frontend app will need to track whether the user is currently authenticated
    (logged in) and show the login or registration page if they are not. This is something
    that will be useful throughout the app and hence we’ll use a React context, specifically
    called `AuthContext`, by adding the following to *frontend/src/AuthContext.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: React context and prop drilling
  prefs: []
  type: TYPE_NORMAL
- en: React context is best used to share things globally within a React component
    tree. This is because any descendant of the provider will be able to access the
    context. We could also achieve this by passing the context via props through the
    tree, called prop drilling. However, prop drilling soon becomes cumbersome when
    there are many components to pass through.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this context available throughout the app, we can add the provider
    to *frontend/src/App.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines should be added to the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This then allows the authentication state to be accessed in any component via
    a `useContext` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We’ll make use of this context next, as we set up the routing.
  prefs: []
  type: TYPE_NORMAL
- en: Adding routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Frontend apps are usually made up of multiple pages, as is our to-do app. We
    will achieve this with routing, which allows different page components to render,
    depending on the app’s path. As we are building a single-page app, this routing
    will be done in the frontend code, rather than the backend, which would be the
    case for a multi-page app.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use React Router ([reactrouter.com](http://reactrouter.com)) to handle
    routing in our app. It is installed by running the following command in the *frontend*
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Single-page app
  prefs: []
  type: TYPE_NORMAL
- en: A **single-page app**, often called an **SPA**, refers to a web app whereby
    only a single page is fetched from the backend server. This single page is then
    able to render all the pages within the app. This is an advantage as navigating
    from one page to another is typically quicker in an SPA; however, this comes with
    the cost of a larger initial download.
  prefs: []
  type: TYPE_NORMAL
- en: 'I find it clearer to place all the routing into a single component called `Router`,
    with each page being an individual `Route`. The `Router` is defined by adding
    the following to *frontend/src/Router.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Router` component should then be rendered within the `Container` component
    as shown by the following, which should be added to *frontend/src/App.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines should be added to the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: We can now add authentication to our routing to ensure that some of the pages
    only render for a logged-in user.
  prefs: []
  type: TYPE_NORMAL
- en: Requiring authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A significant fraction of the routes in the app should only be available for
    users who are logged in. Therefore, we need a component that checks whether the
    user is authenticated and renders the page. Alternatively, if the user isn’t authenticated,
    the app redirects the user to the login page. This is done by creating the following
    component in *frontend/src/components/RequireAuth.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The navigation state is set to include the current location so that the user
    can be redirected back to the page after successfully authenticating.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use `RequireAuth` as a wrapper around a `Page` component within
    a `Route`, as this ensures that the `Page` only renders if the user is authenticated,
    for example (this shouldn’t be added to our app):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The final aspect of the routing setup is to control the scrolling when navigating.
  prefs: []
  type: TYPE_NORMAL
- en: Resetting scrolling on navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a user navigates and changes the page in the app, they will expect to
    view the new page from the start (i.e., the top of the page). As the view, or
    scroll position, will remain fixed on a React Router navigation, we will need
    to reset it to the top ourselves. We can do this We can do this by scrolling up
    to the window top on a change in the path via the following component, as placed
    in *frontend/src/components/ScrollToTop.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `useEffect` will only trigger when its `pathname` dependency changes, hence
    the scrolling only occurs on navigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This component should be rendered within `BrowserRouter` in the `Router` component
    by adding the following to *frontend/src/Router.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines should be added to the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for the frontend tests to pass, we will need to define the `window.scrollTo`
    function by adding the following to *frontend/src/setupTests.ts*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is all we require to enable pages via routing in our app; now, we can focus
    on how the user will enter data.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling data entry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users of our app will need to enter their email and password to log in, and
    then a description, due date, and completion for their to-do tasks. These fields
    will need to be grouped into forms; building forms with a good user experience
    takes a lot of effort as the form must be validated and the touched state, error
    state, and focused state must be managed for each field and the form itself.
  prefs: []
  type: TYPE_NORMAL
- en: Form input states
  prefs: []
  type: TYPE_NORMAL
- en: A form input box will need to display a variety of different states to help
    the user understand how it is used and when there is an issue. To start, the input
    will be in an empty state with no value and no error. This is important as the
    input should not show an error until the user touches/interacts with it. Then,
    while the user is interacting with it, the input should show that it is focused.
    Finally, after the input has been touched, if the value doesn’t validate, it needs
    to show an error state.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use Formik ([formik.org](http://formik.org)) to manage the form and field
    states and Yup ([github.com/jquense/yup](http://github.com/jquense/yup)) to validate
    the inputted data. These are installed by running the following in the *frontend*
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As we will use MUI for styling and Formik to manage the state, we will need
    to create field components that combine the two. While this will differ for each
    field, the following function is useful to all the components and should be placed
    in *frontend/src/utils.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This generic function works by extracting the error from the Formik meta props
    and displaying it alongside the helper text if there is an error and the user
    has touched the input. The comma in `<T, >` is required to distinguish between
    the generic usage we desire and what a `<T>` JSX element alone implies.
  prefs: []
  type: TYPE_NORMAL
- en: With Formik installed and the helper function ready to use, we can start creating
    the field components, beginning with a checkbox field.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a styled checkbox field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our app, we’ll need a checkbox field to indicate whether a to-do is complete
    or to indicate whether the user wants to be remembered when logging in. The following
    should be added to *frontend/src/components/CheckboxField.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: While most of this code is to style a checkbox as specified in the material
    design system, the key aspect is the usage of the `useField` hook to extract the
    Formik state for usage in the MUI components.
  prefs: []
  type: TYPE_NORMAL
- en: We can now move on to the next field, for date entry.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a styled date field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll need a date field for the user to specify a due date for a to-do, which
    will look like *Figure 4.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: The date picker on a mobile screen ](img/B18727_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: The date picker on a mobile screen'
  prefs: []
  type: TYPE_NORMAL
- en: To do so, we’ll make use of a `MUI-X` ([mui.com/x](http://mui.com/x)) component
    rather than the inbuilt browser date picker, as the `MUI-X` picker is much easier
    for users to use. `MUI-X` is a set of advanced `MUI` components and hence works
    with, and follows, the same styling as `MUI`. Alongside `MUI-X`, we also need
    `date-fns` to parse strings into the `Date` instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both are installed by running the following in the *frontend* folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With these libraries installed, we can create a `DateField` component that
    provides a date picker as seen in *Figure 4.4* by adding the following to *frontend/src/components/DateField.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Next, we can add a field component for entering emails.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a styled email field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll need an email field for the user to log in and register. To do so, the
    following should be added to *frontend/src/components/EmailField.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Next, we can add a simple text field.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a styled text field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll need a text field for the user to enter the to-do task information. To
    do so, the following should be added to *frontend/src/components/TextField.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can add a password entry field.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a styled password field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll need a password field for the user to enter their existing password when
    logging in or changing their password. This field should have a visibility toggle
    button that makes the password visible, as this helps the user get their password
    correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, the following should be added to *frontend/src/components/PasswordField.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The visibility button is given a `tabIndex` value of `–1` to take it out of
    the tab flow, so that pressing the *Tab* key after entering the password takes
    the focus to the next field and not the visibility button, thereby matching the
    user’s expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a styled password strength field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The existing password field allows users to enter a password but gives them
    no indication of how strong the password is. This is something that will be useful
    when the user is registering or changing their password. In the past, apps would
    mandate that special uppercase and lowercase characters should be present for
    a strong password. Yet this, sadly, leads to weaker passwords. So instead, we
    will require the password to be strong enough by calculating its entropy (this
    is something we already did in [*Chapter 2*](B18727_02.xhtml#_idTextAnchor053),
    *Creating a Reusable Backend with Quart*).
  prefs: []
  type: TYPE_NORMAL
- en: Only checking the strength in the backend API call leads to a poor user experience
    as it takes too long for the user to receive feedback on the strength of their
    password. Fortunately, there is a `zxcvbn` version that we can use to provide
    users instant feedback on the strength of their password in the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we should install it by running the following in the *frontend* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll want this field to give immediate visual feedback to the user on the
    strength of their password, both as a color that turns more green as the password
    strength improves, and as text that says **Good** or **Strong** as appropriate.
    So, let’s add the following function to *frontend/src/components/PasswordWithStrengthField.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use this function in the field itself by adding the following to
    *frontend/src/components/PasswordWithStrengthField.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This code renders a `LinearProgress` component below the existing `PasswordField`
    and colors it based on the `scoreToDisplay` function already added.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PasswordWithStrengthField` uses `zxcvbn` to determine the strength of
    the password. This means that any component that directly imports `PasswordWithStrengthField`
    will add `zxcvbn` to the bundle it is in, which is a problem, as `zxcvbn` is very
    large. Therefore, to only load `zxcvbn` when required, we can use React’s lazy
    loading and suspense system by adding the following to *frontend/src/components/LazyPasswordWithStrengthField.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now the `PasswordField` will be shown to the user until `zxcvbn` has been downloaded,
    thereby improving the user experience by ensuring it is only downloaded if the
    user needs it.
  prefs: []
  type: TYPE_NORMAL
- en: These are all the custom fields we need for our to-do app; next, we need a set
    of styled action buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing styled form actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The fields we’ve implemented will be contained in forms that will need to be
    submitted. Therefore, let’s add a useful helper `FormActions` component that allows
    the user to submit the form as the primary action or to navigate elsewhere instead
    as secondary actions. The code for this follows and should be added to *frontend/src/components/FormActions.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The primary action is displayed using a `LoadingButton` component as it allows
    us to indicate to the user that the form submission is in progress via a spinning
    circle. Without this feedback, the user may think the app has frozen or ignored
    their click.
  prefs: []
  type: TYPE_NORMAL
- en: We now have all the fields and helper components we need for users to enter
    data. This means we can focus on how we will manage the app’s state and particularly
    how data is fetched from the backend and stored in the app’s state.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the app state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with the backend, it helps to have models that represent the data used in
    the app. These models will validate the data, help the linters ensure that we
    are using the data correctly, and ensure that the correct types are used. We will
    also use the model to correctly convert to and from the JSON representation used
    to communicate with the backend API.
  prefs: []
  type: TYPE_NORMAL
- en: The to-do model needs to be constructed from JSON, based on what is received
    from the backend or from data that the user entered. Then, the model needs to
    output as JSON so that this output can be sent to the backend. In addition, the
    model should validate that the data it is constructed from is of the correct structure
    and convert types (i.e., from strings representing dates in JSON to `Date` instances).
  prefs: []
  type: TYPE_NORMAL
- en: 'We only need a model for to-dos in the frontend, and hence we need the following
    in *frontend/src/models.ts*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `todoSchema` is used in the constructor to confirm the data is of the correct
    structure and to convert the types. The `toJSON` method is a standard JavaScript
    method to convert objects to JSON-compatible structures, which is done by converting
    the due date to an ISO 8601 formatted string.
  prefs: []
  type: TYPE_NORMAL
- en: While this model is specific to our app, using a class with `yup` validation
    is a good pattern for any app’s data.
  prefs: []
  type: TYPE_NORMAL
- en: With a model in place, we can now communicate with the backend, which we’ll
    focus on next.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with the backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll need to send and receive data from the backend API and then store it
    in the local state for usage in the various components that will render it. To
    begin, let’s install `axios` as it has a nicer API for sending and receiving JSON
    than the inbuilt `fetch` function. It is installed by running the following in
    the *frontend* folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to store the data received in a way that allows it to be used
    across multiple components. To manage this state, we’ll use `React-Query` ([https://tanstack.com/query/v4](https://tanstack.com/query/v4)),
    as it is pleasant and easy to use. To start, let’s install it by running the following
    in the *frontend* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To use `React-Query`, a `QueryClient` must be provided via React-Query’s `QueryClientProvider`.
    This is achieved by adding the following to *frontend/src/App.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines should be added to the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: We need to adapt React-Query so that requests that aren’t authenticated result
    in changes to the `AuthContext`. This is to handle cases where a user visits a
    page without logging in first. We’ll also only allow retries if the server doesn’t
    respond or responds with a `5XX` status code.
  prefs: []
  type: TYPE_NORMAL
- en: State management
  prefs: []
  type: TYPE_NORMAL
- en: The rendered output in React must be a function of the current state. Therefore,
    when fetching data from the backend, we need to manage the various states of the
    fetch. These states start with the fetch loading and progress to success or error
    states, depending on the result. Assuming the fetch succeeds, there is then the
    question of how long the data is valid before it needs to be fetched again. All
    of these states are helpfully managed for us by React-Query.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we’ll first write a wrapper around React-Query’s `useQuery`, which
    is used to fetch data from the backend API, by adding the following to *frontend/src/query.ts*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This code wraps the standard `useQuery` hook by checking any errors for a 401-response
    status code, as shown by the first highlighted block. As a 401-response indicates
    the user is unauthenticated, the local authentication state is then updated.
  prefs: []
  type: TYPE_NORMAL
- en: The code also provides logic to decide when the request should be retried, as
    shown by the second highlighted block. The logic will retry the request up to
    a maximum of two times if there is a network error (no response) or a server error
    (as indicated by a `5XX` response code). Note, therefore, that the query will
    be in the loading state until all three attempts have failed in the case of network
    failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll now add the same logic to React-Query’s `useMutation`, which is used
    to send data to the backend API by adding the following to *frontend/src/query.ts*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This `useMutation` hook has the same authentication wrapper and retry logic
    as the `useQuery` hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two new hooks can then be used in any part of the app in the same way
    as the standard React-Query hooks are. For example, the `useQuery` hook can be
    used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We can now fully interact with the backend and store the appropriate state locally,
    which allows us to focus on giving feedback to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting toast feedback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Toasts** (called **Snackbar** in MUI) can be used to show feedback to the
    user that doesn’t relate to a direct element on the page. Good usage of a toast
    is showing an error message if a request to the backend fails, as shown in *Figure
    4.5*, or showing a success message after the user changes their password, as there
    is no direct confirmation via the page content. A bad usage would be to report
    that the entered email is invalid as, in this case, the email field should show
    an error.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: An example of a toast error ](img/B18727_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: An example of a toast error'
  prefs: []
  type: TYPE_NORMAL
- en: 'To support toasts, we need to be able to add a toast from any component in
    the app and have that toast displayed. Crucially, if there are multiple toasts,
    they should be displayed one after another so that there is never more than one
    toast displayed. This is another React context use case, much like the authentication
    context added earlier. So, let’s start by adding the following toast context to
    *frontend/src/ToastContext.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As the `ToastContextProvider` needs to be an ancestor of any of the components
    that use toasts in the app, we can add it to *frontend/src/App.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines should be added to the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to display the toasts. We can do this via a Toasts component,
    by adding the following to *frontend/src/components/Toasts.tsx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The key aspect of this code is `useEffect`, which will take a toast from the
    list of toasts and set it as the current toast whenever there are toasts to display
    and there isn’t an open one. The toasts are also set to automatically close after
    6 seconds, giving the user enough time to register it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to render the `Toasts` component in the `App` component, leaving
    the final version of *frontend/src/App.tsx* as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines are to be added to provide toasts.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when a toast is added by any component, it will show for 6 seconds as an
    alert snackbar at the top center of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve created a styled frontend that includes routing, validated
    data entry, and toast feedback, and can connect to the backend API we built in
    the last chapter. This will allow us to add the specific pages and functionality
    we need for our to-do app.
  prefs: []
  type: TYPE_NORMAL
- en: The functionality added in this chapter can serve as the basis for any app,
    not just the one specific to the to-do app being developed in this book. You can
    take this basis and add any user interface you need for your functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll build the pages and add the functionality that makes
    up the to-do app.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you find you can’t represent the state of your app using React-Query, it
    is probably time to use a full state management tool such as Redux, [https://redux.js.org](https://redux.js.org).
  prefs: []
  type: TYPE_NORMAL
