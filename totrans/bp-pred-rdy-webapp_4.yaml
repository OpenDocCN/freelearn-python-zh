- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Creating a Reusable Frontend with React
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React 创建可重用的前端
- en: In the previous chapter, we built an API to manage sessions, members, and to-dos.
    In this chapter, we will create a frontend that is capable of connecting to that
    API or any other you may wish to use. In addition, we’ll add styling, routing,
    validated data entry, and feedback via toasts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建了一个用于管理会话、成员和待办事项的 API。在本章中，我们将创建一个前端，使其能够连接到该 API 或您可能希望使用的任何其他 API。此外，我们还将添加样式、路由、验证数据输入和通过
    toast 提供反馈。
- en: Styling, routing, data entry, and feedback are all features that will be useful
    in your app and are not specific to to-dos. Therefore, at the end of this chapter,
    we’ll have created a frontend to which we can add a user interface with any specific
    functionality.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 样式、路由、数据输入和反馈都是您应用中非常有用的功能，并不特定于待办事项。因此，在本章结束时，我们将创建一个前端，我们可以向其中添加具有任何特定功能的用户界面。
- en: 'So, in this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主题：
- en: Enhancing the basic React app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升基本的 React 应用
- en: Adding routing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加路由
- en: Enabling data entry
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用数据输入
- en: Managing the app state
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理应用状态
- en: Supporting toast feedback
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持toast反馈
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following additional folders are required in this chapter and should be
    created:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中需要以下额外的文件夹，并应创建它们：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To follow the development in this chapter using the companion repository, [https://github.com/pgjones/tozo](https://github.com/pgjones/tozo),
    see the commits between the `r1-ch4-start` and `r1-ch4-end` tags.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用配套仓库 [https://github.com/pgjones/tozo](https://github.com/pgjones/tozo) 跟进本章的开发，请查看
    `r1-ch4-start` 和 `r1-ch4-end` 标签之间的提交。
- en: Enhancing the basic React app
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升基本的 React 应用
- en: In the *Installing NodeJS for frontend development* section of [*Chapter 1*](B18727_01.xhtml#_idTextAnchor015)*,
    Setting Up Our System for Development*, we used the `create-react-app` tool to
    create a standard React app, which we can now configure for our usage.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第1章*](B18727_01.xhtml#_idTextAnchor015)* 的 *安装 NodeJS 用于前端开发* 部分，我们在 *设置开发系统*
    中使用了 `create-react-app` 工具来创建一个标准的 React 应用，我们现在可以为此用途进行配置。
- en: 'First, as we are using a frontend development server, we will need to proxy
    API requests to our backend by adding the following to *frontend/package.json*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，由于我们正在使用前端开发服务器，我们需要通过在 *frontend/package.json* 中添加以下内容来代理 API 请求到我们的后端：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The highlighted ellipsis represents the existing code; note the additional trailing
    comma that has been added.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的省略号表示现有的代码；请注意，已经添加了额外的尾随逗号。
- en: 'Next, we’ll configure the import system so that we can use full paths with
    *src* as the root (i.e., *src/components/Component*) rather than, for example,
    *../components/Component*. This makes the imported file easier to find as we can
    always relate the path to the *src* directory. It also matches the type of import
    paths we’ve used already in the backend. To do so, we need to add the following
    to *frontend/tsconfig.json*:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将配置导入系统，以便我们可以使用以 *src* 为根的全路径（即，*src/components/Component*），而不是例如 *../components/Component*。这使得导入的文件更容易找到，因为我们总能将路径与
    *src* 目录联系起来。这也与我们已经在后端使用的导入路径类型相匹配。为此，我们需要将以下内容添加到 *frontend/tsconfig.json*：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `compilerOptions` section should already exist, to which the `baseUrl`
    entry should be added (the highlighted ellipsis represents the existing code).
    In addition, we need to install `eslint-import-resolver-typescript` to inform
    `eslint` to use the same `baseUrl` by running the following in the *frontend*
    directory:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`compilerOptions`部分应该已经存在，我们需要在其中添加`baseUrl`条目（突出显示的省略号表示现有的代码）。此外，我们需要安装`eslint-import-resolver-typescript`来通知`eslint`使用相同的`baseUrl`，在*frontend*目录中运行以下命令：'
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is then configured by adding the following to the `eslintConfig` section
    in *frontend/package.json*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过在 *frontend/package.json* 中的 `eslintConfig` 部分添加以下内容来配置：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The highlighted line represents the existing code within the existing `eslintConfig`
    section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行表示现有 `eslintConfig` 部分内的现有代码。
- en: With these small configuration changes, we can now focus on styling the app,
    adding page titles, and adding an authentication context.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些小的配置更改，我们现在可以专注于设计应用样式、添加页面标题和添加认证上下文。
- en: Styling the app
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计应用样式
- en: 'It takes a lot of effort to build a design system and use it consistently to
    style an app. Fortunately, `MUI` ([mui.com](http://mui.com)) is an existing React
    component library that can be used to create apps using the Material Design System
    pioneered by Google. `MUI` is installed by running the following in the *frontend*
    directory:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个设计系统并一致地使用它来设计应用程序需要付出很多努力。幸运的是，`MUI` ([mui.com](http://mui.com)) 是一个现有的
    React 组件库，可以用来创建使用 Google 领先的 Material Design 系统的应用程序。在 *frontend* 目录中运行以下命令来安装
    `MUI`：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As material design and MUI are based on the Roboto font, we will need to install
    that as well by running the following in the *frontend* directory:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于材料设计和 MUI 基于Roboto字体，我们需要在 *frontend* 目录中运行以下命令来安装它：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This font also needs to be included in the bundle and hence the following imports
    should be added to *frontend/src/App.tsx*:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此字体也需要包含在包中，因此以下导入应添加到 *frontend/src/App.tsx* 中：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The number refers to the font weight (boldness); by default, `MUI` only uses
    `300`, `400`, `500`, and `700` weights, so these are the only ones we need.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 数字代表字体粗细（粗度）；默认情况下，`MUI` 只使用 `300`、`400`、`500` 和 `700` 的粗细，因此我们只需要这些。
- en: Semantic HTML
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 语义化 HTML
- en: MUI is very good at using the most descriptive HTML tags for the elements; for
    example, MUI buttons use the `Button` tag rather than styling a `div` tag. This
    is called **semantic HTML** as it uses HTML to reinforce the semantics of the
    content. This is an important thing to do as it aids accessibility and improves
    the user experience.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: MUI 非常擅长使用最描述性的HTML标签来表示元素；例如，MUI按钮使用 `Button` 标签而不是对 `div` 标签进行样式化。这被称为 **语义化HTML**，因为它使用HTML来加强内容的语义。这是一件重要的事情，因为它有助于可访问性并提高用户体验。
- en: 'So far, our app will look exactly the same as the default `MUI` app, but we
    can change that by theming our app. To do so, let’s create a `ThemeProvider` element
    by placing the following in *frontend/src/ThemeProvider.tsx*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用程序将看起来与默认的 `MUI` 应用程序完全一样，但我们可以通过为主题化应用程序来改变这一点。为此，让我们在 *frontend/src/ThemeProvider.tsx*
    中创建一个 `ThemeProvider` 元素，如下所示：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we’ve used the `CssBaseline` component to reset and normalize the browser’s
    styling, thereby ensuring our app looks the same in all browsers. We’ve also used
    the `prefers-color-scheme` system preference to switch the app to a dark mode
    if the user’s system indicates that’s their preference.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 `CssBaseline` 组件来重置和标准化浏览器的样式，从而确保我们的应用程序在所有浏览器中看起来都一样。我们还使用了 `prefers-color-scheme`
    系统首选项来根据用户的系统偏好将应用程序切换到深色模式。
- en: 'The `ThemeProvider` should be rendered in the `App` component as the parent
    of any styled components, i.e. *frontend/src/App.tsx* should be as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThemeProvider` 应该在 `App` 组件中以任何样式化组件的父组件的形式渲染，即 *frontend/src/App.tsx* 应该如下所示：'
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that I’ve changed the `App` function definition syntax to use the arrow
    function syntax rather than the function definition syntax as created for us by
    `create-react-app`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我已经将 `App` 函数定义的语法更改为使用箭头函数语法，而不是 `create-react-app` 为我们创建的函数定义语法。
- en: Function style
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式风格
- en: TypeScript allows for functions to be defined with a `function` keyword or via
    the arrow `=>` syntax. While there are differences between these two styles, for
    a React component it makes no practical difference which style is used. In this
    book, I’ll use the arrow syntax based on my preference.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 允许使用 `function` 关键字或通过箭头 `=>` 语法来定义函数。虽然这两种风格之间存在差异，但对于React组件来说，使用哪种风格实际上没有区别。在这本书中，我将根据我的偏好使用箭头语法。
- en: 'As we’ve changed the `App` component, we also need to update the test by replacing
    *frontend/src/App.test.tsx* with the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经更改了 `App` 组件，我们还需要通过将 *frontend/src/App.test.tsx* 替换为以下内容来更新测试：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We are aiming for our app to be usable on small mobile screens, large desktop
    screens, and everything in-between. We can achieve this by building the app for
    small mobile screens and allowing it to resize with the screen size. However,
    as you can see in *Figure 4.1*, this starts to look odd with large horizontal
    widths:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是使应用程序能够在小手机屏幕、大桌面屏幕以及两者之间的所有屏幕上使用。我们可以通过为小手机屏幕构建应用程序并允许其根据屏幕大小调整大小来实现这一点。然而，正如你在
    *图 4.1* 中可以看到的，当水平宽度很大时，这开始看起来很奇怪：
- en: '![Figure 4.1: How the app would look without a Container  ](img/B18727_04_01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1：没有容器时应用程序的外观](img/B18727_04_01.jpg)'
- en: 'Figure 4.1: How the app would look without a Container'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：没有容器时应用程序的外观
- en: 'This is fixed by adding a `Container` within the `ThemeProvider` in *frontend/src/App.tsx*:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 *frontend/src/App.tsx* 中添加一个 `Container` 来解决这个问题：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The highlighted lines show the additions, and the result is shown in *Figure
    4.2*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行显示了添加的内容，结果如图 *4.2* 所示：
- en: '![Figure 4.2: How the app looks with the Container ](img/B18727_04_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2：带有容器的应用外观](img/B18727_04_02.jpg)'
- en: 'Figure 4.2: How the app looks with the Container'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：带有容器的应用外观
- en: With the styling in place, we can now add a title for each page.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置样式后，我们现在可以为每个页面添加标题。
- en: Adding page titles
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加页面标题
- en: 'We can give the user a better experience by configuring the page title as it
    is displayed in the user’s browser, as seen in *Figure 4.3*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过配置页面标题，使其在用户浏览器中显示，从而为用户提供更好的体验，如图 *4.3* 所示：
- en: '![Figure 4.3: The title (as displayed by Chrome)  ](img/B18727_04_03.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3：标题（如 Chrome 所显示）](img/B18727_04_03.jpg)'
- en: 'Figure 4.3: The title (as displayed by Chrome)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：标题（如 Chrome 所显示）
- en: 'To set the title, we can use `react-helmet-async`, which is installed by running
    the following in the *frontend* directory:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置标题，我们可以使用 `react-helmet-async`，这需要在 *frontend* 目录下运行以下命令：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To use `react-helmet-async`, we need to add `HelmetProvider` as an ancestor
    to our components by adding the following to *frontend/src/App.tsx*:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `react-helmet-async`，我们需要通过在 *frontend/src/App.tsx* 中添加以下内容，将 `HelmetProvider`
    添加为组件的祖先：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The highlighted lines will set the default page title to be `Tozo` and should
    be added to the existing code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示的行将默认页面标题设置为 `Tozo`，并应添加到现有代码中。
- en: 'We can now create a `Title` component that both sets the title displayed by
    the browser and displays clear title text on the page, by adding the following
    to *frontend/src/components/Title.tsx*:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个 `Title` 组件，它既设置浏览器显示的标题，又在页面上显示清晰的标题文本，通过在 *frontend/src/components/Title.tsx*
    中添加以下内容：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this small addition, we can now consider how the app knows whether the
    user is authenticated or not.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个小的添加，我们现在可以思考应用如何知道用户是否已经认证。
- en: Adding an authentication context
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加认证上下文
- en: 'The frontend app will need to track whether the user is currently authenticated
    (logged in) and show the login or registration page if they are not. This is something
    that will be useful throughout the app and hence we’ll use a React context, specifically
    called `AuthContext`, by adding the following to *frontend/src/AuthContext.tsx*:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 前端应用需要跟踪用户当前是否已认证（登录），如果他们没有登录，则显示登录或注册页面。这是在整个应用中都会用到的东西，因此我们将通过在 *frontend/src/AuthContext.tsx*
    中添加以下内容来使用一个 React 上下文，具体称为 `AuthContext`：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: React context and prop drilling
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: React 上下文和属性钻取
- en: React context is best used to share things globally within a React component
    tree. This is because any descendant of the provider will be able to access the
    context. We could also achieve this by passing the context via props through the
    tree, called prop drilling. However, prop drilling soon becomes cumbersome when
    there are many components to pass through.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: React 上下文最适合在 React 组件树中全局共享东西。这是因为提供者的任何子组件都将能够访问上下文。我们也可以通过通过树传递上下文来达到这个效果，这被称为属性钻取。然而，当有大量组件需要传递时，属性钻取很快就会变得繁琐。
- en: 'To make this context available throughout the app, we can add the provider
    to *frontend/src/App.tsx*:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这个上下文在整个应用中可用，我们可以在 *frontend/src/App.tsx* 中添加提供者：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The highlighted lines should be added to the existing code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 应该将突出显示的行添加到现有代码中。
- en: 'This then allows the authentication state to be accessed in any component via
    a `useContext` hook:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就可以通过 `useContext` 钩子在任意组件中访问认证状态：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We’ll make use of this context next, as we set up the routing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在设置路由时使用这个上下文。
- en: Adding routing
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加路由
- en: Frontend apps are usually made up of multiple pages, as is our to-do app. We
    will achieve this with routing, which allows different page components to render,
    depending on the app’s path. As we are building a single-page app, this routing
    will be done in the frontend code, rather than the backend, which would be the
    case for a multi-page app.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前端应用通常由多个页面组成，就像我们的待办事项应用一样。我们将通过路由来实现这一点，路由允许根据应用的路径渲染不同的页面组件。由于我们正在构建单页应用，这个路由将在前端代码中完成，而不是在多页应用中通常的后端完成。
- en: 'We’ll use React Router ([reactrouter.com](http://reactrouter.com)) to handle
    routing in our app. It is installed by running the following command in the *frontend*
    directory:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 React Router ([reactrouter.com](http://reactrouter.com)) 来处理应用中的路由。这需要在
    *frontend* 目录下运行以下命令：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Single-page app
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用
- en: A **single-page app**, often called an **SPA**, refers to a web app whereby
    only a single page is fetched from the backend server. This single page is then
    able to render all the pages within the app. This is an advantage as navigating
    from one page to another is typically quicker in an SPA; however, this comes with
    the cost of a larger initial download.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**单页应用**，通常称为**SPA**，是指从后端服务器只获取单个页面的Web应用。这个单页能够渲染应用内的所有页面。这是一个优点，因为从一页导航到另一页通常在SPA中更快；然而，这也带来了更大的初始下载成本。'
- en: 'I find it clearer to place all the routing into a single component called `Router`,
    with each page being an individual `Route`. The `Router` is defined by adding
    the following to *frontend/src/Router.tsx*:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现将所有路由放入一个名为`Router`的单个组件中更清晰，其中每个页面都是一个单独的`Route`。`Router`是通过在`*frontend/src/Router.tsx*`中添加以下内容来定义的：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Router` component should then be rendered within the `Container` component
    as shown by the following, which should be added to *frontend/src/App.tsx*:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`Router`组件应该被渲染在`Container`组件中，如下所示，这应该添加到`*frontend/src/App.tsx*`中：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The highlighted lines should be added to the existing code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 应该将突出显示的行添加到现有代码中。
- en: We can now add authentication to our routing to ensure that some of the pages
    only render for a logged-in user.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以为我们的路由添加认证，以确保某些页面只对已登录用户显示。
- en: Requiring authentication
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要认证
- en: 'A significant fraction of the routes in the app should only be available for
    users who are logged in. Therefore, we need a component that checks whether the
    user is authenticated and renders the page. Alternatively, if the user isn’t authenticated,
    the app redirects the user to the login page. This is done by creating the following
    component in *frontend/src/components/RequireAuth.tsx*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中的大部分路由应该只对已登录的用户可用。因此，我们需要一个组件来检查用户是否已认证，并显示页面。或者，如果用户未认证，应用将重定向用户到登录页面。这是通过在`*frontend/src/components/RequireAuth.tsx*`中创建以下组件来实现的：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The navigation state is set to include the current location so that the user
    can be redirected back to the page after successfully authenticating.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 导航状态被设置为包括当前位置，以便用户在成功认证后可以返回到页面。
- en: 'We can then use `RequireAuth` as a wrapper around a `Page` component within
    a `Route`, as this ensures that the `Page` only renders if the user is authenticated,
    for example (this shouldn’t be added to our app):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在`Route`组件内将`RequireAuth`用作`Page`组件的包装器，因为这确保了只有当用户认证后，`Page`才会显示，例如（这不应该添加到我们的应用中）：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The final aspect of the routing setup is to control the scrolling when navigating.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 路由设置的最后一点是控制导航时的滚动。
- en: Resetting scrolling on navigation
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在导航时重置滚动
- en: 'When a user navigates and changes the page in the app, they will expect to
    view the new page from the start (i.e., the top of the page). As the view, or
    scroll position, will remain fixed on a React Router navigation, we will need
    to reset it to the top ourselves. We can do this We can do this by scrolling up
    to the window top on a change in the path via the following component, as placed
    in *frontend/src/components/ScrollToTop.tsx*:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在应用中导航并更改页面时，他们期望从页面顶部开始查看新页面（即页面的顶部）。由于视图或滚动位置将在React Router导航中保持固定，我们需要自己将其重置到顶部。我们可以通过以下组件来实现，该组件放置在`*frontend/src/components/ScrollToTop.tsx*`中：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `useEffect` will only trigger when its `pathname` dependency changes, hence
    the scrolling only occurs on navigation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect`仅在它的`pathname`依赖项更改时触发，因此滚动仅在导航时发生。'
- en: 'This component should be rendered within `BrowserRouter` in the `Router` component
    by adding the following to *frontend/src/Router.tsx*:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 应该通过在`*frontend/src/Router.tsx*`中添加以下内容，在`Router`组件中渲染此组件：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The highlighted lines should be added to the existing code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 应该将突出显示的行添加到现有代码中。
- en: 'In order for the frontend tests to pass, we will need to define the `window.scrollTo`
    function by adding the following to *frontend/src/setupTests.ts*:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使前端测试通过，我们需要通过在`*frontend/src/setupTests.ts*`中添加以下内容来定义`window.scrollTo`函数：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is all we require to enable pages via routing in our app; now, we can focus
    on how the user will enter data.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们通过路由在我们的应用中启用页面所需的所有内容；现在，我们可以专注于用户如何输入数据。
- en: Enabling data entry
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用数据输入
- en: Users of our app will need to enter their email and password to log in, and
    then a description, due date, and completion for their to-do tasks. These fields
    will need to be grouped into forms; building forms with a good user experience
    takes a lot of effort as the form must be validated and the touched state, error
    state, and focused state must be managed for each field and the form itself.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序用户需要输入他们的电子邮件和密码来登录，然后是待办任务的描述、截止日期和完成情况。这些字段需要分组到表单中；构建具有良好用户体验的表单需要大量努力，因为必须对每个字段和表单本身进行验证，并管理触摸状态、错误状态和焦点状态。
- en: Form input states
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 表单输入状态
- en: A form input box will need to display a variety of different states to help
    the user understand how it is used and when there is an issue. To start, the input
    will be in an empty state with no value and no error. This is important as the
    input should not show an error until the user touches/interacts with it. Then,
    while the user is interacting with it, the input should show that it is focused.
    Finally, after the input has been touched, if the value doesn’t validate, it needs
    to show an error state.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 表单输入框需要显示各种不同的状态，以帮助用户理解其使用方式和何时出现问题。首先，输入将处于空状态，没有值和错误。这很重要，因为输入不应该在用户触摸/交互之前显示错误。然后，当用户与其交互时，输入应显示它处于焦点状态。最后，在输入被触摸后，如果值不验证，则需要显示错误状态。
- en: 'We’ll use Formik ([formik.org](http://formik.org)) to manage the form and field
    states and Yup ([github.com/jquense/yup](http://github.com/jquense/yup)) to validate
    the inputted data. These are installed by running the following in the *frontend*
    directory:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Formik ([formik.org](http://formik.org)) 来管理表单和字段状态，并使用 Yup ([github.com/jquense/yup](http://github.com/jquense/yup))
    来验证输入数据。这些是通过在 *前端* 目录中运行以下命令来安装的：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As we will use MUI for styling and Formik to manage the state, we will need
    to create field components that combine the two. While this will differ for each
    field, the following function is useful to all the components and should be placed
    in *frontend/src/utils.tsx*:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用 MUI 进行样式化和 Formik 来管理状态，因此我们需要创建结合两者的字段组件。虽然这会因每个字段而异，但以下函数对所有组件都很有用，应该放置在
    *前端/src/utils.tsx*：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This generic function works by extracting the error from the Formik meta props
    and displaying it alongside the helper text if there is an error and the user
    has touched the input. The comma in `<T, >` is required to distinguish between
    the generic usage we desire and what a `<T>` JSX element alone implies.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个通用函数通过从 Formik 元数据属性中提取错误，并在有错误且用户触摸了输入时与辅助文本一起显示来工作。在 `<T, >` 中的逗号是必需的，用于区分我们想要的通用用法和
    `<T>` JSX 元素单独所暗示的内容。
- en: With Formik installed and the helper function ready to use, we can start creating
    the field components, beginning with a checkbox field.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了 Formik 并准备好使用辅助函数后，我们可以开始创建字段组件，从复选框字段开始。
- en: Implementing a styled checkbox field
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现一个样式化的复选框字段
- en: 'In our app, we’ll need a checkbox field to indicate whether a to-do is complete
    or to indicate whether the user wants to be remembered when logging in. The following
    should be added to *frontend/src/components/CheckboxField.tsx*:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们需要一个复选框字段来指示待办事项是否完成，或者指示用户在登录时是否希望被记住。以下内容应添加到 *前端/src/components/CheckboxField.tsx*：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: While most of this code is to style a checkbox as specified in the material
    design system, the key aspect is the usage of the `useField` hook to extract the
    Formik state for usage in the MUI components.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大部分代码是为了按照材料设计系统指定的样式化复选框，但关键方面是使用 `useField` 钩子来提取 Formik 状态，以便在 MUI 组件中使用。
- en: We can now move on to the next field, for date entry.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续到下一个字段，即日期输入字段。
- en: Implementing a styled date field
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现一个样式化的日期字段
- en: 'We’ll need a date field for the user to specify a due date for a to-do, which
    will look like *Figure 4.4*:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个日期字段，让用户指定待办事项的截止日期，它将类似于 *图 4.4*：
- en: '![Figure 4.4: The date picker on a mobile screen ](img/B18727_04_04.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4：移动屏幕上的日期选择器](img/B18727_04_04.jpg)'
- en: 'Figure 4.4: The date picker on a mobile screen'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：移动屏幕上的日期选择器
- en: To do so, we’ll make use of a `MUI-X` ([mui.com/x](http://mui.com/x)) component
    rather than the inbuilt browser date picker, as the `MUI-X` picker is much easier
    for users to use. `MUI-X` is a set of advanced `MUI` components and hence works
    with, and follows, the same styling as `MUI`. Alongside `MUI-X`, we also need
    `date-fns` to parse strings into the `Date` instances.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将使用 `MUI-X` ([mui.com/x](http://mui.com/x)) 组件而不是内置的浏览器日期选择器，因为 `MUI-X`
    选择器对用户来说更容易使用。`MUI-X` 是一套高级 `MUI` 组件，因此它与 `MUI` 一起工作，并遵循相同的样式。除了 `MUI-X` 之外，我们还需要
    `date-fns` 来将字符串解析为 `Date` 实例。
- en: 'Both are installed by running the following in the *frontend* folder:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个组件都是通过在 *前端* 文件夹中运行以下命令来安装的：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With these libraries installed, we can create a `DateField` component that
    provides a date picker as seen in *Figure 4.4* by adding the following to *frontend/src/components/DateField.tsx*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了这些库后，我们可以在 *frontend/src/components/DateField.tsx* 中添加以下内容，以创建一个提供日期选择器的
    `DateField` 组件，如图4.4所示：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Next, we can add a field component for entering emails.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在输入电子邮件的表单中添加一个字段组件。
- en: Implementing a styled email field
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现一个带样式的电子邮件字段
- en: 'We’ll need an email field for the user to log in and register. To do so, the
    following should be added to *frontend/src/components/EmailField.tsx*:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个电子邮件字段，让用户登录和注册。为此，以下内容应添加到 *frontend/src/components/EmailField.tsx*：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Next, we can add a simple text field.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以添加一个简单的文本字段。
- en: Implementing a styled text field
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现一个带样式的文本字段
- en: 'We’ll need a text field for the user to enter the to-do task information. To
    do so, the following should be added to *frontend/src/components/TextField.tsx*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个文本字段，让用户输入待办任务信息。为此，以下内容应添加到 *frontend/src/components/TextField.tsx*：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Finally, we can add a password entry field.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以添加一个密码输入字段。
- en: Implementing a styled password field
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现一个带样式的密码字段
- en: We’ll need a password field for the user to enter their existing password when
    logging in or changing their password. This field should have a visibility toggle
    button that makes the password visible, as this helps the user get their password
    correct.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个密码字段，让用户在登录或更改密码时输入他们的现有密码。这个字段应该有一个可见性切换按钮，使得密码可见，因为这有助于用户正确地输入密码。
- en: 'To do this, the following should be added to *frontend/src/components/PasswordField.tsx*:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，以下内容应添加到 *frontend/src/components/PasswordField.tsx*：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The visibility button is given a `tabIndex` value of `–1` to take it out of
    the tab flow, so that pressing the *Tab* key after entering the password takes
    the focus to the next field and not the visibility button, thereby matching the
    user’s expectations.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 可见性按钮被赋予 `tabIndex` 值为 `-1`，以将其从标签流中移除，这样在输入密码后按下 *Tab* 键会将焦点移至下一个字段而不是可见性按钮，从而符合用户的期望。
- en: Implementing a styled password strength field
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现一个带样式的密码强度字段
- en: The existing password field allows users to enter a password but gives them
    no indication of how strong the password is. This is something that will be useful
    when the user is registering or changing their password. In the past, apps would
    mandate that special uppercase and lowercase characters should be present for
    a strong password. Yet this, sadly, leads to weaker passwords. So instead, we
    will require the password to be strong enough by calculating its entropy (this
    is something we already did in [*Chapter 2*](B18727_02.xhtml#_idTextAnchor053),
    *Creating a Reusable Backend with Quart*).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的密码字段允许用户输入密码，但不会给出密码强度指示。当用户注册或更改密码时，这将非常有用。在过去，应用程序会强制要求密码中包含特殊的大写和小写字母字符，以使密码强度更高。然而，这很遗憾地导致了更弱的密码。因此，我们将要求密码足够强大，通过计算其熵来实现（这是我们在
    [*第2章*](B18727_02.xhtml#_idTextAnchor053)，*使用Quart创建可重用后端）中已经做到的）。
- en: Only checking the strength in the backend API call leads to a poor user experience
    as it takes too long for the user to receive feedback on the strength of their
    password. Fortunately, there is a `zxcvbn` version that we can use to provide
    users instant feedback on the strength of their password in the frontend.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在后端API调用中检查强度会导致用户体验不佳，因为用户需要很长时间才能收到关于密码强度的反馈。幸运的是，有一个 `zxcvbn` 版本，我们可以在前端使用它来为用户提供关于密码强度的即时反馈。
- en: 'To start, we should install it by running the following in the *frontend* directory:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该在 *前端* 目录中运行以下命令来安装它：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We’ll want this field to give immediate visual feedback to the user on the
    strength of their password, both as a color that turns more green as the password
    strength improves, and as text that says **Good** or **Strong** as appropriate.
    So, let’s add the following function to *frontend/src/components/PasswordWithStrengthField.tsx*:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这个字段能够立即向用户提供关于他们密码强度的视觉反馈，无论是通过颜色（随着密码强度的提高而变得更绿），还是通过显示**好**或**强**的文本来表示。因此，让我们向`*frontend/src/components/PasswordWithStrengthField.tsx*`添加以下函数：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can then use this function in the field itself by adding the following to
    *frontend/src/components/PasswordWithStrengthField.tsx*:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在字段本身中使用此函数，通过向`*frontend/src/components/PasswordWithStrengthField.tsx*`添加以下内容：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This code renders a `LinearProgress` component below the existing `PasswordField`
    and colors it based on the `scoreToDisplay` function already added.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在现有的`PasswordField`下方渲染一个`LinearProgress`组件，并根据已添加的`scoreToDisplay`函数着色。
- en: 'The `PasswordWithStrengthField` uses `zxcvbn` to determine the strength of
    the password. This means that any component that directly imports `PasswordWithStrengthField`
    will add `zxcvbn` to the bundle it is in, which is a problem, as `zxcvbn` is very
    large. Therefore, to only load `zxcvbn` when required, we can use React’s lazy
    loading and suspense system by adding the following to *frontend/src/components/LazyPasswordWithStrengthField.tsx*:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`PasswordWithStrengthField`使用`zxcvbn`来确定密码强度。这意味着任何直接导入`PasswordWithStrengthField`的组件都会将`zxcvbn`添加到其包中，这是一个问题，因为`zxcvbn`非常大。因此，为了仅在需要时加载`zxcvbn`，我们可以通过向`*frontend/src/components/LazyPasswordWithStrengthField.tsx*`添加以下内容来使用React的懒加载和suspense系统：'
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now the `PasswordField` will be shown to the user until `zxcvbn` has been downloaded,
    thereby improving the user experience by ensuring it is only downloaded if the
    user needs it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`PasswordField`将显示给用户，直到`zxcvbn`被下载，从而通过确保只有在用户需要时才下载来提高用户体验。
- en: These are all the custom fields we need for our to-do app; next, we need a set
    of styled action buttons.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是我们待办事项应用所需的定制字段；接下来，我们需要一组样式化的操作按钮。
- en: Implementing styled form actions
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现样式化表单操作
- en: 'The fields we’ve implemented will be contained in forms that will need to be
    submitted. Therefore, let’s add a useful helper `FormActions` component that allows
    the user to submit the form as the primary action or to navigate elsewhere instead
    as secondary actions. The code for this follows and should be added to *frontend/src/components/FormActions.tsx*:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的字段将包含在需要提交的表单中。因此，让我们添加一个有用的辅助`FormActions`组件，允许用户将表单作为主要操作提交，或者作为次要操作导航到其他地方。以下代码应添加到`*frontend/src/components/FormActions.tsx*`：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The primary action is displayed using a `LoadingButton` component as it allows
    us to indicate to the user that the form submission is in progress via a spinning
    circle. Without this feedback, the user may think the app has frozen or ignored
    their click.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 主要操作通过使用`LoadingButton`组件来显示，因为它允许我们通过旋转的圆圈向用户指示表单提交正在进行中。如果没有这种反馈，用户可能会认为应用已冻结或忽略了他们的点击。
- en: We now have all the fields and helper components we need for users to enter
    data. This means we can focus on how we will manage the app’s state and particularly
    how data is fetched from the backend and stored in the app’s state.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了用户输入数据所需的所有字段和辅助组件。这意味着我们可以专注于如何管理应用的状态，特别是如何从后端获取数据并将其存储在应用的状态中。
- en: Managing the app state
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理应用状态
- en: As with the backend, it helps to have models that represent the data used in
    the app. These models will validate the data, help the linters ensure that we
    are using the data correctly, and ensure that the correct types are used. We will
    also use the model to correctly convert to and from the JSON representation used
    to communicate with the backend API.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与后端一样，拥有代表应用中使用的数据的模型很有帮助。这些模型将验证数据，帮助linters确保我们正确地使用数据，并确保使用正确的类型。我们还将使用模型来正确地将数据转换为与后端API通信时使用的JSON表示形式。
- en: The to-do model needs to be constructed from JSON, based on what is received
    from the backend or from data that the user entered. Then, the model needs to
    output as JSON so that this output can be sent to the backend. In addition, the
    model should validate that the data it is constructed from is of the correct structure
    and convert types (i.e., from strings representing dates in JSON to `Date` instances).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 待办事项模型需要根据从后端接收到的内容或用户输入的数据构建。然后，模型需要以 JSON 格式输出，以便可以将此输出发送到后端。此外，模型还应验证构建它的数据是否具有正确的结构，并转换类型（即，将表示
    JSON 中日期的字符串转换为 `Date` 实例）。
- en: 'We only need a model for to-dos in the frontend, and hence we need the following
    in *frontend/src/models.ts*:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在前端为待办事项提供一个模型，因此我们需要在 *frontend/src/models.ts* 中添加以下内容：
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `todoSchema` is used in the constructor to confirm the data is of the correct
    structure and to convert the types. The `toJSON` method is a standard JavaScript
    method to convert objects to JSON-compatible structures, which is done by converting
    the due date to an ISO 8601 formatted string.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`todoSchema` 在构造函数中使用，以确认数据具有正确的结构并转换类型。`toJSON` 方法是一个标准的 JavaScript 方法，用于将对象转换为
    JSON 兼容的结构，这是通过将到期日期转换为 ISO 8601 格式的字符串来完成的。'
- en: While this model is specific to our app, using a class with `yup` validation
    is a good pattern for any app’s data.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个模型是针对我们的应用程序特定的，但使用带有 `yup` 验证的类是任何应用程序数据的良好模式。
- en: With a model in place, we can now communicate with the backend, which we’ll
    focus on next.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立模型之后，我们现在可以与后端通信了，这是我们接下来要关注的重点。
- en: Communicating with the backend
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与后端通信
- en: 'We’ll need to send and receive data from the backend API and then store it
    in the local state for usage in the various components that will render it. To
    begin, let’s install `axios` as it has a nicer API for sending and receiving JSON
    than the inbuilt `fetch` function. It is installed by running the following in
    the *frontend* folder:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从后端 API 发送和接收数据，并将其存储在本地状态中，以便在渲染各种组件时使用。首先，让我们安装 `axios`，因为它在发送和接收 JSON
    方面比内置的 `fetch` 函数有更友好的 API。在 *frontend* 文件夹中运行以下命令即可安装：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We will need to store the data received in a way that allows it to be used
    across multiple components. To manage this state, we’ll use `React-Query` ([https://tanstack.com/query/v4](https://tanstack.com/query/v4)),
    as it is pleasant and easy to use. To start, let’s install it by running the following
    in the *frontend* directory:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以允许跨多个组件使用的方式存储接收到的数据。为了管理这个状态，我们将使用 `React-Query` ([https://tanstack.com/query/v4](https://tanstack.com/query/v4))，因为它易于使用且令人愉悦。首先，让我们在
    *frontend* 目录中运行以下命令来安装它：
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To use `React-Query`, a `QueryClient` must be provided via React-Query’s `QueryClientProvider`.
    This is achieved by adding the following to *frontend/src/App.tsx*:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `React-Query`，必须通过 React-Query 的 `QueryClientProvider` 提供一个 `QueryClient`。这是通过在
    *frontend/src/App.tsx* 中添加以下内容来实现的：
- en: '[PRE42]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The highlighted lines should be added to the existing code.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 应该将突出显示的行添加到现有代码中。
- en: We need to adapt React-Query so that requests that aren’t authenticated result
    in changes to the `AuthContext`. This is to handle cases where a user visits a
    page without logging in first. We’ll also only allow retries if the server doesn’t
    respond or responds with a `5XX` status code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要调整 React-Query，使得未认证的请求会导致 `AuthContext` 发生变化。这是为了处理用户在未先登录的情况下访问页面的情况。我们还将只允许在服务器没有响应或响应状态码为
    `5XX` 时重试。
- en: State management
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 状态管理
- en: The rendered output in React must be a function of the current state. Therefore,
    when fetching data from the backend, we need to manage the various states of the
    fetch. These states start with the fetch loading and progress to success or error
    states, depending on the result. Assuming the fetch succeeds, there is then the
    question of how long the data is valid before it needs to be fetched again. All
    of these states are helpfully managed for us by React-Query.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，渲染的输出必须是当前状态的函数。因此，当从后端获取数据时，我们需要管理各种获取状态。这些状态从获取加载开始，根据结果进展到成功或错误状态。假设获取成功，那么数据在需要再次获取之前的有效时长就是一个问题。所有这些状态都由
    React-Query 帮助我们管理。
- en: 'To do so, we’ll first write a wrapper around React-Query’s `useQuery`, which
    is used to fetch data from the backend API, by adding the following to *frontend/src/query.ts*:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们首先需要在 *frontend/src/query.ts* 文件中围绕 React-Query 的 `useQuery` 写一个包装器，该包装器用于从后端
    API 获取数据，通过添加以下内容：
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This code wraps the standard `useQuery` hook by checking any errors for a 401-response
    status code, as shown by the first highlighted block. As a 401-response indicates
    the user is unauthenticated, the local authentication state is then updated.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通过检查401响应状态码的错误来包装标准的`useQuery`钩子，如图中第一个高亮块所示。由于401响应表示用户未认证，因此随后更新了本地认证状态。
- en: The code also provides logic to decide when the request should be retried, as
    shown by the second highlighted block. The logic will retry the request up to
    a maximum of two times if there is a network error (no response) or a server error
    (as indicated by a `5XX` response code). Note, therefore, that the query will
    be in the loading state until all three attempts have failed in the case of network
    failure.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 代码还提供了逻辑来决定何时重试请求，如图中第二个高亮块所示。如果出现网络错误（无响应）或服务器错误（由`5XX`响应代码指示），逻辑将重试请求，最多重试两次。注意，因此，在出现网络故障的情况下，查询将在所有三次尝试都失败之前处于加载状态。
- en: 'We’ll now add the same logic to React-Query’s `useMutation`, which is used
    to send data to the backend API by adding the following to *frontend/src/query.ts*:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向React-Query的`useMutation`添加相同的逻辑，该钩子通过以下方式添加到*frontend/src/query.ts*：
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This `useMutation` hook has the same authentication wrapper and retry logic
    as the `useQuery` hook.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`useMutation`钩子具有与`useQuery`钩子相同的认证包装和重试逻辑。
- en: 'These two new hooks can then be used in any part of the app in the same way
    as the standard React-Query hooks are. For example, the `useQuery` hook can be
    used like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个新的钩子可以在应用的任何部分以与标准React-Query钩子相同的方式使用。例如，`useQuery`钩子可以这样使用：
- en: '[PRE45]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We can now fully interact with the backend and store the appropriate state locally,
    which allows us to focus on giving feedback to the user.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以完全与后端交互，并存储适当的状态，这使我们能够专注于向用户提供反馈。
- en: Supporting toast feedback
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持吐司反馈
- en: '**Toasts** (called **Snackbar** in MUI) can be used to show feedback to the
    user that doesn’t relate to a direct element on the page. Good usage of a toast
    is showing an error message if a request to the backend fails, as shown in *Figure
    4.5*, or showing a success message after the user changes their password, as there
    is no direct confirmation via the page content. A bad usage would be to report
    that the entered email is invalid as, in this case, the email field should show
    an error.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**吐司**（在MUI中称为**Snackbar**）可以用来向用户展示与页面上的直接元素无关的反馈。良好的吐司使用方式是在请求后端失败时显示错误消息，如图*4.5*所示，或者在用户更改密码后显示成功消息，因为没有直接通过页面内容进行确认。不良的使用方式是报告输入的电子邮件无效，在这种情况下，电子邮件字段应该显示错误。'
- en: '![Figure 4.5: An example of a toast error ](img/B18727_04_05.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5：吐司错误示例](img/B18727_04_05.jpg)'
- en: 'Figure 4.5: An example of a toast error'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：吐司错误示例
- en: 'To support toasts, we need to be able to add a toast from any component in
    the app and have that toast displayed. Crucially, if there are multiple toasts,
    they should be displayed one after another so that there is never more than one
    toast displayed. This is another React context use case, much like the authentication
    context added earlier. So, let’s start by adding the following toast context to
    *frontend/src/ToastContext.tsx*:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持吐司，我们需要能够从应用的任何组件中添加吐司，并显示该吐司。关键的是，如果有多个吐司，它们应该一个接一个地显示，以确保不会同时显示多个吐司。这是另一个React上下文用例，类似于之前添加的认证上下文。因此，让我们首先将以下吐司上下文添加到*frontend/src/ToastContext.tsx*：
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As the `ToastContextProvider` needs to be an ancestor of any of the components
    that use toasts in the app, we can add it to *frontend/src/App.tsx*:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ToastContextProvider`需要是任何使用吐司的组件的祖先，我们可以将其添加到*frontend/src/App.tsx*：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The highlighted lines should be added to the existing code.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 应该将高亮行添加到现有代码中。
- en: 'Finally, we need to display the toasts. We can do this via a Toasts component,
    by adding the following to *frontend/src/components/Toasts.tsx*:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要显示吐司。我们可以通过添加以下内容到*frontend/src/components/Toasts.tsx*来实现：
- en: '[PRE48]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The key aspect of this code is `useEffect`, which will take a toast from the
    list of toasts and set it as the current toast whenever there are toasts to display
    and there isn’t an open one. The toasts are also set to automatically close after
    6 seconds, giving the user enough time to register it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的关键方面是`useEffect`，它将从吐司列表中取出一个吐司，并在有吐司要显示且没有打开的吐司时将其设置为当前吐司。吐司也会自动在6秒后关闭，给用户足够的时间来注册它。
- en: 'We now need to render the `Toasts` component in the `App` component, leaving
    the final version of *frontend/src/App.tsx* as the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要在`App`组件中渲染`Toasts`组件，最终版本的前端代码`*frontend/src/App.tsx*`如下所示：
- en: '[PRE49]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The highlighted lines are to be added to provide toasts.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行是为了添加toast。
- en: Now, when a toast is added by any component, it will show for 6 seconds as an
    alert snackbar at the top center of the screen.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当任何组件添加了一个toast时，它将在屏幕顶部中央作为一个alert snackbar显示6秒钟。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve created a styled frontend that includes routing, validated
    data entry, and toast feedback, and can connect to the backend API we built in
    the last chapter. This will allow us to add the specific pages and functionality
    we need for our to-do app.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个包含路由、验证数据输入和toast反馈的样式化前端，并且可以连接到我们在上一章中构建的后端API。这将使我们能够添加我们待办应用所需的特定页面和功能。
- en: The functionality added in this chapter can serve as the basis for any app,
    not just the one specific to the to-do app being developed in this book. You can
    take this basis and add any user interface you need for your functionality.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 本章添加的功能可以作为任何应用的基石，而不仅仅是这本书中开发的特定待办事项应用。你可以在此基础上添加任何你需要的功能的用户界面。
- en: In the next chapter, we’ll build the pages and add the functionality that makes
    up the to-do app.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建页面并添加构成待办事项应用功能的部分。
- en: Further reading
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: If you find you can’t represent the state of your app using React-Query, it
    is probably time to use a full state management tool such as Redux, [https://redux.js.org](https://redux.js.org).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现你无法使用React-Query来表示你应用的状态，那么可能就是时候使用像Redux这样的完整状态管理工具了，[https://redux.js.org](https://redux.js.org)。
