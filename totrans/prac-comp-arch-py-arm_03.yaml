- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: High-Speed Introduction to Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces Python and demonstrates how to write a program in Python
    to solve the type of problem we described in [*Chapter 1*](B19624_01.xhtml#_idTextAnchor015).
    We are not going to delve deeply into Python in this chapter, but we will cover
    Python sufficiently to enable you to simulate and modify a computer to incorporate
    your own ideas.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, a computer program has been compared to a cookery recipe because
    they are analogous. Strictly speaking, this statement applies only to procedural
    languages such as Python, Java, and C. Functional languages such as Lisp do not
    conform to this strictly sequential paradigm and are beyond the scope of this
    text
  prefs: []
  type: TYPE_NORMAL
- en: A recipe is a sequence of *operations* (i.e., actions or steps) that are carried
    out *in order* on the *ingredients* used by the recipe. A program is the same;
    it is a sequence of operations (instructions) that are carried out, in order,
    on data. The instructions of a program are carried out, one by one, sequentially,
    from top to bottom, arranged exactly like a page of printed text. It’s also possible
    to repeat a group or block of instructions several times, and you can even skip
    past or ignore blocks of instructions.
  prefs: []
  type: TYPE_NORMAL
- en: The analogy between a recipe and a program is surprisingly accurate. In a recipe,
    you can have *conditional* instructions such as, “*If the sauce is too thick,
    then add more water.*” In programming, you can have conditional instructions such
    as, “*If x is 0, then add 1 to y.*” Similarly, in cooking, you can express repetitive
    action by expressions such as, “*Beat the mixture until stiff.*” In computing,
    repetition can be expressed using constructs such as, “*Subtract 1 from z until
    z =* *0.*”
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python’s data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mathematical operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Names, values, and variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list – a Python key data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional operations and decision-making
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading data from a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Translating a token detector algorithm into Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computer memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register transfer language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the programs used in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter02](https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: The requirements to write a program in Python and run it are minimal. Python
    is an open source language and is freely available for the PC, Mac, and Linux
    platforms. All the information you need to set up a Python environment on your
    computer system can be found on the home page at [https://www.python.org](https://www.python.org).
  prefs: []
  type: TYPE_NORMAL
- en: Remarkably, you do not need any other software to construct a computer simulator
    in Python. The Python package comes with Python’s **Integrated Learning and Development
    Environment** (**IDLE**) that lets you edit a Python program, save it, run it,
    and debug it.
  prefs: []
  type: TYPE_NORMAL
- en: There are alternatives to IDLE that let you create Python source files supported
    by Python platforms. These alternatives are generally more sophisticated and targeted
    at the professional developer. For the purposes of this chapter, IDLE is more
    than sufficient, and nearly all the Python programs in this text were developed
    with IDLE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternative IDEs are Microsoft’s Visual Studio Code, Thonny, and Geany. All
    these IDEs are freely available. Thonny was developed for the Raspberry Pi, which
    we will use in later chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code:[https://code.visualstudio.com/download](https://code.visualstudio.com/download)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geany:[https://www.geany.org/](https://www.geany.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thonny:[https://thonny.org](https://thonny.org)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading programs is not easy for the beginner because you don’t know how to
    interpret what you see. The following section describes some of the typography
    and layout conventions we will use in this chapter to make the meaning of programs
    more clear and to highlight the features of a program.
  prefs: []
  type: TYPE_NORMAL
- en: Reading programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to help you follow the programs, we have adopted two different type
    fonts – a variable-width font (where letters have different widths, such as the
    bulk of the text here) and a mono-spaced font, such as the Courier font found
    on old mechanical typewriters `that looks` `like this`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for using a mono-spaced font to represent code is twofold. First,
    it tells the reader that a word is computer code and not just part of the narrative
    text. Second, spacing in computer programs is important for readability, and mono-spaced
    fonts line up letters and numbers on adjacent rows neatly in columns. The following
    is an example of code from a later chapter to demonstrate this point. The proportionally-spaced
    text to the right, prefixed by #, indicates that the text is not code but a plain-language
    comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We have occasionally used shading or a bold font to distinguish one feature
    of a piece of code from another.For example, `x = y.`split('.') uses a bold font
    to emphasize the `split` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example. The gray text indicates reserved words and
    symbols in Python that are necessary to specify this construct. The numbers in
    bold black are values supplied by the programmer. The text following # is in a
    non-monospaced font and is a comment ignored by the computer:'
  prefs: []
  type: TYPE_NORMAL
- en: for i in range (0`,`6):# Repeat six times
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we use shading to emphasize a feature – for example, `rS1 =
    int(inst`[2][1]`)`draws your attention to the first parameter, `[2]`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we look at Python in more detail, we will provide a brief introduction
    to getting started with Python and demonstrate a short program. Although we have
    not even introduced the basics of the language, Python programs are remarkably
    easy to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Python is a computer language such as C or Java and, like every computer language,
    it has its advantages and disadvantages. We have chosen to use Python because
    it is free and universal, there’s a vast amount of information about it, and,
    most importantly, it has a very shallow learning curve. Indeed, Python has become
    one of the most popular languages used in computer science education.
  prefs: []
  type: TYPE_NORMAL
- en: Python was conceived by the Dutch computer scientist Guido van Rossum, and the
    stable Python 2.0 was released in 2000\. Today, Python is promoted by the Python
    Software Foundation, a body of volunteers whose aim is to develop the language
    as a public service.
  prefs: []
  type: TYPE_NORMAL
- en: The high-level language programs in this text were written in Python on a PC.
    To install Python, you need to go to its home page at [https://www.python.org](https://www.python.org)
    and follow the instructions. There are several versions of Python because it is
    continually growing. The two main branches are Python 2 and Python 3; I will be
    using the latter. Python is continually updated and new versions are introduced.
    I started with Python 3.6, and at the time of writing, we’re up to Python 3.11\.
    However, new incremental versions do not offer radical changes, and many of the
    new features are not used by the Python version in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the Python packages provides you with a Python documentation library,
    a Python interpreter, and a Python editor called the IDLE. All this is freely
    available. IDLE allows you to perform a cycle, *edit a program, run it, and debug
    it* until you are happy with the result. I also used the freely available Thonny
    IDE, which I found even easier to use. Using an IDE lets you develop a program,
    run it, and then modify it, without having to switch between separate editors,
    compilers, and runtime environments.
  prefs: []
  type: TYPE_NORMAL
- en: Late in the writing of this book, Graeme Harker introduced me to **Visual Studio
    Code** (**VS Code**). This is a popular integrated development system developed
    by Microsoft that supports several languages, including Python, and which runs
    on several platforms, including Windows, Linux, and macOS. VS Code is a very powerful
    IDE indeed and includes facilities that go beyond those of IDLE.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the example of an IDE (in this case, IDLE) in *Figure 2**.1*. Suppose
    we want to create a four-function calculator that performs simple operations such
    as 23 x 46 or 58 - 32\. I’ve chosen this example because it is really a very simple
    computer simulator. *Figure 2**.1* is a screenshot taken after a Python program
    has been loaded using the `file` function. You can also directly enter a Python
    program from the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: If we click on `+`, `-`, `/`, or `*`, it terminates the execution and prints
    a message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like most high-performance IDE systems, IDLE uses color to help you to read
    a program. Python lets you add a commentary to the program because code is not
    always understandable. Any text following a # symbol is ignored. In this case,
    the code is understandable, and these comments are not necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: You have to save a program before you can run it. Saving a program from `IDLE`
    automatically appends `.py`, so that a file named `calc1` is saved as `calc1.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – A screenshot of a Python program in IDLE](img/Figure_2.01_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – A screenshot of a Python program in IDLE
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.1* shows the layout of Python programming, including the all-important
    *indentation*, which is a key feature of Python and indicates which operations
    belong to a particular command.'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a brief description of the program. We will cover this material in greater
    detail later. `while` heads a group of indented instructions that are repeated
    until some condition stops being true. In this case, the instructions are executed
    as long as the `go` variable is `1`.
  prefs: []
  type: TYPE_NORMAL
- en: The `if` statement defines one or more operations that are executed if `if`
    is true. In this case, if the input is `'E'`, the `go` variable is set to `0`,
    and the indented operations after `while` are no longer executed.
  prefs: []
  type: TYPE_NORMAL
- en: The `break` instruction breaks out of the `while` loop (that is, execution continues
    beyond the end of the loop – it’s a sort of short-circuit mechanism).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `int(x)` function converts a keyboard character into an integer
    – for example, `int('27')` converts the two keys, `2` and `7`, into the integer,
    `27`. We will discuss all this in greater detail later.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the program, you select the `F5`. The following demonstrates the effect
    of running this program. The text in bold is the text I entered using the keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this brief demonstration is to show how a Python program is entered
    and executed. In practice, no programmer would write the preceding code. It is
    inefficient. It does not deal with errors (what happens if you type `@` instead
    of `*`, or `$` instead of `4?`). Even worse, to stop the program, you have to
    enter a dummy number before entering `E` to end the program. I leave it as an
    exercise for you to convert this program into a version that is more user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve demonstrated a trivial Python program. The next step is to introduce the
    data with which Python operates – that is, we show how Python handles numbers
    and text.
  prefs: []
  type: TYPE_NORMAL
- en: Python’s data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A recipe uses *ingredients* that fall into distinct groups (fruit, vegetables,
    nuts, cheeses, spices, etc.). A computer program uses data that falls into groups
    called *types*. Some of the main data types used by Python are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Integer**: This uses whole numbers, such as 0, 1, 2, and so on. Integers
    also include negative numbers -1, -2, -3, and so on. Positive integers are also
    known as natural numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Float**: These are numbers with a decimal point (e.g., 23.5 and -0.87). These
    are also called *real* numbers. Surprisingly, we will not be using real numbers
    in this text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Character**: A character is one of the keys on a computer keyboard – for
    example, *Q*, *Z*, *a*, *$*, and *@*. Computer languages often indicate a character
    by putting it in inverted commas – for example, ''R''. In practice, Python does
    not have an explicit character type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''This''` or `''my program''`. Python doesn’t have a character type because
    it treats a character as a string of length 1\. Python allows you to use single
    or double quotes interchangeably – for example, `x = ''this''` and `x = "this"`
    are identical in Python. This mechanism allows you to type x = ''''The boy’s books''''
    (i.e., you can use an apostrophe without it being treated as a quotation mark).
    In computing, the term *string* is rather like the English term *word*. A string
    is any sequence of characters – for example, `''time''` and `''!££??''` are legal
    Python strings. Recall that a string of length 1 is a single character – for example,
    ''Q''. You can have a string of length zero – that is,''''. Here, you have two
    quotation marks with nothing in between. This indicates an empty string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`True` and `False`. The bool type is used in Boolean logic expressions. It
    is also used in comparisons – for example, the English expression, “Is *x* greater
    than *y*?” has two possible outcomes – True or False. If you type `print(5 ==
    5)` in Python, it will print True because the == means “*is the same as?*” and
    the result is True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each data element used in a program is given a *name* so that we can access
    it. The programmer chooses names for variables, and a good programmer chooses
    sensible names that indicate what the variable is. No one calls a variable `qZz3yT`.
    Names must begin with a letter, and then they may have any sequence of letters
    and numbers – for example, `alan`, `alan123`, and `a123lan` are legal Python names,
    whereas `2Alan` or `Al@n` is not legal. However, the underscore may be used in
    a name – for example, `time_one`. By convention, Python uses lowercase for the
    first character of variables and function names. Uppercase first letters are reserved
    for class names (which we will not use in this text). This restriction is a programming
    convention – that is, an error will not occur if you give a variable a name beginning
    with an uppercase letter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve introduced data elements, we next describe some of the operations
    you can apply to numeric data. These are essentially the arithmetic operators
    we encountered in high school, except for division, which has three variations.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Computers can perform the four standard arithmetic operations – addition, subtraction,
    multiplication, and division. For example, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The symbol for multiplication is *** (the asterisk) and not the conventional
    *x*. Using the letter *x* to indicate multiplication would lead to confusion between
    the letter *x* and *x* as a multiplication operator.
  prefs: []
  type: TYPE_NORMAL
- en: Division is more complicated than multiplication because there are three ways
    of expressing the result of x ÷ y. For example, 15/5 is 3, and the result is an
    integer. 17/5 can be expressed in two ways – as a fractional value (i.e., a float)
    3.4, or as 3 remainder 2\. In Python, the division operator provides a float result
    if the result is not an integer (e.g., 100/8 = 12.5).
  prefs: []
  type: TYPE_NORMAL
- en: As well as the division operator, /, Python has two other division operators
    – `//` and `%`.
  prefs: []
  type: TYPE_NORMAL
- en: Python’s `//` is a *floor integer* divide that generates an integer result by
    rounding down to the nearest integer. For example, the operation `x = 17//5` gives
    the result `3` and the fractional part (the remainder) is discarded. Note that
    `x = 19//5` gives the result `3` because it *rounds down*, even though 4 is the
    closest integer. If you were to execute `x = -19//5`, that would give the result
    `-4` because it rounds *down* to the closest integer.
  prefs: []
  type: TYPE_NORMAL
- en: The % symbol is the *modulus* operator and provides the remainder after division.
    For example, `x = 17%5` gives the result `2`. Suppose, on Monday, someone said
    they were visiting you in 425 days. What day of the week is that? 425%7 is 5,
    which indicates Saturday. We can use % to test whether a number is odd or even.
    If you write `y = x%2`, then `y` is `0` if the number is even and `1` if it is
    odd.
  prefs: []
  type: TYPE_NORMAL
- en: Names, values, and variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computers store data in their memory. Each data element has two values associated
    with it – **where** it is, and **what** it is. In computer terms, *where* corresponds
    to the location (address) of the data in memory, and *what* corresponds to the
    value of that data. This is not rocket science, and matches everyday life – for
    example, I might have a bank account numbered 111023024 containing $890\. Here,
    111023024 is the “where,” and the $890 is the “what.”
  prefs: []
  type: TYPE_NORMAL
- en: Now, suppose I write 111023024 + 1\. What exactly do I mean? Do I mean to add
    1 to the account number to get 111023025 (which is a different account), or do
    I mean to add $1 to the number in this account numbered 111023024 to get $891?
    In everyday life, this is something that’s so obvious we just don’t think about
    it. In computing, we have to be a little more careful and think clearly about
    what we are doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data elements are called **variables** because their values can be changed.
    A variable has an address (location) in memory. A programmer doesn’t have to worry
    about the actual location of data; the operating system takes care of that for
    them automatically. All they have to do is to come up with a name for the variable.
    For example, let’s take the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When you write this, you define a new variable that you’ve called `totalPopulation`
    and have told the computer to store the number `8024` at that location. You don’t
    have to worry about all the actions involved in doing this; that’s the job of
    the operating system and compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s summarize. A variable is a name that refers to some value stored in memory.
    Let’s say you write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, the computer reads the current value in the memory location assigned to
    the name `totalPopulation`. It then adds 24 to this value, and finally, stores
    the result in `totalPopulation`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we look at user comments and program layout in a little
    more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because computer languages can be terse and confusing to the human reader,
    they let you add comments that are ignored by the computer (i.e., they are not
    part of the program). In Python, any text on the same line following the # symbol
    is ignored. In the following examples, we’ve put that text in a different font
    to emphasize that it’s not part of the program. First, consider the following
    Python expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This code creates a new data element called `hours` and gives it the integer
    value `12`. *Figure 2**.2* illustrates the structure of this line.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – The structure of a statement with a comment](img/Figure_2.02_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – The structure of a statement with a comment
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you were then to write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Then, the computer would read the value of the name on the right-hand side of
    the expression (i.e., `hours`) and substitute its value with 12\. Then, it would
    add 3 to get 12 + 3 = 15, storing this new value in a memory location called `allTime`.
    The text following `#` is ignored by the computer and serves only to help humans
    understand the program.
  prefs: []
  type: TYPE_NORMAL
- en: Many computer languages use the = symbol differently from how we were taught
    in high school. In school algebra, ‘=’ means “*the same as,*” so that *x* = *y*
    + 2 means that the value of *x* and (*y* + 2) are identical. If the value of *y*
    is 12, then the value of *x* is 14.
  prefs: []
  type: TYPE_NORMAL
- en: In programming, the statement `x = y + 2` indicates that the value of *y* +
    2 is calculated and then *transferred* to *x*. If a programmer writes `x = x +
    2`, it means to add 2 to `x`. If this were a mathematical equation, we could write
    *x* – *x* = *x* – *x* + 2, which simplifies as the nonsensical expression 0 =
    2\. In Python, the = symbol does NOT mean equals!
  prefs: []
  type: TYPE_NORMAL
- en: In Python, the `=` symbol means “*assign to.*” A better symbol is `←`, so that
    *x* `←` *y* + 2 expresses clearly what we are doing. Some languages such as Pascal
    use the symbol pair := to indicate assignment. Sadly, the back arrow is not on
    keyboards, and we are stuck with =. Note that, in Python, a *statement* is a command
    such as `print(`) or an assignment such as `x = 4.` An *expression* is a combination
    of variables or values and operations that returns a result.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve seen, Python has a special symbol for “*is the same as,*” and that
    symbol is ‘==’. Never confuse = and ==. It is very easy to write `if x = 5` instead
    of `if x == 5` and wonder why your program gives the wrong result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example of a simple Python program, where we calculate
    the area of a circle. The names `radius`, `pi`, and `area` are all chosen by the
    programmer. We could have used other names, but these are more obvious to the
    reader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that a Python name consists of letters and (optionally) numbers and
    underscores, but the first character in the name must be a letter and not a number.
    Uppercase and lowercase letters are regarded as being different in Python – that
    is, `tesT22` and `test22` are different names. It is good practice to choose meaningful
    names because that makes it easier to read a program. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding expression is verbose but clear to a human reader. This is an
    example of *camelCase*, a popular term for names that consist of words joined
    without spaces, using a capital letter to indicate each word in the chain, `asWeAreDoingNow`.
    Remember that Python variables and labels do not start with a capital letter (that’s
    a convention and not a requirement).
  prefs: []
  type: TYPE_NORMAL
- en: There are two classes of data elements – constants and variables. A *constant*
    is given a value when it is first named, and that value cannot be changed – for
    example, if you define `x = 2` as a constant in a language such as C, the value
    of *x* is fixed (e.g., the expression `x = 3` would be illegal). A *variable*
    is an element that can be modified. Python does not support constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s calculate the sum of the first *n* integers, *s* = 1 + 2 + 3 + … + *n*.
    Algebra tells us that the sum of *n* integers is *n*(*n* + 1)/2\. We can convert
    this into the following Python program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This three-line Python program asks for an integer, performs the calculation,
    and prints the result. Let’s suppose we don’t know the formula for the sum of
    the first *n* integers. We can do it the hard way by adding them up one by one.
    The Python code to do this is given in *Listing 2.3*.
  prefs: []
  type: TYPE_NORMAL
- en: We have not covered all aspects of this program in detail yet. It is given here
    to demonstrate the essential simplicity of Python. However, note that Python allows
    you to request input from the keyboard and provide a prompt at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – A Python program to add the first n integers](img/Figure_2.03_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – A Python program to add the first n integers
  prefs: []
  type: TYPE_NORMAL
- en: Our next topic introduces one of Python’s key elements – a feature that is immensely
    powerful and flexible and one that makes Python such a popular language, especially
    for beginners. We will describe the list.
  prefs: []
  type: TYPE_NORMAL
- en: The list – a Python key data structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now introduce Python’s *list*, which that groups together a sequence of elements.
    We show how the elements of a list can be accessed. Because the list is such a
    key feature, we will return to it several times, each time introducing new features.
  prefs: []
  type: TYPE_NORMAL
- en: A data structure is an ordered collection of data elements. The term *ordered*
    indicates that the position of a data element matters – for example, in everyday
    life, the week is ordered because the sequence of the days is fixed. A *table*,
    a *stack*, a *queue*, a *list*, a *heap*, a *pile*, a *file*, and an *array* all
    embody the idea of a data structure. In English, a *sackload* of books implies
    an *unordered* collection of items. Python does have a special data structure
    for unordered items, called a set. We will not use sets in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like any other object, the programmer assigns a name to a list. The following
    Python list gives the result of eight consecutive exams taken by a student, expressed
    as a percentage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We have given the list a meaningful name, `myTest`. In Python, a list is enclosed
    in square brackets and the items are separated by commas. Lists can grow (items
    added to them) and shrink (items removed). You can have an empty list – for example,
    `abc = []`.
  prefs: []
  type: TYPE_NORMAL
- en: The whole point of a list is to be able to access individual items and manipulate
    them – for example, we might want to find the highest result or the lowest result,
    or the average in the `myTest` list. Therefore, we need to specify the location
    of an item. Mathematicians use *subscripts* for this task – for example, they
    may write `myTest`5\. Unfortunately, computer science arose in the dark age of
    the mechanical courier typewriter script, when different fonts, colors, italics
    style, and subscripts didn’t exist. So, we have to use the symbols that are on
    all keyboards to indicate a location within a list.
  prefs: []
  type: TYPE_NORMAL
- en: Python indicates the position of an item in a list (or other data structures)
    by means of *parentheses* – for example, element 3 in `myTest` is expressed as
    `myTest[3]`. The first element of a list is position 0 because computers count
    from zero. The first value in `myTest` is `myTest[0]`, which is 63\. Similarly,
    the last result is `myTest[7]`, which is 76\. We have 8 results, numbered 0 to
    7.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python is a more flexible language than some. In Python, the list is a “*one
    size fits all*” data structure. If you want to put different types of items in
    a list, you can. Other computer languages require a list to have identical items
    (e.g., all integers, all floats, or all strings). The following example demonstrates
    some legal lists in Python. As you can see, you can even have a list of lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have aligned the *equals* symbols in a column on the left. This
    is not a feature of Python. Nor is it a requirement. We do it because it makes
    the code easier to read and makes debugging easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s return to the shopping list example and call the list `veg1`. We can
    set up this list with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The individual items in this list are in quotation marks. Why? Because they
    are strings – that is, text. Without quotations, the items would refer to variables
    that were defined earlier, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Slicing lists and strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we will demonstrate how you can take a string or a list and extract data
    elements (i.e., the slices) from a string or a list. The individual characters
    of a string can be accessed – for example, if `y = 'absde'`, then `y[0] = 'a',
    y[1]= 'b', y[2]= 's',` , and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Python lets you select the last element in a string or list by using the - 1
    *index* – for example, if you write `x = y[-1]`, `then x = 'e'`. Similarly, `y[-2]is
    'd'` (i.e., the next but one from the end).
  prefs: []
  type: TYPE_NORMAL
- en: You can select a slice of a string or list using the `list[start:end]` notation.
    The slice specified by `[start:end]` selects elements from `start` to `end - 1`
    that is, you specify the end as the element *after* the last element you require.
    If `q = 'abcdefg'`, then the `r = q[2:5]` slice assigns `r = '``cde'`.
  prefs: []
  type: TYPE_NORMAL
- en: The expression `z = q[3:]`refers to all elements from 3 to the end of the list,
    and assigns `'defg'` to `z`. This is a remarkably useful feature because it allows
    us to take a text string such as `s='R14'` and extract the numeric value of the
    register with `t=int(s[1:])`. The expression `s[1:]` returns a substring from
    the second character to the end – that is, '`R14`' becomes '`14`'. This value
    is a string type. The `int(`'`14`'`)` operation converts the string type to an
    integer type and returns 14.
  prefs: []
  type: TYPE_NORMAL
- en: The `len` function returns the length of a string. If `y='absde'`, `p=len(y)`
    returns 5 because there are 5 characters in the string.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a list of assembly language instructions `– ops=['ADD',` `'MUL',` `'BNE',`
    `'LDRL']`. If we write `len(ops)`, we get the result `4`, because there are 4
    strings in the `ops` list. Suppose we write `x=ops[3][2]`. The value of `ops[3]`
    is `'LDRL'`, and the value of `LDRL[2]` is '`R`'. In other words, we can extract
    one or more characters from a string in a list of strings. The `x[a][b]` notation
    means to take item `a` of list `x` and then take item `b` of that element.
  prefs: []
  type: TYPE_NORMAL
- en: We have used functions such as `print()` and `len()`. We will now discuss functions
    in a little more detail. Later, we show you how you can define your own functions
    as well as use Python’s built-in functions.
  prefs: []
  type: TYPE_NORMAL
- en: Functions in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before continuing, we need to introduce the concept of a function in a high-level
    language. In high school math, we encounter functions such as *sqrt(x)*, which
    is an abbreviation of *square root* and returns the square root of *x* – for example,
    *sqrt(9) = 3*. Computer languages have borrowed the same concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python provides functions that are built into the language. You call a function
    to perform a specific operation (it’s a bit like subcontracting in the real world)
    – for example, `len()`operates on strings and lists. If you call `len(x)` with
    the list `x`, it will return the number of items in that list. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This takes the list we called `veg1` and counts the number of items in it, copying
    that value to the `toBuy` variable. After this operation has been executed, the
    value of `toBuy` will be the integer 3, since there are 3 items in `veg1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Then, the number printed is 8 because there are eight characters in the string
    `q`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s suppose we have another list of food items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s add together the number of items in the two lists. We can do that with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This expression calculates the length of both lists (getting the integers `3`
    and `4`, respectively), adds them together, and assigns the value `7` to the `totalShopping`
    variable. You can print this on the screen by using the `print()`function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This expression consists of the Python word `print`, which displays something
    on the screen. The parameters used by `print` are enclosed in parentheses, separated
    by commas. A parameter in quotes is a string and is printed literally as it is.
    Remember that Python lets you use either single or double quotation marks. A parameter
    that is a variable is printed as its value. In this case, the value of the `totalShopping`
    parameter is `7`. This expression would display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following expression (we’ve shaded the text to be printed). Variables
    whose values will be printed are in bold to improve understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '`print(''`Total items to buy`'',` totalShopping`, ''`These are: `'',` fruit1`)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'What would this print? The output would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Is this what you would have expected? You might have been looking for a list
    in the order of apples, oranges, grapes. But what you asked for was the `fruit1`
    Python list, and that is exactly what you got (hence the brackets, and quotation
    marks around each item in the list). If we wanted to print the list as `apples,
    oranges, grapes, bananas`, we would have had to first convert the list of strings
    into a single string item (which we will discuss later). However, for the impatient
    among you, here’s how it’s done using the `join()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this code is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will discuss the very item that makes a computer a computer – the conditional
    operation that selects one of two or more possible courses of action, depending
    on the result of a test.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional operations and decision-making
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'And now for the biggie – the conditional operation. Let’s consider the following
    recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Take two eggs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Separate the whites.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add sugar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Beat until stiff.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These actions are carried out sequentially. The first three actions are simple
    operations. The fourth action is very different from the previous three, and it
    is this action that gives the computer its power. It’s an operation that performs
    one of two actions, depending on the outcome of a test. In this case, the eggs
    are beaten, then tested. If they are not sufficiently stiff, the beating is continued,
    they are retested, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: What makes a computer so powerful is its ability to take decisions. Without
    a *decision-making* capacity, a computer could not respond to its environment;
    it could perform only the same calculation over and over again. The foundation
    of human intelligence is also decision-making. If you play chess, you use decision-making
    to choose the next move on the basis of the current board positions. The move
    you make is the one that will give you the best chance of winning from your current
    situation.
  prefs: []
  type: TYPE_NORMAL
- en: It’s the same with a computer. At any point in a program, the computer can be
    given two alternative courses of action. Depending on the outcome of a test, the
    computer chooses one of these courses of action to take and then carries out the
    appropriate operations for that decision.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical conditional operation is the `if` statement. In Python, this can
    be expressed as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We’ve put the condition in bold, and the action is shaded. The action is carried
    out if, and only if, the condition is true. If the condition is not true, the
    action is ignored. For example, if *x* is 6, the value of *z* will be 20\. If
    *x* is 4, the value of *z* will remain at 9.
  prefs: []
  type: TYPE_NORMAL
- en: Computers perform simple tests whose outcome is one of the two Boolean values,
    `True` or `False`. More often than not, the test asks, “*Is this variable equal*
    *to zero?*”
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, the `if` statement has the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The only two reserved Python elements are `if` and the colon. The term `condition`
    is any Python expression that returns the `True` or `False` value, and `action`
    is any block of instructions the computer will execute if the condition is `True`.
    Some programmers put the action on a new line. In this case, the action MUST be
    indented, such as the following *Figure 2**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – A Python program to add the first n integers](img/Figure_2.04_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – A Python program to add the first n integers
  prefs: []
  type: TYPE_NORMAL
- en: Although Python lets you use any indentation, good practice suggests the indentation
    be four spaces.
  prefs: []
  type: TYPE_NORMAL
- en: The condition is `x > 5`, and the action is `z = 20`. The condition is a Boolean
    logic expression that yields one of two outcomes – True if *x* is greater than
    5 and False if *x* is not greater than 5.
  prefs: []
  type: TYPE_NORMAL
- en: Using a conditional expression in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Python program to control the temperature of a room might look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Typical Boolean conditions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'These four conditions are *equal to*, *not equal to*, *greater than*, and *less
    than*, respectively. Remember that the expression *x == y* reads, “*Is x equal
    to y?*” Consider the following example (using the Python IDLE interpreter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Examples of if statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A variable, *x*, varies between 0 and 9, inclusive. Let’s say we want *y* to
    be 0 if *x* is less than 5, 1 if *x* > 4 and *x* < 8, and 2 if *x* > 7\. We can
    express this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The second `if` statement tests two conditions together by using an `and` operator.
    Both conditions, `x > 4` and `x < 8`, must be true for the whole expression to
    be true.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use Python’s `or` operation, which means if any of the conditions
    are true. You can write complex conditions such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As in conventional arithmetic, it is necessary to use parentheses to ensure
    that operations are carried out in the appropriate sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test this code by generating sequential values of *x* and printing the
    corresponding value of *y*, as the following code in *Figure 2**.5* demonstrates.
    The first statement executes the indented block for x is 0 to 9 (one less than
    the range given):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Demonstrating iteration ](img/Figure_2.05_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Demonstrating iteration
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from this code is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Python’s if … else
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The preceding code is correct, but it’s not efficient. If the result of the
    first `if` is true, the other `if` statements can’t be true, and yet they are
    tested. What we need is a test in which if it is true, we perform the appropriate
    action. If it is not true, we perform a different action. We have a word for this
    in English – it’s called “else”:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Python has an `elif` (else if) statement that allows multiple tests. We can
    use `elif` to perform another `if` if the result of the first `if` is false. Consider
    the preceding code using `elif`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the computer drops out of this construct as soon as one of the
    conditional tests is true. It does exactly the same as the preceding example using
    `if` statements, but it is more efficient because it terminates as soon as a condition
    is satisfied. That is, once any of the tests yields true, its associated action
    is carried out, and then control passes to the next statement after the `if …
    elif` sequence (in this case, `print`).
  prefs: []
  type: TYPE_NORMAL
- en: The great thing about programming is that there are many ways of doing the same
    thing. Suppose we know that a variable, *x*, is always in the range from 0 to
    10, and we want to know the value of *y* for each *x* (using the preceding algorithm).
    We can calculate the value of *y* as we did previously by using conditional statements
    and programming.
  prefs: []
  type: TYPE_NORMAL
- en: We can implement the algorithm without using an `if` statement by creating a
    *lookup table* that provides the value of *y* for any *x*. Let’s call this table
    `lookupY` and load it with the values of *y* for *x* inputs from 0 to 10\. *Table
    2.1* gives the value of *y* for each possible *x*.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Input x** | **Output y** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 2 |'
  prefs: []
  type: TYPE_TB
- en: Table 2.1 – Using a lookup table to perform a Boolean operation
  prefs: []
  type: TYPE_NORMAL
- en: 'We can code this `lookup` operation in Python in just two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: When we simulate a computer, we need to load programs to be simulated. The next
    section describes how we can read a source file (in text format) from memory into
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Reading data from a file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When testing an assembler or simulator, you need to enter the test data (the
    source program). This can be done in three ways.
  prefs: []
  type: TYPE_NORMAL
- en: Include the data in the program – for example, `myProg = ['add r1,r2', 'inc
    r1', '``beq 7']`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the text from the keyboard – for example, `myProg = input('Type` `program
    ')`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a text file in memory and read it from your program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two techniques are great for testing a very short program but less
    so for a long source program. The third technique means that you write your source
    code using your favorite text editor, save it as a `.txt` file, and then read
    that file in your assembler.
  prefs: []
  type: TYPE_NORMAL
- en: 'I often put the name of my test program in my assembler during development
    work to avoid typing the name (because I’m working on the same source file most
    of the time). Let’s suppose my file is called `c.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `myFile` variable provides the name of the source
    file as a string. Then, the `with open` operation opens and reads `myFile`. This
    operation also closes the file after use. The preceding code opens `c.txt` for
    reading and creates a new file, `sFile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `open` function can be used in three ways, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: It is good practice to close a file after you have used it, with `filename`.`close()`.
    Because the `with open` operation automatically closes a file at the end of an
    operation, it is not necessary to call the `close()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `readlines()` function operates on `sFile` to create a file, `newFile`,
    containing a list of the lines of my source code. The following fragment of code
    demonstrates reading a file from disk and cleaning up the end-of-line sequences
    in a text file. That’s because text files are stored with an `''\n''` sequence
    at the end of each line, and this sequence must be removed because it is not part
    of the source program. We will return to string processing later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output from this code. You can see how the *‘*`\n`*’*
    sequences have been removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We’ve provided enough information to demonstrate a short Python program that
    implements the simple sequence detector we described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Translating a token detector algorithm into Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can readily translate our pseudocode to detect a sequence of red tokens
    in a stream of read/write tokens as follows. In this fragment of Python, you are
    invited to enter first the number of red tokens to detect, and then `r` or `w`
    to indicate the color of each token. Once the appropriate number of tokens has
    been detected, the program terminates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this program for a sequence I entered was the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: A computer has three essential elements – an **arithmetic and logical unit**
    (**ALU**) that performs all arithmetic and logical operations on data, a memory
    that holds programs and data, and a control unit that reads the instructions from
    memory and executes them. In the next section, we will introduce some of the basic
    concepts of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Computer memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we are going to introduce the *concept of memory*, the mechanism that holds
    programs and data. Real or *physical* memory is implemented as DRAM, flash memory,
    and disk drives. This memory is part of a computer’s hardware. We do not cover
    physical memory in this book. Instead, we will discuss *abstract memory* and how
    it is modeled by Python. This is the programmer’s view of memory.
  prefs: []
  type: TYPE_NORMAL
- en: All data is stored in physical memory, and all the data structures designed
    by a programmer must be mapped onto physical memory. The mapping process is the
    job of the operating system, and this book does not deal with the translation
    of abstract memory addresses into real memory addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following Python list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: These three strings have the `[0]`, `[1]`, and `[2]` addresses in the `friends`
    list. The operating system maps these elements onto the physical memory storage
    locations. These strings each require a different number of physical memory locations
    because each one has a different length. Mercifully, computer users do not have
    to worry about any of that. That is the job of the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: We will now take a brief look at the concept of memory because you have to understand
    the nature of memory in order to understand how computers work, and how to write
    programs in assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: First, consider our own memories. Human memory is a strange and *inexact* thing.
    An *event* triggers the recall or *retrieval* of a data element that we call a
    *memory*. The event may be a question that someone asks you, or it may be something
    that *reminds* you of an episode that took place in the past. Often, we remember
    information only partially, or even incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: Human memory seems to be accessed by matching an event against stored information.
    That is, our memory is *associative* because we associate one memory with another.
    A computer’s memory operates in a very different way and is best thought of as
    a *table* or *list* of stored items. You need to know where an item is on the
    list (its address) in order to access it. We will soon meet a Python memory, which
    is associative and called a *dictionary*. You don’t access a dictionary with an
    address but, instead, with a *key* that is associated with the required data element.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.6* shows how a program to find the number of red tokens in a string
    of tokens is stored in a hypothetical memory. I must stress that the program is
    conceptual rather than actual because real computer instructions use rather more
    primitive machine-level instructions than these. This figure, called a *memory
    map*, shows the location of information within the memory. It’s a *snapshot* of
    the memory because it represents the state of the memory at a particular instant.
    The memory map also includes the *variables* used by the program and a string
    of digits. The stored program computer stores instructions, variables, and constants
    in the same memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.6* demonstrates that each location in the memory contains either
    an *instruction* or a *data element*. Numbers 0 to 23 in the first column are
    *addresses* that express the position of data elements and instructions within
    the memory (addresses start from 0 rather than 1 because 0 is a valid identifier).'
  prefs: []
  type: TYPE_NORMAL
- en: The program is in locations 0 to 8, the variables in locations 9, 10, and 11,
    and the data (the tokens) in locations 12 to 23\. You can regard the computer’s
    memory as a table of *items*, and the location of each item is its address – for
    example, memory location 1 contains the instruction `Set numRed to 0`, location
    10 contains the value of the `numRed` element, and location 11 contains the value
    of the current data element (`R` or `W`). Locations 12 onward are in bold font
    to indicate that they contain the values of the sequence of tokens we operate
    on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – The memory map](img/Figure_2.06_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – The memory map
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.6* is an abstract view of a computer’s memory for teaching purposes.
    Real memory is an array of locations, each of the same size (typically, 16, 32,
    or 64 bits). Individual instructions may occupy one, two, or more consecutive
    locations, depending on the actual size of the data.'
  prefs: []
  type: TYPE_NORMAL
- en: Although we will not describe physical memory in any detail, a few comments
    will help to distinguish it from abstract memory. *Figure 2**.7* illustrates the
    organization of actual computer *memory* (e.g., DRAM). The processor provides
    memory with an address on the *address bus* and a control signal that selects
    either a *read* or a *write* cycle. In a *read cycle*, the memory puts data onto
    the *data bus* for the CPU to read. In a *write* *cycle*, data from the CPU is
    stored in the memory. Information enters or leaves memory (or any other functional
    part of a computer system) via a port. A real computer has a hierarchy of memory
    systems implemented with different technologies – for example, DRAM for main memory,
    SSD for the much slower secondary storage, and high-speed cache for frequently
    used data and instructions. In this book, we deal with only abstract memory implemented
    in Python and not real physical memory. The job of the operating system is to
    integrate the abstract memory addresses used by the programmer with the real physical
    addresses of data in memory.
  prefs: []
  type: TYPE_NORMAL
- en: A computer’s main store is composed of high-speed **random-access memory** (**RAM**)
    that can be written to or read from. It is invariably composed of *dynamic* semiconductor
    memory, DRAM (today, it’s DDR4 and DDR5 technology), and the size of a typical
    PC’s RAM generally ranges from 4 GB for tablets to 64 GB for high-performance
    systems. RAM is volatile, which means that its data is lost when you switch it
    off (in comparison with flash memory, which retains data).
  prefs: []
  type: TYPE_NORMAL
- en: The term *dynamic* in the DRAM acronym describes its storage mechanism (as a
    charge on a capacitor, which leaks away and has to be periodically written back).
    From a user’s point of view, DRAM provides very cheap, large-volume storage. From
    a designer’s point of view, DRAM poses particular design problems because of its
    operating characteristics. An alternative to DRAM is **static RAM** (**SRAM**),
    which is easier to use and faster than DRAM but is far more expensive, preventing
    its use in PCs, except for special applications such as cache memory. Cache memory
    is a special high-speed memory that contains frequently used data.
  prefs: []
  type: TYPE_NORMAL
- en: Secondary (physical) storage is a **hard disk drive** (**HDD**) or **solid-state
    drive** (**SSD**). Both these store large quantities of data and are far slower
    than the DRAM of the main store. Computers do not directly access the secondary
    store. The operating system transfers data, a page at a time, from the SSD/HDD
    to a computer’s main store. This is invisible to the user.
  prefs: []
  type: TYPE_NORMAL
- en: The next step in describing abstract memory is to introduce a notation, called
    RTL, which is often employed to describe or define memory transactions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – The memory system](img/Figure_2.07_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – The memory system
  prefs: []
  type: TYPE_NORMAL
- en: Register transfer language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Describing computer operations in words is often cumbersome. Here, we will introduce
    **register transfer language** (**RTL**), which makes it easy to define computer
    operations. RTL is neither an assembly language nor a programming language. It
    is a notation.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to distinguish between a memory *location* and its *contents*.
    Register transfer language uses square brackets, `[ ]`, to indicate the *contents*
    of a memory location. The expression `[15] = maxRed` is interpreted as *the contents
    of memory location 15 contain the value of maxRed*. If we wish to give the memory
    a name, we can write, for example, `dram[15]` rather than just `[15]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ← symbol indicates a *data transfer*. For example, the expression [15]
    ← [15] `+ 1` is interpreted as *the contents of memory location 15 are increased
    by 1 and the result is put back in memory location 15*. Consider the following
    RTL expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Expression (a) states that the contents of memory location 20 are equal to the
    number 5\. Expression (b) states that the number 6 is put into (*copied* or *loaded*
    into) memory location 20\. Expression (c) indicates that the contents of memory
    location 6 are copied into memory location 20.
  prefs: []
  type: TYPE_NORMAL
- en: Expression (d) indicates that 4 is added to the contents of location 3, and
    the sum is put in location 12\. Expression (e) indicates that the sum of the contents
    of locations 7 and 8 are added and put in location 19.
  prefs: []
  type: TYPE_NORMAL
- en: Expression (f) indicates that the contents of location 2 are used to access
    memory to read a value, which is an address. The contents of that second address
    are put in location 4\. This expression is the most interesting because it introduces
    the notion of a *pointer*. The value of memory location 2, `[2]`, is a pointer
    that indicates (points to) another memory location. If we perform `[2] ← [2] +
    1`, the pointer now points to the next location in memory. We will return to this
    when we discuss indirect addressing (also called pointer-based addressing or indexed
    addressing).
  prefs: []
  type: TYPE_NORMAL
- en: The “←” RTL symbol is equivalent to the conventional assignment symbol, “=”,
    used in some high-level languages. RTL is not a computer language; it is a notation
    used to define computer operations.
  prefs: []
  type: TYPE_NORMAL
- en: Nested square brackets such as `[[4]]` indicate the contents of the memory location,
    whose address is given by the contents of memory location 4\. This is called indirect
    addressing. Figure 2.8 demonstrates how location 4 points at location 12, which
    contains the value of the required data – that is, 9.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Pointer-based addressing](img/Figure_2.08_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Pointer-based addressing
  prefs: []
  type: TYPE_NORMAL
- en: An example of the use of RTL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s look at an example of the way that RTL can be used. *Figure 2**.9* illustrates
    a small abstract memory with 12 locations.
  prefs: []
  type: TYPE_NORMAL
- en: '| Address | Data |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | 5 |'
  prefs: []
  type: TYPE_TB
- en: Figure 2.9 – An example of the memory map of an abstract memory
  prefs: []
  type: TYPE_NORMAL
- en: 'We wish to evaluate the expression `X = 3 + [4] + [1+[3]] + [[10]] + [[9]*3]`.
    This expression can be evaluated by summing its components, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first element in the sequence is the literal 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expression [4] represents the contents of memory location 4 – that is, 5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expression [1+[3]] represents [1 + 4] = [5] = 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expression [[10]] represents [1], which is 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expression [[9]*3] represents [2*3] = [6] = 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final value is 3 + 5 + 2 + 2 + 8 = 20.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to simulate abstract memory in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating memory in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now demonstrate how computer memory can be simulated in a Python program.
    To simulate a computer’s main memory (the immediate access store, often called
    DRAM), we just create a Python list. A typical PC has over 4G memory locations
    (222). Here, we will create tiny memories that are easy to simulate. If we call
    the memory `mem`, we can create a memory with eight locations and initialize them
    to zero with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This initialization mechanism is inconvenient if you have much larger memory.
    If so, you can use a Python facility that lets you create a list and fill it with
    identical elements. Let’s consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate simple operations on the memory, we’ll load two numbers into
    the simulated memory, retrieve them, add them, and store the result in memory
    using RTL notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We can translate this into Python and print the contents of location 6 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Python is remarkably close to RTL notation. Now, let’s use data
    in memory as a pointer. Recall that a pointer is a value that points to another
    location in memory. *Figure 2**.10* shows an eight-location memory map with five
    integers stored in the memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – A memory map of an addition operation](img/Figure_2.09_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – A memory map of an addition operation
  prefs: []
  type: TYPE_NORMAL
- en: 'We will perform the following operation, first in RTL and then in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if we use the simplified RTL where “`mem`” is understood, we
    can write this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This operation adds the contents of the memory location pointed at by the contents
    of location 1 to the contents of the memory location pointed at by the contents
    of memory location 2, putting the result in the contents of the memory location
    pointed at by memory location 0\. We can express this in Python as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This program will print the contents of memory as Memory `= [7, 5, 4, 0, 3,
    9, 0, 12].` As you can see, memory location 7 has changed from its initial value
    of 0 to the value 12 – that is, the sum of the contents of memory locations 5
    and 4.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main themes of this book is writing a program to simulate a computer
    so that you can run programs on a computer you designed yourself. To do this,
    it is necessary to write a simulator in a suitable high-level language. We chose
    Python because of its availability, simplicity, and power.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has provided a brief overview of Python by introducing the data
    structures and flow-control features you need to design a computer simulator.
    We have covered the basics of Python in sufficient detail for you to follow simple
    programs that don’t use any of Python’s more esoteric features.
  prefs: []
  type: TYPE_NORMAL
- en: Two important and very fundamental features of Python are the string (which
    is important, as simulation involves text processing) and the list. The list is
    simply a sequence of elements separated by commas and enclosed by square brackets.
    What is special about Python’s lists is that the elements can be any data elements,
    and they are easy to access – for example, element 10 of list `x` is simply `x[10]`.
    Equally, character 5 of string `x = 'a test'` and is expressed as `[5]` and is
    `'i'`. Like all computer languages, Python numbers elements from 0.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at the function, a piece of code that can be called from anywhere
    in a program to carry out some operation. You don’t need functions. However, if
    you do the same thing often, calling a chunk of code to do the job makes the program
    easier to read and debug.
  prefs: []
  type: TYPE_NORMAL
- en: We demonstrated a very simple Python program to simulate memory and took our
    first step on the way to a simulator.
  prefs: []
  type: TYPE_NORMAL
- en: However, Python’s strength (simplicity) is also a weakness. More complex languages
    ensure correctness by providing strict rules – for example, strong typing where
    you must declare the type of each variable and then use it accordingly. A very
    common Python pitfall is wrong indenting. Code in a loop or `if` construct is
    indented to show it belongs to whatever construct guards it. If you make a mistake
    with indenting while editing a program, it will either crash or behave very differently
    from what you intended.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B19624_03.xhtml#_idTextAnchor042), we look at the basic structure
    of a **central processing unit** (**CPU**) and demonstrate how an instruction
    is read from memory, decoded, and executed.
  prefs: []
  type: TYPE_NORMAL
