- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: High-Speed Introduction to Python
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高速 Python 简介
- en: This chapter introduces Python and demonstrates how to write a program in Python
    to solve the type of problem we described in [*Chapter 1*](B19624_01.xhtml#_idTextAnchor015).
    We are not going to delve deeply into Python in this chapter, but we will cover
    Python sufficiently to enable you to simulate and modify a computer to incorporate
    your own ideas.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 Python，并演示了如何编写 Python 程序来解决我们在 [*第 1 章*](B19624_01.xhtml#_idTextAnchor015)
    中描述的问题类型。在本章中，我们不会深入探讨 Python，但我们会足够地介绍 Python，以便您能够模拟和修改计算机以融入您自己的想法。
- en: Traditionally, a computer program has been compared to a cookery recipe because
    they are analogous. Strictly speaking, this statement applies only to procedural
    languages such as Python, Java, and C. Functional languages such as Lisp do not
    conform to this strictly sequential paradigm and are beyond the scope of this
    text
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，计算机程序被比作烹饪菜谱，因为它们是相似的。严格来说，这个陈述只适用于像 Python、Java 和 C 这样的过程式语言。像 Lisp 这样的函数式语言不符合这种严格的顺序范式，并且超出了本文的范围。
- en: A recipe is a sequence of *operations* (i.e., actions or steps) that are carried
    out *in order* on the *ingredients* used by the recipe. A program is the same;
    it is a sequence of operations (instructions) that are carried out, in order,
    on data. The instructions of a program are carried out, one by one, sequentially,
    from top to bottom, arranged exactly like a page of printed text. It’s also possible
    to repeat a group or block of instructions several times, and you can even skip
    past or ignore blocks of instructions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 菜谱是一系列 *操作*（即动作或步骤）的序列，按照顺序在菜谱中使用的 *原料* 上执行。程序也是如此；它是一系列按照顺序执行的操作（指令）的序列。程序中的指令是按顺序、从上到下逐个执行的，排列得就像一页打印文本。也可以重复执行一组或指令块多次，甚至可以跳过或忽略指令块。
- en: The analogy between a recipe and a program is surprisingly accurate. In a recipe,
    you can have *conditional* instructions such as, “*If the sauce is too thick,
    then add more water.*” In programming, you can have conditional instructions such
    as, “*If x is 0, then add 1 to y.*” Similarly, in cooking, you can express repetitive
    action by expressions such as, “*Beat the mixture until stiff.*” In computing,
    repetition can be expressed using constructs such as, “*Subtract 1 from z until
    z =* *0.*”
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 菜谱和程序之间的类比惊人地准确。在菜谱中，您可以有 *条件* 指令，例如，“*如果酱太稠，则添加更多水。*” 在编程中，您可以有条件指令，例如，“*如果
    x 为 0，则将 1 加到 y 上。*” 同样，在烹饪中，您可以通过表达式如，“*搅拌混合物直到变硬。*” 来表达重复动作。在计算中，重复可以通过如，“*从
    z 中减去 1，直到 z =* *0。*” 这样的结构来表示。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Reading programs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读程序
- en: Getting started with Python
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 入门
- en: Python’s data types
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 的数据类型
- en: Mathematical operators
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学运算符
- en: Names, values, and variables
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称、值和变量
- en: Comments
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释
- en: The list – a Python key data structure
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表 - Python 的一种关键数据结构
- en: Functions in Python
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 中的函数
- en: Conditional operations and decision-making
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件操作和决策
- en: Reading data from a file
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件中读取数据
- en: Translating a token detector algorithm into Python
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将令牌检测算法转换为 Python
- en: Computer memory
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机内存
- en: Register transfer language
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器传输语言
- en: Technical requirements
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the programs used in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter02](https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter02).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章使用的程序，链接为 [https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter02](https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter02)。
- en: The requirements to write a program in Python and run it are minimal. Python
    is an open source language and is freely available for the PC, Mac, and Linux
    platforms. All the information you need to set up a Python environment on your
    computer system can be found on the home page at [https://www.python.org](https://www.python.org).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 Python 程序并运行它的要求非常少。Python 是一种开源语言，可以在 PC、Mac 和 Linux 平台上免费使用。您需要设置计算机系统上的
    Python 环境的所有信息都可以在主页 [https://www.python.org](https://www.python.org) 上找到。
- en: Remarkably, you do not need any other software to construct a computer simulator
    in Python. The Python package comes with Python’s **Integrated Learning and Development
    Environment** (**IDLE**) that lets you edit a Python program, save it, run it,
    and debug it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，您不需要任何其他软件就可以在 Python 中构建计算机模拟器。Python 包自带 Python 的 **集成学习与开发环境**（**IDLE**），它允许您编辑
    Python 程序、保存它、运行它和调试它。
- en: There are alternatives to IDLE that let you create Python source files supported
    by Python platforms. These alternatives are generally more sophisticated and targeted
    at the professional developer. For the purposes of this chapter, IDLE is more
    than sufficient, and nearly all the Python programs in this text were developed
    with IDLE.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 IDLE，还有其他替代方案可以让您创建受 Python 平台支持的 Python 源文件。这些替代方案通常更复杂，针对的是专业开发者。在本章中，IDLE
    已经足够使用，而且本书中的几乎所有 Python 程序都是使用 IDLE 开发的。
- en: 'Alternative IDEs are Microsoft’s Visual Studio Code, Thonny, and Geany. All
    these IDEs are freely available. Thonny was developed for the Raspberry Pi, which
    we will use in later chapters:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 替代 IDE 包括微软的 Visual Studio Code、Thonny 和 Geany。所有这些 IDE 都是免费提供的。Thonny 是为 Raspberry
    Pi 开发的，我们将在后续章节中使用它：
- en: Visual Studio Code:[https://code.visualstudio.com/download](https://code.visualstudio.com/download)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code:[https://code.visualstudio.com/download](https://code.visualstudio.com/download)
- en: Geany:[https://www.geany.org/](https://www.geany.org/)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Geany:[https://www.geany.org/](https://www.geany.org/)
- en: Thonny:[https://thonny.org](https://thonny.org)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Thonny:[https://thonny.org](https://thonny.org)
- en: Reading programs is not easy for the beginner because you don’t know how to
    interpret what you see. The following section describes some of the typography
    and layout conventions we will use in this chapter to make the meaning of programs
    more clear and to highlight the features of a program.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学者来说，阅读程序并不容易，因为你不知道如何解释你所看到的内容。以下部分将描述我们在本章中将要使用的一些排版和布局约定，以使程序的意义更加清晰，并突出程序的特点。
- en: Reading programs
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读程序
- en: In order to help you follow the programs, we have adopted two different type
    fonts – a variable-width font (where letters have different widths, such as the
    bulk of the text here) and a mono-spaced font, such as the Courier font found
    on old mechanical typewriters `that looks` `like this`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您跟踪程序，我们采用了两种不同的字体——一种变宽字体（其中字母有不同的宽度，如这里的大部分文本）和一种单倍间距字体，如旧式机械打字机上的 Courier
    字体 `看起来` `像这样`。
- en: 'The reason for using a mono-spaced font to represent code is twofold. First,
    it tells the reader that a word is computer code and not just part of the narrative
    text. Second, spacing in computer programs is important for readability, and mono-spaced
    fonts line up letters and numbers on adjacent rows neatly in columns. The following
    is an example of code from a later chapter to demonstrate this point. The proportionally-spaced
    text to the right, prefixed by #, indicates that the text is not code but a plain-language
    comment:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '使用单倍间距字体表示代码的原因有两个。首先，它告诉读者这个词是计算机代码，而不仅仅是叙述文本的一部分。其次，在计算机程序中，间距对于可读性很重要，单倍间距字体能够整齐地排列相邻行中的字母和数字，形成列。以下是从后续章节中摘取的代码示例，以说明这一点。右侧带有
    # 前缀的按比例间距文本表示该文本不是代码，而是一段普通语言的注释：'
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We have occasionally used shading or a bold font to distinguish one feature
    of a piece of code from another.For example, `x = y.`split('.') uses a bold font
    to emphasize the `split` function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们偶尔会使用阴影或粗体字体来区分代码片段的不同功能。例如，`x = y.`split('.') 使用粗体字体来强调 `split` 函数。
- en: 'Consider the following example. The gray text indicates reserved words and
    symbols in Python that are necessary to specify this construct. The numbers in
    bold black are values supplied by the programmer. The text following # is in a
    non-monospaced font and is a comment ignored by the computer:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例。灰色文本表示 Python 中必要的保留词和符号，用于指定此结构。粗体黑体中的数字是程序员提供的值。# 后面的文本使用非单倍间距字体，是计算机忽略的注释：
- en: for i in range (0`,`6):# Repeat six times
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: for i in range (0,6):# 重复六次
- en: In this example, we use shading to emphasize a feature – for example, `rS1 =
    int(inst`[2][1]`)`draws your attention to the first parameter, `[2]`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用阴影来强调一个功能——例如，`rS1 = int(inst[2][1])` 将你的注意力引向第一个参数 `[2]`。
- en: Getting started with Python
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 入门
- en: Before we look at Python in more detail, we will provide a brief introduction
    to getting started with Python and demonstrate a short program. Although we have
    not even introduced the basics of the language, Python programs are remarkably
    easy to follow.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更详细地了解Python之前，我们将简要介绍如何开始使用Python，并演示一个简短的程序。尽管我们还没有介绍语言的基础，Python程序却非常容易理解。
- en: Python is a computer language such as C or Java and, like every computer language,
    it has its advantages and disadvantages. We have chosen to use Python because
    it is free and universal, there’s a vast amount of information about it, and,
    most importantly, it has a very shallow learning curve. Indeed, Python has become
    one of the most popular languages used in computer science education.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种类似于C或Java的计算机语言，就像每一种计算机语言一样，它都有其优点和缺点。我们选择使用Python，因为它免费且通用，有关它的信息量很大，最重要的是，它的学习曲线非常平缓。实际上，Python已经成为计算机科学教育中最受欢迎的语言之一。
- en: Python was conceived by the Dutch computer scientist Guido van Rossum, and the
    stable Python 2.0 was released in 2000\. Today, Python is promoted by the Python
    Software Foundation, a body of volunteers whose aim is to develop the language
    as a public service.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Python是由荷兰计算机科学家Guido van Rossum构思的，稳定的Python 2.0版本于2000年发布。今天，Python由Python软件基金会推广，这是一个志愿者的组织，其目标是将其作为公共服务来发展语言。
- en: The high-level language programs in this text were written in Python on a PC.
    To install Python, you need to go to its home page at [https://www.python.org](https://www.python.org)
    and follow the instructions. There are several versions of Python because it is
    continually growing. The two main branches are Python 2 and Python 3; I will be
    using the latter. Python is continually updated and new versions are introduced.
    I started with Python 3.6, and at the time of writing, we’re up to Python 3.11\.
    However, new incremental versions do not offer radical changes, and many of the
    new features are not used by the Python version in this book.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 文本中的高级语言程序是在PC上用Python编写的。要安装Python，您需要访问其主页[https://www.python.org](https://www.python.org)并遵循说明。由于Python不断增长，因此有多个版本。两个主要分支是Python
    2和Python 3；我将使用后者。Python不断更新，并引入了新版本。我最初使用Python 3.6，在撰写本文时，我们已达到Python 3.11。然而，新的增量版本并没有带来根本性的变化，而且许多新特性在本书的Python版本中并未使用。
- en: Loading the Python packages provides you with a Python documentation library,
    a Python interpreter, and a Python editor called the IDLE. All this is freely
    available. IDLE allows you to perform a cycle, *edit a program, run it, and debug
    it* until you are happy with the result. I also used the freely available Thonny
    IDE, which I found even easier to use. Using an IDE lets you develop a program,
    run it, and then modify it, without having to switch between separate editors,
    compilers, and runtime environments.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 加载Python包为您提供了Python文档库、Python解释器和名为IDLE的Python编辑器。所有这些都是免费提供的。IDLE允许您进行一个循环，*编辑程序、运行它并进行调试*，直到您对结果满意。我还使用了免费提供的Thonny
    IDE，我发现它甚至更容易使用。使用IDE可以让您开发程序、运行它，然后修改它，而无需在单独的编辑器、编译器和运行时环境之间切换。
- en: Late in the writing of this book, Graeme Harker introduced me to **Visual Studio
    Code** (**VS Code**). This is a popular integrated development system developed
    by Microsoft that supports several languages, including Python, and which runs
    on several platforms, including Windows, Linux, and macOS. VS Code is a very powerful
    IDE indeed and includes facilities that go beyond those of IDLE.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书写作的后期，Graeme Harker向我介绍了**Visual Studio Code**（**VS Code**）。这是一个由微软开发的流行的集成开发系统，支持包括Python在内的多种语言，并在包括Windows、Linux和macOS在内的多个平台上运行。VS
    Code确实是一个非常强大的IDE，并包括超越IDLE的功能。
- en: Consider the example of an IDE (in this case, IDLE) in *Figure 2**.1*. Suppose
    we want to create a four-function calculator that performs simple operations such
    as 23 x 46 or 58 - 32\. I’ve chosen this example because it is really a very simple
    computer simulator. *Figure 2**.1* is a screenshot taken after a Python program
    has been loaded using the `file` function. You can also directly enter a Python
    program from the keyboard.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到*图2**.1*中的IDE（在这种情况下，IDLE）的例子。假设我们想要创建一个四功能计算器，它可以执行简单的运算，如23 x 46或58 - 32。我选择这个例子，因为它实际上是一个非常简单的计算机模拟器。*图2**.1*是在使用`file`函数加载Python程序后所截取的屏幕截图。您也可以直接从键盘输入Python程序。
- en: If we click on `+`, `-`, `/`, or `*`, it terminates the execution and prints
    a message.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击`+`、`-`、`/`或`*`，它将终止执行并打印一条消息。
- en: 'Like most high-performance IDE systems, IDLE uses color to help you to read
    a program. Python lets you add a commentary to the program because code is not
    always understandable. Any text following a # symbol is ignored. In this case,
    the code is understandable, and these comments are not necessary.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '与大多数高性能 IDE 系统一样，IDLE 使用颜色来帮助你阅读程序。Python 允许你在程序中添加注释，因为代码并不总是容易理解。任何跟随 # 符号的文本都会被忽略。在这种情况下，代码是可理解的，这些注释是不必要的。'
- en: You have to save a program before you can run it. Saving a program from `IDLE`
    automatically appends `.py`, so that a file named `calc1` is saved as `calc1.py`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行程序之前，你必须保存它。从 `IDLE` 保存程序会自动追加 `.py` 扩展名，因此名为 `calc1` 的文件将被保存为 `calc1.py`。
- en: '![Figure 2.1 – A screenshot of a Python program in IDLE](img/Figure_2.01_B19624.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 —— IDLE 中 Python 程序的截图](img/Figure_2.01_B19624.jpg)'
- en: Figure 2.1 – A screenshot of a Python program in IDLE
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 —— IDLE 中 Python 程序的截图
- en: '*Figure 2**.1* shows the layout of Python programming, including the all-important
    *indentation*, which is a key feature of Python and indicates which operations
    belong to a particular command.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2.1* 展示了 Python 编程的布局，包括至关重要的 *缩进*，这是 Python 的一个关键特性，它指示哪些操作属于特定的命令。'
- en: Here’s a brief description of the program. We will cover this material in greater
    detail later. `while` heads a group of indented instructions that are repeated
    until some condition stops being true. In this case, the instructions are executed
    as long as the `go` variable is `1`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个程序的简要描述。我们将在稍后更详细地介绍这些内容。`while` 关键字引导一组缩进的指令，这些指令会一直重复执行，直到某个条件不再为真。在这种情况下，只要
    `go` 变量是 `1`，指令就会执行。
- en: The `if` statement defines one or more operations that are executed if `if`
    is true. In this case, if the input is `'E'`, the `go` variable is set to `0`,
    and the indented operations after `while` are no longer executed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句定义了一个或多个在 `if` 为真时执行的运算。在这种情况下，如果输入是 `''E''`，则 `go` 变量被设置为 `0`，并且 `while`
    后面的缩进操作不再执行。'
- en: The `break` instruction breaks out of the `while` loop (that is, execution continues
    beyond the end of the loop – it’s a sort of short-circuit mechanism).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` 指令会跳出 `while` 循环（即，执行会继续到循环的末尾——它是一种短路机制）。'
- en: Finally, the `int(x)` function converts a keyboard character into an integer
    – for example, `int('27')` converts the two keys, `2` and `7`, into the integer,
    `27`. We will discuss all this in greater detail later.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`int(x)` 函数将键盘字符转换为整数——例如，`int('27')` 将两个键，`2` 和 `7`，转换为整数 `27`。我们将在稍后更详细地讨论这些内容。
- en: 'To run the program, you select the `F5`. The following demonstrates the effect
    of running this program. The text in bold is the text I entered using the keyboard:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行程序，你选择 `F5` 键。以下演示了运行此程序的效果。粗体的文本是我使用键盘输入的：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The purpose of this brief demonstration is to show how a Python program is entered
    and executed. In practice, no programmer would write the preceding code. It is
    inefficient. It does not deal with errors (what happens if you type `@` instead
    of `*`, or `$` instead of `4?`). Even worse, to stop the program, you have to
    enter a dummy number before entering `E` to end the program. I leave it as an
    exercise for you to convert this program into a version that is more user-friendly.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短演示的目的是展示如何输入和执行 Python 程序。实际上，没有程序员会编写前面的代码。这是低效的。它没有处理错误（如果你输入 `@` 而不是
    `*`，或者 `$` 而不是 `4` 会发生什么？）。更糟糕的是，为了停止程序，你必须在输入 `E` 结束程序之前输入一个虚拟数字。我将这个任务留给你，将这个程序转换为更用户友好的版本。
- en: We’ve demonstrated a trivial Python program. The next step is to introduce the
    data with which Python operates – that is, we show how Python handles numbers
    and text.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经演示了一个简单的 Python 程序。下一步是介绍 Python 操作的数据——也就是说，我们展示 Python 如何处理数字和文本。
- en: Python’s data types
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 的数据类型
- en: 'A recipe uses *ingredients* that fall into distinct groups (fruit, vegetables,
    nuts, cheeses, spices, etc.). A computer program uses data that falls into groups
    called *types*. Some of the main data types used by Python are as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一个食谱使用的是属于不同组分的 *原料*（水果、蔬菜、坚果、奶酪、香料等）。计算机程序使用的是称为 *类型* 的数据。Python 使用的某些主要数据类型如下：
- en: '**Integer**: This uses whole numbers, such as 0, 1, 2, and so on. Integers
    also include negative numbers -1, -2, -3, and so on. Positive integers are also
    known as natural numbers.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整数**：这使用的是整数，例如 0、1、2 等等。整数还包括负数 -1、-2、-3 等等。正整数也被称为自然数。'
- en: '**Float**: These are numbers with a decimal point (e.g., 23.5 and -0.87). These
    are also called *real* numbers. Surprisingly, we will not be using real numbers
    in this text.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浮点数**：这些是带有小数点的数字（例如，23.5和-0.87）。这些也被称为*实数*。令人惊讶的是，我们在这篇文本中不会使用实数。'
- en: '**Character**: A character is one of the keys on a computer keyboard – for
    example, *Q*, *Z*, *a*, *$*, and *@*. Computer languages often indicate a character
    by putting it in inverted commas – for example, ''R''. In practice, Python does
    not have an explicit character type.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符**：字符是计算机键盘上的一个键——例如，*Q*、*Z*、*a*、*$*和*@*。计算机语言通常通过将字符放在引号中来表示它——例如，`''R''`。实际上，Python没有显式的字符类型。'
- en: '`''This''` or `''my program''`. Python doesn’t have a character type because
    it treats a character as a string of length 1\. Python allows you to use single
    or double quotes interchangeably – for example, `x = ''this''` and `x = "this"`
    are identical in Python. This mechanism allows you to type x = ''''The boy’s books''''
    (i.e., you can use an apostrophe without it being treated as a quotation mark).
    In computing, the term *string* is rather like the English term *word*. A string
    is any sequence of characters – for example, `''time''` and `''!££??''` are legal
    Python strings. Recall that a string of length 1 is a single character – for example,
    ''Q''. You can have a string of length zero – that is,''''. Here, you have two
    quotation marks with nothing in between. This indicates an empty string.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''This''`或`''my program''`。Python没有字符类型，因为它将字符视为长度为1的字符串。Python允许你单引号或双引号互换使用——例如，`x
    = ''this''`和`x = "this"`在Python中是相同的。这种机制允许你输入`x = ''''The boy’s books''''`（即，你可以使用撇号而不会被当作引号处理）。在计算机科学中，术语*字符串*类似于英语中的*单词*。字符串是任何字符序列——例如，`''time''`和`''!££??''`是合法的Python字符串。回想一下，长度为1的字符串是一个单个字符——例如，`''Q''`。你可以有一个长度为零的字符串——也就是说，`''''`。这里，你有两个引号之间没有任何内容。这表示一个空字符串。'
- en: '`True` and `False`. The bool type is used in Boolean logic expressions. It
    is also used in comparisons – for example, the English expression, “Is *x* greater
    than *y*?” has two possible outcomes – True or False. If you type `print(5 ==
    5)` in Python, it will print True because the == means “*is the same as?*” and
    the result is True.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`True`和`False`。布尔类型用于布尔逻辑表达式。它也用于比较——例如，英语表达式，“*x*是否大于*y*？”有两个可能的结果——True或False。如果你在Python中输入`print(5
    == 5)`，它将打印True，因为`==`意味着“*是否相同？*”，结果是True。'
- en: Each data element used in a program is given a *name* so that we can access
    it. The programmer chooses names for variables, and a good programmer chooses
    sensible names that indicate what the variable is. No one calls a variable `qZz3yT`.
    Names must begin with a letter, and then they may have any sequence of letters
    and numbers – for example, `alan`, `alan123`, and `a123lan` are legal Python names,
    whereas `2Alan` or `Al@n` is not legal. However, the underscore may be used in
    a name – for example, `time_one`. By convention, Python uses lowercase for the
    first character of variables and function names. Uppercase first letters are reserved
    for class names (which we will not use in this text). This restriction is a programming
    convention – that is, an error will not occur if you give a variable a name beginning
    with an uppercase letter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中使用的每个数据元素都会被赋予一个*名称*，这样我们就可以访问它。程序员为变量选择名称，一个好的程序员会选择有意义的名称来表示变量的含义。没有人会称一个变量为`qZz3yT`。名称必须以字母开头，然后可以跟任何字母和数字的序列——例如，`alan`、`alan123`和`a123lan`是合法的Python名称，而`2Alan`或`Al@n`则不是合法的。然而，名称中可以使用下划线——例如，`time_one`。按照惯例，Python使用小写字母作为变量和函数名称的第一个字符。大写字母开头保留用于类名称（在本文本中我们将不会使用）。这种限制是一种编程约定——也就是说，如果你给变量起一个以大写字母开头的名称，不会发生错误。
- en: Now that we’ve introduced data elements, we next describe some of the operations
    you can apply to numeric data. These are essentially the arithmetic operators
    we encountered in high school, except for division, which has three variations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了数据元素，接下来我们将描述一些可以应用于数值数据的操作。这些操作本质上是我们高中时遇到的算术运算符，除了除法，它有三种变体。
- en: Mathematical operators
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学运算符
- en: 'Computers can perform the four standard arithmetic operations – addition, subtraction,
    multiplication, and division. For example, we can write the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机可以执行四种标准的算术运算——加法、减法、乘法和除法。例如，我们可以写出以下内容：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The symbol for multiplication is *** (the asterisk) and not the conventional
    *x*. Using the letter *x* to indicate multiplication would lead to confusion between
    the letter *x* and *x* as a multiplication operator.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 乘号的符号是***（星号）*，而不是传统的*x*。使用字母*x*来表示乘法会导致字母*x*和乘法运算符*x*之间的混淆。
- en: Division is more complicated than multiplication because there are three ways
    of expressing the result of x ÷ y. For example, 15/5 is 3, and the result is an
    integer. 17/5 can be expressed in two ways – as a fractional value (i.e., a float)
    3.4, or as 3 remainder 2\. In Python, the division operator provides a float result
    if the result is not an integer (e.g., 100/8 = 12.5).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 除法比乘法更复杂，因为表达 x ÷ y 的结果有三种方式。例如，15/5 等于 3，结果是一个整数。17/5 可以有两种表达方式——作为一个分数值（即浮点数）3.4，或者作为
    3 余 2。在 Python 中，如果结果不是整数，除法运算符会提供一个浮点数结果（例如，100/8 = 12.5）。
- en: As well as the division operator, /, Python has two other division operators
    – `//` and `%`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了除法运算符 / 之外，Python 还有两个其他除法运算符——`//` 和 `%`。
- en: Python’s `//` is a *floor integer* divide that generates an integer result by
    rounding down to the nearest integer. For example, the operation `x = 17//5` gives
    the result `3` and the fractional part (the remainder) is discarded. Note that
    `x = 19//5` gives the result `3` because it *rounds down*, even though 4 is the
    closest integer. If you were to execute `x = -19//5`, that would give the result
    `-4` because it rounds *down* to the closest integer.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `//` 是一个*地板整数*除法，通过向下取整生成一个整数结果。例如，操作 `x = 17//5` 得到的结果是 `3`，小数部分（余数）被舍弃。注意，`x
    = 19//5` 得到的结果是 `3`，因为它*向下取整*，尽管 4 是最接近的整数。如果你执行 `x = -19//5`，那么结果将是 `-4`，因为它*向下取整*到最接近的整数。
- en: The % symbol is the *modulus* operator and provides the remainder after division.
    For example, `x = 17%5` gives the result `2`. Suppose, on Monday, someone said
    they were visiting you in 425 days. What day of the week is that? 425%7 is 5,
    which indicates Saturday. We can use % to test whether a number is odd or even.
    If you write `y = x%2`, then `y` is `0` if the number is even and `1` if it is
    odd.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '% 符号是*模数*运算符，提供除法后的余数。例如，`x = 17%5` 得到的结果是 `2`。假设，周一有人说他将在 425 天后拜访你。那将是星期几？425%7
    是 5，这表示星期六。我们可以使用 % 来测试一个数字是奇数还是偶数。如果你写 `y = x%2`，那么如果数字是偶数，`y` 是 `0`，如果是奇数，`y`
    是 `1`。'
- en: Names, values, and variables
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 名称、值和变量
- en: Computers store data in their memory. Each data element has two values associated
    with it – **where** it is, and **what** it is. In computer terms, *where* corresponds
    to the location (address) of the data in memory, and *what* corresponds to the
    value of that data. This is not rocket science, and matches everyday life – for
    example, I might have a bank account numbered 111023024 containing $890\. Here,
    111023024 is the “where,” and the $890 is the “what.”
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机在它们的内存中存储数据。每个数据元素都与两个值相关联——**它在哪**，以及**它是什么**。在计算机术语中，“在哪”对应于数据在内存中的位置（地址），而“它是什么”对应于该数据的值。这并不是什么火箭科学，这与日常生活相符——例如，我可能有一个账号编号为
    111023024，里面有 890 美元。在这里，111023024 是“在哪”，而 890 美元是“它是什么”。
- en: Now, suppose I write 111023024 + 1\. What exactly do I mean? Do I mean to add
    1 to the account number to get 111023025 (which is a different account), or do
    I mean to add $1 to the number in this account numbered 111023024 to get $891?
    In everyday life, this is something that’s so obvious we just don’t think about
    it. In computing, we have to be a little more careful and think clearly about
    what we are doing.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我写 111023024 + 1。我究竟是什么意思？我是想将 1 加到账号编号上得到 111023025（这是一个不同的账号），还是想将 1
    美元加到编号为 111023024 的这个账号中，得到 891 美元？在日常生活中，这是如此明显，以至于我们甚至没有考虑过。在计算机中，我们必须更加小心，并清楚地思考我们在做什么。
- en: 'Data elements are called **variables** because their values can be changed.
    A variable has an address (location) in memory. A programmer doesn’t have to worry
    about the actual location of data; the operating system takes care of that for
    them automatically. All they have to do is to come up with a name for the variable.
    For example, let’s take the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 数据元素被称为**变量**，因为它们的值可以改变。变量在内存中有一个地址（位置）。程序员不必担心数据的实际位置；操作系统会自动为他们处理。他们只需要为变量想一个名字。例如，让我们看看以下：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When you write this, you define a new variable that you’ve called `totalPopulation`
    and have told the computer to store the number `8024` at that location. You don’t
    have to worry about all the actions involved in doing this; that’s the job of
    the operating system and compiler.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当你写下这段代码时，你定义了一个名为`totalPopulation`的新变量，并告诉计算机在该位置存储数字`8024`。你不必担心完成此操作所涉及的所有动作；那是操作系统和编译器的工作。
- en: 'Let’s summarize. A variable is a name that refers to some value stored in memory.
    Let’s say you write the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下。变量是一个名称，它指向存储在内存中的某个值。假设你写下以下内容：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the computer reads the current value in the memory location assigned to
    the name `totalPopulation`. It then adds 24 to this value, and finally, stores
    the result in `totalPopulation`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，计算机读取分配给名称`totalPopulation`的内存位置中的当前值。然后，它将24加到这个值上，最后将结果存储在`totalPopulation`中。
- en: In the next section, we look at user comments and program layout in a little
    more detail.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更详细地探讨用户注释和程序布局。
- en: Comments
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释
- en: 'Because computer languages can be terse and confusing to the human reader,
    they let you add comments that are ignored by the computer (i.e., they are not
    part of the program). In Python, any text on the same line following the # symbol
    is ignored. In the following examples, we’ve put that text in a different font
    to emphasize that it’s not part of the program. First, consider the following
    Python expression:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计算机语言可能对人类读者来说既简短又令人困惑，它们允许你添加计算机忽略的注释（即，它们不是程序的一部分）。在Python中，同一行中跟随`#`符号的任何文本都会被忽略。在以下示例中，我们将该文本放在不同的字体中以强调它不是程序的一部分。首先，考虑以下Python表达式：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code creates a new data element called `hours` and gives it the integer
    value `12`. *Figure 2**.2* illustrates the structure of this line.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个名为`hours`的新数据元素，并给它赋了整数值`12`。*图2**.2*展示了这一行的结构。
- en: '![Figure 2.2 – The structure of a statement with a comment](img/Figure_2.02_B19624.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 带注释的语句结构](img/Figure_2.02_B19624.jpg)'
- en: Figure 2.2 – The structure of a statement with a comment
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 带注释的语句结构
- en: 'Let’s say you were then to write the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你随后写下以下内容：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then, the computer would read the value of the name on the right-hand side of
    the expression (i.e., `hours`) and substitute its value with 12\. Then, it would
    add 3 to get 12 + 3 = 15, storing this new value in a memory location called `allTime`.
    The text following `#` is ignored by the computer and serves only to help humans
    understand the program.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，计算机将读取表达式右侧名称（即`hours`）的值，并用12替换其值。然后，它会加3得到12 + 3 = 15，并将这个新值存储在名为`allTime`的内存位置中。`#`后面的文本被计算机忽略，仅用于帮助人类理解程序。
- en: Many computer languages use the = symbol differently from how we were taught
    in high school. In school algebra, ‘=’ means “*the same as,*” so that *x* = *y*
    + 2 means that the value of *x* and (*y* + 2) are identical. If the value of *y*
    is 12, then the value of *x* is 14.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 许多计算机语言使用`=`符号的方式与我们高中所学的方式不同。在学校代数中，`=`表示“*等于,*”，所以*x* = *y* + 2意味着*x*和(*y*
    + 2)的值是相同的。如果*y*的值是12，那么*x*的值就是14。
- en: In programming, the statement `x = y + 2` indicates that the value of *y* +
    2 is calculated and then *transferred* to *x*. If a programmer writes `x = x +
    2`, it means to add 2 to `x`. If this were a mathematical equation, we could write
    *x* – *x* = *x* – *x* + 2, which simplifies as the nonsensical expression 0 =
    2\. In Python, the = symbol does NOT mean equals!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，语句`x = y + 2`表示计算*y* + 2的值并将其*转移*到*x*。如果一个程序员写下`x = x + 2`，这意味着要将2加到*x*上。如果这是一个数学方程式，我们可以写成*x*
    – *x* = *x* – *x* + 2，这简化为无意义的表达式0 = 2。在Python中，`=`符号并不表示等于！
- en: In Python, the `=` symbol means “*assign to.*” A better symbol is `←`, so that
    *x* `←` *y* + 2 expresses clearly what we are doing. Some languages such as Pascal
    use the symbol pair := to indicate assignment. Sadly, the back arrow is not on
    keyboards, and we are stuck with =. Note that, in Python, a *statement* is a command
    such as `print(`) or an assignment such as `x = 4.` An *expression* is a combination
    of variables or values and operations that returns a result.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，`=`符号表示“*赋值*”。一个更好的符号是`←`，这样*x* `←` *y* + 2就能清楚地表达我们所做的操作。一些语言，如Pascal，使用符号对`:=`来表示赋值。遗憾的是，回箭头不在键盘上，我们只能坚持使用`=`。请注意，在Python中，一个*语句*是一个命令，如`print(`)或一个赋值，如`x
    = 4.`。一个*表达式*是由变量或值和操作组合而成，返回一个结果。
- en: As we’ve seen, Python has a special symbol for “*is the same as,*” and that
    symbol is ‘==’. Never confuse = and ==. It is very easy to write `if x = 5` instead
    of `if x == 5` and wonder why your program gives the wrong result.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Python有一个特殊的符号表示“*等于*”，这个符号是‘==’。永远不要混淆=和==。很容易写成`if x = 5`而不是`if x ==
    5`，然后 wonder 为什么你的程序给出了错误的结果。
- en: 'Consider the following example of a simple Python program, where we calculate
    the area of a circle. The names `radius`, `pi`, and `area` are all chosen by the
    programmer. We could have used other names, but these are more obvious to the
    reader:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下简单的Python程序示例，其中我们计算圆的面积。名称`radius`、`pi`和`area`都是由程序员选择的。我们也可以使用其他名称，但这些对读者来说更直观：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Recall that a Python name consists of letters and (optionally) numbers and
    underscores, but the first character in the name must be a letter and not a number.
    Uppercase and lowercase letters are regarded as being different in Python – that
    is, `tesT22` and `test22` are different names. It is good practice to choose meaningful
    names because that makes it easier to read a program. Consider the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，Python的名称由字母和（可选的）数字以及下划线组成，但名称中的第一个字符必须是字母而不是数字。在Python中，大写和小写字母被视为不同——也就是说，`tesT22`和`test22`是不同的名称。选择有意义的名称是一种良好的实践，因为这使得阅读程序更加容易。考虑以下示例：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding expression is verbose but clear to a human reader. This is an
    example of *camelCase*, a popular term for names that consist of words joined
    without spaces, using a capital letter to indicate each word in the chain, `asWeAreDoingNow`.
    Remember that Python variables and labels do not start with a capital letter (that’s
    a convention and not a requirement).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表达式对人类读者来说可能有些冗长，但很清晰。这是一个*骆驼命名法*的例子，这是一种用于没有空格连接的单词的流行术语，使用大写字母来表示链中的每个单词，例如`asWeAreDoingNow`。记住，Python的变量和标签不以大写字母开头（这是一个约定而不是要求）。
- en: There are two classes of data elements – constants and variables. A *constant*
    is given a value when it is first named, and that value cannot be changed – for
    example, if you define `x = 2` as a constant in a language such as C, the value
    of *x* is fixed (e.g., the expression `x = 3` would be illegal). A *variable*
    is an element that can be modified. Python does not support constants.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 数据元素分为两类——常量和变量。一个**常量**在首次命名时被赋予一个值，并且该值不能被更改——例如，如果你在C语言等语言中将`x = 2`定义为常量，则*x*的值是固定的（例如，表达式`x
    = 3`将是非法的）。一个**变量**是可以被修改的元素。Python不支持常量。
- en: 'Let’s calculate the sum of the first *n* integers, *s* = 1 + 2 + 3 + … + *n*.
    Algebra tells us that the sum of *n* integers is *n*(*n* + 1)/2\. We can convert
    this into the following Python program:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算前*n*个整数的和，*s* = 1 + 2 + 3 + … + *n*。代数告诉我们，*n*个整数的和是*n*(*n* + 1)/2。我们可以将其转换为以下Python程序：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This three-line Python program asks for an integer, performs the calculation,
    and prints the result. Let’s suppose we don’t know the formula for the sum of
    the first *n* integers. We can do it the hard way by adding them up one by one.
    The Python code to do this is given in *Listing 2.3*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个Python程序行请求一个整数，执行计算，并打印结果。假设我们不知道前*n*个整数的和的公式。我们可以通过逐个相加来硬算。完成这个任务的Python代码在*列表2.3*中给出。
- en: We have not covered all aspects of this program in detail yet. It is given here
    to demonstrate the essential simplicity of Python. However, note that Python allows
    you to request input from the keyboard and provide a prompt at the same time.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有详细涵盖这个程序的所有方面。这里给出是为了展示Python的基本简单性。然而，请注意，Python允许你同时从键盘请求输入并提供提示。
- en: '![Figure 2.3 – A Python program to add the first n integers](img/Figure_2.03_B19624.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 - 一个用于计算前n个整数的Python程序](img/Figure_2.03_B19624.jpg)'
- en: Figure 2.3 – A Python program to add the first n integers
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 - 一个用于计算前n个整数的Python程序
- en: Our next topic introduces one of Python’s key elements – a feature that is immensely
    powerful and flexible and one that makes Python such a popular language, especially
    for beginners. We will describe the list.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要介绍Python的关键元素之一——一个功能强大且灵活的特性，这使得Python成为一门流行的语言，尤其是对于初学者。我们将描述列表。
- en: The list – a Python key data structure
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表——Python的关键数据结构
- en: We now introduce Python’s *list*, which that groups together a sequence of elements.
    We show how the elements of a list can be accessed. Because the list is such a
    key feature, we will return to it several times, each time introducing new features.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们介绍Python的*列表*，它将一系列元素组合在一起。我们展示了如何访问列表的元素。由于列表是一个关键特性，我们将多次回到它，每次都介绍新的特性。
- en: A data structure is an ordered collection of data elements. The term *ordered*
    indicates that the position of a data element matters – for example, in everyday
    life, the week is ordered because the sequence of the days is fixed. A *table*,
    a *stack*, a *queue*, a *list*, a *heap*, a *pile*, a *file*, and an *array* all
    embody the idea of a data structure. In English, a *sackload* of books implies
    an *unordered* collection of items. Python does have a special data structure
    for unordered items, called a set. We will not use sets in this chapter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构是有序数据元素的集合。术语*有序*表示数据元素的位置很重要——例如，在日常生活中，一周是有序的，因为天数的顺序是固定的。*表格*、*栈*、*队列*、*列表*、*堆*、*堆叠*、*文件*和*数组*都体现了数据结构的概念。在英语中，*一袋*书意味着一个*无序*的物品集合。Python确实有一个专门用于无序项的特殊数据结构，称为集合。在本章中，我们不会使用集合。
- en: 'Like any other object, the programmer assigns a name to a list. The following
    Python list gives the result of eight consecutive exams taken by a student, expressed
    as a percentage:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他对象一样，程序员会给列表赋予一个名称。以下Python列表给出了一个学生连续八次考试成绩的结果，以百分比表示：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have given the list a meaningful name, `myTest`. In Python, a list is enclosed
    in square brackets and the items are separated by commas. Lists can grow (items
    added to them) and shrink (items removed). You can have an empty list – for example,
    `abc = []`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经给列表起了一个有意义的名称，`myTest`。在Python中，列表用方括号括起来，项目之间用逗号分隔。列表可以增长（向其中添加项目）和缩小（从中删除项目）。你可以有一个空列表——例如，`abc
    = []`。
- en: The whole point of a list is to be able to access individual items and manipulate
    them – for example, we might want to find the highest result or the lowest result,
    or the average in the `myTest` list. Therefore, we need to specify the location
    of an item. Mathematicians use *subscripts* for this task – for example, they
    may write `myTest`5\. Unfortunately, computer science arose in the dark age of
    the mechanical courier typewriter script, when different fonts, colors, italics
    style, and subscripts didn’t exist. So, we have to use the symbols that are on
    all keyboards to indicate a location within a list.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的全部意义在于能够访问单个项目并对其进行操作——例如，我们可能想要找到最高分或最低分，或者在`myTest`列表中找到平均值。因此，我们需要指定一个项目的位置。数学家使用*下标*来完成这项任务——例如，他们可能会写`myTest`5。不幸的是，计算机科学是在机械信使打字机脚本黑暗时代出现的，当时没有不同的字体、颜色、斜体样式和下标。因此，我们必须使用所有键盘上都有符号来表示列表中的位置。
- en: Python indicates the position of an item in a list (or other data structures)
    by means of *parentheses* – for example, element 3 in `myTest` is expressed as
    `myTest[3]`. The first element of a list is position 0 because computers count
    from zero. The first value in `myTest` is `myTest[0]`, which is 63\. Similarly,
    the last result is `myTest[7]`, which is 76\. We have 8 results, numbered 0 to
    7.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Python通过*括号*来表示列表（或其他数据结构）中一个项目的位置——例如，`myTest`中的第3个元素表示为`myTest[3]`。列表的第一个元素位置是0，因为计算机从0开始计数。`myTest`中的第一个值是`myTest[0]`，即63。同样，最后一个结果是`myTest[7]`，即76。我们共有8个结果，编号从0到7。
- en: 'Python is a more flexible language than some. In Python, the list is a “*one
    size fits all*” data structure. If you want to put different types of items in
    a list, you can. Other computer languages require a list to have identical items
    (e.g., all integers, all floats, or all strings). The following example demonstrates
    some legal lists in Python. As you can see, you can even have a list of lists:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Python比某些语言更灵活。在Python中，列表是一个“*通用的*”数据结构。如果你想在列表中放置不同类型的项，你可以这样做。其他计算机语言要求列表中的项必须是相同的（例如，所有整数、所有浮点数或所有字符串）。以下示例展示了Python中一些合法的列表。正如你所见，你甚至可以有一个列表的列表：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that we have aligned the *equals* symbols in a column on the left. This
    is not a feature of Python. Nor is it a requirement. We do it because it makes
    the code easier to read and makes debugging easier.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在左边列中对*等号*进行了对齐。这不是Python的特性，也不是必需的。我们这样做是为了使代码更容易阅读，并使调试更容易。
- en: 'Let’s return to the shopping list example and call the list `veg1`. We can
    set up this list with the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到购物清单的例子，并将这个列表命名为`veg1`。我们可以用以下方式设置这个列表：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The individual items in this list are in quotation marks. Why? Because they
    are strings – that is, text. Without quotations, the items would refer to variables
    that were defined earlier, such as the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表中的各个项目都在引号中。为什么？因为它们是字符串——即文本。如果没有引号，项目将引用之前定义的变量，如下所示：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Slicing lists and strings
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片列表和字符串
- en: Here, we will demonstrate how you can take a string or a list and extract data
    elements (i.e., the slices) from a string or a list. The individual characters
    of a string can be accessed – for example, if `y = 'absde'`, then `y[0] = 'a',
    y[1]= 'b', y[2]= 's',` , and so on.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将演示如何从一个字符串或列表中提取数据元素（即切片）。字符串的各个字符可以访问——例如，如果 `y = 'absde'`，那么 `y[0]
    = 'a'，y[1]= 'b'，y[2]= 's'`，以此类推。
- en: Python lets you select the last element in a string or list by using the - 1
    *index* – for example, if you write `x = y[-1]`, `then x = 'e'`. Similarly, `y[-2]is
    'd'` (i.e., the next but one from the end).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许您使用 -1 *索引* 选择字符串或列表中的最后一个元素——例如，如果您写 `x = y[-1]`，则 `x = 'e'`。同样，`y[-2]`
    是 `'d'`（即倒数第二个）。
- en: You can select a slice of a string or list using the `list[start:end]` notation.
    The slice specified by `[start:end]` selects elements from `start` to `end - 1`
    that is, you specify the end as the element *after* the last element you require.
    If `q = 'abcdefg'`, then the `r = q[2:5]` slice assigns `r = '``cde'`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `list[start:end]` 符号选择字符串或列表的切片。由 `[start:end]` 指定的切片选择从 `start` 到 `end
    - 1` 的元素，即，您指定的结束是所需最后一个元素之后的元素。如果 `q = 'abcdefg'`，那么 `r = q[2:5]` 切片将 `r` 赋值为
    `'cde'`。
- en: The expression `z = q[3:]`refers to all elements from 3 to the end of the list,
    and assigns `'defg'` to `z`. This is a remarkably useful feature because it allows
    us to take a text string such as `s='R14'` and extract the numeric value of the
    register with `t=int(s[1:])`. The expression `s[1:]` returns a substring from
    the second character to the end – that is, '`R14`' becomes '`14`'. This value
    is a string type. The `int(`'`14`'`)` operation converts the string type to an
    integer type and returns 14.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `z = q[3:]` 指的是从 3 到列表末尾的所有元素，并将 `'defg'` 赋值给 `z`。这是一个非常实用的特性，因为它允许我们从文本字符串，例如
    `s='R14'` 中提取寄存器的数值，使用 `t=int(s[1:])`。表达式 `s[1:]` 返回从第二个字符到末尾的子字符串——即，"`R14`"
    变成 "`14`"。这个值是一个字符串类型。`int('`14`')` 操作将字符串类型转换为整数类型并返回 14。
- en: The `len` function returns the length of a string. If `y='absde'`, `p=len(y)`
    returns 5 because there are 5 characters in the string.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`len` 函数返回字符串的长度。如果 `y=''absde''`，则 `p=len(y)` 返回 5，因为字符串中有 5 个字符。'
- en: Consider a list of assembly language instructions `– ops=['ADD',` `'MUL',` `'BNE',`
    `'LDRL']`. If we write `len(ops)`, we get the result `4`, because there are 4
    strings in the `ops` list. Suppose we write `x=ops[3][2]`. The value of `ops[3]`
    is `'LDRL'`, and the value of `LDRL[2]` is '`R`'. In other words, we can extract
    one or more characters from a string in a list of strings. The `x[a][b]` notation
    means to take item `a` of list `x` and then take item `b` of that element.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个汇编语言指令列表 `– ops=['ADD',` `'MUL',` `'BNE',` `'LDRL']`。如果我们写 `len(ops)`，我们得到结果
    `4`，因为 `ops` 列表中有 4 个字符串。假设我们写 `x=ops[3][2]`。`ops[3]` 的值是 `'LDRL'`，而 `LDRL[2]`
    的值是 '`R`'。换句话说，我们可以从字符串列表中提取一个或多个字符。`x[a][b]` 的表示法意味着取列表 `x` 中的项目 `a`，然后取该元素的项
    `b`。
- en: We have used functions such as `print()` and `len()`. We will now discuss functions
    in a little more detail. Later, we show you how you can define your own functions
    as well as use Python’s built-in functions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了 `print()` 和 `len()` 这样的函数。现在我们将更详细地讨论函数。稍后，我们将向您展示如何定义自己的函数以及如何使用 Python
    的内置函数。
- en: Functions in Python
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 中的函数
- en: Before continuing, we need to introduce the concept of a function in a high-level
    language. In high school math, we encounter functions such as *sqrt(x)*, which
    is an abbreviation of *square root* and returns the square root of *x* – for example,
    *sqrt(9) = 3*. Computer languages have borrowed the same concept.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要介绍高级语言中函数的概念。在高中数学中，我们遇到像 *sqrt(x)* 这样的函数，它是 *square root* 的缩写，并返回
    *x* 的平方根——例如，*sqrt(9) = 3*。计算机语言借鉴了同样的概念。
- en: 'Python provides functions that are built into the language. You call a function
    to perform a specific operation (it’s a bit like subcontracting in the real world)
    – for example, `len()`operates on strings and lists. If you call `len(x)` with
    the list `x`, it will return the number of items in that list. Consider the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了语言内置的函数。你调用一个函数来执行特定的操作（这在现实世界中有点像分包）——例如，`len()`操作字符串和列表。如果你用列表`x`调用`len(x)`，它将返回该列表中的项目数量。考虑以下情况：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This takes the list we called `veg1` and counts the number of items in it, copying
    that value to the `toBuy` variable. After this operation has been executed, the
    value of `toBuy` will be the integer 3, since there are 3 items in `veg1`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们称为`veg1`的列表中的项目数量取出来，并将该值复制到`toBuy`变量中。执行此操作后，`toBuy`的值将是整数3，因为`veg1`中有3个项目。
- en: 'Let’s say you write the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你写下以下内容：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then, the number printed is 8 because there are eight characters in the string
    `q`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打印的数字是8，因为字符串`q`中有八个字符。
- en: 'Let’s suppose we have another list of food items:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们还有另一个食物项目的列表：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s add together the number of items in the two lists. We can do that with
    the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把两个列表中的项目数量加起来。我们可以用以下方法做到：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This expression calculates the length of both lists (getting the integers `3`
    and `4`, respectively), adds them together, and assigns the value `7` to the `totalShopping`
    variable. You can print this on the screen by using the `print()`function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式计算两个列表的长度（分别得到整数`3`和`4`），将它们相加，并将值`7`赋给`totalShopping`变量。你可以通过使用`print()`函数在屏幕上打印这个值：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This expression consists of the Python word `print`, which displays something
    on the screen. The parameters used by `print` are enclosed in parentheses, separated
    by commas. A parameter in quotes is a string and is printed literally as it is.
    Remember that Python lets you use either single or double quotation marks. A parameter
    that is a variable is printed as its value. In this case, the value of the `totalShopping`
    parameter is `7`. This expression would display the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式由Python单词`print`组成，它在屏幕上显示某些内容。`print`使用的参数被括号包围，并用逗号分隔。用引号括起来的参数是一个字符串，并且按原样打印。记住，Python允许你使用单引号或双引号。变量参数按其值打印。在这种情况下，`totalShopping`参数的值是`7`。这个表达式将显示以下内容：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Consider the following expression (we’ve shaded the text to be printed). Variables
    whose values will be printed are in bold to improve understanding:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下表达式（我们已用阴影标出要打印的文本）。将要打印的变量值用粗体表示以增强理解：
- en: '`print(''`Total items to buy`'',` totalShopping`, ''`These are: `'',` fruit1`)`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(''`Total items to buy`'',` totalShopping`, ''`These are: `'',` fruit1`)`'
- en: 'What would this print? The output would be the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印什么？输出将是以下内容：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Is this what you would have expected? You might have been looking for a list
    in the order of apples, oranges, grapes. But what you asked for was the `fruit1`
    Python list, and that is exactly what you got (hence the brackets, and quotation
    marks around each item in the list). If we wanted to print the list as `apples,
    oranges, grapes, bananas`, we would have had to first convert the list of strings
    into a single string item (which we will discuss later). However, for the impatient
    among you, here’s how it’s done using the `join()` function:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你预期的结果吗？你可能期望看到一个按苹果、橙子、葡萄顺序排列的列表。但你所要求的是`fruit1` Python列表，这正是你得到的结果（这就是为什么有括号，列表中每个项目周围都有引号）。如果我们想以`apples,
    oranges, grapes, bananas`的形式打印列表，我们首先必须将字符串列表转换成一个单独的字符串项（我们稍后会讨论）。然而，对于你们中间的急躁者，这里是如何使用`join()`函数完成的：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output from this code is the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出如下：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Next, we will discuss the very item that makes a computer a computer – the conditional
    operation that selects one of two or more possible courses of action, depending
    on the result of a test.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论使计算机成为计算机的非常项目——根据测试结果选择两个或更多可能行动路线的条件操作。
- en: Conditional operations and decision-making
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件操作和决策
- en: 'And now for the biggie – the conditional operation. Let’s consider the following
    recipe:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候讨论大问题——条件操作。让我们考虑以下食谱：
- en: Take two eggs.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿两个鸡蛋。
- en: Separate the whites.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分离蛋白。
- en: Add sugar.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加入糖。
- en: Beat until stiff.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打发至发硬。
- en: These actions are carried out sequentially. The first three actions are simple
    operations. The fourth action is very different from the previous three, and it
    is this action that gives the computer its power. It’s an operation that performs
    one of two actions, depending on the outcome of a test. In this case, the eggs
    are beaten, then tested. If they are not sufficiently stiff, the beating is continued,
    they are retested, and so on.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这些动作是按顺序执行的。前三个动作是简单的操作。第四个动作与前三个非常不同，正是这个动作赋予了计算机其力量。这是一个根据测试结果执行两种动作之一的操作。在这种情况下，鸡蛋被搅拌，然后测试。如果它们不够硬，搅拌会继续，然后重新测试，依此类推。
- en: What makes a computer so powerful is its ability to take decisions. Without
    a *decision-making* capacity, a computer could not respond to its environment;
    it could perform only the same calculation over and over again. The foundation
    of human intelligence is also decision-making. If you play chess, you use decision-making
    to choose the next move on the basis of the current board positions. The move
    you make is the one that will give you the best chance of winning from your current
    situation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机之所以强大，是因为它具有做出决策的能力。如果没有 *决策能力*，计算机就无法对其环境做出反应；它只能反复执行相同的计算。人类智能的基础也是决策。如果你下棋，你会根据当前的棋盘位置做出决策，选择下一步棋。你所做的选择是给你从当前情况下赢得最佳机会的那一步。
- en: It’s the same with a computer. At any point in a program, the computer can be
    given two alternative courses of action. Depending on the outcome of a test, the
    computer chooses one of these courses of action to take and then carries out the
    appropriate operations for that decision.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机也是如此。在任何程序点，计算机都可以被赋予两种不同的行动方案。根据测试的结果，计算机选择其中一种行动方案，然后执行相应的操作。
- en: 'A typical conditional operation is the `if` statement. In Python, this can
    be expressed as the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的条件操作是 `if` 语句。在Python中，这可以表示为以下：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We’ve put the condition in bold, and the action is shaded. The action is carried
    out if, and only if, the condition is true. If the condition is not true, the
    action is ignored. For example, if *x* is 6, the value of *z* will be 20\. If
    *x* is 4, the value of *z* will remain at 9.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将条件加粗，动作被阴影覆盖。如果条件为真，则执行动作；如果条件不为真，则忽略动作。例如，如果 *x* 是6，则 *z* 的值将是20。如果 *x*
    是4，则 *z* 的值将保持为9。
- en: Computers perform simple tests whose outcome is one of the two Boolean values,
    `True` or `False`. More often than not, the test asks, “*Is this variable equal*
    *to zero?*”
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机执行简单的测试，其结果为两个布尔值之一，`True` 或 `False`。通常，测试会问，“*这个变量是否等于零？*”
- en: 'In Python, the `if` statement has the following form:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，`if` 语句具有以下形式：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The only two reserved Python elements are `if` and the colon. The term `condition`
    is any Python expression that returns the `True` or `False` value, and `action`
    is any block of instructions the computer will execute if the condition is `True`.
    Some programmers put the action on a new line. In this case, the action MUST be
    indented, such as the following *Figure 2**.4*:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Python中只有两个保留元素，即 `if` 和冒号。术语 `condition` 是任何返回 `True` 或 `False` 值的Python表达式，而
    `action` 是计算机在条件为 `True` 时将执行的一组指令。一些程序员将动作放在新的一行上。在这种情况下，动作**必须**缩进，如下所示 *图2**.4*：
- en: '![Figure 2.4 – A Python program to add the first n integers](img/Figure_2.04_B19624.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 一个用于计算前n个整数的Python程序](img/Figure_2.04_B19624.jpg)'
- en: Figure 2.4 – A Python program to add the first n integers
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 一个用于计算前n个整数的Python程序
- en: Although Python lets you use any indentation, good practice suggests the indentation
    be four spaces.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python允许你使用任何缩进，但良好的实践建议使用四个空格进行缩进。
- en: The condition is `x > 5`, and the action is `z = 20`. The condition is a Boolean
    logic expression that yields one of two outcomes – True if *x* is greater than
    5 and False if *x* is not greater than 5.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 条件是 `x > 5`，动作是 `z = 20`。条件是一个布尔逻辑表达式，它产生两种结果之一——如果 *x* 大于5则为 True，如果 *x* 不大于5则为
    False。
- en: Using a conditional expression in Python
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Python中使用条件表达式
- en: 'A Python program to control the temperature of a room might look something
    like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于控制房间温度的Python程序可能看起来像这样：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Typical Boolean conditions are as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的布尔条件如下：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'These four conditions are *equal to*, *not equal to*, *greater than*, and *less
    than*, respectively. Remember that the expression *x == y* reads, “*Is x equal
    to y?*” Consider the following example (using the Python IDLE interpreter):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个条件分别是等于、不等于、大于和小于。记住，表达式*x == y*读作“*x等于y吗？*”考虑以下示例（使用Python IDLE解释器）：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Examples of if statements
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`if`语句的示例'
- en: 'A variable, *x*, varies between 0 and 9, inclusive. Let’s say we want *y* to
    be 0 if *x* is less than 5, 1 if *x* > 4 and *x* < 8, and 2 if *x* > 7\. We can
    express this as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 变量*x*在0到9之间变化。假设我们想如果*x*小于5，则*y*为0；如果*x*大于4且小于8，则*y*为1；如果*x*大于7，则*y*为2。我们可以这样表示：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The second `if` statement tests two conditions together by using an `and` operator.
    Both conditions, `x > 4` and `x < 8`, must be true for the whole expression to
    be true.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`if`语句通过使用`and`运算符同时测试两个条件。只有当两个条件`x > 4`和`x < 8`都为真时，整个表达式才为真。
- en: 'We can also use Python’s `or` operation, which means if any of the conditions
    are true. You can write complex conditions such as the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用Python的`or`运算符，这意味着如果任何条件为真。你可以编写如下复杂条件：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As in conventional arithmetic, it is necessary to use parentheses to ensure
    that operations are carried out in the appropriate sequence.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如传统的算术一样，必须使用括号来确保操作按适当的顺序执行。
- en: 'We can test this code by generating sequential values of *x* and printing the
    corresponding value of *y*, as the following code in *Figure 2**.5* demonstrates.
    The first statement executes the indented block for x is 0 to 9 (one less than
    the range given):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过生成*x*的连续值并打印相应的*y*值来测试此代码，正如*图2.5*中所示。第一条语句执行缩进的块，当*x*为0到9（比给定的范围少一个）时：
- en: '![Figure 2.5 – Demonstrating iteration ](img/Figure_2.05_B19624.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – 迭代演示](img/Figure_2.05_B19624.jpg)'
- en: Figure 2.5 – Demonstrating iteration
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 迭代演示
- en: 'The output from this code is the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出如下：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Python’s if … else
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python的if … else
- en: 'The preceding code is correct, but it’s not efficient. If the result of the
    first `if` is true, the other `if` statements can’t be true, and yet they are
    tested. What we need is a test in which if it is true, we perform the appropriate
    action. If it is not true, we perform a different action. We have a word for this
    in English – it’s called “else”:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是正确的，但效率不高。如果第一个`if`的结果为真，其他`if`语句就不可能为真，但它们仍然被测试。我们需要的是一个测试，如果它是真的，我们就执行相应的操作。如果不是真的，我们就执行不同的操作。在英语中，我们有一个词来表示这个——它被称为“else”：
- en: 'Consider the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下内容：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Python has an `elif` (else if) statement that allows multiple tests. We can
    use `elif` to perform another `if` if the result of the first `if` is false. Consider
    the preceding code using `elif`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个`elif`（else if）语句，允许进行多个测试。我们可以使用`elif`在第一个`if`的结果为假时执行另一个`if`。考虑使用`elif`的前面代码：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this case, the computer drops out of this construct as soon as one of the
    conditional tests is true. It does exactly the same as the preceding example using
    `if` statements, but it is more efficient because it terminates as soon as a condition
    is satisfied. That is, once any of the tests yields true, its associated action
    is carried out, and then control passes to the next statement after the `if …
    elif` sequence (in this case, `print`).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，计算机一旦其中一个条件测试为真，就会退出这个结构。它与使用`if`语句的前一个示例完全一样，但更高效，因为它一旦满足条件就终止。也就是说，一旦任何测试结果为真，就执行其关联的操作，然后控制传递到`if
    … elif`序列之后的下一个语句（在这种情况下，`print`）。
- en: The great thing about programming is that there are many ways of doing the same
    thing. Suppose we know that a variable, *x*, is always in the range from 0 to
    10, and we want to know the value of *y* for each *x* (using the preceding algorithm).
    We can calculate the value of *y* as we did previously by using conditional statements
    and programming.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 编程的伟大之处在于，做同样的事情有很多种方法。假设我们知道一个变量*x*始终在0到10的范围内，并且我们想知道每个*x*对应的*y*值（使用前面的算法）。我们可以通过使用条件语句和编程来像以前一样计算*y*的值。
- en: We can implement the algorithm without using an `if` statement by creating a
    *lookup table* that provides the value of *y* for any *x*. Let’s call this table
    `lookupY` and load it with the values of *y* for *x* inputs from 0 to 10\. *Table
    2.1* gives the value of *y* for each possible *x*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个提供任何*x*的*y*值的*查找表*来实现算法，而不使用`if`语句。让我们称这个表为`lookupY`，并为其加载从0到10的*x*输入的*y*值。*表2.1*给出了每个可能的*x*的*y*值。
- en: '| **Input x** | **Output y** |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| **输入 x** | **输出 y** |'
- en: '| --- | --- |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | 0 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 |'
- en: '| 1 | 0 |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 |'
- en: '| 2 | 0 |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 0 |'
- en: '| 3 | 0 |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 0 |'
- en: '| 4 | 0 |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 0 |'
- en: '| 5 | 1 |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 1 |'
- en: '| 6 | 1 |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 1 |'
- en: '| 7 | 1 |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 1 |'
- en: '| 8 | 2 |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 2 |'
- en: '| 9 | 2 |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 2 |'
- en: '| 10 | 2 |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 2 |'
- en: Table 2.1 – Using a lookup table to perform a Boolean operation
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1 – 使用查找表执行布尔运算
- en: 'We can code this `lookup` operation in Python in just two lines:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Python中用两行代码来编写这个 `lookup` 操作：
- en: '[PRE35]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When we simulate a computer, we need to load programs to be simulated. The next
    section describes how we can read a source file (in text format) from memory into
    the simulator.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们模拟计算机时，我们需要加载要模拟的程序。下一节将描述我们如何从内存中读取源文件（文本格式）到模拟器中。
- en: Reading data from a file
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从文件中读取数据
- en: When testing an assembler or simulator, you need to enter the test data (the
    source program). This can be done in three ways.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试汇编器或模拟器时，你需要输入测试数据（源程序）。这可以通过三种方式完成。
- en: Include the data in the program – for example, `myProg = ['add r1,r2', 'inc
    r1', '``beq 7']`
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在程序中包含数据 - 例如，`myProg = ['add r1,r2', 'inc r1', '``beq 7']`
- en: Get the text from the keyboard – for example, `myProg = input('Type` `program
    ')`
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从键盘获取文本 - 例如，`myProg = input('Type` `program ')`
- en: Create a text file in memory and read it from your program
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内存中创建一个文本文件并从你的程序中读取它
- en: The first two techniques are great for testing a very short program but less
    so for a long source program. The third technique means that you write your source
    code using your favorite text editor, save it as a `.txt` file, and then read
    that file in your assembler.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种技术非常适合测试非常短的程序，但对于长源程序来说则不太适用。第三种技术意味着你使用你喜欢的文本编辑器编写源代码，将其保存为 `.txt` 文件，然后在汇编器中读取该文件。
- en: 'I often put the name of my test program in my assembler during development
    work to avoid typing the name (because I’m working on the same source file most
    of the time). Let’s suppose my file is called `c.txt`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发工作中，我经常在我的汇编器中放置测试程序的名称，以避免输入名称（因为我大部分时间都在处理相同的源文件）。假设我的文件名为 `c.txt`：
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding code, the `myFile` variable provides the name of the source
    file as a string. Then, the `with open` operation opens and reads `myFile`. This
    operation also closes the file after use. The preceding code opens `c.txt` for
    reading and creates a new file, `sFile`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`myFile` 变量提供了源文件名称作为字符串。然后，`with open` 操作打开并读取 `myFile`。此操作在使用后也会关闭文件。前面的代码以读取模式打开
    `c.txt` 并创建一个新的文件 `sFile`。
- en: 'The `open` function can be used in three ways, as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`open` 函数可以用以下三种方式使用：'
- en: '[PRE37]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It is good practice to close a file after you have used it, with `filename`.`close()`.
    Because the `with open` operation automatically closes a file at the end of an
    operation, it is not necessary to call the `close()` function.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用文件后关闭文件是一个好习惯，使用 `filename`.`close()`。因为 `with open` 操作在操作结束时自动关闭文件，所以不需要调用
    `close()` 函数。
- en: 'The `readlines()` function operates on `sFile` to create a file, `newFile`,
    containing a list of the lines of my source code. The following fragment of code
    demonstrates reading a file from disk and cleaning up the end-of-line sequences
    in a text file. That’s because text files are stored with an `''\n''` sequence
    at the end of each line, and this sequence must be removed because it is not part
    of the source program. We will return to string processing later:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`readlines()` 函数对 `sFile` 进行操作以创建一个包含我的源代码行列表的文件，`newFile`。以下代码片段演示了从磁盘读取文件并清理文本文件中的行尾序列。这是因为文本文件是以每行末尾的
    `''\n''` 序列存储的，而这个序列必须被移除，因为它不是源程序的一部分。我们将在稍后回到字符串处理：'
- en: '[PRE38]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following is the output from this code. You can see how the *‘*`\n`*’*
    sequences have been removed:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从该代码输出的内容。你可以看到 `‘*`\n`’*` 序列已经被移除：
- en: '[PRE39]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We’ve provided enough information to demonstrate a short Python program that
    implements the simple sequence detector we described earlier.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提供了足够的信息来演示一个简单的Python程序，该程序实现了我们之前描述的简单序列检测器。
- en: Translating a token detector algorithm into Python
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将令牌检测算法翻译成Python
- en: 'We can readily translate our pseudocode to detect a sequence of red tokens
    in a stream of read/write tokens as follows. In this fragment of Python, you are
    invited to enter first the number of red tokens to detect, and then `r` or `w`
    to indicate the color of each token. Once the appropriate number of tokens has
    been detected, the program terminates:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地将我们的伪代码转换为检测读/写令牌流中的红色令牌序列，如下所示。在这个Python片段中，你被邀请首先输入要检测的红色令牌的数量，然后输入
    `r` 或 `w` 以指示每个令牌的颜色。一旦检测到适当的令牌数量，程序就会终止：
- en: '[PRE40]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output of this program for a sequence I entered was the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序对我输入的序列输出的结果是以下内容：
- en: '[PRE42]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: A computer has three essential elements – an **arithmetic and logical unit**
    (**ALU**) that performs all arithmetic and logical operations on data, a memory
    that holds programs and data, and a control unit that reads the instructions from
    memory and executes them. In the next section, we will introduce some of the basic
    concepts of memory.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机有三个基本元素——一个执行所有算术和逻辑运算的**算术逻辑单元**（**ALU**），一个存储程序和数据的内存，以及一个从内存读取指令并执行它们的控制单元。在下一节中，我们将介绍一些内存的基本概念。
- en: Computer memory
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算机内存
- en: Now, we are going to introduce the *concept of memory*, the mechanism that holds
    programs and data. Real or *physical* memory is implemented as DRAM, flash memory,
    and disk drives. This memory is part of a computer’s hardware. We do not cover
    physical memory in this book. Instead, we will discuss *abstract memory* and how
    it is modeled by Python. This is the programmer’s view of memory.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将介绍**内存的概念**，即存储程序和数据的机制。实际或**物理**内存以DRAM、闪存和硬盘驱动器实现。这部分内存是计算机硬件的一部分。本书不涉及物理内存。相反，我们将讨论**抽象内存**以及它是如何由Python建模的。这是程序员的内存视图。
- en: All data is stored in physical memory, and all the data structures designed
    by a programmer must be mapped onto physical memory. The mapping process is the
    job of the operating system, and this book does not deal with the translation
    of abstract memory addresses into real memory addresses.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数据都存储在物理内存中，程序员设计的所有数据结构都必须映射到物理内存上。映射过程是操作系统的任务，本书不涉及将抽象内存地址转换为实际内存地址的转换。
- en: 'Consider the following Python list:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下Python列表：
- en: '[PRE43]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: These three strings have the `[0]`, `[1]`, and `[2]` addresses in the `friends`
    list. The operating system maps these elements onto the physical memory storage
    locations. These strings each require a different number of physical memory locations
    because each one has a different length. Mercifully, computer users do not have
    to worry about any of that. That is the job of the operating system.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个字符串在`friends`列表中分别有`[0]`、`[1]`和`[2]`地址。操作系统将这些元素映射到物理内存存储位置。这些字符串各自需要不同数量的物理内存位置，因为它们的长度不同。幸运的是，计算机用户不必担心这些。这是操作系统的任务。
- en: We will now take a brief look at the concept of memory because you have to understand
    the nature of memory in order to understand how computers work, and how to write
    programs in assembly language.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将简要地看一下内存的概念，因为您必须理解内存的本质，才能理解计算机是如何工作的，以及如何编写汇编语言程序。
- en: First, consider our own memories. Human memory is a strange and *inexact* thing.
    An *event* triggers the recall or *retrieval* of a data element that we call a
    *memory*. The event may be a question that someone asks you, or it may be something
    that *reminds* you of an episode that took place in the past. Often, we remember
    information only partially, or even incorrectly.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，考虑我们自己的记忆。人类的记忆是一种奇怪且**不精确**的东西。一个**事件**会触发我们回忆或**检索**一个我们称之为**记忆**的数据元素。这个事件可能是一个某人问你的问题，或者可能是一件提醒你过去发生的事件。通常，我们只部分地记住信息，甚至可能记错。
- en: Human memory seems to be accessed by matching an event against stored information.
    That is, our memory is *associative* because we associate one memory with another.
    A computer’s memory operates in a very different way and is best thought of as
    a *table* or *list* of stored items. You need to know where an item is on the
    list (its address) in order to access it. We will soon meet a Python memory, which
    is associative and called a *dictionary*. You don’t access a dictionary with an
    address but, instead, with a *key* that is associated with the required data element.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 人类的记忆似乎是通过将事件与存储的信息进行匹配来访问的。也就是说，我们的记忆是**关联的**，因为我们把一个记忆与另一个记忆联系起来。计算机的内存以非常不同的方式运行，最好将其视为一个**表**或**列表**的存储项。您需要知道列表上（其地址）项的位置才能访问它。我们很快就会遇到Python内存，它是一种关联的，被称为**字典**的数据结构。您不是用地址访问字典，而是用与所需数据元素相关联的**键**来访问。
- en: '*Figure 2**.6* shows how a program to find the number of red tokens in a string
    of tokens is stored in a hypothetical memory. I must stress that the program is
    conceptual rather than actual because real computer instructions use rather more
    primitive machine-level instructions than these. This figure, called a *memory
    map*, shows the location of information within the memory. It’s a *snapshot* of
    the memory because it represents the state of the memory at a particular instant.
    The memory map also includes the *variables* used by the program and a string
    of digits. The stored program computer stores instructions, variables, and constants
    in the same memory.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.6* 展示了查找字符串中红色标记数量的程序是如何存储在一个假设的内存中的。我必须强调，这个程序是概念性的，而不是实际的，因为实际的计算机指令使用比这些更原始的机器级指令。这个被称为*内存映射*的图显示了内存中信息的位置。它是一个*快照*，因为它代表了内存在一个特定时刻的状态。内存映射还包括程序使用的*变量*和一串数字。存储程序计算机将指令、变量和常量存储在相同的内存中。'
- en: '*Figure 2**.6* demonstrates that each location in the memory contains either
    an *instruction* or a *data element*. Numbers 0 to 23 in the first column are
    *addresses* that express the position of data elements and instructions within
    the memory (addresses start from 0 rather than 1 because 0 is a valid identifier).'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.6* 证明了内存中的每个位置都包含一个*指令*或一个*数据元素*。第一列中的数字0到23是*地址*，表示数据元素和指令在内存中的位置（地址从0开始而不是1，因为0是一个有效的标识符）。'
- en: The program is in locations 0 to 8, the variables in locations 9, 10, and 11,
    and the data (the tokens) in locations 12 to 23\. You can regard the computer’s
    memory as a table of *items*, and the location of each item is its address – for
    example, memory location 1 contains the instruction `Set numRed to 0`, location
    10 contains the value of the `numRed` element, and location 11 contains the value
    of the current data element (`R` or `W`). Locations 12 onward are in bold font
    to indicate that they contain the values of the sequence of tokens we operate
    on.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 程序位于0到8的位置，变量位于9、10和11的位置，数据（标记）位于12到23的位置。您可以将计算机的内存视为一个*项目*表，每个项目的位置就是其地址——例如，内存位置1包含指令`Set
    numRed to 0`，位置10包含`numRed`元素的值，位置11包含当前数据元素的值（`R`或`W`）。从位置12开始使用粗体字体表示它们包含我们操作的标记序列的值。
- en: '![Figure 2.6 – The memory map](img/Figure_2.06_B19624.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 内存映射](img/Figure_2.06_B19624.jpg)'
- en: Figure 2.6 – The memory map
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 内存映射
- en: '*Figure 2**.6* is an abstract view of a computer’s memory for teaching purposes.
    Real memory is an array of locations, each of the same size (typically, 16, 32,
    or 64 bits). Individual instructions may occupy one, two, or more consecutive
    locations, depending on the actual size of the data.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.6* 是为了教学目的对计算机内存的抽象视图。实际的内存是一个位置数组，每个位置大小相同（通常是16、32或64位）。单个指令可能占用一个、两个或多个连续的位置，具体取决于数据的实际大小。'
- en: Although we will not describe physical memory in any detail, a few comments
    will help to distinguish it from abstract memory. *Figure 2**.7* illustrates the
    organization of actual computer *memory* (e.g., DRAM). The processor provides
    memory with an address on the *address bus* and a control signal that selects
    either a *read* or a *write* cycle. In a *read cycle*, the memory puts data onto
    the *data bus* for the CPU to read. In a *write* *cycle*, data from the CPU is
    stored in the memory. Information enters or leaves memory (or any other functional
    part of a computer system) via a port. A real computer has a hierarchy of memory
    systems implemented with different technologies – for example, DRAM for main memory,
    SSD for the much slower secondary storage, and high-speed cache for frequently
    used data and instructions. In this book, we deal with only abstract memory implemented
    in Python and not real physical memory. The job of the operating system is to
    integrate the abstract memory addresses used by the programmer with the real physical
    addresses of data in memory.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们不会详细描述物理内存，但一些评论将有助于区分它与抽象内存。*图2.7*展示了实际计算机*内存*（例如，DRAM）的组织结构。处理器通过*地址总线*向内存提供一个地址，并通过一个控制信号选择是进行*读取*还是*写入*周期。在*读取周期*中，内存将数据放置到*数据总线*上供CPU读取。在*写入周期*中，CPU的数据被存储在内存中。信息通过端口进入或离开内存（或计算机系统的任何其他功能部分）。一台真正的计算机具有不同技术实现的内存系统层次结构——例如，DRAM用于主存储器，SSD用于较慢的二级存储，高速缓存用于频繁使用的数据和指令。在这本书中，我们只处理用Python实现的抽象内存，而不是真实的物理内存。操作系统的任务是整合程序员使用的抽象内存地址与内存中数据的真实物理地址。
- en: A computer’s main store is composed of high-speed **random-access memory** (**RAM**)
    that can be written to or read from. It is invariably composed of *dynamic* semiconductor
    memory, DRAM (today, it’s DDR4 and DDR5 technology), and the size of a typical
    PC’s RAM generally ranges from 4 GB for tablets to 64 GB for high-performance
    systems. RAM is volatile, which means that its data is lost when you switch it
    off (in comparison with flash memory, which retains data).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的主存储器由高速**随机存取存储器**（**RAM**）组成，可以对其进行写入或读取。它通常由*动态*半导体存储器DRAM（如今是DDR4和DDR5技术）组成，典型PC的RAM大小通常从平板电脑的4GB到高性能系统的64GB不等。RAM是易失性的，这意味着当你关闭它时（与保留数据的闪存相比），其数据会丢失。
- en: The term *dynamic* in the DRAM acronym describes its storage mechanism (as a
    charge on a capacitor, which leaks away and has to be periodically written back).
    From a user’s point of view, DRAM provides very cheap, large-volume storage. From
    a designer’s point of view, DRAM poses particular design problems because of its
    operating characteristics. An alternative to DRAM is **static RAM** (**SRAM**),
    which is easier to use and faster than DRAM but is far more expensive, preventing
    its use in PCs, except for special applications such as cache memory. Cache memory
    is a special high-speed memory that contains frequently used data.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: DRAM缩写中的*动态*一词描述了其存储机制（作为电容器上的电荷，它会泄漏并需要定期写回）。从用户的角度来看，DRAM提供了非常便宜、大量存储。从设计者的角度来看，DRAM由于其操作特性而带来了特定的设计问题。DRAM的替代品是**静态RAM**（**SRAM**），它比DRAM更容易使用且速度更快，但价格昂贵得多，这阻止了它在PC上的使用，除了缓存内存等特殊应用。缓存内存是一种特殊的高速内存，包含频繁使用的数据。
- en: Secondary (physical) storage is a **hard disk drive** (**HDD**) or **solid-state
    drive** (**SSD**). Both these store large quantities of data and are far slower
    than the DRAM of the main store. Computers do not directly access the secondary
    store. The operating system transfers data, a page at a time, from the SSD/HDD
    to a computer’s main store. This is invisible to the user.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 二级（物理）存储器是**硬盘驱动器**（**HDD**）或**固态驱动器**（**SSD**）。这两种存储器都存储大量数据，比主存储器的DRAM慢得多。计算机不能直接访问二级存储器。操作系统将数据，一次一页，从SSD/HDD传输到计算机的主存储器。这对用户来说是不可见的。
- en: The next step in describing abstract memory is to introduce a notation, called
    RTL, which is often employed to describe or define memory transactions.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '描述抽象内存的下一步是引入一种称为RTL的符号，它常用于描述或定义内存事务。 '
- en: '![Figure 2.7 – The memory system](img/Figure_2.07_B19624.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 内存系统](img/Figure_2.07_B19624.jpg)'
- en: Figure 2.7 – The memory system
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 内存系统
- en: Register transfer language
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寄存器传输语言
- en: Describing computer operations in words is often cumbersome. Here, we will introduce
    **register transfer language** (**RTL**), which makes it easy to define computer
    operations. RTL is neither an assembly language nor a programming language. It
    is a notation.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: It is important to distinguish between a memory *location* and its *contents*.
    Register transfer language uses square brackets, `[ ]`, to indicate the *contents*
    of a memory location. The expression `[15] = maxRed` is interpreted as *the contents
    of memory location 15 contain the value of maxRed*. If we wish to give the memory
    a name, we can write, for example, `dram[15]` rather than just `[15]`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'The ← symbol indicates a *data transfer*. For example, the expression [15]
    ← [15] `+ 1` is interpreted as *the contents of memory location 15 are increased
    by 1 and the result is put back in memory location 15*. Consider the following
    RTL expressions:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Expression (a) states that the contents of memory location 20 are equal to the
    number 5\. Expression (b) states that the number 6 is put into (*copied* or *loaded*
    into) memory location 20\. Expression (c) indicates that the contents of memory
    location 6 are copied into memory location 20.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Expression (d) indicates that 4 is added to the contents of location 3, and
    the sum is put in location 12\. Expression (e) indicates that the sum of the contents
    of locations 7 and 8 are added and put in location 19.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Expression (f) indicates that the contents of location 2 are used to access
    memory to read a value, which is an address. The contents of that second address
    are put in location 4\. This expression is the most interesting because it introduces
    the notion of a *pointer*. The value of memory location 2, `[2]`, is a pointer
    that indicates (points to) another memory location. If we perform `[2] ← [2] +
    1`, the pointer now points to the next location in memory. We will return to this
    when we discuss indirect addressing (also called pointer-based addressing or indexed
    addressing).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: The “←” RTL symbol is equivalent to the conventional assignment symbol, “=”,
    used in some high-level languages. RTL is not a computer language; it is a notation
    used to define computer operations.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Nested square brackets such as `[[4]]` indicate the contents of the memory location,
    whose address is given by the contents of memory location 4\. This is called indirect
    addressing. Figure 2.8 demonstrates how location 4 points at location 12, which
    contains the value of the required data – that is, 9.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Pointer-based addressing](img/Figure_2.08_B19624.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Pointer-based addressing
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: An example of the use of RTL
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s look at an example of the way that RTL can be used. *Figure 2**.9* illustrates
    a small abstract memory with 12 locations.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '| Address | Data |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
- en: '| 0 | 6 |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2 |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
- en: '| 2 | 3 |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
- en: '| 3 | 4 |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
- en: '| 4 | 5 |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
- en: '| 5 | 2 |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
- en: '| 6 | 8 |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
- en: '| 7 | 1 |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
- en: '| 8 | 5 |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
- en: '| 9 | 2 |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
- en: '| 10 | 1 |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
- en: '| 11 | 5 |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
- en: Figure 2.9 – An example of the memory map of an abstract memory
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'We wish to evaluate the expression `X = 3 + [4] + [1+[3]] + [[10]] + [[9]*3]`.
    This expression can be evaluated by summing its components, as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: The first element in the sequence is the literal 3
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expression [4] represents the contents of memory location 4 – that is, 5.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expression [1+[3]] represents [1 + 4] = [5] = 2
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expression [[10]] represents [1], which is 2
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expression [[9]*3] represents [2*3] = [6] = 8
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final value is 3 + 5 + 2 + 2 + 8 = 20.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to simulate abstract memory in Python.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Simulating memory in Python
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now demonstrate how computer memory can be simulated in a Python program.
    To simulate a computer’s main memory (the immediate access store, often called
    DRAM), we just create a Python list. A typical PC has over 4G memory locations
    (222). Here, we will create tiny memories that are easy to simulate. If we call
    the memory `mem`, we can create a memory with eight locations and initialize them
    to zero with the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This initialization mechanism is inconvenient if you have much larger memory.
    If so, you can use a Python facility that lets you create a list and fill it with
    identical elements. Let’s consider the following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To demonstrate simple operations on the memory, we’ll load two numbers into
    the simulated memory, retrieve them, add them, and store the result in memory
    using RTL notation:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can translate this into Python and print the contents of location 6 as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see, Python is remarkably close to RTL notation. Now, let’s use data
    in memory as a pointer. Recall that a pointer is a value that points to another
    location in memory. *Figure 2**.10* shows an eight-location memory map with five
    integers stored in the memory.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – A memory map of an addition operation](img/Figure_2.09_B19624.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – A memory map of an addition operation
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'We will perform the following operation, first in RTL and then in Python:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Alternatively, if we use the simplified RTL where “`mem`” is understood, we
    can write this as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This operation adds the contents of the memory location pointed at by the contents
    of location 1 to the contents of the memory location pointed at by the contents
    of memory location 2, putting the result in the contents of the memory location
    pointed at by memory location 0\. We can express this in Python as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This program will print the contents of memory as Memory `= [7, 5, 4, 0, 3,
    9, 0, 12].` As you can see, memory location 7 has changed from its initial value
    of 0 to the value 12 – that is, the sum of the contents of memory locations 5
    and 4.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main themes of this book is writing a program to simulate a computer
    so that you can run programs on a computer you designed yourself. To do this,
    it is necessary to write a simulator in a suitable high-level language. We chose
    Python because of its availability, simplicity, and power.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has provided a brief overview of Python by introducing the data
    structures and flow-control features you need to design a computer simulator.
    We have covered the basics of Python in sufficient detail for you to follow simple
    programs that don’t use any of Python’s more esoteric features.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过介绍你需要设计计算机模拟器的数据结构和流程控制功能，简要概述了Python。我们已经详细介绍了Python的基础知识，以便你能够跟随不使用Python任何更神秘特性的简单程序。
- en: Two important and very fundamental features of Python are the string (which
    is important, as simulation involves text processing) and the list. The list is
    simply a sequence of elements separated by commas and enclosed by square brackets.
    What is special about Python’s lists is that the elements can be any data elements,
    and they are easy to access – for example, element 10 of list `x` is simply `x[10]`.
    Equally, character 5 of string `x = 'a test'` and is expressed as `[5]` and is
    `'i'`. Like all computer languages, Python numbers elements from 0.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Python的两个重要且非常基本的功能是字符串（由于模拟涉及文本处理，因此很重要）和列表。列表简单地说就是由逗号分隔并由方括号包围的元素序列。Python列表的特殊之处在于，元素可以是任何数据元素，并且它们很容易访问——例如，列表`x`的第10个元素简单地表示为`x[10]`。同样，字符串`x
    = 'a test'`的第5个字符表示为`[5]`，其值为`'i'`。像所有计算机语言一样，Python从0开始编号元素。
- en: We also looked at the function, a piece of code that can be called from anywhere
    in a program to carry out some operation. You don’t need functions. However, if
    you do the same thing often, calling a chunk of code to do the job makes the program
    easier to read and debug.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了函数，这是一段可以从程序中的任何位置调用来执行某些操作的代码。你不需要函数。然而，如果你经常做同样的事情，调用一段代码来完成任务可以使程序更容易阅读和调试。
- en: We demonstrated a very simple Python program to simulate memory and took our
    first step on the way to a simulator.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们演示了一个非常简单的Python程序来模拟内存，并迈出了通往模拟器道路的第一步。
- en: However, Python’s strength (simplicity) is also a weakness. More complex languages
    ensure correctness by providing strict rules – for example, strong typing where
    you must declare the type of each variable and then use it accordingly. A very
    common Python pitfall is wrong indenting. Code in a loop or `if` construct is
    indented to show it belongs to whatever construct guards it. If you make a mistake
    with indenting while editing a program, it will either crash or behave very differently
    from what you intended.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Python的强大之处（简单性）也是其弱点。更复杂的语言通过提供严格的规则来确保正确性——例如，强类型要求你必须声明每个变量的类型，然后相应地使用它。Python中一个非常常见的陷阱是错误的缩进。循环或`if`结构中的代码缩进是为了显示它属于保护它的任何结构。如果你在编辑程序时出错缩进，程序可能会崩溃或表现出与预期完全不同的行为。
- en: In [*Chapter 3*](B19624_03.xhtml#_idTextAnchor042), we look at the basic structure
    of a **central processing unit** (**CPU**) and demonstrate how an instruction
    is read from memory, decoded, and executed.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B19624_03.xhtml#_idTextAnchor042)中，我们探讨了**中央处理单元**（**CPU**）的基本结构，并演示了如何从内存中读取指令、解码和执行。
