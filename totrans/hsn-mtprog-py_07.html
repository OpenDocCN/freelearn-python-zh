<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer074">
<h1 id="_idParaDest-66"><em class="italic"><a id="_idTextAnchor068"/>Chapter 5</em>: Understanding Introspection</h1>
<p>In this chapter, we will look at introspection in Python 3 and understand how it is useful in metaprogramming. <strong class="bold">Introspection</strong> is a concept where we can learn about the properties or attributes of objects in<a id="_idIndexMarker212"/> Python during runtime using a suite of Python’s built-in methods.</p>
<p>Why introspection? Introspection is an information-gathering process for Python objects, and the information thus gathered can help in utilizing the objects to perform generic operations by manipulating them externally and, in turn, can help us in writing metaprograms.</p>
<p>Before we understand how to implement introspection, we will have a look at the built-in functions of Python that help in performing introspection. Throughout this chapter, we will look at each function that helps us introspect and understand the objects we use in our programs.</p>
<p>In this chapter, we will be taking a look at the following main topics:</p>
<ul>
<li>Introducing built-in functions</li>
<li>Using the built-in <strong class="source-inline">id</strong> function </li>
<li>Debugging unintentional assignments using <strong class="source-inline">id</strong></li>
<li>Finding out whether an object is callable</li>
<li>Checking whether an object has an attribute</li>
<li>Checking whether an object is an instance</li>
<li>Checking whether an object is a subclass</li>
<li>Understanding the usage of property</li>
<li>Using property as a decorator</li>
</ul>
<p>By the end of this chapter, you should be able to apply built-in functions to introspect Python objects, apply them to examples, and use them to debug code.</p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor069"/>Technical requirements</h1>
<p>The code examples shared in this chapter are available on GitHub under the code for this chapter here: <a href="https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter05">https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter05</a>.</p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor070"/>Introducing built-in functions</h1>
<p>To understand introspection <a id="_idIndexMarker213"/>and the usage of Python’s built-in functions to perform introspection, we will continue making use of our core example of <em class="italic">ABC Megamart</em> throughout this chapter. </p>
<p>We will be covering the usage of the following built-in functions to introspect Python objects:</p>
<ul>
<li><strong class="source-inline">id()</strong></li>
<li><strong class="source-inline">eval()</strong></li>
<li><strong class="source-inline">callable()</strong></li>
<li><strong class="source-inline">hastattr()</strong></li>
<li><strong class="source-inline">getattr()</strong></li>
<li><strong class="source-inline">isinstance()</strong></li>
<li><strong class="source-inline">issubclass()</strong></li>
<li><strong class="source-inline">property()</strong></li>
</ul>
<p>Introspecting Python objects <a id="_idIndexMarker214"/>helps in understanding the properties of objects, which in turn, helps in metaprogramming these objects and using them to debug the objects, which we will be looking at in further chapters as well.</p>
<p>With this understanding, let’s look further into the concept of how to use these built-in functions and introspect objects.</p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor071"/>Using the built-in id function </h1>
<p>Understanding the characteristics of a Python object helps in writing metaprograms on the object. The memory <a id="_idIndexMarker215"/>address of an object is one of its characteristics or properties that can be manipulated using metaprogramming. The <strong class="source-inline">id</strong> function in Python 3 can be called to identify an object using the object’s memory address. Identifying an object through its memory address helps in analyzing objects to find out whether there are multiple assignments or copies of an object created unintentionally during the process of code development. </p>
<p>To understand this further, here is how we will work:</p>
<ol>
<li>We will be creating a class named <strong class="source-inline">Billing</strong>, which calculates and prints a simple bill for any product that is provided as input. Refer to the following code:<p class="source-code">class Billing:</p><p class="source-code">    def __init__(self,product_name,unit_price,quantity,tax):</p><p class="source-code">        self.product_name = product_name</p><p class="source-code">        self.unit_price = unit_price</p><p class="source-code">        self.quantity = quantity</p><p class="source-code">        self.tax = tax</p><p class="source-code">        </p><p class="source-code">    def generate_bill(self):</p><p class="source-code">        total = self.unit_price * self.quantity </p><p class="source-code">        final_total = total + total*self.tax</p><p class="source-code">        print('***********------------------</p><p class="source-code">               **************')</p><p class="source-code">        print('Product:', self.product_name)</p><p class="source-code">        print('Total:',final_total)</p><p class="source-code">        print('***********------------------</p><p class="source-code">               **************')</p></li>
<li>Let’s now create an object for the <strong class="source-inline">Billing</strong> class:<p class="source-code">billing = Billing('Delmonte Cheese',6,4,0.054)</p></li>
<li>Let’s now call the <strong class="source-inline">generate_bill</strong> method to print the bill:<p class="source-code">billing.generate_bill()</p></li>
</ol>
<p>This code gives the following output:</p>
<p class="source-code"><strong class="bold">***********------------------**************</strong></p>
<p class="source-code"><strong class="bold">Product: Delmonte Cheese</strong></p>
<p class="source-code"><strong class="bold">Total: 25.296</strong></p>
<p class="source-code"><strong class="bold">***********------------------**************</strong></p>
<ol>
<li value="4">In the next step, let’s create a separate <strong class="source-inline">generate_bill</strong> function that performs the <a id="_idIndexMarker216"/>same set of operations as the <strong class="source-inline">generate_bill</strong> method that was created inside the <strong class="source-inline">Billing</strong> class. The function will take in four parameters (<strong class="source-inline">product_name</strong>, <strong class="source-inline">unit_price</strong>, <strong class="source-inline">quantity</strong>, and <strong class="source-inline">tax</strong>):<p class="source-code"><strong class="bold">def generate_bill(product_name,unit_price,quantity,tax):</strong></p><p class="source-code"><strong class="bold">    total = unit_price * quantity </strong></p><p class="source-code"><strong class="bold">    final_total = total + total*tax</strong></p><p class="source-code"><strong class="bold">    print('***********------------------</strong></p><p class="source-code"><strong class="bold">           **************')</strong></p><p class="source-code"><strong class="bold">    print('Product:', product_name)</strong></p><p class="source-code"><strong class="bold">    print('Total:',final_total)</strong></p><p class="source-code"><strong class="bold">    print('***********------------------</strong></p><p class="source-code"><strong class="bold">           **************')</strong></p></li>
<li>In the next step, we will be copying the <strong class="source-inline">Billing</strong> class into another variable named <strong class="source-inline">Invoicing</strong>:<p class="source-code"><strong class="bold">Invoicing = Billing</strong></p></li>
</ol>
<p>So far, we have three objects: </p>
<ul>
<li>A class named <strong class="source-inline">Billing</strong></li>
<li>A function named <strong class="source-inline">generate_bill</strong></li>
<li>A variable that assigned the <strong class="source-inline">Billing</strong> class to a variable called <strong class="source-inline">Invoicing</strong></li>
</ul>
<ol>
<li value="6">Now, let’s apply Python’s built-in <strong class="source-inline">id</strong> function to get the memory address of each of these objects:<p class="source-code">id(Billing)</p><p class="source-code"><strong class="bold">2015859835472</strong></p><p class="source-code">id(Invoicing)</p><p class="source-code"><strong class="bold">2015859835472</strong></p><p class="source-code">id(generate_bill)</p><p class="source-code"><strong class="bold">2015871203792</strong></p></li>
</ol>
<p>In the preceding<a id="_idIndexMarker217"/> output, we can notice that both <strong class="source-inline">Billing</strong> and <strong class="source-inline">Invoicing</strong> have the same memory address since <strong class="source-inline">Invoicing</strong> is a copy of the <strong class="source-inline">Billing</strong> class. The following figure is a simple representation of this example:</p>
<div>
<div class="IMG---Figure" id="_idContainer066">
<img alt="Figure 5.1 – The Billing class copied to Invoicing " height="265" src="image/Figure_5.1_B13426.jpg" width="706"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The Billing class copied to Invoicing</p>
<p>With this understanding, we can further look into how we can use the <strong class="source-inline">id</strong> function in implementing metaprogramming.</p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor072"/>Debugging unintentional assignments using id</h1>
<p>In this section, we will be <a id="_idIndexMarker218"/>discussing what happens when we make unintentional references or assignments to an object while defining an attribute, a method, or a function, and how to resolve such incorrect assignments using <a id="_idIndexMarker219"/>the built-in <strong class="source-inline">id</strong> function. When a reference is made unintentionally, the memory address of the object is shared between the actual object and the reference object. In this example, we will be making use of <strong class="source-inline">id</strong> to debug the Python objects created in the preceding section and identify duplicate assignments or references of an object that might have been created unintentionally while developing an application. Here is how it works:</p>
<ol>
<li value="1">To begin with, let’s create a dictionary item, <strong class="source-inline">class_id_count</strong>, to capture the number of occurrences of the memory address of each class:<p class="source-code">class_id_count = {}</p></li>
<li>In the next step, we will be creating the following four lists:<p class="source-code">duplicates = []</p><p class="source-code">ids = []</p><p class="source-code">classes = []</p><p class="source-code">classnames = []</p></li>
</ol>
<p>Here, we capture duplicate memory addresses with <strong class="source-inline">duplicates</strong>, capture results of the <strong class="source-inline">id</strong> function with <strong class="source-inline">ids</strong>, capture the class details with <strong class="source-inline">classes</strong>, and capture the names of classes with <strong class="source-inline">classnames</strong>.</p>
<ol>
<li value="3">In this step, we will be iterating over the directory of Python objects and checking whether the type of the object is <strong class="source-inline">type</strong> since the type of class is <strong class="source-inline">type</strong> in Python. This step helps in identifying all the objects that are classes and then updating the lists created with <strong class="source-inline">ids</strong>, <strong class="source-inline">classes</strong>, and <strong class="source-inline">classnames</strong>. Refer to the following code block:<p class="source-code">for obj in dir():</p><p class="source-code">    if type(eval(obj)) == type:</p><p class="source-code">        ids.append(id(eval(obj)))</p><p class="source-code">        classes.append(eval(obj))</p><p class="source-code">        classnames.append(obj)</p></li>
<li>We will now iterate over the <strong class="source-inline">ids</strong> list and check that the <strong class="source-inline">id</strong> is not in <strong class="source-inline">class_id_count</strong>, and then add it; if it is already in <strong class="source-inline">class_id_count</strong>, we will add it to<a id="_idIndexMarker220"/> the <strong class="source-inline">duplicates</strong> list:<p class="source-code">for i in ids:</p><p class="source-code">    if i not in class_id_count:</p><p class="source-code">        class_id_count[i] = 1</p><p class="source-code">    elif (class_id_count[i] == 1):</p><p class="source-code">        duplicates.append(i)</p><p class="source-code">        class_id_count[i] += 1</p></li>
<li>We will further iterate <a id="_idIndexMarker221"/>over the <strong class="source-inline">classes</strong> and <strong class="source-inline">classnames</strong> lists and check whether there are duplicates. Then, we will print the classes that have duplicates:<p class="source-code">for cls,clsname in zip(classes,classnames):</p><p class="source-code">    for clsid in duplicates:</p><p class="source-code">        if (id(cls)==clsid):</p><p class="source-code">            print(clsname,cls)</p></li>
</ol>
<p>The output of the preceding code is as follows:</p>
<p class="source-code"><strong class="bold">Billing &lt;class '__main__.Billing'&gt;</strong></p>
<p class="source-code"><strong class="bold">Invoicing &lt;class '__main__.Billing'&gt;</strong></p>
<ol>
<li value="6">Executing the <a id="_idIndexMarker222"/>preceding code results in the following output:<p class="source-code">class_id_count</p><p class="source-code"><strong class="bold">{2196689735984: 2}</strong></p><p class="source-code">duplicates</p><p class="source-code"><strong class="bold">[2196689735984]</strong></p><p class="source-code">ids</p><p class="source-code"><strong class="bold">[2196689735984, 2196689735984]</strong></p><p class="source-code">classes</p><p class="source-code"><strong class="bold">[__main__.Billing, __main__.Billing]</strong></p><p class="source-code">classnames</p><p class="source-code"><strong class="bold">['Billing', 'Invoicing']</strong></p></li>
</ol>
<p>In the preceding output, we can see that both the <strong class="source-inline">Billing</strong> and <strong class="source-inline">Invoicing</strong> classes have the same memory address and they are duplicates. There can be scenarios where we might have intentionally referenced a class, and there can also be scenarios where multiple variable <a id="_idIndexMarker223"/>assignments to the same memory address might have happened by mistake. In such intentional scenarios, <strong class="source-inline">id</strong> can be used to check duplicate assignments to a memory address.</p>
<p>The following figure is a simple representation of this example:</p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<img alt="Figure 5.2 – Two classes with one memory address " height="435" src="image/Figure_5.2_B13426.jpg" width="626"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Two classes with one memory address</p>
<p>With this understanding, we<a id="_idIndexMarker224"/> will look further into another <a id="_idIndexMarker225"/>built-in function, <strong class="source-inline">callable</strong>.</p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor073"/>Finding out whether an object is callable</h1>
<p>In this section, we will look at another built-in function named <strong class="source-inline">callable</strong>. As the name implies, this function helps in identifying <a id="_idIndexMarker226"/>whether a Python object can be called. Functions and methods can be called to enable various operations to be<a id="_idIndexMarker227"/> performed on the input parameters. Not all Python objects are callable. For example, a string variable or a numeric variable stores information but will not perform any action when executed. The <strong class="source-inline">callable</strong> function helps in verifying such objects that can be called and those that cannot be called in a function. </p>
<p>Why do we need to check whether an object is callable? Python is an object-oriented programming language where we can write libraries and write classes within the libraries that are encapsulated. The end user of classes or libraries need not always have access to the class definition or method definitions. While importing the Python libraries, we might sometimes want to know whether the imported object is just a variable that stores a value or whether it is a function that can be reused. The simplest way of checking this is to see whether the object is callable, as functions or methods are usually callable. This comes in handy, especially when the developer of a library did not provide any documentation for its methods and attributes. </p>
<p>Let’s make use of <strong class="source-inline">callable</strong> in the following example:</p>
<ol>
<li value="1">Let’s create a new Python file and save it as <strong class="source-inline">product.py</strong>. Go to <a href="https://github.com/PacktPublishing/Metaprogramming-with-Python/blob/main/Chapter05/product.py">https://github.com/PacktPublishing/Metaprogramming-with-Python/blob/main/Chapter05/product.py</a> and add the following code, which creates a class named <strong class="source-inline">Product</strong>. Add the following four attributes to it: <strong class="source-inline">Product ID</strong>, <strong class="source-inline">Product Name</strong>, <strong class="source-inline">Product Category</strong>, and <strong class="source-inline">Unit Price</strong>. We will now assign values to these four attributes, as follows:<p class="source-code">class Product:</p><p class="source-code">    _product_id = 100902</p><p class="source-code">    _product_name = 'Iphone X'</p><p class="source-code">    _product_category = 'Electronics'</p><p class="source-code">    _unit_price = 700</p></li>
<li>Now, let’s add a <a id="_idIndexMarker228"/>method named <strong class="source-inline">get_product</strong> within the <strong class="source-inline">Product</strong> class. This method would simply return the four attributes<a id="_idIndexMarker229"/> created in the preceding step:<p class="source-code">    def get_product(self):</p><p class="source-code">        return self._product_id, self._product_name, </p><p class="source-code">             self._product_category, self._unit_price</p></li>
<li>In this step, we will import the <strong class="source-inline">Product</strong> class from <strong class="source-inline">product.py</strong> and create an object for it:<p class="source-code">import product</p><p class="source-code">prodobj = product.Product()</p></li>
<li>Let’s now check whether the class is callable by using the built-in <strong class="source-inline">callable</strong> function. The class is callable and so the function returns <strong class="source-inline">True</strong>:<p class="source-code">callable(product.Product)</p><p class="source-code"><strong class="bold">True</strong></p></li>
<li>In this step, we can also check whether a class object is callable. The object is not callable since we did not overwrite the <strong class="source-inline">__call__</strong> method of the class to make it callable, and<a id="_idIndexMarker230"/> so the function returns <strong class="source-inline">False</strong>:<p class="source-code">callable(prodobj)</p><p class="source-code"><strong class="bold">False</strong></p></li>
<li>We can now check whether a Python object is callable and then get its attributes:<p class="source-code">if callable(prodobj.get_product):</p><p class="source-code">    print(prodobj.get_product())</p><p class="source-code">else:</p><p class="source-code">    print("This object is not callable")</p></li>
<li>Similarly, we can also check whether a Python object is callable and then print the details of the object if it returns <strong class="source-inline">True</strong>:<p class="source-code">if callable(prodobj):</p><p class="source-code">    print(prodobj)</p><p class="source-code">else:</p><p class="source-code">    print('This is not a method')</p></li>
</ol>
<p>With this example, we<a id="_idIndexMarker231"/> can look further into the next function, <strong class="source-inline">hasattr</strong>.</p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor074"/>Checking whether an object has an attribute</h1>
<p>While using a method or a function<a id="_idIndexMarker232"/> object defined in a framework or library by importing the library into another program, we might not always <a id="_idIndexMarker233"/>know all the attributes of the object. In such cases, we have a built-in <strong class="source-inline">hasattr</strong> function that can be used to introspect if a Python object has a specific attribute.</p>
<p>This function checks whether a given object has attributes. To test this function, we will create a class for the inventory of <em class="italic">ABC Megamart</em>, add the required attributes for the products stored in the inventory, and also include the price of the products along with the tax component. The price will<a id="_idIndexMarker234"/> be calculated both before and after tax for the products stored in the inventory. The following are the <a id="_idIndexMarker235"/>steps for it:</p>
<ol>
<li value="1">We will create a class called <strong class="source-inline">Inventory</strong> and initiate it with the variables required for an inventory, such as <strong class="source-inline">product_id</strong>, <strong class="source-inline">product_name</strong>, <strong class="source-inline">date</strong> (of purchase), <strong class="source-inline">unit_price</strong>, <strong class="source-inline">quantity</strong>, <strong class="source-inline">unit_discount</strong>, and <strong class="source-inline">tax</strong>, as shown in the following code:<p class="source-code">class Inventory:</p><p class="source-code">    def __init__(self,product_id,product_name,date,unit_price,quantity,unit_discount,tax):  </p><p class="source-code">        self.product_id = product_id</p><p class="source-code">        self.product_name = product_name</p><p class="source-code">        self.date = date</p><p class="source-code">        self.unit_price = unit_price</p><p class="source-code">        self.quantity = quantity</p><p class="source-code">        self.unit_discount = unit_discount</p><p class="source-code">        self.tax = tax</p></li>
<li>In this step, we will add a method to <strong class="source-inline">Inventory</strong> to calculate the amount before tax and, in this method, we will have three input parameters: <strong class="source-inline">quantity</strong>, <strong class="source-inline">unit_price</strong>, and <strong class="source-inline">unit_discount</strong>. If these three variables are <strong class="source-inline">None</strong>, then this method will use the same variables initiated during the instantiation of the <strong class="source-inline">Inventory</strong> class to calculate the amount before tax:<p class="source-code">def calc_amount_before_tax(self,quantity=None,unit_price=None, unit_discount=None):</p><p class="source-code">        if quantity is None:</p><p class="source-code">            self.quantity = self.quantity</p><p class="source-code">        else:</p><p class="source-code">            self.quantity = quantity</p><p class="source-code">            </p><p class="source-code">        if unit_price is None:</p><p class="source-code">            self.unit_price = self.unit_price</p><p class="source-code">        else:</p><p class="source-code">            self.unit_price = unit_price</p><p class="source-code">        </p><p class="source-code">        if unit_discount is None:</p><p class="source-code">            self.unit_discount = self.unit_discount</p><p class="source-code">        else:</p><p class="source-code">            self.unit_discount = unit_discount</p><p class="source-code">        amount_before_tax = self.quantity * </p><p class="source-code">           (self.unit_price - self.unit_discount)</p><p class="source-code">        return amount_before_tax</p></li>
<li>We will also add <a id="_idIndexMarker236"/>another method to the <strong class="source-inline">Inventory</strong> class to calculate the amount after tax. This method is <a id="_idIndexMarker237"/>also defined in a similar pattern as <strong class="source-inline">calc_amount_before_tax</strong>:<p class="source-code">def calc_amount_after_tax(self, quantity=None,unit_price=None,unit_discount=None,tax=None):</p><p class="source-code">        if quantity is None:</p><p class="source-code">            self.quantity = self.quantity</p><p class="source-code">        else:</p><p class="source-code">            self.quantity = quantity</p><p class="source-code">            </p><p class="source-code">        if unit_price is None:</p><p class="source-code">            self.unit_price = self.unit_price</p><p class="source-code">        else:</p><p class="source-code">            self.unit_price = unit_price</p><p class="source-code">        </p><p class="source-code">        if unit_discount is None:</p><p class="source-code">            self.unit_discount = self.unit_discount</p><p class="source-code">        else:</p><p class="source-code">            self.unit_discount = unit_discount</p><p class="source-code">            </p><p class="source-code">        if tax is None:</p><p class="source-code">            self.tax = self.tax</p><p class="source-code">        else:</p><p class="source-code">            self.tax = tax</p><p class="source-code">        amount_after_tax = </p><p class="source-code">            self.calc_amount_before_tax(</p><p class="source-code">            self.quantity,self.unit_price,</p><p class="source-code">            self.unit_discount) + self.tax</p><p class="source-code">        return amount_after_tax</p></li>
<li>We will now create the last method for this class, which returns the consolidated <a id="_idIndexMarker238"/>inventory details, creates<a id="_idIndexMarker239"/> a DataFrame, and returns the DataFrame:<p class="source-code">    def return_inventory(self):</p><p class="source-code">        import pandas as pd</p><p class="source-code">        inventory_schema = pd.DataFrame([</p><p class="source-code">                           self.product_id,</p><p class="source-code">                           self.product_name,</p><p class="source-code">                           self.date,</p><p class="source-code">                           self.unit_price,</p><p class="source-code">                           self.quantity,</p><p class="source-code">                           self.unit_discount,</p><p class="source-code">                           self.tax,</p><p class="source-code">                           self.calc_unt_before_tax(),</p><p class="source-code">            self.calc_amount_after_tax()]).transpose()</p><p class="source-code">        inventory_schema.columns = ["Product_id",</p><p class="source-code">            "Product_name","Date","Unit_price",</p><p class="source-code">            "Quantity","Unit_discount","Tax",</p><p class="source-code">            "Amount Before Tax", "Amount After Tax"]</p><p class="source-code">        return inventory_schema    </p></li>
<li>Then, create an object for the <strong class="source-inline">Inventory</strong> class and initialize its attributes:<p class="source-code">inventory = Inventory(300021,</p><p class="source-code">                'Samsung-Refrigerator',</p><p class="source-code">                '08/04/2021',</p><p class="source-code">                200,</p><p class="source-code">                25,</p><p class="source-code">                10,</p><p class="source-code">                0.0522)</p></li>
<li>Check whether <a id="_idIndexMarker240"/>the object returns the<a id="_idIndexMarker241"/> attributes:<p class="source-code">inventory.product_id</p><p class="source-code"><strong class="bold">300021</strong></p><p class="source-code">inventory.product_name</p><p class="source-code"><strong class="bold">'Samsung-Refrigerator'</strong></p><p class="source-code">inventory.date</p><p class="source-code"><strong class="bold">'08/04/2021'</strong></p><p class="source-code">inventory.unit_price</p><p class="source-code"><strong class="bold">200</strong></p><p class="source-code">inventory.quantity</p><p class="source-code"><strong class="bold">25</strong></p><p class="source-code">inventory.unit_discount</p><p class="source-code"><strong class="bold">10</strong></p><p class="source-code">inventory.tax</p><p class="source-code"><strong class="bold">0.0522</strong></p><p class="source-code">inventory.calc_amount_before_tax()</p><p class="source-code"><strong class="bold">4750</strong></p><p class="source-code">inventory.calc_amount_after_tax()</p><p class="source-code"><strong class="bold">4750.0522</strong></p><p class="source-code">inventory.return_inventory()</p></li>
</ol>
<p>The output of the preceding code is as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<img alt="Figure 5.3 – The output – Inventory details  " height="182" src="image/Figure_5.3_B13426.jpg" width="1648"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – The output – Inventory details </p>
<ol>
<li value="7">Next, let’s make <a id="_idIndexMarker242"/>use of <strong class="source-inline">dir</strong> to list down <a id="_idIndexMarker243"/>all the names of arguments in the <strong class="source-inline">Inventory</strong> class:<p class="source-code">dir(Inventory)</p><p class="source-code">['__class__',</p><p class="source-code"> '__delattr__',</p><p class="source-code"> '__dict__',</p><p class="source-code"> ‚__dir__',</p><p class="source-code"> ‚__doc__',</p><p class="source-code"> ‚__eq__',</p><p class="source-code"> ‚__format__',</p><p class="source-code"> ‚__ge__',</p><p class="source-code"> ‚__getattribute__',</p><p class="source-code"> ‚__gt__',</p><p class="source-code"> ‚__hash__',</p><p class="source-code"> ‚__init__',</p><p class="source-code"> ‚__init_subclass__',</p><p class="source-code"> ‚__le__',</p><p class="source-code"> ‚__lt__',</p><p class="source-code"> ‚__module__',</p><p class="source-code"> ‚__ne__',</p><p class="source-code"> ‚__new__',</p><p class="source-code"> ‚__reduce__',</p><p class="source-code"> ‚__reduce_ex__',</p><p class="source-code"> ‚__repr__',</p><p class="source-code"> ‚__setattr__',</p><p class="source-code"> ‚__sizeof__',</p><p class="source-code"> ‚__str__',</p><p class="source-code"> ‚__subclasshook__',</p><p class="source-code"> ‚__weakref__',</p><p class="source-code"> ‚calc_amount_after_tax',</p><p class="source-code"> ‚calc_amount_before_tax',</p><p class="source-code"> ‚return_inventory']</p></li>
<li>Now, let’s make use of <strong class="source-inline">hasattr</strong> to check whether the class has attributes. If the type of attribute <a id="_idIndexMarker244"/>is a method, then <a id="_idIndexMarker245"/>use <strong class="source-inline">getattr</strong> to get the attributes. Executing the following loop results in the list of all the attributes of <strong class="source-inline">Inventory</strong>:<p class="source-code">for i in dir(Inventory):</p><p class="source-code">     if (hasattr(Inventory,i)):</p><p class="source-code">            if type(getattr(inventory, i)) is type(getattr(inventory,  '__init__')):</p><p class="source-code">                print(getattr(Inventory,i))&lt;class 'type'&gt;</p><p class="source-code"><strong class="bold">&lt;function Inventory.__init__ at 0x000001C9BBB46CA0&gt;</strong></p><p class="source-code"><strong class="bold">&lt;function Inventory.calc_amount_after_tax at 0x000001C9BBB46DC0&gt;</strong></p><p class="source-code"><strong class="bold">&lt;function Inventory.calc_amount_before_tax at 0x000001C9BBB46D30&gt;</strong></p><p class="source-code"><strong class="bold">&lt;function Inventory.return_inventory at 0x000001C9BBB46E50&gt;</strong></p></li>
</ol>
<p>With this understanding, we can <a id="_idIndexMarker246"/>further look into <a id="_idIndexMarker247"/>another built-in function, <strong class="source-inline">isinstance</strong>.</p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor075"/>Checking whether an object is an instance</h1>
<p>In this section, we will look at<a id="_idIndexMarker248"/> another function named <strong class="source-inline">isinstance</strong>, which can be used to check whether an object is an instance of a particular class. As we are covering introspection in this chapter, we are more focused on what <a id="_idIndexMarker249"/>functions are available to introspect an object rather than how these functions can be used further to manipulate or debug a piece of code. <a href="B13426_06_Final_PG_epub.xhtml#_idTextAnchor080"><em class="italic">Chapter 6</em></a>, will cover the usage of these functions on metaprogramming along with examples. </p>
<p>In the preceding section, we created a class named <strong class="source-inline">Inventory</strong>. In this section, we can continue using the same class and create another object for the class. This is shown as follows:</p>
<pre class="source-code">inventory_fmcg = Inventory(100011,</pre>
<pre class="source-code">                'Delmonte Ketchup',</pre>
<pre class="source-code">                '09/04/2021',</pre>
<pre class="source-code">                5,</pre>
<pre class="source-code">                0.25,</pre>
<pre class="source-code">                0.10,</pre>
<pre class="source-code">                0.0522)</pre>
<pre class="source-code">inventory_fmcg.product_id</pre>
<pre class="source-code"><strong class="bold">100011</strong></pre>
<pre class="source-code">inventory_fmcg.calc_amount_before_tax()</pre>
<pre class="source-code"><strong class="bold">1.225</strong></pre>
<pre class="source-code">inventory_fmcg.calc_amount_after_tax()</pre>
<pre class="source-code"><strong class="bold">1.2772000000000001</strong></pre>
<pre class="source-code">inventory_fmcg.return_inventory()</pre>
<p>The output of the preceding code is as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer069">
<img alt="Figure 5.4 – The output – Inventory details of inventory_fmcg " height="191" src="image/Figure_5.4_B13426.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – The output – Inventory details of inventory_fmcg</p>
<p>Now, let’s <a id="_idIndexMarker250"/>check whether <strong class="source-inline">inventory_fmcg</strong> is an <a id="_idIndexMarker251"/>object of the <strong class="source-inline">Inventory</strong> class using <strong class="source-inline">isinstance</strong>:</p>
<pre class="source-code">isinstance(inventory_fmcg,Inventory)</pre>
<p class="source-code"><strong class="bold">True</strong></p>
<p>Similarly, we can also check whether the previously created <strong class="source-inline">inventory</strong> object is still an instance of the <strong class="source-inline">Inventory</strong> class:</p>
<pre class="source-code">isinstance(inventory,Inventory)</pre>
<p class="source-code"><strong class="bold">True</strong></p>
<p>Let’s consider a scenario where we have reallocated the object inventory to another value by mistake while writing the code, and we might still need to make use of the object and call its methods to return the inventory details. To test this scenario using <strong class="source-inline">isinstance</strong>, we can look at the following steps:</p>
<ol>
<li value="1">Check whether an object is an instance of the <strong class="source-inline">Inventory</strong> class and call a method of the function. If the object is not an instance of the class, check the type of variable to which it has been reallocated:<p class="source-code">if isinstance(inventory,Inventory):</p><p class="source-code">    display(inventory.return_inventory())</p><p class="source-code">else:</p><p class="source-code">    print("Object reallocated to",  type(inventory), </p><p class="source-code">          ", please correct it")</p></li>
<li>The preceding code results in the following output since <strong class="source-inline">inventory</strong> is still an object of the <strong class="source-inline">Inventory</strong> class:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer070">
<img alt="Figure 5.5 – The output – Inventory details " height="187" src="image/Figure_5.5_B13426.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – The output – Inventory details</p>
<ol>
<li value="3">Now, let’s reallocate<a id="_idIndexMarker252"/> the <strong class="source-inline">inventory</strong> variable to some other string value and call the <strong class="source-inline">return_inventory</strong> method <a id="_idIndexMarker253"/>on it:<p class="source-code">inventory = "test"</p></li>
<li>Calling the <strong class="source-inline">return_inventory</strong> method for the <strong class="source-inline">inventory</strong> object will result in the following error:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer071">
<img alt="Figure 5.6 – Error on calling the return_inventory method on a reallocated object " height="123" src="image/Figure_5.6_B13426.jpg" width="651"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Error on calling the return_inventory method on a reallocated object</p>
<ol>
<li value="5">To avoid the preceding error and to let the code handle this error gracefully and, at the same time, provide more information to the developer, we can modify the code as follows <a id="_idIndexMarker254"/>using the <strong class="source-inline">isinstance</strong> method:<p class="source-code">if isinstance(inventory,Inventory):</p><p class="source-code">    print(inventory.return_inventory())</p><p class="source-code">else:</p><p class="source-code">    print("Object reallocated to",  type(inventory), </p><p class="source-code">          ", please correct it")</p></li>
</ol>
<p>The output of the preceding code is as follows:</p>
<pre class="source-code"><strong class="bold">Object reallocated to &lt;class 'str'&gt; , please correct it</strong></pre>
<p>With this understanding, we<a id="_idIndexMarker255"/> can look further into another in-built function, <strong class="source-inline">issubclass</strong>.</p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor076"/>Checking whether an object is a subclass</h1>
<p>In this section, we <a id="_idIndexMarker256"/>will look at the <strong class="source-inline">issubclass</strong> function. This function is used to check whether a given input class is actually a child class or a <a id="_idIndexMarker257"/>subclass of a specific parent class. To introspect a class using this function, let’s look at the following steps:</p>
<ol>
<li value="1">Create an <strong class="source-inline">FMCG</strong> class by initializing variables for supplier information such as <strong class="source-inline">supplier_name</strong>, <strong class="source-inline">supplier_code</strong>, <strong class="source-inline">supplier_address</strong>, <strong class="source-inline">supplier_contract_start_date</strong>, <strong class="source-inline">supplier_contract_end_date</strong>, and <strong class="source-inline">supplier_quality_code</strong>, shown as follows:<p class="source-code">class FMCG:</p><p class="source-code">    def __init__(self,supplier_name,supplier_code,</p><p class="source-code">       supplier_address,supplier_contract_start_date,\</p><p class="source-code">    supplier_contract_end_date,supplier_quality_code):</p><p class="source-code">        self.supplier_name = supplier_name</p><p class="source-code">        self.supplier_code = supplier_code</p><p class="source-code">        self.supplier_address = supplier_address</p><p class="source-code">        self.supplier_contract_start_date = </p><p class="source-code">             supplier_contract_start_date</p><p class="source-code">        self.supplier_contract_end_date = </p><p class="source-code">             supplier_contract_end_date</p><p class="source-code">        self.supplier_quality_code = </p><p class="source-code">             supplier_quality_code</p></li>
<li>Add a method in the class to simply get the supplier details initialized in the class and return it as a <a id="_idIndexMarker258"/>dictionary object <a id="_idIndexMarker259"/>with a key and a value:<p class="source-code">    def get_supplier_details(self):</p><p class="source-code">        supplier_details = {</p><p class="source-code">           'Supplier_name': self.supplier_name, </p><p class="source-code">            'Supplier_code': self.supplier_code,</p><p class="source-code">            'Supplier_address': self.supplier_address,</p><p class="source-code">            'ContractStartDate': </p><p class="source-code">                    self.supplier_contract_start_date,</p><p class="source-code">            'ContractEndDate': </p><p class="source-code">                      self.supplier_contract_end_date, </p><p class="source-code">            'QualityCode': self.supplier_quality_code</p><p class="source-code">        }</p><p class="source-code">        return supplier_details</p></li>
<li>Create an object for the <strong class="source-inline">FMCG</strong> class and initialize the variables with supplier data and then display the supplier details by calling the preceding method:<p class="source-code">fmcg = FMCG('Test Supplier','a0015','5093 9th Main Street, Pasadena,California, 91001', '05/04/2020', '05/04/2025',1)</p><p class="source-code">fmcg.get_supplier_details()</p><p class="source-code">{'Supplier_name': 'Test Supplier',</p><p class="source-code"> 'Supplier_code': 'a0015',</p><p class="source-code"> 'Supplier_address': '5093 9th Main Street, </p><p class="source-code">    Pasadena,California, 91001',</p><p class="source-code"> 'ContractStartDate': '05/04/2020',</p><p class="source-code"> 'ContractEndDate': '05/04/2025',</p><p class="source-code"> 'QualityCode': 1}</p></li>
<li>Here, we can then create another <a id="_idIndexMarker260"/>class for condiments that covers both inventory details and<a id="_idIndexMarker261"/> FMCG supplier details by inheriting this class from both the <strong class="source-inline">FMCG</strong> class and the <strong class="source-inline">Inventory</strong> class. This class will be initialized with all the product-level inventory variables and the supplier-level variables:<p class="source-code">class Condiments(FMCG,Inventory):</p><p class="source-code">    def __init__(self,*inventory):</p><p class="source-code">        self.product_id = inventory[0]</p><p class="source-code">        self.product_name = inventory[1]</p><p class="source-code">        self.date = inventory[2]</p><p class="source-code">        self.unit_price = inventory[3]</p><p class="source-code">        self.quantity = inventory[4]</p><p class="source-code">        self.unit_discount = inventory[5]</p><p class="source-code">        self.tax = inventory[6]</p><p class="source-code">        self.supplier_name = inventory[7]</p><p class="source-code">        self.supplier_code = inventory[8]</p><p class="source-code">        self.supplier_address = inventory[9]</p><p class="source-code">        self.supplier_contract_start_date = </p><p class="source-code">                                inventory[10]</p><p class="source-code">        self.supplier_contract_end_date = </p><p class="source-code">                                inventory[11]</p><p class="source-code">        self.supplier_quality_code = inventory[12]</p></li>
<li>Then, let’s add a method to simply return all the variables initialized in the <strong class="source-inline">Condiments</strong> class by<a id="_idIndexMarker262"/> storing them as a<a id="_idIndexMarker263"/> DataFrame or table:<p class="source-code">    def return_condiment_inventory(self):</p><p class="source-code">        import pandas as pd</p><p class="source-code">        inventory_schema = pd.DataFrame([</p><p class="source-code">                        self.product_id,</p><p class="source-code">                        self.date,</p><p class="source-code">                        self.unit_price,</p><p class="source-code">                        self.quantity,</p><p class="source-code">                        self.unit_discount,</p><p class="source-code">                        self.tax,</p><p class="source-code">                        self.calc_amount_before_tax(),</p><p class="source-code">                        self.calc_amount_after_tax(),</p><p class="source-code">                        self.get_supplier_details()</p><p class="source-code">                                       ]).transpose()</p><p class="source-code">        inventory_schema.columns = ["Product_id",</p><p class="source-code">            "Date","Unit_price","Quantity",</p><p class="source-code">            "Unit_discount","Tax","Amount Before Tax", </p><p class="source-code">            "Amount After Tax",'Supplier_details']</p><p class="source-code">        return inventory_schema          </p></li>
<li>We can now<a id="_idIndexMarker264"/> create an object<a id="_idIndexMarker265"/> for this class and call its method:<p class="source-code">ketchup = Condiments(100011,'Delmonte Ketchup','09/04/2021',5,0.25,0.10,0.0522,'Test Supplier','a0015','5093 9th Main Street, Pasadena,California, 91001', '05/04/2020', '05/04/2025',1)</p><p class="source-code">ketchup.return_condiment_inventory()</p></li>
<li>Executing the preceding code results in the following output:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer072">
<img alt="Figure 5.7 – The output – Condiment inventory details " height="250" src="image/Figure_5.7_B13426.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – The output – Condiment inventory details</p>
<ol>
<li value="8">Now let’s check whether the <strong class="source-inline">FMCG</strong> class is a subclass of <strong class="source-inline">Inventory</strong>. It will return as <strong class="source-inline">False</strong> since FMCG is not a subclass of <strong class="source-inline">Inventory</strong>:<p class="source-code">issubclass(FMCG,Inventory)</p><p class="source-code"><strong class="bold">False</strong></p></li>
<li>In this step, we will check whether <strong class="source-inline">Condiments</strong> is a subclass of <strong class="source-inline">FMCG</strong> and also whether it is a subclass of <strong class="source-inline">Inventory</strong>. Both should return as <strong class="source-inline">True</strong> since <strong class="source-inline">Condiments</strong> is inherited from both of these classes:<p class="source-code">issubclass(Condiments,FMCG)</p><p class="source-code"><strong class="bold">True</strong></p><p class="source-code">issubclass(Condiments,Inventory)</p><p class="source-code"><strong class="bold">True</strong></p></li>
<li>Next, we will be creating an object for a class by, first, checking whether a class is a subclass of a specific <a id="_idIndexMarker266"/>parent class, then<a id="_idIndexMarker267"/> creating an object accordingly, and then calling a method on the newly created object:<p class="source-code">if issubclass(Condiments,FMCG):</p><p class="source-code">    fmcg = Condiments(100011,'Delmonte </p><p class="source-code">      Ketchup','09/04/2021',5,0.25,0.10,0.0522,</p><p class="source-code">      'Test Supplier','a0015','5093 9th Main Street, </p><p class="source-code">      Pasadena,California, 91001', '05/04/2020', </p><p class="source-code">      '05/04/2025',1)</p><p class="source-code">else:</p><p class="source-code">    fmcg = FMCG('Test Supplier','a0015','5093 9th Main</p><p class="source-code">      Street, Pasadena,California, 91001', </p><p class="source-code">      '05/04/2020', '05/04/2025',1)</p><p class="source-code">display(fmcg.get_supplier_details())</p></li>
<li>Executing the preceding code results in the following output:<p class="source-code"><strong class="bold">{'Supplier_name': 'Test Supplier',</strong></p><p class="source-code"><strong class="bold"> 'Supplier_code': 'a0015',</strong></p><p class="source-code"><strong class="bold"> 'Supplier_address': '5093 9th Main Street, </strong></p><p class="source-code"><strong class="bold">    Pasadena,California, 91001',</strong></p><p class="source-code"><strong class="bold"> 'ContractStartDate': '05/04/2020',</strong></p><p class="source-code"><strong class="bold"> 'ContractEndDate': '05/04/2025',</strong></p><p class="source-code"><strong class="bold"> 'QualityCode': 1}</strong></p></li>
</ol>
<p>With this understanding, we can look<a id="_idIndexMarker268"/> further into the last topic of this chapter.</p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor077"/>Understanding the usage of property</h1>
<p>In this section, we will look at the last built-in function <a id="_idIndexMarker269"/>covered in this chapter, <strong class="source-inline">property</strong>. This function is used to initialize, set, get, or delete methods of attributes in Python. These values are called the properties of an object. Let’s first understand how <strong class="source-inline">property</strong> works on Python objects by creating an example.</p>
<p>We can create a property by simply calling the <strong class="source-inline">property</strong> function and storing it as a variable. Refer to the following code:</p>
<pre class="source-code">test_property = property()</pre>
<pre class="source-code">test_property</pre>
<pre class="source-code"><strong class="bold">&lt;property at 0x1c9c9335950&gt;</strong></pre>
<p>We still did not answer the question of how this function creates a property. The <strong class="source-inline">property</strong> function takes in four variables to get, set, delete, and document the properties of an attribute. To examine it further, let’s look at it in a little more detail. The steps are as follows:</p>
<ol>
<li value="1">Create a class named <strong class="source-inline">TestPropertyClass</strong>. </li>
<li>Initialize it with a <strong class="source-inline">test</strong> attribute and set it as <strong class="source-inline">None</strong>. </li>
<li>We will then add three methods to perform the functions of getting, setting, and deleting the initialized <strong class="source-inline">test</strong> attribute. </li>
<li>We will then create another variable within the class named <strong class="source-inline">test_attr</strong> and assign the <strong class="source-inline">property</strong> function<a id="_idIndexMarker270"/> to it with the <strong class="source-inline">get</strong>, <strong class="source-inline">set</strong>, and <strong class="source-inline">delete</strong> methods created in this class.</li>
</ol>
<p> The code for this example is as follows:</p>
<pre class="source-code">class TestPropertyClass:</pre>
<pre class="source-code">    def __init__(self):</pre>
<pre class="source-code">        self._test_attr = None</pre>
<pre class="source-code">    def get_test_attr(self):</pre>
<pre class="source-code">        print("get test_attr")</pre>
<pre class="source-code">        return self._test_attr</pre>
<pre class="source-code">    def set_test_attr(self, value):</pre>
<pre class="source-code">        print("set test_attr")</pre>
<pre class="source-code">        self._test_attr = value</pre>
<pre class="source-code">    def del_test_attr(self):</pre>
<pre class="source-code">        print("del test_attr")</pre>
<pre class="source-code">        del self._test_attr</pre>
<pre class="source-code">    test_attr = property(get_test_attr, set_test_attr, </pre>
<pre class="source-code">        del_test_attr, "test_attr is a property")</pre>
<p>In the preceding code, <strong class="source-inline">get_test_attr</strong> simply returns the <strong class="source-inline">test</strong> attribute,<strong class="source-inline"> set_test_attr</strong> sets a value to the <strong class="source-inline">test</strong> attribute, and <strong class="source-inline">del_test_attr</strong> deletes the <strong class="source-inline">test</strong> attribute. </p>
<p>Let’s now create an object for this class and check how <strong class="source-inline">property</strong> works on it:</p>
<pre class="source-code">test_property_object = TestPropertyClass()</pre>
<pre class="source-code">test_property_object.test_attr</pre>
<pre class="source-code"><strong class="bold">get test_attr</strong></pre>
<p>In the preceding code, calling the <strong class="source-inline">test</strong> attribute has, in turn, invoked the <strong class="source-inline">get_test_attr</strong> method since it is provided as the <strong class="source-inline">get</strong> method to the <strong class="source-inline">property</strong> function. Let’s confirm this understanding further by setting a value to <strong class="source-inline">test_attr</strong>:</p>
<pre class="source-code">test_property_object.test_attr = 1980</pre>
<pre class="source-code"><strong class="bold">set test_attr</strong></pre>
<p>Assigning a value to the <strong class="source-inline">test_attr</strong> variable has now invoked the <strong class="source-inline">set_test_attr</strong> method since it is provided as a <strong class="source-inline">set</strong> method to the <strong class="source-inline">property</strong> function. Calling the <strong class="source-inline">test_attr</strong> attribute again returns the <a id="_idIndexMarker271"/>value set in the preceding step:</p>
<pre class="source-code">test_property_object.test_attr</pre>
<pre class="source-code"><strong class="bold">get test_attr</strong></pre>
<pre class="source-code"><strong class="bold">1980</strong></pre>
<p>Similarly, deleting the attribute, in turn, invokes the <strong class="source-inline">del_test_attr</strong> method since it is provided as a <strong class="source-inline">delete</strong> method to the <strong class="source-inline">property</strong> function:</p>
<pre class="source-code">del test_property_object.test_attr</pre>
<pre class="source-code"><strong class="bold">del test_attr</strong></pre>
<p>Once the attribute is deleted, the <strong class="source-inline">get</strong> method will still be invoked while calling the attribute, but it will not return the value previously assigned since it is deleted:</p>
<pre class="source-code">test_property_object.test_attr</pre>
<p>The output of the preceding code would now look as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<img alt="Figure 5.8 – The get method invoked on a deleted attribute " height="278" src="image/Figure_5.8_B13426.jpg" width="658"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – The get method invoked on a deleted attribute</p>
<p>By modifying the behavior of the <strong class="source-inline">getter</strong>, <strong class="source-inline">setter</strong>, or <strong class="source-inline">deleter</strong> methods, we can modify the properties of the <a id="_idIndexMarker272"/>attribute itself. We will look at this statement in detail in <a href="B13426_06_Final_PG_epub.xhtml#_idTextAnchor080"><em class="italic">Chapter 6</em></a>.</p>
<p>With this understanding of assigning the <strong class="source-inline">property</strong> function to a variable and then invoking its <strong class="source-inline">getter</strong>, <strong class="source-inline">setter</strong>, and <strong class="source-inline">deleter</strong> methods, we will further look into another variation of implementing <strong class="source-inline">property</strong>.</p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor078"/>Using property as a decorator</h1>
<p>In the preceding section, we looked at <a id="_idIndexMarker273"/>how to use <strong class="source-inline">property</strong> as a function to modify the properties of an attribute in a class. In this section, we will look at how to use <strong class="source-inline">property</strong> as a decorator. Let’s consider the same <strong class="source-inline">TestPropertyClass</strong> as in the preceding example and modify the class definition to use the <strong class="source-inline">@property</strong> decorator statement instead of the <strong class="source-inline">property()</strong> function statement. Refer to the following code:</p>
<pre class="source-code">class TestPropertyClass:</pre>
<pre class="source-code">    def __init__(self):</pre>
<pre class="source-code">        self._test_attr = None</pre>
<pre class="source-code">    @property</pre>
<pre class="source-code">    def test_attr(self):</pre>
<pre class="source-code">        return self.test_attr</pre>
<pre class="source-code">    @test_attr.getter</pre>
<pre class="source-code">    def test_attr(self):</pre>
<pre class="source-code">        print("get test_attr")</pre>
<pre class="source-code">        return self._test_attr</pre>
<pre class="source-code">    @test_attr.setter</pre>
<pre class="source-code">    def test_attr(self, value):</pre>
<pre class="source-code">        print("set test_attr")</pre>
<pre class="source-code">        self._test_attr = value</pre>
<pre class="source-code">    @test_attr.deleter</pre>
<pre class="source-code">    def test_attr(self):</pre>
<pre class="source-code">        print("del test_attr")</pre>
<pre class="source-code">        del self._test_attr</pre>
<p>In the preceding code, we have added <strong class="source-inline">@property</strong> as the decorator for <strong class="source-inline">test_attr</strong>, and we have also added <strong class="source-inline">@test_attr.setter</strong> for the <strong class="source-inline">set</strong> method, <strong class="source-inline">@test_attr.getter</strong> for the <strong class="source-inline">get</strong> method, and <strong class="source-inline">@test_attr.deleter</strong> for the <strong class="source-inline">delete</strong> method. </p>
<p>Let’s proceed with executing the <a id="_idIndexMarker274"/>code further to check whether <strong class="source-inline">getter</strong>, <strong class="source-inline">setter</strong>, and <strong class="source-inline">deleter</strong> are working as expected:</p>
<pre class="source-code">test_property_object = TestPropertyClass()</pre>
<pre class="source-code">test_property_object.test_attr</pre>
<pre class="source-code"><strong class="bold">get test_attr</strong></pre>
<p>In the preceding code, calling the attribute invoked the <strong class="source-inline">getter</strong> method. Similarly, <strong class="source-inline">setter</strong> and <strong class="source-inline">deleter</strong> also invoked the <strong class="source-inline">set</strong> and <strong class="source-inline">delete</strong> methods, respectively:</p>
<pre class="source-code">test_property_object.test_attr = 1982</pre>
<pre class="source-code"><strong class="bold">set test_attr</strong></pre>
<pre class="source-code">test_property_object.test_attr</pre>
<pre class="source-code"><strong class="bold">get test_attr</strong></pre>
<pre class="source-code"><strong class="bold">1982</strong></pre>
<pre class="source-code">del test_property_object.test_attr</pre>
<pre class="source-code"><strong class="bold">del test_attr</strong></pre>
<p>These are some of the <a id="_idIndexMarker275"/>examples of how introspection can be applied to Python objects using Python’s built-in functions.</p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor079"/>Summary</h1>
<p>In this chapter, we have learned how to introspect Python objects using built-in functions.</p>
<p>We then saw how to use the <strong class="source-inline">id</strong> function, and how to debug code using <strong class="source-inline">id</strong>. We also looked at how to check whether an object is callable, how to check whether an object has an attribute, how to check whether an object is an instance, how to check whether an object is a subclass, and finally, we looked at how to get, set, and delete properties on attributes. From all of these concepts, we learned how to inspect Python objects such as classes, methods, and functions. From the examples covered under each topic, we also learned how to apply introspection in practical use cases.</p>
<p>In the next chapter, we will be extending the learning from introspection and applying it further to understand reflection on Python objects.</p>
</div>
</div></body></html>