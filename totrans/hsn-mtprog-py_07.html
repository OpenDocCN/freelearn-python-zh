<html><head></head><body>
<div><div><h1 id="_idParaDest-66"><em class="italic"><a id="_idTextAnchor068"/>Chapter 5</em>: Understanding Introspection</h1>
<p>In this chapter, we will look at introspection in Python 3 and understand how it is useful in metaprogramming. <strong class="bold">Introspection</strong> is a concept where we can learn about the properties or attributes of objects in<a id="_idIndexMarker212"/> Python during runtime using a suite of Python’s built-in methods.</p>
<p>Why introspection? Introspection is an information-gathering process for Python objects, and the information thus gathered can help in utilizing the objects to perform generic operations by manipulating them externally and, in turn, can help us in writing metaprograms.</p>
<p>Before we understand how to implement introspection, we will have a look at the built-in functions of Python that help in performing introspection. Throughout this chapter, we will look at each function that helps us introspect and understand the objects we use in our programs.</p>
<p>In this chapter, we will be taking a look at the following main topics:</p>
<ul>
<li>Introducing built-in functions</li>
<li>Using the built-in <code>id</code> function </li>
<li>Debugging unintentional assignments using <code>id</code></li>
<li>Finding out whether an object is callable</li>
<li>Checking whether an object has an attribute</li>
<li>Checking whether an object is an instance</li>
<li>Checking whether an object is a subclass</li>
<li>Understanding the usage of property</li>
<li>Using property as a decorator</li>
</ul>
<p>By the end of this chapter, you should be able to apply built-in functions to introspect Python objects, apply them to examples, and use them to debug code.</p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor069"/>Technical requirements</h1>
<p>The code examples shared in this chapter are available on GitHub under the code for this chapter here: <a href="https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter05">https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter05</a>.</p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor070"/>Introducing built-in functions</h1>
<p>To understand introspection <a id="_idIndexMarker213"/>and the usage of Python’s built-in functions to perform introspection, we will continue making use of our core example of <em class="italic">ABC Megamart</em> throughout this chapter. </p>
<p>We will be covering the usage of the following built-in functions to introspect Python objects:</p>
<ul>
<li><code>id()</code></li>
<li><code>eval()</code></li>
<li><code>callable()</code></li>
<li><code>hastattr()</code></li>
<li><code>getattr()</code></li>
<li><code>isinstance()</code></li>
<li><code>issubclass()</code></li>
<li><code>property()</code></li>
</ul>
<p>Introspecting Python objects <a id="_idIndexMarker214"/>helps in understanding the properties of objects, which in turn, helps in metaprogramming these objects and using them to debug the objects, which we will be looking at in further chapters as well.</p>
<p>With this understanding, let’s look further into the concept of how to use these built-in functions and introspect objects.</p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor071"/>Using the built-in id function </h1>
<p>Understanding the characteristics of a Python object helps in writing metaprograms on the object. The memory <a id="_idIndexMarker215"/>address of an object is one of its characteristics or properties that can be manipulated using metaprogramming. The <code>id</code> function in Python 3 can be called to identify an object using the object’s memory address. Identifying an object through its memory address helps in analyzing objects to find out whether there are multiple assignments or copies of an object created unintentionally during the process of code development. </p>
<p>To understand this further, here is how we will work:</p>
<ol>
<li>We will be creating a class named <code>Billing</code>, which calculates and prints a simple bill for any product that is provided as input. Refer to the following code:<pre>class Billing:
    def __init__(self,product_name,unit_price,quantity,tax):
        self.product_name = product_name
        self.unit_price = unit_price
        self.quantity = quantity
        self.tax = tax
        
    def generate_bill(self):
        total = self.unit_price * self.quantity 
        final_total = total + total*self.tax
        print('***********------------------
               **************')
        print('Product:', self.product_name)
        print('Total:',final_total)
        print('***********------------------
               **************')</pre></li>
<li>Let’s now create an object for the <code>Billing</code> class:<pre>billing = Billing('Delmonte Cheese',6,4,0.054)</pre></li>
<li>Let’s now call the <code>generate_bill</code> method to print the bill:<pre>billing.generate_bill()</pre></li>
</ol>
<p>This code gives the following output:</p>
<pre><strong class="bold">***********------------------**************</strong>
<strong class="bold">Product: Delmonte Cheese</strong>
<strong class="bold">Total: 25.296</strong>
<strong class="bold">***********------------------**************</strong></pre>
<ol>
<li value="4">In the next step, let’s create a separate <code>generate_bill</code> function that performs the <a id="_idIndexMarker216"/>same set of operations as the <code>generate_bill</code> method that was created inside the <code>Billing</code> class. The function will take in four parameters (<code>product_name</code>, <code>unit_price</code>, <code>quantity</code>, and <code>tax</code>):<pre><strong class="bold">def generate_bill(product_name,unit_price,quantity,tax):</strong>
<strong class="bold">    total = unit_price * quantity </strong>
<strong class="bold">    final_total = total + total*tax</strong>
<strong class="bold">    print('***********------------------</strong>
<strong class="bold">           **************')</strong>
<strong class="bold">    print('Product:', product_name)</strong>
<strong class="bold">    print('Total:',final_total)</strong>
<strong class="bold">    print('***********------------------</strong>
<strong class="bold">           **************')</strong></pre></li>
<li>In the next step, we will be copying the <code>Billing</code> class into another variable named <code>Invoicing</code>:<pre><strong class="bold">Invoicing = Billing</strong></pre></li>
</ol>
<p>So far, we have three objects: </p>
<ul>
<li>A class named <code>Billing</code></li>
<li>A function named <code>generate_bill</code></li>
<li>A variable that assigned the <code>Billing</code> class to a variable called <code>Invoicing</code></li>
</ul>
<ol>
<li value="6">Now, let’s apply Python’s built-in <code>id</code> function to get the memory address of each of these objects:<pre>id(Billing)
<strong class="bold">2015859835472</strong>
id(Invoicing)
<strong class="bold">2015859835472</strong>
id(generate_bill)
<strong class="bold">2015871203792</strong></pre></li>
</ol>
<p>In the preceding<a id="_idIndexMarker217"/> output, we can notice that both <code>Billing</code> and <code>Invoicing</code> have the same memory address since <code>Invoicing</code> is a copy of the <code>Billing</code> class. The following figure is a simple representation of this example:</p>
<div><div><img alt="Figure 5.1 – The Billing class copied to Invoicing " height="265" src="img/Figure_5.1_B13426.jpg" width="706"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The Billing class copied to Invoicing</p>
<p>With this understanding, we can further look into how we can use the <code>id</code> function in implementing metaprogramming.</p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor072"/>Debugging unintentional assignments using id</h1>
<p>In this section, we will be <a id="_idIndexMarker218"/>discussing what happens when we make unintentional references or assignments to an object while defining an attribute, a method, or a function, and how to resolve such incorrect assignments using <a id="_idIndexMarker219"/>the built-in <code>id</code> function. When a reference is made unintentionally, the memory address of the object is shared between the actual object and the reference object. In this example, we will be making use of <code>id</code> to debug the Python objects created in the preceding section and identify duplicate assignments or references of an object that might have been created unintentionally while developing an application. Here is how it works:</p>
<ol>
<li value="1">To begin with, let’s create a dictionary item, <code>class_id_count</code>, to capture the number of occurrences of the memory address of each class:<pre>class_id_count = {}</pre></li>
<li>In the next step, we will be creating the following four lists:<pre>duplicates = []
ids = []
classes = []
classnames = []</pre></li>
</ol>
<p>Here, we capture duplicate memory addresses with <code>duplicates</code>, capture results of the <code>id</code> function with <code>ids</code>, capture the class details with <code>classes</code>, and capture the names of classes with <code>classnames</code>.</p>
<ol>
<li value="3">In this step, we will be iterating over the directory of Python objects and checking whether the type of the object is <code>type</code> since the type of class is <code>type</code> in Python. This step helps in identifying all the objects that are classes and then updating the lists created with <code>ids</code>, <code>classes</code>, and <code>classnames</code>. Refer to the following code block:<pre>for obj in dir():
    if type(eval(obj)) == type:
        ids.append(id(eval(obj)))
        classes.append(eval(obj))
        classnames.append(obj)</pre></li>
<li>We will now iterate over the <code>ids</code> list and check that the <code>id</code> is not in <code>class_id_count</code>, and then add it; if it is already in <code>class_id_count</code>, we will add it to<a id="_idIndexMarker220"/> the <code>duplicates</code> list:<pre>for i in ids:
    if i not in class_id_count:
        class_id_count[i] = 1
    elif (class_id_count[i] == 1):
        duplicates.append(i)
        class_id_count[i] += 1</pre></li>
<li>We will further iterate <a id="_idIndexMarker221"/>over the <code>classes</code> and <code>classnames</code> lists and check whether there are duplicates. Then, we will print the classes that have duplicates:<pre>for cls,clsname in zip(classes,classnames):
    for clsid in duplicates:
        if (id(cls)==clsid):
            print(clsname,cls)</pre></li>
</ol>
<p>The output of the preceding code is as follows:</p>
<pre><strong class="bold">Billing &lt;class '__main__.Billing'&gt;</strong>
<strong class="bold">Invoicing &lt;class '__main__.Billing'&gt;</strong></pre>
<ol>
<li value="6">Executing the <a id="_idIndexMarker222"/>preceding code results in the following output:<pre>class_id_count
<strong class="bold">{2196689735984: 2}</strong>
duplicates
<strong class="bold">[2196689735984]</strong>
ids
<strong class="bold">[2196689735984, 2196689735984]</strong>
classes
<strong class="bold">[__main__.Billing, __main__.Billing]</strong>
classnames
<strong class="bold">['Billing', 'Invoicing']</strong></pre></li>
</ol>
<p>In the preceding output, we can see that both the <code>Billing</code> and <code>Invoicing</code> classes have the same memory address and they are duplicates. There can be scenarios where we might have intentionally referenced a class, and there can also be scenarios where multiple variable <a id="_idIndexMarker223"/>assignments to the same memory address might have happened by mistake. In such intentional scenarios, <code>id</code> can be used to check duplicate assignments to a memory address.</p>
<p>The following figure is a simple representation of this example:</p>
<div><div><img alt="Figure 5.2 – Two classes with one memory address " height="435" src="img/Figure_5.2_B13426.jpg" width="626"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Two classes with one memory address</p>
<p>With this understanding, we<a id="_idIndexMarker224"/> will look further into another <a id="_idIndexMarker225"/>built-in function, <code>callable</code>.</p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor073"/>Finding out whether an object is callable</h1>
<p>In this section, we will look at another built-in function named <code>callable</code>. As the name implies, this function helps in identifying <a id="_idIndexMarker226"/>whether a Python object can be called. Functions and methods can be called to enable various operations to be<a id="_idIndexMarker227"/> performed on the input parameters. Not all Python objects are callable. For example, a string variable or a numeric variable stores information but will not perform any action when executed. The <code>callable</code> function helps in verifying such objects that can be called and those that cannot be called in a function. </p>
<p>Why do we need to check whether an object is callable? Python is an object-oriented programming language where we can write libraries and write classes within the libraries that are encapsulated. The end user of classes or libraries need not always have access to the class definition or method definitions. While importing the Python libraries, we might sometimes want to know whether the imported object is just a variable that stores a value or whether it is a function that can be reused. The simplest way of checking this is to see whether the object is callable, as functions or methods are usually callable. This comes in handy, especially when the developer of a library did not provide any documentation for its methods and attributes. </p>
<p>Let’s make use of <code>callable</code> in the following example:</p>
<ol>
<li value="1">Let’s create a new Python file and save it as <code>product.py</code>. Go to <a href="https://github.com/PacktPublishing/Metaprogramming-with-Python/blob/main/Chapter05/product.py">https://github.com/PacktPublishing/Metaprogramming-with-Python/blob/main/Chapter05/product.py</a> and add the following code, which creates a class named <code>Product</code>. Add the following four attributes to it: <code>Product ID</code>, <code>Product Name</code>, <code>Product Category</code>, and <code>Unit Price</code>. We will now assign values to these four attributes, as follows:<pre>class Product:
    _product_id = 100902
    _product_name = 'Iphone X'
    _product_category = 'Electronics'
    _unit_price = 700</pre></li>
<li>Now, let’s add a <a id="_idIndexMarker228"/>method named <code>get_product</code> within the <code>Product</code> class. This method would simply return the four attributes<a id="_idIndexMarker229"/> created in the preceding step:<pre>    def get_product(self):
        return self._product_id, self._product_name, 
             self._product_category, self._unit_price</pre></li>
<li>In this step, we will import the <code>Product</code> class from <code>product.py</code> and create an object for it:<pre>import product
prodobj = product.Product()</pre></li>
<li>Let’s now check whether the class is callable by using the built-in <code>callable</code> function. The class is callable and so the function returns <code>True</code>:<pre>callable(product.Product)
<strong class="bold">True</strong></pre></li>
<li>In this step, we can also check whether a class object is callable. The object is not callable since we did not overwrite the <code>__call__</code> method of the class to make it callable, and<a id="_idIndexMarker230"/> so the function returns <code>False</code>:<pre>callable(prodobj)
<strong class="bold">False</strong></pre></li>
<li>We can now check whether a Python object is callable and then get its attributes:<pre>if callable(prodobj.get_product):
    print(prodobj.get_product())
else:
    print("This object is not callable")</pre></li>
<li>Similarly, we can also check whether a Python object is callable and then print the details of the object if it returns <code>True</code>:<pre>if callable(prodobj):
    print(prodobj)
else:
    print('This is not a method')</pre></li>
</ol>
<p>With this example, we<a id="_idIndexMarker231"/> can look further into the next function, <code>hasattr</code>.</p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor074"/>Checking whether an object has an attribute</h1>
<p>While using a method or a function<a id="_idIndexMarker232"/> object defined in a framework or library by importing the library into another program, we might not always <a id="_idIndexMarker233"/>know all the attributes of the object. In such cases, we have a built-in <code>hasattr</code> function that can be used to introspect if a Python object has a specific attribute.</p>
<p>This function checks whether a given object has attributes. To test this function, we will create a class for the inventory of <em class="italic">ABC Megamart</em>, add the required attributes for the products stored in the inventory, and also include the price of the products along with the tax component. The price will<a id="_idIndexMarker234"/> be calculated both before and after tax for the products stored in the inventory. The following are the <a id="_idIndexMarker235"/>steps for it:</p>
<ol>
<li value="1">We will create a class called <code>Inventory</code> and initiate it with the variables required for an inventory, such as <code>product_id</code>, <code>product_name</code>, <code>date</code> (of purchase), <code>unit_price</code>, <code>quantity</code>, <code>unit_discount</code>, and <code>tax</code>, as shown in the following code:<pre>class Inventory:
    def __init__(self,product_id,product_name,date,unit_price,quantity,unit_discount,tax):  
        self.product_id = product_id
        self.product_name = product_name
        self.date = date
        self.unit_price = unit_price
        self.quantity = quantity
        self.unit_discount = unit_discount
        self.tax = tax</pre></li>
<li>In this step, we will add a method to <code>Inventory</code> to calculate the amount before tax and, in this method, we will have three input parameters: <code>quantity</code>, <code>unit_price</code>, and <code>unit_discount</code>. If these three variables are <code>None</code>, then this method will use the same variables initiated during the instantiation of the <code>Inventory</code> class to calculate the amount before tax:<pre>def calc_amount_before_tax(self,quantity=None,unit_price=None, unit_discount=None):
        if quantity is None:
            self.quantity = self.quantity
        else:
            self.quantity = quantity
            
        if unit_price is None:
            self.unit_price = self.unit_price
        else:
            self.unit_price = unit_price
        
        if unit_discount is None:
            self.unit_discount = self.unit_discount
        else:
            self.unit_discount = unit_discount
        amount_before_tax = self.quantity * 
           (self.unit_price - self.unit_discount)
        return amount_before_tax</pre></li>
<li>We will also add <a id="_idIndexMarker236"/>another method to the <code>Inventory</code> class to calculate the amount after tax. This method is <a id="_idIndexMarker237"/>also defined in a similar pattern as <code>calc_amount_before_tax</code>:<pre>def calc_amount_after_tax(self, quantity=None,unit_price=None,unit_discount=None,tax=None):
        if quantity is None:
            self.quantity = self.quantity
        else:
            self.quantity = quantity
            
        if unit_price is None:
            self.unit_price = self.unit_price
        else:
            self.unit_price = unit_price
        
        if unit_discount is None:
            self.unit_discount = self.unit_discount
        else:
            self.unit_discount = unit_discount
            
        if tax is None:
            self.tax = self.tax
        else:
            self.tax = tax
        amount_after_tax = 
            self.calc_amount_before_tax(
            self.quantity,self.unit_price,
            self.unit_discount) + self.tax
        return amount_after_tax</pre></li>
<li>We will now create the last method for this class, which returns the consolidated <a id="_idIndexMarker238"/>inventory details, creates<a id="_idIndexMarker239"/> a DataFrame, and returns the DataFrame:<pre>    def return_inventory(self):
        import pandas as pd
        inventory_schema = pd.DataFrame([
                           self.product_id,
                           self.product_name,
                           self.date,
                           self.unit_price,
                           self.quantity,
                           self.unit_discount,
                           self.tax,
                           self.calc_unt_before_tax(),
            self.calc_amount_after_tax()]).transpose()
        inventory_schema.columns = ["Product_id",
            "Product_name","Date","Unit_price",
            "Quantity","Unit_discount","Tax",
            "Amount Before Tax", "Amount After Tax"]
        return inventory_schema    </pre></li>
<li>Then, create an object for the <code>Inventory</code> class and initialize its attributes:<pre>inventory = Inventory(300021,
                'Samsung-Refrigerator',
                '08/04/2021',
                200,
                25,
                10,
                0.0522)</pre></li>
<li>Check whether <a id="_idIndexMarker240"/>the object returns the<a id="_idIndexMarker241"/> attributes:<pre>inventory.product_id
<strong class="bold">300021</strong>
inventory.product_name
<strong class="bold">'Samsung-Refrigerator'</strong>
inventory.date
<strong class="bold">'08/04/2021'</strong>
inventory.unit_price
<strong class="bold">200</strong>
inventory.quantity
<strong class="bold">25</strong>
inventory.unit_discount
<strong class="bold">10</strong>
inventory.tax
<strong class="bold">0.0522</strong>
inventory.calc_amount_before_tax()
<strong class="bold">4750</strong>
inventory.calc_amount_after_tax()
<strong class="bold">4750.0522</strong>
inventory.return_inventory()</pre></li>
</ol>
<p>The output of the preceding code is as follows:</p>
<div><div><img alt="Figure 5.3 – The output – Inventory details  " height="182" src="img/Figure_5.3_B13426.jpg" width="1648"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – The output – Inventory details </p>
<ol>
<li value="7">Next, let’s make <a id="_idIndexMarker242"/>use of <code>dir</code> to list down <a id="_idIndexMarker243"/>all the names of arguments in the <code>Inventory</code> class:<pre>dir(Inventory)
['__class__',
 '__delattr__',
 '__dict__',
 ‚__dir__',
 ‚__doc__',
 ‚__eq__',
 ‚__format__',
 ‚__ge__',
 ‚__getattribute__',
 ‚__gt__',
 ‚__hash__',
 ‚__init__',
 ‚__init_subclass__',
 ‚__le__',
 ‚__lt__',
 ‚__module__',
 ‚__ne__',
 ‚__new__',
 ‚__reduce__',
 ‚__reduce_ex__',
 ‚__repr__',
 ‚__setattr__',
 ‚__sizeof__',
 ‚__str__',
 ‚__subclasshook__',
 ‚__weakref__',
 ‚calc_amount_after_tax',
 ‚calc_amount_before_tax',
 ‚return_inventory']</pre></li>
<li>Now, let’s make use of <code>hasattr</code> to check whether the class has attributes. If the type of attribute <a id="_idIndexMarker244"/>is a method, then <a id="_idIndexMarker245"/>use <code>getattr</code> to get the attributes. Executing the following loop results in the list of all the attributes of <code>Inventory</code>:<pre>for i in dir(Inventory):
     if (hasattr(Inventory,i)):
            if type(getattr(inventory, i)) is type(getattr(inventory,  '__init__')):
                print(getattr(Inventory,i))&lt;class 'type'&gt;
<strong class="bold">&lt;function Inventory.__init__ at 0x000001C9BBB46CA0&gt;</strong>
<strong class="bold">&lt;function Inventory.calc_amount_after_tax at 0x000001C9BBB46DC0&gt;</strong>
<strong class="bold">&lt;function Inventory.calc_amount_before_tax at 0x000001C9BBB46D30&gt;</strong>
<strong class="bold">&lt;function Inventory.return_inventory at 0x000001C9BBB46E50&gt;</strong></pre></li>
</ol>
<p>With this understanding, we can <a id="_idIndexMarker246"/>further look into <a id="_idIndexMarker247"/>another built-in function, <code>isinstance</code>.</p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor075"/>Checking whether an object is an instance</h1>
<p>In this section, we will look at<a id="_idIndexMarker248"/> another function named <code>isinstance</code>, which can be used to check whether an object is an instance of a particular class. As we are covering introspection in this chapter, we are more focused on what <a id="_idIndexMarker249"/>functions are available to introspect an object rather than how these functions can be used further to manipulate or debug a piece of code. <a href="B13426_06_Final_PG_epub.xhtml#_idTextAnchor080"><em class="italic">Chapter 6</em></a>, will cover the usage of these functions on metaprogramming along with examples. </p>
<p>In the preceding section, we created a class named <code>Inventory</code>. In this section, we can continue using the same class and create another object for the class. This is shown as follows:</p>
<pre class="source-code">inventory_fmcg = Inventory(100011,</pre>
<pre class="source-code">                'Delmonte Ketchup',</pre>
<pre class="source-code">                '09/04/2021',</pre>
<pre class="source-code">                5,</pre>
<pre class="source-code">                0.25,</pre>
<pre class="source-code">                0.10,</pre>
<pre class="source-code">                0.0522)</pre>
<pre class="source-code">inventory_fmcg.product_id</pre>
<pre class="source-code"><strong class="bold">100011</strong></pre>
<pre class="source-code">inventory_fmcg.calc_amount_before_tax()</pre>
<pre class="source-code"><strong class="bold">1.225</strong></pre>
<pre class="source-code">inventory_fmcg.calc_amount_after_tax()</pre>
<pre class="source-code"><strong class="bold">1.2772000000000001</strong></pre>
<pre class="source-code">inventory_fmcg.return_inventory()</pre>
<p>The output of the preceding code is as follows:</p>
<div><div><img alt="Figure 5.4 – The output – Inventory details of inventory_fmcg " height="191" src="img/Figure_5.4_B13426.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – The output – Inventory details of inventory_fmcg</p>
<p>Now, let’s <a id="_idIndexMarker250"/>check whether <code>inventory_fmcg</code> is an <a id="_idIndexMarker251"/>object of the <code>Inventory</code> class using <code>isinstance</code>:</p>
<pre class="source-code">isinstance(inventory_fmcg,Inventory)
<strong class="bold">True</strong></pre>
<p>Similarly, we can also check whether the previously created <code>inventory</code> object is still an instance of the <code>Inventory</code> class:</p>
<pre class="source-code">isinstance(inventory,Inventory)
<strong class="bold">True</strong></pre>
<p>Let’s consider a scenario where we have reallocated the object inventory to another value by mistake while writing the code, and we might still need to make use of the object and call its methods to return the inventory details. To test this scenario using <code>isinstance</code>, we can look at the following steps:</p>
<ol>
<li value="1">Check whether an object is an instance of the <code>Inventory</code> class and call a method of the function. If the object is not an instance of the class, check the type of variable to which it has been reallocated:<pre>if isinstance(inventory,Inventory):
    display(inventory.return_inventory())
else:
    print("Object reallocated to",  type(inventory), 
          ", please correct it")</pre></li>
<li>The preceding code results in the following output since <code>inventory</code> is still an object of the <code>Inventory</code> class:</li>
</ol>
<div><div><img alt="Figure 5.5 – The output – Inventory details " height="187" src="img/Figure_5.5_B13426.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – The output – Inventory details</p>
<ol>
<li value="3">Now, let’s reallocate<a id="_idIndexMarker252"/> the <code>inventory</code> variable to some other string value and call the <code>return_inventory</code> method <a id="_idIndexMarker253"/>on it:<pre>inventory = "test"</pre></li>
<li>Calling the <code>return_inventory</code> method for the <code>inventory</code> object will result in the following error:</li>
</ol>
<div><div><img alt="Figure 5.6 – Error on calling the return_inventory method on a reallocated object " height="123" src="img/Figure_5.6_B13426.jpg" width="651"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Error on calling the return_inventory method on a reallocated object</p>
<ol>
<li value="5">To avoid the preceding error and to let the code handle this error gracefully and, at the same time, provide more information to the developer, we can modify the code as follows <a id="_idIndexMarker254"/>using the <code>isinstance</code> method:<pre>if isinstance(inventory,Inventory):
    print(inventory.return_inventory())
else:
    print("Object reallocated to",  type(inventory), 
          ", please correct it")</pre></li>
</ol>
<p>The output of the preceding code is as follows:</p>
<pre class="source-code"><strong class="bold">Object reallocated to &lt;class 'str'&gt; , please correct it</strong></pre>
<p>With this understanding, we<a id="_idIndexMarker255"/> can look further into another in-built function, <code>issubclass</code>.</p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor076"/>Checking whether an object is a subclass</h1>
<p>In this section, we <a id="_idIndexMarker256"/>will look at the <code>issubclass</code> function. This function is used to check whether a given input class is actually a child class or a <a id="_idIndexMarker257"/>subclass of a specific parent class. To introspect a class using this function, let’s look at the following steps:</p>
<ol>
<li value="1">Create an <code>FMCG</code> class by initializing variables for supplier information such as <code>supplier_name</code>, <code>supplier_code</code>, <code>supplier_address</code>, <code>supplier_contract_start_date</code>, <code>supplier_contract_end_date</code>, and <code>supplier_quality_code</code>, shown as follows:<pre>class FMCG:
    def __init__(self,supplier_name,supplier_code,
       supplier_address,supplier_contract_start_date,\
    supplier_contract_end_date,supplier_quality_code):
        self.supplier_name = supplier_name
        self.supplier_code = supplier_code
        self.supplier_address = supplier_address
        self.supplier_contract_start_date = 
             supplier_contract_start_date
        self.supplier_contract_end_date = 
             supplier_contract_end_date
        self.supplier_quality_code = 
             supplier_quality_code</pre></li>
<li>Add a method in the class to simply get the supplier details initialized in the class and return it as a <a id="_idIndexMarker258"/>dictionary object <a id="_idIndexMarker259"/>with a key and a value:<pre>    def get_supplier_details(self):
        supplier_details = {
           'Supplier_name': self.supplier_name, 
            'Supplier_code': self.supplier_code,
            'Supplier_address': self.supplier_address,
            'ContractStartDate': 
                    self.supplier_contract_start_date,
            'ContractEndDate': 
                      self.supplier_contract_end_date, 
            'QualityCode': self.supplier_quality_code
        }
        return supplier_details</pre></li>
<li>Create an object for the <code>FMCG</code> class and initialize the variables with supplier data and then display the supplier details by calling the preceding method:<pre>fmcg = FMCG('Test Supplier','a0015','5093 9th Main Street, Pasadena,California, 91001', '05/04/2020', '05/04/2025',1)
fmcg.get_supplier_details()
{'Supplier_name': 'Test Supplier',
 'Supplier_code': 'a0015',
 'Supplier_address': '5093 9th Main Street, 
    Pasadena,California, 91001',
 'ContractStartDate': '05/04/2020',
 'ContractEndDate': '05/04/2025',
 'QualityCode': 1}</pre></li>
<li>Here, we can then create another <a id="_idIndexMarker260"/>class for condiments that covers both inventory details and<a id="_idIndexMarker261"/> FMCG supplier details by inheriting this class from both the <code>FMCG</code> class and the <code>Inventory</code> class. This class will be initialized with all the product-level inventory variables and the supplier-level variables:<pre>class Condiments(FMCG,Inventory):
    def __init__(self,*inventory):
        self.product_id = inventory[0]
        self.product_name = inventory[1]
        self.date = inventory[2]
        self.unit_price = inventory[3]
        self.quantity = inventory[4]
        self.unit_discount = inventory[5]
        self.tax = inventory[6]
        self.supplier_name = inventory[7]
        self.supplier_code = inventory[8]
        self.supplier_address = inventory[9]
        self.supplier_contract_start_date = 
                                inventory[10]
        self.supplier_contract_end_date = 
                                inventory[11]
        self.supplier_quality_code = inventory[12]</pre></li>
<li>Then, let’s add a method to simply return all the variables initialized in the <code>Condiments</code> class by<a id="_idIndexMarker262"/> storing them as a<a id="_idIndexMarker263"/> DataFrame or table:<pre>    def return_condiment_inventory(self):
        import pandas as pd
        inventory_schema = pd.DataFrame([
                        self.product_id,
                        self.date,
                        self.unit_price,
                        self.quantity,
                        self.unit_discount,
                        self.tax,
                        self.calc_amount_before_tax(),
                        self.calc_amount_after_tax(),
                        self.get_supplier_details()
                                       ]).transpose()
        inventory_schema.columns = ["Product_id",
            "Date","Unit_price","Quantity",
            "Unit_discount","Tax","Amount Before Tax", 
            "Amount After Tax",'Supplier_details']
        return inventory_schema          </pre></li>
<li>We can now<a id="_idIndexMarker264"/> create an object<a id="_idIndexMarker265"/> for this class and call its method:<pre>ketchup = Condiments(100011,'Delmonte Ketchup','09/04/2021',5,0.25,0.10,0.0522,'Test Supplier','a0015','5093 9th Main Street, Pasadena,California, 91001', '05/04/2020', '05/04/2025',1)
ketchup.return_condiment_inventory()</pre></li>
<li>Executing the preceding code results in the following output:</li>
</ol>
<div><div><img alt="Figure 5.7 – The output – Condiment inventory details " height="250" src="img/Figure_5.7_B13426.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – The output – Condiment inventory details</p>
<ol>
<li value="8">Now let’s check whether the <code>FMCG</code> class is a subclass of <code>Inventory</code>. It will return as <code>False</code> since FMCG is not a subclass of <code>Inventory</code>:<pre>issubclass(FMCG,Inventory)
<strong class="bold">False</strong></pre></li>
<li>In this step, we will check whether <code>Condiments</code> is a subclass of <code>FMCG</code> and also whether it is a subclass of <code>Inventory</code>. Both should return as <code>True</code> since <code>Condiments</code> is inherited from both of these classes:<pre>issubclass(Condiments,FMCG)
<strong class="bold">True</strong>
issubclass(Condiments,Inventory)
<strong class="bold">True</strong></pre></li>
<li>Next, we will be creating an object for a class by, first, checking whether a class is a subclass of a specific <a id="_idIndexMarker266"/>parent class, then<a id="_idIndexMarker267"/> creating an object accordingly, and then calling a method on the newly created object:<pre>if issubclass(Condiments,FMCG):
    fmcg = Condiments(100011,'Delmonte 
      Ketchup','09/04/2021',5,0.25,0.10,0.0522,
      'Test Supplier','a0015','5093 9th Main Street, 
      Pasadena,California, 91001', '05/04/2020', 
      '05/04/2025',1)
else:
    fmcg = FMCG('Test Supplier','a0015','5093 9th Main
      Street, Pasadena,California, 91001', 
      '05/04/2020', '05/04/2025',1)
display(fmcg.get_supplier_details())</pre></li>
<li>Executing the preceding code results in the following output:<pre><strong class="bold">{'Supplier_name': 'Test Supplier',</strong>
<strong class="bold"> 'Supplier_code': 'a0015',</strong>
<strong class="bold"> 'Supplier_address': '5093 9th Main Street, </strong>
<strong class="bold">    Pasadena,California, 91001',</strong>
<strong class="bold"> 'ContractStartDate': '05/04/2020',</strong>
<strong class="bold"> 'ContractEndDate': '05/04/2025',</strong>
<strong class="bold"> 'QualityCode': 1}</strong></pre></li>
</ol>
<p>With this understanding, we can look<a id="_idIndexMarker268"/> further into the last topic of this chapter.</p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor077"/>Understanding the usage of property</h1>
<p>In this section, we will look at the last built-in function <a id="_idIndexMarker269"/>covered in this chapter, <code>property</code>. This function is used to initialize, set, get, or delete methods of attributes in Python. These values are called the properties of an object. Let’s first understand how <code>property</code> works on Python objects by creating an example.</p>
<p>We can create a property by simply calling the <code>property</code> function and storing it as a variable. Refer to the following code:</p>
<pre class="source-code">test_property = property()</pre>
<pre class="source-code">test_property</pre>
<pre class="source-code"><strong class="bold">&lt;property at 0x1c9c9335950&gt;</strong></pre>
<p>We still did not answer the question of how this function creates a property. The <code>property</code> function takes in four variables to get, set, delete, and document the properties of an attribute. To examine it further, let’s look at it in a little more detail. The steps are as follows:</p>
<ol>
<li value="1">Create a class named <code>TestPropertyClass</code>. </li>
<li>Initialize it with a <code>test</code> attribute and set it as <code>None</code>. </li>
<li>We will then add three methods to perform the functions of getting, setting, and deleting the initialized <code>test</code> attribute. </li>
<li>We will then create another variable within the class named <code>test_attr</code> and assign the <code>property</code> function<a id="_idIndexMarker270"/> to it with the <code>get</code>, <code>set</code>, and <code>delete</code> methods created in this class.</li>
</ol>
<p> The code for this example is as follows:</p>
<pre class="source-code">class TestPropertyClass:</pre>
<pre class="source-code">    def __init__(self):</pre>
<pre class="source-code">        self._test_attr = None</pre>
<pre class="source-code">    def get_test_attr(self):</pre>
<pre class="source-code">        print("get test_attr")</pre>
<pre class="source-code">        return self._test_attr</pre>
<pre class="source-code">    def set_test_attr(self, value):</pre>
<pre class="source-code">        print("set test_attr")</pre>
<pre class="source-code">        self._test_attr = value</pre>
<pre class="source-code">    def del_test_attr(self):</pre>
<pre class="source-code">        print("del test_attr")</pre>
<pre class="source-code">        del self._test_attr</pre>
<pre class="source-code">    test_attr = property(get_test_attr, set_test_attr, </pre>
<pre class="source-code">        del_test_attr, "test_attr is a property")</pre>
<p>In the preceding code, <code>get_test_attr</code> simply returns the <code>test</code> attribute,<code> set_test_attr</code> sets a value to the <code>test</code> attribute, and <code>del_test_attr</code> deletes the <code>test</code> attribute. </p>
<p>Let’s now create an object for this class and check how <code>property</code> works on it:</p>
<pre class="source-code">test_property_object = TestPropertyClass()</pre>
<pre class="source-code">test_property_object.test_attr</pre>
<pre class="source-code"><strong class="bold">get test_attr</strong></pre>
<p>In the preceding code, calling the <code>test</code> attribute has, in turn, invoked the <code>get_test_attr</code> method since it is provided as the <code>get</code> method to the <code>property</code> function. Let’s confirm this understanding further by setting a value to <code>test_attr</code>:</p>
<pre class="source-code">test_property_object.test_attr = 1980</pre>
<pre class="source-code"><strong class="bold">set test_attr</strong></pre>
<p>Assigning a value to the <code>test_attr</code> variable has now invoked the <code>set_test_attr</code> method since it is provided as a <code>set</code> method to the <code>property</code> function. Calling the <code>test_attr</code> attribute again returns the <a id="_idIndexMarker271"/>value set in the preceding step:</p>
<pre class="source-code">test_property_object.test_attr</pre>
<pre class="source-code"><strong class="bold">get test_attr</strong></pre>
<pre class="source-code"><strong class="bold">1980</strong></pre>
<p>Similarly, deleting the attribute, in turn, invokes the <code>del_test_attr</code> method since it is provided as a <code>delete</code> method to the <code>property</code> function:</p>
<pre class="source-code">del test_property_object.test_attr</pre>
<pre class="source-code"><strong class="bold">del test_attr</strong></pre>
<p>Once the attribute is deleted, the <code>get</code> method will still be invoked while calling the attribute, but it will not return the value previously assigned since it is deleted:</p>
<pre class="source-code">test_property_object.test_attr</pre>
<p>The output of the preceding code would now look as follows:</p>
<div><div><img alt="Figure 5.8 – The get method invoked on a deleted attribute " height="278" src="img/Figure_5.8_B13426.jpg" width="658"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – The get method invoked on a deleted attribute</p>
<p>By modifying the behavior of the <code>getter</code>, <code>setter</code>, or <code>deleter</code> methods, we can modify the properties of the <a id="_idIndexMarker272"/>attribute itself. We will look at this statement in detail in <a href="B13426_06_Final_PG_epub.xhtml#_idTextAnchor080"><em class="italic">Chapter 6</em></a>.</p>
<p>With this understanding of assigning the <code>property</code> function to a variable and then invoking its <code>getter</code>, <code>setter</code>, and <code>deleter</code> methods, we will further look into another variation of implementing <code>property</code>.</p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor078"/>Using property as a decorator</h1>
<p>In the preceding section, we looked at <a id="_idIndexMarker273"/>how to use <code>property</code> as a function to modify the properties of an attribute in a class. In this section, we will look at how to use <code>property</code> as a decorator. Let’s consider the same <code>TestPropertyClass</code> as in the preceding example and modify the class definition to use the <code>@property</code> decorator statement instead of the <code>property()</code> function statement. Refer to the following code:</p>
<pre class="source-code">class TestPropertyClass:</pre>
<pre class="source-code">    def __init__(self):</pre>
<pre class="source-code">        self._test_attr = None</pre>
<pre class="source-code">    @property</pre>
<pre class="source-code">    def test_attr(self):</pre>
<pre class="source-code">        return self.test_attr</pre>
<pre class="source-code">    @test_attr.getter</pre>
<pre class="source-code">    def test_attr(self):</pre>
<pre class="source-code">        print("get test_attr")</pre>
<pre class="source-code">        return self._test_attr</pre>
<pre class="source-code">    @test_attr.setter</pre>
<pre class="source-code">    def test_attr(self, value):</pre>
<pre class="source-code">        print("set test_attr")</pre>
<pre class="source-code">        self._test_attr = value</pre>
<pre class="source-code">    @test_attr.deleter</pre>
<pre class="source-code">    def test_attr(self):</pre>
<pre class="source-code">        print("del test_attr")</pre>
<pre class="source-code">        del self._test_attr</pre>
<p>In the preceding code, we have added <code>@property</code> as the decorator for <code>test_attr</code>, and we have also added <code>@test_attr.setter</code> for the <code>set</code> method, <code>@test_attr.getter</code> for the <code>get</code> method, and <code>@test_attr.deleter</code> for the <code>delete</code> method. </p>
<p>Let’s proceed with executing the <a id="_idIndexMarker274"/>code further to check whether <code>getter</code>, <code>setter</code>, and <code>deleter</code> are working as expected:</p>
<pre class="source-code">test_property_object = TestPropertyClass()</pre>
<pre class="source-code">test_property_object.test_attr</pre>
<pre class="source-code"><strong class="bold">get test_attr</strong></pre>
<p>In the preceding code, calling the attribute invoked the <code>getter</code> method. Similarly, <code>setter</code> and <code>deleter</code> also invoked the <code>set</code> and <code>delete</code> methods, respectively:</p>
<pre class="source-code">test_property_object.test_attr = 1982</pre>
<pre class="source-code"><strong class="bold">set test_attr</strong></pre>
<pre class="source-code">test_property_object.test_attr</pre>
<pre class="source-code"><strong class="bold">get test_attr</strong></pre>
<pre class="source-code"><strong class="bold">1982</strong></pre>
<pre class="source-code">del test_property_object.test_attr</pre>
<pre class="source-code"><strong class="bold">del test_attr</strong></pre>
<p>These are some of the <a id="_idIndexMarker275"/>examples of how introspection can be applied to Python objects using Python’s built-in functions.</p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor079"/>Summary</h1>
<p>In this chapter, we have learned how to introspect Python objects using built-in functions.</p>
<p>We then saw how to use the <code>id</code> function, and how to debug code using <code>id</code>. We also looked at how to check whether an object is callable, how to check whether an object has an attribute, how to check whether an object is an instance, how to check whether an object is a subclass, and finally, we looked at how to get, set, and delete properties on attributes. From all of these concepts, we learned how to inspect Python objects such as classes, methods, and functions. From the examples covered under each topic, we also learned how to apply introspection in practical use cases.</p>
<p>In the next chapter, we will be extending the learning from introspection and applying it further to understand reflection on Python objects.</p>
</div>
</div></body></html>