<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Advanced Django in PTVS"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Advanced Django in PTVS</h1></div></div></div><p>Once we look at how a Django development environment in Visual Studio with PTVS is set up, we can start analyzing some powerful libraries for Django and how to use them in Visual Studio. Over the years, lots of developers have created powerful libraries and tools for Django that speed up various aspects of the development cycle. We are going to take a closer look at some of them here to see how they integrate in Visual Studio and PTVS.</p><p>In this chapter, we will analyze two libraries that are useful for a Django developer in two different aspects: automatizing tasks using the Fabric library, and managing model migrations on Django with South.</p><div class="section" title="Library management"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Library management</h1></div></div></div><p>We have already learned how to install new packages in PTVS using the GUI tools that it provides. Now, we will learn more about the criteria for choosing one package index over another; in other words, when to choose <code class="literal">easy_install</code> over <code class="literal">pip</code>.</p><p>Generally speaking, using <code class="literal">pip</code> is much better than using <code class="literal">easy_install</code>, and there are major reasons for this. As Ian Bicking, the creator of <code class="literal">pip</code>, wrote in his own introduction to <code class="literal">pip</code>, the <a id="id188" class="indexterm"/>advantages are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">All packages are downloaded before installation. As a result, partially completed installation doesn't occur.</li><li class="listitem" style="list-style-type: disc">Care is taken when presenting useful output on the console.</li><li class="listitem" style="list-style-type: disc">The reasons for actions are being tracked. For instance, if a package is being installed, <code class="literal">pip</code> keeps track of why that package was required.</li><li class="listitem" style="list-style-type: disc">Error messages should be useful.</li><li class="listitem" style="list-style-type: disc">The code is relatively concise and cohesive, making it easier to use programmatically.</li><li class="listitem" style="list-style-type: disc">Packages don't have to be installed as egg archives; they can be installed flat (while keeping the egg metadata).</li><li class="listitem" style="list-style-type: disc">Native support is available for other version control systems (<code class="literal">Git</code>, <code class="literal">Mercurial</code>, and <code class="literal">Bazaar</code>).</li><li class="listitem" style="list-style-type: disc">Uninstallation of packages is easy.</li><li class="listitem" style="list-style-type: disc">It is<a id="id189" class="indexterm"/> simple to define, has fixed sets of requirements, and reliably reproduces a set of packages.</li></ul></div><p>It may seem that there are no reasons to choose <code class="literal">easy_install</code> over <code class="literal">pip</code>. However, this is where careful consideration is needed.</p><p>There is a caveat that makes the choice really hard for Windows environments: some libraries or dependencies are written in Python C, which is a way for Python to call libraries written in C/C++. To compile these libraries on your Windows machine, you have to install the exact same version of the original compiler that has been used to compile to the original interpreter. For example, you will need the C++ compiler of Visual Studio 2008 if you use Python 2.7 or Visual Studio 2010 for Python 3.</p><p>This is due to a long tradition where Python extension modules must be built with the same compiler version (more specifically, a CRT version) as Python itself, which is mentioned at <a class="ulink" href="https://mail.python.org/pipermail/python-list/2010-April/573606.html">https://mail.python.org/pipermail/python-list/2010-April/573606.html</a>.</p><p>Using the <code class="literal">easy_install</code> package installer, the precompiled packages are downloaded and installed into the system's <code class="literal">site-packages</code> folder.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>A rule of thumb: if the library you are trying to install on your Windows machine has Python C extensions in it, it's far better to choose <code class="literal">easy_install</code>. For all other cases, <code class="literal">pip</code> is way better.</p></div></div><p>If you don't know what kind of library you are importing, you should go with <code class="literal">pip</code>. If it encounters a problem during the compilation process of the installation, you can uninstall the library and reinstall it using <code class="literal">easy_install</code>.</p><p>Generally, most libraries that have low-level capabilities (for example, cryptography, graphics, and mathematical functions) and interaction with other software (for example, drivers) use Python C extensions.</p></div></div>
<div class="section" title="The Fabric library &#x2013; the deployment and development task manager"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec30"/>The Fabric library – the deployment and development task manager</h1></div></div></div><p>Fabric is<a id="id190" class="indexterm"/> a Python library and a command-line tool that allows execution in application deployment and administration tasks. Essentially, Fabric is a tool that allows the developer to execute arbitrary Python functions via the command line and also a set of functions in order to execute shell commands on remote servers via SSH. Combining these two things together offers developers a powerful way to administrate the application workflow without having to remember the series of commands that need to be executed on the command line.</p><p>The library<a id="id191" class="indexterm"/> documentation can be found at <a class="ulink" href="http://fabric.readthedocs.org/">http://fabric.readthedocs.org/</a>.</p><p>Installing the library in PTVS is straightforward. Like all other libraries, to insert this library into a Django project, right-click on the <span class="strong"><strong>Python 2.7</strong></span> node in <span class="strong"><strong>Python Environments</strong></span> of the <span class="strong"><strong>Solution Explorer</strong></span> window. Then, select the <span class="strong"><strong>Install Python Package</strong></span> entry.</p><div class="mediaobject"><img src="graphics/8687OS_05_01.jpg" alt="The Fabric library – the deployment and development task manager"/><div class="caption"><p>The Python environment contextual menu</p></div></div><p>Clicking on it brings up the <span class="strong"><strong>Install Python Package</strong></span> modal window as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8687OS_05_02.jpg" alt="The Fabric library – the deployment and development task manager"/></div><p>It's important<a id="id192" class="indexterm"/> to use <code class="literal">easy_install</code> to download from the Python package index. This will bring the precompiled versions of the library into the system instead of the plain Python C libraries that have to be compiled on the system.</p><p>Once the package is installed in the system, you can start creating tasks that can be executed outside your application from the command line. First, create a configuration file, <code class="literal">fabfile.py</code>, for Fabric. This file contains the tasks that Fabric will execute.</p><div class="mediaobject"><img src="graphics/8687OS_05_03.jpg" alt="The Fabric library – the deployment and development task manager"/></div><p>The previous screenshot shows a really simple task: it prints out the string <code class="literal">hello world</code> once it's executed. You can execute it from the command prompt by using the Fabric command <code class="literal">fab</code>, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8687OS_05_04.jpg" alt="The Fabric library – the deployment and development task manager"/></div><p>Now that you<a id="id193" class="indexterm"/> know that the system is working fine, you can move on to the juicy part where you can make some tasks that interact with a remote server through <code class="literal">ssh</code>. Create a task that connects to a remote machine and find out the type of OS that runs on it.</p><div class="mediaobject"><img src="graphics/8687OS_05_05.jpg" alt="The Fabric library – the deployment and development task manager"/><div class="caption"><p>The env object provides a way to add credentials to Fabric in a programmatic way</p></div></div><p>We have defined a Python function, <code class="literal">host_type</code>, that runs a POSIX command, <code class="literal">uname –s</code>, on the remote. We also set up a couple of variables to tell Fabric which is the remote machine we are connecting to, i.e. <code class="literal">env.hosts</code>, and the password that has to be used to access that machine, i.e. <code class="literal">env.password</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>It's never a good idea to put plain passwords into the source code, as is shown in the preceding screenshot example.</p></div></div><p>Now, we can execute the <code class="literal">host_type</code> task in the command line as follows:</p><div class="mediaobject"><img src="graphics/8687OS_05_06.jpg" alt="The Fabric library – the deployment and development task manager"/></div><p>The Fabric<a id="id194" class="indexterm"/> library connects to the remote machine with the information provided and executes the command on the server. Then, it brings back the result of the command itself in the output part of the response.</p><p>We can also create tasks that accept parameters from the command line. Create a task that echoes a message on the remote machine, starting with a parameter as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8687OS_05_07.jpg" alt="The Fabric library – the deployment and development task manager"/></div><p>The following are two examples of how the task can be executed:</p><div class="mediaobject"><img src="graphics/8687OS_05_08.jpg" alt="The Fabric library – the deployment and development task manager"/></div><p>We can also create a helper function that executes an arbitrary command on the remote machine as follows:</p><div class="informalexample"><pre class="programlisting">def execute(cmd):
    run(cmd)</pre></div><p>We are also <a id="id195" class="indexterm"/>able to upload a file into the remote server by using <code class="literal">put</code>:</p><div class="mediaobject"><img src="graphics/8687OS_05_09.jpg" alt="The Fabric library – the deployment and development task manager"/></div><p>The first argument of <code class="literal">put</code> is the local file you want to upload and the second one is the destination folder's filename. Let's see what happens:</p><div class="mediaobject"><img src="graphics/8687OS_05_10.jpg" alt="The Fabric library – the deployment and development task manager"/><div class="caption"><p>Deploying process with Fabric</p></div></div><p>The possibilities of using Fabric are really endless, since the tasks can be written in plain Python language. This provides the opportunity to automate many operations and focus more on the development instead of focusing on how to deploy your code to servers to maintain them.</p></div>
<div class="section" title="South &#x2013; the database deployment library"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec31"/>South – the database deployment library</h1></div></div></div><p>Developed by the Python community, South is a Django library that brings schema migration to Django applications. The South library's main objective is to provide a simple, stable, and database-independent migration layer to prevent all the hassles of schema changes.</p><p>The key<a id="id196" class="indexterm"/> features of South are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Automatic migration creation</strong></span>: South can detect what's changed in your application model by analyzing your <code class="literal">model.py</code> files and automatically creating the migration code—basically the SQL commands for the database you are using—that matches the changes in the models.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Database independence</strong></span>: South is database agnostic, supporting different database backends. Currently, South supports PostgreSQL, MySQL, SQLite, Microsoft SQL Server, Oracle, and Firebird (beta support).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>App-savvy</strong></span>: South knows and works with the concept of Django applications, allowing developers to use migrations on only some of the applications and not on the whole project.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>VCS-proof</strong></span>: South will notice when someone else commits migrations to the same application and can check if there are conflicts.</li></ul></div><div class="section" title="Why use South with Django"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec17"/>Why use South with Django</h2></div></div></div><p>One <a id="id197" class="indexterm"/>of the most interesting parts of Django is its <span class="strong"><strong>Object-relational mapping</strong></span> (<span class="strong"><strong>ORM</strong></span>), which creates a consistent abstraction of the database <a id="id198" class="indexterm"/>structure. This is a very powerful tool that allows<a id="id199" class="indexterm"/> programmers to focus on the Python code. Django takes good care of the database structure management only for new models (for example, when creating them). It doesn't have an out-of-the-box solution to manage updates in the models that can be applied to existing database schemas.</p><p>It's usually a painful operation to change the model during the application lifecycle. Technically, when changing the schema of the model or when migrating the schema, whether you are modifying a field or adding another one, the database structure needs to be recreated. This means that all the data of that model is lost, or a manual migration needs to be done to move the data from the old version of the tables to the new one on the database. This is especially time consuming if you have to align that database from a development server environment to a production server environment.</p></div><div class="section" title="Installing South"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec18"/>Installing South</h2></div></div></div><p>Let's see<a id="id200" class="indexterm"/> how to bring South into PTVS. Like other Python libraries, we can install it from the <span class="strong"><strong>Solution Explorer</strong></span> window by right-clicking on the environment of your choice (Python 2.7) and selecting <span class="strong"><strong>Install Python Package</strong></span> to bring up the following installation dialog box:</p><div class="mediaobject"><img src="graphics/8687OS_05_11.jpg" alt="Installing South"/></div><p>As stated in the South documentation, you have to use the <code class="literal">easy_install</code> <span class="strong"><strong>Python Package Index</strong></span>; be sure to select it.</p><p>Once the package is installed, it's important to make sure that it's activated in the settings file. To do so, add <code class="literal">south</code> at the end of the code for <code class="literal">Installed_Apps</code>.</p><div class="mediaobject"><img src="graphics/8687OS_05_12.jpg" alt="Installing South"/><div class="caption"><p>Be sure that the "south" library is the last in the "Installed_Apps" section in Settings.py</p></div></div><p>South<a id="id201" class="indexterm"/> needs to be the last package of the list due to the fact that when Django executes the library, all the models of the Django project are already created and are discoverable by South.</p><p>To test if everything is working, navigate to the Django shell and try to import the library. Ordinary Python developers will go to the command line and run the <code class="literal">manage.py</code> shell, but in PTVS, there's a panel for this. To open it, quickly right-click on the <span class="strong"><strong>Django</strong></span> project entry in the <span class="strong"><strong>Solution Explorer</strong></span> window and select the <span class="strong"><strong>Open Django</strong></span> <span class="strong"><strong>Shell</strong></span> option in <span class="strong"><strong>Django</strong></span>:</p><div class="mediaobject"><img src="graphics/8687OS_05_13.jpg" alt="Installing South"/></div><p>This opens a new <span class="strong"><strong>Django Management Console</strong></span> panel, which is basically a REPL but with Django integration. From here, it's possible to see if the South library is working correctly by trying to import the library:</p><div class="mediaobject"><img src="graphics/8687OS_05_14.jpg" alt="Installing South"/></div><p>IntelliSense is active in the Django shell, so if you see <span class="strong"><strong>south</strong></span> appear, then everything is working fine.</p><p>To finish<a id="id202" class="indexterm"/> the initialization process, run <code class="literal">sync_db </code>for South to create the migration-tracking tables. This can also be done from the Django contextual menu as seen earlier: just select the<span class="strong"><strong> Django Sync DB</strong></span> command in the <span class="strong"><strong>Django</strong></span> menu.</p><div class="mediaobject"><img src="graphics/8687OS_05_15.jpg" alt="Installing South"/></div><p>As shown in the preceding screenshot, this starts the synchronization process of the current models in your application on South.</p></div><div class="section" title="Schema migration with South"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec19"/>Schema migration with South</h2></div></div></div><p>Now<a id="id203" class="indexterm"/> that we have <code class="literal">south</code> installed and working<a id="id204" class="indexterm"/> in our solution, let's try to create something to test the migration. Create a new application in your project and call it <code class="literal">south2ptvs</code> by <a id="id205" class="indexterm"/>using the <span class="strong"><strong>Django app</strong></span> command in the <span class="strong"><strong>Add</strong></span> menu, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8687OS_05_16.jpg" alt="Schema migration with South"/></div><p>Don't forget to register the new application in the <code class="literal">settings.py</code> file, and make sure that <code class="literal">south</code> remains as the last entry of the <code class="literal">Installed_Apps</code> section:</p><div class="mediaobject"><img src="graphics/8687OS_05_17.jpg" alt="Schema migration with South"/></div><p>Then, open the <code class="literal">models.py</code> file of the newly created application in which we are going to define our testing model:</p><div class="mediaobject"><img src="graphics/8687OS_05_18.jpg" alt="Schema migration with South"/></div><p>Instead<a id="id206" class="indexterm"/> of using the standard Django <code class="literal">sync_db</code> command to <a id="id207" class="indexterm"/>create the schema of the <a id="id208" class="indexterm"/>model in the database, let's set up a migration for the model <code class="literal">Knight</code>. This operation will be the entry point for the entire migration history of the model.</p><p>Navigate to the command line and execute the initialization migration by executing the following command:</p><div class="informalexample"><pre class="programlisting">python manage.py schemamigration south2ptvs –-initial</pre></div><p>This will execute South's <code class="literal">schemamigration</code> command on the <code class="literal">south2pvts</code> application for the<a id="id209" class="indexterm"/> initialization process. Here is what is going to happen:</p><div class="mediaobject"><img src="graphics/8687OS_05_19.jpg" alt="Schema migration with South"/></div><p>We have successfully created the migration file but haven't applied it to <code class="literal">db</code>. Since <span class="strong"><strong>South</strong></span> works on one application at a time, the migration file in which the information of the migration is stored is created inside the <code class="literal">south2ptvs</code> folder.</p><div class="mediaobject"><img src="graphics/8687OS_05_20.jpg" alt="Schema migration with South"/><div class="caption"><p>The content of the migrations folder in the Django app</p></div></div><p>The <a id="id210" class="indexterm"/>migration files are plain files written in Python. They<a id="id211" class="indexterm"/> can be edited, but you should do it with caution and only do so when necessary.</p><p>The only thing left to do is to apply the migration to the database by calling the South library's <code class="literal">migrate</code> command<a id="id212" class="indexterm"/> on the app with the following command:</p><div class="informalexample"><pre class="programlisting">python manage.py migrate south2ptvs</pre></div><div class="mediaobject"><img src="graphics/8687OS_05_21.jpg" alt="Schema migration with South"/><div class="caption"><p>Execution of South's migration command</p></div></div><p>This will finalize the migration; now our model is ready to be modified. Future updates to the model can be easily applied to the database by South using migrations.</p><p>Update the model by adding a new field as follows:</p><div class="mediaobject"><img src="graphics/8687OS_05_22.jpg" alt="Schema migration with South"/></div><p>So, now we have to create a new migration file and then apply it to the database. To create<a id="id213" class="indexterm"/> the migration file, use the <code class="literal">schemamigration</code> command again as shown in the following command. However, instead <a id="id214" class="indexterm"/>of the <code class="literal">–-initial</code> parameter, use <code class="literal">–-auto</code>, since<a id="id215" class="indexterm"/> a migration is already defined in the model.</p><div class="informalexample"><pre class="programlisting">python manage.py schemamigration south2ptvs –-auto</pre></div><div class="mediaobject"><img src="graphics/8687OS_05_23.jpg" alt="Schema migration with South"/></div><p>To obtain the result of the migration file creation state to apply the migration to <code class="literal">db</code>, just run the<a id="id216" class="indexterm"/> following <code class="literal">migrate</code> command:</p><div class="informalexample"><pre class="programlisting">python manage.py migrate south2ptvs</pre></div><div class="mediaobject"><img src="graphics/8687OS_05_24.jpg" alt="Schema migration with South"/></div><p>If we register the model in the admin interface, we can go to the admin section of our website and see if the new field appears in the model:</p><div class="mediaobject"><img src="graphics/8687OS_05_25.jpg" alt="Schema migration with South"/></div><p>Since<a id="id217" class="indexterm"/> the migrations are stored on the files, you can <a id="id218" class="indexterm"/>apply the changes on the remote server by just copying the migration files to the server and then applying the migration on the remote system (maybe with Fabric).</p><p>For more details and insights into this powerful tool, visit the official documentation website for<a id="id219" class="indexterm"/> South at <a class="ulink" href="http://south.readthedocs.org/">http://south.readthedocs.org/</a>.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec32"/>Summary</h1></div></div></div><p>In this chapter, we took a more in-depth look into how to deal with third-party Python libraries in PTVS, the main differences between the <code class="literal">pip</code> and <code class="literal">easy_install</code> package indexes, and how they deal with precompiled libraries written with Python C extensions.</p><p>We also looked into two popular and powerful Django open source libraries, Fabric and South, which add remote task management and schema migrations to your Django projects.</p><p>In the next chapter, we will introduce IPython and its graphic power in Visual Studio in order to cover the topic of IronPython and its integration with the .NET framework.</p></div></body></html>