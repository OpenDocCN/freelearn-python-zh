- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connecting to the Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It seems that nearly every application needs to talk to the outside world sooner
    or later, and your ABQ Data Entry application is no exception. You've received
    some new feature requests that will require some interactions with remote servers
    and services.
  prefs: []
  type: TYPE_NORMAL
- en: First, the quality assurance division is doing a study of how local weather
    conditions are impacting the environmental data in each lab; they've requested
    a way to download and store local weather data in the database on demand. The
    second request is from your manager, who is still required to upload daily CSV
    files to the central corporate servers. She would like this process streamlined
    and available at a mouse click.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn to interface with the cloud in the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: In *HTTP using urllib*, you'll connect to web services and download data using
    `urllib`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *RESTful HTTP using requests*, you'll learn to interact with REST services
    using the `requests` library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *SFTP using paramiko*, you'll upload files over SSH using `paramiko`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP using urllib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every time you open a website in your browser, you're using the Hypertext Transfer
    Protocol, or HTTP. HTTP was created over 30 years ago as a way for web browsers
    to download HTML documents, but has evolved into one of the most popular client-server
    communication protocols for any number of purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Not only do we use it in the browser to view everything from plain text to streaming
    video across the internet, but applications can also use it to transfer data,
    initiate remote procedures, or distribute computing tasks.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP transaction fundamentals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A basic HTTP transaction between a client and server goes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the client creates a **request**, which it will send to the server.
    The request contains the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A **URL**, which specifies the host, port, and path to which the request is
    being made.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A **method**, also known as a verb, which tells the server what operation the
    client is requesting. The most common methods are `GET`, for retrieving data,
    and `POST`, for submitting data.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A **header**, which includes metadata in key-value pairs; for example, the type
    of content being submitted, how the content is encoded, or authorization tokens.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the request may have a **payload**, which would contain the data being
    submitted to a server; for example, a file being uploaded, or a set of key-value
    pairs from a form.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the server receives the request, it returns a **response**. The response
    contains the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A **header** containing metadata such as the size or content type of the response.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A **payload** containing the actual content of the response, such as HTML, XML,
    JSON, or binary data.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In a web browser, these interactions take place in the background, but our application
    code will deal directly with request and response objects in order to talk to
    remote HTTP servers.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP status codes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every HTTP request includes a **status code** in its header, which is a 3-digit
    number indicating the disposition of the request. The codes, defined in the HTTP
    standard, are organized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1XX status codes are informational messages sent during the processing of the
    request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2XX status codes indicate a successful request; for example, 200 is the most
    common response, indicating the request was successful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3XX status codes indicate a redirection. For example, a 301 is used to redirect
    the client to a new URL, and 304 indicates that the content hasn't been modified
    since it was last downloaded (redirecting the client to its cache).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4XX status codes indicate an error in the client's request. For example, a 403
    error indicates a forbidden request (such as a request to secure documents without
    authentication), while the well-known 404 error indicates that a non-existent
    document was requested.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5XX status codes indicate an error on the server's side, such as the generic
    500 error issued when the server encounters a bug in the web service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While web browser users typically only encounter the 4XX and 5XX errors, you
    will encounter a few different status codes as you work directly with HTTP through
    `urllib`.
  prefs: []
  type: TYPE_NORMAL
- en: Basic downloading with urllib.request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `urllib.request` module is a Python module for implementing HTTP interactions.
    It contains a number of functions and classes for generating requests, the most
    basic of which is the `urlopen()` function. This function can create a `GET` or
    `POST` request, send it to a remote server, and return an object containing the
    server's response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore how `urllib` works; open a Python shell and execute the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `urlopen()` function takes, at a minimum, a URL string. By default, it makes
    a `GET` request to the URL and returns an object that wraps the response received
    from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'This response object exposes metadata or content received from the server,
    which we can use in our application. Much of the response''s metadata is found
    in the header, which we can extract using its `getheader()` method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `getheader()` method requires a key name, and returns the value of that
    key if it is found in the header. If the key isn't found, it returns `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also extract the status code and a text explanation of the code using
    the `status` and `reason` attributes, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Remember that a `200` status means a successful request. The `OK` string is
    just a more human-readable form of the status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The payload of the response object can be retrieved using an interface similar
    to a file handle; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Just like a file handle, the response can only be read once, using the `read()`
    method; unlike a file handle, it can't be "rewound" using `seek()`, so it's important
    to save the response data in another variable if it needs to be accessed more
    than once. Note that the output of `response.read()` is a bytes object, which
    should be cast or decoded into an appropriate object depending on the content
    downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we know from the `Content-Type` header that the content is a
    UTF-8 string, so we should convert it to `str` using `decode()`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Generating POST requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `urlopen()` function can also generate `POST` requests. To do this, we
    just need to include a `data` argument, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `data` value needs to be a URL-encoded `bytes` object. A URL-encoded data
    string consists of key-value pairs separated by ampersand (`&`) symbols, with
    certain reserved characters encoded to URL-safe alternatives (for example, the
    space character is `%20`, or sometimes just `+`).
  prefs: []
  type: TYPE_NORMAL
- en: 'A string like this can be created by hand, but it''s easier to use the `urlencode()`
    function provided by the `urllib.parse` module, as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `data` argument must be `bytes`, not a string, so `encode()` must
    be called on the URL-encoded string before `urlopen()` will accept it.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading weather data to ABQ Data Entry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's try downloading the weather data needed for our application. The site
    we'll be using is [http://weather.gov](http://weather.gov), which provides weather
    data within the United States. The actual URL we'll be downloading is [https://w1.weather.gov/xml/current_obs/STATION.xml](http://w1.weather.gov/xml/current_obs/STATION.xml),
    where `STATION` is replaced by the call-sign of the local weather station. In
    the case of ABQ, we'll be using `KBMG`, located in Bloomington, Indiana.
  prefs: []
  type: TYPE_NORMAL
- en: The QA team wants you to record the temperature (in degrees Celsius), relative
    humidity, air pressure (in millibars), and sky conditions (a string, like "overcast"
    or "fair"). They also need the date and time at which the weather was observed
    by the station.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a weather data model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While it would be simple enough to put `urlopen()` calls in an `Application`
    class callback, it's more consistent with our MVC design to wrap our interactions
    with the weather data service in a model class. Our model class will be responsible
    for acquiring the weather data from the web service and translating it into a
    format our other components can use easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `models.py` file and let''s begin by importing `urlopen()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, at the end of the file, let''s start a new model class to wrap our data
    download:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Our initializer will take a `station` string as an argument and use it with
    the base URL value to build the download URL for the weather data. By making the
    `station` value a variable, we can set the station in the user's configuration
    file, allowing users at other ABQ facilities to use the feature as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s begin writing a public method for this class to retrieve the weather
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We start the method by sending a GET request to the model's URL and retrieve
    a response. Note that this may raise an exception (for example, if the site can't
    be reached for some reason), which code calling this method will need to handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming things went okay, we just need to parse out the data in this response
    and put it into a form that the `Application` class can pass to the SQL model.
    To determine how we''ll handle the response, let''s go back to the Python shell
    and examine the data there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As the URL indicated, the payload of the response is an XML document, most
    of which we won''t need. After some searching, though, you should be able to locate
    the fields we need, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Good, the data we need is there, so we just need to extract it from the XML
    string into a format our application can use. Let's take a moment to learn about
    parsing XML data.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing the XML weather data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Python standard library contains an `xml` package, which consists of several
    sub-modules for parsing or creating XML data. Of these, the `xml.etree.ElementTree`
    sub-module is a simple, lightweight parser that should meet our needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s import `ElementTree` into our `models.py` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, back at the end of our `get_weather_data()` method, we''ll parse the XML
    data in our response object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `fromstring()` method takes an XML string and returns an `Element` object.
    To get at the data we need, we'll first need to understand what an `Element` object
    represents, and how to work with it.
  prefs: []
  type: TYPE_NORMAL
- en: XML is a hierarchical representation of data; an element represents a node in
    this hierarchy. An element begins with a tag, which is a text string inside angle
    brackets. Each tag has a matching closing tag, which is just the tag with a forward-slash
    prefixed to the tag name.
  prefs: []
  type: TYPE_NORMAL
- en: Between the opening and closing tags, an element may have other child elements
    or it may have text. An element can also have attributes, which are key-value
    pairs placed inside the angle brackets of the opening tag, just after the tag
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example of XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This example is an (incomplete) XML description of the solar system. The root
    element has a tag of `<star_system>` with an attribute of `starname`. Under this
    root element, we have four `<planet>` elements and a `<dwarf_planet>` element,
    each of which contains a text node with the planet's name. Some of the planet
    nodes also have child `<moon>` nodes, each containing a text node with the moon's
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Arguably, this data could have been structured differently; for example, planet
    names could have been in a child `<name>` node inside the planet elements, or
    listed as an attribute of the `<planet>` tag. While XML *syntax* is well-defined,
    the actual *structure* of an XML document is up to its creator, so fully parsing
    XML data requires a knowledge of the way the data is laid out in the document.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the XML weather data that we downloaded in the shell earlier,
    you'll notice it's a fairly shallow hierarchy. Under the `<current_observations>`
    node, there are a number of child elements whose tags represent specific data
    fields like temperature, humidity, wind chill, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access and extract these child elements, the `Element` object offers us
    the following variety of methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Returns |'
  prefs: []
  type: TYPE_TB
- en: '| `iter()` | An iterator of all child nodes (recursively) |'
  prefs: []
  type: TYPE_TB
- en: '| `find(tag)` | The first element matching the given tag |'
  prefs: []
  type: TYPE_TB
- en: '| `findall(tag)` | A list of elements matching the given tag |'
  prefs: []
  type: TYPE_TB
- en: '| `getchildren()` | A list of the immediate child nodes |'
  prefs: []
  type: TYPE_TB
- en: '| `iterfind(tag)` | An iterator of all child nodes matching the given tag (recursive)
    |'
  prefs: []
  type: TYPE_TB
- en: 'When we downloaded the XML data earlier, we identified five tags containing
    the data we want to extract from this document: `<observation_time_rfc822>`, `<weather>`,
    `<temp_c>`, `<relative_humidity>`, and `<pressure_mb>`. We''ll want our function
    to return a Python dictionary containing each of these tags as keys.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, inside `get_weather_data()`, let''s create a dictionary containing the
    tags we want, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s get the values from the `Element` object and add them to the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For each of our tag names, we're going to use the `find()` method to try to
    locate the element with a matching tag in `xmlroot`. This particular XML document
    does not use duplicate tags (since it would make no sense for a single observation
    to have multiple times, temperature values, humidity values, and so on), so the
    first instance of any tag should be the only one. If the tag is matched, we'll
    get back an `Element` object of the matched node; if not, we get back `None`,
    so we need to make sure `element` is not `None` before trying to access its `text`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've done that for all the tags, we can finish the function by returning
    the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test this function in the Python shell; from a command line, navigate
    to the `ABQ_Data_Entry` directory and start a Python shell. Then enter these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You should get back a dictionary with the current weather conditions in Bloomington,
    Indiana.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the station codes for other cities inside the U.S. at [http://w1.weather.gov/xml/current_obs/](http://w1.weather.gov/xml/current_obs/).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our weather data model, we just need to build the table for
    storing the data and the interface for triggering the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing weather data storage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To store our weather data, we'll start by creating a table in the ABQ database
    to hold the individual observation data, then build a `SQLModel` method to store
    the retrieved data in it. We don't need to worry about writing code to retrieve
    data back from the database, since our laboratory's QA team has their own reporting
    tools that they'll use to access it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the SQL table
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Under the application''s `sql` folder, open the `create_db.sql` file, and add
    a new `CREATE TABLE` statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this table, we're using the `TIMESTAMP` data type on the record as a primary
    key; there's no point in saving the same timestamped observation twice, so this
    makes an adequate primary key. The `(0)` size after the `TIMESTAMP` data type
    indicates how many decimal places we need for the seconds measurement. Since these
    measurements are taken approximately hourly, and we only need one every four hours
    or so (when the lab checks are done), we don't need fractions of seconds in our
    timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we're saving the time zone; always store time zone data with timestamps
    when it's available! It may not seem necessary, especially when your application
    will be run in a workplace that will never change time zones, but there are many
    edge cases such as daylight savings time changes, where the lack of a time zone
    can create major problems.
  prefs: []
  type: TYPE_NORMAL
- en: Run this `CREATE` query in your database to build the table, and let's move
    on to creating our `SQLModel` method.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the SQLModel.add_weather_data() method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Over in `models.py`, let''s add a new method to the `SQLModel` class called
    `add_weather_data()`, which takes a dictionary as its only argument. Start this
    method by creating an `INSERT` query as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is a straightforward parameterized `INSERT` query using variable names
    that match the dictionary keys which the `get_local_weather()` function extracts
    from the XML data. We should only need to pass this query and the `data` dictionary
    into our `query()` method.
  prefs: []
  type: TYPE_NORMAL
- en: There is one problem, however; if we get a duplicate timestamp, our query will
    fail due to a duplicate primary key. We could do another query to check first,
    but that would be slightly redundant, since PostgreSQL itself checks for duplicate
    keys before inserting a new row.
  prefs: []
  type: TYPE_NORMAL
- en: When it detects such an error, `psycopg2` raises an `IntegrityError` exception,
    so we can just catch this exception and, if it gets raised, do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we''ll wrap our `query()` call in the `try`/`except` block, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, our data entry staff can call this method as often as they wish, but it
    will only save a record when there is a fresh observation to save.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the SettingsModel class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before leaving `models.py`, we will need to add a new application setting to
    store the preferred weather station. Add the following new entry in the `SettingsModel.fields`
    dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We won't add a GUI to change this setting, since users won't need to update
    it. It'll be up to us, or the system admin at other lab sites, to make sure this
    is properly set on each workstation by editing the `abq_settings.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the GUI elements for weather download
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Application` object now needs to connect the weather download method from
    `WeatherDataModel` to the database method in `SQLModel` with an appropriate callback
    method that the main menu classes can call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `application.py` and start a new method in the `Application` class called
    `_update_weather_data()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This method begins by creating a `WeatherDataModel` instance using the `weather_station`
    value pulled from the `settings` dictionary. Then, it attempts to call `get_weather_data()`
    inside a `try` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that in an error scenario, `urlopen()` can raise any number of exceptions,
    depending on what went wrong with the HTTP transaction. There isn''t really anything
    the application can do to handle such exceptions other than informing the user
    and exiting the method. Therefore, we''ll catch the generic `Exception` and display
    the text in a `messagebox` dialogbox, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the event that `get_local_weather()` succeeds, we simply need to pass the
    data on to our model method. We can add this in an `else` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In addition to saving the data, we've notified the user in the status bar that
    the weather was updated and displayed the timestamp of the update.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the callback method done, let''s add it to our callbacks dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now we can add a `command` item for the callback in the main menu. In keeping
    with the main menu guidelines we learned in *Chapter 10*, *Maintaining Cross-Platform
    Compatibility*, we should consider an appropriate sub-menu for the command. On
    Windows, functionality like this goes in the `Tools` menu, and since neither the
    Gnome nor macOS guidelines seem to indicate a more appropriate location, we'll
    implement a `Tools` menu in the `LinuxMainMenu` and `MacOsMainMenu` classes to
    hold this command, just to be consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `mainmenu.py`, and starting in the generic menu class, let''s add a private
    method that will add the `command` item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in each menu class''s initializer, we''ll create a `Tools` menu and add
    the command to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this same code to the macOS and Linux menu classes'' initializers. In the
    `WindowsMainMenu` class''s initializer, you only need to add the second line,
    since the `Tools` menu already exists. After updating the menus, you can run the
    application and try the new command from the `Tools` menu. If all went well, you
    should see an indication in the status bar as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1: Success downloading the weather data.](img/B17578_13_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: Success downloading the weather data'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should also connect to the database with your PostgreSQL client and check
    that the table contains some weather data now by executing the following SQL command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'That SQL statement should return output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| datetime | temperature | rel_hum | pressure | conditions |'
  prefs: []
  type: TYPE_TB
- en: '| 2021-08-12 18:53:00-05 | 26.10 | 74.00 | 1013.70 | Fair |'
  prefs: []
  type: TYPE_TB
- en: As you've seen, `urllib` is fairly simple to work with for downloading files
    from the web; most of the work involves parsing the downloaded file and utilizing
    it in the application. However, not all web transactions are as simple as a single
    `GET` or `POST` request. In the next section, we'll look at a more powerful tool
    for HTTP interactions, `requests`.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful HTTP using requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've been asked by your manager to create a function in your program that
    will allow her to upload a CSV extract of the daily data to ABQ's corporate web
    services, which uses an authenticated REST API. **REST** stands for **REpresentational
    State Transfer** and refers to an approach to web services that is built around
    advanced HTTP semantics to provide a more code-friendly interface. Services designed
    around the REST concept are described as **RESTful**. Let's take a deeper look
    at how REST interactions work.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding RESTful web services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A RESTful service is built around the idea of accessing **resources**. A resource
    is typically a data record or file, though it could also be something like a remote
    procedure or hardware interface. We access resources via **endpoints**, which
    are URLs that represent a particular resource.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that web servers typically allow you to fetch data using `GET`
    and submit data using `POST`. REST APIs, however, employ additional HTTP methods
    like `DELETE`, `PUT`, and `PATCH` to indicate different operations. Depending
    on which method we use when requesting an endpoint, we can perform different actions
    on the resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'While implementations of REST services vary, the following table shows the
    generally-agreed-upon functions of HTTP methods by a typical API:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Function |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Retrieve a resource |'
  prefs: []
  type: TYPE_TB
- en: '| `HEAD` | Retrieve only metadata (headers) about a resource |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Create or update a resource based on the submitted data |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | Upload a resource as-is (typically for files) |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Update an existing resource with partial data (rarely implemented)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Delete a resource |'
  prefs: []
  type: TYPE_TB
- en: In addition to a more robust set of methods, REST services also exchange data
    in a way that is more code-friendly. While browser-oriented services accept data
    in URL-encoded strings and return HTML documents, RESTful services may accept
    requests and return responses in formats like JSON or XML. In some cases, clients
    can even request the data format to be returned.
  prefs: []
  type: TYPE_NORMAL
- en: It's critical to understand that, while some standards for RESTful services
    exist, the organization and behavior of REST sites (including their precise responses
    to different methods) vary widely. In order to interact with a REST API, you will
    need to consult its specific documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The Python requests library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in the first section of this chapter, `urllib` is fairly simple to
    use for basic `GET` and `POST` requests, and being in the standard library makes
    it a good choice when that's all we require. However, more complex HTTP interactions
    involving authentication, file uploads, or additional HTTP methods can be frustrating
    and complicated using `urllib` alone. To get this done, we'll turn to the third-party
    `requests` library. This library is highly recommended by the Python community
    for any serious work involving HTTP. As you'll see, `requests` removes many of
    the rough edges and outdated assumptions left in `urllib`, providing convenient
    classes and wrapper functions for more modern HTTP transactions like REST. Complete
    documentation on `requests` can be found at [https://docs.python-requests.org](https://docs.python-requests.org),
    but the next section will cover most of what you need to know to use it effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and using requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `requests` package is written in pure Python, so installing it with `pip`
    requires no compiling or binary downloads. Simply type `pip install --user requests`
    in the terminal and it will be added to your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check out how `requests` works in the Python shell; open a shell and
    enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `requests.request()` function requires, at a minimum, an HTTP method and
    a URL. Just like `urlopen()`, it constructs the appropriate request packet, sends
    it to the URL, and returns an object representing the server's response. Here,
    we're making a `GET` request to this author's website.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the `request()` function, `requests` has shortcut functions
    that correspond to the most common HTTP methods. Thus, the same request can be
    made as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `get()` method requires only the URL and performs a `GET` request. Likewise,
    the `post()`, `put()`, `patch()`, `delete()`, and `head()` functions send requests
    using the corresponding HTTP method. All of these request functions take additional
    optional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can send data with a `POST` request as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, unlike `urlopen()`, we can use a Python dictionary directly as
    a `data` argument; `requests` does the job of converting it to the proper URL-encoded
    `bytes` object for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the more common arguments used with request functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| `params` | Like `data`, but added to the query string rather than the payload
    |'
  prefs: []
  type: TYPE_TB
- en: '| `json` | JSON data to include in the payload |'
  prefs: []
  type: TYPE_TB
- en: '| `headers` | A dictionary of header data to use for the request |'
  prefs: []
  type: TYPE_TB
- en: '| `files` | A dictionary of `{fieldnames: file_objects}` to send as a multipart
    form data request |'
  prefs: []
  type: TYPE_TB
- en: '| `auth` | Username and password tuple to use for basic HTTP digest authentication
    |'
  prefs: []
  type: TYPE_TB
- en: Note that the `auth` argument here only works to authenticate against HTTP digest
    authentication; this is an older method of authentication that is implemented
    at the web server level rather than in the actual web application, and it's rarely
    used on modern websites. To work with modern authentication systems, we need to
    understand the use of sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with authenticated sites using Session
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HTTP is a **stateless** protocol, meaning that each HTTP request stands on its
    own and is not connected to any other requests, even between the same client and
    server. Although it may seem like you are "connected" to your social media or
    banking website when you log in, in reality there is no underlying ongoing connection
    between you and the server, only a series of unrelated requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: How, then, do such sites manage to keep your interactions secure?
  prefs: []
  type: TYPE_NORMAL
- en: On modern sites, this is typically done using either a **session cookie** or
    **authentication token**. In both of these approaches, when the client authenticates
    to the server, the server returns a piece of data that the client can include
    with future requests to identify itself as the same entity that successfully authenticated.
    In this way, both client and server can simulate a stateful connection by associating
    the requests and responses between them into a session.
  prefs: []
  type: TYPE_NORMAL
- en: The differences between session cookies and authentication tokens are immaterial
    for us on the client side; just know that both require us to store something from
    the server after authentication and provide it with each future request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `requests` module makes this kind of interaction simple by providing the
    `Session` class. A `Session` object persists settings, cookies, and tokens across
    multiple requests, allowing you to interact with services that require authentication
    or special client settings. To create a `Session` object, use the `requests.session()`
    factory function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can call request methods like `get()`, `post()`, and others on our
    `Session` object, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Token and cookie handling like this happens in the background, without any explicit
    action from us. Cookies are stored in a `CookieJar` object in the `Session` object's
    `cookies` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also set configuration options on our `Session` object that will persist
    across requests; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we've set the user-agent string to `Mozilla`, which will then
    be used for all requests made from this `Session` object. We also set a default
    URL parameter using the `params` attribute; thus, the actual URL that was requested
    was `http://example.com?uid=12345`.
  prefs: []
  type: TYPE_NORMAL
- en: The requests.Response object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the request functions and methods in `requests` return a `Response` object.
    These `Response` objects are not the same as those returned by `urlopen()`; they
    contain all the same data, but in a slightly different (and generally more convenient)
    form. In addition, they have some helpful methods that make quick work of translating
    their contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the response headers are already translated into a Python dictionary
    for us, as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Another difference from `urllib` is that `requests` does not automatically raise
    an exception on HTTP errors. However, the `.raise_for_status()` response method
    can be called to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s make a request to a URL that will give an HTTP `404` error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This gives us the option of dealing with HTTP errors using exception handling
    or more traditional flow control logic if we prefer, or to defer our exception
    handling to a more convenient moment.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a REST backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start implementing our interactions with the ABQ corporate REST server, we
    need to figure out what kind of requests we're going to send. We've been provided
    with some documentation from the corporate office that describes how to interact
    with the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The API documentation tells us the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Before accessing any other endpoints, we'll need to obtain an authentication
    token. We do this by submitting a `POST` request to the `/auth` endpoint. The
    payload of the `POST` request should include `username` and `password` as URL-encoded
    data. If our credentials fail, we'll get an HTTP 401 error. If we don't have a
    token, any other requests will fail with an HTTP 403 error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we have a token, we can work with files using the `/files` endpoint:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can upload files using a `PUT` request. The file is uploaded as multipart
    form data specified in a parameter called `file`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We can retrieve a file by sending a `GET` request in the form of `/files/FILENAME`,
    where `FILENAME` is the name of the file.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, we can retrieve only metadata about a file by sending a `HEAD`
    request to `/files/FILENAME`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All HTTP errors are accompanied by a JSON payload that includes the status code
    and a message indicating what caused the error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example script, `sample_rest_service.py`, is included with the example code
    for this book that replicates the functionality of the ABQ Corporate REST services.
    To use it, you'll need to install the `flask` library using the command `pip install
    -u flask`, then run the command `python sample_rest_service.py` at a terminal
    prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, in keeping with our MVC design, we''re going to implement a model
    that encapsulates all these interactions. We''ll begin in `models.py` by importing
    the `requests` library like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, at the end of the file, let''s start a new model class, `CorporateRestModel`,
    for the REST site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The class initializer takes a `base_url` argument defining the base URL of the
    REST service we want to contact. It then uses this URL to construct the endpoint
    URLs for upload, authentication, and file retrieval. Finally, since we're going
    to need to store authentication tokens, we create a session object for each method
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: We could have just specified the `base_url` as a class attribute like we did
    with the `WeatherDataModel`; however, to enable us to test this class against
    the test service, or to accommodate the possibility of a change to the corporate
    servers, we'll store this value in the user's settings so it can be easily swapped
    out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we go on, let''s add a setting to our `SettingsModel` for the REST base
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The default value of `http://localhost:8000` is the base URL of the example
    server provided for testing; in production, this setting can be altered by technical
    support for each user by editing their `abq_settings.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, back in our `CorporateRestModel` class, we need to implement four methods:'
  prefs: []
  type: TYPE_NORMAL
- en: An `authenticate()` method to send credentials via a `POST` request to the `/auth`
    endpoint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `upload_file()` method to send a file via a `PUT` request to the `/files`
    endpoint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `check_file()` method to retrieve only metadata from the `/files` endpoint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `get_file()` method to download a file from the `/files` endpoint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: The authenticate() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since we can''t do anything else without an authentication token, let''s start
    with the `authenticate()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will take a username and password and post them to the `auth_url`
    using our model''s `Session` object. The session will automatically store the
    token we receive if we''re successful. Recall that the server will return an HTTP
    401 error if we provide invalid credentials; we could simply check the status
    code of the response and return `True` or `False` from this method. However, since
    there are a variety of other ways that a call to a remote HTTP server can fail
    (for example, a problem on the server might result in a 500 error), it would be
    better if we could report back to the calling code some more detailed information
    about the failure. We could do this by calling the `Response` object''s `raise_for_status()`
    method to send an `HTTPError` exception back to the calling code. That might give
    us an error dialog like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2: An ugly 401 error](img/B17578_13_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: An ugly 401 error'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we can, and should, do a bit better. Most users won't know what an
    HTTP 401 error means.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember from the API specification that the server also returns a JSON object
    with the error that contains a more meaningful message about the failure. We can
    write a static method for our model that will handle an `HTTPError` and convert
    it to an exception with a more human-friendly message. Add this method to the
    model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This method accepts a `Response` object, then calls its `raise_for_status()`
    method. If the status was a success (200), then nothing will happen and the method
    returns. If it raises an `HTTPError`, however, we'll extract the `message` value
    from the `Response` object's JSON payload and raise a new `Exception` error using
    that message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `authenticate()`, let''s end the method by passing the response to
    this static method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now a failed login looks more like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3: A much nicer failure message](img/B17578_13_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.3: A much nicer failure message'
  prefs: []
  type: TYPE_NORMAL
- en: If no exception is raised, we don't need to do anything else. The session has
    the token and we can proceed to other operations.
  prefs: []
  type: TYPE_NORMAL
- en: The upload_file() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our next method will implement actually uploading a file. Remember from the
    API documentation that this requires a `PUT` request to the `/files` endpoint.
    The method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: To send a file using `requests`, we have to actually open it and retrieve a
    file handle, then place the file handle in a dictionary, which we pass to the
    request method's `files` argument. Multiple files can be sent if each one receives
    a different key in the dictionary; our API only allows one file at a time, however,
    and it must have a key of `file`. Once again, we finish the method by checking
    the response for an error code with our `_raise_for_status()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Notice we open the file in binary-read mode (`rb`). The `requests` documentation
    recommends this, as it ensures the correct `Content-length` value will be calculated
    for the request header.
  prefs: []
  type: TYPE_NORMAL
- en: The check_file() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next method we need is the `check_file()` method, which will retrieve header
    information about a file on the server without actually downloading it. The API
    documentation tells us that we can get metadata about the file by sending a `HEAD`
    request to the `files/FILENAME` endpoint, where `FILENAME` is the name of the
    file we want information about. `HEAD` requests are useful when dealing with slow
    connections or large files, as they allow us to find out information about the
    file (for example, its size or whether it exists or not) without actually downloading
    the entire file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement this method like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: For our purposes, we are mostly interested in whether files on the server exist
    or not, so we're going to return a Boolean value from this method depending on
    whether we get a status 200 (success) or 404 (file not found). Of course, other
    things can go wrong with the request too, so we'll also pass the response to our
    `_raise_for_status()` method if it has a different status code.
  prefs: []
  type: TYPE_NORMAL
- en: The get_file() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last method we''ll implement is the `get_file()` method, for downloading
    file data. Add the following method to `CorporateRestModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Unlike other endpoints in this API, a `GET` request to the `/files` endpoint
    does *not* return JSON, but rather the contents of the file. We can retrieve these
    contents from the `Response` object's `text` attribute, which we're returning
    from the method. It will be up to the code that calls this method to do something
    suitable with the content returned from the method. We'll do this in our `Application`
    class, where we'll save the downloaded content to a file.
  prefs: []
  type: TYPE_NORMAL
- en: As our model is now complete, let's head over to the `Application` class to
    begin working on the front end.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating REST upload into the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After discussions with your manager, who is responsible for performing the
    REST upload, you determine that the workflow for the REST upload operation needs
    to go something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: When a REST upload is run from the GUI, it should first check if there is any
    data in the database for that day, and abort if there is not. It looks bad on
    your manager if they upload empty files!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is data, it should create a CSV extract of the day's data using the
    original naming format that was used before the facility went to SQL storage,
    since this is the filename format expected by ABQ Corporate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, it should prompt for authentication credentials for the REST API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, the program should check if a file has already been uploaded for
    that day's data. If not, go ahead and upload the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is a file (sometimes she forgets and uploads twice), the program should
    prompt whether the file should be overwritten or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the event we're not overwriting the file, there should be an option to download
    the file from the server so it can be manually compared with the data in SQL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin implementing this code!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a CSV extract
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we can upload anything, we need to implement a way to create a CSV extract
    of the daily data. This will be used by more than one function, so we'll implement
    it as a separate method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a new private method in `Application` called `_create_csv_extract()`,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The method begins by creating a new instance of our `CSVModel` class; even though
    we're no longer storing our data in the CSV files, we can still use the model
    to export a CSV file. We are not passing in any arguments, just using the default
    file path of the file. Next, we call the `get_all_records()` method of the application's
    `SQLModel` instance. Remember that our `SQLModel.get_all_records()` method returns
    a list of all records for the current day by default. Since your boss doesn't
    want to upload empty files, we'll raise an exception if there are no records to
    build a CSV with. Our calling code can catch that and display the appropriate
    warning. If there are records to save, the method iterates through them, saving
    each one to the CSV, then returns the `CSVModel` object's `file` attribute (that
    is, a `Path` object pointing to the saved file).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the upload callback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have a way to create a CSV extract file, we can write the actual
    callback method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: To begin, we attempt to create a CSV extract file; if we get any exceptions
    (for example, the "No records" exception we created, or perhaps a database issue)
    we'll display an error message and exit the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we''ve created a CSV file successfully, our next step is to authenticate
    to the REST API. To do that, we need to get a username and password from the user.
    Fortunately, we have the perfect class for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Our `LoginDialog` class serves us well here. Unlike with our database login,
    we're not going to run this in an endless loop; if the password is wrong, we will
    just return from the function and the user can rerun the command if need be. Recall
    that dialog's `result` attribute will be `None` if the user clicks `Cancel`, so
    we'll just exit the callback method in that case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have credentials and a filename, we can try to authenticate to
    the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We begin by creating a `CorporateRestModel` instance based on the user's `abq_rest_url`
    setting, then passing our credentials to its `authenticate()` method. Recall that
    in the event of an HTTP problem (including invalid credentials), our model will
    raise an `Exception` with a human-friendly message, so we can simply display that
    in a message box and exit the callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next step is to check if a file for today''s date already exists on the
    server. We''ll do that using our model''s `check_file()` method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Remember that `check_file()` will return a Boolean value indicating if the file
    exists on the server or not, or it might raise an exception if some other HTTP
    issue arises. As before, in the event of an error we'll just show a dialog and
    exit the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the file already exists, we need to determine what the user wants to do
    about it; first, whether they want to just overwrite it, and if not, whether they
    want to download it. We can do that using some message boxes, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Remember from *Chapter 7*, *Creating Menus with Menu and Tkinter Dialogs*, that
    `askyesno()` returns a Boolean value depending on whether the user clicks **Yes**
    or **No**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user wants to download the file, we can do that using our model, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first retrieve the filename the user wants to save the downloaded file
    to using a `filedialog` function. If they cancel the dialog, we'll just exit the
    function doing nothing. Otherwise, we attempt to download the file using our model's
    `get_file()` method. As before, if it fails we display the error and exit. If
    it succeeds, we'll open a new UTF-8 file and save the data to it. Finally, we
    display a success dialog once the file is written. The final `return` statement
    exits the method whether or not the user decides to download the file; since at
    this point, they've opted not to overwrite the file in either case.
  prefs: []
  type: TYPE_NORMAL
- en: 'If they have opted to overwrite the file, our method continues outside that
    `if` block as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: At this point, if the method has not yet returned due to an error or user selection,
    we can go ahead and upload the file. This is done using our model's `upload_file()`
    method. We'll either get a success dialog or an error dialog depending on whether
    the operation succeeds or fails. In either case, our method is finished at this
    point.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing up
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last thing we need to do is add a menu option for running the REST upload.
    First, add the method to the `Application` class''s event callbacks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s add the command item to our main menu. We''ll start by adding
    a method to create the REST upload entry in the menu, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll need to add a call to this method in the `GenericMainMenu` class
    initializer and each of the platform-specific menus; in each case, it should look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now, run the application and let's try it out. To make it work, you'll need
    to have at least one record saved in the database, and you'll need to start up
    the `sample_rest_service.py` script from the example code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If all goes well, you should get a dialog like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_13_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.4: A successful upload to the REST server'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your server should also have printed some output to the terminal similar to
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `POST`, `HEAD`, and `PUT` requests, as well as the filename of the
    CSV file in the payload of `PUT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also run the upload a second time, in which case you should get the
    dialogs asking if you want to overwrite the file, and then if you want to download
    it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5: Download dialog](img/B17578_13_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.5: Download dialog'
  prefs: []
  type: TYPE_NORMAL
- en: That completes the functionality we needed for this application. Good job!
  prefs: []
  type: TYPE_NORMAL
- en: SFTP using paramiko
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While custom-written RESTful web APIs may be common with large companies and
    third-party services, our programs are often called upon to exchange files or
    data with servers using standard communication protocols. In the Linux and Unix
    world, the secure shell or SSH protocol has long been the de-facto standard for
    communication between systems. Most implementations of SSH include SFTP (**Secure
    File Transfer Protocol**), an encrypted replacement for the archaic FTP service.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to uploading the CSV extract to the corporate REST service, your
    manager has to upload a second copy to a remote server using SFTP. The user workflow
    needs to be the same, though there is a requirement to upload the file into a
    particular directory on the server. You need to implement this upload in your
    application just as you did for the REST service.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up SSH services for testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to test the SFTP features we''re going to code in our application,
    we need to have an SSH server available to us. If you don''t have access to a
    device that runs SSH, you can easily install it on your own workstation, depending
    on your operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: On macOS, SSH is preinstalled but needs to be enabled. You can enable it from
    the **Sharing** page in **System Preferences**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On most Linux distributions, you can find SSH in your package manager as `ssh`,
    `ssh-server`, or `openssh` if it's not already installed. Most distributions will
    enable the server by default after installation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Windows 10 and above, you can install OpenSSH server using the **Optional
    Features** tool under **Settings** | **Apps** | **Apps & features**. Once installed,
    start the service by opening the **Services** app, selecting **OpenSSH** **server**,
    and clicking **Start the service**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the service is installed and running, you can connect to your computer
    using an SSH client like OpenSSH Client, and log in using a local username and
    password. You can use your normal user account, but since our application will
    be creating directories and copying files under the home directory of whatever
    user you use to connect to SSH, you may also wish to create a test user account
    for login so that the application does not accidentally overwrite any of your
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and using paramiko
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although the standard library offers nothing in the way of SSH or SFTP support,
    the third-party `paramiko` library provides a full suite of tools for working
    with both. Install `paramiko` from PyPI using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '`paramiko` is pure Python, so it should not require compilation or additional
    programs to be installed. You can learn more about `paramiko` on its website,
    [https://www.paramiko.org](https://www.paramiko.org).'
  prefs: []
  type: TYPE_NORMAL
- en: Using paramiko
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The main class we''ll work with in `paramiko` is the `SSHClient` class, through
    which we''ll connect and interact with remote servers. Open a Python shell and
    let''s create one like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can connect to any servers with the object, we need to configure
    its key management policy. As part of the secure design of SSH, SSH clients exchange
    encryption keys with the server the first time they connect; thus, when connecting
    to a new server for the first time with an SSH client, you''ll likely see a message
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: If you choose to continue, the server's key (or **fingerprint**) will be stored
    with the hostname in a file usually called `known_hosts`. When connecting to the
    server again, SSH consults the known hosts list to verify that we're connecting
    to the same server. If the keys differ, the connection will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the first thing we need to do is load any available key store that we have;
    if your SSH keys are stored in a standard location, calling the `load_system_host_keys()`
    method will suffice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify a known hosts file explicitly using the `load_host_keys()`
    method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'A prompt for adding an unknown host to the known hosts list may be OK for an
    interactive client, but within a programming library it is obviously not so practical.
    Instead, we need to set a policy of what the `SSHClient` object will do when we
    try to connect to an unknown host. By default, it will simply fail, but we can
    force it to automatically trust new hosts using the `set_missing_host_key_policy()`,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Here we've set the policy to an instance of `AutoAddPolicy`, which means any
    new host keys will automatically be trusted. `paramiko` also provides a `RejectPolicy`
    class (which is the default) that automatically rejects all new keys, and for
    advanced use cases we can define our own policy class for more nuanced behaviors.
    We're using `AutoAddPolicy` for convenience in this case; in a real-world, secure
    environment you should leave the default `RejectPolicy` setting and manage the
    `known_hosts` list outside the script.
  prefs: []
  type: TYPE_NORMAL
- en: You can add servers to your `known_hosts` file simply by logging into them using
    **OpenSSH** Client and choosing `yes` when prompted to add the key, or by retrieving
    the key using the `ssh-keyscan` command included with OpenSSH Client and adding
    them to the file manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve settled the issue of key management, we can connect to a host.
    This is done using the `connect()` method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to taking a hostname or IP address as a positional argument, `connect()`
    accepts a number of keyword arguments, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Default | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `username` | Local username | Username to use for authentication. |'
  prefs: []
  type: TYPE_TB
- en: '| `password` | `None` | Password for authentication. If blank, `SSHClient`
    will attempt key-based authentication. |'
  prefs: []
  type: TYPE_TB
- en: '| `port` | `22` | TCP port to connect to. |'
  prefs: []
  type: TYPE_TB
- en: '| `pkey` | `None` | A private key string to use for authentication. |'
  prefs: []
  type: TYPE_TB
- en: '| `key_file` | `None` | A file containing private keys or certificates for
    authentication. |'
  prefs: []
  type: TYPE_TB
- en: '| `compress` | `False` | Enable or disable compression of transmitted data.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `timeout` | `None` | A timeout in seconds before giving up on the connection.
    |'
  prefs: []
  type: TYPE_TB
- en: Inspecting our connection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once connected to a server, our code might need to get some information about
    the connection. This can be done by accessing the `Transport` object associated
    with the client. This object represents the connection and contains a number of
    methods and attributes to set or retrieve information about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can retrieve the `Transport` object using the `get_transport()` method of
    the `SSHClient`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can inspect our connection in various ways, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: These properties can be particularly useful in situations where the user is
    connecting using default values detected from the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Using SFTP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we''ve established an SSH connection to a server, we can begin using
    SFTP. To do this, we''ll create an instance of `SFTPClient` using the `open_sftp()`
    method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the methods of the `SFTPClient` object to execute various file management
    commands on the remote server over SFTP. Some of the more useful of these are
    shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Arguments | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `chdir()` | `path` | Set the current working directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `getcwd()` | None | Return the path of the current working directory. Note
    that it returns `None` if the directory was not set with `chdir()`. |'
  prefs: []
  type: TYPE_TB
- en: '| `listdir()` | `path` (optional) | Return a list of the files and directories
    in `path`, or in the current working directory if not specified. |'
  prefs: []
  type: TYPE_TB
- en: '| `mkdir()` | `path` | Create a directory on the server at `path`. |'
  prefs: []
  type: TYPE_TB
- en: '| `rmdir()` | `path` | Remove the directory from the server described by `path`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `get()` | `remotepath`, `localpath` | Download the file on the server at
    `remotepath` and save it to the client at `localpath`. |'
  prefs: []
  type: TYPE_TB
- en: '| `put()` | `localpath`, `remotepath` | Upload the file on the client at `localpath`
    and save it on the server at `remotepath`. |'
  prefs: []
  type: TYPE_TB
- en: '| `stat()` | `path` | Return an object containing information about the file
    or directory at `path`. |'
  prefs: []
  type: TYPE_TB
- en: '| `remove()` | `path` | Remove the file from the server described by `path`.
    Does not work if `path` is a directory (use `rmdir()` instead). |'
  prefs: []
  type: TYPE_TB
- en: '| `close()` | None | Close the SFTP connection. |'
  prefs: []
  type: TYPE_TB
- en: 'For example, suppose we need to create a folder called `Bananas` in the `Fruit`
    directory on our server, and upload a file called `cavendish.ban` from `/home/alanm/bananas/`
    to the new directory on the server. That exchange would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, in the destination path of the `put()` call, we did not include
    the `Fruit` directory. That's because it's our current working directory, so our
    remote paths are understood to be relative to it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see if we can use our understanding of `paramiko` and SFTP to implement
    an SFTP upload in ABQ Data Entry.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an SFTP model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we did with our REST upload, we'll begin by encapsulating our interactions
    with the SFTP server in a model class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `models.py` and we''ll begin by importing `paramiko`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s begin our model class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Our class initializer will take a hostname for the server and optionally a port
    number. SSH typically runs on port `22`, though it's not uncommon for system administrators
    to run it on another port for security reasons, so it's good to provide this as
    an option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll continue our initializer by configuring our `SSHClient` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: After creating our client instance and saving it to an instance property, we're
    configuring it to automatically add new host keys. Finally, we load in the known
    hosts from the default system location.
  prefs: []
  type: TYPE_NORMAL
- en: In a secure production environment, you may want to leave this policy at the
    default `RestrictPolicy` setting and manage the known hosts list outside of your
    application. Note, however, that the `AutoAddPolicy` only impacts connections
    to *new hosts*; if `SSHClient` receives an invalid fingerprint when connecting
    to a known host, it will still raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'That takes care of our initializer, so let''s create an `authenticate()` method
    to establish a connection to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This method will take a `username` and `password` and use them to establish
    a connection using the `connect()` method. If authentication fails, `paramiko`
    will raise an `AuthenticationException`. We could simply allow this to pass back
    to the calling code, but as we did with our REST model, we're cleaning it up a
    little so that our `Application` object can display a more user-friendly message.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with our `RESTModel`, we''re going to create three more methods: one to
    upload a file, one to download a file, and one to check if a file exists on the
    server. Because all of these require that we''re connected and authenticated,
    though, it would be handy to have another method that raises an exception if we''re
    not.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a private method for this called `_check_auth()`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: As you saw in the previous section, our connection's active and authenticated
    statuses can be retrieved from its `Transport` object; so, this method retrieves
    the transport, then raises an exception if it's not both active and authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how we''ll use this, let''s create our `get_file()` method first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This method will take a remote path and a local path and copy the file down
    from the remote path to the local one. Note that we start with a call to `_check_auth()`
    to ensure that we're properly connected to the server. Then we create our SFTP
    client and run the `get()` method. That's all there is to it!
  prefs: []
  type: TYPE_NORMAL
- en: When creating a command or function that copies or moves data, it's a long-standing
    convention to put your arguments in the order `(SOURCE, DESTINATION)`. Mixing
    this up may rightly earn you the extreme displeasure of your users or fellow developers.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating an upload method will be slightly more complex. Unlike the REST client,
    which was working with a single endpoint, the SFTP server has a filesystem structure
    and we have the possibility of uploading to a subdirectory on the server. If we
    try to upload a file to a directory that doesn't exist, `paramiko` will raise
    an exception.
  prefs: []
  type: TYPE_NORMAL
- en: So, before we upload a file, we'll need to connect to the server and make sure
    all the directories in the destination path are there first. If any of them are
    not, we'll need to create that directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin our method as before by checking the connection and creating an
    SFTPClient instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll check the directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Our `remote_path` will likely be a string, so the first thing we do is convert
    it to a `pathlib.Path` object for easier manipulation. `remote_path.parent.parts`
    gives us a list of all the directories that contain the file, in order from the
    topmost to the bottom-most. For example, if the `remote_path` value was `Food/Fruit/Bananas/cavendish.ban`,
    this attribute would give us the list `['Food', 'Fruit', 'Bananas']`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have that list, we iterate through it, checking to see if the directory
    is in the contents of the current working directory. If not, we create it. Once
    we know that the directory exists, we change the current working directory to
    it and repeat with the next directory in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the directory structure is established, we can upload the actual file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The `put()` method takes our local path to the file and the remote path where
    we want to copy it. Note, however, that we're only using the `name` portion of
    the remote path; that's because the `for` loop that iterated over our directories
    has left our current working directory at the proper parent directory where the
    file needs to be put. Thus, we should just pass the file's name as a destination.
  prefs: []
  type: TYPE_NORMAL
- en: Checking a file's existence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last method we need is one that checks for a file's existence on the server.
    For this, we'll rely on the `stat()` method. The `stat()` method of `SFTPClient`
    can be used to fetch metadata about a file on the server, such as size and modification
    time. We don't need that information, but one useful side effect of `stat()` is
    that it raises a `FileNotFoundError` if passed a path that doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use that in our method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: As with the other methods, this one begins by checking for authentication, then
    creating our `SFTPClient` object. Then, it attempts to `stat()` the file at `remote_path`.
    If a `FileNotFoundError` is raised, we return `False`. Otherwise, we return `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This completes our `SFTPModel`, at least for the operation our application
    needs to perform; but before we leave `models.py`, jump up to the `SettingsModel`
    class and let''s add a few SFTP-related settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: These settings define the host and port of the server, as well as the subdirectory
    path on the server where our files will need to be uploaded. With these added,
    we're ready to work on the GUI side.
  prefs: []
  type: TYPE_NORMAL
- en: Using SFTPModel in our application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The SFTP upload process we need to implement is identical to the REST upload
    process: we need to authenticate to the server, then check to see if the file
    already exists. If it does, we ask the user if they want to overwrite it. If not,
    we offer to download the file for their inspection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin this method in `Application`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Just as before, we begin by attempting to create a CSV file from the day's data;
    if we get an exception, we'll display it and exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll authenticate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Again, just like before, we request a username and password from the user using
    our `LoginDialog`, simply adjusting the label text for SFTP. Then we create our
    `SFTPModel` instance using the host and port values from the `settings` object
    and attempt to authenticate. Any authentication errors will be displayed in a
    message box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to check the destination path to see if it exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: This time, we need to construct a complete destination path by combining the
    `abq_sftp_path` value from `settings` with the generated CSV filename. Notice
    that we're building the path using string formatting rather than with a `Path`
    object. That's because `Path` will join path components using the path separator
    character (forward-slash or backslash) used on our *local* system. The path we're
    creating needs to be compatible with the *remote* filesystem. Fortunately, `paramiko`
    will use forward-slashes (Unix-style path separators) regardless of whether the
    remote server uses Windows or a Unix-like system. For that reason, we're explicitly
    formatting our paths using forward-slashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the file exists, we need to ask the user what to do next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Once again, this is identical to our REST-based code, except that we need to
    remember we're dealing with paths, not just filenames. Thus, we've used `destination_path`
    where we previously used `csvfile.name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the method has not yet returned at this point, we can go ahead and attempt
    to upload our file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: That finishes up our SFTP upload callback.
  prefs: []
  type: TYPE_NORMAL
- en: Some readers might wonder why our model checks its authenticated status for
    each call, when our callback method only runs its operations after it has successfully
    authenticated. First, this is a defensive programming move. We don't know how
    our model class may be used in the future, and the model can't always count on
    well-behaved views and controllers ensuring authentication before other operations.
    Secondly, it's because, unlike HTTP, SSH is a **stateful** protocol. That means
    there is an active session created when we connect which must be maintained for
    any operations to be done. If this session is interrupted (say, by a temporary
    network outage, or a laptop user switching networks) between authentication and
    subsequent operations, those operations would fail and we'd need to start over
    again. Thus, when working with stateful protocols, it's a good idea to check connection
    and authentication status before individual operations.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing up
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All that remains to do now is to add the new feature to our menu. Back in `Application.__init__()`,
    add the callback to our `event_callbacks` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, head over to `mainmenu.py` and add a new private method to `GenericMainMenu`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in each menu subclass, add the entry to the `Tools` menu, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Our new upload feature is now complete! Make sure SSH is running on your system,
    launch ABQ Data Entry, make sure there''s at least one record saved for the day,
    and run the upload from the **Tools** menu. You should see a success dialog like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6: Success dialog for SFTP upload](img/B17578_13_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.6: Success dialog for SFTP upload'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the feature a second time, and you should get your warning dialog, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7: Overwrite dialog for SFTP upload](img/B17578_13_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.7: Overwrite dialog for SFTP upload'
  prefs: []
  type: TYPE_NORMAL
- en: Follow through and make sure you can download the file. Excellent work!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reached out to the cloud using the network protocols HTTP
    and SSH. You learned how to download data over HTTP using `urllib`, and how to
    parse XML data structures using the `ElementTree` module. You also discovered
    an alternative way to interact with HTTP using the `requests` library and learned
    the basics of interacting with a REST API. You learned to work with HTTP interactions
    that required authentications and session cookies, and uploaded a file. Finally,
    you learned how to transfer and manage remote files over SSH with SFTP services
    using the `paramiko` library.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll stop long-running processes from freezing up our
    application and improve our application's performance by learning about asynchronous
    programming. We'll learn to manipulate the Tkinter event loop for better responsiveness
    as well as advanced asynchronous programming using Python's `threading` library.
  prefs: []
  type: TYPE_NORMAL
