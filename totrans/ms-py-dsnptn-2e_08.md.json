["```py\nimport sqlite3\nfrom pathlib import Path\nfrom random import randint\nimport redis\nfrom faker import Faker\nfake = Faker()\nDB_PATH = Path(__file__).parent / Path(\"quotes.sqlite3\")\ncache = redis.StrictRedis(host=\"localhost\", port=6379, decode_responses=True)\n```", "```py\ndef setup_db():\n    try:\n        with sqlite3.connect(DB_PATH) as db:\n            cursor = db.cursor()\n            cursor.execute(\n                \"\"\"\n                CREATE TABLE quotes(id INTEGER PRIMARY KEY, text TEXT)\n            \"\"\"\n            )\n            db.commit()\n            print(\"Table 'quotes' created\")\n    except Exception as e:\n        print(e)\n```", "```py\ndef add_quotes(quotes_list):\n    added = []\n    try:\n        with sqlite3.connect(DB_PATH) as db:\n            cursor = db.cursor()\n            for quote_text in quotes_list:\n                quote_id = randint(1, 100) # nosec\n                quote = (quote_id, quote_text)\n                cursor.execute(\n                    \"\"\"INSERT OR IGNORE INTO quotes(id, text) VALUES(?, ?)\"\"\", quote\n                )\n                added.append(quote)\n            db.commit()\n    except Exception as e:\n        print(e)\n    return added\n```", "```py\ndef main():\n    msg = \"Choose your mode! Enter 'init' or 'update_db_only' or 'update_all': \"\n    mode = input(msg)\n    if mode.lower() == \"init\":\n        setup_db()\n    elif mode.lower() == \"update_all\":\n        quotes_list = [fake.sentence() for _ in range(1, 11)]\n        added = add_quotes(quotes_list)\n        if added:\n            print(\"New (fake) quotes added to the database:\")\n            for q in added:\n                print(f\"Added to DB: {q}\")\n                print(\"  - Also adding to the cache\")\n                cache.set(str(q[0]), q[1], ex=60)\n    elif mode.lower() == \"update_db_only\":\n        quotes_list = [fake.sentence() for _ in range(1, 11)]\n        added = add_quotes(quotes_list)\n        if added:\n            print(\"New (fake) quotes added to the database ONLY:\")\n            for q in added:\n                print(f\"Added to DB: {q}\")\n```", "```py\nimport sqlite3\nfrom pathlib import Path\nimport redis\nCACHE_KEY_PREFIX = \"quote\"\nDB_PATH = Path(__file__).parent / Path(\"quotes.sqlite3\")\ncache = redis.StrictRedis(host=\"localhost\", port=6379, decode_responses=True)\n```", "```py\ndef get_quote(quote_id: str) -> str:\n    out = []\n    quote = cache.get(f\"{CACHE_KEY_PREFIX}.{quote_id}\")\n    if quote is None:\n        # Get from the database\n        query_fmt = \"SELECT text FROM quotes WHERE id = {}\"\n        try:\n            with sqlite3.connect(DB_PATH) as db:\n                cursor = db.cursor()\n                res = cursor.execute(query_fmt.format(quote_id)).fetchone()\n                if not res:\n                    return \"There was no quote stored matching that id!\"\n                quote = res[0]\n                out.append(f\"Got '{quote}' FROM DB\")\n        except Exception as e:\n            print(e)\n            quote = \"\"\n        # Add to the cache\n        if quote:\n            key = f\"{CACHE_KEY_PREFIX}.{quote_id}\"\n            cache.set(key, quote, ex=60)\n            out.append(f\"Added TO CACHE, with key '{key}'\")\n    else:\n        out.append(f\"Got '{quote}' FROM CACHE\")\n    if out:\n        return \" - \".join(out)\n    else:\n        return \"\"\n```", "```py\ndef main():\n    while True:\n        quote_id = input(\"Enter the ID of the quote: \")\n        if quote_id.isdigit():\n            out = get_quote(quote_id)\n            print(out)\n        else:\n            print(\"You must enter a number. Please retry.\")\n```", "```py\nChoose your mode! Enter 'init' or 'update_db_only' or 'update_all': update_all\nNew (fake) quotes added to the database:\nAdded to DB: (62, 'Instead not here public.')\n- Also adding to the cache\nAdded to DB: (26, 'Training degree crime serious beyond management and.')\n- Also adding to the cache\nAdded to DB: (25, 'Agree hour example cover game bed.')\n- Also adding to the cache\nAdded to DB: (23, 'Dark team exactly really wind.')\n- Also adding to the cache\nAdded to DB: (46, 'Only loss simple born remain.')\n- Also adding to the cache\nAdded to DB: (13, 'Clearly statement mean growth executive mean.')\n- Also adding to the cache\nAdded to DB: (88, 'West policy a human job structure bed.')\n- Also adding to the cache\nAdded to DB: (25, 'Work maybe back play.')\n- Also adding to the cache\nAdded to DB: (18, 'Here certain require consumer strategy.')\n- Also adding to the cache\nAdded to DB: (48, 'Discover method many by hotel.')\npython ch08/cache_aside/populate_db.py and choose the update_db_only mode. In that case, we get the following output:\n\n```", "```py\nEnter the ID of the quote: 23\nGot 'Dark team exactly really wind.' FROM DB - Added TO CACHE, with key 'quote.23'\nEnter the ID of the quote: 12\nThere was no quote stored matching that id!\nEnter the ID of the quote: 43\nGot 'Significant hot those think heart shake ago.' FROM DB - Added TO CACHE, with key 'quote.43'\nEnter the ID of the quote: 45\nThere was no quote stored matching that id!\nEnter the ID of the quote: 77\nGot 'Standard much career either will when chance.' FROM DB - Added TO CACHE, with key 'quote.77'\n```", "```py\nfrom datetime import timedelta\nfrom functools import lru_cache\n```", "```py\ndef fibonacci_func1(n):\n    if n < 2:\n        return n\n    return fibonacci_func1(n - 1) + fibonacci_func1(n - 2)\n```", "```py\n@lru_cache(maxsize=None)\ndef fibonacci_func2(n):\n    if n < 2:\n        return n\n    return fibonacci_func2(n - 1) + fibonacci_func2(n - 2)\n```", "```py\ndef main():\n    import time\n    n = 30\n    start_time = time.time()\n    result = fibonacci_func1(n)\n    duration = timedelta(time.time() - start_time)\n    print(f\"Fibonacci_func1({n}) = {result}, calculated in {duration}\")\n    start_time = time.time()\n    result = fibonacci_func2(n)\n    duration = timedelta(time.time() - start_time)\n    print(f\"Fibonacci_func2({n}) = {result}, calculated in {duration}\")\n```", "```py\nFibonacci_func1(30) = 832040, calculated in 7:38:53.090973\nFibonacci_func2(30) = 832040, calculated in 0:00:02.760315\n```", "```py\nclass LazyLoadedData:\n    def __init__(self):\n        self._data = None\n```", "```py\n    @property\n    def data(self):\n        if self._data is None:\n            self._data = self.load_data()\n        return self._data\n```", "```py\n    def load_data(self):\n        print(\"Loading expensive data...\")\n        return sum(i * i for i in range(100000))\n```", "```py\ndef main():\n    obj = LazyLoadedData()\n    print(\"Object created, expensive attribute not loaded yet.\")\n    print(\"Accessing expensive attribute:\")\n    print(obj.data)\n    print(\"Accessing expensive attribute again, no reloading occurs:\")\n    print(obj.data)\n```", "```py\nObject created, expensive attribute not loaded yet.\nAccessing expensive attribute:\nLoading expensive data...\n333328333350000\nAccessing expensive attribute again, no reloading occurs:\n_data. On subsequent accesses, the data stored is retrieved (from the attribute) without re-performing the expensive operation.\n\t\t\tThe lazy loading pattern, applied this way, is very useful for improving performance in applications where certain data or computations are needed from time to time but are expensive to produce.\n\t\t\tImplementing the lazy loading pattern – using caching\n\t\t\tIn this second example, we consider a function that calculates the factorial of a number using recursion, which can become quite expensive computationally as the input number grows. While Python’s `math` module provides a built-in function for calculating factorials efficiently, implementing it recursively serves as a good example of an expensive computation that could benefit from caching. We will use caching with `lru_cache`, as in the previous section, but this time for the purpose of lazy loading.\n\t\t\tWe start with importing the modules and functions we need:\n\n```", "```py\n\n\t\t\tThen, we create a `recursive_factorial()` function that calculates the factorial of a number `n` recursively:\n\n```", "```py\n\n\t\t\tThird, we create a `cached_factorial()` function that returns the result of calling `recursive_factorial()` and is decorated with `@lru_cache`. This way, if the function is called again with the same arguments, the result is retrieved from the cache instead of being recalculated, significantly reducing computation time:\n\n```", "```py\n\n\t\t\tWe create a `main()` function as usual for testing the functions. We call the non-cached function, and then we call the `cached_factorial` function twice, showing the computation time for each case. The code is as follows:\n\n```", "```py\n\n\t\t\tTo test the implementation, run the `python ch08/lazy_loading/lazy_loading_with_caching.py` command. You should get the following output:\n\n```", "```py\n\n\t\t\tYou will notice the time taken for the initial calculation of the factorial without caching, then the time with caching, and finally, the time for a repeated calculation with caching.\n\t\t\tAlso, `lru_cache` is inherently a memoization tool, but it can be adapted and used in cases where, for example, there are expensive initialization processes that need to be executed only when required and not make the application slow. In our example, we used factorial computation to simulate such expensive processes.\n\t\t\tIf you are asking yourself what is the difference from memoization, the answer is that the context in which caching is used here is for managing resource initialization.\n\t\t\tSummary\n\t\t\tThroughout this chapter, we have explored patterns that developers can use to enhance the efficiency and scalability of applications.\n\t\t\tThe cache-aside pattern teaches us how to manage cache effectively, ensuring data is fetched and stored in a manner that optimizes performance and consistency, particularly in environments with dynamic data sources.\n\t\t\tThe memoization pattern demonstrates the power of caching function results to speed up applications by avoiding redundant computations. This pattern is beneficial for expensive, repeatable operations and can dramatically improve the performance of recursive algorithms and complex calculations.\n\t\t\tFinally, the lazy loading pattern emphasizes delaying the initialization of resources until they are needed. This approach not only improves the startup time of applications but also reduces memory overhead, making it ideal for resource-intensive operations that may not always be necessary for the user’s interactions.\n\t\t\tIn the next chapter, we are going to discuss patterns that govern distributed systems.\n\n```", "```py\n\n```"]