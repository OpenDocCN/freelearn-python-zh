- en: '9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9'
- en: Itertools for Combinatorics – Permutations and Combinations
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 组合学中的 `itertools` – 排列和组合
- en: Functional programming emphasizes stateless algorithms. In Python, this leads
    us to work with generator expressions, generator functions, and iterables. In
    this chapter, we’ll continue our study of the `itertools` library, with numerous
    functions to help us work with iterable collections.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程强调无状态算法。在 Python 中，这使我们倾向于使用生成器表达式、生成器函数和可迭代对象。在本章中，我们将继续研究 `itertools`
    库，其中包含许多函数，帮助我们处理可迭代集合。
- en: 'In the previous chapter, we looked at three broad groupings of iterator functions.
    They are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了三种广泛的迭代器函数分组。它们如下：
- en: Functions that work with infinite iterators, which can be applied to any iterable
    or an iterator over any collection; they consume the entire source
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与无限迭代器一起工作的函数，可以应用于任何可迭代对象或任何集合的迭代器；它们消耗整个源
- en: Functions that work with finite iterators, which can either accumulate a source
    multiple times, or produce a reduction of the source
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与有限迭代器一起工作的函数，这些函数可以多次累积源数据，或者生成源数据的减少
- en: The `tee()` iterator function, which clones an iterator into several copies
    that can each be used independently
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tee()` 迭代器函数，该函数将迭代器克隆到几个副本中，每个副本都可以独立使用'
- en: 'In this chapter, we’ll look at the `itertools` functions that work with permutations
    and combinations. These include several combinatorial functions and a few recipes
    built on these functions. The functions are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨与排列和组合一起工作的 `itertools` 函数。这包括几个组合函数和一些基于这些函数的食谱。函数如下：
- en: '`product()`: This function forms a Cartesian product equivalent to the nested
    `for` statements or nested generator expressions.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product()`: 此函数形成与嵌套 `for` 语句或嵌套生成器表达式等价的笛卡尔积。'
- en: '`permutations()`: This function yields tuples of length r from a universe p
    in all possible orderings; there are no repeated elements.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`permutations()`: 此函数从集合 p 中按所有可能的顺序生成长度为 r 的元组；元素不重复。'
- en: '`combinations()`: This function yields tuples of length r from a universe p
    in sorted order; there are no repeated elements.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`combinations()`: 此函数从集合 p 中按顺序生成长度为 r 的元组；元素不重复。'
- en: '`combinations_with_replacement()`: This function yields tuples of length r
    from p in sorted order, allowing the repetition of elements.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`combinations_with_replacement()`: 此函数从 p 中按顺序生成长度为 r 的元组，允许元素重复。'
- en: These functions embody algorithms that can create potentially large result sets
    from small collections of input data. Some kinds of problems have exact solutions
    based on exhaustively enumerating the universe of permutations. As a trivial example,
    when trying to find out if a hand of cards contains a straight (all numbers in
    adjacent, ascending order), one solution is to compute all permutations and see
    if at least one arrangement of cards is ascending. For a 5-card hard, there are
    only 120 arrangements. These functions make it simple to yield all the permutations;
    in some cases, this kind of simple enumeration isn’t optimal or even desirable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数体现了可以从少量输入数据创建潜在大型结果集的算法。某些类型的问题基于穷举排列宇宙的精确解决方案。作为一个简单的例子，当试图找出一张牌是否包含顺子（所有数字相邻且按升序排列）时，一种解决方案是计算所有排列并查看是否至少有一种牌的排列是升序的。对于五张牌的硬牌，只有
    120 种排列。这些函数使得生成所有排列变得简单；在某些情况下，这种简单的枚举可能不是最优的，甚至是不希望的。
- en: 9.1 Enumerating the Cartesian product
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1 枚举笛卡尔积
- en: The term Cartesian product refers to the idea of enumerating all the possible
    combinations of elements drawn from the elements of sets.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 笛卡尔积这个术语指的是从集合的元素中枚举所有可能元素组合的想法。
- en: 'Mathematically, we might say that the product of two sets, {1,2,3,…,13}×{♣,♢,♡,♠},
    has 52 pairs, as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，我们可以说两个集合 {1,2,3,…,13}×{♣,♢,♡,♠} 的乘积有 52 对，如下所示：
- en: '![{(1,♣),(1,♢),(1,♡ ),(1,♠ ),(2,♣ ),(2,♢ ),(2,♡),(2,♠),...,(13,♣ ),(13,♢),(13,♡),(13,♠
    )} ](img/file80.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![{(1,♣),(1,♢),(1,♡ ),(1,♠ ),(2,♣ ),(2,♢ ),(2,♡),(2,♠),...,(13,♣ ),(13,♢),(13,♡),(13,♠
    )} ](img/file80.jpg)'
- en: 'We can produce the preceding results by executing the following commands:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行以下命令来生成前面的结果：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The calculation of a product can be extended to any number of iterable collections.
    Using a large number of collections can lead to a very large result set.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 乘积的计算可以扩展到任何数量的可迭代集合。使用大量集合可能导致非常大的结果集。
- en: 9.2 Reducing a product
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2 减少乘积
- en: In relational database theory, a join between tables can be thought of as a
    filtered product. For those who know SQL, the `SELECT` statement joining tables
    without a `WHERE` clause will produce a Cartesian product of rows in the tables.
    This can be thought of as the worst-case algorithm—a vast product without any
    useful filtering to pick the desired subset of results. We can implement this
    using the `itertools.product()` function to enumerate all possible combinations
    and filter those to keep the few that match properly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系数据库理论中，表之间的连接可以被视为一个过滤后的乘积。对于了解SQL的人来说，没有`WHERE`子句的`SELECT`语句连接表将产生表中行的笛卡尔积。这可以被视为最坏情况的算法——一个没有任何有用过滤来选择所需结果子集的巨大乘积。我们可以使用`itertools.product()`函数来枚举所有可能的组合，并过滤出那些匹配正确的组合。
- en: 'We can define a `join()` function to join two iterable collections or generators,
    as shown in the following commands:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个`join()`函数来连接两个可迭代集合或生成器，如下面的命令所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All combinations of the two iterables, `t1` and `t2`, are computed. The `filter()`
    function will apply the given `where()` function to pass or reject two-tuples,
    hinted as `tuple[JTL,`` JTR]`, that match properly. The `where()` function has
    the hint `Callable[[tuple[JTL,`` JTR]],` `bool]` to show that it returns a Boolean
    result. This is typical of how SQL database queries work in the worst-case situation
    where there are no useful indexes or cardinality statistics to suggest a better
    algorithm.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 计算两个可迭代对象`t1`和`t2`的所有组合。`filter()`函数将应用给定的`where()`函数，以通过或拒绝匹配正确的两个元组，提示为`tuple[JTL,
    JTR]`。`where()`函数的提示为`Callable[[tuple[JTL, JTR]], bool]`，以表明它返回一个布尔结果。这通常是SQL数据库查询在没有任何有用的索引或基数统计信息来建议更好的算法的最坏情况下的典型做法。
- en: While this algorithm always works, it can be terribly inefficient. We often
    need to look carefully at the problem and the available data to find a more efficient
    algorithm.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个算法总是有效的，但它可能非常低效。我们通常需要仔细观察问题和可用数据，以找到更有效的算法。
- en: First, we’ll generalize the problem slightly by replacing the simple Boolean
    matching function. Instead of a binary result, it’s common to look for a minimum
    or maximum of some distance between items. In this case, the comparison yields
    a float value.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将问题稍微泛化一下，通过替换简单的布尔匹配函数。而不是二元结果，我们通常寻找项目之间某些距离的最小值或最大值。在这种情况下，比较产生一个浮点值。
- en: 'Assume that we have a class to define instances in a table of `Color` objects,
    as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个类来定义一个`Color`对象表中的实例，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here’s an example of using this definition to create some `Color` instances:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用此定义创建一些`Color`实例的例子：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For more information, see [Chapter 6](Chapter_06.xhtml#x1-1260006), [Recursions
    and Reductions](Chapter_06.xhtml#x1-1260006), where we showed you how to parse
    a file of colors to create `NamedTuple` objects. In this case, we’ve left the
    RGB color as a `tuple[int,`` int,`` int]`, instead of decomposing each individual
    field.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅[第6章](Chapter_06.xhtml#x1-1260006)，[递归和归约](Chapter_06.xhtml#x1-1260006)，其中我们向您展示了如何解析颜色文件以创建`NamedTuple`对象。在这种情况下，我们将RGB颜色保留为`tuple[int,
    int, int]`，而不是分解每个单独的字段。
- en: 'An image will have a collection of pixels, each of which is an RGB tuple. Conceptually,
    an image contains data like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一幅图像将包含像素集合，每个像素都是一个RGB元组。从概念上讲，图像包含如下数据：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As a practical matter, the Python Imaging Library (PIL) package presents the
    pixels in a number of forms. One of these is the mapping from the (x,y) coordinate
    to the RGB triple. For the Pillow project documentation, visit [https://pypi.python.org/pypi/Pillow](https://pypi.python.org/pypi/Pillow).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Python Imaging Library (PIL)包以多种形式呈现像素。其中之一是将(x,y)坐标映射到RGB三元组。对于Pillow项目文档，请访问[https://pypi.python.org/pypi/Pillow](https://pypi.python.org/pypi/Pillow)。
- en: 'Given a `PIL.Image` object, we can iterate over the collection of pixels with
    something like the following commands:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个`PIL.Image`对象，我们可以使用类似以下命令迭代像素集合：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This function determines the range of each coordinate based on the image size,
    `img.size`. The values of the `product(range(w),`` range(h))` method create all
    the possible combinations of coordinates. It has a result identical to two nested
    `for` statements in a single expression.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数根据图像大小`img.size`确定每个坐标的范围。`product(range(w), range(h))`方法创建所有可能的坐标组合。它的结果与单个表达式中的两个嵌套`for`语句的结果相同。
- en: This has the advantage of enumerating each pixel with its coordinates. We can
    then process the pixels in no particular order and still reconstruct an image.
    This is particularly handy when using multiprocessing or multithreading to spread
    the workload among several cores or processors. The `concurrent.futures` module
    provides an easy way to distribute work among cores or processors.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个优点，就是为每个像素及其坐标进行枚举。然后我们可以以任意顺序处理像素，并仍然重建图像。这在使用多进程或多线程将工作负载分散到多个核心或处理器时特别有用。`concurrent.futures`模块提供了一个简单的方法来在核心或处理器之间分配工作。
- en: 9.2.1 Computing distances
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1 计算距离
- en: A number of decision-making problems require that we find a close enough match.
    We might not be able to use a simple equality test. Instead, we have to use a
    distance metric and locate items with the shortest distance to our target. The
    k-Nearest Neighbors (k-NN) algorithm, for example, uses a training set of data
    and a distance measurement function. It locates the k nearest neighbors to an
    unknown sample, and uses the majority of those neighbors to classify the unknown
    sample.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 许多决策问题需要我们找到一个足够接近的匹配。我们可能无法使用简单的相等测试。相反，我们必须使用距离度量并定位到目标最近的项目。例如，k-最近邻（k-NN）算法使用数据训练集和距离测量函数。它定位到未知样本的k个最近邻，并使用这些邻居中的大多数来分类未知样本。
- en: To explore this concept of enumerating all possible matches, we’ll use a slightly
    simpler example. However, even though it’s superficially simpler, it doesn’t work
    out well if we approach it naively and exhaustively enumerate all potential matches.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索枚举所有可能的匹配的概念，我们将使用一个稍微简单一点的例子。然而，尽管表面上更简单，如果我们天真地全面枚举所有潜在的匹配，它可能不会得到好的结果。
- en: When doing color matching, we won’t have a simple equality test. A color, C,
    for our purposes, is a triple ⟨r,g,b⟩. It’s a point in three-dimensional space.
    It’s often sensible to define a minimal distance function to determine whether
    two colors are close enough, without having the same three values of ⟨r[1],g[1],b[1]⟩
    = ⟨r[2],g[2],b[2]⟩. We need a multi-dimensional distance computation, using the
    red, green, and blue axes of a color space. There are several common approaches
    to measuring distance, including the Euclidean distance, Manhattan distance, and
    other more complex weightings based on visual preferences.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行颜色匹配时，我们不会有简单的相等测试。在我们的目的中，颜色C是一个三元组 ⟨r,g,b⟩。它是在三维空间中的一个点。通常，定义一个最小距离函数来确定两种颜色是否足够接近，而不需要具有相同的三个值
    ⟨r[1],g[1],b[1]⟩ = ⟨r[2],g[2],b[2]⟩ 是合理的。我们需要使用颜色空间的红、绿、蓝轴进行多维距离计算。有几种常见的测量距离的方法，包括欧几里得距离、曼哈顿距离以及其他基于视觉偏好的更复杂的加权方法。
- en: 'Here are the Euclidean and Manhattan distance functions:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是欧几里得和曼哈顿距离函数：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The Euclidean distance measures the hypotenuse of a right-angled triangle among
    the three points in an RGB space. Here’s the formal definition for three dimensions:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得距离衡量了RGB空间中三个点之间直角三角形的斜边。以下是三维空间中的正式定义：
- en: '![ ∘ -------------------------------- ED (c1,c2) = (r1 − r2)2 + (g1 − g2)2
    + (b1 − b2)2 ](img/file81.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![ ∘ -------------------------------- ED (c1,c2) = (r1 − r2)2 + (g1 − g2)2
    + (b1 − b2)2 ](img/file81.jpg)'
- en: 'Here’s a two-dimensional sketch of the Euclidean distance between two points:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是两个点之间欧几里得距离的二维草图：
- en: '![ √ ------- ((E14D,,15))= 32 + 42 = 5](img/file82.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![ √ ------- ((E14D,,15))= 32 + 42 = 5](img/file82.jpg)'
- en: 'The Manhattan distance sums the edges of each leg of the right-angled triangle
    among the three points. It’s named after the gridded layout of the Borough of
    Manhattan in New York City. To get around, one is forced to travel only on the
    streets and avenues. Here’s the formal definition for three dimensions:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 曼哈顿距离将三个点之间直角三角形的每条边的长度相加。它是以纽约市曼哈顿区的网格布局命名的。为了出行，人们被迫只能在街道和大道上行走。以下是三维空间中的正式定义：
- en: '![M D(c1,c2) = (r1 − r2) + (g1 − g2)+ (b1 − b2) ](img/file83.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![M D(c1,c2) = (r1 − r2) + (g1 − g2)+ (b1 − b2) ](img/file83.jpg)'
- en: 'Here’s a two-dimensional sketch of the Manhattan distance between two points:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是两个点之间曼哈顿距离的二维草图：
- en: '![((M14,,D15))= 3+ 4 = 7](img/file84.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![((M14,,D15))= 3+ 4 = 7](img/file84.jpg)'
- en: The Euclidean distance offers precision, while the Manhattan distance offers
    calculation speed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得距离提供精度，而曼哈顿距离提供计算速度。
- en: 'Looking forward, we’re aiming for a structure that looks like this. For each
    individual pixel, we can compute the distance from that pixel’s color to the available
    colors in a limited color set. The results of this calculation for one individual
    pixel of an image might start like the following example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 展望未来，我们希望的结构看起来像这样。对于每个单独的像素，我们可以计算该像素颜色与有限颜色集中的可用颜色之间的距离。对于图像中的一个单独像素的计算结果可能开始如下示例：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We’ve shown a sequence of tuples; each tuple has four items:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了一系列元组；每个元组包含四个项目：
- en: The pixel’s coordinates; for example, (0,0)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像素的坐标；例如，(0,0)
- en: The pixel’s original color; for example, (92, 139, 195)
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像素的原始颜色；例如，(92, 139, 195)
- en: A `Color` object from a set of seven colors; for example, `Color``(``rgb``=(48,`
    `186,` `143)``,` `name``=’``Mountain` `Meadow``’)`
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自一组七个颜色的 `Color` 对象；例如，`Color`(`rgb=(48, 186, 143)', `name='Mountain Meadow'`)
- en: The Euclidean distance between the original color and the given `Color` object;
    for example, 82.75868534480233
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始颜色与给定的 `Color` 对象之间的欧几里得距离；例如，82.75868534480233
- en: It can help to create a `NamedTuple` to encapsulate the four items in each tuple.
    We could call it an X-Y, Pixel, Color, Distance tuple, something like ”XYPCD.”
    This would make it slightly easier to identify the (x,y) coordinate, the original
    pixel’s color, the matching color, and the distance between the original color
    and the selected match.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有助于创建一个 `NamedTuple` 来封装每个元组中的四个项目。我们可以称它为 X-Y，像素，颜色，距离元组，类似于“XYPCD”。这将使识别 (x,y)
    坐标、原始像素的颜色、匹配的颜色以及原始颜色和所选匹配之间的距离稍微容易一些。
- en: 'The smallest Euclidean distance is a closest match color. For the four example
    colors, the Mountain Meadow is the closest match for this pixel. This kind of
    reduction is done with the `min()` function. If the overall four-tuple of (x,y),
    pixel, color, and distance is assigned to a variable name, `choices`, the pixel-level
    reduction would look like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最小的欧几里得距离是最接近匹配的颜色。对于这四种示例颜色，Mountain Meadow 是这个像素的最接近匹配。这种减少是通过 `min()` 函数完成的。如果将
    (x,y)，像素，颜色和距离的整体四元组分配给一个变量名，`choices`，像素级别的减少将看起来像这样：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This expression will pick a single tuple as the optimal match between a pixel
    and color. It uses a lambda to select item 3 from the tuple, the distance metric.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式将选择一个元组作为像素和颜色之间的最佳匹配。它使用 lambda 从元组中选择第 3 项，即距离度量。
- en: 9.2.2 Getting all pixels and all colors
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.2 获取所有像素和所有颜色
- en: How do we get to the structure that contains all pixels and all colors? One
    seemingly simple answer turns out to be less than optimal.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何到达包含所有像素和所有颜色的结构？一个看似简单的答案最终证明并不理想。
- en: 'One way to map pixels to colors is to enumerate all pixels and all colors using
    the `product()` function:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将像素映射到颜色的一种方法是通过使用 `product()` 函数枚举所有像素和所有颜色：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The core of this is the `product(pixel_iter(img),`` colors)` expression that
    creates a sequence of all pixels combined with all colors. The overall expression
    then applies the `euclidean()` function to compute distances between pixels and
    `Color` objects. The result is a sequence of four-tuple objects with the original
    (x,y) coordinate, the original pixel, an available color, and the distance between
    the original pixel color and the available color.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这的核心是 `product(pixel_iter(img), colors)` 表达式，它创建了一个所有像素与所有颜色组合的序列。然后，整体表达式应用
    `euclidean()` 函数来计算像素和 `Color` 对象之间的距离。结果是包含原始 (x,y) 坐标、原始像素、可用颜色以及原始像素颜色和可用颜色之间距离的四元组对象序列。
- en: The final selection of colors uses the `groupby()` function and the `min(choices,`` ...)`
    expression to locate the closest match.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的颜色选择使用 `groupby()` 函数和 `min(choices, ...)` 表达式来定位最接近的匹配。
- en: The `product()` function applied to pixels and colors creates a long, flat iterable.
    We grouped the iterable into smaller collections where the coordinates match.
    This will break the big iterable into smaller iterables of only the pool of colors
    associated with a single pixel. We can then pick the minimal color distance for
    each available color for a pixel.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `product()` 函数应用于像素和颜色创建了一个长而平的迭代器。我们将迭代器分组到更小的集合中，其中坐标匹配。这将把大迭代器分解成仅与单个像素关联的颜色池的小迭代器。然后我们可以为每个像素的每个可用颜色选择最小颜色距离。
- en: In a picture that’s 3,648×2,736 pixels with 133 Crayola colors, we have an iterable
    with 3,648 × 2,736 × 133 = 1,327,463,424 items to be evaluated. That is a billion
    combinations created by this `distances` expression. The number is not necessarily
    impractical; it’s well within the limits of what Python can do. However, it reveals
    an important flaw in the naive use of the `product()` function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个3,648×2,736像素的图片中，使用了133种克雷奥拉颜色，我们有一个包含3,648 × 2,736 × 133 = 1,327,463,424个项目的可迭代对象需要评估。这是由这个`distances`表达式创建的十亿种组合。这个数字并不一定不切实际；它完全在Python能处理的范围内。然而，它揭示了在简单使用`product()`函数时的一个重要缺陷。
- en: 'We can’t trivially do this kind of large-scale processing without first doing
    some analysis to see how large the intermediate data will be. Here are some `timeit`
    numbers for these two distance functions. This is the overall number of seconds
    to do each of these calculations only 1,000,000 times:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行一些分析以查看中间数据有多大之前，我们无法简单地执行这种大规模处理。以下是这两个距离函数的`timeit`数字。这是只进行1,000,000次这些计算的总秒数：
- en: 'Euclidean: 1.761'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欧几里得距离：1.761
- en: 'Manhattan: 0.857'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 曼哈顿距离：0.857
- en: Scaling up by a factor of 1,000—from 1 million combinations to 1 billion—means
    the processing will take at least 1,800 seconds; that is, about half an hour for
    the Manhattan distance and 46 minutes to calculate the Euclidean distance. It
    appears this kind of naive bulk processing is ineffective for large datasets.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过1,000倍的比例放大——从1百万组合到10亿——意味着处理至少需要1,800秒；即曼哈顿距离需要大约半小时，欧几里得距离需要46分钟来计算。这似乎表明这种简单的批量处理对于大数据集是无效的。
- en: More importantly, we’re doing it wrong. This kind of width × height × color
    processing is simply a bad design. In many cases, we can do much better.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我们做错了。这种宽度 × 高度 × 颜色处理的设计本身就是错误的。在许多情况下，我们可以做得更好。
- en: 9.3 Performance improvements
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3 性能改进
- en: A key feature of any big data algorithm is locating a way to execute some kind
    of a divide-and-conquer strategy. This is true of functional programming design
    as well as imperative design.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 任何大数据算法的一个关键特性是找到一种执行某种分而治之策略的方法。这在函数式编程设计以及命令式设计中都是正确的。
- en: 'Here are three options to speed up this processing:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三个选项可以加快这个处理过程：
- en: We can try to use parallelism to do more of the calculations concurrently. On
    a four-core processor, the time can be cut to approximately 25 percent. This reduces
    the time to 8 minutes for Manhattan distances.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以尝试使用并行性来同时进行更多的计算。在四核处理器上，时间可以减少到大约25%。这把曼哈顿距离的计算时间减少到了8分钟。
- en: We can see if caching intermediate results will reduce the amount of redundant
    calculation. The question arises of how many colors are the same and how many
    colors are unique.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以看看缓存中间结果是否会减少冗余计算的数量。问题在于有多少颜色是相同的，有多少颜色是唯一的。
- en: We can look for a radical change in the algorithm.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以寻找算法的彻底改变。
- en: We’ll combine the last two points by computing all the possible comparisons
    between source colors and target colors. In this case, as in many other contexts,
    we can easily enumerate the entire mapping of pixels and colors. If colors are
    repeated, we avoid doing redundant calculations to locate the closest color. We’ll
    also change the algorithm from a series of comparisons to a series of lookups
    in a mapping object.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过计算源颜色和目标颜色之间所有可能的比较来合并最后两个点。在这种情况下，就像在许多其他情况下一样，我们可以轻松地枚举整个像素和颜色的映射。如果颜色重复，我们将避免进行冗余计算以找到最近的颜色。我们还将把算法从一系列比较改为一系列在映射对象中的查找。
- en: In many problem domains, the source data is a collection of floating-point values.
    While these `float` values are flexible, and correspond in some ways with the
    mathematical abstraction of real numbers, they introduce some additional costs.
    Float operations can be slower than integer operations. More importantly, float
    values can contain a number of ”noise” bits. For example, common RGB color definitions
    use 256 distinct values for each of the Red, Green, and Blue components. These
    values are represented exactly with 8 bits. A floating-point variant, using values
    from 0.0 to 1.0, would use the full 64 bits for each color. Any arithmetic that
    led to floating-point truncation would introduce noise. While `float` values seem
    simple, they introduce troubling problems.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多问题域中，源数据是一组浮点值。虽然这些`float`值很灵活，并且在某些方面与实数的数学抽象相对应，但它们引入了一些额外的成本。浮点运算可能比整数运算慢。更重要的是，浮点值可以包含许多“噪声”位。例如，常见的RGB颜色定义使用256个不同的值来表示红色、绿色和蓝色组件。这些值使用8位精确表示。使用从0.0到1.0的值的浮点数变体将每个颜色使用完整的64位。任何导致浮点截断的算术都会引入噪声。虽然`float`值看起来很简单，但它们引入了令人烦恼的问题。
- en: 'Here’s an example, using a red `r=15`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，使用红色`r=15`：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Algebraically, r[f] + ![1100](img/file85.jpg) −![1100-](img/file86.jpg) = r[f].
    However, the `float` definition is only an approximation of the abstract concept
    of a real number. The value of ![-1- 100](img/file87.jpg) doesn’t have an exact
    representation in binary-based floating-point. Using a value like this introduces
    truncation errors that propagate through subsequent computations. We’ve chosen
    to use integer-based color matching to show a way to minimize the additional complications
    that can arise from floating-point values.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从代数上讲，r[f] + ![1100](img/file85.jpg) −![1100-](img/file86.jpg) = r[f]。然而，`float`定义只是对实数抽象概念的近似。![−1−100](img/file87.jpg)的值在基于二进制的浮点数中没有确切的表示。使用这样的值会引入截断误差，这些误差会传播到后续的计算中。我们选择使用基于整数的颜色匹配来展示如何最小化由浮点值引起的额外复杂性。
- en: 'When looking at this idea of pre-computing all transformations from source
    color to target color, we need some overall statistics for an arbitrary image.
    The code associated with this book includes `IMG_2705.jpg`. Here is a basic algorithm
    to collect all of the distinct color tuples from the specified image:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑从源颜色到目标颜色的所有转换的预计算这一想法时，我们需要一个任意图像的整体统计数据。与本书相关的代码包括`IMG_2705.jpg`。以下是收集指定图像中所有不同颜色元组的简单算法：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We collected all pixels of a given color into a list organized by color. From
    this, we’ll learn the following facts:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将给定颜色的所有像素收集到一个按颜色组织的列表中。从这些数据中，我们将学习以下事实：
- en: The total number of pixels is 9,980,928\. This fits the expectation for a 10-megapixel
    image.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像素总数为9,980,928。这符合10兆像素图像的预期。
- en: The total number of colors is 210,303\. If we try to compute the Euclidean distance
    between actual colors and the 133 target colors, we would do 27,970,299 calculations,
    which might take about 76 seconds.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色的总数为210,303。如果我们尝试计算实际颜色和133个目标颜色之间的欧几里得距离，我们将进行27,970,299次计算，这可能需要大约76秒。
- en: If we use a less accurate representation, one with fewer bits, we can speed
    things up. We’ll call this ”masking” to remove some of the irrelevant least-significant
    bits. Using a 3-bit mask, `0b11100000`, the total number of colors actually used
    is reduced to 214 out of a domain of 2³ × 2³ × 2³ = 512 possible colors.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用更不精确的表示，即位数更少的表示，我们可以加快速度。我们将称之为“掩码”，以去除一些不相关的最低有效位。使用3位掩码，`0b11100000`，实际使用的颜色总数减少到214种，而可能的颜色域为2³
    × 2³ × 2³ = 512种。
- en: Using a 4-bit mask, `0b11110000`, 1,150 colors are actually used.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用4位掩码，`0b11110000`，实际上使用了1,150种颜色。
- en: Using a 5-bit mask, `0b11111000`, 5,845 colors are actually used.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用5位掩码，`0b11111000`，实际上使用了5,845种颜色。
- en: Using a 6-bit mask, `0b11111100`, 27,726 colors are actually used. The domain
    of possible colors swells to 2⁶ × 2⁶ × 2⁶ = 262,144.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用6位掩码，`0b11111100`，实际上使用了27,726种颜色。可能的颜色域增加到2⁶ × 2⁶ × 2⁶ = 262,144。
- en: This gives us some insight into how we can rearrange the data structure, calculate
    the matching colors quickly, and then rebuild the image without doing a billion
    comparisons and avoiding any additional complications from floating-point approximations.
    There are a number of changes required to avoid needless (and error-introducing)
    computations.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们了解如何重新排列数据结构，快速计算匹配的颜色，然后在不进行十亿次比较并避免任何额外的浮点近似复杂性的情况下重建图像。需要做出一些改变以避免不必要的（并引入错误的）计算。
- en: 'The core idea behind masking is to preserve the most significant bits of a
    value and eliminate the least significant bits. Consider a color with a red value
    of 200\. We can use the Python `bin()` function to see the binary representation
    of that value:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 掩码背后的核心思想是保留值的最高有效位并消除最低有效位。考虑一个红色值为200的颜色。我们可以使用Python的`bin()`函数来查看该值的二进制表示：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The computation of `200`` &`` 0b11100000` applied a mask to conceal the least
    significant 5 bits and preserve the most significant 3 bits. What remains after
    the mask is applied as a red value of 192.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 计算`200 & 0b11100000`应用了一个掩码来隐藏最低有效5位并保留最高有效3位。掩码应用后剩下的值作为红色值为192。
- en: 'We can apply mask values to the RGB three-tuple with the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令将掩码值应用于RGB三元组：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will pick out the most significant 3 bits of the red, green, and blue values
    of a color tuple by using the `&` operator to select particular bits from an integer
    value. If we use this masked value instead of the original color to create a `Counter`
    object, we’ll see that the image only uses 214 distinct values after the mask
    is applied. This is fewer than half the theoretical number of colors.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过使用`&`运算符从整数值中选择特定的位来挑选出颜色元组的红色、绿色和蓝色值的最显著3位。如果我们用这个掩码值而不是原始颜色来创建一个`Counter`对象，我们会看到在应用掩码后，图像只使用了214个不同的值。这比理论上的颜色数量少了一半。
- en: 9.3.1 Rearranging the problem
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.1 重新排列问题
- en: The naive use of the `product()` function to compare all pixels and all colors
    was a bad idea. There are 10 million pixels, but only 200,000 unique colors. When
    mapping the source colors to target colors, we only have to save 200,000 values
    in a simple map.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`product()`函数比较所有像素和所有颜色是天真且不恰当的。有1000万个像素，但只有20万个独特的颜色。在将源颜色映射到目标颜色时，我们只需要在简单的映射中保存20万个值。
- en: 'We’ll approach it as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按以下方式处理：
- en: 'Compute the source-to-target color mapping. In this case, let’s use 3-bit color
    values as output. Each R, G, and B value comes from the eight values in the `range(0,`` 256,`` 32)`
    expression. We can use this expression to enumerate all the output colors:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算源到目标颜色映射。在这种情况下，让我们使用3位颜色值作为输出。每个R、G和B值来自`range(0, 256, 32)`表达式中的八个值。我们可以使用这个表达式来枚举所有输出颜色：
- en: '[PRE14]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can then compute the Euclidean distance to the nearest color in our source
    palette, doing just 68,096 calculations. This takes about 0.14 seconds. It’s done
    one time only and computes the 200,000 mappings.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以计算到源调色板中最近颜色的欧几里得距离，只需进行68,096次计算。这大约需要0.14秒。它只做一次计算，并计算200,000个映射。
- en: In one pass through the source image, we build a new image using the revised
    color table. In some cases, we can exploit the truncation of integer values. We
    can use an expression such as `(0b11100000&r,`` 0b11100000&g,`` 0b11100000&b)`
    to remove the least significant bits of an image color. We’ll look at this additional
    reduction in computation later.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一次遍历源图像的过程中，我们使用修订后的颜色表构建一个新的图像。在某些情况下，我们可以利用整数值的截断。我们可以使用如`(0b11100000&r,
    0b11100000&g, 0b11100000&b)`这样的表达式来移除图像颜色的最低有效位。我们将在稍后查看这种额外的计算减少。
- en: This will replace a billion distance calculations with 10 million dictionary
    lookups, transforming a potential 30 minutes of calculation into about 30 seconds.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这将用1000万个字典查找替换十亿次的距离计算，将潜在的30分钟计算时间缩短到大约30秒。
- en: Given a source palette of approximately 200,000 colors, we can apply a fast
    Manhattan distance to locate the nearest color in a target palette, such as the
    Crayola colors.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 给定大约有20万个颜色的源调色板，我们可以应用快速曼哈顿距离来定位目标调色板（如Crayola颜色）中的最近颜色。
- en: We’ll fold in yet another optimization—truncation. This will give us an even
    faster algorithm.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加入另一个优化——截断。这将给我们一个更快的算法。
- en: 9.3.2 Combining two transformations
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.2 结合两个转换
- en: When combining multiple transformations, we can build a more complex mapping
    from the source through intermediate targets to the result. To illustrate this,
    we’ll truncate the colors as well as applying a mapping.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当结合多个转换时，我们可以从源通过中间目标到结果构建一个更复杂的映射。为了说明这一点，我们将截断颜色并应用映射。
- en: In some problem contexts, truncation can be difficult. In other cases, it’s
    often quite simple. For example, truncating US postal ZIP codes from nine to five
    characters is common. Postal codes can be further truncated to three characters
    to determine a regional facility that represents a larger geography.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些问题背景下，截断可能很困难。在其他情况下，它通常相当简单。例如，将美国邮政编码从九位截断到五位是常见的。邮政编码可以进一步截断到三位，以确定代表更大地理区域的区域设施。
- en: For colors, we can use the bit-masking shown previously to truncate colors from
    three 8-bit values (24 bits, 16 million colors) to three 3-bit values (9 bits,
    512 colors).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于颜色，我们可以使用之前显示的位掩码来截断从三个 8 位值（24 位，1600 万种颜色）到三个 3 位值（9 位，512 种颜色）的颜色。
- en: 'Here is a way to build a color map that combines distances to a given set of
    colors and truncation of the source colors:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一种构建颜色映射的方法，它结合了给定颜色集的距离和源颜色的截断：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We created a range object, `bit3`, that will iterate through all eight of the
    3-bit color values. The use of the binary value, `0b0010_0000`, can help visualize
    the way the bits are being used. The least significant 5 bits will be ignored;
    only the upper 3 bits will be used.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个范围对象 `bit3`，它将遍历所有八个 3 位颜色值。使用二进制值 `0b0010_0000` 可以帮助可视化位的使用方式。最低的 5
    位将被忽略；只使用最高 3 位。
- en: The `range` objects aren’t like ordinary iterators; they can be used multiple
    times. As a result of this, the `product(bit3,`` bit3,`` bit3)` expression will
    produce all 512 color combinations that we’ll use as the output colors.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`range` 对象与普通迭代器不同；它们可以被多次使用。因此，`product(bit3, bit3, bit3)` 表达式将生成我们用作输出颜色的所有
    512 种颜色组合。'
- en: For each truncated RGB color, we created a three-tuple that has (0) the distance
    from all crayon colors, (1) the RGB color, and (2) the crayon `Color` object.
    When we ask for the minimum value of this collection, we’ll get the closest crayon
    `Color` object to the truncated RGB color.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个截断的 RGB 颜色，我们创建了一个包含（0）所有蜡笔颜色的距离、（1）RGB 颜色和（2）蜡笔 `Color` 对象的三元组。当我们请求这个集合的最小值时，我们将得到与截断
    RGB 颜色最接近的蜡笔 `Color` 对象。
- en: We built a dictionary that maps from the truncated RGB color to the closest
    crayon. In order to use this mapping, we’ll truncate a source color before looking
    up the nearest crayon in the mapping. This use of truncation coupled with the
    pre-computed mapping shows how we might need to combine mapping techniques.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了一个字典，将截断的 RGB 颜色映射到最接近的蜡笔。为了使用这个映射，我们将在查找映射中最接近的蜡笔之前截断源颜色。这种截断与预计算的映射的结合展示了我们可能需要结合映射技术。
- en: 'The following function will build a new image from a color map:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数将从一个颜色映射构建新的图像：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This uses the PIL `putpixel()` function to replace all of the pixels in a picture
    with other pixels. The mask value preserves the upper-most three bits of each
    color, reducing the number of colors to a subset.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用 PIL 的 `putpixel()` 函数来替换图片中的所有像素。掩码值保留每个颜色的最高三位，将颜色数量减少到子集。
- en: What we’ve seen is that the naive use of some functional programming tools can
    lead to algorithms that are expressive and succinct, but also inefficient. The
    essential tools to compute the complexity of a calculation (sometimes called Big-O
    analysis) is just as important for functional programming as it is for imperative
    programming.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的是，一些函数式编程工具的简单使用可能导致表达简洁但效率低下的算法。计算复杂度（有时称为 Big-O 分析）的基本工具对于函数式编程来说，与命令式编程一样重要。
- en: The problem is not that the `product()` function is inefficient. The problem
    is that we can use the `product()` function to create an inefficient algorithm.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 问题不在于 `product()` 函数效率低下。问题在于我们可以使用 `product()` 函数创建一个效率低下的算法。
- en: 9.4 Permuting a collection of values
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4 对值集合进行排列
- en: When we permute a collection of values, we’ll generate all the possible orders
    for the values in the collection. There are n! permutations of n items. We can
    use a sequence of permutations as a kind of brute-force solution to a variety
    of optimization problems.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对值集合进行排列时，我们将生成集合中值的所有可能顺序。n 个项目的排列有 n! 种。我们可以使用排列序列作为解决各种优化问题的暴力解决方案。
- en: Typical combinatorial optimization problems are the Traveling Salesman problem,
    the Minimum Spanning Tree problem, and the Knapsack problem. These problems are
    famous because they involve potentially vast numbers of permutations. Approximate
    solutions are necessary to avoid exhaustive enumeration of all permutations. The
    use of the `itertools.permutations()` function is only handy for exploring very
    small problems.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的组合优化问题包括旅行商问题、最小生成树问题和背包问题。这些问题之所以著名，是因为它们涉及到可能的大量排列。为了避免对所有排列进行穷举，需要近似解。使用`itertools.permutations()`函数仅适用于探索非常小的问题。
- en: One popular example of these combinatorial optimization problems is the assignment
    problem. We have n agents and n tasks, but the cost of each agent performing a
    given task is not equal. Imagine that some agents have trouble with some details,
    while other agents excel at these details. If we can properly assign tasks to
    agents, we can minimize the costs.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: 'We can create a simple grid that shows how well a given agent is able to perform
    a given task. For a small problem of seven agents and tasks, there will be a grid
    of 49 costs. Each cell in the grid shows agents A[0] to A[6] performing tasks
    T[0] to T[6]:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个简单的网格，以显示给定代理完成给定任务的能力。对于七个代理和任务的简单问题，将有一个49个成本的网格。网格中的每个单元格显示代理A[0]到A[6]执行任务T[0]到T[6]：
- en: Agent
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 代理
- en: '* * *'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: '* * *'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '25'
- en: Task
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 任务
- en: A[0]
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: A[0]
- en: A[1]
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: A[2]
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: A[2]
- en: A[3]
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '24'
- en: A[4]
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: A[4]
- en: A[5]
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: A[5]
- en: A[6]
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: A[3]
- en: '* * *'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: T[3]
- en: '* * *'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: T[0]
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: T[0]
- en: '14'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: '11'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: '6'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: A[6]
- en: '20'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '12'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: '9'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '4'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '* * *'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '30'
- en: '* * *'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: A[1]
- en: T[1]
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: T[1]
- en: '15'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: '28'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '34'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '34'
- en: '4'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '12'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '24'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '28'
- en: '21'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '21'
- en: '* * *'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '20'
- en: '* * *'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: T[2]
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: T[2]
- en: '16'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '31'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: T[5]
- en: '22'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '22'
- en: '18'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '18'
- en: '31'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '31'
- en: '15'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: '23'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '23'
- en: '* * *'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '24'
- en: '* * *'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: T[3]
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '20'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '20'
- en: '18'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '18'
- en: '9'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: '15'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: '30'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '30'
- en: '4'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '18'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '18'
- en: '* * *'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '31'
- en: '* * *'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: T[4]
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: T[4]
- en: '24'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '8'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组合优化问题的一个流行例子是分配问题。我们有n个代理和n个任务，但每个代理执行特定任务的成本并不相等。想象一下，一些代理在处理某些细节时遇到困难，而其他代理在这些细节上表现出色。如果我们能正确分配任务给代理，我们可以最小化成本。
- en: '24'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: '30'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '30'
- en: '28'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '25'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '4'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '* * *'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '28'
- en: '* * *'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '24'
- en: '* * *'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: T[5]
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '3'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '23'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '23'
- en: '22'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '22'
- en: '11'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: '5'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '30'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: '5'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '* * *'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: T[6]
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: T[6]
- en: '13'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: '7'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '5'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '10'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '7'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '7'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '32'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '32'
- en: '* * *'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Given this grid, we can enumerate all the possible permutations of agents and
    their tasks. However, this approach doesn’t scale well. For this problem, there
    are 720 alternatives. If we have more agents, for example 10, the value of 10!
    is 3,628,800\. We can create the entire sequence of 3 million items with the `list(permutations(range(10)))`
    expression.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个网格，我们可以列出所有代理和任务的排列组合。然而，这种方法扩展性不好。对于这个问题，有720种选择。如果我们有更多的代理，例如10个，10!的值是3,628,800。我们可以使用`list(permutations(range(10)))`表达式创建整个300万项的序列。
- en: 'We would expect to solve a problem of this tiny size in a fraction of a second.
    For 10!, we might take a few seconds. When we double the size of the problem to
    20!, we have a bit of a scalability problem: there will be 2.433 × 10^(18) permutations.
    On a computer where it takes about 0.56 seconds to generate 10! permutations,
    the process of generating 20! permutations would take about 12,000 years.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预计在几秒钟内就能解决这么小的问题。对于10!，我们可能需要几秒钟。当我们把问题规模加倍到20!时，我们遇到了一些可扩展性问题：将有2.433 ×
    10^(18)种排列。在一个生成10!排列需要大约0.56秒的计算机上，生成20!排列的过程将需要大约12,000年。
- en: 'We can formulate the exhaustive search for the optimal solution as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将穷举搜索最优解的形式化如下：
- en: '[PRE17]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We’ve created all permutations of tasks for a group of agents and assigned this
    to `perms`. From this, we’ve created two-tuples of the sum of all costs in the
    cost matrix for a given permutation. To locate the relevant costs, a specific
    permutation is enumerated to create two-tuples showing the agent and the task
    assignment for that agent. For example, one of the permutations is tasks `(2,`` 4,`` 6,`` 1,`` 5,`` 3,`` 0)`.
    We can assign agent index values using the expression `list``(``enumerate``((2,`
    `4,` `6,` `1,` `5,` `3,` `0)``)``)`. The result, `[(0,`` 2),`` (1,`` 4),`` (2,`` 6),`` (3,`` 1),`` (4,`` 5),`` (5,`` 3),`` (6,`` 0)]`,
    has all seven agent index values and their associated task assignments. We can
    translate the index numbers to agent names and task names by incorporating a dictionary
    lookup. The sum of the values in the cost matrix tells us how expensive this specific
    task assignment would be.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为一系列代理创建所有任务排列，并将其分配给`perms`。从这些排列中，我们创建了两个元组，表示给定排列的成本矩阵中所有成本的总和。为了定位相关成本，我们枚举一个特定的排列以创建显示代理及其任务分配的两个元组。例如，一个排列是任务`(2,
    4, 6, 1, 5, 3, 0)`。我们可以使用表达式`list(enumerate((2, 4, 6, 1, 5, 3, 0)))`来分配代理索引值。结果是`[(0,
    2), (1, 4), (2, 6), (3, 1), (4, 5), (5, 3), (6, 0)]`，包含所有七个代理索引值及其相关的任务分配。我们可以通过字典查找将索引数字转换为代理名称和任务名称。成本矩阵中值的总和告诉我们这个特定任务分配的成本是多少。
- en: 'One of the optimal solutions might look like the assignment above. It requires
    folding in the agent names and task names to translate the task permutation into
    a specific list of assignments:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 一个最优解可能看起来像上面的分配。它需要将代理名称和任务名称折叠进来，以将任务排列转换为特定的分配列表：
- en: '|'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| A[0] | T[2] |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| A[0] | T[2] |'
- en: '|'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| A[1] | T[4] |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| A[1] | T[4] |'
- en: '|'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| A[2] | T[6] |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| A[2] | T[6] |'
- en: '|'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| A[3] | T[1] |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| A[3] | T[1] |'
- en: '|'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| A[4] | T[5] |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| A[4] | T[5] |'
- en: '|'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| A[5] | T[3] |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| A[5] | T[3] |'
- en: '|'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| A[6] | T[0] |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| A[6] | T[0] |'
- en: '|'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  |  |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '|  |  |'
- en: In some cases, there might be multiple optimal solutions; this algorithm will
    locate all of them. The expression `min(alt)[0]` selects the first of the set
    of minima.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能会有多个最优解；此算法将找到所有这些解。表达式`min(alt)[0]`选择最小值集中的第一个。
- en: For small textbook examples, this seems to be reasonably fast. There are linear
    programming approaches which avoid exhaustive enumeration of all permutations.
    The Python Linear Programming module PuLP can be used to solve the assignment
    problem. See [https://coin-or.github.io/pulp/](https://coin-or.github.io/pulp/).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小的教科书示例，这似乎是相当快的。有一些线性规划方法可以避免枚举所有排列。Python线性规划模块PuLP可用于解决分配问题。请参阅[https://coin-or.github.io/pulp/](https://coin-or.github.io/pulp/)。
- en: 9.5 Generating all combinations
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5 生成所有组合
- en: The `itertools` module also supports computing all combinations of a set of
    values. When looking at combinations, the order doesn’t matter, so there are far
    fewer combinations than permutations. The number of combinations is often stated
    as ![(p) r](img/file88.jpg) = ![--p!-- r!(p− r)!](img/file89.jpg). This is the
    number of ways that we can take combinations of r things at a time from a universe
    of p items overall.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools`模块也支持计算一组值的所有组合。在考虑组合时，顺序不重要，因此组合的数量远少于排列。组合的数量通常表示为 ![(p) r](img/file88.jpg)
    = ![--p!-- r!(p− r)!](img/file89.jpg)。这是从包含p个项目的总体中一次取r个项目的组合方式的数量。'
- en: 'For example, there are 2,598,960 five-card poker hands. We can actually enumerate
    all 2 million hands by executing the following command:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有2,598,960种五张牌的扑克手牌。实际上，我们可以通过执行以下命令来枚举所有200万种手牌：
- en: '[PRE18]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'More practically, assume we have a dataset with a number of variables. A common
    exploratory technique is to determine the correlation among all pairs of variables
    in a set of data. If there are v variables, then we will enumerate all variables
    that must be compared by executing the following command:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 更实际的做法是，假设我们有一个包含多个变量的数据集。一种常见的探索技术是确定数据集中所有变量对之间的相关性。如果有v个变量，那么我们将执行以下命令来枚举必须比较的所有变量：
- en: '[PRE19]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A fun source of data for simple statistical analysis is the Spurious Correlations
    site. This has a great many datasets with surprising statistical properties. Let’s
    get some sample data from Spurious Correlations, [http://www.tylervigen.com](http://www.tylervigen.com),
    to show how this will work. We’ll pick three datasets with the same time range,
    datasets numbered 7, 43, and 3,890\. We’ll simply catenate the data into a grid.
    Because the source data repeats the `year` column, we’ll start with data that
    includes the repeated `year` column. We’ll eventually remove the obvious redundancy,
    but it’s often best to start with all of the data present as a way to confirm
    that the various sources of data align with each other properly.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 简单统计分析的一个有趣数据来源是Spurious Correlations网站。这个网站拥有大量具有惊人统计特性的数据集。让我们从Spurious Correlations网站，[http://www.tylervigen.com](http://www.tylervigen.com)，获取一些样本数据，以展示这是如何工作的。我们将选择三个具有相同时间范围的数据集，编号为7、43和3,890。我们将简单地将数据串联成一个网格。因为源数据重复了`year`列，我们将从包含重复`year`列的数据开始。我们最终会移除明显的冗余，但通常最好从所有现有数据开始，以便确认各种数据来源是否正确对齐。
- en: 'This is how the first and the remaining rows of the yearly data will look:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是年度数据的第1行和剩余行将看起来像这样：
- en: '[PRE20]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is how we can use the `combinations()` function to yield all the combinations
    of the nine variables in this dataset, taken two at a time:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何使用`combinations()`函数产生这个数据集中九个变量的所有组合，每次取两个：
- en: '[PRE21]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There are 36 possible combinations. We’ll have to reject the combinations that
    involve matching columns `year` and `year`. These will trivially correlate with
    a value of 1.00.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 有36种可能的组合。我们必须拒绝涉及匹配列`year`和`year`的组合。这些组合将与1.00的值简单地相关。
- en: 'Here is a function that picks a column of data out of our dataset:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个从我们的数据集中选择数据列的函数：
- en: '[PRE22]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This allows us to use the `corr()` function from [Chapter 4](Chapter_04.xhtml#x1-740004),
    [Working with Collections](Chapter_04.xhtml#x1-740004), to compute the correlation
    between the two columns of data.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们使用[第4章](Chapter_04.xhtml#x1-740004)，[处理集合](Chapter_04.xhtml#x1-740004)中的`corr()`函数来计算两个数据列之间的相关性。
- en: 'This is how we can compute all combinations of correlations:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何计算所有相关性的组合：
- en: '[PRE23]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For each combination of columns, we’ve extracted the two columns of data from
    our dataset. The `header_p,`` *data_p`` =...` statement uses multiple assignments
    to separate the first item in the sequence, the header, from the remaining rows
    of data. If the headers match, we’re comparing a variable to itself. This will
    be `True` for the three combinations of year and year that stem from the redundant
    year columns.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一组列的组合，我们已经从我们的数据集中提取了两个数据列。`header_p,` `*data_p` `=...`语句使用多个赋值来分离序列中的第一个项目，即标题，与剩余的行数据。如果标题匹配，我们就是在比较一个变量与自身。这对于从冗余的年份列中产生的三个年份与年份的组合将是`True`。
- en: Given a combination of columns, we will compute the correlation function and
    then print the two headings along with the correlation of the columns. We’ve intentionally
    chosen two datasets that show spurious correlations with a third dataset that
    does not follow the same pattern as closely. In spite of this, the correlations
    are remarkably high.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个列的组合，我们将计算相关性函数，然后打印出两列的标题以及它们的相关性。我们有意选择了两个显示与第三个数据集有虚假相关性的数据集，该数据集并不紧密遵循相同的模式。尽管如此，相关性却非常高。
- en: 'The results look like this:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来像这样：
- en: '[PRE24]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It’s not at all clear what this pattern means. Why do these values correlate?
    The presence of spurious correlations with no significance can cloud statistical
    analysis. We’ve located data that has strangely high correlations with no obvious
    causal factors.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式的意义并不明确。为什么这些值会相关？虚假相关性（无显著性）的存在可能会使统计分析变得复杂。我们已经找到了具有奇怪高相关性但没有明显因果因素的数据。
- en: What’s important is that a simple expression, `combinations(range(9),`` 2)`,
    enumerates all the possible combinations of data. This kind of succinct, expressive
    technique makes it easier to focus on the data analysis issues instead of the
    combinatoric algorithm considerations.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，一个简单的表达式`combinations(range(9), 2)`列出了所有可能的数据组合。这种简洁、表达性的技术使得关注数据分析问题而不是组合算法考虑变得更容易。
- en: 9.5.1 Combinations with replacement
  id: totrans-359
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.5.1 带替换的组合
- en: 'The `itertools` library has two functions for generating combinations of items
    selected from some set of values. The `combinations()` function reflects our expectations
    when dealing hands from a deck of cards: each card will appear at most once. The
    `combinations_with_` `replacement()` function reflects the idea of taking a card
    from a deck, writing it down, and then shuffling it back into the deck before
    selecting another card. This second procedure could potentially yield a five-card
    sample with five aces of spades.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools` 库有两个函数用于生成从某些值集中选择的项的组合。`combinations()` 函数反映了从一副牌中发牌时的预期：每张牌最多出现一次。`combinations_with_replacement()`
    函数反映了从一副牌中取一张牌，写下它，然后将其洗回牌堆，在再次选择另一张牌之前。这种第二种程序可能产生一个包含五张黑桃A的五张牌样本。'
- en: 'We can see this more clearly by using the following kind of expression:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下类型的表达式更清楚地看到这一点：
- en: '[PRE25]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There are ![(6) 2](img/file90.jpg) = 15 combinations of six things taken two
    at a time. There are 6² = 36 combinations when replacement is permitted, since
    any value is a possible member of the result.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 从六个事物中每次取两个，有 ![(6) 2](img/file90.jpg) = 15 种组合。当允许替换时，有 6² = 36 种组合，因为任何值都是结果的可能成员。
- en: 9.6 Recipes
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6 食谱
- en: The `itertools` chapter of the Python library documentation is outstanding.
    The basic definitions are followed by a series of recipes that are extremely clear
    and helpful. Since there’s no reason to reproduce these, we’ll reference them
    here. They are required reading materials on functional programming in Python.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: Python 库文档中的 `itertools` 章节非常出色。基本定义之后，是一系列非常清晰且有用的食谱。由于没有必要重新生成这些内容，我们在这里引用它们。它们是
    Python 函数式编程的必读材料。
- en: The Itertools Recipes section in the Python Standard Library is a wonderful
    resource. Visit [https://docs.python.org/3/library/itertools.html#itertools-recipes](https://docs.python.org/3/library/itertools.html#itertools-recipes)
    for more details.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Python 标准库中的 `itertools` 食谱部分是一个极好的资源。访问 [https://docs.python.org/3/library/itertools.html#itertools-recipes](https://docs.python.org/3/library/itertools.html#itertools-recipes)
    获取更多详情。
- en: These function definitions aren’t importable functions in the `itertools` modules.
    These are ideas that need to be read and understood and then, perhaps, copied
    or modified before inclusion in an application.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数定义不是 `itertools` 模块中的可导入函数。这些是需要阅读和理解，然后可能复制或修改后包含到应用程序中的想法。
- en: 'The following table summarizes some recipes that show functional programming
    algorithms built from the itertools basics:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了显示由 itertools 基础构建的函数式编程算法的一些食谱：
- en: '|  |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| Function Name | Arguments | Results |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| 函数名称 | 参数 | 结果 |'
- en: '|  |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |  |  |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |'
- en: '|  |  |  |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |'
- en: '| `powerset` | `(iterable)` | Generate all the subsets of the iterable. Each
    subset is a tuple object, not a set instance. |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| `powerset` | `(iterable)` | 生成迭代器的所有子集。每个子集都是一个元组对象，而不是集合实例。 |'
- en: '| `random\_product` | `(*args,`` repeat=1)` | Randomly select from `product()`.
    |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| `random_product` | `(*args, repeat=1)` | 从 `product()` 中随机选择。 |'
- en: '| `random\_permutation` | `(iterable,`` r=None)` | Randomly select from `permutations()`.
    |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| `random_permutation` | `(iterable, r=None)` | 从 `permutations()` 中随机选择。 |'
- en: '| `random\_combination` | `(iterable,`` r)` | Randomly select from `combinations()`.
    |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| `random_combination` | `(iterable, r)` | 从 `combinations()` 中随机选择。 |'
- en: '|  |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |  |  |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |'
- en: '|  |  |  |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |'
- en: '|  |  |  |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |'
- en: '|  |  |  |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |'
- en: '|  |  |  |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |'
- en: 9.7 Summary
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7 概述
- en: In this chapter, we looked at a number of functions in the `itertools` module.
    This standard library module provides a number of functions that help us work
    with iterators in sophisticated ways.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 `itertools` 模块中的多个函数。这个标准库模块提供了一系列函数，帮助我们以复杂的方式处理迭代器。
- en: 'We looked at these combination-producing functions:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了以下这些组合生成函数：
- en: The `product()` function computes all the possible combinations of the elements
    chosen from two or more collections.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product()` 函数计算从两个或更多集合中选择的元素的所有可能组合。'
- en: The `permutations()` function gives us different ways to reorder a given set
    of values.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`permutations()` 函数为我们提供了重新排列给定值集的不同方式。'
- en: The `combinations()` function returns all the possible subsets of an original
    set.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`combinations()` 函数返回原始集合的所有可能子集。'
- en: We also looked at ways in which the `product()` and `permutations()` functions
    can be used naively to create extremely large result sets. This is an important
    cautionary note. A succinct and expressive algorithm can also involve a vast amount
    of computation. We must perform basic complexity analysis to be sure that the
    code will finish in a reasonable amount of time.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了如何天真地使用`product()`和`permutations()`函数来创建极其大的结果集。这是一个重要的警告。一个简洁且表达力强的算法也可能涉及大量的计算。我们必须进行基本的复杂度分析，以确保代码能在合理的时间内完成。
- en: In the next chapter, we’ll look at the `functools` module. This module includes
    some tools to work with functions as first-class objects. This builds on some
    material shown in [Chapter 2](Chapter_02.xhtml#x1-340002), [Introducing Essential
    Functional Concepts](Chapter_02.xhtml#x1-340002), and [Chapter 5](Chapter_05.xhtml#x1-1000005),
    [Higher-Order Functions](Chapter_05.xhtml#x1-1000005).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨`functools`模块。此模块包含一些工具，用于将函数作为一等对象处理。这基于[第2章](Chapter_02.xhtml#x1-340002)，[介绍基本函数概念](Chapter_02.xhtml#x1-340002)，和[第5章](Chapter_05.xhtml#x1-1000005)，[高阶函数](Chapter_05.xhtml#x1-1000005)中展示的一些材料。
- en: 9.8 Exercises
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.8 练习
- en: This chapter’s exercises are based on code available from Packt Publishing on
    GitHub. See [https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的练习基于Packt Publishing在GitHub上提供的代码。请参阅[https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition)。
- en: In some cases, the reader will notice that the code provided on GitHub includes
    partial solutions to some of the exercises. These serve as hints, allowing the
    reader to explore alternative solutions.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，读者会注意到GitHub上提供的代码包含一些练习的部分解决方案。这些作为提示，允许读者探索替代解决方案。
- en: In many cases, exercises will need unit test cases to confirm they actually
    solve the problem. These are often identical to the unit test cases already provided
    in the GitHub repository. The reader should replace the book’s example function
    name with their own solution to confirm that it works.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，练习需要单元测试用例来确认它们确实解决了问题。这些通常与GitHub仓库中已提供的单元测试用例相同。读者应将书中的示例函数名称替换为自己的解决方案，以确认其有效性。
- en: 9.8.1 Alternative distance computations
  id: totrans-396
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.8.1 替代距离计算方法
- en: See Effects of Distance Measure Choice on KNN Classifier Performance - A Review.
    This is available at [https://arxiv.org/pdf/1708.04321](https://arxiv.org/pdf/1708.04321).
    In this paper, dozens of distance metrics are examined for their utility in implementing
    the k-Nearest Neighbors (k-NN) classifier.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 参见《距离度量选择对KNN分类器性能的影响——综述》。该综述可在[https://arxiv.org/pdf/1708.04321](https://arxiv.org/pdf/1708.04321)找到。在这篇论文中，考察了数十种距离度量在实现k-最近邻(k-NN)分类器中的实用性。
- en: 'Some of these are also suitable for the color-matching algorithm presented
    in this chapter. We defined a color, c, a three-tuple, (r,g,b), based on the Red,
    Green, and Blue components of the color. We can compute the distance between two
    colors, D(c[1],c[2]), based on their RGB components:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些也适用于本章中介绍的色彩匹配算法。我们定义了一个颜色，c，一个三元组，(r,g,b)，基于颜色的红、绿、蓝成分。我们可以根据它们的RGB成分计算两种颜色之间的距离，D(c[1],c[2])：
- en: '![ ( ) D (c1,c2) = D (r1,g1,b1),(r2,g2,b2) ](img/file91.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![ ( ) D (c1,c2) = D (r1,g1,b1),(r2,g2,b2) ](img/file91.jpg)'
- en: 'We showed two: Euclidean and Manhattan distances. Here are some more formal
    definitions:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了两种：欧几里得距离和曼哈顿距离。以下是更正式的定义：
- en: '![ ∘ -------2-----------2----------2- ED = (r1 − r2) + (g1 − g2) + (b1 − b2)
    ](img/file92.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![ ∘ -------2-----------2----------2- ED = (r1 − r2) + (g1 − g2) + (b1 − b2)
    ](img/file92.jpg)'
- en: '![M D = |r1 − r2|+ |g1 − g2|+ |b1 − b2| ](img/file93.jpg)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![M D = |r1 − r2|+ |g1 − g2|+ |b1 − b2| ](img/file93.jpg)'
- en: 'Some additional examples include these:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 一些额外的例子包括这些：
- en: 'The Chebyshev Distance (CD) is the maximum of the absolute values of each color
    difference:'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切比雪夫距离(CD)是每个颜色差异绝对值的最大值：
- en: '![CD = max (|r1 − r2|,|g1 − g2|,|b1 − b2|) ](img/file94.jpg)'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![CD = max (|r1 − r2|,|g1 − g2|,|b1 − b2|) ](img/file94.jpg)'
- en: 'The Sorensen Distance (SD) is a modification of the Manhattan distance that
    tends to normalize the distance:'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索尔森距离(SD)是对曼哈顿距离的一种修改，倾向于标准化距离：
- en: '![ |r1 −-r2|+-|g1 −-g2|+-|b1 −-b2| SD = r1 + r2 + g1 + g2 + b1 + b2 ](img/file95.jpg)'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![ |r1 −-r2|+-|g1 −-g2|+-|b1 −-b2| SD = r1 + r2 + g1 + g2 + b1 + b2 ](img/file95.jpg)'
- en: Redefine the `make_color_map()` function to be a higher-order function that
    will accept a distance function as a parameter. All of the distance functions
    should have a type hint of `Callable[[RGB,`` Color],`` float]`. Once the `make_color_map()`
    function has been changed, it becomes possible to create alternative color maps
    with alternative distance functions.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 重新定义`make_color_map()`函数，使其成为一个接受距离函数作为参数的高阶函数。所有距离函数都应该有`Callable[[RGB, Color],
    float]`类型的提示。一旦`make_color_map()`函数被修改，就可以使用不同的距离函数创建替代的颜色图。
- en: This function creates a mapping from ”masked” RGB values to a defined set of
    colors. Using a 3-bit mask defines a mapping from 2³ × 2³ × 2³ = 512 possible
    RGB values to the domain of 133 colors.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数创建从“掩码”RGB值到定义的颜色集的映射。使用3位掩码定义从2³ × 2³ × 2³ = 512个可能的RGB值到133个颜色域的映射。
- en: 'The function’s definition should look like this:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的定义应该如下所示：
- en: '[PRE26]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How much difference does the choice of distance function make? How can we characterize
    the mapping from the large collection of possible RGB values to the limited domain
    of subset colors? Is a histogram showing how many distinct RGB values map to a
    subset color sensible and informative?
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 距离函数的选择对差异有多大？我们如何描述从大量可能的RGB值到有限的颜色子集域的映射？显示有多少不同的RGB值映射到子集颜色的直方图是否合理且具有信息性？
- en: 9.8.2 Actual domain of pixel color values
  id: totrans-413
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.8.2像素颜色值的实际域
- en: When creating a color map, a mask was used to reduce the domain of possible
    colors from 2⁸ × 2⁸ × 2⁸ = 16,777,216 to a more manageable 2³ × 2³ × 2³ = 512
    possible values.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建颜色图时，使用了一个掩码来将可能的颜色域从2⁸ × 2⁸ × 2⁸ = 16,777,216减少到更易于管理的2³ × 2³ × 2³ = 512个可能值。
- en: Does it make sense to scan the original image using the mask value to determine
    the actual domain of available colors? A given image, may, for example, have only
    210 distinct colors when a 3-bit mask is used. How much additional time is required
    to create this summary of colors actually in use?
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 使用掩码值扫描原始图像以确定实际可用颜色的域是否有意义？例如，当使用3位掩码时，一个给定的图像可能有210种不同的颜色。创建此颜色摘要实际上需要多少额外的时间？
- en: Can the color summary be further optimized? Could we, for example, exclude rarely
    used colors? If we do exclude these rarely used colors, how do we replace a pixel’s
    color with more commonly used colors? What changes in an image if we use the color
    of the majority of the neighboring pixels to replace pixels with rarely used colors?
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色摘要能否进一步优化？例如，我们能否排除很少使用的颜色？如果我们排除这些很少使用的颜色，我们如何用更常用的颜色替换像素的颜色？如果我们用大多数相邻像素的颜色替换很少使用的颜色，图像会有什么变化？
- en: 'Consider an algorithm that makes the following two passes over an image’s pixels:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个算法，该算法对图像的像素进行以下两次遍历：
- en: Create a `Counter` with the frequency of each color.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含每种颜色频率的`Counter`。
- en: For colors with fewer than some threshold, 𝜖, locate the neighboring pixels.
    In a corner, there may be as few as three. In the middle, there will be no more
    than eight. Find the color of the majority of those pixels and replace the outlier.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于少于某个阈值𝜖的颜色，找到相邻像素。在角落处，可能只有三个。在中间，不会超过八个。找到大多数这些像素的颜色并替换异常值。
- en: '![Algorithm 8: Imperative iteration ](img/Algo_9.1.JPG)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![算法8：命令式迭代](img/Algo_9.1.JPG)'
- en: 'Algorithm 8: Imperative iteration'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 算法8：命令式迭代
- en: Before starting on this algorithm, it’s important to consider any ”edge” cases.
    Specifically, there is a potential complication when rarely used colors are adjacent.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始这个算法之前，考虑任何“边缘”情况是很重要的。特别是，当很少使用的颜色相邻时，可能会出现潜在的复杂情况。
- en: 'Consider this case:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下情况：
- en: '|'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| p[(0,0)] | p[(1,0)] | p[(2,0)] |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| p[(0,0)] | p[(1,0)] | p[(2,0)] |'
- en: '|'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| p[(0,1)] | p[(1,1)] | p[(2,1)] |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| p[(0,1)] | p[(1,1)] | p[(2,1)] |'
- en: '|'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| p[(0,2)] | p[(1,2)] | p[(2,2)] |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| p[(0,2)] | p[(1,2)] | p[(2,2)] |'
- en: '|'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  |  |  |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |'
- en: If the four pixels in the top-left corner, p[(0,0)], p[(1,0)], p[(0,1)], and
    p[(1,1)], all had rarely used colors, then it would be difficult to pick a majority
    color to replace p[(0,0)].
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 如果左上角四个像素p[(0,0)]、p[(1,0)]、p[(0,1)]和p[(1,1)]都具有很少使用的颜色，那么很难选择一个多数颜色来替换p[(0,0)]。
- en: In the case where there are no non-rare colors surrounding a pixel with a rare
    color, the algorithm would need to queue this up for later resolution after the
    neighbors have been processed. In this example, the color for pixel p[(1,0)] can
    be computed using neighbors that are not rare colors. After p[(0,1)] and p[(1,1)]
    are also resolved, then p[(0,0)] can be replaced with the majority color of the
    three neighbors.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有非稀有颜色围绕一个稀有颜色的像素的情况下，算法需要在处理了邻居之后将其排队以供稍后解决。在这个例子中，像素p[(1,0)]的颜色可以使用不是稀有颜色的邻居来计算。在p[(0,1)]和p[(1,1)]也被解决之后，p[(0,0)]可以用三个邻居的大多数颜色来替换。
- en: Is this algorithmic complexity helpful for a picture with 10 million pixels?
    Choosing one or a few photos arbitrarily isn’t a sophisticated survey. However,
    it can help to avoid overthinking potential problems.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的复杂性对于有1000万个像素的图片有帮助吗？任意选择一张或几张照片并不算是一个复杂的调查。然而，它可以帮助避免过度思考潜在的问题。
- en: Survey the colors in a collection of images. How common is it to see a single
    pixel with a unique color? If you don’t have a private collection of images, visit
    [kaggle.com](https://kaggle.com) to look for image datasets that can be examined.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 调查一组图片中的颜色。看到单个具有独特颜色的像素有多常见？如果您没有私人图片收藏，请访问[kaggle.com](https://kaggle.com)寻找可以检查的图像数据集。
- en: 9.8.3 Cribbage hand scoring
  id: totrans-460
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.8.3 克里比奇手牌得分
- en: The card game of cribbage involves a phase where a player’s hand is evaluated.
    A player will use four cards that are dealt to them, plus a fifth card, called
    the starter.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 克里比奇牌戏涉及一个阶段，玩家的手牌被评估。玩家将使用分发给他们的四张牌，加上一张称为起始牌的第五张牌。
- en: To avoid overusing the word ”points,” we’ll consider each card to have a number
    of pips. Each face card is counted as having 10 pips; all other cards have a number
    of pips equal to their rank. Aces have a single pip.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免过度使用“点”这个词，我们将考虑每张牌都有一个点数。每张面牌计为10点；所有其他牌的点数等于它们的等级。A计为一点。
- en: 'The scoring involves the following combinations of cards:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 得分涉及以下牌的组合：
- en: Any combination of cards that totals 15 pips adds 2 points to the score.
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何总点数为15的牌的组合为得分增加2分。
- en: Pairs – two cards of the same rank – add 2 points to the score.
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对子—两张相同等级的牌—为得分增加2分。
- en: Any run of three, four, or five cards adds 3, 4, or 5 points to the score.
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何三张、四张或五张牌的顺子都会为得分增加3分、4分或5分。
- en: A flush of four cards in a hand adds 4 points to the score. If the starter card
    is of the same suit, then the flush, as a whole, is 5 points.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一手牌中的四张同花色的牌为得分增加4分。如果起始牌也是同一花色，那么整个同花顺为5分。
- en: If a jack in a hand has the same suit as the starter card, this adds 1 point
    to the score.
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一手牌中的杰克与起始牌的花色相同，这将为得分增加1分。
- en: If a hand contains three cards of the same rank, this is counted as three separate
    pairs, worth 6 points in aggregate.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一手牌包含三张相同等级的牌，这算作三个单独的对子，总共值6分。
- en: 'An interesting hand involves runs with a pair. For example, a hand 7C, 7D,
    8H, and 9S, with an irrelevant starter card of a Queen, has two runs—7C, 8H, 9S,
    and 7D, 8H, 9S—and a pair of 7’s. This is a total of 8 points. Furthermore, there
    are two combinations that add to 15: 7C, 8H and 7D, 8H, bringing the hand’s value
    to 12 points.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的手牌包含带有对子的顺子。例如，一张手牌7C、7D、8H和9S，以及一个无关的起始牌王后，有两个顺子—7C、8H、9S和7D、8H、9S—以及一对7。这总共是8分。此外，还有两种组合加起来是15分：7C、8H和7D、8H，将手牌的价值提升到12分。
- en: Note that a 4-card run is not counted as two overlapping 3-card runs. It’s only
    worth 4 points.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，4张牌的顺子不算作两个重叠的3张牌的顺子。它只值4分。
- en: 'Another interesting example is holding 4C, 5D, 5H, 6S, and the starter card
    is 3C. There are two distinct runs of 4 cards: 3C, 4C, 5D, 6S, and 3C, 4C, 5H,
    6S, as well a pair of 5s, leading to 10 points for this pattern. Additionally,
    there are two distinct ways to count 15 pips: 4C, 5D, 6S and 4C, 5H, 6S, adding
    4 more points to the score.'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的例子是持有4C、5D、5H、6S，起始牌是3C。有两个不同的4张牌顺子：3C、4C、5D、6S和3C、4C、5H、6S，以及一对5，这个模式总共是10分。此外，有两种不同的方式计算15点：4C、5D、6S和4C、5H、6S，为得分增加4分。
- en: 'A handy algorithm for this is to enumerate several combinations and permutations
    of cards to locate all the scoring. The following rules can be applied:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此问题的一个实用算法是列举几张牌的组合和排列，以定位所有得分。以下规则可以应用：
- en: 'Iterate over the powerset of the cards. This is the set of all subsets: all
    of the singletons, all of the pairs, all of the triples, etc., up to the set of
    all five cards. Each of these is a distinct set, some of which will tally to 15
    pips. For more information on generating the powerset, see the Itertools Recipes
    section of the Python Standard Library documentation.'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历牌的幂集。这是所有子集的集合：所有单张牌、所有对子、所有三张牌等，直到所有五张牌的集合。这些每个都是独特的集合，其中一些的总点数为15点。有关生成幂集的更多信息，请参阅Python标准库文档中的Itertools食谱部分。
- en: Enumerate all pairs of cards to compute scores for any pairs. The `combinations()`
    function works well for this.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出所有牌对以计算任何牌对的分数。`combinations()`函数对此非常适用。
- en: For sets of five cards, if they’re adjacent, ascending values, this is a run.
    If they’re not adjacent, ascending values, then enumerate the sets of four-card
    runs to see if either of these have adjacent numbers. Failing that test, enumerate
    all sets of three-card runs to see if any of these have adjacent numbers. The
    longest run applies to the score, and shorter runs are ignored.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于五张牌的集合，如果它们是相邻的、升序的值，则这是一个连牌。如果不是相邻的、升序的值，则列出四张牌连牌的集合，以查看这些连牌中是否有相邻的数字。如果这个测试失败，则列出所有三张牌连牌的集合，以查看这些连牌中是否有相邻的数字。最长的连牌适用于计分，较短的连牌则被忽略。
- en: Check the hand and starter for a five-flush. If there’s no five-flush, check
    the hand only for a four-flush. Only one of these two combinations is scored.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查手牌和起始牌是否构成五顺子。如果没有五顺子，则只检查手牌是否构成四顺子。这两种组合中只有一种是计分的。
- en: Also, check to see if the hand has a jack of the same suit as the starter.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，检查手牌中是否有与起始牌同花色的杰克。
- en: Since there are only five cards involved in this, the number of permutations
    and combinations is rather small. Be prepared to summarize exactly how many combinations
    and permutations are required for a five-card hand.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只涉及五张牌，排列和组合的数量相对较小。准备好精确总结五张牌手牌所需的组合和排列数量。
- en: Join our community Discord space
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间
- en: 'Join our Python Discord workspace to discuss and know more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的Python Discord工作空间，讨论并了解更多关于这本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
