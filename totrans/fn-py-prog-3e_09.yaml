- en: '9'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Itertools for Combinatorics – Permutations and Combinations
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming emphasizes stateless algorithms. In Python, this leads
    us to work with generator expressions, generator functions, and iterables. In
    this chapter, we’ll continue our study of the `itertools` library, with numerous
    functions to help us work with iterable collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we looked at three broad groupings of iterator functions.
    They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions that work with infinite iterators, which can be applied to any iterable
    or an iterator over any collection; they consume the entire source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions that work with finite iterators, which can either accumulate a source
    multiple times, or produce a reduction of the source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `tee()` iterator function, which clones an iterator into several copies
    that can each be used independently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll look at the `itertools` functions that work with permutations
    and combinations. These include several combinatorial functions and a few recipes
    built on these functions. The functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`product()`: This function forms a Cartesian product equivalent to the nested
    `for` statements or nested generator expressions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`permutations()`: This function yields tuples of length r from a universe p
    in all possible orderings; there are no repeated elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`combinations()`: This function yields tuples of length r from a universe p
    in sorted order; there are no repeated elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`combinations_with_replacement()`: This function yields tuples of length r
    from p in sorted order, allowing the repetition of elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These functions embody algorithms that can create potentially large result sets
    from small collections of input data. Some kinds of problems have exact solutions
    based on exhaustively enumerating the universe of permutations. As a trivial example,
    when trying to find out if a hand of cards contains a straight (all numbers in
    adjacent, ascending order), one solution is to compute all permutations and see
    if at least one arrangement of cards is ascending. For a 5-card hard, there are
    only 120 arrangements. These functions make it simple to yield all the permutations;
    in some cases, this kind of simple enumeration isn’t optimal or even desirable.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1 Enumerating the Cartesian product
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The term Cartesian product refers to the idea of enumerating all the possible
    combinations of elements drawn from the elements of sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mathematically, we might say that the product of two sets, {1,2,3,…,13}×{♣,♢,♡,♠},
    has 52 pairs, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![{(1,♣),(1,♢),(1,♡ ),(1,♠ ),(2,♣ ),(2,♢ ),(2,♡),(2,♠),...,(13,♣ ),(13,♢),(13,♡),(13,♠
    )} ](img/file80.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can produce the preceding results by executing the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The calculation of a product can be extended to any number of iterable collections.
    Using a large number of collections can lead to a very large result set.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2 Reducing a product
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In relational database theory, a join between tables can be thought of as a
    filtered product. For those who know SQL, the `SELECT` statement joining tables
    without a `WHERE` clause will produce a Cartesian product of rows in the tables.
    This can be thought of as the worst-case algorithm—a vast product without any
    useful filtering to pick the desired subset of results. We can implement this
    using the `itertools.product()` function to enumerate all possible combinations
    and filter those to keep the few that match properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a `join()` function to join two iterable collections or generators,
    as shown in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: All combinations of the two iterables, `t1` and `t2`, are computed. The `filter()`
    function will apply the given `where()` function to pass or reject two-tuples,
    hinted as `tuple[JTL,`` JTR]`, that match properly. The `where()` function has
    the hint `Callable[[tuple[JTL,`` JTR]],` `bool]` to show that it returns a Boolean
    result. This is typical of how SQL database queries work in the worst-case situation
    where there are no useful indexes or cardinality statistics to suggest a better
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: While this algorithm always works, it can be terribly inefficient. We often
    need to look carefully at the problem and the available data to find a more efficient
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll generalize the problem slightly by replacing the simple Boolean
    matching function. Instead of a binary result, it’s common to look for a minimum
    or maximum of some distance between items. In this case, the comparison yields
    a float value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that we have a class to define instances in a table of `Color` objects,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example of using this definition to create some `Color` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For more information, see [Chapter 6](Chapter_06.xhtml#x1-1260006), [Recursions
    and Reductions](Chapter_06.xhtml#x1-1260006), where we showed you how to parse
    a file of colors to create `NamedTuple` objects. In this case, we’ve left the
    RGB color as a `tuple[int,`` int,`` int]`, instead of decomposing each individual
    field.
  prefs: []
  type: TYPE_NORMAL
- en: 'An image will have a collection of pixels, each of which is an RGB tuple. Conceptually,
    an image contains data like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As a practical matter, the Python Imaging Library (PIL) package presents the
    pixels in a number of forms. One of these is the mapping from the (x,y) coordinate
    to the RGB triple. For the Pillow project documentation, visit [https://pypi.python.org/pypi/Pillow](https://pypi.python.org/pypi/Pillow).
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a `PIL.Image` object, we can iterate over the collection of pixels with
    something like the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This function determines the range of each coordinate based on the image size,
    `img.size`. The values of the `product(range(w),`` range(h))` method create all
    the possible combinations of coordinates. It has a result identical to two nested
    `for` statements in a single expression.
  prefs: []
  type: TYPE_NORMAL
- en: This has the advantage of enumerating each pixel with its coordinates. We can
    then process the pixels in no particular order and still reconstruct an image.
    This is particularly handy when using multiprocessing or multithreading to spread
    the workload among several cores or processors. The `concurrent.futures` module
    provides an easy way to distribute work among cores or processors.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.1 Computing distances
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A number of decision-making problems require that we find a close enough match.
    We might not be able to use a simple equality test. Instead, we have to use a
    distance metric and locate items with the shortest distance to our target. The
    k-Nearest Neighbors (k-NN) algorithm, for example, uses a training set of data
    and a distance measurement function. It locates the k nearest neighbors to an
    unknown sample, and uses the majority of those neighbors to classify the unknown
    sample.
  prefs: []
  type: TYPE_NORMAL
- en: To explore this concept of enumerating all possible matches, we’ll use a slightly
    simpler example. However, even though it’s superficially simpler, it doesn’t work
    out well if we approach it naively and exhaustively enumerate all potential matches.
  prefs: []
  type: TYPE_NORMAL
- en: When doing color matching, we won’t have a simple equality test. A color, C,
    for our purposes, is a triple ⟨r,g,b⟩. It’s a point in three-dimensional space.
    It’s often sensible to define a minimal distance function to determine whether
    two colors are close enough, without having the same three values of ⟨r[1],g[1],b[1]⟩
    = ⟨r[2],g[2],b[2]⟩. We need a multi-dimensional distance computation, using the
    red, green, and blue axes of a color space. There are several common approaches
    to measuring distance, including the Euclidean distance, Manhattan distance, and
    other more complex weightings based on visual preferences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the Euclidean and Manhattan distance functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The Euclidean distance measures the hypotenuse of a right-angled triangle among
    the three points in an RGB space. Here’s the formal definition for three dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∘ -------------------------------- ED (c1,c2) = (r1 − r2)2 + (g1 − g2)2
    + (b1 − b2)2 ](img/file81.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here’s a two-dimensional sketch of the Euclidean distance between two points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ √ ------- ((E14D,,15))= 32 + 42 = 5](img/file82.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Manhattan distance sums the edges of each leg of the right-angled triangle
    among the three points. It’s named after the gridded layout of the Borough of
    Manhattan in New York City. To get around, one is forced to travel only on the
    streets and avenues. Here’s the formal definition for three dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![M D(c1,c2) = (r1 − r2) + (g1 − g2)+ (b1 − b2) ](img/file83.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here’s a two-dimensional sketch of the Manhattan distance between two points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![((M14,,D15))= 3+ 4 = 7](img/file84.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Euclidean distance offers precision, while the Manhattan distance offers
    calculation speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking forward, we’re aiming for a structure that looks like this. For each
    individual pixel, we can compute the distance from that pixel’s color to the available
    colors in a limited color set. The results of this calculation for one individual
    pixel of an image might start like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve shown a sequence of tuples; each tuple has four items:'
  prefs: []
  type: TYPE_NORMAL
- en: The pixel’s coordinates; for example, (0,0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pixel’s original color; for example, (92, 139, 195)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Color` object from a set of seven colors; for example, `Color``(``rgb``=(48,`
    `186,` `143)``,` `name``=’``Mountain` `Meadow``’)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Euclidean distance between the original color and the given `Color` object;
    for example, 82.75868534480233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can help to create a `NamedTuple` to encapsulate the four items in each tuple.
    We could call it an X-Y, Pixel, Color, Distance tuple, something like ”XYPCD.”
    This would make it slightly easier to identify the (x,y) coordinate, the original
    pixel’s color, the matching color, and the distance between the original color
    and the selected match.
  prefs: []
  type: TYPE_NORMAL
- en: 'The smallest Euclidean distance is a closest match color. For the four example
    colors, the Mountain Meadow is the closest match for this pixel. This kind of
    reduction is done with the `min()` function. If the overall four-tuple of (x,y),
    pixel, color, and distance is assigned to a variable name, `choices`, the pixel-level
    reduction would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This expression will pick a single tuple as the optimal match between a pixel
    and color. It uses a lambda to select item 3 from the tuple, the distance metric.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.2 Getting all pixels and all colors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How do we get to the structure that contains all pixels and all colors? One
    seemingly simple answer turns out to be less than optimal.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to map pixels to colors is to enumerate all pixels and all colors using
    the `product()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The core of this is the `product(pixel_iter(img),`` colors)` expression that
    creates a sequence of all pixels combined with all colors. The overall expression
    then applies the `euclidean()` function to compute distances between pixels and
    `Color` objects. The result is a sequence of four-tuple objects with the original
    (x,y) coordinate, the original pixel, an available color, and the distance between
    the original pixel color and the available color.
  prefs: []
  type: TYPE_NORMAL
- en: The final selection of colors uses the `groupby()` function and the `min(choices,`` ...)`
    expression to locate the closest match.
  prefs: []
  type: TYPE_NORMAL
- en: The `product()` function applied to pixels and colors creates a long, flat iterable.
    We grouped the iterable into smaller collections where the coordinates match.
    This will break the big iterable into smaller iterables of only the pool of colors
    associated with a single pixel. We can then pick the minimal color distance for
    each available color for a pixel.
  prefs: []
  type: TYPE_NORMAL
- en: In a picture that’s 3,648×2,736 pixels with 133 Crayola colors, we have an iterable
    with 3,648 × 2,736 × 133 = 1,327,463,424 items to be evaluated. That is a billion
    combinations created by this `distances` expression. The number is not necessarily
    impractical; it’s well within the limits of what Python can do. However, it reveals
    an important flaw in the naive use of the `product()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can’t trivially do this kind of large-scale processing without first doing
    some analysis to see how large the intermediate data will be. Here are some `timeit`
    numbers for these two distance functions. This is the overall number of seconds
    to do each of these calculations only 1,000,000 times:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Euclidean: 1.761'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Manhattan: 0.857'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling up by a factor of 1,000—from 1 million combinations to 1 billion—means
    the processing will take at least 1,800 seconds; that is, about half an hour for
    the Manhattan distance and 46 minutes to calculate the Euclidean distance. It
    appears this kind of naive bulk processing is ineffective for large datasets.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, we’re doing it wrong. This kind of width × height × color
    processing is simply a bad design. In many cases, we can do much better.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3 Performance improvements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A key feature of any big data algorithm is locating a way to execute some kind
    of a divide-and-conquer strategy. This is true of functional programming design
    as well as imperative design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are three options to speed up this processing:'
  prefs: []
  type: TYPE_NORMAL
- en: We can try to use parallelism to do more of the calculations concurrently. On
    a four-core processor, the time can be cut to approximately 25 percent. This reduces
    the time to 8 minutes for Manhattan distances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can see if caching intermediate results will reduce the amount of redundant
    calculation. The question arises of how many colors are the same and how many
    colors are unique.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can look for a radical change in the algorithm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll combine the last two points by computing all the possible comparisons
    between source colors and target colors. In this case, as in many other contexts,
    we can easily enumerate the entire mapping of pixels and colors. If colors are
    repeated, we avoid doing redundant calculations to locate the closest color. We’ll
    also change the algorithm from a series of comparisons to a series of lookups
    in a mapping object.
  prefs: []
  type: TYPE_NORMAL
- en: In many problem domains, the source data is a collection of floating-point values.
    While these `float` values are flexible, and correspond in some ways with the
    mathematical abstraction of real numbers, they introduce some additional costs.
    Float operations can be slower than integer operations. More importantly, float
    values can contain a number of ”noise” bits. For example, common RGB color definitions
    use 256 distinct values for each of the Red, Green, and Blue components. These
    values are represented exactly with 8 bits. A floating-point variant, using values
    from 0.0 to 1.0, would use the full 64 bits for each color. Any arithmetic that
    led to floating-point truncation would introduce noise. While `float` values seem
    simple, they introduce troubling problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example, using a red `r=15`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Algebraically, r[f] + ![1100](img/file85.jpg) −![1100-](img/file86.jpg) = r[f].
    However, the `float` definition is only an approximation of the abstract concept
    of a real number. The value of ![-1- 100](img/file87.jpg) doesn’t have an exact
    representation in binary-based floating-point. Using a value like this introduces
    truncation errors that propagate through subsequent computations. We’ve chosen
    to use integer-based color matching to show a way to minimize the additional complications
    that can arise from floating-point values.
  prefs: []
  type: TYPE_NORMAL
- en: 'When looking at this idea of pre-computing all transformations from source
    color to target color, we need some overall statistics for an arbitrary image.
    The code associated with this book includes `IMG_2705.jpg`. Here is a basic algorithm
    to collect all of the distinct color tuples from the specified image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We collected all pixels of a given color into a list organized by color. From
    this, we’ll learn the following facts:'
  prefs: []
  type: TYPE_NORMAL
- en: The total number of pixels is 9,980,928\. This fits the expectation for a 10-megapixel
    image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The total number of colors is 210,303\. If we try to compute the Euclidean distance
    between actual colors and the 133 target colors, we would do 27,970,299 calculations,
    which might take about 76 seconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we use a less accurate representation, one with fewer bits, we can speed
    things up. We’ll call this ”masking” to remove some of the irrelevant least-significant
    bits. Using a 3-bit mask, `0b11100000`, the total number of colors actually used
    is reduced to 214 out of a domain of 2³ × 2³ × 2³ = 512 possible colors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a 4-bit mask, `0b11110000`, 1,150 colors are actually used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a 5-bit mask, `0b11111000`, 5,845 colors are actually used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a 6-bit mask, `0b11111100`, 27,726 colors are actually used. The domain
    of possible colors swells to 2⁶ × 2⁶ × 2⁶ = 262,144.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This gives us some insight into how we can rearrange the data structure, calculate
    the matching colors quickly, and then rebuild the image without doing a billion
    comparisons and avoiding any additional complications from floating-point approximations.
    There are a number of changes required to avoid needless (and error-introducing)
    computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The core idea behind masking is to preserve the most significant bits of a
    value and eliminate the least significant bits. Consider a color with a red value
    of 200\. We can use the Python `bin()` function to see the binary representation
    of that value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The computation of `200`` &`` 0b11100000` applied a mask to conceal the least
    significant 5 bits and preserve the most significant 3 bits. What remains after
    the mask is applied as a red value of 192.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can apply mask values to the RGB three-tuple with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will pick out the most significant 3 bits of the red, green, and blue values
    of a color tuple by using the `&` operator to select particular bits from an integer
    value. If we use this masked value instead of the original color to create a `Counter`
    object, we’ll see that the image only uses 214 distinct values after the mask
    is applied. This is fewer than half the theoretical number of colors.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.1 Rearranging the problem
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The naive use of the `product()` function to compare all pixels and all colors
    was a bad idea. There are 10 million pixels, but only 200,000 unique colors. When
    mapping the source colors to target colors, we only have to save 200,000 values
    in a simple map.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll approach it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compute the source-to-target color mapping. In this case, let’s use 3-bit color
    values as output. Each R, G, and B value comes from the eight values in the `range(0,`` 256,`` 32)`
    expression. We can use this expression to enumerate all the output colors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can then compute the Euclidean distance to the nearest color in our source
    palette, doing just 68,096 calculations. This takes about 0.14 seconds. It’s done
    one time only and computes the 200,000 mappings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In one pass through the source image, we build a new image using the revised
    color table. In some cases, we can exploit the truncation of integer values. We
    can use an expression such as `(0b11100000&r,`` 0b11100000&g,`` 0b11100000&b)`
    to remove the least significant bits of an image color. We’ll look at this additional
    reduction in computation later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will replace a billion distance calculations with 10 million dictionary
    lookups, transforming a potential 30 minutes of calculation into about 30 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Given a source palette of approximately 200,000 colors, we can apply a fast
    Manhattan distance to locate the nearest color in a target palette, such as the
    Crayola colors.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll fold in yet another optimization—truncation. This will give us an even
    faster algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.2 Combining two transformations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When combining multiple transformations, we can build a more complex mapping
    from the source through intermediate targets to the result. To illustrate this,
    we’ll truncate the colors as well as applying a mapping.
  prefs: []
  type: TYPE_NORMAL
- en: In some problem contexts, truncation can be difficult. In other cases, it’s
    often quite simple. For example, truncating US postal ZIP codes from nine to five
    characters is common. Postal codes can be further truncated to three characters
    to determine a regional facility that represents a larger geography.
  prefs: []
  type: TYPE_NORMAL
- en: For colors, we can use the bit-masking shown previously to truncate colors from
    three 8-bit values (24 bits, 16 million colors) to three 3-bit values (9 bits,
    512 colors).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a way to build a color map that combines distances to a given set of
    colors and truncation of the source colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We created a range object, `bit3`, that will iterate through all eight of the
    3-bit color values. The use of the binary value, `0b0010_0000`, can help visualize
    the way the bits are being used. The least significant 5 bits will be ignored;
    only the upper 3 bits will be used.
  prefs: []
  type: TYPE_NORMAL
- en: The `range` objects aren’t like ordinary iterators; they can be used multiple
    times. As a result of this, the `product(bit3,`` bit3,`` bit3)` expression will
    produce all 512 color combinations that we’ll use as the output colors.
  prefs: []
  type: TYPE_NORMAL
- en: For each truncated RGB color, we created a three-tuple that has (0) the distance
    from all crayon colors, (1) the RGB color, and (2) the crayon `Color` object.
    When we ask for the minimum value of this collection, we’ll get the closest crayon
    `Color` object to the truncated RGB color.
  prefs: []
  type: TYPE_NORMAL
- en: We built a dictionary that maps from the truncated RGB color to the closest
    crayon. In order to use this mapping, we’ll truncate a source color before looking
    up the nearest crayon in the mapping. This use of truncation coupled with the
    pre-computed mapping shows how we might need to combine mapping techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function will build a new image from a color map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This uses the PIL `putpixel()` function to replace all of the pixels in a picture
    with other pixels. The mask value preserves the upper-most three bits of each
    color, reducing the number of colors to a subset.
  prefs: []
  type: TYPE_NORMAL
- en: What we’ve seen is that the naive use of some functional programming tools can
    lead to algorithms that are expressive and succinct, but also inefficient. The
    essential tools to compute the complexity of a calculation (sometimes called Big-O
    analysis) is just as important for functional programming as it is for imperative
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is not that the `product()` function is inefficient. The problem
    is that we can use the `product()` function to create an inefficient algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 9.4 Permuting a collection of values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we permute a collection of values, we’ll generate all the possible orders
    for the values in the collection. There are n! permutations of n items. We can
    use a sequence of permutations as a kind of brute-force solution to a variety
    of optimization problems.
  prefs: []
  type: TYPE_NORMAL
- en: Typical combinatorial optimization problems are the Traveling Salesman problem,
    the Minimum Spanning Tree problem, and the Knapsack problem. These problems are
    famous because they involve potentially vast numbers of permutations. Approximate
    solutions are necessary to avoid exhaustive enumeration of all permutations. The
    use of the `itertools.permutations()` function is only handy for exploring very
    small problems.
  prefs: []
  type: TYPE_NORMAL
- en: One popular example of these combinatorial optimization problems is the assignment
    problem. We have n agents and n tasks, but the cost of each agent performing a
    given task is not equal. Imagine that some agents have trouble with some details,
    while other agents excel at these details. If we can properly assign tasks to
    agents, we can minimize the costs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a simple grid that shows how well a given agent is able to perform
    a given task. For a small problem of seven agents and tasks, there will be a grid
    of 49 costs. Each cell in the grid shows agents A[0] to A[6] performing tasks
    T[0] to T[6]:'
  prefs: []
  type: TYPE_NORMAL
- en: Agent
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Task
  prefs: []
  type: TYPE_NORMAL
- en: A[0]
  prefs: []
  type: TYPE_NORMAL
- en: A[1]
  prefs: []
  type: TYPE_NORMAL
- en: A[2]
  prefs: []
  type: TYPE_NORMAL
- en: A[3]
  prefs: []
  type: TYPE_NORMAL
- en: A[4]
  prefs: []
  type: TYPE_NORMAL
- en: A[5]
  prefs: []
  type: TYPE_NORMAL
- en: A[6]
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: T[0]
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: T[1]
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  prefs: []
  type: TYPE_NORMAL
- en: '34'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: T[2]
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  prefs: []
  type: TYPE_NORMAL
- en: '22'
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: T[3]
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: T[4]
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: T[5]
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  prefs: []
  type: TYPE_NORMAL
- en: '22'
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: T[6]
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Given this grid, we can enumerate all the possible permutations of agents and
    their tasks. However, this approach doesn’t scale well. For this problem, there
    are 720 alternatives. If we have more agents, for example 10, the value of 10!
    is 3,628,800\. We can create the entire sequence of 3 million items with the `list(permutations(range(10)))`
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would expect to solve a problem of this tiny size in a fraction of a second.
    For 10!, we might take a few seconds. When we double the size of the problem to
    20!, we have a bit of a scalability problem: there will be 2.433 × 10^(18) permutations.
    On a computer where it takes about 0.56 seconds to generate 10! permutations,
    the process of generating 20! permutations would take about 12,000 years.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can formulate the exhaustive search for the optimal solution as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We’ve created all permutations of tasks for a group of agents and assigned this
    to `perms`. From this, we’ve created two-tuples of the sum of all costs in the
    cost matrix for a given permutation. To locate the relevant costs, a specific
    permutation is enumerated to create two-tuples showing the agent and the task
    assignment for that agent. For example, one of the permutations is tasks `(2,`` 4,`` 6,`` 1,`` 5,`` 3,`` 0)`.
    We can assign agent index values using the expression `list``(``enumerate``((2,`
    `4,` `6,` `1,` `5,` `3,` `0)``)``)`. The result, `[(0,`` 2),`` (1,`` 4),`` (2,`` 6),`` (3,`` 1),`` (4,`` 5),`` (5,`` 3),`` (6,`` 0)]`,
    has all seven agent index values and their associated task assignments. We can
    translate the index numbers to agent names and task names by incorporating a dictionary
    lookup. The sum of the values in the cost matrix tells us how expensive this specific
    task assignment would be.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the optimal solutions might look like the assignment above. It requires
    folding in the agent names and task names to translate the task permutation into
    a specific list of assignments:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| A[0] | T[2] |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| A[1] | T[4] |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| A[2] | T[6] |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| A[3] | T[1] |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| A[4] | T[5] |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| A[5] | T[3] |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| A[6] | T[0] |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  |'
  prefs: []
  type: TYPE_TB
- en: In some cases, there might be multiple optimal solutions; this algorithm will
    locate all of them. The expression `min(alt)[0]` selects the first of the set
    of minima.
  prefs: []
  type: TYPE_NORMAL
- en: For small textbook examples, this seems to be reasonably fast. There are linear
    programming approaches which avoid exhaustive enumeration of all permutations.
    The Python Linear Programming module PuLP can be used to solve the assignment
    problem. See [https://coin-or.github.io/pulp/](https://coin-or.github.io/pulp/).
  prefs: []
  type: TYPE_NORMAL
- en: 9.5 Generating all combinations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `itertools` module also supports computing all combinations of a set of
    values. When looking at combinations, the order doesn’t matter, so there are far
    fewer combinations than permutations. The number of combinations is often stated
    as ![(p) r](img/file88.jpg) = ![--p!-- r!(p− r)!](img/file89.jpg). This is the
    number of ways that we can take combinations of r things at a time from a universe
    of p items overall.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, there are 2,598,960 five-card poker hands. We can actually enumerate
    all 2 million hands by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'More practically, assume we have a dataset with a number of variables. A common
    exploratory technique is to determine the correlation among all pairs of variables
    in a set of data. If there are v variables, then we will enumerate all variables
    that must be compared by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A fun source of data for simple statistical analysis is the Spurious Correlations
    site. This has a great many datasets with surprising statistical properties. Let’s
    get some sample data from Spurious Correlations, [http://www.tylervigen.com](http://www.tylervigen.com),
    to show how this will work. We’ll pick three datasets with the same time range,
    datasets numbered 7, 43, and 3,890\. We’ll simply catenate the data into a grid.
    Because the source data repeats the `year` column, we’ll start with data that
    includes the repeated `year` column. We’ll eventually remove the obvious redundancy,
    but it’s often best to start with all of the data present as a way to confirm
    that the various sources of data align with each other properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the first and the remaining rows of the yearly data will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we can use the `combinations()` function to yield all the combinations
    of the nine variables in this dataset, taken two at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There are 36 possible combinations. We’ll have to reject the combinations that
    involve matching columns `year` and `year`. These will trivially correlate with
    a value of 1.00.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a function that picks a column of data out of our dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to use the `corr()` function from [Chapter 4](Chapter_04.xhtml#x1-740004),
    [Working with Collections](Chapter_04.xhtml#x1-740004), to compute the correlation
    between the two columns of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we can compute all combinations of correlations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: For each combination of columns, we’ve extracted the two columns of data from
    our dataset. The `header_p,`` *data_p`` =...` statement uses multiple assignments
    to separate the first item in the sequence, the header, from the remaining rows
    of data. If the headers match, we’re comparing a variable to itself. This will
    be `True` for the three combinations of year and year that stem from the redundant
    year columns.
  prefs: []
  type: TYPE_NORMAL
- en: Given a combination of columns, we will compute the correlation function and
    then print the two headings along with the correlation of the columns. We’ve intentionally
    chosen two datasets that show spurious correlations with a third dataset that
    does not follow the same pattern as closely. In spite of this, the correlations
    are remarkably high.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It’s not at all clear what this pattern means. Why do these values correlate?
    The presence of spurious correlations with no significance can cloud statistical
    analysis. We’ve located data that has strangely high correlations with no obvious
    causal factors.
  prefs: []
  type: TYPE_NORMAL
- en: What’s important is that a simple expression, `combinations(range(9),`` 2)`,
    enumerates all the possible combinations of data. This kind of succinct, expressive
    technique makes it easier to focus on the data analysis issues instead of the
    combinatoric algorithm considerations.
  prefs: []
  type: TYPE_NORMAL
- en: 9.5.1 Combinations with replacement
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `itertools` library has two functions for generating combinations of items
    selected from some set of values. The `combinations()` function reflects our expectations
    when dealing hands from a deck of cards: each card will appear at most once. The
    `combinations_with_` `replacement()` function reflects the idea of taking a card
    from a deck, writing it down, and then shuffling it back into the deck before
    selecting another card. This second procedure could potentially yield a five-card
    sample with five aces of spades.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this more clearly by using the following kind of expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There are ![(6) 2](img/file90.jpg) = 15 combinations of six things taken two
    at a time. There are 6² = 36 combinations when replacement is permitted, since
    any value is a possible member of the result.
  prefs: []
  type: TYPE_NORMAL
- en: 9.6 Recipes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `itertools` chapter of the Python library documentation is outstanding.
    The basic definitions are followed by a series of recipes that are extremely clear
    and helpful. Since there’s no reason to reproduce these, we’ll reference them
    here. They are required reading materials on functional programming in Python.
  prefs: []
  type: TYPE_NORMAL
- en: The Itertools Recipes section in the Python Standard Library is a wonderful
    resource. Visit [https://docs.python.org/3/library/itertools.html#itertools-recipes](https://docs.python.org/3/library/itertools.html#itertools-recipes)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: These function definitions aren’t importable functions in the `itertools` modules.
    These are ideas that need to be read and understood and then, perhaps, copied
    or modified before inclusion in an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes some recipes that show functional programming
    algorithms built from the itertools basics:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '| Function Name | Arguments | Results |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `powerset` | `(iterable)` | Generate all the subsets of the iterable. Each
    subset is a tuple object, not a set instance. |'
  prefs: []
  type: TYPE_TB
- en: '| `random\_product` | `(*args,`` repeat=1)` | Randomly select from `product()`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `random\_permutation` | `(iterable,`` r=None)` | Randomly select from `permutations()`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `random\_combination` | `(iterable,`` r)` | Randomly select from `combinations()`.
    |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |'
  prefs: []
  type: TYPE_TB
- en: 9.7 Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we looked at a number of functions in the `itertools` module.
    This standard library module provides a number of functions that help us work
    with iterators in sophisticated ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'We looked at these combination-producing functions:'
  prefs: []
  type: TYPE_NORMAL
- en: The `product()` function computes all the possible combinations of the elements
    chosen from two or more collections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `permutations()` function gives us different ways to reorder a given set
    of values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `combinations()` function returns all the possible subsets of an original
    set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also looked at ways in which the `product()` and `permutations()` functions
    can be used naively to create extremely large result sets. This is an important
    cautionary note. A succinct and expressive algorithm can also involve a vast amount
    of computation. We must perform basic complexity analysis to be sure that the
    code will finish in a reasonable amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look at the `functools` module. This module includes
    some tools to work with functions as first-class objects. This builds on some
    material shown in [Chapter 2](Chapter_02.xhtml#x1-340002), [Introducing Essential
    Functional Concepts](Chapter_02.xhtml#x1-340002), and [Chapter 5](Chapter_05.xhtml#x1-1000005),
    [Higher-Order Functions](Chapter_05.xhtml#x1-1000005).
  prefs: []
  type: TYPE_NORMAL
- en: 9.8 Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter’s exercises are based on code available from Packt Publishing on
    GitHub. See [https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the reader will notice that the code provided on GitHub includes
    partial solutions to some of the exercises. These serve as hints, allowing the
    reader to explore alternative solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, exercises will need unit test cases to confirm they actually
    solve the problem. These are often identical to the unit test cases already provided
    in the GitHub repository. The reader should replace the book’s example function
    name with their own solution to confirm that it works.
  prefs: []
  type: TYPE_NORMAL
- en: 9.8.1 Alternative distance computations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: See Effects of Distance Measure Choice on KNN Classifier Performance - A Review.
    This is available at [https://arxiv.org/pdf/1708.04321](https://arxiv.org/pdf/1708.04321).
    In this paper, dozens of distance metrics are examined for their utility in implementing
    the k-Nearest Neighbors (k-NN) classifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of these are also suitable for the color-matching algorithm presented
    in this chapter. We defined a color, c, a three-tuple, (r,g,b), based on the Red,
    Green, and Blue components of the color. We can compute the distance between two
    colors, D(c[1],c[2]), based on their RGB components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( ) D (c1,c2) = D (r1,g1,b1),(r2,g2,b2) ](img/file91.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We showed two: Euclidean and Manhattan distances. Here are some more formal
    definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∘ -------2-----------2----------2- ED = (r1 − r2) + (g1 − g2) + (b1 − b2)
    ](img/file92.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![M D = |r1 − r2|+ |g1 − g2|+ |b1 − b2| ](img/file93.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Some additional examples include these:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Chebyshev Distance (CD) is the maximum of the absolute values of each color
    difference:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![CD = max (|r1 − r2|,|g1 − g2|,|b1 − b2|) ](img/file94.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The Sorensen Distance (SD) is a modification of the Manhattan distance that
    tends to normalize the distance:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![ |r1 −-r2|+-|g1 −-g2|+-|b1 −-b2| SD = r1 + r2 + g1 + g2 + b1 + b2 ](img/file95.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Redefine the `make_color_map()` function to be a higher-order function that
    will accept a distance function as a parameter. All of the distance functions
    should have a type hint of `Callable[[RGB,`` Color],`` float]`. Once the `make_color_map()`
    function has been changed, it becomes possible to create alternative color maps
    with alternative distance functions.
  prefs: []
  type: TYPE_NORMAL
- en: This function creates a mapping from ”masked” RGB values to a defined set of
    colors. Using a 3-bit mask defines a mapping from 2³ × 2³ × 2³ = 512 possible
    RGB values to the domain of 133 colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function’s definition should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How much difference does the choice of distance function make? How can we characterize
    the mapping from the large collection of possible RGB values to the limited domain
    of subset colors? Is a histogram showing how many distinct RGB values map to a
    subset color sensible and informative?
  prefs: []
  type: TYPE_NORMAL
- en: 9.8.2 Actual domain of pixel color values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When creating a color map, a mask was used to reduce the domain of possible
    colors from 2⁸ × 2⁸ × 2⁸ = 16,777,216 to a more manageable 2³ × 2³ × 2³ = 512
    possible values.
  prefs: []
  type: TYPE_NORMAL
- en: Does it make sense to scan the original image using the mask value to determine
    the actual domain of available colors? A given image, may, for example, have only
    210 distinct colors when a 3-bit mask is used. How much additional time is required
    to create this summary of colors actually in use?
  prefs: []
  type: TYPE_NORMAL
- en: Can the color summary be further optimized? Could we, for example, exclude rarely
    used colors? If we do exclude these rarely used colors, how do we replace a pixel’s
    color with more commonly used colors? What changes in an image if we use the color
    of the majority of the neighboring pixels to replace pixels with rarely used colors?
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an algorithm that makes the following two passes over an image’s pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Counter` with the frequency of each color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For colors with fewer than some threshold, 𝜖, locate the neighboring pixels.
    In a corner, there may be as few as three. In the middle, there will be no more
    than eight. Find the color of the majority of those pixels and replace the outlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Algorithm 8: Imperative iteration ](img/Algo_9.1.JPG)'
  prefs: []
  type: TYPE_IMG
- en: 'Algorithm 8: Imperative iteration'
  prefs: []
  type: TYPE_NORMAL
- en: Before starting on this algorithm, it’s important to consider any ”edge” cases.
    Specifically, there is a potential complication when rarely used colors are adjacent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| p[(0,0)] | p[(1,0)] | p[(2,0)] |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| p[(0,1)] | p[(1,1)] | p[(2,1)] |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| p[(0,2)] | p[(1,2)] | p[(2,2)] |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  |  |'
  prefs: []
  type: TYPE_TB
- en: If the four pixels in the top-left corner, p[(0,0)], p[(1,0)], p[(0,1)], and
    p[(1,1)], all had rarely used colors, then it would be difficult to pick a majority
    color to replace p[(0,0)].
  prefs: []
  type: TYPE_NORMAL
- en: In the case where there are no non-rare colors surrounding a pixel with a rare
    color, the algorithm would need to queue this up for later resolution after the
    neighbors have been processed. In this example, the color for pixel p[(1,0)] can
    be computed using neighbors that are not rare colors. After p[(0,1)] and p[(1,1)]
    are also resolved, then p[(0,0)] can be replaced with the majority color of the
    three neighbors.
  prefs: []
  type: TYPE_NORMAL
- en: Is this algorithmic complexity helpful for a picture with 10 million pixels?
    Choosing one or a few photos arbitrarily isn’t a sophisticated survey. However,
    it can help to avoid overthinking potential problems.
  prefs: []
  type: TYPE_NORMAL
- en: Survey the colors in a collection of images. How common is it to see a single
    pixel with a unique color? If you don’t have a private collection of images, visit
    [kaggle.com](https://kaggle.com) to look for image datasets that can be examined.
  prefs: []
  type: TYPE_NORMAL
- en: 9.8.3 Cribbage hand scoring
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The card game of cribbage involves a phase where a player’s hand is evaluated.
    A player will use four cards that are dealt to them, plus a fifth card, called
    the starter.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid overusing the word ”points,” we’ll consider each card to have a number
    of pips. Each face card is counted as having 10 pips; all other cards have a number
    of pips equal to their rank. Aces have a single pip.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scoring involves the following combinations of cards:'
  prefs: []
  type: TYPE_NORMAL
- en: Any combination of cards that totals 15 pips adds 2 points to the score.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pairs – two cards of the same rank – add 2 points to the score.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any run of three, four, or five cards adds 3, 4, or 5 points to the score.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A flush of four cards in a hand adds 4 points to the score. If the starter card
    is of the same suit, then the flush, as a whole, is 5 points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a jack in a hand has the same suit as the starter card, this adds 1 point
    to the score.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a hand contains three cards of the same rank, this is counted as three separate
    pairs, worth 6 points in aggregate.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting hand involves runs with a pair. For example, a hand 7C, 7D,
    8H, and 9S, with an irrelevant starter card of a Queen, has two runs—7C, 8H, 9S,
    and 7D, 8H, 9S—and a pair of 7’s. This is a total of 8 points. Furthermore, there
    are two combinations that add to 15: 7C, 8H and 7D, 8H, bringing the hand’s value
    to 12 points.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that a 4-card run is not counted as two overlapping 3-card runs. It’s only
    worth 4 points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting example is holding 4C, 5D, 5H, 6S, and the starter card
    is 3C. There are two distinct runs of 4 cards: 3C, 4C, 5D, 6S, and 3C, 4C, 5H,
    6S, as well a pair of 5s, leading to 10 points for this pattern. Additionally,
    there are two distinct ways to count 15 pips: 4C, 5D, 6S and 4C, 5H, 6S, adding
    4 more points to the score.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A handy algorithm for this is to enumerate several combinations and permutations
    of cards to locate all the scoring. The following rules can be applied:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterate over the powerset of the cards. This is the set of all subsets: all
    of the singletons, all of the pairs, all of the triples, etc., up to the set of
    all five cards. Each of these is a distinct set, some of which will tally to 15
    pips. For more information on generating the powerset, see the Itertools Recipes
    section of the Python Standard Library documentation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enumerate all pairs of cards to compute scores for any pairs. The `combinations()`
    function works well for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For sets of five cards, if they’re adjacent, ascending values, this is a run.
    If they’re not adjacent, ascending values, then enumerate the sets of four-card
    runs to see if either of these have adjacent numbers. Failing that test, enumerate
    all sets of three-card runs to see if any of these have adjacent numbers. The
    longest run applies to the score, and shorter runs are ignored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the hand and starter for a five-flush. If there’s no five-flush, check
    the hand only for a four-flush. Only one of these two combinations is scored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, check to see if the hand has a jack of the same suit as the starter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since there are only five cards involved in this, the number of permutations
    and combinations is rather small. Be prepared to summarize exactly how many combinations
    and permutations are required for a five-card hand.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community Discord space
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Join our Python Discord workspace to discuss and know more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
