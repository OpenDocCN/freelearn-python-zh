["```py\ndef original(...):\n    ...\noriginal = modifier(original) \n```", "```py\n@modifier\ndef original(...):\n   ... \n```", "```py\n# decorator_function_1.py\nclass ControlledException(Exception):\n    \"\"\"A generic exception on the program's domain.\"\"\"\ndef retry(operation):\n    @wraps(operation)\n    def wrapped(*args, **kwargs):\n        last_raised = None\n        RETRIES_LIMIT = 3\n        for _ in range(RETRIES_LIMIT):\n            try:\n                return operation(*args, **kwargs)\n            except ControlledException as e:\n                logger.info(\"retrying %s\", operation.__qualname__)\n                last_raised = e\n        raise last_raised\n    return wrapped \n```", "```py\n@retry\ndef run_operation(task):\n    \"\"\"Run a particular task, simulating some failures on its execution.\"\"\"\n    return task.run() \n```", "```py\nclass LoginEventSerializer:\n    def __init__(self, event):\n        self.event = event\n    def serialize(self) -> dict:\n        return {\n            \"username\": self.event.username,\n            \"password\": \"**redacted**\",\n            \"ip\": self.event.ip,\n            \"timestamp\": self.event.timestamp.strftime(\"%Y-%m-%d \n             %H:%M\"),\n        }\n@dataclass\nclass LoginEvent:\n    SERIALIZER = LoginEventSerializer\n    username: str\n    password: str\n    ip: str\n    timestamp: datetime\n    def serialize(self) -> dict:\n        return self.SERIALIZER(self).serialize() \n```", "```py\nfrom dataclasses import dataclass\ndef hide_field(field) -> str:\n    return \"**redacted**\"\ndef format_time(field_timestamp: datetime) -> str:\n    return field_timestamp.strftime(\"%Y-%m-%d %H:%M\")\ndef show_original(event_field):\n    return event_field\nclass EventSerializer:\n    def __init__(self, serialization_fields: dict) -> None:\n        self.serialization_fields = serialization_fields\n    def serialize(self, event) -> dict:\n        return {\n            field: transformation(getattr(event, field))\n            for field, transformation\n            in self.serialization_fields.items()\n        }\nclass Serialization:\n\n    def __init__(self, **transformations):\n        self.serializer = EventSerializer(transformations)\n    def __call__(self, event_class):\n        def serialize_method(event_instance):\n            return self.serializer.serialize(event_instance)\n        event_class.serialize = serialize_method\n        return event_class\n@Serialization( \n    username=str.lower, \n    password=hide_field, \n    ip=show_original, \n    timestamp=format_time, \n) \n@dataclass \nclass LoginEvent: \n    username: str \n    password: str \n    ip: str \n    timestamp: datetime \n```", "```py\n@retry(arg1, arg2,... ) \n```", "```py\n <original_function> = retry(arg1, arg2, ....)(<original_function>) \n```", "```py\n_DEFAULT_RETRIES_LIMIT = 3\n    def with_retry(\n        retries_limit: int = _DEFAULT_RETRIES_LIMIT,\n        allowed_exceptions: Optional[Sequence[Exception]] = None,\n    ):\n        allowed_exceptions = allowed_exceptions or\n        (ControlledException,) # type: ignore\n        def retry(operation):\n            @wraps(operation)\n            def wrapped(*args, **kwargs):\n                last_raised = None\n                for _ in range(retries_limit):\n                    try:\n                        return operation(*args, **kwargs)\n                    except allowed_exceptions as e:\n                        logger.warning(\n                            \"retrying %s due to %s\",\n                            operation.__qualname__, e\n                        )\n                        last_raised = e\n                raise last_raised\n            return wrapped\n        return retry \n```", "```py\n# decorator_parametrized_1.py\n@with_retry()\ndef run_operation(task):\n    return task.run()\n@with_retry(retries_limit=5)\ndef run_with_custom_retries_limit(task):\n    return task.run()\n@with_retry(allowed_exceptions=(AttributeError,))\ndef run_with_custom_exceptions(task):\n    return task.run()\n@with_retry(\n    retries_limit=4, allowed_exceptions=(ZeroDivisionError, AttributeError)\n)\ndef run_with_custom_parameters(task):\n    return task.run() \n```", "```py\n_DEFAULT_RETRIES_LIMIT = 3\nclass WithRetry:\n    def __init__(\n        self,\n        retries_limit: int = _DEFAULT_RETRIES_LIMIT,\n        allowed_exceptions: Optional[Sequence[Exception]] = None,\n    ) -> None:\n    self.retries_limit = retries_limit\n    self.allowed_exceptions = allowed_exceptions or\n(ControlledException,)\n    def __call__(self, operation):\n        @wraps(operation)\n        def wrapped(*args, **kwargs):\n            last_raised = None\n            for _ in range(self.retries_limit):\n                try:\n                    return operation(*args, **kwargs)\n                except self.allowed_exceptions as e:\n                logger.warning(\n                    \"retrying %s due to %s\",\n                    operation.__qualname__, e\n                )\n                    last_raised = e\n            raise last_raised\n      return wrapped \n```", "```py\n@WithRetry(retries_limit=5)\ndef run_with_custom_retries_limit(task):\n    return task.run() \n```", "```py\n@retry()\ndef my function(): ... \n```", "```py\n@retry\ndef my function(): ... \n```", "```py\n @decorator(x=3, y=4)\n        def my_function(x, y):\n            return x + y\n        my_function()  # 7 \n```", "```py\ndef decorator(function=None, *, x=DEFAULT_X, y=DEFAULT_Y):\n    if function is None:  # called as `@decorator(...)`\n\n        def decorated(function):\n            @wraps(function)\n            def wrapped():\n                return function(x, y)\n\n            return wrapped\n\n        return decorated\n    else:  # called as `@decorator`\n\n        @wraps(function)\n        def wrapped():\n            return function(x, y)\n\n        return wrapped \n```", "```py\ndef decorator(function=None, *, x=DEFAULT_X, y=DEFAULT_Y):\n    if function is None:\n        return lambda f: decorator(f, x=x, y=y)\n\n    @wraps(function)\n    def wrapped():\n        return function(x, y)\n\n    return wrapped \n```", "```py\nreturn partial(decorator, x=x, y=y) \n```", "```py\ndef retry(operation, /): ... \n```", "```py\nX, Y = 1, 2\n\ndef decorator(callable):\n    \"\"\"Call <callable> with fixed values\"\"\"\n\n    @wraps(callable)\n    def wrapped():\n        return callable(X, Y)\n\n    return wrapped\n\n@decorator\ndef func(x, y):\n    return x + y\n\n@decorator\nasync def coro(x, y):\n    return x + y \n```", "```py\nimport inspect\ndef timing(callable):\n    @wraps(callable)\n    def wrapped(*args, **kwargs):\n        start = time.time()\n        result = callable(*args, **kwargs)\n        latency = time.time() - start\n        return {\"latency\": latency, \"result\": result}\n\n    @wraps(callable)\n    async def wrapped_coro(*args, **kwargs):\n        start = time.time()\n        result = await callable(*args, **kwargs)\n        latency = time.time() - start\n        return {\"latency\": latency, \"result\": result}\n\n    if inspect.iscoroutinefunction(callable):\n        return wrapped_coro\n\n    return wrapped \n```", "```py\ndef _log(f, *args, **kwargs):\n    print(f\"calling {f.__qualname__!r} with {args=} and {kwargs=}\")\n    return f(*args, **kwargs)\n\n@(lambda f: lambda *args, **kwargs: _log(f, *args, **kwargs))\ndef func(x):\n    return x + 1 \n```", "```py\n>>> func(3)\ncalling 'func' with args=(3,) and kwargs={} \n```", "```py\ndef resolver_function(root, args, context, info): ... \n```", "```py\ndef resolver_function(root, args, context, info):\n    helper = DomainObject(root, args, context, info)\n    ...\n    helper.process() \n```", "```py\n@DomainArgs\ndef resolver_function(helper):\n    helper.process()\n   ... \n```", "```py\n# decorator_wraps_1.py\ndef trace_decorator(function):\n    def wrapped(*args, **kwargs):\n        logger.info(\"running %s\", function.__qualname__)\n        return function(*args, **kwargs)\n    return wrapped \n```", "```py\n@trace_decorator\ndef process_account(account_id: str):\n    \"\"\"Process an account by Id.\"\"\"\n    logger.info(\"processing account %s\", account_id)\n    ... \n```", "```py\n>>> help(process_account)\nHelp on function wrapped in module decorator_wraps_1:\nwrapped(*args, **kwargs) \n```", "```py\n>>> process_account.__qualname__\n'trace_decorator.<locals>.wrapped' \n```", "```py\n>>> process_account.__annotations__\n{} \n```", "```py\n# decorator_wraps_2.py\ndef trace_decorator(function):\n    @wraps(function)\n    def wrapped(*args, **kwargs):\n        logger.info(\"running %s\", function.__qualname__)\n        return function(*args, **kwargs)\n    return wrapped \n```", "```py\n>>> from decorator_wraps_2 import process_account\n>>> help(process_account)\nHelp on function process_account in module decorator_wraps_2:\nprocess_account(account_id)\n    Process an account by Id. \n```", "```py\n>>> process_account.__qualname__\n'process_account' \n```", "```py\ndef decorator(original_function):\n    @wraps(original_function)\n    def decorated_function(*args, **kwargs):\n        # modifications done by the decorator ...\n        return original_function(*args, **kwargs)\n    return decorated_function \n```", "```py\ndef traced_function_wrong(function):\n    logger.info(\"started execution of %s\", function)\n    start_time = time.time()\n    @wraps(function)\n    def wrapped(*args, **kwargs):\n        result = function(*args, **kwargs)\n        logger.info(\n            \"function %s took %.2fs\",\n            function,\n            time.time() - start_time\n        )\n        return result\n    return wrapped \n```", "```py\n@traced_function_wrong\ndef process_with_delay(callback, delay=0):\n    time.sleep(delay)\n    return callback() \n```", "```py\n>>> from decorator_side_effects_1 import process_with_delay\nINFO:started execution of <function process_with_delay at 0x...> \n```", "```py\n>>> main()\n...\nINFO:function <function process_with_delay at 0x> took 8.67s\n>>> main()\n...\nINFO:function <function process_with_delay at 0x> took 13.39s\n>>> main()\n...\nINFO:function <function process_with_delay at 0x> took 17.01s \n```", "```py\nprocess_with_delay = traced_function_wrong(process_with_delay) \n```", "```py\ndef traced_function(function):\n    @functools.wraps(function)\n    def wrapped(*args, **kwargs):\n        logger.info(\"started execution of %s\", function.__qualname__)\n        start_time = time.time()\n        result = function(*args, **kwargs)\n        logger.info(\n            \"function %s took %.2fs\",\n            function.__qualname__,\n            time.time() - start_time\n        )\n        return result\n    return wrapped \n```", "```py\nEVENTS_REGISTRY = {}\ndef register_event(event_cls):\n    \"\"\"Place the class for the event into the registry to make it     accessible in the module.\n    \"\"\"\n    EVENTS_REGISTRY[event_cls.__name__] = event_cls\n    return event_cls\nclass Event:\n    \"\"\"A base event object\"\"\"\nclass UserEvent:\n    TYPE = \"user\"\n@register_event\nclass UserLoginEvent(UserEvent):\n    \"\"\"Represents the event of a user when it has just accessed the system.\"\"\"\n@register_event\nclass UserLogoutEvent(UserEvent):\n    \"\"\"Event triggered right after a user abandoned the system.\"\"\" \n```", "```py\n>>> from decorator_side_effects_2 import EVENTS_REGISTRY\n>>> EVENTS_REGISTRY\n{'UserLoginEvent': decorator_side_effects_2.UserLoginEvent,\n 'UserLogoutEvent': decorator_side_effects_2.UserLogoutEvent} \n```", "```py\n# src/decorator_universal_1.py\nfrom functools import wraps\nfrom log import logger\nclass DBDriver:\n    def __init__(self, dbstring: str) -> None:\n        self.dbstring = dbstring\n    def execute(self, query: str) -> str:\n        return f\"query {query} at {self.dbstring}\"\ndef inject_db_driver(function):\n    \"\"\"This decorator converts the parameter by creating a ``DBDriver``\n    instance from the database dsn string.\n    \"\"\"\n    @wraps(function)\n    def wrapped(dbstring):\n        return function(DBDriver(dbstring))\n    return wrapped\n@inject_db_driver\ndef run_query(driver):\n    return driver.execute(\"test_function\") \n```", "```py\n>>> run_query(\"test_OK\")\n'query test_function at test_OK' \n```", "```py\nclass DataHandler:\n    @inject_db_driver\n    def run_query(self, driver):\n        return driver.execute(self.__class__.__name__) \n```", "```py\n>>> DataHandler().run_query(\"test_fails\")\nTraceback (most recent call last):\n  ...\nTypeError: wrapped() takes 1 positional argument but 2 were given \n```", "```py\nfrom functools import wraps\nfrom types import MethodType\nclass inject_db_driver:\n    \"\"\"Convert a string to a DBDriver instance and pass this to the \n       wrapped function.\"\"\"\n    def __init__(self, function) -> None:\n        self.function = function\n        wraps(self.function)(self)\n    def __call__(self, dbstring):\n        return self.function(DBDriver(dbstring))\n    def __get__(self, instance, owner):\n        if instance is None:\n            return self\n        return self.__class__(MethodType(self.function, instance)) \n```", "```py\nclass BaseResolverMixin:\n    def __getattr__(self, attr: str):\n        if attr.startswith(\"resolve_\"):\n            *_, actual_attr = attr.partition(\"resolve_\")\n        else:\n            actual_attr = attr\n        try:\n            return self.__dict__[actual_attr]\n        except KeyError as e:\n            raise AttributeError from e\n\n@dataclass\nclass Customer(BaseResolverMixin):\n    customer_id: str\n    name: str\n    address: str \n```", "```py\nfrom dataclasses import dataclass\n\ndef _resolver_method(self, attr):\n    \"\"\"The resolution method of attributes that will replace __getattr__.\"\"\"\n    if attr.startswith(\"resolve_\"):\n        *_, actual_attr = attr.partition(\"resolve_\")\n    else:\n        actual_attr = attr\n    try:\n        return self.__dict__[actual_attr]\n    except KeyError as e:\n        raise AttributeError from e\n\ndef with_resolver(cls):\n    \"\"\"Set the custom resolver method to a class.\"\"\"\n    cls.__getattr__ = _resolver_method\n    return cls\n\n@dataclass\n@with_resolver\nclass Customer:\n    customer_id: str\n    name: str\n    address: str \n```", "```py\n>>> customer = Customer(\"1\", \"name\", \"address\")\n>>> customer.resolve_customer_id\n'1'\n>>> customer.resolve_name\n'name' \n```", "```py\nclass Connection: pass\nclass EncryptedConnection(Connection): pass \n```", "```py\ndef traced_function(function):\n    @functools.wraps(function)\n    def wrapped(*args, **kwargs):\n        logger.info(\"started execution of %s\", function.__qualname__)\n        start_time = time.time()\n        result = function(*args, **kwargs)\n        logger.info(\n            \"function %s took %.2fs\",\n            function.__qualname__,\n            time.time() - start_time\n        )\n        return result\n    return wrapped \n```", "```py\ndef log_execution(function):\n    @wraps(function)\n    def wrapped(*args, **kwargs):\n        logger.info(\"started execution of %s\", function.__qualname__)\n        return function(*kwargs, **kwargs)\n    return wrapped\ndef measure_time(function):\n    @wraps(function)\n    def wrapped(*args, **kwargs):\n        start_time = time.time()\n        result = function(*args, **kwargs)\n        logger.info(\n            \"function %s took %.2f\",\n            function.__qualname__,\n            time.time() - start_time,\n        )\n        return result\n    return wrapped \n```", "```py\n@measure_time\n@log_execution\ndef operation():\n    .... \n```", "```py\n@app.task\ndef mytask():\n   .... \n```", "```py\n@route(\"/\", method=[\"GET\"])\ndef view_handler(request):\n ... \n```"]