- en: Advanced Application Structure
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级应用程序结构
- en: Our application has gone from a very simple example to an extendable foundation
    on which powerful features can easily be built. However, having our application
    entirely reside in one file needlessly clutters our code. This is one of the advantages
    of Flask; you can write a small REST service or web application on a single file,
    or a full-blown enterprise application. The framework won't get in your way and
    won't impose any project layout.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序已经从一个非常简单的示例转变为一个可扩展的基础，在这个基础上可以轻松构建强大的功能。然而，让我们的应用程序完全驻留在单个文件中是不必要的，这会使我们的代码变得杂乱。这是
    Flask 的一大优点；您可以在单个文件上编写一个小的 REST 服务或 Web 应用程序，或者一个完整的商业应用程序。框架不会妨碍您，也不会强制任何项目布局。
- en: 'To make the application code clearer and more comprehensible, we will transform
    the entire code into a Python module and each feature into a module by itself.
    This modular approach enables you to scale easily and in a predictable way, so
    new features will have an obvious place and structure. In this chapter, you will
    learn the best practices for the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使应用程序代码更清晰易懂，我们将整个代码转换为一个 Python 模块，并将每个特性转换为一个独立的模块。这种模块化方法使您能够轻松且可预测地进行扩展，因此新特性将有一个明显的位置和结构。在本章中，您将学习以下最佳实践：
- en: Creating a modular application that easily scales
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个易于扩展的模块化应用程序
- en: Application factory pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序工厂模式
- en: Modular application
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化应用程序
- en: 'Currently, your folder structure should look like the following (take a look
    at the code provided for the previous chapter):'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，您的文件夹结构应该如下所示（查看前一章提供的代码）：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To convert our code into a more modular application, our files will be structured
    as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的代码转换为一个更模块化的应用程序，我们的文件结构如下：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first change to make is to create a folder in your application that will
    hold the module. In this example, it will be called `webapp`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要做的是在你的应用程序中创建一个文件夹，用于存放模块。在这个例子中，它将被命名为 `webapp`。
- en: 'Next, for each module in our application, we will create a respective Python
    module. If the module is a classic web application using web templates and forms,
    we would create the following files:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于我们应用中的每个模块，我们将创建相应的 Python 模块。如果该模块是一个使用 Web 模板和表单的经典 Web 应用程序，我们将创建以下文件：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The idea is to have separation of concerns, so each module will contain all
    the necessary views (declared and contained inside a Flask blueprint), web forms,
    and modules. This modular structure will translate into predictable namespaces
    for URIs, templates, and Python modules. Continuing to reason with an abstract
    approach, each module will have the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是关注点的分离，因此每个模块将包含所有必要的视图（在 Flask 蓝图中声明并包含在内），Web 表单和模块。这种模块化结构将转化为 URI、模板和
    Python 模块的可预测命名空间。继续以抽象方法进行推理，每个模块将具有以下特点：
- en: 'Python module (folder with `__init__.py`) using its name: `MODULE_NAME`. Inside
    the module is a `controllers` Python module that declares a blueprint named `<MODULE_NAME>_blueprint`
    attached to a URL, `prefix /<MODULE_NAME>`.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 模块（包含 `__init__.py` 的文件夹）使用其名称：`MODULE_NAME`。在模块内部是一个 `controllers` Python
    模块，它声明了一个名为 `<MODULE_NAME>_blueprint` 的蓝图，并将其附加到一个 URL，前缀为 `/<MODULE_NAME>`。
- en: Template folder inside `templates` named `<MODULE_NAME>`.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `templates` 内名为 `<MODULE_NAME>` 的模板文件夹。
- en: This pattern will make the code very predictable to other team members, and
    very easy to change and extend. If you want to create a brand new feature, just
    create a new module using the proposed structure, and all team members will immediately
    guess the new feature's URI namespace, where all views are declared, and where
    the database models are defined for this feature. If some bug is identified, you
    can easily identify where to look for it, and have a much more restricted code
    base to worry about.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式将使代码对其他团队成员来说非常可预测，并且非常容易更改和扩展。如果您想创建一个全新的特性，只需使用建议的结构创建一个新的模块，所有团队成员将立即猜出新特性的
    URI 命名空间，其中声明了所有视图，以及为该特性定义的数据库模型。如果发现了一些错误，您可以轻松地确定查找错误的位置，并且有一个更受限制的代码库需要关注。
- en: Refactoring the code
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码重构
- en: At first, it looks like a lot has changed but you will see that, taking into
    account the previously explained structure, the changes are simple and natural.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，看起来变化很大，但您会发现，考虑到之前解释的结构，这些变化简单且自然。
- en: 'First, we have moved our SQLAlchemy code to the `models.py` file inside the
    `blog module` folder. We just want to move the model definitions, not any database
    initialization code. All initialization code will be kept in the main application
    module, `webapp`, inside `__init__.py`. The import section and database-related
    object creation appear as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The main application module will be responsible for creating the Flask application
    (factory pattern, explained in the next section) and initializing SQLAlchemy.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'The `blog/models.py` file will import the initialized `db` object:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, the `CommentForm` object, along with all the WTForms imports, should be
    moved to the `blog/forms.py` file. The `forms.py` file will hold all the WTForms
    objects related to the blog feature.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'The `forms.py` file should look like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `blog_blueprint` object, all its routes, and the `sidebar_data` data function
    need to be moved to the `blog/controllers.py` file in the `controllers` folder.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'The `blog/controllers.py` file should now look like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So, whenever a new feature is needed that is big enough to be a candidate for
    an application module, a new Python module (folder with an `__init__.py` file) with
    the name of the feature is needed with the previously described files. We will
    be breaking down the application code into logical groups.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to import the new feature blueprint into the main `__init__.py` file
    and register it in Flask:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Application factories
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are using blueprints in a modular manner, there is another improvement
    we can make to our abstraction, which creates a **factory** for our application.
    The concept of a factory comes from the **object-oriented programming** (**OOP**)
    world, and it simply means a function or an object that creates another object.
    Our application factory will take one of our `config` objects, which we created
    at the beginning of the book, and return a Flask application object.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'The object factory design was popularized by the now famous book, *Design Patterns:
    Elements of Reusable Object-Oriented Software*, by the Gang of Four. To learn
    more about these design patterns and how they can help simplify a project''s code,
    look at [https://en.wikipedia.org/wiki/Structural_pattern](https://en.wikipedia.org/wiki/Structural_pattern).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Creating a factory function for our application object has several benefits.
    First, it allows the context of the environment to change the configuration of
    the application. When your server creates the application object to serve, it
    can take into account any changes in the server that are necessary, and change
    the configuration object given to the app accordingly. Second, it makes testing
    much easier because it allows differently configured applications to be tested
    quickly. Third, multiple instances of the same application using the same configuration
    can be created very easily. This is useful for situations where web traffic is
    balanced across several different servers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the benefits of application factories are clear, let''s modify our
    `__init__.py` file to implement one:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序工厂的好处已经很明显了，让我们修改我们的`__init__.py`文件来实现一个：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The change to the file is very simple: we contained our code in a function
    that takes a `config` object and returns an application object. To start our application
    using the right configuration from an environment variable, we need to change `main.py`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的更改非常简单：我们将代码包含在一个接受`config`对象并返回应用程序对象的函数中。为了使用环境变量中的正确配置来启动我们的应用程序，我们需要更改`main.py`：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We also need to modify our `manage.py` file in order to work with the `create_app`
    function as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改我们的`manage.py`文件，以便与`create_app`函数一起使用，如下所示：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When we created our configuration objects, it was mentioned that the environment
    that the application is running in could change the configuration of the application.
    This code has a very simple example of that functionality, where an environment
    variable is loaded and determines which `config` object to give to the `create_app`
    function. Environment variables are dynamic name values that are part of a process
    environment. These environments can be shared by multiple processes, system-wide,
    user-wide, or for a single process. They can be set in Bash with the following
    syntax:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建配置对象时，提到应用程序运行的环境可能会改变应用程序的配置。此代码提供了一个非常简单的功能示例，其中加载了一个环境变量，并确定要将哪个`config`对象提供给`create_app`函数。环境变量是进程环境的一部分，是动态的名称值。这些环境可以被多个进程、系统范围、用户范围或单个进程共享。它们可以使用以下语法在Bash中设置：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Use this to read a variable:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法来读取变量：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can also delete the variable easily, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以轻松地删除变量，如下所示：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: On your production server, you would set `WEBAPP_ENV` to `prod`. The true power
    of this setup will become clearer once you deploy to production in [Chapter 13](380101ac-fb85-4e2e-b664-8d6de77928f4.xhtml),
    *Deploying Flask Apps*, and when we get to [Chapter 12](9ffdc8da-2c26-4e97-8738-eebc7629535c.xhtml),
    *Testing Flask Apps*, which covers testing our project.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的生产服务器上，你会将`WEBAPP_ENV`设置为`prod`。一旦你部署到生产环境（[第13章](380101ac-fb85-4e2e-b664-8d6de77928f4.xhtml)，*部署Flask应用程序*），以及当我们到达[第12章](9ffdc8da-2c26-4e97-8738-eebc7629535c.xhtml)，*测试Flask应用程序*），该章节涵盖了测试我们的项目，这个设置的真正威力将变得更加清晰。
- en: Summary
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have transformed our application into a much more manageable and scalable
    structure, which will save us a lot of headaches as we move further through the
    book and add more advanced features. In the next chapter, we will add a login
    and registration system to our application, and other features to make our site
    more secure.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将我们的应用程序转换成了一个更加可管理和可扩展的结构，这将在我们进一步阅读本书并添加更多高级功能时节省我们很多麻烦。在下一章中，我们将向我们的应用程序添加登录和注册系统，以及其他使我们的网站更加安全的特性。
