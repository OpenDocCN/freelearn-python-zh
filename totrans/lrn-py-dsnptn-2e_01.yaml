- en: Chapter 1. Introduction to Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will go through the basics of object-oriented programming
    and discuss the object-oriented design principles in detail. This will get us
    prepared for the advanced topics covered later in the book. This chapter will
    also give a brief introduction to the concept of design patterns so that you will
    be able to appreciate the context and application of design patterns in software
    development. Here we also classify the design patterns under three main aspects—creational,
    structural, and Behavioral patterns. So, essentially, we will cover the following
    topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding object-oriented programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing object-oriented design principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the concept of design patterns and their taxonomy and context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing patterns for dynamic languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classifying patterns—creational pattern, structural pattern, and behavioral
    pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding object-oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you start learning about design patterns, it's always good to cover the
    basics and go through object-oriented paradigms in Python. The object-oriented
    world presents the concept of *objects* that have attributes (data members) and
    procedures (member functions). These functions are responsible for manipulating
    the attributes. For instance, take an example of the `Car` object. The `Car` object
    will have attributes such as `fuel level`, `isSedan`, `speed`, and `steering wheel`
    and `coordinates`, and the methods would be `accelerate()` to increase the speed
    and `takeLeft()` to make the car turn left. Python has been an object-oriented
    language since it was first released. As they say, *everything in Python is an
    object*. Each class instance or variable has its own memory address or identity.
    Objects, which are instances of classes, interact among each other to serve the
    purpose of an application under development. Understanding the core concepts of
    object-oriented programming involves understanding the concepts of objects, classes,
    and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points describe objects:'
  prefs: []
  type: TYPE_NORMAL
- en: They represent entities in your application under development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entities interact among themselves to solve real-world problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, Person is an entity and Car is an entity. Person drives Car to
    move from one location to the other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Classes help developers to represent real-world entities:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes define objects in attributes and behaviors. Attributes are data members
    and behaviors are manifested by the member functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes consist of constructors that provide the initial state for these objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes are like templates and hence can be easily reused
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, class `Person` will have attributes `name` and `age` and member
    function `gotoOffice()` that defines his behavior for travelling to office for
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points talk about what methods do in the object-oriented world:'
  prefs: []
  type: TYPE_NORMAL
- en: They represent the behavior of the object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods work on attributes and also implement the desired functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A good example of a class and object created in Python v3.5 is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Methods](img/00002.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Major aspects of object-oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have understood the basics of object-oriented programming, let's
    dive into the major aspects of OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key features of encapsulation are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An object's behavior is kept hidden from the outside world or objects keep their
    state information private.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clients can't change the object's internal state by directly acting on them;
    rather, clients request the object by sending messages. Based on the type of requests,
    objects may respond by changing their internal state using special member functions
    such as `get` and `set`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Python, the concept of encapsulation (data and method hiding) is not implicit,
    as it doesn't have keywords such as **public**, **private**, and **protected**
    (in languages such as C++ or Java) that are required to support encapsulation.
    Of course, accessibility can be made private by prefixing `__` in the variable
    or function name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The major features of polymorphism are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Polymorphism can be of two types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object provides different implementations of the method based on input parameters
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The same interface can be used by objects of different types
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In Python, polymorphism is a feature built-in for the language. For example,
    the `+` operator can act on two integers to add them or can work with strings
    to concatenate them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, strings, tuples, or lists can all be accessed with
    an integer index. This shows how Python demonstrates polymorphism in built-in
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points help us understand the inheritance process better:'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance indicates that one class derives (most of its) functionality from
    the parent class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance is described as an option to reuse functionality defined in the
    base class and allow independent extensions of the original software implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance creates hierarchy via the relationships among objects of different
    classes. Python, unlike Java, supports multiple inheritance (inheriting from multiple
    base classes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following code example, `class A` is the base class and `class B` derives
    its features from `class A`. So, the methods of `class A` can be accessed by the
    object of `class B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Abstraction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key features of abstraction are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides you with a simple interface to the clients, where the clients can
    interact with class objects and call methods defined in the interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It abstracts the complexity of internal classes with an interface so that the
    client need not be aware of internal implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, internal details of the `Adder` class are abstracted
    with the `add()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Composition refers to the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: It is a way to combine objects or classes into more complex data structures
    or software implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In composition, an object is used to call member functions in other modules
    thereby making base functionality available across modules without inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, the object of `class A` is composited under `class
    B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Object-oriented design principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's talk about another set of concepts that are going to be crucial for
    us. These are nothing but the object-oriented design principles that will act
    as a toolbox for us while learning design patterns in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The open/close principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The open/close principle states that *classes or objects and methods should
    be open for extension but closed for modifications*.
  prefs: []
  type: TYPE_NORMAL
- en: What this means in simple language is, when you develop your software application,
    make sure that you write your classes or modules in a generic way so that whenever
    you feel the need to extend the behavior of the class or object, then you shouldn't
    have to change the class itself. Rather, a simple extension of the class should
    help you build the new behavior.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the open/close principle is manifested in a case where a user has
    to create a class implementation by extending the abstract base class to implement
    the required behavior instead of changing the abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advantages of this design principle are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Existing classes are not changed and hence the chances of regression are less
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also helps maintain backward compatibility for the previous code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The inversion of control principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The inversion of control principle states that *high-level modules shouldn't
    be dependent on low-level modules; they should both be dependent on abstractions.
    Details should depend on abstractions and not the other way round*.
  prefs: []
  type: TYPE_NORMAL
- en: This principle suggests that any two modules shouldn't be dependent on each
    other in a tight way. In fact, the base module and dependent module should be
    decoupled with an abstraction layer in between.
  prefs: []
  type: TYPE_NORMAL
- en: This principle also suggests that the details of your class should represent
    the abstractions. In some cases, the philosophy gets inverted and implementation
    details itself decide the abstraction, which should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advantages of the inversion of control principle are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The tight coupling of modules is no more prevalent and hence no complexity/rigidity
    in the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As there is a clear abstraction layer between dependent modules (provided by
    a hook or parameter), it's easy to deal with dependencies across modules in a
    better way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interface segregation principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the interface segregation principle states, *clients should not be forced
    to depend on interfaces they don't use*.
  prefs: []
  type: TYPE_NORMAL
- en: This principle talks about software developers writing their interfaces well.
    For instance, it reminds the developers/architects to develop methods that relate
    to the functionality. If there is any method that is not related to the interface,
    the class dependent on the interface has to implement it unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a `Pizza` interface shouldn't have a method called `add_chicken()`.
    The `Veg Pizza` class based on the `Pizza` interface shouldn't be forced to implement
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advantages of this design principle are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It forces developers to write thin interfaces and have methods that are specific
    to the interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps you not to populate interfaces by adding unintentional methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single responsibility principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the single responsibility principle states, *a class should have only one
    reason to change*.
  prefs: []
  type: TYPE_NORMAL
- en: This principle says that when we develop classes, it should cater to the given
    functionality well. If a class is taking care of two functionalities, it is better
    to split them. It refers to functionality as a reason to change. For example,
    a class can undergo changes because of the difference in behavior expected from
    it, but if a class is getting changed for two reasons (basically, changes in two
    functionalities), then the class should be definitely split.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advantages of this design principle are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever there is a change in one functionality, this particular class needs
    to change, and nothing else
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, if a class has multiple functionalities, the dependent classes
    will have to undergo changes for multiple reasons, which gets avoided
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The substitution principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The substitution principle states that *derived classes must be able to completely
    substitute the base classes*.
  prefs: []
  type: TYPE_NORMAL
- en: This principle is pretty straightforward in the sense that it says when application
    developers write derived classes, they should extend the base classes. It also
    suggests that the derived class should be as close to the base class as possible
    so much so that the derived class itself should replace the base class without
    any code changes.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, now is the time that we start talking about design patterns! What are
    design patterns?
  prefs: []
  type: TYPE_NORMAL
- en: 'Design patterns were first introduced by **GoF** (**Gang of Four**), where
    they mentioned them as being solutions to given problems. If you would like to
    know more, GoF refers to the four authors of the book, *Design Patterns: Elements
    of Reusable Object-Oriented Software*. The book''s authors are *Erich Gamma*,
    *Richard Helm*, *Ralph Johnson*, and *John Vlissides*, with a foreword by *Grady
    Booch*. This book covers software engineering solutions to the commonly occurring
    problems in software design. There were 23 design patterns first identified, and
    the first implementation was done with respect to the Java program language. Design
    patterns are discoveries and not an invention in themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key features of design patterns are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: They are language-neutral and can be implemented across multiple languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are dynamic, as new patterns get introduced every now and then
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are open for customization and hence useful for developers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Initially, when you hear about design patterns, you may feel the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It's a panacea to all the design problems that you've had so far
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's an extraordinary, specially clever way of solving a problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many experts in software development world agree to these solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's something repeatable about the design, hence the word pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You too must have attempted to solve the problems that a design patterns intends
    to, but maybe your solution was incomplete, and the completeness that we're looking
    for is inherent or implicit in the design pattern. When we say completeness, it
    can refer to many factors such as the design, scalability, reuse, memory utilization,
    and others. Essentially, a design pattern is about learning from others' successes
    rather than your own failures!
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting discussion that comes up on design patterns is—when do I
    use them? Is it in the analysis or design phase of **Software Development Life
    Cycle** (**SDLC**)?
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, design patterns are solutions to known issues. So they can be
    very much used in analysis or design, and as expected, in the development phase
    because of the direct relation in the application code.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of design patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The advantages of design patterns are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: They are reusable across multiple projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The architectural level of problems can be solved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are time-tested and well-proven, which is the experience of developers
    and architects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have reliability and dependence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taxonomy of design patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Not every piece of code or design can be termed as a design pattern. For example,
    a programming construct or data structure that solves one problem can''t be termed
    as a pattern. Let''s understand terms in a very simplistic way below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Snippet**: This is code in some language for a certain purpose, for example,
    DB connectivity in Python can be a code snippet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Design**: A better solution to solve this particular problem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Standard**: This is a way to solve some kind of problems, and can be very
    generic and applicable to a situation at hand'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pattern**: This is a time-tested, efficient, and scalable solution that will
    resolve the entire class of known issues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Context – the applicability of design patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use design patterns efficiently, application developers must be aware of
    the context where design patterns apply. We can classify the context into the
    following main categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Participants**: They are classes that are used in design patterns. Classes
    play different roles to accomplish multiple goals in the pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-functional requirements**: Requirements such as memory optimization,
    usability, and performance fall under this category. These factors impact the
    complete software solution and are thus critical.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trade-offs**: Not all design patterns fit in application development as it
    is, and trade-offs are necessary. These are decisions that you take while using
    a design pattern in an application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Results**: Design patterns can have a negative impact on other parts of the
    code if the context is not appropriate. Developers should understand the consequences
    and use of design patterns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patterns for dynamic languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python is a dynamic language like Lisp. The dynamic nature of Python can be
    represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Types or classes are objects at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables can have type as a value and can be modified at runtime. For example,
    `a = 5` and `a = "John"`, the `a` variable is assigned at runtime and type also
    gets changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic languages have more flexibility in terms of class restrictions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, in Python, polymorphism is built into the language, there are no
    keywords such as `private` and `protected` and everything is public by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Represents a case where design patterns can be easily implemented in dynamic
    languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classifying patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The book by GoF on design patterns spoke about 23 design patterns and classified
    them under three main categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Creational patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavioral patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The classification of patterns is done based primarily on how the objects get
    created, how classes and objects are structured in a software application, and
    also covers the way objects interact among themselves. Let's talk about each of
    the categories in detail in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creational patterns:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the properties of Creational patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: They work on the basis of how objects can be created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They isolate the details of object creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code is independent of the type of object to be created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of a creational pattern is the Singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Structural patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the properties of Structural patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: They design the structure of objects and classes so that they can compose to
    achieve larger results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The focus is on simplifying the structure and identifying the relationship between
    classes and objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They focus on class inheritance and composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of a behavior pattern is the Adapter pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the properties of Behavioral patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: They are concerned with the interaction among objects and responsibility of
    objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects should be able to interact and still be loosely coupled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of a behavioral pattern is the Observer pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the basic concepts of object-oriented programming,
    such as objects, classes, variables, and features such as polymorphism, inheritance,
    and abstraction with code examples.
  prefs: []
  type: TYPE_NORMAL
- en: We are also now aware of object-oriented design principles that we, as developers/architects,
    should consider while designing an application.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we went on to explore more about design patterns and their applications
    and context in which they can be applied and also discussed their classifications.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, we're now ready to take the next step and study
    design patterns in detail.
  prefs: []
  type: TYPE_NORMAL
