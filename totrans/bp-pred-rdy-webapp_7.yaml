- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Securing and Packaging the App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护并打包应用程序
- en: In the previous chapter, we deployed our app to [tozo.dev](http://tozo.dev),
    allowing users to use our web app via a browser on any device, and added monitoring
    so that we know when things go wrong.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们将应用程序部署到[tozo.dev](http://tozo.dev)，允许用户通过任何设备的浏览器使用我们的Web应用程序，并添加了监控，以便我们知道何时出现问题。
- en: In this chapter, we will focus on how we can keep our app secure, both in terms
    of the code we use and the methods users use to authenticate. We’ll also package
    our app so that users can use our app via the app stores.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注如何保持我们的应用程序安全，无论是从我们使用的代码还是用户使用的认证方法来看。我们还将打包我们的应用程序，以便用户可以通过应用商店使用我们的应用程序。
- en: It is important to view the app’s security as a continual process, whereby the
    practices and packages must be continually updated and improved. In this chapter,
    I’ll demonstrate my process for managing package updates, which you can adopt
    and improve upon. We’ll also adopt current best practices to secure the app.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序的安全性视为一个持续的过程非常重要，在这个过程中，实践和包必须不断更新和改进。在本章中，我将演示我的包更新管理流程，您可以采用并在此基础上进行改进。我们还将采用当前的最佳实践来保护应用程序。
- en: We’ll also make a major change to support multifactor authentication. While
    this will allow users to opt-in for greater security, it will also show how to
    make large changes to the app; specifically, it will show how to alter the database
    via a migration.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将进行一项重大更改以支持多因素认证。虽然这将使用户能够选择更高的安全性，但它也将展示如何对应用程序进行大规模的更改；具体来说，它将展示如何通过迁移来更改数据库。
- en: Finally, by packaging our app, we can allow our users to find our app in the
    app stores and use it as they would any other app on their phone.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过打包我们的应用程序，我们可以让我们的用户在应用商店中找到我们的应用程序，并像使用他们手机上的任何其他应用程序一样使用它。
- en: 'So, in this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主题：
- en: Securing the app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护应用程序
- en: Updating packages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新包
- en: Adding multifactor authentication
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加多因素认证
- en: Converting to a progressive web app
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换为渐进式Web应用程序
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the development in this chapter using the companion repository, [https://github.com/pgjones/tozo](https://github.com/pgjones/tozo),
    see the commits between the `r1-ch7-start` and `r1-ch7-end` tags.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用配套仓库[https://github.com/pgjones/tozo](https://github.com/pgjones/tozo)跟踪本章的开发，请查看`r1-ch7-start`和`r1-ch7-end`标签之间的提交。
- en: Securing the app
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护应用程序
- en: Much of what we’ve done so far uses secure defaults (for example, the Strict
    SameSite setting used in [*Chapter 2*](B18727_02.xhtml#_idTextAnchor053)*, Creating
    a Reusable Backend with Quart*), however, there is always more than can be done
    to secure an app. Specifically, we can utilize secure headers to limit what the
    browser will allow the page to do, further protect against account enumeration,
    and limit the accounts that can register to limit spam. Let’s look at those security
    options now.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止所做的大部分工作都使用了安全默认设置（例如，在[*第2章*](B18727_02.xhtml#_idTextAnchor053)*，使用Quart创建可重用后端*）中使用的Strict
    SameSite设置），然而，总有更多可以做的事情来保护应用程序。具体来说，我们可以利用安全头来限制浏览器允许页面执行的操作，进一步防止账户枚举，并限制可以注册的账户以减少垃圾邮件。现在让我们来看看这些安全选项。
- en: Adding secure headers
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加安全头信息
- en: 'To further secure our app, we can utilize additional secure headers to limit
    what the browser will allow the app to do. These headers should be added to every
    response the app sends; we can do this by adding the following to *backend/src/backend/run.py*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步保护我们的应用程序，我们可以利用额外的安全头来限制浏览器允许应用程序执行的操作。这些头应该添加到应用程序发送的每个响应中；我们可以通过在`backend/src/backend/run.py`中添加以下内容来实现：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The highlighted value of `report_uri` given as `“https://ingest.sentry.io”`
    is a placeholder, and the correct value for your usage can be found in the CSP
    section of the Sentry dashboard for the backend project.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮显示的`report_uri`值`“https://ingest.sentry.io”`是一个占位符，您使用的正确值可以在后端项目的Sentry仪表板的CSP部分找到。
- en: 'The secure headers added are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的安全头信息如下：
- en: '`Content-Security-Policy` (`CSP`): This is used to limit how the content can
    interact with the page and other domains. As used, it restricts the content such
    that it must have been served by our domain (called `self`) with the exception
    of any styling content that can also be added inline (called `unsafe-inline`)
    as required for MUI to work correctly. The setup also allows connections to [sentry.io](http://sentry.io)
    so that our monitoring can work. Finally, it has a reporting URI so that we can
    monitor any errors with the CSP itself.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content-Security-Policy` (`CSP`): 这用于限制内容如何与页面和其他域名交互。如使用所示，它限制了内容，使其必须由我们的域名（称为`self`）提供，除了任何可以内联添加的样式内容（称为`unsafe-inline`），这是为了正确工作所需的MUI。设置还允许连接到[sentry.io](http://sentry.io)，以便我们的监控可以工作。最后，它有一个报告URI，以便我们可以监控CSP本身的任何错误。'
- en: '`Cross-Origin-Opener-Policy` (`COOP`): This isolates our app from other domains
    (origins).'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cross-Origin-Opener-Policy` (`COOP`): 这将我们的应用与其他域名（来源）隔离开。'
- en: '`Referrer-Policy`: This restricts how the browser can populate the `Referer`
    header when following links and is used to protect the user’s privacy.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Referrer-Policy`: 这限制了浏览器在跟随链接时如何填充`Referer`头，并用于保护用户的隐私。'
- en: '`X-Content-Type-Options`: This ensures that the browser respects the `content`
    type we return from the server.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-Content-Type-Options`: 这确保了浏览器尊重我们从服务器返回的`content`类型。'
- en: '`X-Frame-Options`: This improves protection against clickjacking and ensures
    that our app is only displayed on our domain.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-Frame-Options`: 这提高了对点击劫持的保护，并确保我们的应用仅在我们自己的域名上显示。'
- en: '`Strict-Transport-Security`: This informs the browser that all subsequent connections
    to our app must be done over HTTPS.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Strict-Transport-Security`: 这通知浏览器所有后续连接到我们的应用都必须通过HTTPS进行。'
- en: OWASP
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP
- en: 'The authoritative source for web application security best practices is the
    **OWASP** foundation, which can be found here: [owasp.org](http://owasp.org).
    The header recommendations in this book are based on their recommendations.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序安全最佳实践的权威来源是**OWASP**基金会，您可以在[owasp.org](http://owasp.org)找到它。本书中的头部推荐基于他们的建议。
- en: With the secure headers in place, we can look in more detail at how we log users
    in while protecting against account enumeration.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全头设置到位后，我们可以更详细地了解我们如何登录用户，同时保护免受账户枚举攻击。
- en: Protecting against account enumeration
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护免受账户枚举攻击
- en: Account enumeration is where an attacker attempts to learn what email addresses
    are used as registered accounts. By doing so, the attacker can learn who uses
    a sensitive app (e.g., a dating app) and can learn which accounts they can try
    to force access to. Protecting against this requires compromises in the user experience,
    as we discussed in the *Adding user authentication pages* section of [*Chapter
    5*](B18727_05.xhtml#_idTextAnchor138)*, Building the Single-Page App*, in reference
    to auto logins on registration.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 账户枚举是指攻击者试图了解哪些电子邮件地址被用作注册账户。通过这样做，攻击者可以了解谁使用敏感的应用程序（例如，约会应用），并且可以了解他们可以尝试强制访问哪些账户。保护免受这种攻击需要妥协用户体验，正如我们在[*第五章*](B18727_05.xhtml#_idTextAnchor138)“添加用户认证页面”部分中讨论的那样，在[*第三章*](B18727_03.xhtml#_idTextAnchor076)“构建单页应用程序”中，关于注册时的自动登录。
- en: In this book, we’ll adopt the most secure practices possible, which means we
    need to revisit the login functionality implemented in the *Building the session
    API* section of [*Chapter 3*](B18727_03.xhtml#_idTextAnchor076)*, Building the
    API*, as it is susceptible to account enumeration attacks.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将采用最安全的做法，这意味着我们需要重新审视在[*第三章*](B18727_03.xhtml#_idTextAnchor076)“构建API”部分中实现的登录功能，因为它容易受到账户枚举攻击。
- en: 'The weakness in the login functionality is due to the code only checking the
    password hash if the given email belongs to a registered member. This means that
    the route takes significantly longer to respond to emails belonging to registered
    members than for emails that don’t; this allows an attacker to time the response
    to understand whether the email is registered or not. Therefore, the mitigation
    is to always check a password hash, by changing the route in *backend/src/backend/blueprints/sessions.py*
    to the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 登录功能中的弱点在于代码仅当提供的电子邮件属于注册成员时才检查密码散列。这意味着对于属于注册成员的电子邮件，该路由响应时间明显更长，而对于不属于的电子邮件则更快；这允许攻击者通过响应时间来判断电子邮件是否已注册。因此，缓解措施是始终检查密码散列，通过将`backend/src/backend/blueprints/sessions.py`中的路由更改为以下内容：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`REFERENCE_HASH` is set to a very long random string of characters that is
    extremely unlikely to be matched by chance.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`REFERENCE_HASH`被设置为一个非常长的随机字符字符串，几乎不可能偶然匹配。'
- en: With the additional protection against account enumeration, we can focus on
    the accounts themselves by adding protection against spam accounts.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过增加对账户枚举的保护，我们可以通过添加对垃圾邮件账户的保护来专注于账户本身。
- en: Protecting against spam accounts
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护免受垃圾邮件账户的侵害
- en: 'If you allow users to register and interact with your app, it is inevitable
    that you will have users that will use it to spam you or other users. An easy
    initial mitigation against this is to prevent users from registering to your app
    with disposable email addresses (these are free short-lived email addresses that
    are perfect for spammers). Fortunately, the `disposable-email-domains` project
    keeps a track of these domains and is installed by running the following in the
    *backend* directory:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您允许用户注册并与应用程序交互，那么不可避免的是，您将会有一些用户会利用它来向您或其他用户发送垃圾邮件。对此的一个简单初始缓解措施是防止用户使用一次性电子邮件地址（这些是免费的短期电子邮件地址，非常适合垃圾邮件发送者）注册到您的应用程序。幸运的是，`disposable-email-domains`项目跟踪这些域，并在*backend*目录中运行以下命令进行安装：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following can then be added to the start of the `register` route in *backend/src/backend/blueprints/members.py*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以将以下内容添加到`*backend/src/backend/blueprints/members.py*`中`register`路由的开头：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the previous code block, `...` represents the existing `register` code. This
    will block registrations from the blocked email domains by returning an appropriate
    error code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码块中，`...`代表现有的`register`代码。这将通过返回适当的错误代码来阻止来自被阻止电子邮件域的注册。
- en: 'Now, we need to handle this error in the `useRegister` hook found in *frontend/src/pages/Register.tsx*:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要处理在`*frontend/src/pages/Register.tsx*`中找到的`useRegister`钩子中的这个错误：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The highlighted lines are the existing code in the `useRegister` hook. It is
    important that the check is added as an `else if` clause to the existing `if`
    clause (as shown in this snippet), otherwise the user may get multiple confusing
    error messages.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行是`useRegister`钩子中的现有代码。将检查添加到现有的`if`子句作为`else if`子句（如本片段所示）是很重要的，否则用户可能会收到多个令人困惑的错误信息。
- en: Keeping an app secure is in practice an arms race against attackers, and I recommend
    you continue to follow OWASP and adopt the latest guidance. Likewise, we’ll need
    to keep updating our packages, which we’ll focus on next.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，保持应用程序的安全就像是一场与攻击者的军备竞赛，我建议您继续遵循OWASP并采用最新的指导方针。同样，我们还需要不断更新我们的包，这是我们接下来要关注的重点。
- en: Updating packages
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新包
- en: A very common source of vulnerabilities in web applications is vulnerable dependent
    packages. This is especially true if the application is using an older version
    of a package when a new, more secure version is available. To mitigate against
    this, we can periodically check for known vulnerabilities and, crucially, update
    the packages as often as possible.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中，一个非常常见的漏洞来源是有漏洞的依赖包。如果应用程序正在使用一个包的较旧版本，而新版本提供了更高的安全性，这种情况尤其如此。为了减轻这种风险，我们可以定期检查已知的漏洞，并且关键的是，尽可能频繁地更新包。
- en: Importance of lockfiles
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 锁文件的重要性
- en: By using npm and PDM, we are using lockfiles; this means that we’ll always install
    the same package version on any system until we change the lockfile. Without a
    lockfile, we would quickly be in a position where different systems run with different
    package versions and potentially different packages. This would make it hard to
    diagnose bugs, as it may depend on a version we aren’t testing. Crucially though,
    it would make our app less secure as we would have no control over what was installed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用npm和PDM，我们正在使用锁文件；这意味着在更改锁文件之前，我们将在任何系统上始终安装相同的包版本。如果没有锁文件，我们很快就会处于不同系统运行不同包版本甚至不同包的状态，这会使诊断错误变得困难，因为它可能依赖于我们未测试的版本。然而，关键的是，这会使我们的应用程序的安全性降低，因为我们无法控制安装的内容。
- en: Periodically checking for vulnerabilities
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定期检查漏洞
- en: In our app, we are using many third-party dependencies, each of which is likely
    to be using additional third-party dependencies. This means there is a large number
    of libraries that we need to check for vulnerabilities – too many to do ourselves!
    Fortunately, when others find vulnerabilities, they are published, and tools exist
    to check the version installed against the published list of issues.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们使用了许多第三方依赖项，每个依赖项都可能使用额外的第三方依赖项。这意味着我们需要检查大量库是否存在漏洞——太多以至于我们无法自己完成！幸运的是，当其他人发现漏洞时，它们会被发布，并且存在工具可以检查安装的版本与已发布的漏洞列表之间的版本。
- en: We’ll use these tools to check our code, allowing us to switch to a fixed version
    if they find anything. This is something I recommend to be done periodically and
    automatically, specifically every week, via a GitHub workflow.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这些工具来检查我们的代码，如果它们发现任何问题，我们可以切换到固定版本。我建议定期自动执行此操作，具体来说，每周通过GitHub工作流执行一次。
- en: 'To start, we can create a workflow that is scheduled to run at 9 a.m. UTC on
    a Tuesday by adding the following to *.github/workflows/audit.yml*:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们可以创建一个工作流，该工作流计划在UTC时间周二上午9点运行，通过在*.github/workflows/audit.yml*中添加以下内容来实现：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tuesday patches
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 周二补丁
- en: Tuesday is typically the day to apply patches as it’s early in the week, almost
    always a workday (Mondays may not be workdays during holidays), and crucially,
    gives time on Monday to respond to weekend issues, leaving Tuesday free for patch
    issues.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 周二通常是应用补丁的日子，因为它在一周的开始，几乎总是工作日（假期期间周一可能不是工作日），并且最重要的是，它为周一提供了时间来响应周末的问题，使得周二可以自由处理补丁问题。
- en: 'To check the frontend code, we can use `npm audit`, which is built into the
    `npm` package manager. This tool will check the installed frontend dependencies
    and alert if any insecure package versions are found. To run it on the schedule,
    the following job should be added to *.github/workflows/audit.yml*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查前端代码，我们可以在`npm`包管理器中内置的`npm audit`工具。此工具将检查已安装的前端依赖项，并在发现任何不安全的包版本时发出警报。为了按计划运行它，应在*.github/workflows/audit.yml*中添加以下作业：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, to check the backend code, we can use `pip-audit`, which is installed
    by running the following command in the *backend* directory:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了检查后端代码，我们可以在*后端*目录中运行以下命令来使用`pip-audit`：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We’ll add a `pdm` script so that we can use `pdm run audit` to audit the code,
    as we did in the *Installing Python for backend development* section of [*Chapter
    1*](B18727_01.xhtml#_idTextAnchor015)*, Setting Up Our System for Development;*
    so, add the following to *backend/pyproject.toml*:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个`pdm`脚本来使用`pdm run audit`来审计代码，就像我们在[*第1章*](B18727_01.xhtml#_idTextAnchor015)*，设置我们的开发系统；*中的*安装后端开发Python*部分所做的那样；因此，将以下内容添加到*后端/pyproject.toml*中：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With this in place, we can add the following job to *.github/workflows/audit.yml*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们可以在*.github/workflows/audit.yml*中添加以下作业：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This workflow will fail if either the `frontend-audit` or `backend-audit` job
    finds packages with security issues, and will alert us. However, it is best to
    be proactive and keep our dependencies up to date.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`frontend-audit`或`backend-audit`作业发现存在安全问题的包，此工作流将失败，并发出警报。然而，最好是主动地保持我们的依赖项更新。
- en: A system for monthly updates
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个月度更新系统
- en: To ensure the dependencies are up to date, I recommend updating all the packages
    every month. This ensures that the app never has dependencies that are more than
    a month old and makes it easier to utilize the dependencies’ latest features.
    This may seem like a lot of work, however, in my experience, it takes much more
    effort to do all the upgrades at once than to do them in smaller batches.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保依赖项是最新的，我建议每个月更新所有包。这确保了应用程序永远不会使用超过一个月的依赖项，并且更容易利用依赖项的最新功能。这看起来可能是一项繁重的工作，然而，根据我的经验，一次性完成所有升级比分批进行需要更多的努力。
- en: To make this process easier, we must unpin the dependencies in the *frontend/package.json*
    and *backend/pyproject.toml* files. This doesn’t mean we’ve unpinned the dependencies
    though, as both *frontend/package-lock.json* and *backend/pdm.lock* will fully
    define the exact versions to install. It instead means that we will allow our
    app to work with any library version if directed – and we will direct it to always
    use the latest.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个过程更容易，我们必须在*前端/package.json*和*后端/pyproject.toml*文件中取消固定依赖项。但这并不意味着我们已经取消固定依赖项，因为*前端/package-lock.json*和*后端/pdm.lock*将完全定义要安装的确切版本。这反而意味着如果需要，我们将允许我们的应用程序与任何库版本一起工作——并且我们将指导它始终使用最新版本。
- en: 'The *frontend/package.json* file should look like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*前端/package.json*文件应如下所示：'
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that each dependency is now unpinned, with `*` meaning any version is allowed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在每个依赖项都没有被固定，`*`表示允许任何版本。
- en: 'With these changes made, we can run the following command in the *frontend*
    directory to update the frontend dependencies:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出这些更改后，我们可以在*前端*目录中运行以下命令来更新前端依赖项：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can also run a similar command in the *backend* directory to update the
    backend dependencies:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在*后端*目录中运行类似的命令来更新后端依赖项：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, to upgrade the infrastructure dependencies, the following should be
    run in the *infrastructure* directory:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了升级基础设施依赖项，应在*基础设施*目录中运行以下命令：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These updates will likely result in small changes needing to be made to support
    the latest versions. It is likely that the CI checks, especially the type checking
    we’ve used throughout, will warn if these changes are not made.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更新可能需要做出一些小的更改以支持最新版本。很可能会出现CI检查警告，特别是我们一直在使用的类型检查，如果这些更改没有进行。
- en: Now that we have a system for keeping our app up to date, we can add multifactor
    authentication to help our users secure their accounts.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个系统来保持我们的应用程序更新，我们可以添加多因素认证来帮助我们的用户保护他们的账户。
- en: Adding multifactor authentication
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加多因素认证
- en: Our app allows users to log in by providing an email and a password. This means
    we allow them to authenticate with something they know (i.e., the password). We
    could also allow them to use other factors of authentication such as using their
    fingerprint (i.e., something they are), or a specific mobile device (i.e., something
    they have). Requiring a user to authenticate using multiple factors makes it much
    harder for an attacker to gain access to their account, however, it also makes
    it harder for the user to authenticate themselves. Therefore, it is best to allow
    users to opt into multifactor authentication.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序允许用户通过提供电子邮件和密码来登录。这意味着我们允许他们通过他们知道的东西（即密码）进行身份验证。我们还可以允许他们使用其他身份验证因素，例如使用他们的指纹（即他们是什么），或特定的移动设备（即他们有什么）。要求用户使用多个因素进行身份验证会使攻击者更难访问他们的账户，但这也使得用户进行身份验证变得更加困难。因此，最好允许用户选择加入多因素认证。
- en: Users are most familiar with using their phones as an additional factor, which
    we will implement using **time-based one-time passcode** (**TOTP**) tokens based
    on a shared secret. The shared secret, on the user’s phone, is an additional factor.
    It is also common to use SMS messages sent to the user’s phone; however, this
    method is increasingly easy to attack and should not be considered secure.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 用户最熟悉的是将手机作为额外因素使用，我们将使用基于共享密钥的**基于时间的单次密码**（TOTP）令牌来实现这一点。在用户的手机上，共享密钥是一个额外的因素。使用发送到用户手机的短信消息也很常见；然而，这种方法越来越容易受到攻击，不应被视为安全。
- en: TOTP
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: TOTP
- en: The TOTP algorithm makes use of a shared secret and the current time to generate
    a code that is valid for a certain period of time (usually about 60 seconds).
    Any two systems should calculate the same code for the same time and shared secret,
    hence the user can provide a code that our app should match.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: TOTP算法利用共享密钥和当前时间生成一个在一定时间内有效的代码（通常约为60秒）。任何两个系统都应该为相同的时间和共享密钥计算出相同的代码，因此用户可以提供一个代码，我们的应用程序应该匹配。
- en: '**Multifactor Authentication** (**MFA**) using TOTP works by first sharing
    a secret with the user. This is typically done by showing a QR code in our app,
    which the user scans using an authentication app. The user’s authentication app
    will then display a code that the user can enter in our app to confirm that MFA
    has been set up. Then, on any subsequent logins, the user will need to enter the
    current code as displayed by their authentication app.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于TOTP的多因素认证（MFA**）的工作原理是首先与用户共享一个密钥。这通常是通过在我们的应用程序中显示一个二维码来完成的，用户使用身份验证应用程序扫描该二维码。然后，用户的身份验证应用程序将显示一个用户可以在我们的应用程序中输入的代码，以确认已设置MFA。然后，在随后的任何登录中，用户都需要输入由他们的身份验证应用程序显示的当前代码。'
- en: To support MFA in our app, we will need to update the database and associated
    models, add the functionality to activate it in the backend and frontend, and
    then, finally, utilize MFA when logging in.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用程序中支持MFA，我们需要更新数据库和相关模型，添加在后端和前端激活它的功能，然后，最后，在登录时利用MFA。
- en: Updating the database and models
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新数据库和模型
- en: 'To support MFA, we need to store two pieces of information for each member:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要支持MFA，我们需要为每个成员存储两块信息：
- en: The first is the shared secret, which can be `NULL` if the user hasn’t activated
    MFA.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一项是共享密钥，如果用户尚未激活多因素认证（MFA），则该密钥可以是`NULL`。
- en: The second is the last code they used, which can also be `NULL`. The last code
    is required to prevent replay attacks whereby an attacker simply resends the previous
    MFA code.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二项是他们最后使用的代码，也可以是`NULL`。最后使用的代码是必需的，以防止重放攻击，攻击者只需重新发送之前的MFA代码。
- en: 'To add this information, we need to create a new database migration by adding
    the following code to *backend/src/backend/migrations/1.py*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加此信息，我们需要创建一个新的数据库迁移，通过将以下代码添加到`backend/src/backend/migrations/1.py`：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Good migrations
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的迁移
- en: Database migrations must be written with care, as the migration will change
    the database state while the code is accessing it. For this reason, it is best
    to write migrations that add functionality while allowing older code to continue
    to run. For example, it is best not to delete or rename columns in one migration;
    instead, a new column should be added, then used for a while before the old column
    is removed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库迁移必须谨慎编写，因为迁移将在代码访问数据库状态时更改数据库状态。因此，最好编写在允许旧代码继续运行的同时添加功能的迁移。例如，最好不要在一个迁移中删除或重命名列；相反，应该添加一个新列，然后使用一段时间后再删除旧列。
- en: 'We also need to update the backend model to account for these two new columns,
    by changing the `Member` model in *backend/src/backend/models/member.py* to the
    following (changes are highlighted):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新后端模型以考虑这两个新列，通过将 *backend/src/backend/models/member.py* 中的 `Member` 模型更改为以下内容（变更已高亮显示）：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We now also need to update the following model functions in *backend/src/backend/models/member.py*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还需要更新以下模型函数在 *backend/src/backend/models/member.py*：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that the only change (as highlighted) is to add the new columns to the
    SQL query.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，唯一的变更（如高亮所示）是在SQL查询中添加新列。
- en: 'To be able to change the values of the `last_totp` and `totp_secret` columns,
    we’ll need to add the following functions to *backend/src/backend/models/member.py*:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够更改 `last_totp` 和 `totp_secret` 列的值，我们需要在 *backend/src/backend/models/member.py*
    中添加以下函数：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With the database and backend models updated, we can add the functionality to
    activate MFA.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库和后端模型更新后，我们可以添加激活MFA的功能。
- en: Activating MFA
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 激活MFA
- en: 'To activate MFA, we will need a page in our app that follows the process shown
    in *Figure 7.1*:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活MFA，我们需要一个页面，我们的应用程序中的页面应遵循 *图7.1* 中显示的过程：
- en: '![Figure 7.1: MFA activation process ](img/B18787_07_01.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：MFA激活过程](img/B18787_07_01.jpg)'
- en: 'Figure 7.1: MFA activation process'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：MFA激活过程
- en: 'The secret itself will need to be generated and managed on the backend, which
    we can do using the `pyotp` library; the library is installed by running the following
    in the *backend* directory:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥本身需要在后端生成和管理，我们可以使用 `pyotp` 库来完成；在 *backend* 目录中运行以下命令来安装库：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can now start adding the backend routes, beginning with a route that returns
    the member’s MFA status. This will either be `active` where MFA is in use, `inactive`
    where MFA is not in use, or `partial` where the member is in the process of activating
    MFA; it will also need to return the shared secret. We’ll return the secret as
    a URI from which we can generate a QR code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始添加后端路由，从返回成员MFA状态的路由开始。这将要么是 `active`（MFA正在使用中），要么是 `inactive`（MFA未使用），要么是
    `partial`（成员正在激活MFA的过程中）；它还需要返回共享密钥。我们将以URI的形式返回密钥，我们可以从中生成QR码。
- en: 'The code for this route is as follows and should be added to *backend/src/backend/blueprints/members.py*:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此路由的代码如下，并应添加到 *backend/src/backend/blueprints/members.py*：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that `totp_uri` is only returned for a partial state (highlighted), as
    the secret it contains should only be shared when it is needed.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`totp_uri` 仅在部分状态下返回（已高亮），因为它包含的秘密只有在需要时才应共享。
- en: 'The next route we need is to allow a member to initiate MFA, by creating a
    shared secret. This should be added to *backend/src/backend/blueprints/members.py*:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个我们需要的路由是允许成员通过创建共享密钥来启动MFA。这应该添加到 *backend/src/backend/blueprints/members.py*：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The final route we need is to confirm the setup by allowing the user to put
    a TOTP code, which should be added to *backend/src/backend/blueprints/members.py*:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最后一个路由是允许用户输入TOTP代码以确认设置，这应该添加到 *backend/src/backend/blueprints/members.py*：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can now build the frontend page to handle the interface, which will need
    to display a QR code. We can do that via `qrcode.react`, which is installed by
    running the following command in the *frontend* directory:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以构建前端页面来处理界面，该界面需要显示QR码。我们可以通过在 *frontend* 目录中运行以下命令来安装 `qrcode.react`
    来实现这一点：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The page we need to build should look like *Figure 7.2*:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要构建的页面应该看起来像 *图7.2*：
- en: '![Figure 7.2: The MFA setup page ](img/B18787_07_02.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2：MFA设置页面](img/B18787_07_02.jpg)'
- en: 'Figure 7.2: The MFA setup page'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：MFA设置页面
- en: 'To build the MFA page, we first need to add a specific field for the user to
    enter one-time codes, by adding the following to *frontend/src/components/TotpField.tsx*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建MFA页面，我们首先需要在 *frontend/src/components/TotpField.tsx* 中添加一个特定字段，让用户输入一次性密码，具体操作如下：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Before we use `TotpField`, we need to add the functionality required to activate
    MFA to *frontend/src/pages/MFA.tsx*:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`TotpField`之前，我们需要将激活MFA所需的功能添加到 *frontend/src/pages/MFA.tsx*：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The mutation invalidates the `mfa` queries, as this is the key that we’ll use
    for the query that determines the user’s MFA state.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该突变使`mfa`查询无效，因为这是我们用于确定用户MFA状态的查询的关键。
- en: 'We also need functionality to confirm the MFA activation, which can be added
    to *frontend/src/pages/MFA.tsx*:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加一个功能来确认MFA激活，这可以添加到 *frontend/src/pages/MFA.tsx*：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With the functionality in place, we can add the UI elements, as follows, which
    should be added to *frontend/src/pages/MFA.tsx*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能到位后，我们可以添加以下UI元素，这些元素应添加到 *frontend/src/pages/MFA.tsx*：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The displayed UI code is dependent on the MFA state, including initially when
    a `Skeleton` is shown while the MFA state is being fetched from the backend. It
    then shows a `LoadingButton` to activate MFA, a QR code and `TotpField` to confirm
    MFA activation, and finally confirmation text if MFA is active.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的UI代码取决于MFA状态，包括最初在从后端获取MFA状态时显示`Skeleton`的情况。然后显示`LoadingButton`以激活MFA，一个二维码和`TotpField`以确认MFA激活，如果MFA处于激活状态，则最终显示确认文本。
- en: 'Next, the MFA page needs to be added to the routing by adding the following
    to *frontend/src/Router.tsx*:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，需要通过在 *frontend/src/Router.tsx* 中添加以下内容来将MFA页面添加到路由中：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the code block, `...` represents code that has been omitted for brevity.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码块中，`...`代表为了简洁而省略的代码。
- en: 'To allow the user to find the MFA page, we can add the following `MenuItem`
    to the `AccountMenu` component in *frontend/src/components/AccountMenu.tsx*:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用户能够找到MFA页面，我们可以在 *frontend/src/components/AccountMenu.tsx* 组件中添加以下`MenuItem`：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now that the user can activate MFA, we can utilize it in the login process.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户可以激活MFA，我们可以在登录过程中使用它。
- en: Logging in with MFA
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用MFA登录
- en: 'The login process must also change to ask the user for a one-time code if they
    have activated MFA. To do this, the backend must indicate to the frontend that
    an additional token is required for users that have activated MFA. The following
    code should replace the login route in *backend/src/backend/blueprints/sessions.py*:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 登录过程还必须更改，如果用户已激活MFA，则要求用户提供一次性密码。为此，后端必须向前端指示，对于已激活MFA的用户，需要额外的令牌。以下代码应替换 *backend/src/backend/blueprints/sessions.py*
    中的登录路由：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This code will return a `400` error response if the user has activated MFA,
    but the login data doesn’t include a one-time code (`token`); this allows the
    frontend login page to then ask the user for the one-time code and then retry
    logging in. In addition, the code will return a `401` invalid credentials message
    if the one-time code is invalid – noting that it checks the previously used code
    to prevent replay attacks.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户已激活MFA，但登录数据不包括一次性密码（`token`），则此代码将返回`400`错误响应；这允许前端登录页面随后要求用户提供一次性密码并重新尝试登录。此外，如果一次性密码无效，代码将返回`401`无效凭据消息——注意它检查之前使用的代码以防止重放攻击。
- en: 'We can now alter the existing login page so that it looks like *Figure 7.3*
    for accounts that have activated MFA:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以修改现有的登录页面，使其看起来像 *图7.3*，适用于已激活MFA的账户：
- en: '![Figure 7.3: The Login page with the additional One time code field ](img/B18787_07_03.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3：带有额外一次性密码字段的登录页面](img/B18787_07_03.jpg)'
- en: 'Figure 7.3: The Login page with the additional One time code field'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：带有额外一次性密码字段的登录页面
- en: 'To begin, we need to alter the `useLogin` logic in *frontend/src/pages/Login.tsx*
    to be the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要修改 *frontend/src/pages/Login.tsx* 中的`useLogin`逻辑，如下所示：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `useLogin` hook returns the login functionality and a flag indicating whether
    a one-time code is required. This flag is set when a login is attempted, and a
    `400` response is returned by the backend.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`useLogin`钩子返回登录功能和一个标志，指示是否需要一次性密码。当尝试登录时，此标志被设置，并且后端返回`400`响应。'
- en: 'We can use the flag from the `useLogin` hook to show `TotpField` in the login
    form by making the highlighted changes to *frontend/src/pages/Login.tsx*:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`useLogin`钩子中的标志来在登录表单中显示`TotpField`，通过在 *frontend/src/pages/Login.tsx*
    中进行以下突出显示的更改：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will allow the user to type in a one-time code and complete the login.
    We can now consider how to handle the user losing the shared secret.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许用户输入一次性密码并完成登录。我们现在可以考虑如何处理用户丢失共享密钥的情况。
- en: Recovering and inactivating MFA
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恢复和停用MFA
- en: Users will inevitably lose the shared secret and need to recover access to their
    accounts. This is something that is often done via recovery codes that the user
    is given when activating MFA. These recovery codes are additional single-use secrets
    stored in the backend and can be used once to regain access. While this works,
    any recovery system needs to consider how and what form your customer service
    will take, as users typically reach out for help.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 用户不可避免地会丢失共享密钥并需要恢复对账户的访问。这通常是用户在激活多因素认证时获得的恢复代码所完成的。这些恢复代码是存储在后端中的额外一次性密钥，可以一次性使用以恢复访问。虽然这可行，但任何恢复系统都需要考虑您的客户服务将如何以及以何种形式进行，因为用户通常会寻求帮助。
- en: 'OWASP provides additional guidance for this, which you can see here: [cheatsheetseries.owasp.org/cheatsheets/Multifactor_Authentication_Cheat_Sheet.xhtml#resetting-mfa](http://cheatsheetseries.owasp.org/cheatsheets/Multifactor_Authentication_Cheat_Sheet.xhtml#resetting-mfa).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP为此提供了额外的指导，您可以在以下链接中查看：[cheatsheetseries.owasp.org/cheatsheets/Multifactor_Authentication_Cheat_Sheet.xhtml#resetting-mfa](http://cheatsheetseries.owasp.org/cheatsheets/Multifactor_Authentication_Cheat_Sheet.xhtml#resetting-mfa)。
- en: We’ve successfully made a major change to our app, which you can use as a template
    for further major changes you’ll need to make for your app. Next, we package our
    app for the app stores by converting it into a progressive web app.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对我们的应用进行了重大更改，您可以用它作为模板来进一步为您的应用进行重大更改。接下来，我们将通过将其转换为渐进式Web应用来打包我们的应用以供应用商店使用。
- en: Converting to a Progressive Web App
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换为渐进式Web应用
- en: We can make our app more user-friendly, especially on mobile devices, by converting
    it into a **progressive web app** (**PWA**). PWAs can be installed on a mobile,
    like all other apps, either via the app stores or directly from a prompt in the
    browser. PWAs can also work offline and use other advanced features such as push
    notifications. However, PWAs are more complicated to develop, and service workers
    (a key feature) can be very difficult to get right.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将其转换为**渐进式Web应用**（**PWA**）来使我们的应用更加用户友好，尤其是在移动设备上。PWA可以像所有其他应用一样安装在手机上，无论是通过应用商店还是直接从浏览器中的提示进行安装。PWA还可以离线工作并使用其他高级功能，如推送通知。然而，PWA的开发更为复杂，服务工作者（一个关键特性）可能非常难以正确实现。
- en: Service workers
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者
- en: Service workers are custom JavaScript scripts that act as a proxy between the
    web page and the server. This allows the service worker to add offline-frst functionality,
    such as caching pages for performance or accepting push notifications.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者是作为网页和服务器之间代理的定制JavaScript脚本。这允许服务工作者添加离线优先功能，例如缓存页面以提高性能或接受推送通知。
- en: 'A PWA must have a service worker and a manifest file to work; these are available
    via the `create-react-app` tool we used in [*Chapter 1*](B18727_01.xhtml#_idTextAnchor015),
    *Setting Up Our System for Development*. To do so, let’s create a new `react`
    app using the PWA template in a temporary directory:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一个PWA必须有一个服务工作者和一个清单文件才能工作；这些文件可以通过我们用于[*第1章*](B18727_01.xhtml#_idTextAnchor015)、“设置我们的开发系统”的`create-react-app`工具获得。为此，让我们在临时目录中使用PWA模板创建一个新的`react`应用：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can then copy the service worker code from this temporary project into ours
    by copying the following files:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过复制以下文件将服务工作者代码从临时项目复制到我们的项目中：
- en: Copy *temp/src/service-worker.ts* to *frontend/src/service-worker.ts*
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将*temp/src/service-worker.ts*复制到*frontend/src/service-worker.ts*
- en: Copy *temp/src/serviceWorkerRegistration.ts* to *frontend/src/serviceWorkerRegistration.ts*
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将*temp/src/serviceWorkerRegistration.ts*复制到*frontend/src/serviceWorkerRegistration.ts*
- en: The *temp* directory can now be deleted or kept for reference if you prefer.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以选择删除*temp*目录或保留以供参考。
- en: 'To activate the service worker, the following should be added to *frontend/src/index.tsx*
    to register the service worker:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活服务工作者，以下内容应添加到*frontend/src/index.tsx*中以注册服务工作者：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This service worker needs a large number of dependencies from the workbox toolkit
    ([web.dev/workbox/](http://web.dev/workbox/)) to work; these dependencies are
    developed by Google to make service workers easier to use. These dependencies
    can be installed by running the following in the *frontend* directory:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务工作者需要从workbox工具包（[web.dev/workbox/](http://web.dev/workbox/））中依赖大量依赖项才能工作；这些依赖项由Google开发，以使服务工作者更容易使用。这些依赖项可以通过在*前端*目录中运行以下命令来安装：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The service worker isn’t active while we develop the app using the frontend
    development server with `npm run start`, so to test it, we need to serve it locally
    by the backend development server. First, we must build the frontend, by running
    the following in the *frontend* directory:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This will have created files in the *frontend/build* directory, which we need
    to copy over to the backend. This requires the following file movements:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Copy the entire *frontend/build/static* directory to *backend/src/backend/static*
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the *frontend/build/index.xhtml* file to *backend/src/backend/templates/index.xhtml*
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the remaining files in *frontend/build* to *backend/src/backend/static*
    (e.g., *frontend/build/service-worker.js* to *backend/src/backend/static/service-worker.js*)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The remaining files also need to be included in *Dockerfile*, and the following
    should be added next to the existing `COPY --from=frontend` commands:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With the backend running (via `pdm run start`), the service worker-enabled
    app is reachable at `localhost:5050`. You can check the service worker is working
    via the dev tools console as seen in *Figure 7.4*:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: The service worker output in the browser dev tools ](img/B18787_07_04.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: The service worker output in the browser dev tools'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The service worker will now start caching the content, and you should be able
    to refresh the app while the backend is not running.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: App icons
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Web pages in the browser have an icon associated with them, typically shown
    next to the title in the tab. This icon is called the favicon. A PWA has additional
    icons used for the app on the mobile home screen (and elsewhere); these icons
    are defined in the manifest file.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now turn our attention to the manifest file, which describes the app
    and the logo that should be associated with it. Once you have designed a logo,
    I’d recommend that it be saved as a favicon in the SVG format placed in *frontend/public/favicon.svg*.
    As we are using an SVG format rather than ICO, the following should replace the
    existing code in *frontend/public/index.xhtml* (note the file extension):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The same logo then needs to be saved in the PNG format as a 192x192 pixel square
    in *frontend/public/logo192.png* and as a 512x512 pixel square in *frontend/public/logo512.png*.
    The manifest should include the following, which should be placed in *frontend/public/manifest.json*:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As with the service worker, we also need to copy the logos to the backend.
    For development, copy all the logos to the *backend/src/backend/static/* folder.
    For production, the following should be added to the *Dockerfile*:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We now need to serve these new files from the backend, which we can do by adding
    the following code to *backend/src/backend/blueprints/serving.py*:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With these changes made, our app is a PWA, which means that we can package it
    for the app stores. The easiest way to do so is to use [pwabuilder.com](http://pwabuilder.com),
    which will create iOS and Android packages. To do so, visit [pwabuilder.com](http://pwabuilder.com)
    and enter your app’s domain. It will then present the packages that can be uploaded
    to the Google Play store and iOS app stores.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: PWA Builder
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: PWA Builder is a Microsoft-directed project to improve PWA adoption by making
    it easier. PWAs are first-class apps on Windows and Android.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: There are limitations to this approach; first, while PWAs are first-class apps
    on Windows and Android systems, they have limited support on Apple’s iOS. It may
    be the case that your app as packaged by PWA Builder is not accepted on the app
    store – with little explanation why. In addition, iOS does not support all the
    features that PWAs can; the most notable being that push notifications will not
    be supported till 2023.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: With the conversion to PWA complete, we can upload the PWA package to the various
    app stores allowing users to install it on their phones from the store. Further
    instructions on how to do so are given for Android (https://docs.pwabuilder.com/#/builder/android)
    and iOS ([https://docs.pwabuilder.com/#/builder/app-store](https://docs.pwabuilder.com/#/builder/app-store)).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve secured our app and adopted a process of continual updates
    to keep it secure. We’ve also added a major feature, MFA, which will serve as
    a guide for making future major changes to your app. Finally, we’ve packaged our
    app ready to be added to the app stores.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: This is a great place to be, as you now have a blueprint for a web app that
    is running in production using many industry best practices. This is a blueprint
    you can adapt for your own needs with the to-do specific aspects serving as a
    guide, and I hope that the best practices and tools I’ve introduced to you serve
    you well.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This isn’t the end; there is much more you can and should now do to improve
    your app to make it more valuable to your users. I’d recommend you add more testing
    to reduce bugs, specifically by adding end-to-end testing. I’d also recommend
    you use tools such as Lighthouse, [pagespeed.web.dev](http://pagespeed.web.dev),
    to identify common performance, accessibility, and general PWA issues.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
