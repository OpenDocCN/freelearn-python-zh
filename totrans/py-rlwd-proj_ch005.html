<html xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<meta charset="utf-8"/>
<meta content="pandoc" name="generator"/>
<title>ch005.xhtml</title>

<!-- kobo-style -->
<style id="koboSpanStyle" type="text/css" xmlns="http://www.w3.org/1999/xhtml">.koboSpan { -webkit-text-combine: inherit; }</style>
</head>
<body epub:type="bodymatter">

<h1 data-number="5">Chapter 1<br/>
Project Zero: A Template for Other Projects</h1>
<p>This is a book of projects. To make each project a good portfolio piece, we’ll treat each project as an enterprise software product. You can build something that could be posted to a company’s (or organization’s) internal repository.</p>
<p>For this book, we’ll define some standards that will apply to all of these projects. The standards will identify deliverables as a combination of files, modules, applications, notebooks, and documentation files. While each enterprise is unique, the standards described here are consistent with my experience as a consultant with a variety of enterprises.</p>
<p>We want to draw an informal boundary to avoid some of the steps required to post to the PyPI website. Our emphasis is on a product with test cases and enough documentation to explain what it does. We don’t want to go all the way to creating a project in PyPI. This allows us to avoid the complications of a build system and the associated <code>pyproject.toml</code> file.</p>
<p>These projects are not intended to produce generic, reusable modules. They’re applications specific to a problem domain and a dataset. While these are specific solutions, we don’t want to discourage anyone who feels motivated to generalize a project into something generic and reusable.</p>
<p>This chapter will show the general outline of each project. Then we’ll look at the set of deliverables. This chapter ends with project zero – an initial project that will serve as a template for others. We’ll cover the following topics:</p>
<ul>
<li><p>An overview of the software quality principles that we’ll try to emphasize.</p></li>
<li><p>A suggested approach to completing the project as a sequence of project sprints.</p></li>
<li><p>A general overview of the list of deliverables for each project.</p></li>
<li><p>Some suggested tools. These aren’t required, and some readers may have other choices.</p></li>
<li><p>A sample project to act as a template for subsequent projects.</p></li>
</ul>
<p>We’ll start with an overview of some characteristics of high-quality software. The idea is to establish some standards for the deliverables of each project. </p>

<h2 data-number="5.1">1.1  On quality</h2>
<p>It helps to have a clear definition of expectations. For these expectations, we’ll rely on the ISO 25010 standard to define quality goals for each project. For more details, see <a class="url" href="https://iso25000.com/index.php/en/iso-25000-standards/iso-25010">https://iso25000.com/index.php/en/iso-25000-standards/iso-25010</a>.</p>
<p>The ISO/IEC 25010:2011 standard describes <strong>Systems and software</strong> <strong>Quality Requirements and Evaluation </strong>(<strong>SQuaRE</strong>). This standard provides eight characteristics of software. These characteristics are as follows:</p>
<ul>
<li><p><strong>Functional suitability</strong>. Does it do what we need? It is complete, correct, and appropriate for the user’s expressed (and implied) needs? This is the focus of each project’s description.</p></li>
<li><p><strong>Performance efficiency</strong>. Does it work quickly? Does it use the minimum resources? Does it have enough capacity to meet the user’s needs? We won’t address this deeply in this book. We’ll talk about writing performance tests and ways to address performance concerns.</p></li>
<li><p><strong>Compatibility</strong>. Does it co-exist with other software? Does it properly interoperate with other applications? To an extent, Python can help assure an application interoperates politely with other applications. We’ll emphasize this compatibility issue in our choices of file formats and communication protocols.</p></li>
<li><p><strong>Usability</strong>. There are a number of sub-characteristics that help us understand usability. Many of the projects in this book focus on the <strong>command-line interface </strong>(<strong>CLI</strong>) to assure a bare minimum of learnability, operability, error protection, and accessibility. A few projects will include a web services API, and others will make use of the GUI interface of JupyterLab to provide interactive processing.</p></li>
<li><p><strong>Reliability</strong>. Is it available when the users want it? Can we detect and repair problems? We need to make sure we have all of the parts and pieces so we can use the software. We also need to make sure we have a complete set of tests to confirm that it will work.</p></li>
<li><p><strong>Security</strong>. As with usability, this is a deep topic. We’ll address some aspects of security in one of the projects. The remaining projects will use a CLI permitting us to rely on the operating system’s security model.</p></li>
<li><p><strong>Maintainability</strong>. Can we diagnose problems? Can we extend it? We’ll look at documentation and test cases as essential for maintainability. We’ll also leverage a few additional project files to make sure our project can be downloaded and extended by others.</p></li>
<li><p><strong>Portability</strong>. Can we move to a new Python version? New hardware? This is very important. The Python ecosystem is rapidly evolving. Since all of the libraries and packages are in a constant state of change, we need to be able to define precisely what packages our project depends on, and confirm that it works with a new candidate set of packages.</p></li>
</ul>
<p>Two of these characteristics (Compatibility and Portability) are features of Python. A wise choice of interfaces assures that these characteristics are met. These are sometimes described as architectural decisions since they influence how multiple applications work together.</p>
<p>For Security, we will rely on the operating system. Similarly, for Usability, we’ll limit ourselves to CLI applications, relying on long-standing design principles.</p>
<p>The idea of Performance is something we won’t emphasize here. We will point out places where large data sets will require some careful design. The choice of data structure and algorithm is a separate subject area. Our objective in this book is to expose you to projects that can provide the stimulus for a deeper study of performance issues.</p>
<p>Three of these quality characteristics — Functional suitability, Reliability, and Maintainability — are the real focus of these projects. These seem to be essential elements of good software design. These are the places where you can demonstrate your Python programming skills.</p>
<p>Another view is available from <strong>The Twelve-Factor App </strong>( <a class="url" href="https://12factor.net">https://12factor.net</a>). This is narrowly focused on web applications. The concepts provide deeper insights and more concrete technical guidance into the quality characteristics shown above:</p>
<ol>
<li><div><p>Codebase. ”One codebase tracked in revision control, many deploys.” We’ll use <strong>Git </strong>and <strong>GitHub </strong>or perhaps one of the other version managers supported by <strong>sourceforge</strong>.</p>
</div></li>
<li><div><p>Dependencies. ”Explicitly declare and isolate dependencies.” Traditionally, a Python <code>requirements.txt</code> file was used for this. In this book, we’ll move forward to using a <code>pyproject.toml</code> file.</p>
</div></li>
<li><div><p>Config. ”Store config in the environment.” We won’t emphasize this, but Python offers numerous ways to handle configuration files.</p>
</div></li>
<li><div><p>Backing services. ”Treat backing services as attached resources.” We touch on this in a few places. How storage, messages, mail, or caching work isn’t something we’ll examine deeply.</p>
</div></li>
<li><div><p>Build, release, run. ”Strictly separate build and run stages.” For command-line applications, this means we should deploy the application into a ”production” environment to use the high-value data and produce the results that the enterprise needs. We want to avoid running things in our desktop development environment.</p>
</div></li>
<li><div><p>Processes. ”Execute the app as one or more stateless processes.” CLI applications tend to be structured this way without making any additional effort.</p>
</div></li>
<li><div><p>Port binding. ”Export services via port binding.” We won’t emphasize this; it’s very specific to web services.</p>
</div></li>
<li><div><p>Concurrency. ”Scale out via the process model.” This is a subject for the interested reader who wants to process very large data sets. We won’t emphasize it in the main text. We will suggest some of these topics in the ”Extras” section of some chapters.</p>
</div></li>
<li><div><p>Disposability. ”Maximize robustness with fast startup and graceful shutdown.” CLI applications tend to be structured this way, also.</p>
</div></li>
<li><div><p>Dev/prod parity. ”Keep development, staging, and production as similar as possible.” While we won’t emphasize this deeply, our intent with CLI applications is to expose the distinctions between development and production with command-line arguments, shell environment variables, and configuration files.</p>
</div></li>
<li><div><p>Logs. ”Treat logs as event streams.” We will suggest applications write logs, but we won’t provide more detailed guidance in this book.</p>
</div></li>
<li><div><p>Admin processes. ”Run admin/management tasks as one-off processes.” A few of the projects will require some additional administrative programming. These will be built as deliverable CLI applications, complete with an acceptance test suite.</p>
</div></li>
</ol>
<p>Our objective is to provide project descriptions and lists of deliverables that try to conform to these quality standards. As we noted earlier, each enterprise is unique, and some organizations will fall short of these standards, while some will exceed them. </p>

<h3 data-number="5.1.1">1.1.1  More Reading on Quality</h3>
<p>In addition to the ISO standard, the IEEE 1061 standard also covers software quality. While it has been inactive since 2020, it contains some good ideas. The standard is focused on quality <em>metrics</em>, which dives deeply into the idea of analyzing software for quality factors.</p>
<p>It can also help to read <a class="url" href="https://en.wikipedia.org/wiki/ISO/IEC_9126">https://en.wikipedia.org/wiki/ISO/IEC_9126</a> for some background on the origins of the ISO standard.</p>
<p>When doing more reading on this topic, it can help to recognize the following three terms:</p>
<ul>
<li><p><strong>Factors </strong>are an external view of the software. They reflect the user’s understanding. Some of the underlying quality characteristics are not directly visible to users. Maintainability, for example, may appear to users as a reliability or usability problem because the software is difficult to repair or extend.</p></li>
<li><p><strong>Criteria </strong>come from an internal view of the software. Quality criteria are the focus of the project’s deliverables. Our project code should reflect the eight quality characteristics listed above.</p></li>
<li><p><strong>Metrics </strong>are how we can control the factors that are seen by the user. We won’t emphasize quality metrics. In some cases, tools like <strong>pylint</strong> provide tangible measurements of static code quality. This isn’t a comprehensive tool for software quality in general, but it provides an easy starting point for a few key metrics related to complexity and maintainability.</p></li>
</ul>
<p>Given these standards for high-quality software, we can turn our attention to the sequence of steps for building these files. We’ll suggest a sequence of stages you can follow. </p>



<h2 data-number="5.2">1.2  Suggested project sprints</h2>
<p>We hesitate to provide a detailed step-by-step process for building software. For more experienced developers, our sequence of steps may not match their current practices. For less experienced developers, the suggested process can help by providing a rational order in which the deliverables can be built.</p>
<p>There was a time when a ”statement of work” with a detailed list of specific tasks was a central part of a software development effort. This was often part of a ”waterfall” methodology where requirements flowed to analysts who wrote specifications that flowed down to designers who wrote high-level designs that flowed down to coders. This wasn’t a great way to build software, and has been largely supplanted by Agile methods. For more information on Agility, see <a class="url" href="https://agilemanifesto.org">https://agilemanifesto.org</a>.</p>
<p>The Agile approach lets us examine a project both as a series of steps to be completed, as well as a collection of deliverables that need to be created. We’ll describe the steps first, avoiding too much emphasis on details. We’ll revisit the deliverables, and in those sections, dive a little more deeply into what the final product needs to be.</p>
<p>The suggested approach follows the ”Agile Unified Process” ( <a class="url" href="https://www.methodsandtools.com/archive/archive.php?id=21">https://www.methodsandtools.com/archive/archive.php?id=21</a>), which has four general phases. We’ll subdivide one of the phases to distinguish two important kinds of deliverables.</p>
<p>We suggest tackling each project in the following five phases:</p>
<ol>
<li><div><p>Inception. Ready the tools. Organize the project directory and virtual environment.</p>
</div></li>
<li><div><p>Elaboration, part 1: Define done. This is implemented as acceptance test cases.</p>
</div></li>
<li><div><p>Elaboration, part 2: Define components and some tests. This is implemented as unit test cases for components that need to be built.</p>
</div></li>
<li><div><p>Construction. Build the software.</p>
</div></li>
<li><div><p>Transition. Final cleanup: make sure all tests pass and the documentation is readable.</p>
</div></li>
</ol>
<p>These efforts don’t proceed in a simple linear fashion. It’s often necessary to iterate between elaboration and construction to create features separately.</p>
<p>It often works as shown in <a href="#1.1"><em>Figure 1.1</em></a>.</p>
<figure class="IMG---Figure">
<img alt="Figure 1.1: Development Phases and Cycles " src="img/file4.jpg"/>
<figcaption class="IMG---Caption">Figure 1.1: Development Phases and Cycles </figcaption>
</figure>
<p>This figure provides a very coarse overview of the kinds of activities we’ll discuss below. The important concept is iterating between the elaboration and construction phases. It’s difficult to fully design a project before constructing all of the code. It’s easier to design a little, construct a little, and refactor as needed.</p>
<p>For a complex project, there may be a series of transitions to production. Often a ”minimally viable product” will be created to demonstrate some of the concepts. This will be followed by products with more features or features better focused on the user. Ideally, it will have both kinds of enhancements: more features and a better focus on the user’s needs.</p>
<p>We’ll look at each of these four phases in a little more detail, starting with the inception phases. </p>

<h3 data-number="5.2.1">1.2.1  Inception</h3>
<p>Start the inception phase by creating the parent directory for the project, then some commonly-used sub-directories (<code>docs</code>, <code>notebooks</code>, <code>src</code>, <code>tests</code>). There will be some top-level files (<code>README.md</code>, <code>pyproject.toml</code>, and <code>tox.ini</code>). The list of expected directories and files is described in more detail in <a href="#x1-260003"><em>List of deliverables</em></a>, later in this chapter. We’ll look at the contents of each of these files and directories in the <a href="#x1-310003"><em>Deliverables</em></a> section.</p>
<p>It helps to capture any initial ideas in the <code>README.md</code> file. Later, this will be refactored into more formal documentation. Initially, it’s the perfect place to keep notes and reminders.</p>
<p>Build a fresh, new virtual environment for the project. Each project should have its own virtual environment. Environments are essentially free: it’s best to build them to reflect any unique aspects of each project.</p>
<p>Here’s a <strong>conda </strong>command that can be used to build an environment.</p>
<div><div><pre class="console">% conda create -n project0 --channel=conda-forge python=3.10</pre>
</div>
</div>
<p>An important part of inception is to start the documentation for the project. This can be done using the Sphinx tool.</p>
<p>While Sphinx is available from the <strong>Conda Forge</strong>, this version lags behind the version available from the <strong>PyPI </strong>repository. Because of this lag, it’s best to install Sphinx using <strong>PIP</strong>:</p>
<div><div><pre class="console">% python -m pip install sphinx</pre>
</div>
</div>
<p>After installing Sphinx, it helps to initialize and publish the documentation for the project. Starting this permits publishing and sharing the design ideas as the work progresses. In the <code>docs</code> directory, do the following steps:</p>
<ol>
<li><div><p>Run the <code>sphinx-quickstart</code> command to populate the documentation. See <a class="url" href="https://www.sphinx-doc.org/en/master/usage/quickstart.html#setting-up-the-documentation-sources">https://www.sphinx-doc.org/en/master/usage/quickstart.html#setting-up-the-documentation-sources</a>.</p>
</div></li>
<li><div><p>Update the <code>index.rst</code> table of contents (TOC) with two entries: “overview” and “API”. These are sections that will be in separate files.</p>
</div></li>
<li><div><p>Write an <code>overview.rst</code> document with the definition of done: what will be accomplished. This should cover the core ”Who-What-When-Where-Why” of the project.</p>
</div></li>
<li><div><p>Put a title in the API document, and a <code>..</code><code> </code><code> todo::</code> note to yourself. You’ll add to this document as you add modules to your project.</p>
</div></li>
<li><div><p>During Elaboration, you’ll update the the <code>index.rst</code> to add sections for architecture and design decisions.</p>
</div></li>
<li><div><p>During Construction, as you create code, you’ll add to the API section.</p>
</div></li>
<li><div><p>During Transition, you’ll add to the <code>index.rst</code> with some ”How” sections: How to test it, and how to use it.</p>
</div></li>
</ol>
<p>With this as the starting point, the <code>make</code><code> html</code> command will build a documentation set in HTML. This can be shared with stakeholders to assure there’s a clear, common understanding of the project.</p>
<p>With a skeleton directory and some initial places to record ideas and decisions, it makes sense to start elaborating on the initial goal to and decide what will be built, and how it will work. </p>


<h3 data-number="5.2.2">1.2.2  Elaboration, part 1: define done</h3>
<p>It helps to have a clear definition of ”done.” This guides the construction effort toward a well-defined goal. It helps to have the definition of done written out as a formal, automated test suite. For this, the Gherkin language is helpful. The <strong>behave </strong>tool can execute the Gherkin feature to evaluate the application software. An alternative to Gherkin is using the <strong>pytest </strong>tool with the <strong>pytest-bdd </strong>plug-in to run the acceptance tests.</p>
<p>The two big advantages of Gherkin are the ability to structure the feature descriptions into scenarios and write the descriptions in English (or any other natural language). Framing the expected behavior into discrete operating scenarios forces us to think clearly about how the application or module is used. Writing in English (or other natural languages) makes it easier to share definitions with other people to confirm our understanding. It also helps to keep the definition of done focused on the problem domain without devolving into technical considerations and programming.</p>
<p>Each scenario can have three steps: Given, When, and Then. The Given step defines a context. The When step defines an action or a request of the software. The Then step defines the expected results. These step definitions can be as complex as needed, often involving multiple clauses joined with <code>And</code>. Examples can be provided in tables to avoid copying and pasting a scenario with a different set of values. A separate module provides Python implementations for the English-language step text.</p>
<p>See <a class="url" href="https://behave.readthedocs.io/en/stable/gherkin.html#gherkin-feature-testing-language">https://behave.readthedocs.io/en/stable/gherkin.html#gherkin-feature-testing-language</a> for numerous examples of scenarios written in Gherkin.</p>
<p>Start this part of elaboration by creating a <code>tests/features/project.feature</code> file based on the overview description. Don’t use a boring name like <code>project</code>. A complex project may have multiple features, so the feature file names should reflect the features.</p>
<p>To use <strong>pytest</strong>, write one (or more) acceptance test scripts in the <code>tests</code> directory.</p>
<p>The features are supported by <strong>steps</strong>. These steps are in modules in the <code>tests/steps</code> directory. A <code>tests/steps/hw_cli.py</code> module provides the necessary Python definitions for the steps in the feature file. The names of the modules don’t matter; we suggest something like <code>hw_cli</code> because it implements the steps for a hello-world command-line interface.</p>
<p>The underlying mechanism is used by the <strong>Behave </strong>tool are function decorators. These match text from the feature file to define the function that implements that step. These can have wildcard-matching to permit flexibility in wording. The decorator can also parse out parameter values from the text.</p>
<p>A <code>tests/environment.py</code> file is required, but it can be empty for simple tests. This file provides a testing context, and is where some functions used by the <strong>Behave </strong>tool to control test setup and teardown are defined.</p>
<p>As soon as scenarios have been written, it makes sense to run the <strong>Behave</strong> tool to see the acceptance test fail. Initially, this lets you debug the step definitions.</p>
<p>For this application, the steps must properly execute the application program and capture the output file. Because the application doesn’t exist yet, a test failure at this point is expected.</p>
<p>The feature files with the application scenarios are a working definition of done. When the test suite runs, it will show whether or not the software works. Starting with features that fail to work means the rest of the construction phase will be debugging the failures and fixing the software until the application passes the acceptance test suite.</p>
<p>In <a href="#x1-280005"><em>Project 0 – Hello World with test cases</em></a> we’ll look at an example of a Gherkin-language feature, the matching step definitions, and a <code>tox.ini</code> to run the test suite. </p>


<h3 data-number="5.2.3">1.2.3  Elaboration, part 2: define components and tests</h3>
<p>The acceptance test suite is often relatively ”coarse” – the tests exercise the application as a whole, and avoid internal error conditions or subtle edge cases. The acceptance test suite rarely exercises all of the individual software components. Because of this, it can be difficult to debug problems in complex applications without detailed unit tests for each unit — each package, module, class, and function.</p>
<p>After writing the general acceptance test suite, it helps to do two things. First, start writing some skeleton code that’s likely to solve the problem. The class or function will contain a docstring explaining the idea. Optionally, it can have a body of the <code>pass</code> statement. After writing this skeleton, the second step is to expand on the docstring ideas by writing unit tests for the components.</p>
<p>Let’s assume we’ve written a scenario with a step that will execute an application named <code>src/hello_world.py</code>. We can create this file and include a skeleton class definition like this:</p>
<div><div><pre class="source-code">class Greeting:
    """
    Created with a greeting text.
    Writes the text to stdout.

    ..  todo:: Finish this
    """
    pass</pre>
</div>
</div>
<p>This example shows a class with a design idea. This needs to be expanded with a clear statement of expected behaviors. Those expectations should take the form of unit tests for this class.</p>
<p>Once some skeletons and tests are written, the <strong>pytest </strong>tool can be used to execute those tests.</p>
<p>The unit tests will likely fail because the skeleton code is incomplete or doesn’t work. In the cases where tests are complete, but classes don’t work, you’re ready to start the construction phase.</p>
<p>In the cases where the design isn’t complete, or the tests are fragmentary, it makes sense to remain in the elaboration phase for those classes, modules, or functions. Once the tests are understood, construction has a clear and achievable goal.</p>
<p>We don’t always get the test cases right the first time, we must change them as we learn. We rarely get the working code right the first time. If the test cases come first, they make sure we have a clear goal.</p>
<p>In some cases, the design may not be easy to articulate without first writing some ”spike solution” to explore an alternative. Once the spike works, it makes sense to write tests to demonstrate the code works.</p>
<p>See <a class="url" href="http://www.extremeprogramming.org/rules/spike.html">http://www.extremeprogramming.org/rules/spike.html</a> for more on creating spike solutions.</p>
<p>At this point, you have an idea of how the software will be designed. The test cases are a way to formalize the design into a goal. It’s time to begin construction. </p>


<h3 data-number="5.2.4">1.2.4  Construction</h3>
<p>The construction phase finishes the class and function (and module and package) definitions started in the elaboration phase. In some cases, test cases will need to be added as the definitions expand.</p>
<p>As we get closer to solving the problem, the number of tests passed will grow.</p>
<p>The number of tests may also grow. It’s common to realize the sketch of a class definition is incomplete and requires additional classes to implement the <strong>State </strong>or <strong>Strategy </strong>design pattern. As another example, we may realize subclasses are required to handle special cases. This new understanding will change the test suite.</p>
<p>When we look at our progress over several days, we should see that the number of tests pass approaches the total number of tests.</p>
<p>How many tests do we need? There are strong opinions here. For the purposes of showing high-quality work, tests that exercise 100% of the code are a good starting point. For some industries, a more strict rule is to cover 100% of the logic paths through the code. This higher standard is often used for applications like robotics and health care where the consequences of a software failure may involve injury or death. </p>


<h3 data-number="5.2.5">1.2.5  Transition</h3>
<p>For enterprise applications, there is a transition from the development team to formal operations. This usually means a deployment into a production environment with the real user community and their data.</p>
<p>In organizations with good Continuous Integration/Continuous Deployment (CI/CD) practices, there will be a formalized execution of the <code>tox</code> command to make sure everything works: all the tests pass.</p>
<p>In some enterprises, the <code>make</code><code> html</code> command will also be run to create the documentation.</p>
<p>Often, the technical operations team will need specific topics in the documentation and the <code>README.md</code> file. Operations staff may have to diagnose and troubleshoot problems with hundreds of applications, and they will need very specific advice in places where they can find it immediately. We won’t emphasize this in this book, but as we complete our projects, it’s important to think that our colleagues will be using this software, and we want their work life to be pleasant and productive.</p>
<p>The final step is to post your project to your public repository of choice.</p>
<p>You have completed part of your portfolio. You’ll want potential business partners or hiring managers or investors to see this and recognize your level of skill.</p>
<p>We can view a project as a sequence of steps. We can also view a project as a deliverable set of files created by those steps. In the next section, we’ll look over the deliverables in a little more detail. </p>



<h2 data-number="5.3">1.3  List of deliverables</h2>
<p>We’ll take another look at the project, this time from the view of what files will be created. This will parallel the outline of the activities shown in the previous section.</p>
<p>The following outline shows many of the files in a completed project:</p>
<ul>
<li><p>The documentation in the <code>docs</code> directory. There will be other files in there, but you’ll be focused on the following files:</p>
<ul>
<li><p>The Sphinx <code>index.rst</code> starter file with references to overview and API sections.</p></li>
<li><p>An <code>overview.rst</code> section with a summary of the project.</p></li>
<li><p>An <code>api.rst</code> section with <code>..</code><code> automodule::</code> commands to pull in documentation from the application.</p></li>
</ul></li>
<li><p>A set of test cases in the <code>tests</code> directory.</p>
<ul>
<li><p>Acceptance tests aimed at Behave (or the <strong>pytest-bdd </strong>plug-in for Gherkin). When using Behave, there will be two sub-directories: a <code>features</code> directory and a <code>steps</code> directory. Additionally, there will be an <code>environment.py</code> file.</p></li>
<li><p>Unit test modules written with the <strong>pytest </strong>framework. These all have a name that starts with <code>test_</code> to make them easy for <strong>pytest</strong> to find. Ideally, the <strong>Coverage </strong>tool is used to assure 100% of the code is exercised.</p></li>
</ul></li>
<li><p>The final code in the <code>src</code> directory. For some of the projects, a single module will be sufficient. Other projects will involve a few modules. (Developers familiar with Java or C++ often create too many modules here. The Python concept of <em>module </em>is more akin to the Java concept of <em>package</em>. It’s not common Python practice to put each class definition into a separate module file.)</p></li>
<li><p>Any JupyterLab notebooks can be in the <code>notebooks</code> folder. Not all projects use JupyterLab notebooks, so this folder can be omitted if there are no notebooks.</p></li>
<li><p>A few other project files are in the top-level directory.</p>
<ul>
<li><p>A <code>tox.ini</code> file should be used to run the <strong>pytest </strong>and <strong>behave</strong> test suites.</p></li>
<li><p>The <code>pyproject.toml</code> provides a number of pieces of information about the project. This includes a detailed list of packages and version numbers to be installed to run the project, as well as the packages required for development and testing. With this in place, the <strong>tox </strong>tool can then build virtual environments using the <code>requirements.txt</code> or the <strong>pip-tools </strong>tool to test the project. As a practical matter, this will also be used by other developers to create their working desktop environment.</p></li>
<li><p>An <code>environment.yml</code> can help other developers use <strong>conda</strong> to create their environment. This will repeat the contents of <code>requirements-dev.txt</code>. For a small team, it isn’t helpful. In larger enterprise work groups, however, this can help others join your project.</p></li>
<li><p>Also, a <code>README.md</code> (or <code>README.rst</code>) with a summary is essential. In many cases, this is the first thing people look at; it needs to provide an ”elevator pitch” for the project (see <a class="url" href="https://www.atlassian.com/team-playbook/plays/elevator-pitch">https://www.atlassian.com/team-playbook/plays/elevator-pitch</a>).</p></li>
</ul></li>
</ul>
<p>See <a class="url" href="https://github.com/cmawer/reproducible-model">https://github.com/cmawer/reproducible-model</a> for additional advice on structuring complex projects.</p>
<p>We’ve presented the files in this order to encourage following an approach of writing documentation first. This is followed by creating test cases to assure the documentation will be satisfied by the programming.</p>
<p>We’ve looked at the development activities and a review of the products to be created. In the next section, we’ll look at some suggested development tools. </p>


<h2 data-number="5.4">1.4  Development tool installation</h2>
<p>Many of the projects in this book are focused on data analysis. The tooling for data analysis is often easiest to install with the <strong>conda </strong>tool. This isn’t a requirement, and readers familiar with the <strong>PIP </strong>tool will often be able to build their working environments without the help of the <strong>conda</strong> tool.</p>
<p>We suggest the following tools:</p>
<ul>
<li><p><strong>Conda </strong>for installing and configuring each project’s unique virtual environment.</p></li>
<li><p><strong>Sphinx </strong>for writing documentation.</p></li>
<li><p><strong>Behave </strong>for acceptance tests.</p></li>
<li><p><strong>Pytest </strong>for unit tests. The <strong>pytest-cov </strong>plug-in can help to compute test coverage.</p></li>
<li><p><strong>Pip-Tool </strong>for building a few working files from the <code>pyproject.toml</code> project definition.</p></li>
<li><p><strong>Tox </strong>for running the suite of tests.</p></li>
<li><p><strong>Mypy </strong>for static analysis of the type annotations.</p></li>
<li><p><strong>Flake8 </strong>for static analysis of code, in general, to make sure it follows a consistent style.</p></li>
</ul>
<p>One of the deliverables is the <code>pyproject.toml</code> file. This has all of the metadata about the project in a single place. It lists packages required by the application, as well as the tools used for development and testing. It helps to pin exact version numbers, making it easier for someone to rebuild the virtual environment.</p>
<p>Some Python tools — like PIP — work with files derived from the <code>pyproject.toml</code> file. The <strong>pip-tools </strong>creates these derived files from the source information in the TOML file.</p>
<p>For example, we might use the following output to extract the development tools information from <code>pyproject.toml</code> and write it to <code>requirements-dev.txt</code>.</p>
<div><div><pre class="console">% conda install -c conda-forge pip-tools
% pip-compile --extra=dev --output-file=requirements-dev.txt</pre>
</div>
</div>
<p>It’s common practice to then use the <code>requirements-dev.txt</code> to install packages like this:</p>
<div><div><pre class="console">% conda install --file requirements-dev.txt --channel=conda-forge</pre>
</div>
</div>
<p>This will try to install all of the named packages, pulled from the community <code>conda-forge</code> channel.</p>
<p>Another alternative is to use PIP like this:</p>
<div><div><pre class="console">% python -m pip install --r requirements-dev.txt</pre>
</div>
</div>
<p>This environment preparation is an essential ingredient in each project’s inception phase. This means the <code>pyproject.toml</code> is often the first deliverable created. From this, the <code>requirements-dev.txt</code> is extracted to build environments.</p>
<p>To make the preceding steps and deliverables more specific, we’ll walk through an initial project. This project will help show how the remaining projects should be completed. </p>


<h2 data-number="5.5">1.5  Project 0 – Hello World with test cases</h2>
<p>This is our first project. This project will demonstrate the pattern for all of the book’s projects. It will include these three elements.</p>
<ul>
<li><p><strong>Description</strong>: The description section will set out a problem, and why a user needs software to solve it. In some projects, the description will have very specific details. Other projects will require more imagination to create a solution.</p></li>
<li><p><strong>Approach</strong>: The approach section will offer some guidance on architectural and design choices. For some projects there are trade-offs, and an <strong>Extras </strong>section will explore some of the other choices.</p></li>
<li><p><strong>Deliverables</strong>: The deliverables section lists the expectations for the final application or module. It will often provide a few Gherkin feature definitions.</p></li>
</ul>
<p>For this initial project, the description isn’t going to be very complicated. Similarly, the approach part of this first project will be brief. We’ll dwell on the deliverables with some additional technical discussion. </p>

<h3 data-number="5.5.1">1.5.1  Description</h3>
<p>The problem the users need to solve is how best to bring new developers on board. A good onboarding process helps our users by making new members of the team as productive as quickly as possible. Additionally, a project like this can be used for experienced members to introduce them to new tools.</p>
<p>We need to guide our team members in installing the core set of development tools, creating a working module, and then displaying their completed work at the end of a sprint. This first project will use the most important tools and assure that everyone has a common understanding of the tools and the deliverables.</p>
<p>Each developer will build a project to create a small application. This application will have a command-line interface (CLI) to write a cheerful greeting.</p>
<p>The expectations are shown in the following example:</p>
<div><div><pre class="console">% python src/hello_world.py --who "World"
Hello, World!</pre>
</div>
</div>
<p>This example shows how running the application with a command-line parameter of <code>--who</code><code> "world"</code> produces a response on the console. </p>


<h3 data-number="5.5.2">1.5.2  Approach</h3>
<p>For this project, the objective is to create a Python application module. The module will need several internal functions. The functions can be combined into a class, if that seems more appropriate. The functions are these:</p>
<ul>
<li><p>A function to parse the command-line options. This will use the <code>argparse</code> module. The default command-line argument values are available in <code>sys.argv</code>.</p></li>
<li><p>A function to write a cheerful greeting. This is, perhaps, only a single line of code.</p></li>
<li><p>An overall function with an obvious name like <code>main()</code> to get the options and write the greeting.</p></li>
</ul>
<p>The module, as a whole, will have the function (or class) definitions. It will also have an <code>if</code><code> __name__</code><code> ==</code><code> "__main__":</code> block. This block will guard the evaluation of the expression <code>main()</code> to make the module easier to unit test.</p>
<div><div><p>This is quite a bit of engineering for a simple problem. Some might call it over-engineering. The idea is to create something with enough complexity that more than one unit test case is required.</p>
</div>
</div>
<p></p>


<h3 data-number="5.5.3">1.5.3  Deliverables</h3>
<p>As noted above in <a href="#x1-260003"><em>List of deliverables</em></a>, there are a number of deliverable files for projects in general. Here are the suggested files for this project:</p>
<ul>
<li><p><code>README.md</code> summarizes the project.</p></li>
<li><p><code>pyproject.toml</code> defines the project, including development tools, test tools, and other dependencies.</p></li>
<li><p><code>docs</code> contains the documentation. As described above, this should be built by the <code>sphinx-quickstart</code> tool and should contain at least an overview and an API section.</p></li>
<li><p><code>tests</code> contains test cases; the files include the following:</p>
<ul>
<li><p><code>test_hw.py</code> contains unit tests for the module’s functions or classes.</p></li>
<li><p><code>features/hello_world.feature</code> has an overall acceptance test as a collection of scenarios.</p></li>
<li><p><code>steps/hw_cli.py</code> has Python definitions for the steps in the scenarios.</p></li>
<li><p><code>environment.py</code> contains functions to control <strong>behave</strong>’s test setup and teardown. For simple projects, it may be empty.</p></li>
</ul></li>
<li><p><code>tox.ini</code> configuration for the <strong>tox </strong>tool to run the complete test suite.</p></li>
<li><p><code>src</code> contains the <code>hello_world.py</code> module.</p></li>
</ul>
<p>We’ll look at a few of these files in detail in the following sub-sections.</p>

<h4 class="likesubsubsectionHead" data-number="5.5.3.1">The pyproject.toml project file</h4>
<p>The <code>pyproject.toml</code> file contains a great deal of project metadata in a single location. The minimal content of this file is a description of the ”build-system” used to build and install the package.</p>
<p>For the purposes of this book, we can use the following two lines to define the build system:</p>
<div><div><pre class="source-code">[build-system]
requires = ["setuptools", "wheel"]  # PEP 508 specifications.</pre>
</div>
</div>
<p>This specifies the use of the <code>setuptools</code> module to create a “wheel” with the project’s code. The <code>pyproject.toml</code> doesn’t need to define the distribution package in any more detail. This book doesn’t emphasize the creation of a distribution package or the management of packages with the Python Package Index, PyPI.</p>
<p>The rest of this file should have information about the project. You can include a section like the following:</p>
<pre class="source-code">[project]
name = "project_0"
version = "1.0.0"
authors = [
    {name = "Author", email = "author@email.com"},
]
description = "Real-World Python Projects -- Project 0."
readme = "README.md"
requires-python = "&gt;=3.10"</pre>
<p>Clearly, you’ll want to update the <code>authors</code> section with your information. You may be using a newer version of Python and may need to change the <code>requires-python</code> string to specify the minimum version required for your unique solution.</p>
<p>The <code>[project]</code> section needs three other pieces of information:</p>
<ul>
<li><p>The packages required to execute your application.</p></li>
<li><p>Any packages or tools required to test your application.</p></li>
<li><p>Any packages or tools required to develop your application.</p></li>
</ul>
<p>These three dependencies are organized as follows:</p>
<div><div><pre class="source-code">dependencies = [
    # Packages required -- None for Project Zero.
]
[project.optional-dependencies]
dev = [
    # Development tools to work on this project
    "sphinx==7.0.1",
    "sphinxcontrib-plantuml==0.25",
    "pip-tools==6.13.0"
]
test = [
    # Testing tools to test this project
    "pytest==7.2.0",
    "tox==4.0.8",
    "behave==1.2.6"
]</pre>
</div>
</div>
<p>The <code>dependencies</code> line lists the dependencies required to execute the application. Some projects — like this one — rely on the standard library, and nothing more needs to be added. The <code>[project.optional-dependencies]</code> section contains two lists of additional packages: those required for development, and those required for testing.</p>
<p>Note that we’ve put specific version numbers in this file so that we can be absolutely certain what packages will be used. As these packages evolve, we’ll need to test newer versions and upgrade the dependencies.</p>
<p>If you see the version numbers in this book are behind the current state of the art on PyPI or Conda-Forge, feel free to use up-to-date versions.</p>
<p>It helps to use the <strong>pip-compile </strong>command. This is installed as part of <strong>pip-tools</strong>. This command create extract files from the <code>pyproject.toml</code> file for use by <strong>pip</strong> or <strong>conda</strong>.</p>
<p>For developers, we often want to install all of the ”extras.” This usually means executing the following command to create a <code>requirements-dev.txt</code> file that can be used to build a development environment.</p>
<div><div><pre class="console">% pip-compile --all-extras -o requirements-dev.txt</pre>
</div>
</div>
<p>In order to run the <strong>tox </strong>tool, it’s common to also create a testing-only subset of the required packages and tools. Use the following command:</p>
<div><div><pre class="console">% pip-compile --extra test -o requirements.txt</pre>
</div>
</div>
<p>This creates the <code>requirements.txt</code> to be used to detect manage virtual environments used by <strong>tox </strong>for testing.</p>


<h4 class="likesubsubsectionHead" data-number="5.5.3.2">The docs directory</h4>
<p>As noted above in <a href="#x1-200002"><em>Suggested project sprints</em></a> this directory should be built with <code>sphinx-quickstart</code>. After the initial set of files is created, make the following changes:</p>
<ul>
<li><p>Add a <code>api.rst</code> file as a placeholder for the Sphinx-generated API documentation. This will use the <code>..</code><code> </code><code> automodule::</code> directive to extract documentation from your application.</p></li>
<li><p>Add a <code>overview.rst</code> file with an overview of the project.</p></li>
<li><p>Update the <code>index.rst</code> to include these two new files in the table of contents.</p></li>
<li><p>Update the <code>conf.py</code> to append the <code>src</code> directory to <code>sys.path</code>. Also, the <code>sphinx.ext.autodoc</code> extension needs to be added to the <code>extensions</code> setting in this file.</p></li>
</ul>
<p>The <code>make</code><code> html</code> command in the <code>docs</code> directory can be used to build the documentation.</p>


<h4 class="likesubsubsectionHead" data-number="5.5.3.3">The tests/features/hello_world.feature file</h4>
<p>The <code>features</code> directory will have Gherkin-language definitions of the features. Each feature file will contain one or more scenarios. For larger projects, these files often start with statements lifted from problem descriptions or architectural overviews that are later refined into more detailed steps to describe an application’s behavior.</p>
<p>For this project, one of the feature files should be <code>features/hello_world.feature</code>. The contents of this file should include a description of the feature and at least one scenario. It would look like the following example:</p>
<div><div><pre class="source-code">Feature: The Cheerful Greeting CLI interface provides a greeting
    to a specific name.

Scenario: When requested, the application writes the greeting message.
  When we run command "python src/hello_world.py"
  Then output has "Hello, World!"</pre>
</div>
</div>
<p>There’s no <code>Given</code> step in this scenario; there’s no initialization or preparation required. Each of the steps has only a single clause, so there are no <code>And</code> steps, either.</p>
<div><div><p>This example doesn’t precisely match the example in the description. There are two possible reasons for this: one of the two examples is wrong, or, more charitably, this example hints at a second feature.</p>
<p>The idea implied by this example is there’s a default behavior when no <code>--who</code> command-line option is provided. This suggests that a second scenario — one with the <code>--who</code> option should be added for this feature.</p>
</div>
</div>


<h4 class="likesubsubsectionHead" data-number="5.5.3.4">The tests/steps/hw_cli.py module</h4>
<p>The <code>steps</code> directory contains modules that define the natural-language phrases in the feature files. In the <code>hello_world.feature</code> file the <code>When</code> and <code>Then</code> steps had phrases written out in plain English:</p>
<ul>
<li><p>We run the command ”<code>python</code><code> src/hello_world.py</code>”</p></li>
<li><p>Output has ”<code>Hello,</code><code> World!</code>”</p></li>
</ul>
<p>The <code>steps/hw_cli.py</code> module will map the step’s phrases to Python functions. It works by using decorators and pattern-matching to specify the type of step (<code>@given</code>, <code>@when</code>, or <code>@then</code>) and the text to match. The presence of <code>{parameter}</code> in the text will match the text and provide the value matched to the step function as an argument. The function names are irrelevant and are often <code>step_impl()</code>.</p>
<p>Generally, the <code>@given</code> steps will accumulate parameter values in the test context object. Best practices suggest there should be only one <code>@when</code> step; this will perform the required operation. For this project, it will run the application and gather the output files. The <code>@then</code> steps can use <code>assert</code> statements to compare actual results against the expected results shown in the feature file.</p>
<p>Here’s how the <code>steps/hw_cli.py</code> module might look:</p>
<div><div><pre class="source-code">import subprocess
import shlex
from pathlib import Path

@when(u’we run command "{command}"’)
def step_impl(context, command):
    output_path = Path("output.log")
    with output_path.open(’w’) as target:
        status = subprocess.run(
            shlex.split(command),
            check=True, text=True, stdout=target, stderr=subprocess.STDOUT)
    context.status = status
    context.output = output_path.read_text()
    output_path.unlink()

@then(u’output has "{expected_output}"’)
def step_impl(context, expected_output):
    assert context.status.returncode == 0
    assert expected_output in context.output</pre>
</div>
</div>
<p>This assumes a relatively small output file that can be collected in memory. For a larger file, it would make sense for the <code>@when</code> step to create a temporary file and save the file object in the context. The <code>@then</code> step can read and close this file. The <code>tempfile</code> module is handy for creating files that will be deleted when closed.</p>
<p>An alternative is to create a <code>Path</code> object and save this object in the context. The <code>@when</code> step can write output to this path. The <code>@then</code> step can read and examine the contents of the file named by the <code>Path</code> object.</p>
<p>When a test step detects a problem with an <code>assert</code> statement, it may not finish completely. The approach of using a <code>Path</code> object requires some care to be sure the temporary files are deleted. The <code>environment.py</code> module can define an <code>after_scenario(context,</code><code> scenario)</code> function to remove temporary files.</p>


<h4 class="likesubsubsectionHead" data-number="5.5.3.5">The tests/environment.py file</h4>
<p>This module will contain some function definitions used by <strong>behave</strong>. For this project, it will be empty. The module must be present; a module docstring is appropriate to explain that it’s empty.</p>
<p>The <code>tests/steps</code> module for this example will have examples that can be refactored into two potentially reusable functions for executing an application and checking the output from an application for specific text. This additional design effort isn’t part of this project. You may find it helpful to do this refactoring after completing several of these projects.</p>
<p>Once the features, steps, and environment are in place, the <strong>behave </strong>program can be used to test the application. If there’s no application module, the tests will fail. Creating a skeleton application module in the <code>src</code> directory will allow the test case to execute and fail because the output isn’t what was expected.</p>


<h4 class="likesubsubsectionHead" data-number="5.5.3.6">The tests/test_hw.py unit tests</h4>
<p>A unit test can be implemented as a <strong>pytest </strong>function that uses a fixture, <code>capsys</code>, to capture the system output. The unit test case expects the application to have a <code>main()</code> function that parses the command-line options.</p>
<p>Here’s one suggested unit test function:</p>
<div><div><pre class="source-code">import hello_world

def test_hw(capsys):
        hello_world.main([])
        out, err = capsys.readouterr()
        assert "Hello, World!" in out</pre>
</div>
</div>
<p>Note the test for the <code>main()</code> function provides an explicit empty list of argument values. It is essential to override any value for <code>sys.argv</code> that might be present when <strong>pytest </strong>is running.</p>
<p>The <code>hello_world</code> module is imported by this test. There are two important consequences of this import:</p>
<ul>
<li><p>The <code>src/hello_world.py</code> module must have an <code>if</code><code> __name__</code><code> ==</code><code> "__main__":</code> section. A simple Python script (without this section) will execute completely when imported. This can make testing difficult.</p></li>
<li><p>The <code>src</code> directory must be part of the <code>PYTHONPATH</code> environment variable. This is handled by the <code>tox.ini</code> file.</p></li>
</ul>
<p>This test will tolerate additional output in addition to the required cheerful greeting. It might make sense to use something like <code>"Hello,</code><code> World!"</code><code> ==</code><code> out.strip()</code>.</p>
<p>The implementation details of the <code>main()</code> function are opaque to this test. This <code>main()</code> function could create an instance of a class; it could use a static method of a class, also.</p>


<h4 class="likesubsubsectionHead" data-number="5.5.3.7">The src/tox.ini file</h4>
<p>Now that the tests exist, we can run them. The <strong>tox </strong>(and <strong>nox</strong>) tools are ideal for running a suite of tests.</p>
<p>Here’s an example <code>tox.ini</code> file:</p>
<div><div><pre class="source-code">[tox]
min_version = 4.0
skipsdist = true

[testenv]
deps = pip-tools
    pytest
    behave
commands_pre = pip-sync requirements.txt
setenv =
    PYTHONPATH=src
commands =
    pytest tests
    behave tests</pre>
</div>
</div>
<p>This file lists the tools used for testing: <strong>pip-tools</strong>, <strong>pytest</strong>, and <strong>behave</strong>. It provides the setting for the <code>PYTHONPATH</code>. The <code>commands_pre</code> will prepare the the virtual environment using the <strong>pip-sync </strong>command that is part of the <strong>pip-tools </strong>package. The given sequence of commands defines the test suite.</p>


<h4 class="likesubsubsectionHead" data-number="5.5.3.8">The src/hello_world.py file</h4>
<p>This is the desired application module. The test framework is helpful to confirm that it really does work, and — more importantly — it meets the definition of done provided in the <code>*.feature</code> files.</p>
<p>As we noted above, the unit tests will import this app as a module. The acceptance test, in contrast, will run the app. This means the <code>if</code><code> __name__</code><code> ==</code><code> "__main__":</code> section is essential.</p>
<p>For a small application like this, the real work of the application should be encapsulated in a <code>main()</code> function. This allows the main module to end with the following snippet:</p>
<div><div><pre class="source-code">if __name__ == "__main__":
    main()</pre>
</div>
</div>
<p>This assures that the module will not take off and start running when imported. It will only do useful work when invoked from the command line. </p>



<h3 data-number="5.5.4">1.5.4  Definition of done</h3>
<p>This project is tested by running the <code>tox</code> command.</p>
<p>When all of the tests execute, the output will look like this:</p>
<pre class="console">(projectbook) slott@MacBookPro-SLott project_0 % tox
py: commands[0]&gt; pytest tests
...
py: commands[1]&gt; behave tests
...
py: OK (0.96=setup[0.13]+cmd[0.53,0.30] seconds)
congratulations :) (1.55 seconds)</pre>
<p>This output has elided the details from <strong>pytest </strong>and <strong>behave</strong>. The output from the <strong>tox </strong>tool is the important summary <code>py:</code><code> OK</code>. This tells us all the tests passed.</p>
<p>Once this is complete, we can run the following to create the API documentation:</p>
<div><div><pre class="console">% (cd docs; make html)</pre>
</div>
</div>
<p>It can help to wrap the two commands with <code>()</code> so the <code>cd</code><code> docs</code> command doesn’t leave the console session in the <code>docs</code> directory. Some developers prefer to have two windows open: one in the top-level directory to run the <strong>tox </strong>tool and one in the <code>docs</code> subdirectory to run the <strong>make </strong>commands for the <strong>sphinx</strong> tool. </p>



<h2 data-number="5.6">1.6  Summary</h2>
<p>In this chapter, we’ve looked at the following topics:</p>
<ul>
<li><p>An overview of the software quality principles that we’ll try to emphasize.</p></li>
<li><p>A suggested approach to completing the project as a sequence of project sprints.</p></li>
<li><p>A general overview of the list of deliverables for each project.</p></li>
<li><p>The tools suggested for creating these examples.</p></li>
<li><p>A sample project to act as a template for subsequent projects.</p></li>
</ul>
<p>After creating this initial project, the next chapter will look at the general collection of projects. The idea is to create a complete data analysis tool set with a number of closely-related projects. </p>


<h2 data-number="5.7">1.7  Extras</h2>
<p>Here are some ideas for you to add to this project. </p>

<h3 data-number="5.7.1">1.7.1  Static analysis - mypy, flake8</h3>
<p>There are several common static analysis tools that are as essential as automated testing:</p>
<ul>
<li><p><strong>mypy </strong>checks type annotations to be sure the functions and classes will interact properly.</p></li>
<li><p><strong>flake8 </strong>does other syntax checks to make sure the code avoids some of the more common Python mistakes.</p></li>
<li><p><strong>black </strong>can be used to check the formatting to make sure it follows the recommended style. The <code>black</code> application can also be used to reformat a new file.</p></li>
<li><p><strong>isort </strong>can be used to put a long collection of <code>import</code> statements into a consistent order.</p></li>
</ul>
<p>Once the application passes the functional tests in the <code>*.feature</code> files, these additional non-functional tests can be applied. These additional tests are often helpful for spotting more nuanced problems that can make a program difficult to adapt or maintain. </p>


<h3 data-number="5.7.2">1.7.2  CLI features</h3>
<p>The command-language interface permits a single option, the <code>--who</code> option, to provide a name.</p>
<p>It makes sense to add a scenario to exercise this option.</p>
<p>What should happen with the <code>--who</code> is provided without a value? Is the following appropriate?</p>
<pre class="console">(projectbook) slott@MacBookPro-SLott project_0 % python src/hello_world.py
  --who

usage: hello_world.py [-h] [--who WHO]
hello_world.py: error: argument --who/-w: expected one argument</pre>
<p>Should the help be extended to clarify what’s required?</p>
<p>Consider adding the following scenarios (and the implementing code):</p>
<ul>
<li><p>Add a scenario for the <code>--help</code> option, which is provided automatically by the <code>argparse</code> module.</p></li>
<li><p>Add a scenario for the <code>--who</code> with no value error.</p></li>
</ul>
<p></p>


<h3 data-number="5.7.3">1.7.3  Logging</h3>
<p>Consider a more complex application where additional debugging output might be helpful. For this, it’s common to add a <code>--verbose</code> option to set the logging level to <code>logging.DEBUG</code> instead of a default level of <code>logging.INFO</code>.</p>
<p>Adding this option requires adding logging capabilities. Consider making the following changes to this module:</p>
<ul>
<li><p>Import the <code>logging</code> module and create a global logger for the application.</p></li>
<li><p>Update the <code>main()</code> function to set the logger’s level based on the options.</p></li>
<li><p>Update the <code>__name__</code><code> ==</code><code> "__main__":</code> block to have two lines: <code>logging.basicConfig()</code> and <code>main()</code>. It’s best to keep logging configuration isolated from the rest of the application processing.</p></li>
</ul>
<p></p>


<h3 data-number="5.7.4">1.7.4  Cookiecutter</h3>
<p>The <code>cookiecutter</code> project (see <a class="url" href="https://cookiecutter.readthedocs.io/en/stable/">https://cookiecutter.readthedocs.io/en/stable/</a>) is a way to build a template project. This can help team members get started by sharing a single template. As tool versions or solution architectures change, additional cookie-cutter templates can be developed and used.</p>
<p>There are thousands of cookie-cutter templates available. It can be difficult to locate one that’s suitably simple. It may be better to create your own and add to it as new concepts are introduced in later chapters.</p>
<p></p>



</body>
</html>
