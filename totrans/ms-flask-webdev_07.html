<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Using NoSQL with Flask</h1>
                </header>
            
            <article>
                
<p>A <strong>NoSQL</strong> (short for <strong>Not Only SQL</strong>) database is any non-relational data store. It usually focuses on speed and scalability. NoSQL has been taking the web development world by storm for the past seven years. Huge companies, such as Netflix and Google, have announced that they are moving many of their services to NoSQL databases, and many smaller companies have followed their example.</p>
<p>This chapter will deviate from the rest of the book in that it will not mostly focus on Flask. The focus on the database design might seem odd in a book about Flask, but choosing the correct database for your application is arguably the most important decision that you can make while designing your technology stack. In the vast majority of web applications, the database is the bottleneck, so the database you pick will determine the overall speed of your app. A study conducted by Amazon showed that even a 100 ms delay caused a one percent reduction in sales, so speed should always be one of the main concerns of a web developer. There is also an abundance of horror stories in the programmer community of web developers involving developers choosing a popular NoSQL database and then not really understanding what the database requires in terms of administration. This leads to large amounts of data loss and crashes, which in turn means the loss of customers. All in all, it's no exaggeration to say that your choice of database for your application can be the difference between your app succeeding and failing.</p>
<p>In this chapter, we will illustrate the strengths and weaknesses of NoSQL databases by examining each type of NoSQL database and the differences between NoSQL and traditional databases.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Types of NoSQL database</h1>
                </header>
            
            <article>
                
<p>NoSQL is a blanket term used to describe nontraditional methods of storing data in a database. The vast majority of NoSQL databases are not relational—unlike RDBMS—which means that they normally cannot perform operations such as <kbd>JOIN</kbd>. There are a number of other features that distinguish an SQL database from a NoSQL database. With a NoSQL database, we have the ability to not impose a fixed schema—for example, a collection on MongoDB can hold different fields, and so they can accept any kind of document. With NoSQL you can (and should) take advantage of denormalization, making a tradeoff between storage and speed.</p>
<p>Modern NoSQL databases include key-value stores, document stores, column family stores, and graph databases.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Key-value stores</h1>
                </header>
            
            <article>
                
<p>A <strong>key-value</strong> NoSQL database acts much like a dictionary in Python. A single value is associated with one key and is accessed via that key. Also, like a Python dictionary, most key-value databases have the same read speed regardless of how many entries there are. Advanced programmers would know this as <strong>O(1) reads</strong>. In some key-value stores, only one key can be retrieved at a time, rather than multiple rows in traditional SQL databases. In most key-value stores, the content of the value is not queryable, but the keys are. Values are just binary blobs: they can be literally anything, from a string to a movie file. However, some key-value stores give default types, such as strings, lists, sets, and dictionaries, while still giving the option of adding binary data.</p>
<p>Because of their simplicity, key-value stores are typically very fast. However, their simplicity makes them unsuitable as the main database for most applications. As such, most key-value store use cases involve storing simple objects that need to expire after a certain amount of time. Two common examples of this pattern are storing users' session data and shopping cart data. Also, key-value stores are commonly used as caches for the application or for other databases. For example, results from a commonly run, or CPU-intensive, query or function are stored with the query or function name as a key. The application will check the cache in the key-value store before running the query on the database, thereby decreasing page load times and stress on the database. An example of this functionality will be shown in <a href="657deeac-378d-4d68-8f93-bb2512fe7ad8.xhtml"><span class="ChapterrefPACKT">Chapter 10</span></a>, <em>Useful Flask Extensions</em>.</p>
<p>The most popular key–value stores are <strong>Redis</strong>, <strong>Riak</strong>, and <strong>Amazon DynamoDB</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Document stores</h1>
                </header>
            
            <article>
                
<p><strong>Document store</strong> is one of the most popular NoSQL database types, and is typically used to replace RDBMSes. Databases store data in collections of key-value pairs called documents. These documents are schemaless, meaning that no document follows the structure of any other document. Also, extra keys may be appended to each document after its creation. Document stores can store data in <strong>JSON</strong>, BSON, and XML. For example, the following are two different post objects stored in JSON:</p>
<pre>{ 
  "title": "First Post", 
  "text": "Lorem ipsum...", 
  "date": "2015-01-20", 
  "user_id": 45 
},
{ 
  "title": "Second Post", 
  "text": "Lorem ipsum...", 
  "date": "2015-01-20", 
  "user_id": 45, 
  "comments": [ 
    { 
      "name": "Anonymous", 
      "text": "I love this post." 
    } 
  ] 
} </pre>
<p>Note that the first document has no comments array. As stated before, documents are schemaless, so this format is perfectly valid. The lack of a schema also means that there are no type checks at the database level. There is nothing in the database to stop an integer from being entered into the title field of a post. Schemaless data is the most powerful feature of document stores and attracts many developers to adopt it for their apps. However, it can also be considered very dangerous, as there is one less check to stop faulty or malformed data from getting into your database.</p>
<p>Some document stores collect similar objects into collections of documents to make querying objects easier. However, in some document stores, all objects are queried at once. Document stores store the metadata of each object, which allows all of the values in each document to be queried and return matching documents.</p>
<p>The most popular document stores are <strong>MongoDB</strong>, <strong>CouchDB</strong>, and <strong>Couchbase</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Column family stores</h1>
                </header>
            
            <article>
                
<p><strong>Column family stores</strong>, also known as <strong>wide column stores</strong>, have many things in common with both key-value stores and document stores. Column family stores are the fastest type of NoSQL database because they are designed for large applications. Their main advantage is their ability to handle terabytes of data and still have very fast read and write speeds by distributing the data across several servers in an intelligent way.</p>
<p>Column family stores are also the hardest to understand, due in part to the vernacular of column family stores, as they use many of the same terms as RDBMSes, but with wildly different meanings. In order to <span>clearly </span><span>understand what a column family store is, let's jump straight into an example. Let's create a simple</span> <em>user-to-posts</em> <span>association in a typical column family store.</span></p>
<p>First, we need a user table. In column family stores, data is stored and accessed via a unique key, such as a key-value store, but the content consists of unstructured columns, such as a document store. Consider the following user table:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Key</strong></p>
</td>
<td>
<p><kbd>Jack</kbd></p>
</td>
<td>
<p> </p>
</td>
<td>
<p> </p>
</td>
<td>
<p><kbd>John</kbd></p>
</td>
<td>
<p> </p>
</td>
</tr>
<tr>
<td>
<p><strong>Column</strong></p>
</td>
<td>
<p><kbd>Full Name</kbd></p>
</td>
<td>
<p><kbd>Bio</kbd></p>
</td>
<td>
<p><kbd>Location</kbd></p>
</td>
<td>
<p><kbd>Full Name</kbd></p>
</td>
<td>
<p><kbd>Bio</kbd></p>
</td>
</tr>
<tr>
<td>
<p><strong>Value</strong></p>
</td>
<td>
<p><kbd>Jack Stouffer</kbd></p>
</td>
<td>
<p><kbd>This is my about me</kbd></p>
</td>
<td>
<p><kbd>Michigan, USA</kbd></p>
</td>
<td>
<p><kbd>John Doe</kbd></p>
</td>
<td>
<p><kbd>This is my about me</kbd></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Note that each key holds columns, which are key-value pairs as well. Also, it is not necessary for each key to have the same number or type of columns. Each key can store hundreds of unique columns, or they can all have the same number of columns to make application development easier. This is in contrast to key-value stores, which can hold any type of data with each key. This is also slightly different than document stores, which can store types, such as arrays and dictionaries, in each document. Now let's create our posts table:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Key</strong></p>
</td>
<td>
<p><kbd>Post/1</kbd></p>
</td>
<td>
<p> </p>
</td>
<td>
<p> </p>
</td>
<td>
<p><kbd>Post/2</kbd></p>
</td>
<td>
<p> </p>
</td>
<td>
<p> </p>
</td>
</tr>
<tr>
<td>
<p><strong>Column</strong></p>
</td>
<td>
<p><kbd>Title</kbd></p>
</td>
<td>
<p><kbd>Date</kbd></p>
</td>
<td>
<p><kbd>Text</kbd></p>
</td>
<td>
<p><kbd>Title</kbd></p>
</td>
<td>
<p><kbd>Date</kbd></p>
</td>
<td>
<p><kbd>Text</kbd></p>
</td>
</tr>
<tr>
<td>
<p><strong>Value</strong></p>
</td>
<td>
<p><kbd>Hello World</kbd></p>
</td>
<td>
<p><kbd>2015-01-01</kbd></p>
</td>
<td>
<p><kbd>Post text...</kbd></p>
</td>
<td>
<p><kbd>Still Here</kbd></p>
</td>
<td>
<p><kbd>2015-02-01</kbd></p>
</td>
<td>
<p><kbd>Post text...</kbd></p>
</td>
</tr>
</tbody>
</table>
<p class="mce-root"/>
<p class="mce-root"/>
<p>There are several things to understand about column family stores before we continue. Firstly, in column family stores, data can only be selected via a single key or key range; there is no way to query the contents of the columns. To get around this, many programmers use an external search tool with their database—such as <strong>Elasticsearch</strong>—that stores the contents of columns in a searchable format (Lucene's inverted indexes) and returns matching keys to be queried on the database. This limitation is why proper <em>schema</em> design is so crucial in column family stores, and must be carefully thought through before storing any data.</p>
<p>Secondly, data cannot be ordered by the content of the columns. Data can only be ordered by key, which is why the keys to the posts are integers. This allows the posts to be returned in the order in which they were entered. This is not a requirement for the user table because there is no need to sequentially order users.</p>
<p>Thirdly, there are no <kbd>JOIN</kbd> operators, and we cannot query for a column that would hold a user key. With our current schema, there is no way to associate a post with a user. To create this functionality, we need a third table that holds the user to post associations, as follows:</p>
<div class="CDPAlignCenter CDPAlign">
<table style="border-collapse: collapse;width: 100%" class="table" border="1">
<tbody>
<tr>
<td style="width: 159.1px">
<p><strong>Key</strong></p>
</td>
<td style="width: 108.117px">
<p><kbd>Jack</kbd></p>
</td>
<td/>
<td/>
</tr>
<tr>
<td style="width: 159.1px">
<p><strong>Column</strong></p>
</td>
<td style="width: 108.117px">
<p><kbd>Posts</kbd></p>
</td>
<td style="width: 147.567px">
<p><kbd>Posts/1</kbd></p>
</td>
<td style="width: 128.217px">
<p><kbd>Post/1</kbd></p>
</td>
</tr>
<tr>
<td style="width: 159.1px">
<p><strong>Value</strong></p>
</td>
<td style="width: 108.117px"/>
<td style="width: 147.567px">
<p><kbd>Posts/2</kbd></p>
</td>
<td style="width: 128.217px">
<p><kbd>Post/2</kbd></p>
</td>
</tr>
</tbody>
</table>
</div>
<p>This is slightly different from the other tables we have seen so far. The <kbd>Posts</kbd> column is named a <strong>super column</strong>, which is a column that holds other columns. In this table, a super column is associated with our user key, which is holding an association of the position of a post to one post. Clever readers might ask why we wouldn't just store this association in our <kbd>user</kbd> table, much like how the problem would be solved in document stores. This is because regular columns and super columns cannot be held in the same table. You must choose one at the creation of each table.</p>
<p>To get a list of all the posts by a user, we would first have to query the post association table with our user key, use the returned list of associations to get all of the keys in the posts' table, and query the post table with the keys.</p>
<p>If that query seems like a roundabout process to you, that's because it is, and it is made that way by design. The limiting nature of a column family store is what allows it to be so fast and handle so much data. Removing features such as searching by value and column name gives column family stores the ability to handle hundreds of terabytes of data. It's not an exaggeration to say that SQLite is a more complex database for the programmer than a typical column family store.</p>
<p class="mce-root"/>
<p>For this reason, most Flask developers should steer clear of column family stores as they add complexity to applications that isn't necessary. Unless your application is going to handle millions of reads and writes a second, using a column family store is like pounding in a nail with an atomic bomb.</p>
<p>The most popular column family stores are <strong>BigTable</strong>, <strong>Cassandra</strong>, and <strong>HBase</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Graph databases</h1>
                </header>
            
            <article>
                
<p>Designed to describe and then query relationships, <strong>graph databases</strong> are like document stores, but have mechanisms to create and describe links between two nodes.</p>
<p>A <strong>node</strong> is like an instance of an object, usually a collection of key-value pairs or a JSON document. Nodes can be given labels to mark them as part of a category—for example, a user or a group. After your nodes have been defined, an arbitrary number of one-way relationships between the nodes, named <strong>links</strong>, can be created with their own attributes. For example, if our data had two user nodes and each of the two users knew each other, we would define two <kbd>knows</kbd> links between them to describe that relationship, as shown in the following diagram. This would allow you to query all the people that know one user or all the people that a user knows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-534 image-border" src="assets/511f648d-f81b-41e3-8666-0229727d66e1.png" style="width:36.75em;height:26.00em;"/></div>
<p class="mce-root"/>
<p>Graph stores also allow you to query by the link's attributes. This allows you to easily create otherwise complex queries, such as a search for all of the users that one user marked as known in October 2001. Graph stores can follow links from node to node to create even more complex queries. If this example dataset had more groups, we can query for groups that people we know have joined but that we haven't joined. Otherwise, we can query for people who are in the same groups as a user, but who the user doesn't know. Queries in a graph store can also follow a large number of links to answer complex questions, such as "which restaurants <span>in New York </span><span>t</span><span>hat serve burgers</span><span> and have a three-star rating or higher have my friends liked?"</span></p>
<p>The most common use case for a graph database is to build a recommendation engine. For example, say that we had a graph store that is filled with our friend data from a social networking site. Using this data, we could build a mutual friend finder by querying for users that have been marked <span>as friends </span><span>by more than two of our friends.</span></p>
<p>It is very rare for a graph database to be used as the primary data store of an application. Most uses of graph stores have each node acting as a representation of a piece of data in their main database by storing its unique identifier and a small amount of other identifying information.</p>
<p>The most popular graph stores are <strong>Neo4j</strong> and <strong>InfoGrid</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RDBMS versus NoSQL</h1>
                </header>
            
            <article>
                
<p>NoSQL is a tool, and like any tool there are specific use cases where it excels and there are use cases where some other tool would be a better fit. No one would use a screwdriver to pound in a nail; it's possible, but using a hammer would make the job easier. One large problem with NoSQL databases is that people adopt them when an RDBMS would solve the problem just as well, or better.</p>
<p>To understand which tool should be used when, we must understand the strengths and weaknesses of both systems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The strengths of RDBMS databases</h1>
                </header>
            
            <article>
                
<p>One of the biggest strengths of RDBMSes is their maturity. The technology behind RDBMSes has existed for over 40 years and is based on the solid theory of relational algebra and relational calculus. Because of their maturity, they have a long, proven track record across many different industries of handling data in a safe and secure way.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data integrity</h1>
                </header>
            
            <article>
                
<p>Integrity is also one of the biggest selling points of RDBMSes. RDBMSes have several methods in place to ensure that the data entered into a database will not only be correct, but that data loss will be practically nonexistent. These methods combine to form what is known as <strong>ACID</strong> (short for <strong>atomicity</strong>, <strong>consistency</strong>, <strong>isolation</strong>, and <strong>durability</strong>). ACID is a set of rules for transactions that guarantee that the transaction is handled safely.</p>
<p>The principle of atomicity requires that each transaction is all or nothing. If one part of the transaction fails, the entire transaction fails. This is much like the following quote from <em>The Zen of Python</em>:</p>
<div class="packt_quote">"Errors should never pass silently. Unless explicitly silenced."</div>
<p>If there is a problem with the data that has been changed or entered, the transaction should not keep operating because the proceeding operations most likely require that the previous operations were successful.</p>
<p>The principle of consistency requires that any data that the transaction modifies or adds follows the rules of each table. Such rules include type checks, user-defined constraints—such as <em>foreign keys—</em>cascade rules, and triggers. If any of the rules are broken, then according to the atomicity rule, the transaction will be thrown out.</p>
<p>The principle of isolation requires that if the database runs transactions concurrently to speed up writes, then the outcome of the transactions would be the same as if they were run serially. This is mostly a rule for database programmers, and is not something that web developers need to worry about.</p>
<p>Finally, the principle of durability requires that once a transaction is accepted, the data must never be lost, barring a hard drive failure after the transaction is accepted. If the database crashes or loses power, then the durability principle requires that any data written before the problem occurred should still be present when the server is backed up. This essentially means that all transactions must be written to the disk once they are accepted.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Speed and scale</h1>
                </header>
            
            <article>
                
<p>A common misconception is that the ACID principle makes RDBMSes <span>slow </span><span>and</span><span> </span><span>unable to scale. This is only half true—it is completely possible for an RDBMS to scale. For example, an Oracle database configured by a professional database administrator can handle tens of thousands of complex queries a second. Huge companies, such as Facebook, Twitter, Tumblr, and Yahoo!, are using MySQL to great effect, and PostgreSQL is emerging as a favorite of many programmers because of its speed advantage over MySQL.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tools</h1>
                </header>
            
            <article>
                
<p>When evaluating a programming language, the strongest points for or against adopting it are the size and activity of its community. A larger and more active community means more help if you get stuck and more open source tools available for you to use in your projects.</p>
<p>It's no different with databases. RDBMSes, such as MySQL and PostgreSQL, have official libraries for almost every language that is used in commercial environments and unofficial libraries for everything else. Tools, such as Excel, can easily download the latest data from one of these databases and allow the user to treat it like it was any other dataset. Several free desktop GUIs exist for each database, and some are officially supported by the databases' corporate sponsor.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The strengths of NoSQL databases</h1>
                </header>
            
            <article>
                
<p>The main reason that many people use NoSQL databases is its s<span>peed advantage</span><span> over traditional databases. Out of the box, many NoSQL databases can outperform RDBMSes. However, a well-tuned and properly scaled SQL database </span><span>with read slaves</span><span> can outperform NoSQL databases. Many NoSQL databases, especially document stores, sacrifice consistency for availability. This means that they can handle many concurrent reads and writes, but those writes may be in conflict with one another. Yet, this is not straightforward, as you will soon see when we look at the CAP theorem</span><span>.</span></p>
<p>The second feature that pulls people to NoSQL is its ability to handle unformatted data. Storing data in XML or JSON allows an arbitrary structure to each document. Applications that store user-designed data have benefited greatly from the adoption of NoSQL. For example, a video game that allows players to submit their custom levels to some central repository can now store the data in a queryable format rather than in a binary blob.</p>
<p>The third feature that draws people to NoSQL is the ease of creating a cluster of databases working in tandem. Not having <kbd>JOIN</kbd> operators or only accessing values via keys makes splitting the data across servers a rather trivial task when compared with RDBMSes. This is due to the fact that <kbd>JOIN</kbd> operators require a scan of the entire table, even if it is split across many different servers. The <kbd>JOIN</kbd> operators become even slower when documents or keys can be assigned to a server by an algorithm as simple as the starting character of its unique identifier—for example, everything that starts with the letters A–H is sent to server 1, I–P to server 2, and Q–Z to server 3. This makes looking up the location of data for a connected client very fast.</p>
<p>Next, we will briefly explain the CAP theorem, to give you some background on the underlying problems behind database-distributed systems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CAP theorem</h1>
                </header>
            
            <article>
                
<p>The <strong>CAP</strong> theorem stands for <strong>consistency</strong>, <strong>availability</strong>, and <strong>partition</strong> tolerance, and states that it's not possible for a distributed system to guarantee all three, so a trade-off must be made.</p>
<p>The following list shows exactly what each of these guarantees means on a distributed system:</p>
<ul>
<li style="font-weight: 400"><strong>Consistency:</strong> Guarantees that each node on a cluster returns the most recent write and preserves linear consistency</li>
<li style="font-weight: 400"><strong>Availability:</strong> Every non failing node is able to respond to a request with a non error response</li>
<li style="font-weight: 400"><strong>Partition tolerance</strong>: The system continues to operate despite network outages/delays</li>
</ul>
<p>The theorem states that in case of a network partition, a distributed system has to choose between consistency or availability, so <span>in the case of a network partition, </span><span>systems must fall into two main categories, CP and AP.</span></p>
<p>A simple visualization of such a distributed system would be two instances serving many clients concurrently on distinct data centers. One client sends: write the key-value <strong>a:0</strong> to <strong>server1</strong>. Then <strong>server1</strong> sends <strong>a:0</strong> to <strong>server2</strong>, <strong>server2</strong> sends an acknowledgement back to <strong>server1</strong> which then sends an acknowledgement back to the client. This is shown in the following diagram:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-535 image-border" src="assets/82a9d1a9-ded1-4560-890f-1b6db2ad194e.png" style="width:31.75em;height:31.08em;"/></div>
<p>Imagine that a network partition occurs and this prevents <strong>server1</strong> from communicating with <strong>server2</strong>. Meanwhile, <strong>client1</strong> requests that <strong>server1</strong> changes <strong>a:0</strong> to <strong>a:1</strong>. If the system aims for consistency, then it would reject the transaction since it can't send the write to <strong>server2</strong> and <strong>server2</strong> would deny any transactions since it could serve dirty reads, and we are aiming for consistency. This relationship is shown in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-536 image-border" src="assets/73ec2395-8639-44f5-a5ad-12a4174c9508.png" style="width:25.25em;height:27.00em;"/></div>
<p>If we want to aim for availability, we must relax consistency. In today's database RDBMS or NoSQL, systems are not 100% CP or AP, but they can be configured to be more or less relaxed as to their consistency and availability to a certain degree.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Although not 100% correct, MongoDB aims for consistency and partition tolerance. MongoDB in a cluster architecture uses a single-master setup, which means that a single node can accept writes. It avoids a <strong>single point of failure</strong> (<strong><span>SPOF</span></strong>) by having the ability to switch if the majority of the other nodes lose contact with their current master. This increases availability by lowering consistency for the following reasons:</p>
<ul>
<li>If you use a single node, then reads and writes to the same system on MongoDB will make it a very consistent system, but if you use multiple instances for reads with asynchronous replication, then the entire system will eventually become consistent</li>
<li>When the old master node recovers, it will rejoin the cluster as a slave node, and all the dirty writes it might have will be rolled back</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What database to use and when</h1>
                </header>
            
            <article>
                
<p>So, each database has different uses. It was stated at the beginning of the section that the main problem when programmers choose a NoSQL database for their technology stack is that they choose it when an RDBMS would work just as well. This is born out of some common misconceptions. Firstly, people try to use a relational mindset and data model and think that they will work just as well in a NoSQL database. People usually come to this misunderstanding because the marketing on the various websites of NoSQL databases is misleading, and encourages users to drop their current database without considering whether a non-relational model will work for their project.</p>
<p>Secondly, people believe that you must use only one data store for your application. Many applications can benefit from using more than one data store. Take a Facebook clone as an example. It could use MySQL for holding user data, Redis to store session data, a document store to hold the data for the quizzes and surveys that people share with each other, and a graph database to implement a feature for finding friends.</p>
<p>If an application feature needs very fast writes, and write safety is not a primary concern, then you should use a document store database. If you need to store and query schemaless data, then you should use a document store database.</p>
<p>If an application feature needs to store something that deletes itself after a specified time, or if the data does not need to be searched, then you should use a key-value store.</p>
<p>If an application feature involves finding or describing complex relationships between two or more sets of data, then you should use a graph store.</p>
<p class="mce-root"/>
<p>If an application feature needs guaranteed write safety, or if it needs each entry to fit into a specified schema, different sets of data in the database to be compared using <kbd>JOIN</kbd> operators, or constraints on the entered data, then you should use an RDBMS.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MongoDB in Flask</h1>
                </header>
            
            <article>
                
<p>MongoDB is far and away the most popular NoSQL database. MongoDB is also the best-supported NoSQL database for Flask and Python in general. Therefore, our examples will focus on MongoDB.</p>
<p>MongoDB is a document storage NoSQL database. Documents are stored in collections, which allow the grouping of similar documents, but no similarities between documents are necessary to store a document in a collection. Documents are defined in a JSON superset named <strong>BSON</strong> (short for <strong>Binary JSON</strong>). BSON allows JSON to be stored in binary format rather than in string format, saving a lot of space. BSON also distinguishes between several different ways of storing numbers, such as 32-bit integers and doubles.</p>
<p>To understand the basics of MongoDB, we will use <strong>Flask-MongoEngine</strong> to cover the same functionality of Flask-SQLAlchemy in the previous chapters. Remember that these are just examples. There is no benefit of refactoring our current code to use MongoDB because MongoDB cannot offer any new functionality for our use case. New functionality with MongoDB will be shown in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing MongoDB</h1>
                </header>
            
            <article>
                
<p>To install MongoDB, go to <a href="https://www.mongodb.org/downloads"><span class="URLPACKT">https://www.mongodb.org/downloads</span></a> and select your OS from the tabs under the heading <span class="packt_screen">Download MongoDB</span>. Every OS that has a supported version has installation instructions listed next to the download button of the installer.</p>
<p>To run MongoDB, go to Bash and run the following:</p>
<pre class="mce-root"><strong>$ mongod</strong></pre>
<p>This will run a server for as long as the window is open.</p>
<p>Using Docker, you can easily launch a MongoDB server without needing to install anything else on your computer.</p>
<p class="mce-root"/>
<p>To start a MongoDB server on Docker, enter the following:</p>
<pre><strong>$docker run -d -p 27017:27017 mongo:3.2.20-jessie<br/>$docker container list<br/></strong>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES<br/>4c6706af399b mongo:3.2.20-jessie "docker-entrypoint.s…" About a minute ago Up About a minute 0.0.0.0:27017-&gt;27017/tcp silly_ardinghelli<strong><br/></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up MongoEngine</h1>
                </header>
            
            <article>
                
<p> If you're following the example code provided with this book <span>(which you can find at </span><a href="https://github.com/PacktPublishing/Hands-On-Web-Development-with-Flask" target="_blank">https://github.com/PacktPublishing/Hands-On-Web-Development-with-Flask</a><span>), then</span><span> all you need to do is create a new Python virtual environment and install all the necessary dependencies. You will notice the provided</span> <kbd>init.sh</kbd> <span>and</span> <kbd>requirements.txt</kbd><span>. Inside the</span> <kbd>init.sh</kbd><span>, we have all the necessary commands to get us set up, as shown in the following code:</span></p>
<pre><span>if [ </span>! <span>-d </span><span>"venv"</span><span> ]</span>; <span>then<br/></span>    virtualenv venv<br/>fi<br/>source venv/bin/activate<br/>pip install -r requirements.txt</pre>
<p>And, of course, our <strong><kbd>requirements.txt</kbd> </strong>contains the following necessary packages:</p>
<pre>Flask<br/>Flask-MongoEngine</pre>
<p>In the <kbd>__init__.py</kbd> file, a <kbd>mongo</kbd> object will be created that represents our database, as shown in the following code:</p>
<pre>from flask_mongoengine import MongoEngine<br/><br/>mongo = MongoEngine<br/><br/>def create_app(object_name):<br/>...<br/>    mongo.init_app(app)<br/>...</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Before our app will run, our <kbd>DevConfig</kbd> object in <kbd>config.py</kbd> needs to set up the parameters of the <kbd>mongo</kbd> connection:</p>
<pre>MONGODB_SETTINGS = { 
  'db': 'local', 
  'host': 'localhost', 
  'port': 27017 
} </pre>
<p>These are the defaults for a brand new MongoDB installation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining documents</h1>
                </header>
            
            <article>
                
<p>MongoEngine is an ORM that is based around Python's object system, and is specifically designed for MongoDB. Unfortunately, there is no SQLAlchemy-style wrapper that supports all NoSQL drivers. In RDBMSes, the implementations of SQL are so similar that creating a universal interface is possible. However, the underlying implementations of each document store are different enough that the task of creating a similar interface would be more trouble than it is worth.</p>
<p>Each collection in your Mongo database is represented by a class that inherits from <kbd>mongo.Document</kbd>, as shown in the following code:</p>
<pre>class Post(mongo.Document): 
    title = mongo.StringField(required=True) 
    text = mongo.StringField() 
    publish_date = mongo.DateTimeField(default=datetime.datetime.now()) 
   
    def __repr__(self): 
        return "&lt;Post '{}'&gt;".format(self.title) </pre>
<p>Each class variable is a representation of a key belonging to a document, which is represented in this example of a <kbd>Post</kbd> class. The class variable name is used as the key in the document.</p>
<p>Unlike SQLAlchemy, there is no need to define a primary key. A unique ID will be generated for you under the <kbd>id</kbd> attribute. The preceding code would generate a BSON document that would resemble the following:</p>
<pre>{ 
  "_id": "55366ede8b84eb00232da905", 
  "title": "Post 0", 
  "text": "&lt;p&gt;Lorem ipsum dolor...", 
  "publish_date": {"$date": 1425255876037} 
} </pre>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Field types</h1>
                </header>
            
            <article>
                
<p>There are a large number of fields, and each represents a distinct category of data in Mongo. Unlike the underlying database, each field provides a type check before the document is allowed to be saved or altered. The most-used fields are as follows:</p>
<ul>
<li><kbd>BooleanField</kbd></li>
<li><kbd>DateTimeField</kbd></li>
<li><kbd>DictField</kbd></li>
<li><kbd>DynamicField</kbd></li>
<li><kbd>EmbeddedDocumentField</kbd></li>
<li><kbd>FloatField</kbd></li>
<li><kbd>IntField</kbd></li>
<li><kbd>ListField</kbd></li>
<li><kbd>ObjectIdField</kbd></li>
<li><kbd>ReferenceField</kbd></li>
<li><kbd>StringField</kbd></li>
</ul>
<div class="packt_infobox">For a full list of fields and detailed documentation, go to the MongoEngine website at <a href="http://docs.mongoengine.org"><span class="URLPACKT">http://docs.mongoengine.org</span></a>.</div>
<p>The majority of these are named after the Python type they accept and work in the same way as the SQLAlchemy types. However, there are some new types that have no counterpart in SQLAlchemy. Let's take a look at them in detail:</p>
<ul>
<li><kbd>DynamicField</kbd> is a field that can hold any type of value and performs no type checks on values.</li>
<li><kbd>DictField</kbd> can store any Python dictionary that can be serialized by <kbd>json.dumps()</kbd>.</li>
<li><kbd>ReferenceField</kbd> simply stores the unique ID of a document, and when queried, MongoEngine will return the referenced document.</li>
<li><kbd>EmbeddedDocumentField</kbd> stores the passed document in the parent document, so there is no need for a second query.</li>
<li><kbd>ListField</kbd> represents a list of fields of a specific type. This is typically used to store a list of references to other documents or a list of embedded documents to create a one-to-many relationship. If a list of unknown types is needed, then <kbd>DynamicField</kbd> can be used.</li>
</ul>
<p class="mce-root"/>
<p>Each field type takes some common arguments, as shown in the following code:</p>
<pre>Field( 
  primary_key=None 
  db_field=None, 
  required=False, 
  default=None, 
  unique=False, 
  unique_with=None, 
  choices=None 
) </pre>
<ul>
<li>The <kbd>primary_key</kbd> argument specifies that you do not want MongoEngine to autogenerate a unique key, but the value of the field should be used as the ID. The value of this field will now be accessible from both the <kbd>id</kbd> attribute and the name of the field.</li>
<li><kbd>db_field</kbd> defines what the key will be named in each document. If it is not set, it will default to the name of the class variable.</li>
<li>If <kbd>required</kbd> is defined as <kbd>True</kbd>, then that key must be present in the document. Otherwise, the key does not have to exist for documents of that type. When a class is defined, the nonexistent key is queried, and it will return <kbd>None</kbd>.</li>
<li><kbd>default</kbd> specifies the value that this field will be given if no value is defined.</li>
<li>If <kbd>unique</kbd> is set to <kbd>True</kbd>, then MongoEngine checks to make sure that no other documents in the collection will have the same value for this field:
<ul>
<li>When passed a list of field names, <kbd>unique_with</kbd> <span>will make sure that—when taken in combination—the values of all the fields will be unique for each document. This is much like multicolumn</span> <kbd>UNIQUE</kbd> <span>indexes in RDBMSes.</span></li>
</ul>
</li>
</ul>
<ul>
<li>Finally, when given a list, the <kbd>choices</kbd> option limits the allowable values for that field to the elements in the list.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Types of documents</h1>
                </header>
            
            <article>
                
<p>MongoEngine's method to define documents allows either flexibility or rigidity on a collection-by-collection basis. Inheriting from <kbd>mongo.Document</kbd> means that only the keys defined in the class can be saved to the database. Those keys defined in the class can be empty, but everything else will be ignored. On the other hand, if your class inherits <kbd>mongo.DynamicDocument</kbd>, then any extra fields that are set will be treated as <kbd>DynamicField</kbd> and will be saved with the document, as follows:</p>
<pre>class Post(mongo.DynamicDocument): 
  title = mongo.StringField(required=True, unique=True) 
  text = mongo.StringField() 
  ... </pre>
<p>To show the  extreme case (which is <span>not recommended)</span><span>, the following class is perfectly valid; it has no required fields and allows any fields to be set:</span></p>
<pre>class Post(mongo.DynamicDocument): 
  pass </pre>
<p>The last type of document is <kbd>EmbeddedDocument</kbd>. A <kbd>EmbeddedDocument</kbd> is simply a document that is passed to <kbd>EmbeddedDocumentField</kbd> and is stored as is in the document, as follows:</p>
<pre>class Comment(mongo.EmbeddedDocument):
    name = mongo.StringField(required=True)
    text = mongo.StringField(required=True)
    date = mongo.DateTimeField(default=datetime.datetime.now())</pre>
<p>Why use <kbd>EmbeddedDocumentField</kbd> over <kbd>DictField</kbd> when they seem to perform the same function? The end result of using each is the same. However, an embedded document defines a structure for the data, while <kbd>DictField</kbd> can be anything. To understand this better, think of it this way: <kbd>Document</kbd> is to <kbd>DynamicDocument</kbd> what <kbd>EmbeddedDocument</kbd> is to <kbd>DictField</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The meta attribute</h1>
                </header>
            
            <article>
                
<p>Using the <kbd>meta</kbd> class variable, many attributes of a document can be manually set. If you are working with an existing set of data and want to connect your classes to the collections, then set the collection key of the <kbd>meta</kbd> dictionary, as follows:</p>
<pre>class Post(mongo.Document): 
  ... 
  meta = {'collection': 'user_posts'} </pre>
<p class="mce-root"/>
<p>You can also manually set the maximum number of documents in the collection and the maximum size of each document. In the following example, there can be only 10,000 documents, and each document can't be larger than 2 MB:</p>
<pre>class Post(mongo.Document): 
  ... 
  meta = { 
    'collection': 'user_posts', 
    'max_documents': 10000, 
    'max_size': 2000000 
  } </pre>
<p>Indexes can also be set through MongoEngine. Indexes can be made single field by using a string or multifield by using a tuple, as follows:</p>
<pre>class Post(mongo.Document): 
  ... 
  meta = { 
    'collection': 'user_posts', 
    'max_documents': 10000, 
    'max_size': 2000000, 
    'indexes': [ 
      'title', 
      ('title', 'user') 
    ] 
  } </pre>
<p>The default ordering of a collection can be set through the <kbd>meta</kbd> variable using the <strong>ordering key</strong>, as shown in the following code. When <kbd>-</kbd> is prepended, it tells MongoEngine to order results in descending order of that field. If <kbd>+</kbd> is prepended, it tells MongoEngine to order results in ascending order of that field. This default behavior is overridden if the <kbd>order_by</kbd> function is specified in a query, which will be shown in the <em>CRUD</em> section:</p>
<pre>class Post(mongo.Document): 
  ... 
  meta = { 
    'collection': 'user_posts', 
    'max_documents': 10000, 
    'max_size': 2000000, 
    'indexes': [ 
      'title', 
      ('title', 'user') 
    ], 
    'ordering': ['-publish_date'] 
  } </pre>
<p class="mce-root"/>
<p>The <kbd>meta</kbd> variable can also enable inheritance from user-defined documents, which is disabled by default. The subclass of the original document will be treated as a member of the parent class and will be stored in the same collection, as follows:</p>
<pre>class Post(mongo.Document): 
  ... 
  meta = {'allow_inheritance': True} 
 
class Announcement(Post): 
  ... </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CRUD</h1>
                </header>
            
            <article>
                
<p>As stated in <a href="42af8825-fb77-4eb9-a010-7d7fc9644f7c.xhtml"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Creating Models with SQLAlchemy</em>, there are four main forms of data manipulation that any data store must implement. They are the creation of new data, the reading of existing data, the updating of existing data, and the deletion of data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Create</h1>
                </header>
            
            <article>
                
<p>To create a new document, just create a new instance of the class and call the <kbd>save</kbd> method, as follows:</p>
<pre><strong>&gt;&gt;&gt; post = Post()</strong>
<strong>&gt;&gt;&gt; post.title = "Post From The Console"</strong>
<strong>&gt;&gt;&gt; post.text = "Lorem Ipsum..."</strong>
<strong>&gt;&gt;&gt; post.save()</strong></pre>
<p>Otherwise, the values can be passed as keywords in the object creation, as follows:</p>
<pre><strong>&gt;&gt;&gt; post = Post(title="Post From Console", text="Lorem Ipsum...")</strong></pre>
<p>Unlike SQLAlchemy, MongoEngine does not automatically save related objects that are stored in <kbd>ReferenceFields</kbd>. To save any changes to referenced documents along with the changes to the current document, pass <kbd>cascade</kbd> as <kbd>True</kbd>, as shown in the following code:</p>
<pre><strong>&gt;&gt;&gt; post.save(cascade=True)</strong></pre>
<p>If you wish to insert a document and skip its checks against the defined parameters in the class definition, then pass <kbd>validate</kbd> as <kbd>False</kbd>, as shown in the following code:</p>
<pre><strong>&gt;&gt;&gt; post.save(validate=False)</strong></pre>
<div class="packt_tip">Remember that these checks exist for a reason. Turn them off only for a very good reason.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Write safety</h1>
                </header>
            
            <article>
                
<p>By default, MongoDB does not wait for the data to be written to disk before acknowledging that the write occurred. This means that it is possible for writes that were acknowledged to have failed, either by hardware failure or some error when the write occurred. To ensure that the data is written to disk before Mongo confirms the write, use the <kbd>write_concern</kbd> keyword. The <kbd>write_concern</kbd> parameter tells Mongo when it should return with an acknowledgement of the write, as shown in the following code:</p>
<pre><strong># will not wait for write and not notify client if there was an error</strong>
<strong>&gt;&gt;&gt; post.save(write_concern={"w": 0})</strong>
<strong># default behavior, will not wait for write</strong>
<strong>&gt;&gt;&gt; post.save(write_concern={"w": 1})</strong>
<strong># will wait for write</strong>
<strong>&gt;&gt;&gt; post.save(write_concern={"w": 1, "j": True})</strong></pre>
<div class="packt_infobox">As stated in the <em>RDBMS versus NoSQL</em> section, it's very important that you understand how the NoSQL database that you are using treats writes. To learn more about MongoDB's write concern, go to <a href="http://docs.mongodb.org/manual/reference/write-concern/"><span class="URLPACKT">http://docs.mongodb.org/manual/reference/write-concern/</span></a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Read</h1>
                </header>
            
            <article>
                
<p><span>The</span><span> </span><kbd>objects</kbd><span> </span><span>attribute is used t</span>o access the documents from the database. To read all of the documents in a collection, use the <kbd>all</kbd> method, as follows:</p>
<pre><strong>&gt;&gt;&gt; Post.objects.all()</strong>
<strong>[&lt;Post: "Post From The Console"&gt;]</strong></pre>
<p>To limit the number of items returned, use the <kbd>limit</kbd> method as follows:</p>
<pre><strong># only return five items</strong>
<strong>&gt;&gt;&gt; Post.objects.limit(5).all()</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This <kbd>limit</kbd> command is slightly different than the SQL version. In SQL, the <kbd>limit</kbd> command can also be used to skip the first results. To replicate this functionality, use the <kbd>skip</kbd> method as follows:</p>
<pre><strong># skip the first 5 items and return items 6-10</strong>
<strong>&gt;&gt;&gt; Post.objects.skip(5).limit(5).all()</strong></pre>
<p>By default, MongoDB returns the results in the order of the time of their creation. To control this, there is the <kbd>order_by</kbd> function, which is used as follows:</p>
<pre><strong># ascending</strong>
<strong>&gt;&gt;&gt; Post.objects.order_by("+publish_date").all()</strong>
<strong># descending</strong>
<strong>&gt;&gt;&gt; Post.objects.order_by("-publish_date").all()</strong></pre>
<p>If you want only the first result from a query, use the <kbd>first</kbd> method. If your query returns nothing, and you expected it to, then use <kbd>first_or_404</kbd> to automatically abort with a <kbd>404</kbd> error. This acts in exactly the same way as its Flask-SQLAlchemy counterpart, and is provided by Flask-MongoEngine, as follows:</p>
<pre><strong>&gt;&gt;&gt; Post.objects.first()
&lt;Post: "Post From The Console"&gt;
&gt;&gt;&gt; Post.objects.first_or_404()
&lt;Post: "Post From The Console"&gt;</strong></pre>
<p>The same behavior is available for the <kbd>get</kbd> method, which expects that the query will only return one result and will raise an exception otherwise, as follows:</p>
<pre><strong># The id value will be different your document</strong>
<strong>&gt;&gt;&gt; Post.objects(id="5534451d8b84ebf422c2e4c8").get()</strong>
<strong>&lt;Post: "Post From The Console"&gt;
&gt;&gt;&gt; Post.objects(id="5534451d8b84ebf422c2e4c8").get_or_404()
&lt;Post: "Post From The Console"&gt;</strong></pre>
<p>The <kbd>paginate</kbd> method is also present and has the exact same API as its Flask-SQLAlchemy counterpart, as follows:</p>
<pre><strong>&gt;&gt;&gt; page = Post.objects.paginate(1, 10)</strong>
<strong>&gt;&gt;&gt; page.items()</strong>
<strong>[&lt;Post: "Post From The Console"&gt;]</strong></pre>
<p>Also, if your document has a <kbd>ListField</kbd> method, then the <kbd>paginate_field</kbd> method on the document object can be used to paginate through the items of the list.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Filtering</h1>
                </header>
            
            <article>
                
<p>If you know the exact value of the field you wish to filter by, then you can pass its value as a keyword to the <kbd>objects</kbd> method, as follows:</p>
<pre><strong>&gt;&gt;&gt; Post.objects(title="Post From The Console").first()</strong>
<strong>&lt;Post: "Post From The Console"&gt;</strong></pre>
<p>Unlike SQLAlchemy, we cannot pass truth tests to filter our results. Instead, special keyword arguments are used to test values. For example, to find all posts published after January 1 2015, enter the following:</p>
<pre><strong>&gt;&gt;&gt; Post.objects(</strong>
    <strong>    publish_date__gt=datetime.datetime(2015, 1, 1)</strong>
<strong>).all()</strong>
<strong>[&lt;Post: "Post From The Console"&gt;]</strong></pre>
<p>The <kbd>__gt</kbd> appended to the end of the keyword is called an operator. MongoEngine supports the following operators:</p>
<ul>
<li><kbd>ne</kbd>: Not equal to</li>
<li><kbd>lt</kbd>: Less than</li>
<li><kbd>lte</kbd>: Less than or equal to</li>
<li><kbd>gt</kbd>: Greater than</li>
<li><kbd>gte</kbd>: Greater than or equal to</li>
<li><kbd>not</kbd>: Negate an operator—for example, <kbd>publish_date__not__gt</kbd></li>
<li><kbd>in</kbd>: Value is in the list</li>
<li><kbd>nin</kbd>: Value is not in the list</li>
<li><kbd>mod</kbd>: Value % a == b—a and b are passed as (a, b)</li>
<li><kbd>all</kbd>: Every item in the provided list of values is in the field</li>
<li><kbd>size</kbd>: The size of the list</li>
<li><kbd>exists</kbd>: Value for the field exists</li>
</ul>
<p>MongoEngine also provides the following operators to test string values:</p>
<ul>
<li><kbd>exact</kbd>: String equals the value</li>
<li><kbd>iexact</kbd>: String equals the value (case-insensitive)</li>
<li><kbd>contains</kbd>: String contains the value</li>
<li><kbd>icontains</kbd>: String contains the value (case-insensitive)</li>
<li><kbd>startswith</kbd>: String starts with the value</li>
<li><kbd>istartswith</kbd>: String starts with the value (case-insensitive)</li>
<li><kbd>endswith</kbd>: String ends with the value</li>
<li><kbd>iendswith</kbd>: String ends with the value (case insensitive) <kbd>Update</kbd></li>
</ul>
<p>These operators can be combined to create the same powerful queries that were created in the previous sections. For example, to find all of the posts that were created after January 1 2015 don't use the word <kbd>post</kbd> in the title. Instead, the body text should start with the word <kbd>Lorem</kbd> and should be ordered by the publish date, starting with the latest one. You can do this using the following code:</p>
<pre><strong>&gt;&gt;&gt; Post.objects(</strong>
    <strong>    title__not__icontains="post",</strong>
    <strong>    text__istartswith="Lorem",</strong>
    <strong>    publish_date__gt=datetime.datetime(2015, 1, 1),</strong>
<strong>).order_by("-publish_date").all()</strong></pre>
<p>However, if there is a complex query that cannot be represented by these tools, then a raw Mongo query can be passed as well, as follows:</p>
<pre><strong>&gt;&gt;&gt; Post.objects(__raw__={"title": "Post From The Console"})</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Update</h1>
                </header>
            
            <article>
                
<p>To update objects, the <kbd>update</kbd> method is called on the results of a query, as follows:</p>
<pre><strong>&gt;&gt;&gt; Post.objects(</strong>
    <strong>    id="5534451d8b84ebf422c2e4c8"</strong>
<strong>).update(text="Ipsum lorem")</strong></pre>
<p>If your query should only return one value, then use <kbd>update_one</kbd> to only modify the first result, as follows:</p>
<pre><strong>&gt;&gt;&gt; Post.objects(</strong>
    <strong>    id="5534451d8b84ebf422c2e4c8"</strong>
<strong>).update_one(text="Ipsum lorem")</strong></pre>
<p>Unlike traditional SQL, there are many different ways to change a value in MongoDB. Operators are used to change the values of a field in the following different ways:</p>
<ul>
<li><kbd>set</kbd>: Sets a value (same as given earlier)</li>
<li><kbd>unset</kbd>: Deletes a value and removes the key</li>
<li><kbd>inc</kbd>: Increments a value</li>
<li><kbd>dec</kbd>: Decrements a value</li>
<li><kbd>push</kbd>: Appends a value to a list</li>
<li><kbd>push_all</kbd>: Appends several values to a list</li>
<li><kbd>pop</kbd>: Removes the first or last element of a list</li>
<li><kbd>pull</kbd>: Removes a value from a list</li>
<li><kbd>pull_all</kbd>: Removes several values from a list</li>
<li><kbd>add_to_set</kbd>: Adds a value to a list only if it's not in the list already</li>
</ul>
<p>For example, if a <kbd>Python</kbd> value needs to be added to a <kbd>ListField</kbd> named tags for all <kbd>Post</kbd> documents that have the <kbd>MongoEngine</kbd> tag, as follows:</p>
<pre><strong>&gt;&gt;&gt; Post.objects(</strong>
    <strong>    tags__in="MongoEngine",</strong>
    <strong>    tags__not__in="Python"</strong>
<strong>).update(push__tags="Python")</strong></pre>
<p>The same write concern parameters to save exist for updates, as shown in the following code:</p>
<pre><strong>&gt;&gt;&gt; Post.objects(</strong>
    <strong>    tags__in="MongoEngine"</strong>
    <strong>  ).update(push__tags="Python", write_concern={"w": 1, "j": True})</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Delete</h1>
                </header>
            
            <article>
                
<p>To delete a document instance, call its <kbd>delete</kbd> method as follows:</p>
<pre><strong>&gt;&gt;&gt; post = Post.objects(</strong>
    <strong>    id="5534451d8b84ebf422c2e4c8"</strong>
<strong>).first()</strong>
<strong>&gt;&gt;&gt; post.delete()</strong>
  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Relationships in NoSQL</h1>
                </header>
            
            <article>
                
<p>Just as we created relationships in SQLAlchemy, we can create relationships between objects in MongoEngine. Only with MongoEngine, we will be doing so without <kbd>JOIN</kbd> operators.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">One-to-many relationships</h1>
                </header>
            
            <article>
                
<p>There are two ways to create a one-to-many relationship in MongoEngine. The first method is to create a relationship between two documents by using <kbd>ReferenceField</kbd> to point to the ID of another object, as follows:</p>
<pre>class Post(mongo.Document): 
  ... 
  user = mongo.ReferenceField(User) </pre>
<p>Accessing the property of <kbd>ReferenceField</kbd> gives us direct access to the referenced object, as follows:</p>
<pre><strong>&gt;&gt;&gt; user = User.objects.first()</strong>
<strong>&gt;&gt;&gt; post = Post.objects.first()</strong>
<strong>&gt;&gt;&gt; post.user = user</strong>
<strong>&gt;&gt;&gt; post.save()</strong>
<strong>&gt;&gt;&gt; post.user</strong>
&lt;User Jack&gt;</pre>
<p>Unlike SQLAlchemy, MongoEngine has no way to access objects that have relationships to other objects. With SQLAlchemy, a <kbd>db.relationship</kbd> variable could be declared, which allowed a user object to access all of the posts with a matching <kbd>user_id</kbd> column. No such variable exists in MongoEngine.</p>
<p>A solution is to get the user ID for the posts you wish to search for and filter with the <kbd>user</kbd> field. This is the same thing that SQLAlchemy did behind the scenes, but we are doing it manually, as follows:</p>
<pre><strong>&gt;&gt;&gt; user = User.objects.first()</strong>
<strong>&gt;&gt;&gt; Post.objects(user__id=user.id)</strong></pre>
<p>The second way to create a one-to-many relationship is to use <kbd>EmbeddedDocumentField</kbd> with <kbd>EmbeddedDocument</kbd>, as follows:</p>
<pre>class Post(mongo.Document): 
    title = mongo.StringField(required=True) 
    text = mongo.StringField() 
    publish_date = mongo.DateTimeField(default=datetime.datetime.now()) 
    user = mongo.ReferenceField(User) 
    comments = mongo.ListField(mongo.EmbeddedDocumentField(Comment)) </pre>
<p class="mce-root"/>
<p>Accessing the <kbd>comments</kbd> property gives a list of all the embedded documents. To add a new comment to the post, treat it like a list and append <kbd>comment</kbd> documents to it, as follows:</p>
<pre><strong>&gt;&gt;&gt; comment = Comment()</strong>
<strong>&gt;&gt;&gt; comment.name = "Jack"</strong>
<strong>&gt;&gt;&gt; comment.text = "I really like this post!"</strong>
<strong>&gt;&gt;&gt; post.comments.append(comment)</strong>
<strong>&gt;&gt;&gt; post.save()</strong>
<strong>&gt;&gt;&gt; post.comments</strong>
[&lt;Comment 'I really like this post!'&gt;]
  </pre>
<p>Note that there was no call to a <kbd>save</kbd> method on the <kbd>comment</kbd> variable. This is because the comment document is not a real document; it is only an abstraction of <kbd>DictField</kbd>. Also, keep in mind that documents can only be up to 16 MB in size, so be careful how many <kbd>EmbeddedDocumentFields</kbd> are on each document and how many <kbd>EmbeddedDocuments</kbd> each one is holding.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Many-to-many relationships</h1>
                </header>
            
            <article>
                
<p>The concept of a many-to-many relationship does not exist in document store databases. This is because with <kbd>ListFields</kbd>, they become completely irrelevant. To idiomatically create the tag feature for the <kbd>Post</kbd> object, add a list of strings as follows:</p>
<pre>class Post(mongo.Document):
    title = mongo.StringField(required=True) 
    text = mongo.StringField() 
    publish_date = mongo.DateTimeField(default=datetime.datetime.now()) 
    user = mongo.ReferenceField(User) 
    comments = mongo.ListField(mongo.EmbeddedDocumentField(Comment)) 
    tags = mongo.ListField(mongo.StringField()) </pre>
<p>Now, when we wish to query for all of the <kbd>Post</kbd> objects that have a specific tag or many tags, all we need is a simple query, as shown in the following code:</p>
<pre><strong>&gt;&gt;&gt; Post.objects(tags__in="Python").all()</strong>
<strong>&gt;&gt;&gt; Post.objects(tags__all=["Python", "MongoEngine"]).all()</strong></pre>
<p>For the list of roles on each user object, we use a list of references using the <kbd>ListField</kbd> of <kbd>ReferenceField(Role)</kbd>, as shown in the highlighted text in the following code:</p>
<pre><span>...<br/>class </span><strong><span>Role</span></strong>(mongo.Document):<br/>    name = mongo.StringField(<span>max_length</span>=<span>64</span><span>, </span><span>required</span>=<span>True</span><span>, </span><span>unique</span>=<span>True</span>)<br/>    description = mongo.StringField()<br/>...<br/><br/><span>class </span><span>User</span>(mongo.Document):<br/>    username = mongo.StringField(<span>required</span>=<span>True</span>)<br/>    password = mongo.StringField()<br/>    <strong>roles = mongo.ListField(mongo.ReferenceField(Role))</strong><br/>...</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Leveraging the power of NoSQL</h1>
                </header>
            
            <article>
                
<p>To show the unique power of NoSQL, let's add a feature that would be possible with SQLAlchemy, but which would be much more difficult: different post types, each with their own custom bodies. This will be much like the functionality of the popular blog platform Tumblr.</p>
<p>To begin, allow your post type to act as a parent class and remove the text field from the <kbd>Post</kbd> class, as not all posts will have text on them. This is shown in the following code:</p>
<pre>class Post(mongo.Document): 
    title = mongo.StringField(required=True) 
    publish_date = mongo.DateTimeField(default=datetime.datetime.now()) 
    user = mongo.ReferenceField(Userm) 
    comments = mongo.ListField( 
    mongo.EmbeddedDocumentField(Commentm) 
  ) 
    tags = mongo.ListField(mongo.StringField()) 
   
    meta = { 
        'allow_inheritance': True 
    } </pre>
<p>Each post type will inherit from the <kbd>Post</kbd> class. Doing so will allow the code to treat any <kbd>Post</kbd> subclass as if it were a post. Our blogging app will have four types of post: a normal blog post, an image post, a video post, and a quote post. These are shown in the following code:</p>
<pre>class BlogPost(Post): 
    text = db.StringField(required=True) 
    <br/>    @property<br/>    def type(self): 
      return "blog" 
 
class VideoPost(Post): 
    url = db.StringField(required=True) 
    <br/>    @property<br/>    def type(self): 
      return "video" 
 
class ImagePost(Post): 
    image_url = db.StringField(required=True) 
  <br/>    @property 
    def type(self): 
      return "image" 
 
class QuotePost(Post): 
    quote = db.StringField(required=True) 
    author = db.StringField(required=True) 
  <br/>    @property 
    def type(self): 
      return "quote" </pre>
<p>Our post-creation page needs to be able to create each of these post types. The <kbd>PostForm</kbd> object in <kbd>forms.py</kbd>, which handles post creation, will need to be modified to handle the new fields first. We will add a selection field that determines the type of post, an <kbd>author</kbd> field for the quote type, an <kbd>image</kbd> field to hold a URL, and a <kbd>video</kbd> field that will hold the embedded HTML iframe. The <kbd>quote</kbd> and <kbd>blog</kbd> post content will both share the <kbd>text</kbd> field, as follows:</p>
<pre>class PostForm(Form): 
    title = StringField('Title', [ 
      DataRequired(), 
      Length(max=255) 
    ]) 
    type = SelectField('Post Type', choices=[ 
      ('blog', 'Blog Post'), 
      ('image', 'Image'), 
      ('video', 'Video'), 
      ('quote', 'Quote') 
    ]) 
    text = TextAreaField('Content') 
    image = StringField('Image URL', [URL(), Length(max=255)]) 
    video = StringField('Video Code', [Length(max=255)]) 
    author = StringField('Author', [Length(max=255)]) </pre>
<p>The <kbd>new_post</kbd> view function in the <kbd>blog/controllers.py</kbd> controller will also need to be updated to handle the new post types, as follows:</p>
<pre>@blog_blueprint.route('/new', methods=['GET', 'POST']) 
@login_required 
@poster_permission.require(http_exception=403) 
def new_post(): 
  form = PostForm() 
  if form.validate_on_submit(): 
    if form.type.data == "blog": 
      new_post = BlogPost() 
      new_post.text = form.text.data 
    elif form.type.data == "image": 
      new_post = ImagePost() 
      new_post.image_url = form.image.data 
    elif form.type.data == "video": 
      new_post = VideoPost() 
      new_post.video_object = form.video.data 
    elif form.type.data == "quote": 
      new_post = QuotePost() 
      new_post.text = form.text.data 
      new_post.author = form.author.data 
    new_post.title = form.title.data 
    new_post.user = User.objects( 
      username=current_user.username 
    ).one() 
    new_post.save() 
  return render_template('new.html', form=form) </pre>
<p>The <kbd>new.html</kbd> file that renders our <kbd>form</kbd> object will need to display the new fields that are added to the form, as follows:</p>
<pre>&lt;form method="POST" action="{{ url_for('.new_post') }}"&gt; 
... 
&lt;div class="form-group"&gt; 
  {{ form.type.label }} 
  {% if form.type.errors %} 
    {% for e in form.type.errors %} 
      &lt;p class="help-block"&gt;{{ e }}&lt;/p&gt; 
    {% endfor %} 
  {% endif %} 
  {{ form.type(class_='form-control') }} 
&lt;/div&gt; 
... 
&lt;div id="image_group" class="form-group"&gt; 
  {{ form.image.label }} 
  {% if form.image.errors %} 
    {% for e in form.image.errors %} 
      &lt;p class="help-block"&gt;{{ e }}&lt;/p&gt; 
    {% endfor %} 
  {% endif %} 
  {{ form.image(class_='form-control') }} 
&lt;/div&gt; 
&lt;div id="video_group" class="form-group"&gt; 
  {{ form.video.label }} 
  {% if form.video.errors %} 
    {% for e in form.video.errors %} 
      &lt;p class="help-block"&gt;{{ e }}&lt;/p&gt; 
    {% endfor %} 
  {% endif %} 
  {{ form.video(class_='form-control') }} 
&lt;/div&gt; 
&lt;div id="author_group" class="form-group"&gt; 
  {{ form.author.label }} 
    {% if form.author.errors %} 
      {% for e in form.author.errors %} 
        &lt;p class="help-block"&gt;{{ e }}&lt;/p&gt; 
      {% endfor %} 
    {% endif %} 
    {{ form.author(class_='form-control') }} 
&lt;/div&gt; 
&lt;input class="btn btn-primary" type="submit" value="Submit"&gt; 
&lt;/form&gt; </pre>
<p>Now that we have our new inputs, we can add some JavaScript to show and hide the fields based on the type of post, as follows:</p>
<pre>{% block js %} 
&lt;script src="//cdn.ckeditor.com/4.4.7/standard/ckeditor.js"&gt;&lt;/script&gt; 
&lt;script&gt; 
  CKEDITOR.replace('editor'); 
 
  $(function () { 
    $("#image_group").hide(); 
    $("#video_group").hide(); 
    $("#author_group").hide(); 
 
    $("#type").on("change", function () { 
      switch ($(this).val()) { 
        case "blog": 
          $("#text_group").show(); 
          $("#image_group").hide(); 
          $("#video_group").hide(); 
          $("#author_group").hide(); 
          break; 
        case "image": 
          $("#text_group").hide(); 
          $("#image_group").show(); 
          $("#video_group").hide(); 
          $("#author_group").hide(); 
          break; 
        case "video": 
          $("#text_group").hide(); 
          $("#image_group").hide(); 
          $("#video_group").show(); 
          $("#author_group").hide(); 
          break; 
        case "quote": 
          $("#text_group").show(); 
          $("#image_group").hide(); 
          $("#video_group").hide(); 
          $("#author_group").show(); 
          break; 
      } 
    }); 
  }) 
&lt;/script&gt; 
{% endblock %} </pre>
<p>Finally, the <kbd>post.html</kbd> file needs to be able to display our post types correctly. We have the following code:</p>
<pre>&lt;div class="col-lg-12"&gt;
{{ post.text | safe }}
&lt;/div&gt;</pre>
<p>All that is needed is to replace this with the following:</p>
<pre>&lt;div class="col-lg-12"&gt; 
  {% if post.type == "blog" %} 
    {{ post.text | safe }} 
  {% elif post.type == "image" %} 
    &lt;img src="{{ post.image_url }}" alt="{{ post.title }}"&gt; 
  {% elif post.type == "video" %} 
    {{ post.video_object | safe }} 
  {% elif post.type == "quote" %} 
    &lt;blockquote&gt; 
      {{ post.text | safe }} 
    &lt;/blockquote&gt; 
    &lt;p&gt;{{ post.author }}&lt;/p&gt; 
  {% endif %} 
&lt;/div&gt; </pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, the fundamental differences between NoSQL and traditional SQL systems were laid out. We explored the main types of NoSQL systems and why an application might need, or not need, to be designed with a NoSQL database. We addressed the CAP theorem and its implications regarding modern database systems.</p>
<p>Using our app's models as a base, the power of MongoDB and MongoEngine was shown by demonstrating how simple it was to set up complex relationships and inheritance.</p>
<p>In the next chapter, our blogging application will be extended with a feature designed for other programmers who wish to use our site to build their own service—that is, RESTful endpoints.</p>


            </article>

            
        </section>
    </body></html>