- en: Chapter 6. IPython and IronPython in PTVS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章：PTVS 中的 IPython 和 IronPython
- en: 'In this chapter, we will see how PTVS interacts with two particularly useful
    Python extensions: IPython and IronPython.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到 PTVS 如何与两个特别有用的 Python 扩展程序交互：IPython 和 IronPython。
- en: Despite their names, they are very different from each other. IPython is more
    oriented toward extending the REPL interface in a way that can help you have a
    more interactive approach to the code, providing you with features such as on-the-fly
    graph plotting. IronPython provides .NET class access to your Python code and
    integrates Python in .NET applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们的名称不同，但它们彼此之间非常不同。IPython 更倾向于以扩展 REPL 接口的方式，帮助您以更互动的方式处理代码，提供诸如即时图形绘图等特性。IronPython
    提供了对 Python 代码的 .NET 类访问，并将 Python 集成到 .NET 应用程序中。
- en: IPython in PTVS
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PTVS 中的 IPython
- en: IPython is a command shell for interactive computing for Python (also available
    for other language integrations) that offers enhanced type introspection—the possibility
    to examine the type or properties of an object at runtime—rich media, and REPL
    extensions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 是一个用于 Python（也适用于其他语言集成）的交互式计算命令行，它提供了增强的类型内省——在运行时检查对象类型或属性的可能性——丰富的媒体和
    REPL 扩展。
- en: As an interactive shell tool used for data analysis and math graph plotting,
    IPython comes from an academic-scientific computing background, but appeals to
    data scientists through the power of graphing integration.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种用于数据分析和数学图形绘制的交互式外壳工具，IPython 源自学术科学计算背景，但通过图形集成功能吸引了数据科学家。
- en: An interesting feature of IPython is its ability to plot mathematical graphs
    of expressions in an interactive way, much like MATLAB.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 的一个有趣特性是它能够以交互式方式绘制表达式的数学图形，这与 MATLAB 类似。
- en: PTVS supports IPython libraries and provides the ability to integrate the graph
    that is generated inside REPL.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: PTVS 支持 IPython 库，并提供了将 REPL 内部生成的图形集成的功能。
- en: We need to install IPython and its supporting dependencies such as matplotlib
    from a distribution that has all the code already compiled for Windows OS. The
    distribution of this package can be downloaded from [http://www.lfd.uci.edu/~gohlke/pythonlibs/#scipy-stack](http://www.lfd.uci.edu/~gohlke/pythonlibs/#scipy-stack).
    This web page, from the University of California in Irivine, contains an unofficial
    repository of Windows binaries for a large number of Python packages. There are
    different packages that are available, which depend on the version of the Python
    interpreter and the operating system you are using. For our proposal, we are going
    to install Python 2.7 for Windows 32-bit.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从已经为 Windows 操作系统编译好所有代码的发行版中安装 IPython 及其支持依赖，如 matplotlib。此软件包的发行版可以从
    [http://www.lfd.uci.edu/~gohlke/pythonlibs/#scipy-stack](http://www.lfd.uci.edu/~gohlke/pythonlibs/#scipy-stack)
    下载。这个网页来自加州大学欧文分校，包含大量 Python 软件包的 Windows 二进制文件的非官方仓库。有不同版本的软件包可供选择，这取决于您使用的
    Python 解释器和操作系统版本。对于我们的提案，我们将安装 Windows 32 位系统的 Python 2.7。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As an alternative, you can use the Python (x, y) distribution that contains
    a whole range of Python libraries for scientific and engineering software. The
    installer can be downloaded from [https://code.google.com/p/pythonxy/](https://code.google.com/p/pythonxy/).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种替代方案，您可以使用包含一系列用于科学和工程软件的 Python 库的 Python (x, y) 发行版。安装程序可以从 [https://code.google.com/p/pythonxy/](https://code.google.com/p/pythonxy/)
    下载。
- en: Running the installer gives you the ability to choose the libraries it offers;
    for our scope, ensure that you include the SciPy libraries and IPython.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 运行安装程序后，您可以选择它提供的库；对于我们的范围，请确保包括 SciPy 库和 IPython。
- en: 'Once you have the libraries from the source of your choice, we can test the
    whole installation by executing the following command from the command prompt:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您从您选择的源获得了库，我们就可以通过从命令提示符执行以下命令来测试整个安装：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command executes the IPython environment with the `pylab` extension. Also,
    it permits you to use the matplotlib library to plot graphs; this is a Python-plotting
    library that can be used with Python to plot graphs using mathematical functions.
    As an example, let''s try to plot a histogram out of 10,000 random numbers that
    are clustered in 100 samples:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令执行带有 `pylab` 扩展的 IPython 环境。它还允许您使用 matplotlib 库来绘制图形；这是一个可以与 Python 一起使用数学函数绘制图形的
    Python 绘图库。例如，让我们尝试绘制 10,000 个随机数字的直方图，这些数字被分成 100 个样本：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Typing the preceding code into the IPython shell will display the following
    result:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码输入到 IPython 壳中，将显示以下结果：
- en: '![IPython in PTVS](img/8687OS_06_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![IPython in PTVS](img/8687OS_06_01.jpg)'
- en: For more details on what the matplotlib library can do, refer to the library
    website at [http://matplotlib.org/](http://matplotlib.org/).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 matplotlib 库能做什么的更多详细信息，请参阅库网站 [http://matplotlib.org/](http://matplotlib.org/)。
- en: Now that IPython is up and working, let's instruct PTVS in a way that will allow
    REPL to talk to IPython to extend it along with its plotting capabilities. First,
    we need to find the Python interpreter's REPL options. You can quickly locate
    this from the **Python Environments** window by clicking on the **Interactive
    Options** label in the Python environment that is being used.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 IPython 已经启动并运行，让我们指导 PTVS 以允许 REPL 与 IPython 通信，从而扩展其绘图功能。首先，我们需要找到 Python
    解释器的 REPL 选项。您可以通过单击正在使用的 Python 环境中的 **交互选项** 标签，从 **Python 环境** 窗口中快速定位此选项。
- en: '![IPython in PTVS](img/8687OS_06_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![IPython in PTVS](img/8687OS_06_02.jpg)'
- en: 'This will bring up the **Options** dialog box, as shown in the following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这将弹出 **选项** 对话框，如下所示：
- en: '![IPython in PTVS](img/8687OS_06_03.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![IPython in PTVS](img/8687OS_06_03.jpg)'
- en: 'In the **Interactive Mode** drop-down menu, the different modes of the PTVS
    REPL tool are listed as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **交互模式** 下拉菜单中，PTVS REPL 工具的不同模式如下列出：
- en: '**Standard**: This mode offers the default REPL interactive window in which
    we can execute the Python code'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准模式**：此模式提供了默认的 REPL 交互式窗口，在其中我们可以执行 Python 代码'
- en: '**IPython**: This mode permits us to see the graphs directly inside REPL when
    REPL interacts with the PyLab library directly'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IPython**：此模式允许我们在 REPL 与 PyLab 库直接交互时直接在 REPL 中查看图表'
- en: '**IPython w/o PyLab**: This mode permits us to see the graphs that are rendered
    in an independent window'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无 PyLab 的 IPython**：此模式允许我们在独立窗口中看到渲染的图表'
- en: 'For our example, we are choosing the IPython mode. Now that we have set up
    **Interactive Window**, let''s see how Visual Studio acts. Instead of writing
    the code of our previous example inside **Interactive Window**, you can write
    it in the code editor and then execute it in REPL through the **Send to Interactive
    Window** option in the contextual menu. As we have seen in [Chapter 2](ch02.html
    "Chapter 2. Python Tools in Visual Studio"), *Python Tools in Visual Studio*,
    the following is the result to be expected:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的例子，我们选择了 IPython 模式。现在我们已经设置了 **交互式窗口**，让我们看看 Visual Studio 的表现。你可以在代码编辑器中编写我们之前示例的代码，然后通过上下文菜单中的
    **发送到交互式窗口** 选项在 REPL 中执行它，而不是在 **交互式窗口** 内部编写代码。正如我们在 [第 2 章](ch02.html "第 2
    章。Visual Studio 中的 Python 工具") 中所看到的，“Visual Studio 中的 Python 工具”，预期的结果是以下内容：
- en: '![IPython in PTVS](img/8687OS_06_04.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![IPython in PTVS](img/8687OS_06_04.jpg)'
- en: 'We can also execute the code in the file in a way through which we''ll only
    see the resulting graph in an external window. However, before we can do this,
    we need to add some other code as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过一种方式执行文件中的代码，这样我们只能在外部窗口中看到生成的图表。然而，在我们能够这样做之前，我们需要添加一些其他代码，如下所示：
- en: '![IPython in PTVS](img/8687OS_06_05.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![IPython in PTVS](img/8687OS_06_05.jpg)'
- en: 'The first line in the preceding screenshot will reference the `pylab` libraries,
    and the last line will render the plot. To run the code in an external window,
    right-click on the file node in the **Solution Explorer** window and select the
    **Start without debugging** command as shown in the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图中的第一行将引用 `pylab` 库，最后一行将渲染图表。要在外部窗口中运行代码，请右键单击 **解决方案资源管理器** 窗口中的文件节点，并选择以下截图所示的
    **不调试启动** 命令：
- en: '![IPython in PTVS](img/8687OS_06_06.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![IPython in PTVS](img/8687OS_06_06.jpg)'
- en: 'This will execute the code in the console, and the resulting rendering window
    will appear at the end of the execution:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台中执行代码，并在执行结束时出现生成的渲染窗口：
- en: '![IPython in PTVS](img/8687OS_06_07.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![IPython in PTVS](img/8687OS_06_07.jpg)'
- en: 'The matplotlib library also offers the possibility to save the resulting plot
    into a file with just a line of code by adding the `savefig` command as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 库还提供了通过添加 `savefig` 命令仅用一行代码将生成的图表保存到文件的选项，如下所示：
- en: '![IPython in PTVS](img/8687OS_06_08.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![IPython in PTVS](img/8687OS_06_08.jpg)'
- en: In this example, the resulting graph will be saved as a `plot.png` file in the
    root of the project folder.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，生成的图表将被保存为项目文件夹根目录下的 `plot.png` 文件。
- en: For more in-depth functionalities and to dig deeper into the plotting functionalities
    offered by the IPython integration, please refer to the IPython website at [http://ipython.org/](http://ipython.org/).
    You can also refer to the matplotlib website at [http://matplotlib.org/](http://matplotlib.org/),
    which contains great documentation on this subject that are correlated with examples.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解功能以及深入挖掘 IPython 集成提供的绘图功能，请参阅 IPython 网站 [http://ipython.org/](http://ipython.org/)。您还可以参考
    matplotlib 网站 [http://matplotlib.org/](http://matplotlib.org/)，其中包含与此主题相关的示例和出色的文档。
- en: The only limitation of IPython is the fact that it cannot be used with the other
    library, IronPython, that we are going to explore right now. IronPython currently
    does not support IPython, despite the fact that you can select it on the **Interactive
    Options** form.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: IronPython 的唯一限制是它不能与我们现在将要探索的其他库 IronPython 一起使用。尽管您可以在 **交互选项** 表单中选择它，但 IronPython
    目前不支持 IPython。
- en: IronPython
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IronPython
- en: IronPython is an open source implementation of the Python language which is
    tightly integrated with the Microsoft .NET framework. This means that you can
    use the .NET libraries through IronPython in your Python applications or use Python
    scripts inside .NET languages.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: IronPython 是 Python 语言的开放源代码实现，与 Microsoft .NET 框架紧密集成。这意味着您可以通过 IronPython
    在您的 Python 应用程序中使用 .NET 库，或者在使用 .NET 语言时使用 Python 脚本。
- en: Using .NET classes in Python code with IronPython
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Python 代码中使用 IronPython 的 .NET 类
- en: To set up IronPython in PTVS, first we need to download the IronPython installer
    from the official website, [http://ironpython.net/](http://ironpython.net/).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 PTVS 中设置 IronPython，首先我们需要从官方网站下载 IronPython 安装程序，[http://ironpython.net/](http://ironpython.net/)。
- en: 'Once you download the version of the package for your operating system, install
    the package by double-clicking on it. After the installation is complete, you
    will see that a new interpreter is available in the **Python Environments** window
    as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下载适用于您操作系统的包版本后，通过双击它来安装包。安装完成后，您将在 **Python 环境窗口**中看到一个新的解释器，如下所示：
- en: '![Using .NET classes in Python code with IronPython](img/8687OS_06_09.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![在 IronPython 代码中使用 .NET 类](img/8687OS_06_09.jpg)'
- en: In the example shown in the preceding screenshot, there are actually two interpreters.
    This is because the 64-bit version of IronPython is installed, which results in
    the installation of both the 32-bit and 64-bit versions on the machine.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面截图所示的示例中，实际上有两个解释器。这是因为安装了 IronPython 的 64 位版本，这导致在机器上安装了 32 位和 64 位版本。
- en: 'Let''s try to create a new IronPython project to learn how to interact with
    the .NET libraries from Python. Navigate to **File** | **New** | **Project** to
    create a new project:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试创建一个新的 IronPython 项目，以了解如何从 Python 交互 .NET 库。导航到 **文件** | **新建** | **项目**
    来创建一个新的项目：
- en: '![Using .NET classes in Python code with IronPython](img/8687OS_06_10.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![在 IronPython 代码中使用 .NET 类](img/8687OS_06_10.jpg)'
- en: 'This will open the **New Project** dialog box. Select the **IronPython Application**
    template and assign a project name to it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开 **新建项目** 对话框。选择 **IronPython 应用程序** 模板，并为它指定一个项目名称：
- en: '![Using .NET classes in Python code with IronPython](img/8687OS_06_11.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![在 IronPython 代码中使用 .NET 类](img/8687OS_06_11.jpg)'
- en: This will create a normal Python project, except that the environment for the
    project will be IronPython instead of Python.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个普通的 Python 项目，但项目环境将是 IronPython 而不是 Python。
- en: '![Using .NET classes in Python code with IronPython](img/8687OS_06_12.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![在 IronPython 代码中使用 .NET 类](img/8687OS_06_12.jpg)'
- en: You can find IronPython indicated as the environment in Solution Explorer
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在解决方案资源管理器中找到表示环境的 IronPython。
- en: Now you can access .NET libraries from inside the Python applications. The system's
    .NET namespace is referenced by default, so we can start using the elements inside
    it to see how to interact with the base classes in Python.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以从 Python 应用程序内部访问 .NET 库。默认情况下，系统 .NET 命名空间被引用，因此我们可以开始使用其中的元素来了解如何与 Python
    中的基类交互。
- en: As an example, let's see how to create a **Globally Unique Identifier** (**GUID**),
    play with the `date` function, and then print them out to the console; we're doing
    all of this using Python by accessing the .NET classes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看如何创建一个 **全局唯一标识符**（**GUID**），使用 `date` 函数进行操作，然后将它们打印到控制台；我们使用 Python
    通过访问 .NET 类来完成所有这些操作。
- en: '![Using .NET classes in Python code with IronPython](img/8687OS_06_13.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![在 IronPython 代码中使用 .NET 类](img/8687OS_06_13.jpg)'
- en: Example of using .NET classes inside Python
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中使用.NET类的示例
- en: As shown, we imported the `Console`, `Guid`, and `DateTime` .NET objects and
    used them in the code to create a new GUID object (line **3**), get the current
    UTC date and time (line **4**), and add 100 days to it (line **5**). After this,
    we used the .NET console object to print out the result (line **7** to **11**)
    and waited for the user to press the *Enter* key to close the application. Obviously,
    we could have used the normal Python `print` command instead of the `Console`
    object to print out the result. However, since there is no distinction between
    Python and the .NET code with IronPython, we used the `Console` object for the
    sake of seeing different object integrations in action.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，我们导入了`Console`、`Guid`和`DateTime` .NET对象，并在代码中使用它们创建一个新的GUID对象（第**3**行），获取当前的UTC日期和时间（第**4**行），并在此基础上添加100天（第**5**行）。之后，我们使用.NET控制台对象打印出结果（第**7**到**11**行），并等待用户按下*Enter*键关闭应用程序。显然，我们可以使用正常的Python
    `print`命令而不是`Console`对象来打印结果。然而，由于IronPython中Python和.NET代码之间没有区别，我们为了看到不同对象集成的实际效果，使用了`Console`对象。
- en: 'The execution of the code will provide us with the following result:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的执行将为我们提供以下结果：
- en: '![Using .NET classes in Python code with IronPython](img/8687OS_06_14.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![使用IronPython在Python代码中使用.NET类](img/8687OS_06_14.jpg)'
- en: 'We can also take advantage of other .NET namespaces outside of the Core System
    assembly. For example, if we want to use the `System.Xml` assembly, which is a
    .NET core library that is installed in the **Global Assembly Cache** (**GAC**)
    of the system, all we need to do is to load it in our code using the load functionality
    of the `clr` module as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以利用Core System组件之外的其他.NET命名空间。例如，如果我们想使用`System.Xml`组件，这是一个安装在系统**全局程序集缓存**（**GAC**）中的.NET核心库，我们只需要在代码中使用`clr`模块的加载功能将其加载进来，如下所示：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now it can be referenced in the code, and the IntelliSense functionalities
    become available:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它可以在代码中引用，并且IntelliSense功能变得可用：
- en: '![Using .NET classes in Python code with IronPython](img/8687OS_06_15.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![使用IronPython在Python代码中使用.NET类](img/8687OS_06_15.jpg)'
- en: .NET types are exposed as Python classes, and you can do many of the same operations
    on .NET types as with Python classes. In either case, you create an instance by
    calling the type. Even for complex types, `XmlDocument` for example, you don't
    need to instantiate it as you do in .NET; it will be done by the IronPython runtime
    under the hood.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: .NET类型以Python类的形式暴露，你可以在.NET类型上执行许多与Python类相同的操作。在两种情况下，你都是通过调用类型来创建实例。即使是复杂类型，例如`XmlDocument`，你也不需要像在.NET中那样实例化它；这将在IronPython运行时幕后完成。
- en: '![Using .NET classes in Python code with IronPython](img/8687OS_06_16.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![使用IronPython在Python代码中使用.NET类](img/8687OS_06_16.jpg)'
- en: An example of using the XmlDocument class in Python
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中使用XmlDocument类的示例
- en: Using the Python code in .NET with IronPython
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在.NET中使用IronPython的Python代码
- en: So far, we have learned how we can interact with .NET classes from the Python
    code; now let's take a look at how to use Python inside our .NET code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何从Python代码中与.NET类交互；现在让我们看看如何在.NET代码中使用Python。
- en: 'To start, let''s create a new C# console application. To be able to run the
    Python code from your .NET code, you need to reference two assemblies that are
    necessary to add the integration functionality for our .NET application: `IronPython`
    and `Microsoft.Scripting`. To add a reference to an assembly in a .NET application,
    right-click on the **Reference** node of the **Solution Explorer** window and
    select the **Add Reference** menu item:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个新的C#控制台应用程序。为了能够在.NET代码中运行Python代码，你需要引用两个必要的组件，以添加我们的.NET应用程序的集成功能：`IronPython`和`Microsoft.Scripting`。要在.NET应用程序中添加对组件的引用，右键单击**解决方案资源管理器**窗口中的**引用**节点，并选择**添加引用**菜单项：
- en: '![Using the Python code in .NET with IronPython](img/8687OS_06_17.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![使用IronPython在.NET中使用Python代码](img/8687OS_06_17.jpg)'
- en: 'This will open the **Reference Manager** dialog window. The two assemblies
    that we need are located in the **Extensions** list, which can be activated by
    clicking on the tree view on the left-hand side:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开**引用管理器**对话框窗口。我们需要的两個组件位于**扩展**列表中，可以通过点击左侧的树视图来激活：
- en: '![Using the Python code in .NET with IronPython](img/8687OS_06_18.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![使用IronPython在.NET中使用Python代码](img/8687OS_06_18.jpg)'
- en: Once the two assemblies are selected from the list by placing a tick in the
    checkboxes next to them, click on **OK**. The references to these assemblies are
    made in the project.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从列表中选择两个程序集，通过在它们旁边的复选框中放置勾选标记，然后点击**确定**。这些程序集的引用已添加到项目中。
- en: 'You will see them listed in the **Reference** list in the **Solution Explorer**
    window as shown in the following screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在**解决方案资源管理器**窗口的**引用**列表中看到它们，如下面的截图所示：
- en: '![Using the Python code in .NET with IronPython](img/8687OS_06_19.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![使用IronPython在.NET中使用Python代码](img/8687OS_06_19.jpg)'
- en: 'Now let''s create a new class in our project that contains the code for our
    Python integration:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在我们的项目中创建一个新的类，该类包含Python集成的代码：
- en: '![Using the Python code in .NET with IronPython](img/8687OS_06_20.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![使用IronPython在.NET中使用Python代码](img/8687OS_06_20.jpg)'
- en: This code will create `scripting engine` for Python (line **8**), define the
    string that contains the Python code to be executed (lines **12**-**18**), and
    then execute the Python script. Pay special attention to the string that contains
    the Python code. It has to be indented correctly; otherwise, the interpreter will
    return an indentation error.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将为Python创建`脚本引擎`（第**8**行），定义包含要执行Python代码的字符串（第**12**-**18**行），然后执行Python脚本。请特别注意包含Python代码的字符串。它必须正确缩进；否则，解释器将返回缩进错误。
- en: 'To run the code and see the result in the console, add the following code into
    the `Program.cs` file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要在控制台运行代码并查看结果，请将以下代码添加到`Program.cs`文件中：
- en: '![Using the Python code in .NET with IronPython](img/8687OS_06_21.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![使用IronPython在.NET中使用Python代码](img/8687OS_06_21.jpg)'
- en: 'This will execute our function defined earlier and expect the user to press
    *Enter*. Run the application to see the following result:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行我们之前定义的函数，并期望用户按下*Enter*。运行应用程序以查看以下结果：
- en: '![Using the Python code in .NET with IronPython](img/8687OS_06_22.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![使用IronPython在.NET中使用Python代码](img/8687OS_06_22.jpg)'
- en: You can also call variables and functions defined in .NET applications and use
    them inside the Python code. To do this, we need to define a scope and pass it
    as an argument to the `Execute` method in a way that the interpreter can pass
    those elements to the Python code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以调用在.NET应用程序中定义的变量和函数，并在Python代码中使用它们。为此，我们需要定义一个作用域，并将其作为参数传递给`Execute`方法，以便解释器可以将这些元素传递给Python代码。
- en: 'Extend our previous `Execute` method by adding a scope that contains an `Add`
    function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加包含`Add`函数的作用域来扩展我们之前的`Execute`方法：
- en: '![Using the Python code in .NET with IronPython](img/8687OS_06_23.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![使用IronPython在.NET中使用Python代码](img/8687OS_06_23.jpg)'
- en: 'We created a scope and the `Add` function with a lambda function (lines **13**
    and **14**); then, we added a new Python command (line **23**) that invokes this
    function. Finally, we executed the Python code and passed the scope variable to
    the script (line **27**). Executing the program will display the following result:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用lambda函数创建了一个作用域和`Add`函数（第**13**和**14**行）；然后，我们添加了一个新的Python命令（第**23**行），调用此函数。最后，我们执行了Python代码，并将作用域变量传递给脚本（第**27**行）。执行程序将显示以下结果：
- en: '![Using the Python code in .NET with IronPython](img/8687OS_06_24.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![使用IronPython在.NET中使用Python代码](img/8687OS_06_24.jpg)'
- en: 'In our last example, we will see how to execute a code that comes from an external
    file. Let''s say that we have a Python file that contains the following code,
    which is actually the code we had as a string in our last example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最后一个例子中，我们将看到如何执行来自外部文件的代码。假设我们有一个包含以下代码的Python文件，这实际上是我们在上一个例子中作为字符串拥有的代码：
- en: '![Using the Python code in .NET with IronPython](img/8687OS_06_25.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![使用IronPython在.NET中使用Python代码](img/8687OS_06_25.jpg)'
- en: 'This is how we can execute the file from inside our .NET application:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何在.NET应用程序内部执行文件的方式：
- en: '![Using the Python code in .NET with IronPython](img/8687OS_06_26.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![使用IronPython在.NET中使用Python代码](img/8687OS_06_26.jpg)'
- en: In the example, we define the scripting engine and the scope. Instead of defining
    and executing the Python code from inside the .NET code, we are loading it from
    an external file, passing the scope to the interpreter, and executing it (line
    **40**).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了脚本引擎和作用域。我们不是在.NET代码内部定义和执行Python代码，而是从外部文件加载它，将作用域传递给解释器，并执行它（第**40**行）。
- en: The possibilities offered by integrating Python code into .NET applications
    are really endless. Sharing the scope variables with the interpreter opens up
    a possibility to use existent Python libraries from inside the .NET applications
    or use Python as a scripting language inside our application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将Python代码集成到.NET应用程序中提供的可能性真的是无限的。与解释器共享作用域变量打开了一种可能性，即可以在.NET应用程序内部使用现有的Python库，或者在我们的应用程序内部使用Python作为脚本语言。
- en: Summary
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we looked at two ways to extend PTVS and Python in Visual
    Studio in general along with two powerful tools: IPython and IronPython. IPython
    is more related to plain Python language and IronPython is more integrated with
    the Microsoft .NET framework.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了两种在Visual Studio中扩展PTVS和Python的方法，以及两个强大的工具：IPython和IronPython。IPython与纯Python语言更为相关，而IronPython则与Microsoft
    .NET框架更为集成。
- en: Both tools show new ways to use and interact with Python, providing new frontiers
    to explore with this powerful language; all made possible from inside Visual Studio
    and PTVS.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个工具展示了使用和交互Python的新方法，为探索这个强大语言提供了新的边界；所有这些都是在Visual Studio和PTVS内部实现的。
- en: With this chapter, our voyage to explore the Python tools in Visual Studio ends.
    We tried to show Python developers the power of Visual Studio and the amount of
    automatism and help that the Microsoft IDE offers; we also explored and learned
    the possibility of using Python as a language to create new powerful applications.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们探索Visual Studio中Python工具的旅程就此结束。我们试图向Python开发者展示Visual Studio的强大功能和Microsoft
    IDE提供的自动化和帮助；我们还探讨了使用Python作为创建新强大应用程序的语言的可能性。
- en: Besides the tools themselves, we also went through the possible problems and
    workarounds of using Python libraries on the Microsoft Windows operating system.
    We also looked at the topic of exploring Django in Visual Studio and also some
    of the powerful libraries it offers to accelerate and manage the application's
    life cycle.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了工具本身，我们还探讨了在Microsoft Windows操作系统上使用Python库可能遇到的问题和解决方案。我们还研究了在Visual Studio中探索Django的主题，以及它提供的用于加速和管理应用程序生命周期的强大库。
- en: We have only scratched the surface, but we hope that this book has provided
    you with a deep insight into PTVS and has sparked the curiosity for you to go
    deeper and explore more.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是触及了表面，但我们希望这本书已经为您提供了对PTVS的深入洞察，并激发了您进一步探索和学习的兴趣。
- en: Happy coding!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 开心编码！
