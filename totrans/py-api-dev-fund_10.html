<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-184">10. Deployment<a id="_idTextAnchor409"/></h1>
		</div>
		<div><h2>Learning Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Explain the application deployment process to the cloud</li>
				<li class="bullets">Explain the difference between SaaS, PaaS, and IaaS</li>
				<li class="bullets">Set up different configurations between development and production environments</li>
				<li class="bullets">Set up the Heroku cloud platform</li>
				<li class="bullets">Install and configure Heroku Postgres</li>
				<li class="bullets">Use the Heroku command-line interface (Heroku CLI) to deploy an application</li>
				<li class="bullets">Set up the Postman environment variable</li>
			</ul>
			<p>In this chapter, we are going to deploy our application to Heroku and test it using Postman.</p>
		</div>
		<div><h2 id="_idParaDest-185"><a id="_idTextAnchor410"/>Introduction</h2>
			<p>In the previous chapter, we added the cache and rate limit functions to our Smilecook applications. These last two functions are very useful, especially when we are dealing with huge volumes of traffic. Caching and rate-limiting can improve response speeds and can also raise the security level.</p>
			<p>In this chapter, we will discuss how we can deploy our application to a cloud server. Deploying an application is like publishing a book or releasing a movie. It is like releasing our application on the market. Nowadays, a lot of cloud services provide free usage quotas. They allow developers to deploy their application to their cloud platform for free provided the resource usage is below a certain threshold. For our Smilecook application, what we need to do is simply make a few minor changes to the code and some configuration files. Everything else will be handled by the cloud platform. You will see how simple this is very soon.</p>
			<p>We will first make minor modifications to the application code to segregate the production and development environment configurations. Then, we will talk about the Heroku cloud service platform, on which we are going to deploy the Smilecook application. We will walk you through the account registration, configuration, and deployment processes in the Heroku cloud service platform.</p>
			<p>Once the deployment is done, we will use Postman to test the APIs directly in the production environment. Isn't that exciting?! Without further ado, let's get started.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor411"/>Deployment</h2>
			<p>What is <strong class="bold">deployment</strong> for? The API application we wrote earlier just runs the code on the local machine. Using one of the ports on the local machine, we can send the request from the client to the local server. This is good for development purpose. We can quickly test and adjust our application in a development environment. However, our local machine is not intended to be a server; others can't access it. And they cannot send HTTP requests to APIs hosted on our local machine.</p>
			<p>If we want to open this API service to external users, we need to host it on a server. The server should be connected to the internet, with a domain and URL that allow others to access it.</p>
			<p>Moving an application from a local machine to a server that runs on the internet is called deployment. This will involve work such as environment setting, dependent package installation, and building a web server.</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor412"/>Comparing SaaS, PaaS, and IaaS</h2>
			<p>In the past, it was expensive to set up your own web server. There are lots of considerations, including network connectivity, storage, server configuration, and OS setup. Nowadays, cloud computing services are here to provide all the infrastructure services, which lowers costs significantly, especially for individual developers and small- and medium-sized companies. There are three main categories of cloud computing services out there. These are <strong class="keyword">Software as a Service</strong> (<strong class="keyword">SaaS</strong>), <strong class="keyword">Platform as a Service</strong> (<strong class="keyword">PaaS</strong>), and <strong class="keyword">Infrastructure as a Service</strong> (<strong class="keyword">IaaS</strong>). There are pros and cons for each, and these will be discussed in this section.</p>
			<p><strong class="bold">IaaS</strong>: Users do not need to purchase their own servers, software, network devices, and so on. These infrastructures are provided as a service, and users do not need to care about setup and maintenance. They still have the ability to configure these services, such as installing software and setting up firewall. Example of IaaS include <strong class="keyword">AWS EC2</strong> and <strong class="keyword">Google Compute Engine</strong> (<strong class="keyword">GCE</strong>).</p>
			<p>Compared with the past, this IaaS model can greatly reduce the hardware and network setup costs, and all other costs relating to space and resources surrounding that. Individual developers, or small- and medium-sized companies often do not need that many system resources. This model, therefore, allows them to rent the infrastructure as a service; they just need to pay for the resources that they need.</p>
			<ul>
				<li>Pros: Developers have much more flexibility. IaaS provides the necessary computing resources for applications to run on. Developers can easily request additional resources, or trim down resources, according to the needs of the application. This is easily customizable. </li>
				<li>Cons: Developers need to spend time learning how to configure the cloud platform according to their needs.</li>
			</ul>
			<p><strong class="bold">PaaS</strong>: PaaS is somewhere between SaaS and IaaS. There is no need for users to manage and maintain infrastructures. Service providers already package all these infrastructure and related services together as a platform and rent them out as a service to users. Users do not need to worry about the backend setup required, nor aspects such as extending the number of servers and load balancing. Users (developers) just need to focus on their development and deploy their work accordingly to the cloud platform. Example of PaaS include Heroku, Windows Azure, and AWS Elastic Beanstalk.</p>
			<ul>
				<li>Pros: Reduced setup time. By leveraging the services provided by the platform, developers can zero in on development.</li>
				<li>Cons: There could be an unnecessary charge incurred. Compared to IaaS, PaaS is less flexible in the sense that you have less control over the infrastructure setup and configuration. As the whole platform is packaged as a service, some unused packaged resources could go to waste. In this case, the charge could be comparatively higher than IaaS.</li>
			</ul>
			<p><strong class="bold">SaaS</strong>: SaaS basically refers to web applications available on the internet. Users are not required to maintain the software. The software is provided as a service. A very typical example is Gmail. Example of SaaS include Dropbox, Salesforce, and Slack.</p>
			<ul>
				<li>Pros: The cost is low as we don't need to care about hardware purchases and other setup costs. If a user has a specific requirement that can be addressed by this service, SaaS could be the easiest and most effective solution.</li>
				<li>Cons: Since the vast amount of user data will be stored in the cloud platform, there could be some concerns regarding data security. Also, we need to consider service availability once the application is deployed.</li>
			</ul>
			<p>As individual developers, we need a stable and scalable server for us to deploy our application. PaaS is the best option here. It provides the computing platform for applications to run on, and developers do not need to worry about hardware maintenance since service providers take care of all of this. Hence, it is a time and cost-saving solution for developers. Developers can focus on developing good software.<a id="_idTextAnchor413"/></p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor414"/>The Heroku Platform</h2>
			<p>Heroku is a popular PaaS. We can deploy our APIs there so that they can be accessed by anyone in the world. And it doesn't just support Python, but also other programming languages, including Ruby and Go.</p>
			<p>Heroku provides a free plan for developers to deploy and test their applications there. Certainly, they do have paid plans as well, and with many more powerful functions that can make our APIs more secure and efficient. Later on, if you need these powerful features and system resources for your application, you can consider that. But right now, for teaching purposes, a free plan is good enough.</p>
			<h4><a id="_idTextAnchor415"/>Note</h4>
			<p class="callout">Apart from Heroku, there are other cloud service providers. Some of the market leaders in cloud services are <strong class="keyword">Amazon Web Services</strong> (<strong class="keyword">AWS</strong>), <strong class="keyword">Google Cloud Platform</strong> (<strong class="keyword">GCP</strong>), IBM Cloud, Microsoft Azure, and Rackspace Cloud.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor416"/>Configuration Handling in Smilecook</h2>
			<p>Most applications require multiple configurations; at least one is required for a production server, and one for development use. There will be differences between them, such as the debug mode, secret key, and database URL. We can use a default configuration that is always loaded, and a separate configuration for the production server and development environment to inherit the default configuration depending on the environment. For environment-specific configurations, we will create two new classes – <code>DevelopmentConfig</code> and <code>ProductionConfig</code>.</p>
			<h3 id="_idParaDest-190"><a id="_idTextAnchor417"/>Exercise 63: Configuration Handling for the Production and Development Environments</h3>
			<p>In this exercise, we will segregate our application configurations between the development and production environments. For configurations such as <code>DEBUG</code>, we will require different values for the two environments. The same goes for the database URL as well. We are therefore going to create two sets of configurations, <code>DevelopmentConfig</code> and <code>ProductionConfig</code>. The former is for development and system enhancement in a development environment, while the latter is to be run in the production environment. Perform the following steps to complete the exercise:</p>
			<ol>
				<li><a id="_idTextAnchor418"/><a id="_idTextAnchor419"/>First, in <code>config.py</code>, add a default configuration that will be used in all environments:<pre>import os
class Config:
    DEBUG = False
 
    SQLALCHEMY_TRACK_MODIFICATIONS = False
 
    JWT_ERROR_MESSAGE_KEY = 'message'
 
    JWT_BLACKLIST_ENABLED = True
    JWT_BLACKLIST_TOKEN_CHECKS = ['access', 'refresh']
 
    UPLOADED_IMAGES_DEST = 'static/images'
 
    CACHE_TYPE = 'simple'
    CACHE_DEFAULT_TIMEOUT = 10 * 60
 
    RATELIMIT_HEADERS_ENABLED = True</pre></li>
				<li>Add <code>DevelopmentConfig</code> after the <code>Config</code> class:<pre>class DevelopmentConfig(Config):
    DEBUG = True
    SECRET_KEY = 'super-secret-key'
    SQLALCHEMY_DATABASE_URI = 'postgresql+psycopg2://your_name:your_password@localhost:5432/smilecook'</pre><p>The new <code>DevelopmentConfig</code> class extends the parent <code>Config</code> class. The <code>DEBUG</code> value is set to <code>True</code>. That will allow us to see the error messages while we are developing.</p></li>
				<li>Add <code>ProductionConfig</code> after the <code>Development Config</code> class:<pre>class ProductionConfig(Config):
    SECRET_KEY = os.environ.get('SECRET_KEY')
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')</pre><p>The <code>ProductionConfig</code> class here also extends the parent <code>Config</code> class. Similar to the <code>DevelopmentConfig</code> class, we have <code>SECRET_KEY</code> and <code>SQLALCHEMY_DATABASE_URI</code> set here. In the production environment, these values are obtained from the environment variables. We will teach you how to set these on a cloud platform later.</p></li>
				<li>In <code>app.py</code>, import <code>os</code>:<pre>import os</pre></li>
				<li> In <code>app.py</code>, make the following change to get the configurations dynamically<a id="_idTextAnchor420"/>:<pre>def create_app():
    env = os.environ.get('ENV', 'Development')
    if env == 'Production':
        config_str = 'config.ProductionConfig'
    else:
        config_str = 'config.DevelopmentConfig'
    app = Flask(__name__)
    app.config.from_object(config_str)
    ...
    
    return app</pre><p>The <code>ENV</code> environment variable will be obtained via <code>os.environ.get</code>. If it is <code>Production</code>, the production environment configuration will be used. In addition, the development environment configuration will be used.</p></li>
				<li><a id="_idTextAnchor421"/>Right-click on PyCharm and run the application. Because we haven't set up the <code>ENV</code> environment variable in the local machine, Flask will pick up <code>config.DevelopmentConfig</code> and execute it. We can see from the output that <strong class="bold">Debug mode: on</strong>:<p> </p><div><img src="img/C15309_10_01.jpg" alt="Figure 10.1: Running an application in the development environment&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 10.1: Running an application in the development environment</h6>
			<p>So, we have separated the configurations between the production and development environments. In the future, if there are common configurations shared among the two environments, we will put them in the <code>Config</code> class. Otherwise, they should be placed under the corresponding <code>DevelopmentConfig</code> or <code>ProductionConfig</code> class.</p>
			<h3 id="_idParaDest-191">E<a id="_idTextAnchor422"/>xercise 64: Adding a Staging Configuration Class</h3>
			<p>In order to facilitate internal testing, in this exercise, we need to add a <code>StagingConfig</code> class. This configuration will extend the common <code>Config</code> class. The staging environment will not be much different from production, because it is mainly designed to imitate the production environment for testing. And we will obtain the secret key and database URI from the environment variables:</p>
			<ol>
				<li value="1">I<a id="_idTextAnchor423"/>n <code>config.py</code>, create a <code>StagingConfig</code> class that extends <code>Config</code>:<pre>class StagingConfig(Config):
    SECRET_KEY = os.environ.get('SECRET_KEY')
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')</pre></li>
				<li>I<a id="_idTextAnchor424"/>n <code>app.py</code>, modify the conditional statements for <code>StagingConfig</code>:<pre>    if env == 'Production':
        config_str = 'config.ProductionConfig'
    elif env == 'Staging':
        config_str = 'config.StagingConfig'
    else:
        config_str = 'config.DevelopmentConfig'</pre></li>
			</ol>
			<p>Hence, we have set up the configuration for the staging environment. But it is not completed yet, since the environment variables will need to be obtained from the cloud server. Next, we will start to work on the cloud platform, <strong class="bold">Heroku</strong>.</p>
			<h2 id="_idParaDest-192">H<a id="_idTextAnchor425"/>eroku Application</h2>
			<p>Before we deploy to Heroku (the cloud platform), we will first create an account and set up the environment there. We will create a new Heroku application. Then, we will need to install the Postgres database on Heroku. The installation process can be done within the Heroku platform; everything is integrated. Finally, we set up the virtual environment variables, such as the database URL and the secret key. Once all these precursors are completed, we will then start the deployment process.</p>
			<h3 id="_idParaDest-193">E<a id="_idTextAnchor426"/>xercise 65: Creating a New Application in Heroku</h3>
			<p>In this exercise, we will first register a Heroku account. Then, we will create a new app on it. Heroku provides a nice user interface with an easy-to-follow setup flow. We just need to click a few buttons and that's it. As Heroku is a PaaS, we don't need to manage any hardware nor set up the OS. These are all taken care of by Heroku: </p>
			<ol>
				<li value="1">V<a id="_idTextAnchor427"/>isit the Heroku website, <a href="https://www.heroku.com/">https://www.heroku.com/</a>, and click <strong class="bold">Sign up</strong>: <div><img src="img/C15309_10_02.jpg" alt="Figure 10.2: Visiting the Heroku website&#13;&#10;"/></div><h6>Figure 10.2: Visiting the Heroku website</h6></li>
				<li>On<a id="_idTextAnchor428"/>ce the signup process is complete, click <strong class="bold">Log in</strong> and access the dashboard. Click <strong class="bold">Create new app</strong> to create a new application in Heroku:<div><img src="img/C15309_10_03.jpg" alt="Figure 10.3: Logging in and accessing the Heroku dashboard&#13;&#10;"/></div><h6>Figure 10.3: Logging in and accessing the Heroku dashboard</h6></li>
				<li>Type in the app name, and then select the server region (right now, the only options are the United States and Europe; please select the one that is closer to your target users). Then, click <strong class="bold">Create app</strong> to continue:</li>
			</ol>
			<div><div><img src="img/C15309_10_04.jpg" alt="Figure 10.4: Typing in the app name and selecting the server region&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 10.4: Typing in the app name and selecting the server region</h6>
			<h4>Note</h4>
			<p class="callout">The app name will be used in the application URL provided by Heroku, for example, <code>https://{app_name}.herokuapp.com/</code>. Users can then access our APIs using this URL.</p>
			<p>After the application is created, we can see the app administration screen, along the lines of the following:</p>
			<div><div><img src="img/C15309_10_05.jpg" alt="Figure 10.5: Heroku app administration screen&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 10.5: Heroku app administration screen</h6>
			<p>The app administration screen provides information for us to understand the application status:</p>
			<p><strong class="bold">Overview</strong>: For us to see the cost incurred or other collaborators' activities</p>
			<p><strong class="bold">Resources</strong>: For managing add-ons and the <strong class="bold">Procfile</strong> setting</p>
			<p><strong class="bold">Deploy</strong>: For choosing the deployment method</p>
			<p><strong class="bold">Metrics</strong>: For showing the metrics of the app</p>
			<p><strong class="bold">Activity</strong>: For tracking user activity</p>
			<p><strong class="bold">Access</strong>: For managing collaborator access</p>
			<p><strong class="bold">Settings</strong>: Includes environment variable configurations, buildpack settings, and other advanced features</p>
			<h4>Note</h4>
			<p class="callout">At the heart of the Heroku platform is the ability to run the applications using the lightweight container Dynos. Containerization is a standard way to package your application's code, configuration, and dependencies into a single object. Containerization can reduce the burden on the managing hardware, virtual machine, or environment setup, and so on. </p>
			<p>Once the application has been created, we will install the Postgres repository in Heroku and we will install it directly via Heroku add-ons.</p>
			<h2 id="_idParaDest-194">Herok<a id="_idTextAnchor429"/>u Add-Ons</h2>
			<p>Heroku has a rich add-ons library. Add-ons are like plugins, which provide tools and services for developing, extending, and operating your apps, including data stores, monitoring, logging, analytics, and security. For our Smilecook application, we will use Heroku Postgres from Heroku, which is a reliable and powerful database as a service based on PostgreSQL. The starter tier is free and offers a 10,000-row limit and provides an expected uptime of 99.5%. This is suitable for developing hobby applications.</p>
			<h3 id="_idParaDest-195">Exerc<a id="_idTextAnchor430"/>ise 66: Installing Heroku Postgres</h3>
			<p>In this exercise, we will install Heroku Postgres. It is more convenient to install Postgres from Heroku, compared to installing it from the Postgres official website. We only need to go to the <strong class="bold">Data Stores</strong> category in <strong class="bold">Heroku add-ons</strong> and then select <strong class="bold">Heroku Postgres</strong> directly to install. Heroku provides a backend management interface so that we can see the database status at a glance:</p>
			<ol>
				<li value="1">Switc<a id="_idTextAnchor431"/>h to the <strong class="bold">Resources</strong> tab in Heroku, and then right-click on the <strong class="bold">Find more add-ons</strong> button:<div><img src="img/C15309_10_06.jpg" alt="Figure 10.6: Switching to the Resources tab in Heroku&#13;&#10;"/></div><h6>Figure 10.6: Switching to the Resources tab in Heroku</h6></li>
				<li>In the<a id="_idTextAnchor432"/> <strong class="bold">Add-ons</strong> page, click on <strong class="bold">Data Stores</strong> and select <strong class="bold">Heroku Postgres</strong>:<div><img src="img/C15309_10_07.jpg" alt="Figure 10.7: Add-ons page in Heroku&#13;&#10;"/></div><h6>Figure 10.7: Add-ons page in Heroku</h6></li>
				<li>Then, click on <strong class="bold">Install Heroku Postgres</strong> to install the add-on in our cloud server:<div><img src="img/C15309_10_08.jpg" alt="Figure 10.8: Installing the Heroku Postgres add-on&#13;&#10;"/></div><h6>Figure 10.8: Installing the Heroku Postgres add-on</h6></li>
				<li>Select the default, <strong class="bold">Hobby Dev - Free Plan</strong>. This plan is free. In <strong class="bold">App to provision to</strong>, put in the app name we used in the previous exercise, and then click <strong class="bold">Provision add-on</strong>:<p> </p><div><img src="img/C15309_10_09.jpg" alt="Figure 10.9: Selecting the Heroku Postgres add-on plan&#13;&#10;"/></div><h6>Figure 10.9: Selecting the Heroku Postgres add-on plan</h6></li>
				<li>Once that is done, we can check whether <strong class="bold">Heroku Postgres</strong> is installed on the <strong class="bold">Add-ons</strong> page:<div><img src="img/C15309_10_10.jpg" alt="Figure 10.10: Checking that Heroku Postgres is installed&#13;&#10;"/></div><h6>Figure 10.10: Checking that Heroku Postgres is installed</h6></li>
				<li>Then, click on <strong class="bold">Heroku Postgres add-on</strong> to enter the management page:</li>
			</ol>
			<div><div><img src="img/C15309_10_11.jpg" alt="Figure 10.11: Heroku Postgres management page&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 10.11: Heroku Postgres management page</h6>
			<p>The <strong class="bold">Overview</strong> allows us to check the database status, utilization rate, and so on. <strong class="bold">Durability</strong> allows us to manage data security and backup. <strong class="bold">Settings</strong> stores the database credentials and other advanced settings. <strong class="bold">Data clips</strong> allow you to query the database data using the SQL command online. You can export or share the result there.</p>
			<p>As you can see, it is pretty straightforward to install Postgres on Heroku; it just takes a few steps. Next, we will work on setting up the environment variables in the cloud platform. </p>
			<h2 id="_idParaDest-196">Setting Up <a id="_idTextAnchor433"/>Environment Variables for the Heroku App</h2>
			<p>We previously modified <code>config.py</code> and added <code>ProductionConfig</code> there. Now we have to add the environment variables in Heroku, including the secret key and database URL. In addition to these, let's not forget the Mailgun API key and the Mailgun domain as well. We will set up all of these together in the next exercise.</p>
			<h3 id="_idParaDest-197">Exercise 67<a id="_idTextAnchor434"/>: Setting Up the App Environment Variables</h3>
			<p>In this exercise, we will set up the environment variables in the production environment. Fortunately, because we are using Heroku Postgres, the database URL environment variable has already been set up for us. We only need to set <code>ENV</code>, <code>SECRET_KEY</code>, <code>MAILGUN KEY</code>, and <code>DOMAIN</code>. Then, once the setting is complete, after the <code>Deploy</code> code is completed, the application will read the newly added environment variables in <code>App config</code>:</p>
			<ol>
				<li value="1">Generate the secret key using the following two lines of code in the Python console in PyCharm:<pre>&gt;&gt;&gt;import os
&gt;&gt;&gt;os.urandom(24)</pre><h4>Note</h4><p class="callout">A secret key should be as random as possible. There are a lot of random generators out there that we can leverage. But perhaps the easiest way to do so is to generate that in the Python console in PyCharm. </p></li>
				<li>Go to the <strong class="bold">S<a id="_idTextAnchor435"/>ettings</strong> tab and set up the <strong class="bold">ENV</strong>, <strong class="bold">MAILGUN_API_KEY</strong>, <strong class="bold">MAILGUN_DOMAIN</strong>, and <strong class="bold">SECRET_KEY</strong> environment variables as the following:</li>
			</ol>
			<div><div><img src="img/C15309_10_12.jpg" alt="Figure 10.12: Setting up environment variables in Heroku&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 10.12: Setting up environment variables in Heroku</h6>
			<p>Now that we have finished the necessary preparatory setup in Heroku, we will go straight to the deployment process.</p>
			<h3 id="_idParaDest-198">Deployment U<a id="_idTextAnchor436"/>sing Heroku Git</h3>
			<p>Heroku provides a guideline on how we can deploy our application. The guide can be found in the <strong class="bold">Deploy</strong> tab. It is mainly divided into three parts. They are <strong class="bold">Install the Heroku CLI</strong>, <strong class="bold">Create a new Git repository</strong>, and <strong class="bold">Deploy your application</strong>. The details are as follows:</p>
			<div><div><img src="img/C15309_10_13.jpg" alt="Figure 10.13: Deployment using the Heroku Git guideline&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 10.13: Deployment using the Heroku Git guideline</h6>
			<p>There are three parts to the guideline in the <strong class="bold">Deploy</strong> tab:</p>
			<p><strong class="bold">Install the Heroku CLI</strong></p>
			<ul>
				<li><code>heroku login</code> – For logging into Heroku using the Heroku CLI tool provided.</li>
			</ul>
			<p><strong class="bold">Create a new Git repository</strong></p>
			<ul>
				<li><code>cd my-project/</code> – Change directory to the <code>my-project</code> folder.</li>
				<li><code>git init</code> – Initialize <code>git</code>, which is a version control system. We will discuss this soon.</li>
				<li><code>heroku git:remote -a smilecook</code> – Add the app (Smilecook) repository to the remote repository list of the local Git.</li>
			</ul>
			<p><strong class="bold">Deploy your application</strong></p>
			<ul>
				<li><code>git add .</code> – To add all files and folders to the current directory and subfolder to Git.</li>
				<li><code>git commit -am "make it better"</code> – Commit a change and insert the commit message to <code>make it better</code>.</li>
				<li><code>git push heroku master</code> – This will upload the local repository content to the remote repository, which is the repository in Heroku. Once it is pushed, Heroku will run the app start-up procedure.</li>
			</ul>
			<p>Before we start deploying our application, there are still a few bits of terminology that require explanation.</p>
			<h3 id="_idParaDest-199"><a id="_idTextAnchor437"/>What is Git?</h3>
			<p><strong class="bold"><a id="_idTextAnchor438"/>Git</strong> is a distributed version control system. A version control system is mainly a system that can keep track of every version of your source code. Any changes in the source code will be recorded in the system. It allows developers to easily restore the previous version. No manual backup is required.</p>
			<p>Git also supports collaboration and other advanced features. If you are interested, you can go to the official Git website to learn more about it: <a href="https://git-scm.com">https://git-scm.com</a>.</p>
			<h3 id="_idParaDest-200">What is gitig<a id="_idTextAnchor439"/>nore?</h3>
			<p><strong class="bold">gitignore</strong> is a file that contains a list of files and folders that Git should ignore. Files and folders in this list will not be stored in Git. Usually, we will include the environment configs, logs, and so on in this list. </p>
			<h3 id="_idParaDest-201">What is Procf<a id="_idTextAnchor440"/>ile?</h3>
			<p><strong class="bold">Procfile</strong> is a file that will be executed during the app start-up process in Heroku. Developers will put in the commands they want Heroku to run during the app start-up process. Usually, we will put the setup scripts and server start-up scripts here.</p>
			<h3 id="_idParaDest-202">What is Gunic<a id="_idTextAnchor441"/>orn?</h3>
			<p><strong class="bold">Gunicorn</strong> is a Python WSGI HTTP server that is compatible with various web applications. It can be used as an interface between web servers and web applications. Gunicorn can communicate with multiple web servers or start multiple web applications. It is a powerful and fast HTTP server.</p>
			<p>Now that we have learned about the deployment flow as well as some key concepts and terminology, we will work on the deployment together in our next exercise.</p>
			<h3 id="_idParaDest-203">Exercise 68: <a id="_idTextAnchor442"/>Setting Up the Git and the Heroku CLI</h3>
			<p>In this exercise, we will deploy our Smilecook application to the production environment. We will download and install the Heroku CLI and Git first so that we can run the deployment command in the local machine. Then, we will add the <code>gitignore</code> file to ensure that some files will not be uploaded to Heroku. Finally, we will add <code>main.py</code> and <code>Procfile</code> to the root directory of the project and then deploy it to Heroku:</p>
			<ol>
				<li value="1">Install the <strong class="bold">H<a id="_idTextAnchor443"/>eroku CLI</strong> from <a href="https://devcenter.heroku.com/articles/heroku-cli">https://devcenter.heroku.com/articles/heroku-cli</a>. Pick the version for your OS and download it:<div><img src="img/C15309_10_14.jpg" alt="Figure 10.14: Installing the Heroku CLI&#13;&#10;"/></div><h6>Figure 10.14: Installing the Heroku CLI</h6></li>
				<li>If you haven't<a id="_idTextAnchor444"/> installed Git, please install it from <a href="https://git-scm.com/">https://git-scm.com/</a>:<div><img src="img/C15309_10_15.jpg" alt="Figure 10.15: Installing Git&#13;&#10;"/></div><h6>Figure 10.15: Installing Git</h6></li>
				<li>At the bottom o<a id="_idTextAnchor445"/>f PyCharm, open the terminal. Run the <code>git --version</code> command to confirm that Git has installed successfully:<pre>$ git --version
 git version 2.19.1 // You may see a different value inside the brackets depending on your OS</pre></li>
				<li>Right-click to <a id="_idTextAnchor446"/>create a <code>.gitignore</code> file in the project. This file will contain a list of files or folders that we don't want to be added to Git:<pre>static/images/avatars/*
static/images/recipes/*
.idea/
venv/</pre><p><code>static/images/avatars/*</code> – We do not want to include all the testing images that we created in the previous chapters to be uploaded to the production environment.</p><p><code>static/images/recipes/*</code> – We do not want to include all the testing images that we created in the previous chapters to be uploaded to the production environment.</p><p><code>.idea/</code> – This is the IDE project-specific settings folder. We don't need it in production.</p><p><code>venv/</code> – This is the virtual environment.</p></li>
				<li>Log in to your <a id="_idTextAnchor447"/>Heroku account:<pre>$ heroku login</pre></li>
				<li>Then, type in t<a id="_idTextAnchor448"/>he following <code>git init</code> command to initialize Git. This is to add version control to our project:<pre>$ git init</pre></li>
				<li>Add the Heroku <a id="_idTextAnchor449"/>repository to the Git remote repository (please replace <code>your-heroku-app</code> with the name of your Heroku app).<pre>$ heroku git:remote -a your-heroku-app</pre><h4>Note</h4><p class="callout">Before adding in the remote repository, all our changes can only be committed to the local repository.</p></li>
				<li>In <code>requirements<a id="_idTextAnchor450"/>.txt</code>, add in the <code>gunicorn</code> package, which is going to be our HTTP server:<pre>gunicorn==19.9.0</pre></li>
				<li>Create <code>main.py</code> <a id="_idTextAnchor451"/><a id="_idTextAnchor452"/>under the project root folder. This will be executed by Gunicorn to start up our web application: <pre>from app import create_app
app = create_app()</pre></li>
				<li>Right-click to <a id="_idTextAnchor453"/>create a file under the project root folder. Name it <code>Procfile</code> without an extension and then insert the following two commands:<pre>release: flask db upgrade
web: gunicorn main:app</pre><p>This <code>Procfile</code> file is for Heroku to run during the app start-up process. The first line is to ask Heroku to run <code>flask db upgrade</code> after every deployment. This is designed to ensure that our database schema is always up to date.</p><p>The second line is to have Heroku recognize it as the task that starts the webserver.</p></li>
				<li>Run <code>git add .</code> i<a id="_idTextAnchor454"/>n the Python console under PyCharm. This will add our source code to Git, for version control and deployment:<pre>$ git add .</pre></li>
				<li>Run the <code>git com<a id="_idTextAnchor455"/>mit</code> command to commit our source code. The <code>-a</code> parameter tells Git to stage files that have been modified or deleted. The <code>-m</code> parameter is for incorporating the commit message: <pre>$ git commit -am "first commit"</pre></li>
				<li>Deploy the appl<a id="_idTextAnchor456"/>ication by using <code>git push</code> to push the source code to the Heroku repository:<pre>$ git push heroku master</pre><p>Heroku will automatically set up the environment. We can see the following output:</p><div><img src="img/C15309_10_16.jpg" alt="Figure 10.16: Deploying the application to Heroku&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 10.16: Deploying the application to Heroku</h6>
			<h4>Note</h4>
			<p class="callout">During the <a id="_idTextAnchor457"/>deployment process, if we want to know more about what's happening behind the scenes, we can check the application logs by clicking the <strong class="bold">More</strong> button in the top right-hand corner, and then clicking <strong class="bold">VIEW logs</strong>.</p>
			<div><div><img src="img/C15309_10_17.jpg" alt="Figure 10.17: Deploying the application to Heroku&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 10.17: Deploying the application to Heroku</h6>
			<p>From the precedin<a id="_idTextAnchor458"/><a id="_idTextAnchor459"/>g log, we can see that after the database is upgraded, it will run Gunicorn. And finally, you can see the message <strong class="bold">State changed from starting to up</strong>.</p>
			<p>We have successfully deployed our Smilecook application to Heroku, which means it is ready to serve the public. Later, we will test it using Postman.</p>
			<h4>Note</h4>
			<p class="callout">In the future, when there is a new version, we only need to use three commands to redeploy the application. First, use <code>git add .</code> to add our source code to Git, and then use <code>git commit -am "make it better"</code>. Lastly, use <code>git push heroku master</code> to push the source code to Heroku.</p>
			<h3 id="_idParaDest-204"><a id="_idTextAnchor460"/>Exercise 69: Checking the Heroku Postgres Tables in pgAdmin</h3>
			<p>In the last exercise, we completed deployment. We will now need to check whether the tables have been created in the database. So, in this exercise, we are going to use <code>pgAdmin</code> to connect to Heroku Postgres:</p>
			<ol>
				<li value="1">Get the credentia<a id="_idTextAnchor461"/>ls of the database in Heroku Postgres, go to <strong class="bold">Add-ons</strong> &gt; <strong class="bold">Settings</strong>, then click <strong class="bold">View Credentials</strong>, and you will see the following screen:<div><img src="img/C15309_10_18.jpg" alt="Figure 10.18: Getting the credentials of the database in Heroku Postgres&#13;&#10;"/></div><h6>Figure 10.18: Getting the credentials of the database in Heroku Postgres</h6></li>
				<li>Right-click on <strong class="bold">Servers</strong> and then create a new server in pgAdmin:<div><img src="img/C15309_10_19.jpg" alt="Figure 10.19: Creating a new server in pgAdmin&#13;&#10;"/></div><h6>Figure 10.19: Creating a new server in pgAdmin</h6></li>
				<li>In the <strong class="bold">General</strong> tab, name the server <strong class="bold">Heroku</strong>:<div><img src="img/C15309_10_20.jpg" alt="Figure 10.20: Entering the name for the server in the General tab&#13;&#10;"/></div><h6>Figure 10.20: Entering the name for the server in the General tab</h6></li>
				<li>In the <strong class="bold">Connection</strong> tab, enter the credentials, including the <strong class="bold">Host name/address</strong>, <strong class="bold">Port</strong>, <strong class="bold">Maintenance database</strong>, <strong class="bold">Username</strong>, and <strong class="bold">Password</strong>, and then click <strong class="bold">Save</strong>:<div><img src="img/C15309_10_21.jpg" alt="Figure 10.21: Adding credentials to the Connection tab&#13;&#10;"/></div><h6>Figure 10.21: Adding credentials to the Connection tab</h6></li>
				<li>Now, check the database tables in pgAdmin. Go to <strong class="bold">Heroku</strong> &gt;&gt; <strong class="bold">Databases</strong> &gt;&gt; (your database name) &gt;&gt; <strong class="bold">Schemas</strong> &gt;&gt; <strong class="bold">Public</strong> &gt;&gt; <strong class="bold">Tables</strong> to verify this:<div><img src="img/C15309_10_22.jpg" alt="Figure 10.22: Checking the database tables in pgAdmin&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 10.22: Checking the database tables in pgAdmin</h6>
			<p>Now we can see whether the tables have been created in the database. If you can see that the tables have been created successfully, we can continue to the next step, which is using Postman to test our APIs.</p>
			<h2 id="_idParaDest-205">Setting Up Variables i<a id="_idTextAnchor462"/>n Postman</h2>
			<p>We have successfully deployed our project to Heroku. Now you can test them in Postman using all the saved requests that we set up before. However, the requests we have saved previously in Postman are all running against localhost. Instead of changing the URL bit by bit to the production URL, we can leverage the variables in Postman. We can set up a <code>url</code> variable and assign the production URL to it in Postman, then replace the URL with <code>{{url}}</code> from the saved request. Postman will then substitute <code>{{url}}</code> with the production URL for us dynamically.</p>
			<h3 id="_idParaDest-206">Exercise 70: Setting U<a id="_idTextAnchor463"/>p Variables in Postman</h3>
			<p>In this exercise, we will set up variables in Postman so that we can dynamically incorporate the appropriate value depending on the environment. We will set up the URL as a variable so that when we are testing in the development environment, we simply need to change the URL variable to <code>http://localhost:5000</code>. And if we are testing in a production environment, we can change that to <code>https://your_heroku_app.herokuapp.com</code>: </p>
			<ol>
				<li value="1">Click <code>Smilecook</code> as the environment name. Then, create a <code>url</code> variable with the value <code>https://your_heroku_app.herokuapp.com</code>. If the current value is not set, it will automatically assume the initial value. Please replace <code>your_heroku_app</code> with the name of your Heroku app, and then click <strong class="bold">Update</strong>:<div><img src="img/C15309_10_23.jpg" alt="Figure 10.23: Adding an environment variable in Postman&#13;&#10;"/></div><h6>Figure 10.23: Adding an environment variable in Postman</h6></li>
				<li>Once it is added, verif<a id="_idTextAnchor465"/>y the variable by clicking on the eye icon in the top right-hand corner:<div><img src="img/C15309_10_24.jpg" alt="Figure 10.24: Verifying the environment variable in Postman&#13;&#10;"/></div><h6>Figure 10.24: Verifying the environment variable in Postman</h6></li>
				<li>In the <code>UserList</code> request,<a id="_idTextAnchor466"/> update the URL to <code>{{url}}/users</code> and then click <code>https://your_heroku_app.herokuapp.com/users</code> when the request is sent):<div><img src="img/C15309_10_25.jpg" alt="Figure 10.25: Using an environment variable in the URL&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 10.25: Using an environment variable in the URL</h6>
			<p>Postman is a very powerful testing tool. It can even allow us to effectively test our API endpoints on different environments. In the future, if you want to test other API endpoints in the production environment, you just need to change the URL in the previously saved requests. In the next activity, we will test your knowledge of this.</p>
			<h3 id="_idParaDest-207">Activity 18: Changing acc<a id="_idTextAnchor467"/>ess_token to a Variable in Postman</h3>
			<p>In the previous exercise, you learned how to change a URL to a variable. In this activity, we would like you to do the same for <code>access_token</code>:</p>
			<ol>
				<li value="1">Get an access token by using the previously saved <strong class="bold">POST Token</strong> request.</li>
				<li>Add <code>access_token</code> as a variable in Postman.</li>
				<li>Test a Smilecook API endpoint that requires the access token.<h4>Note</h4><p class="callout">The solution to this activity can be found on page 345.</p></li>
			</ol>
			<p>That's great. When you are done with this activity, that means that you have already deployed and tested the Smilecook API in production. This is the final activity in the book and we are glad that you made it to this point!</p>
			<p>Now, we will setup the Smilecook frontend website, which will work with the APIs that you have just developed. </p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor468"/>Setting up the Front-end Interface to Work with the Smilecook API</h2>
			<p>Please download the <code>smilecook-vuejs</code> folder, which contains the frontend website source code, from <a href="https://github.com/TrainingByPackt/Python-API-Development-Fundamentals/tree/master/Lesson10/Frontend">https://github.com/TrainingByPackt/Python-API-Development-Fundamentals/tree/master/Lesson10/Frontend</a>:</p>
			<ol>
				<li value="1"><a id="_idTextAnchor469"/>Crea<a id="_idTextAnchor470"/>te a new app in the Heroku platform, which is for deploying our frontend web interface: <div><img src="img/C15309_10_26.jpg" alt="Figure 10.26: Creating a new app in Heroku platform&#13;&#10;"/></div><h6>Figure 10.26: Creating a new app in the Heroku platform</h6></li>
				<li>O<a id="_idTextAnchor471"/>nce the app is created, we go to the <strong class="bold">Settings</strong> tab and then <strong class="bold">Config Vars</strong>. Here, we are going to set up an environment variable, which will be used to store the backend API URL:<div><img src="img/C15309_10_27.jpg" alt="Figure 10.27: Setting up an environment variable&#13;&#10;"/></div><h6>Figure 10.27: Setting up an environment variable</h6></li>
				<li>Set the variable name to be <code>VUE_APP_API_URL</code>, and insert the backend Smilecook API URL here.</li>
				<li>Op<a id="_idTextAnchor472"/>en the <code>smilecook-vuejs</code> project in PyCharm.</li>
				<li>In<a id="_idTextAnchor473"/> the PyCharm console, type in the following command to log in to the Heroku CLI:<pre>$ heroku login</pre></li>
				<li>Then, initialize <code>git</code> and add the Heroku repository to the <code>git:remote</code> repository:<pre>$ git init
$ heroku git:remote -a your_heroku_app_name</pre></li>
				<li>Then, add the source code to <code>git</code>, commit, and push them to Heroku.<pre>$ git add .
$ git commit -am "make it better"
$ git push heroku master</pre></li>
				<li>When deployment is complete, you should see the following message on screen:<pre>remote: -----&gt; Compressing...
remote:        Done: 30M
remote: -----&gt; Launching...
remote:        Released v1
remote:        https://your_heroku_app_name.herokuapp.com/ deployed to Heroku
remote: 
remote: Verifying deploy... done.
To https://git.heroku.com/your_heroku_app_name.git
   59c4f7f..57c0642  master -&gt; master</pre></li>
				<li>Ty<a id="_idTextAnchor474"/>pe <code>https://your_heroku_app_name.herokuapp.com/</code> in the browser; we can see that the frontend interface has been set up successfully:<div><img src="img/C15309_10_28.jpg" alt="Figure 10.28: Successful frontend setup&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 10.28: Successful frontend setup</h6>
			<p>Now, you can interact with the Smilecook API using this frontend website interface.</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor475"/>Summary</h2>
			<p>In this chapter, we successfully deployed the Smilecook API to the Heroku cloud server. The deployment process is simple as we are leveraging the service provided by Heroku. We do not need to worry about purchasing hardware, setting up the server OS, connecting the server to the internet, and so on. Everything is provided by Heroku. A cloud platform service can quickly help developers to deploy their applications/APIs to the internet. This easy deployment process allows developers to focus on development and not the infrastructure/platform setup. And once the API is deployed, millions of users on the internet can connect to the API through their client-side app.</p>
			<p>Of course, Heroku is just one of the many cloud services available out there. As to which cloud service should be chosen, you should consider important factors such as cost, additional services provided, and the scale of our application. We do not limit you to a particular platform. In fact, we hope that this book is a starting point for your journey as a professional developer. With the fundamental knowledge that you have learned, you should be able to explore and further develop new skills and use new tools to build more advanced APIs.</p>
			<p>Congratulations! We have completed the whole book. Not only have you learned what an API is, but you have also developed and deployed a real-life API service, Smilecook, yourself. Throughout the entire book, you have learned about setting up a development environment, building an API, interacting with a database, object serialization, security tokens, interacting with third-party APIs, caching, and finally deployment. We have covered many different topics horizontally, and we have also explored each topic in-depth vertically. Apart from learning the theory, you have also practiced actual coding in the exercises and activities. You also tested your work thoroughly.</p>
			<p>Your next steps should involve continuing to learn by working on development projects. The most important thing is to have hands-on development experience, together with an inquiring mind. Look for a better solution whenever you encounter a problem. You should not be satisfied with just getting things done. Instead, you should aim at doing things right. That's what will take you to the next level.</p>
			<p>We hope you enjoyed the learning journey with us. Thank you!</p>
		</div>
	</body></html>